<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>A Straightforward Framework For Video Retrieval Using CLIP</title>
    <url>/2021/04/20/A-Straightforward-Framework-For-Video-Retrieval-Using-CLIP/</url>
    <content><![CDATA[<p><a href="https://github.com/Deferf/CLIP_Video_Representation" target="_blank" rel="noopener">code</a></p>
<h2 id="本文的任务"><a href="#本文的任务" class="headerlink" title="本文的任务"></a>本文的任务</h2><p>Zero-shot Video-Text Retrieval</p>
<h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><p>CLIP model 是用互联网上<strong>大规模</strong>的image-text pairs 训练出来的一个多模态检索模型，其在 image text 检索上获得了非常优异的性能，且适合于zero-shot 的场景。</p>
<p>在本文中，作者尝试使用clip model 来处理 video-text pair, 并且仍然以  <strong style="color:red;">zero-shot</strong> 的方式。</p>
<ul>
<li>使用clip的 image encoder 来 获取frame feature, 然后使用 平均聚合，获取video-level feature.</li>
<li><p>使用 clip 的 text encoder 来获取 text feature。</p>
</li>
<li><p>使用cosine similarity 来计算 video-text sim</p>
</li>
</ul>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>TVR: Text Video Retrieval</p>
<p>VTR: Video Text Retrieval</p>
<h3 id="MSR-VTT"><a href="#MSR-VTT" class="headerlink" title="MSR-VTT"></a>MSR-VTT</h3><p><img src="https://i.loli.net/2021/04/23/pKQ6Y8msudJSgah.png" alt="image-20210423101035581" style="zoom: 67%;"></p>
<h3 id="MSVD"><a href="#MSVD" class="headerlink" title="MSVD"></a>MSVD</h3><p><img src="https://i.loli.net/2021/04/23/3jQUnoyTuNWBvPs.png" alt="image-20210423101137713" style="zoom:67%;"></p>
<h3 id="LSMDC"><a href="#LSMDC" class="headerlink" title="LSMDC"></a>LSMDC</h3><p><img src="https://i.loli.net/2021/04/23/bhjOL9yDcdunm7W.png" alt="image-20210423101208808" style="zoom:67%;"></p>
<h2 id="others"><a href="#others" class="headerlink" title="others"></a>others</h2><p>本文也探索了其他两种时域聚合的方式，但是不如取平均的方式好。</p>
<ul>
<li>（1） Follow【1】。将视频提取帧之后，取第30帧。由于视频每秒大约有30帧，所以，相当于取第一秒的最后一针。</li>
<li>（2）Follow【2】。使用 K-means， 获取K个video embedding , 计算每个embedding 与 text embedding 之间的相似度 and <strong>register each query’s minimum rank,</strong></li>
</ul>
<p>在MSR-VTT 验证集上的1000个视频-文本对上进行了实验：</p>
<p><img src="https://i.loli.net/2021/04/23/ZSOYgE2zj7nHpeI.png" alt="image-20210423100745024" style="zoom:67%;"></p>
<p>值得注意的是，在K-means方法中，结果之间没有明显的差异。 这可能是因为MSR视频的长度不超过32秒，这可能不足以在创建聚类时区分中心点。<strong style="color:red;">（<strong>yaya: 可能K-means 这种方法更加适合long-term video</strong>）</strong></p>
<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>本文虽然创新性，没有那么强，但是在<strong>性能上是非常可观</strong>的。而且采取的是 <strong>Zero-Shot</strong> 的方式。</li>
<li>这种zero-shot 的方式，就可以应用到很多需要泛化性的地方。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><p>但是本文只是在这几个数据集上进行了测试，在其他的数据集上的性能还不可知，例如，在long-term videos 上的性能如何呢？</p>
</li>
<li><p>因为CLIP是在英文的句子上进行预训练的，当前测试的数据集仅仅是 english text，那么对于Chinese text效果如何呢？</p>
</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>本文的视频是直接解帧，然后对所有的帧进行时域聚合（平均池化）？这样的采样，是不是比较密集，且是不是含有冗余？？</li>
</ul>
]]></content>
      <categories>
        <category>cross-modal</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
      </tags>
  </entry>
  <entry>
    <title>A Survey of Evaluation Metrics Used for NLG Systems</title>
    <url>/2020/08/28/A-Survey-of-Evaluation-Metrics-Used-for-NLG-Systems/</url>
    <content><![CDATA[<h3 id><a href="#" class="headerlink" title=" "></a> </h3><h3 id="Recommendations-Possible-future-research-directions"><a href="#Recommendations-Possible-future-research-directions" class="headerlink" title="Recommendations (Possible future research directions)"></a>Recommendations (Possible future research directions)</h3><ul>
<li><p><strong style="color:blue;">为所有的评估指标构建一个通用的工具包</strong></p>
</li>
<li><p><strong style="color:blue;">构建一个包含 human judgments 的数据集。</strong></p>
<p>（1）human 会从不同的角度进行评估</p>
<p>（2）根据收集的数据，可以训练出来一个评价指标</p>
</li>
<li><p><strong style="color:blue;">提出 task-specific and context-dependent metrics</strong></p>
<p>类似于 dialog 这个任务，reference response 与 right prediction response 之间的word overlap 很小，因此，only reference dependent 的评价指标是有缺陷的，还需要结合 context 来设计评价指标</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gh954nipuej319z0k4q9z.jpg"></p>
</li>
<li><p><strong style="color:blue;">提出具有可解释性的评价指标</strong></p>
<p>当前大部分的评价指标， 对预测仅仅给出 a single score, 没有任何具体的指向。但是对于 human evaluation, 会从具体的层面，eg: fluency, adequency. coherence 来进行评价。因此 a single score 不够具有可解释性。</p>
<p>应该设计不同的评价指标，每一个评价指标，从特定的层面进行评价。</p>
</li>
<li><p><strong style="color:red;">Creating robust benchmarks for evaluating evaluation metrics </strong></p>
<p>early metrics, 例如，BLEU，METEOR 等，已经在各种各样的任务上进行了验证。</p>
<p>但是，最近新提出的评价指标还没有被 examined critically，为了实施这一研究，需要收集一个 <strong>对抗 evaluation benchmarks</strong>， <strong>这个 benchmarks可以测试这些metrics 的鲁棒性。</strong></p>
<p>举个例子：对于dialog，给定一个context， 可以收集一些 adversarially crafted responses（与 passage 有较高的 word overlap, 但实际上是不相关的，或者是不正确的）  。查看evaluation metrics 是否会对这种手工创造的对抗例子给<strong>低分</strong>，已验证其鲁棒性。</p>
<p><strong>除了这种 adversarial evaluations， 还需要研究 提出的evaluation metrics 是否有specific biases.</strong> 比如，GAN based evaluators 会在一些systems上进行训练，则其更容易对这些 systems 给高分。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
        <category>评价指标</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>A Novel Graph-based Multi-modal Fusion Encoder for Neural Machine Translation</title>
    <url>/2021/02/26/A-Novel-Graph-based-Multi-modal-Fusion-Encoder-for-Neural-Machine-Translation/</url>
    <content><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul>
<li>当前主流的multi-modal NMT models 不能充分利用不同模态语义单元之间的<strong>细粒度的语义对应。</strong></li>
<li>在本文中，提出了一个新颖的graph-based  cross-modal fusion encoder 来处理NMT task。具体地，（1）首先使用一个 unified multi-modal graph来编码input sentence and image。这种方式可以捕获到多模态语义单元（words and visual objects）之间各种语义关系。（2）使用多个 graph-based multi-modal fusion layers 来迭代的执行语义交互，以学习node representations。（3）以上获得的contextual representations 送入decoder中。</li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul>
<li><p>该任务的重要性，有很多现实的应用：包括翻译多媒体新闻，Web产品信息和电影字幕。</p>
<blockquote>
<p>A visual attention grounding neural model for multimodal machine translation.</p>
</blockquote>
</li>
<li><p>该任务对于提高机器翻译的准确性有作用：视觉环境有助于解决歧义的多义词。</p>
<blockquote>
<p>Distilling translations with visual awareness.</p>
</blockquote>
</li>
</ul>
<p>很显然，再在 multi-modal NMT 中，如何有效的利用视觉信息是一个核心的问题。</p>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p><img src="https://i.loli.net/2021/02/26/7IOXHm89QM5DNq4.png" alt="Untitled"></p>
<h3 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h3><ul>
<li><p>Multi-modal Graph</p>
<p><img src="https://i.loli.net/2021/02/26/w1vmXMebCR3Kt5y.png" alt="Untitled3"></p>
<ul>
<li><p>所有的单词都作为 textual nodes。使用Stanford parser来找到文本中的所有名词，然后使用 visual grounding tookit来检测 bbox，并作为visual nodes。</p>
<blockquote>
<p>visual grounding tookit: <strong>A fast and accurate one-stage approach to visual grounding</strong></p>
</blockquote>
</li>
<li><p>在 multi-modal graph中使用了两种类型的edges。<strong>intra-modal edge(fully-connected)</strong> and <strong>inter-modal edge(partly-connected)</strong></p>
</li>
</ul>
</li>
<li><p>Embedding Layer</p>
<ul>
<li>Before inputting the multi-modal graph into the stacked fusion layers，首先获得其初始特征。</li>
<li>对于textual modes， 使用word embedding 和 position embedding 的求和。</li>
<li>对于visual nodes，使用Faster-RCNN提取 roi pooling layer 的特征，然后使用MLP + RELU 将视觉特征映射到与文本特征相同的空间。</li>
</ul>
</li>
<li><p>Graph-based Multi-modal Fusion Layers</p>
<ul>
<li>On the top of embedding layer, stack multiple graph-based multimodal fusion layers to encode the above-mentioned multi-modal graph.</li>
<li>在每个融合层，序列地实施模态内和模态间的融合，来更新所有的节点状态。这种方式，可以使得最终的节点状态能够同时编码到相同模态和跨模态的语义信息。</li>
<li>由于视觉节点和文本节点是包含了不同模态信息的两种语义单元。因此，使用相同的操作，但是不同的参数（不共享）来更新它们的节点状态。</li>
</ul>
</li>
</ul>
<h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><ul>
<li><p>Our decoder is similar to the conventional Transformer decoder。堆叠多个相同的层来生成 target-side hidden states，每一层由三个子层组成。</p>
<p>前两个子层是一个masked self-attention 和 一个encoder-decoder attention 来分别聚合target-side and source-side contexts。</p>
<p>最后由a position-wise fully-connected forward neural network 和 线性变化来生成next-step predict word。</p>
</li>
</ul>
<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><ul>
<li>与本文类似的模型结构有以下两篇</li>
</ul>
<blockquote>
<p>Multi-Modality Cross Attention Network for Image and Sentence Matching</p>
<p>(LXMERT) LXMERT Learning Cross-Modality Encoder Representations from Transformers</p>
</blockquote>
]]></content>
      <categories>
        <category>cross-modal</category>
        <category>image-guided MT</category>
      </categories>
      <tags>
        <tag>cross-modal,image-guided MT</tag>
      </tags>
  </entry>
  <entry>
    <title>A negative case analysis of visual grounding methods for VQA</title>
    <url>/2020/04/15/A-negative-case-analysis-of-visual-grounding-methods-for-VQA/</url>
    <content><![CDATA[<h4 id="yaya简述"><a href="#yaya简述" class="headerlink" title="yaya简述"></a>yaya简述</h4><p>在VQA任务中，现在的方法尝试希望模型在回答问题时，同时能够关注到相对应的正确的物体（出发点：当模型关注到正确的物体时，能够更好的帮助模型选择出正确的答案）。于是，基于这样的方式，提出了一些方法 [1] [2]. 但是本文发现即便在模型中给了vision grounding 的监督，但是模型的grounding 能力却未必很好。那么提升VQA性能的真正原因其实是这个监督，仅仅是一种正则化效果。</p>
<p>作者使用了Grounding using irrelevant cues；Grounding using fixed random cues；Grounding using variable random cues 来说明，即使是错误的监督信息，相比于正确的监督也不会使得性能下降很多。</p>
<p>作者使用Regularization by zeroing out answers  来说明，给损失函数中加一个正则化项，使得training accuracy下降，就会达到正则化的效果，其VQA的性能与用grounding 监督的效果差距也不大。这就证明了使用grounding来监督，其实仅仅是起到了正则化的效果。</p>
<h4 id="Future-work"><a href="#Future-work" class="headerlink" title="Future work"></a>Future work</h4><ul>
<li><p>未来的方法必须设法通过使用与本文中介绍的类似的实验设置来验证性能增益不是源于spurious source.</p>
</li>
<li><p>创建一个数据集，使得能够评估  if methods are able to focus on relevant information.</p>
</li>
<li>Use tasks  that explicitly test grounding, e.g., in visual query detection an agent must output boxes around any regions of a scene that match the natural language query .</li>
</ul>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>[1] Ramprasaath R Selvaraju, Stefan Lee, Yilin Shen, Hongxia Jin, Shalini Ghosh, Larry Heck, Dhruv Batra, and Devi Parikh. <strong>Taking a hint: Leveraging explanations to make vision and language models more grounded.</strong>  In ICCV 2019. </p>
<p>[2] Jialin Wu and Raymond Mooney. <strong>Self-critical reasoning for robust visual question answering.</strong> In NeurIPS 2019</p>
]]></content>
      <categories>
        <category>Visual Grounding</category>
      </categories>
      <tags>
        <tag>Visual Grounding</tag>
      </tags>
  </entry>
  <entry>
    <title>A Closer Look at the Robustness of Vision-and-Language Pre-trained Models</title>
    <url>/2021/02/24/A-Closer-Look-at-the-Robustness-of-Vision-and-Language-Pre-trained-Models/</url>
    <content><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>大规模的预训练多模态transformer将最新的视觉-语言任务推进到了一个新的高度。虽然在标准任务上实现了令人印象深刻的性能，但是，迄今为止，任然不清楚这些预训练模型的鲁棒性。</p>
<p>为了进行调查，我们针对现有的预训练模型对4种不同类型的V + L特定模型的鲁棒性进行了全面的评估：(i) Linguistic Variation; (ii) Logical Reasoning; (iii) Visual Content Manipulation; and (iv) Answer Distribution Shift. 有趣的是，by standard model finetuning，预训练的V+L模型相比于task-specific 模型展示出更好的鲁棒性。</p>
<p>为了<strong>进一步增强模型的鲁棒性</strong>，本文提出了<strong>MANGO</strong>，一个具有泛化性且鲁棒的方法，可以在embedding space 学习a Multimodal Adversarial Noise GeneratOr 以愚弄pre-trained V+L models。与以往针对一种特定类型的鲁棒性的研究不同，MANGO具有任务不可知性，并且可以针对各种任务（旨在评估鲁棒性的广泛方面）对预训练模型进行通用性能提升。</p>
<p> 全面的实验表明，MANGO在9个鲁棒性基准中有7个达到了最新水平，大大超过了现有方法。</p>
<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p>当前的 V+L pre-tranining model取得了很大的进展在各种 V+L tasks，但是这些benchmark 在测试集和数据集上的分布常常是相似的，textual query 几乎没有 linguistic variation, 使用干净的自然图像，而没有任何visual content manipulation。 因此，尽管这些标准基准对于通用模型评估有效，但仍<strong>缺乏明确评估模型鲁棒性的能力</strong>。（在本文中，我们不关注 adversarial robustness，<strong style="color:red;">因为目前没有可用的adversarial benchmark</strong>。因此，我们在已有的robustness benchmark上进行观测，这些benchmark 设有挑战性的设置，并且经过了人类的验证）</p>
<p>(i) VQA-Rephrasings[56] for <strong>linguistic variation</strong>;</p>
<p>(ii) VQA-LOL (Compose and Supplement) [18], VQA-Introspect [54] and GQA [25] for <strong>logical reasoning</strong>; </p>
<p>(iii) IV-VQA and CVVQA [2] for <strong>visual content manipulation</strong>;  </p>
<p>(iv) VQA-CP v2 [3] and GQA-OOD [31] for <strong>answer distribution shift</strong>.</p>
<h3 id="当前方法存在的问题"><a href="#当前方法存在的问题" class="headerlink" title="当前方法存在的问题"></a>当前方法存在的问题</h3><p>VILLA，在multimodal embedding 加入对抗扰动，<strong>projected gradient descent（PGD） attack training（AT）</strong> 可以在 linguistic variation and visual content manipulation 增强鲁棒性，但是在训练集和测试集之间有显著的数据分布差异时，会有收效甚微的影响甚至drop model performence。</p>
<h3 id="本文方法简介"><a href="#本文方法简介" class="headerlink" title="本文方法简介"></a>本文方法简介</h3><p>为了在所有方面都实现鲁棒性，本文提出了 MANGO，通过在multi-modal embedding space 引入adversarial noise来增强鲁棒性。</p>
<p><img src="https://i.loli.net/2021/02/24/yDSgc5JwWFHCU8h.png" alt="image-20210224120151245"></p>
<p>如图 figure 1a所示，不使用PGD来生成对抗扰动，而是使用一个基于可训练神经网络来学习一个adversarial noise generator。与 VILLA相同，在embedding space 加入扰动，因为本文的目标 是对抗训练的最终结果，而不是制造对抗样本。</p>
<p>【1】本文要学习的是一个 universial noise generator，但是在VILLA中使用的PGD方法是针对每个特定样本来生成的，本文提出的noise generator 是通用的，对输入训练样本是不加区别的。【2】而PGD的方法是<strong>耗时</strong>的，而本文提出的方法是轻量级的，不需要梯度计算中的重复迭代。同时，为了使能多样性的对抗embedding，本文进一步提出随机对image regions 和 textual tokens掩码。</p>
<h3 id="本文的贡献"><a href="#本文的贡献" class="headerlink" title="本文的贡献"></a>本文的贡献</h3><ul>
<li>第一个系统性的分析pre-trained V+L 模型的鲁棒性</li>
<li>提出了 MANGO，一个generic and efficient 对抗训练方法来增强 V+L model 鲁棒性</li>
<li>实验结果证明了本文提出方法的鲁棒性。</li>
</ul>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><h4 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h4><p>Perturbing clean images with Gaussian noise. we use Gaussian noise augmentation as a simple baseline to investigate model robustness under V+L setting. Instead of adding noise to raw image pixels as in [52], we add perturbations directly to the embeddings.</p>
<h4 id="Adversarial-Noise-Generator-our"><a href="#Adversarial-Noise-Generator-our" class="headerlink" title="Adversarial Noise Generator (our)"></a><strong>Adversarial Noise Generator</strong> (our)</h4><p>Adding Gaussian noise to clean image-text pairs 可以补充训练样本。但是，随着训练的持续，模型可以逐渐的适应这种扰动，因为扰动都是从同一个 Gaussian noise distribution 中采样来的。</p>
<p>为了得到 harder perturbations，本文提出了一个可学习的 adversarial noise generator。对抗性噪声发生器将高斯噪声样本作为输入，通过可学习神经网络产生对抗性噪声样本。</p>
<p>Intuitively, to maximally fool the backbone network, 【1】we want to <strong>maximize prediction errors on these adversarially perturbed samples.</strong> 【2】In the meantime, we want the model to possess <strong>less confidence in its predictions on perturbed samples</strong> than clean samples, to promote harder adversarial examples。因此，<strong>adversarial noise generator 的目标是</strong>最大化这两个损失的求和：【1】task-speficic loss 【2】KL loss, which measures the distance between the predicted answer distribution of perturbed samples and that of clean samples.</p>
<p>另一方面，the trained model 旨在通过将对抗性生成的嵌入作为数据增强来最大程度地减少这两种损失。</p>
<p>综合上述两种方面，提出了如下的min-max game:</p>
<script type="math/tex; mode=display">
\min _{\boldsymbol{\theta}} \max _{\boldsymbol{\phi}_{v}(\boldsymbol{v}, \boldsymbol{w}, \boldsymbol{y}) \sim \mathcal{D} \boldsymbol{\alpha} \in \mathcal{N}(\mathbf{0}, \mathbf{1})} \mathbb{E}\left[\mathcal{L}_{s t d}\left(\boldsymbol{\theta}, \boldsymbol{\phi}_{v}\right)+\beta \mathcal{R}_{k l}\left(\boldsymbol{\theta}, \boldsymbol{\phi}_{v}\right)\right]</script><p>where $\beta$ is a hyper-parameter, and</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\mathcal{L}_{s t d}\left(\boldsymbol{\theta}, \boldsymbol{\phi}_{v}\right)=\mathcal{L}_{\mathrm{BCE}}\left(f_{\boldsymbol{\theta}}\left(\boldsymbol{v}+g_{\boldsymbol{\phi}_{v}}(\boldsymbol{\alpha}), \boldsymbol{w}\right), \boldsymbol{y}\right) \\
\mathcal{R}_{k l}\left(\boldsymbol{\theta}, \boldsymbol{\phi}_{v}\right)=\mathcal{L}_{k l}\left(f_{\boldsymbol{\theta}}\left(\boldsymbol{v}+g_{\phi_{v}}(\boldsymbol{\alpha}), \boldsymbol{w}\right), f_{\boldsymbol{\theta}}(\boldsymbol{v}, \boldsymbol{w})\right)
\end{array}</script><p>在训练时，迭代跟新 an outer loop of the backbone network and an inner loop of noise generator.</p>
<p>本文提出的adversarial noise generator 是轻量级的，仅仅存在 a few linear layers。相比于一个深层模型，这种轻量模型更容易陷入局部最优。因此，定期地，we replace the learned noise generator with a new one trained from scratch。每次，new  generator is trained against the latese learned parameters of the backbone.</p>
<h4 id="Random-Masking"><a href="#Random-Masking" class="headerlink" title="Random Masking"></a>Random Masking</h4><p>虽然 adversarial noise generator 可以产生具有挑战性，更加多样化的噪声扰动，但是不会改变训练样本的内在统计（例如，问题长度和image regions的分布）。然而，实际上，在robustness benchmark 的训练和测试集中存在这种 significant mismatch。比如，the average length of questions in VQA-LOL 测试集是VQA V2 训练集的 2-3倍。</p>
<p>为了补偿这种统计上的不匹配，我们建议在向图像和单词嵌入中添加对抗性噪声时，<strong>随机掩盖图像区域</strong> and <strong>随机插入[MASK]令牌</strong>。</p>
<h3 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h3><p>进行实验分析了 pre-trained V+L model 的鲁棒性和 本文提出的MANGO framework 的有效性。本文使用UNITER作为 backbone，并将 MANGO与 UNITER和 VILLA 在9个 robustness datasets + VQA v2 dataset上进行了比较。本文在这10个 benchmark上进行研究，<strong style="color:red;"><strong>因为目前在其他任务上没有这种 robustness dataset。</strong></strong></p>
<p>VILLA 在预训练阶段和微调阶段都采用了 对抗训练，而本文只是在微调阶段（即针对特定任务）</p>
<p><img src="https://i.loli.net/2021/02/25/HwjDn2voZfWKFOk.png" alt="image-20210225095811994"></p>
<h3 id="Future-Work"><a href="#Future-Work" class="headerlink" title="Future Work"></a>Future Work</h3><p>investigate the adversarial robustness of pre-trained V+L models.</p>
<p>（在本文中，我们不关注 adversarial robustness，<strong style="color:red;">因为目前没有可用的adversarial benchmark</strong>。因此，我们在已有的robustness benchmark上进行观测，这些benchmark 设有挑战性的设置，并且经过了人类的验证）</p>
]]></content>
      <categories>
        <category>cross-modal</category>
        <category>对抗</category>
      </categories>
      <tags>
        <tag>cross-modal,对抗</tag>
      </tags>
  </entry>
  <entry>
    <title>(ACL 2019)Putting Evaluation in Context: Contextual Embeddings improve Machine Translation Evaluation</title>
    <url>/2020/04/01/ACL-2019-Putting-Evaluation-in-Context-Contextual-Embeddings-improve-Machine-Translation-Evaluation/</url>
    <content><![CDATA[<ul>
<li><p>没有认真阅读本篇文章，但是其中提到了尝试去拟合Human judgements，这一训练方案。</p>
<p> （1）We treat the human reference translation and the MT output as the premise and hypothesis, respectively 。</p>
<p>（2）Using squared error as part of regression loss – being better suited to Pearson’s r — and might be resolved through a different loss. Using hinge loss over pairwise preferences which would better reflect Kendall’s Tau</p>
</li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Adaptive Offline Quintuplet Loss for Image-Text Matching</title>
    <url>/2021/02/21/Adaptive-Offline-Quintuplet-Loss-for-Image-Text-Matching/</url>
    <content><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>现有的image-text matching 的方法一般使用<strong>在线</strong>负样本和三元组损失来训练模型。对于mini-batch中的 image 或 text anchor, 模型被训练以希望区分与anchor 相对应的 positive sample 和 most confusing negative sample。这种策略能够提高模型区分image 和 text 之间细粒度的对应或者是不对应。</p>
<p>但是，这种方法存在几个缺陷。（1）负样本的选择策略，给模型提供了较少的机会：从<strong>很难区分的样本</strong>中学习。（2）训练的模型从训练集到测试集的泛化性较差。（3）The penalty lacks hierarchy and adaptiveness for hard negatives with different “hardness” degrees。</p>
<p>在本文中，（1）我们提出了一个从整个训练集中采样 <strong>negative offline samples</strong> 的解决方法。这种方法，提供了 “harder” offline negatives than online hard negatives 让模型来区分。（2）基于 <strong>the offline hard negatives,</strong> 一个五元组损失被提出来，以提高模型的泛化性。（3）另外，提出了一个新颖的损失函数来结合 <strong>the knowledge of</strong> positives, online hard negatives and online hard negatives.</p>
<p>由于本文提出的方法，不是创建了一个新颖的模型，而是在采集样本与损失函数上做的改进，因此，本文在三个最好的模型上添加了本文提出的模块，并报告了实验结果，证明了本文提出方法的有效性。</p>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><ul>
<li>本文使用了<strong>两轮训练</strong>来增加<strong>offline “harder” negatives</strong>。在第一轮，本文使用原始的 online triple loss来训练matching model。 然后，使用训练好的模型，对于训练集中的 image or text anchor，模型预测它们与训练中的负样本的相似性分数，并对这些负样本进行排序。在第二轮，对于mini-batch 中的每个anchor，本文从 top negative list中采取采样offline negatives. 在这个过程中，多种offline hard negative pairs被构建，这些负样本与anchor之间共享或者不共享common elements。</li>
<li>进一步地，本文修改了损失函数，将offline hard negative pairs的信息融合到 online triplet loss中。The complete training loss实现了对(positive pairs， offline hard negatives、online hard negatives)  <strong>分等级</strong>和<strong>自适应</strong>的惩罚，</li>
</ul>
]]></content>
      <categories>
        <category>cross-modal</category>
        <category>Image-Text Matching</category>
      </categories>
      <tags>
        <tag>cross-modal,Image-Text Matching</tag>
      </tags>
  </entry>
  <entry>
    <title>Aligning Visual Regions and Textual Concepts for Semantic-Grounded Image Representations</title>
    <url>/2020/07/31/Aligning-Visual-Regions-and-Textual-Concepts-for-Semantic-Grounded-Image-Representations/</url>
    <content><![CDATA[<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p>Understanding the image, which necessitates the acquisition of grounded image representations. </p>
<p>以下，提供了几种方式来 表达image content.</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gha8v7kk80j316b0ciqmw.jpg"></p>
<p><strong style="color:blue;">[1]</strong> 基于 R-CNN 的方法可以获得 regions，但是却没有与 actual words关联起来，这将会造成两个域之间的语义不一致，并且需要由 downstream systems 自己学习 alignments。</p>
<p><strong style="color:blue;">[2]</strong> 此外，这些representations 仅包含局部特征，缺少全局结构信息。 这些问题 使system 难以有效地理解图像。</p>
<p>因此，本文提出一个 Mutual Iterative Attention (MIA) 模块，在编码阶段，从<strong style="color:red;">视觉域和语言域</strong>（解决[1]） 构建<strong style="color:red;">聚合的 image representations</strong>(解决[2])。</p>
<p>we perform mutual attention <strong style="color:blue;">iteratively </strong> between the two domains to realize the procedure <strong>without annotated alignment data.</strong> </p>
<p>The visual receptive fields gradually concentrate on salient visual regions, and the original word-level concepts are gradually merged to recapitulate corresponding visual regions. </p>
<p>In addition, the aligned visual features and textual concepts provide a more clear definition of the image aspects they represent. </p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gha9crz1pbj30de0s4jxg.jpg" style="zoom:50%;"></p>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gha9gjk5vbj31h50j3jvs.jpg"></p>
<h3 id="textual-concepts"><a href="#textual-concepts" class="headerlink" title="textual concepts"></a>textual concepts</h3><p>从下面这篇论文中提取 text concepts</p>
<blockquote>
<p> <strong>From captions to visual concepts and back.</strong> In CVPR, 2015</p>
</blockquote>
]]></content>
      <categories>
        <category>图像描述</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>Align2Ground: Weakly Supervised Phrase Grounding Guided by Image-Caption Alignment</title>
    <url>/2020/07/30/Align2Ground-Weakly-Supervised-Phrase-Grounding-Guided-by-Image-Caption-Alignment/</url>
    <content><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>本文提出使用caption-to-image retrieval 作为下游任务，来引导 phrase localization。</p>
<p>第一步，学习 RoIs 与 phrases 之间的隐式对应，并利用这些匹配的RoIs来生成具有判别性的image representation。</p>
<p>第二步，learnedd representaion 与caption 对齐。</p>
<p>本文的贡献是，构建了“caption-conditioned” image encodinng，这件所有的任务都耦合在一起，并使得弱监督可以有效的引导 visual grounding。</p>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><ul>
<li>监督学习的方法：依赖 region-phrase correspondence 数据。</li>
<li>弱监督：grounding free-form textual phrase，从image-caption pairs 这种weak correspondence中进行学习。</li>
</ul>
<p><strong>weakly supervised paradigm 的一个关键是，紧密耦合监督学习任务（image-caption matching）和无法获得显示标签的任务（region-phrase matching）。联合推理确保前者的监督损失可以有效的引导后者的学习。</strong></p>
<blockquote>
<p>[1] Andrej Karpathy and Li Fei-Fei. <strong>Deep visual-semantic alignments for generating image descriptions.</strong> In CVPR, 2015</p>
<p>[2] AndrejKarpathy,ArmandJoulin,andLiFFei-Fei. <strong>Deep fragment embeddings for bidirectional image sentence mapping.</strong> In NIPS,  2014</p>
</blockquote>
<p>[ 1 ] [ 2 ] 采用了 such paradigm，一般地，这种模型存在两个阶段：（1）local matching mudule: 得到 region-phrase 的隐式对应，进而生成local matching information.（2）gobal matching module: 使用（1）中得到的information来得到 image-caption matching.</p>
<p>需要注意的是，这种方案的设计，primary objective 是 image-caption matching 而不是 phrase matching。这种训练方式，将会放大selective regions 和 phrases 之间的相关性。举例说明：如果 第一阶段中，a small subset of phrases 存在很强的 match, 那么将会传递到第二阶段，<strong>via average pooling of the RoI–phrase matching scores</strong>, 使得image 和 caption 之间存在 high matching score。</p>
<p>这将会<strong>使得模型不去学习 准确的ground <strong style="color:red;">所有的</strong> phrases</strong>。分析可得，将visual grounding 作为 primary aim 不是一个有效的解决办法。<strong>这种“作弊”倾向，使模型学会了在下游任务上做得很好而不必在中间任务上做得更好。</strong></p>
<p>本文将这种现象称之为：“selective amplification” behavior</p>
<p>本文解决这个问题：我们通过提出一种novel mechanism 来解决这一问题，该机制以使两个阶段之间更紧密耦合的方式 to relay this information about the latent, inferred correspondences</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gh8vyf8slej30wt0q914q.jpg" style="zoom: 50%;"></p>
<p>Our novelty lies in designing this effective transfer of  information between the supervised and unsupervised parts  of the model such that the quality of image representations for the supervised matching task is a direct consequence of  <strong>the correct localization of all phrases.</strong> </p>
<h3 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a>Approach</h3><p>our proposed model uses a novel technique that builds a discriminative image representation from the matched RoIs and uses this representation for the image-caption matching. </p>
<p>Specifically, the image representation that is used to match an image with a caption is conditioned only on <strong style="color:red;">the subset of image regions</strong> that align semantically with <strong style="color:red;">all the phrases</strong> in that caption. </p>
<p>本文认为，与标准的 pooling-based method 相比，这种结构的设计使图像字幕对的监督，成为 visual grounding 的更强学习信号。</p>
<h4 id="The-Local-Matching-module"><a href="#The-Local-Matching-module" class="headerlink" title="The Local Matching module"></a>The Local Matching module</h4><p>将 region 和 phrase 映射到相同的空间，然后计算 cosine similarity。</p>
<p>infer the matched RoI for a phrase最直接的方法是 选择top scoring box，但是，这种方案容易<strong>过拟合</strong>，因为模型经常持续选择 相同的错误region。</p>
<p>改进：使用attened region vector 作为matched RoI，虽然这种方法在其他的多模态任务中是有效的，但在这个任务中不是一个有效的方法。这是因为在训练过程中，多个匹配的RoI的加权平均似乎会损害匹配的RoI的辨别力（discriminativeness）。</p>
<p>再次改进：选择 top-k (k=3) scoring RoI candidates，然后随机的选择其中的一个作为 query phrase 的 匹配 RoI。这种策略通过在巡林过程中探索多样性的选择，进而可以增加鲁棒性。</p>
<h4 id="The-Local-Aggregator-module"><a href="#The-Local-Aggregator-module" class="headerlink" title="The Local Aggregator module"></a>The Local Aggregator module</h4><p>这个模块的设计比较玄学。说是为了generate a caption-conditioned representation of the image.</p>
<p>设计的模块：a two-layer Multilayer Perceptron (MLP) with a mean operation. </p>
<p>这个模块的输入，是从上一步中得到的 matched RoIs for correspondance phrases.</p>
<h4 id="The-Global-Matching-module"><a href="#The-Global-Matching-module" class="headerlink" title="The Global Matching module"></a>The Global Matching module</h4><p>将 caption 映射到与 上一步中得到  representation of the image 相同的空间，然后利用 cosine similarity</p>
<h4 id="Loss-Function"><a href="#Loss-Function" class="headerlink" title="Loss Function"></a>Loss Function</h4><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gh939pfhcgj30tq040wen.jpg" style="zoom:33%;"></p>
<h3 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h3><p>motivation 挺好的 ，但是local aggregator 的设计比较朴素。</p>
]]></content>
      <categories>
        <category>Visual Grounding</category>
      </categories>
      <tags>
        <tag>Visual Grounding</tag>
      </tags>
  </entry>
  <entry>
    <title>[All NLP Tasks Are Generation Tasks] A General Pretraining Framework</title>
    <url>/2021/03/20/All-NLP-Tasks-Are-Generation-Tasks-A-General-Pretraining-Framework/</url>
    <content><![CDATA[<h2 id="yaya-总结"><a href="#yaya-总结" class="headerlink" title="yaya 总结"></a>yaya 总结</h2><ul>
<li><p>模型结构上</p>
<p><strong style="color:red;">GLM 采用的是Transformer Model 中decoder 结构，而BERT采用的是 encoder 结构</strong></p>
</li>
<li><p>预训练任务上：<br>提出了两个 multi short span recover (benefit for NLU) and  a single longer span recover (benefit for NLG) 的预训练任务。</p>
<p>与这篇做 text filling 论文很相似：Enabling Language Models to Fill in the Blanks</p>
</li>
<li><p>下游任务的微调：</p>
<p>受到[1] [2] 的启发， 将分类任务转化为文本生成的填空任务。</p>
</li>
</ul>
<h2 id="1-存在的问题"><a href="#1-存在的问题" class="headerlink" title="1. 存在的问题"></a>1. 存在的问题</h2><p>目前基于预训练 的语言模型大致分为三类：</p>
<ul>
<li>autoregressive models (e.g.,GPT) 擅长长文本生成</li>
<li>autoencoding models (e.g., BERT) 擅长理解型任务，分类任务</li>
<li>encoder-decoder models (e.g., T5) 擅长基于条件的文本生成任务，比如 text summarize</li>
</ul>
<p>但是目前还未存在一个预训练框架可以在这三种任务上同时表现出优异的性能。这给模型的开发和选择带来了不便。</p>
<p>下表总结了不同的预训练框架可以处理的任务：</p>
<p><img src="https://i.loli.net/2021/03/20/ldKAem71a86xBcq.png" alt="image-20210320100920079" style="zoom: 25%;"></p>
<p>先前的工作试图通过多任务学习将各自的 objective 结合起来，从而统一不同的框架。但是，自回归和自编码的 objective 在本质上是不同的，简单的结合不能够充分的揭示所有框架的优势。</p>
<h2 id="2-本文的点"><a href="#2-本文的点" class="headerlink" title="2. 本文的点"></a>2. 本文的点</h2><h3 id="2-1-新颖的预训练框架GLM"><a href="#2-1-新颖的预训练框架GLM" class="headerlink" title="2.1 新颖的预训练框架GLM"></a>2.1 新颖的预训练框架GLM</h3><p>本文提出了一个新颖的预训练框架GLM（General Language Model）来解决这个问题。如图1。</p>
<p><img src="https://i.loli.net/2021/03/20/VrzfCnOFQi27NRU.png" alt="image-20210320103954828" style="zoom: 33%;"></p>
<ul>
<li>本文的预训练模型GLM基于autoregressive blank-filling（预训练方案），<strong style="color:red;">遵循自动编码(auto-encoding)的思想，我们从输入文本中随机消除了令牌的连续跨度。并遵循自回归预训练(auto-regressive)的思想训练模型以重建跨度。</strong></li>
<li>为了在一个框架中同时学习双向和单向的注意力机制，本文将文本分成两部分，未掩码的部分可以互相关注。掩码的部分不可以关注后续的掩码的token。</li>
<li>本文还提出了一个 2D位置编码技术，来指示inter- and intra- span position information。</li>
<li></li>
</ul>
<p>因此，本文的框架 GLM在预训练过程中，可以同时学习上下文表达和自回归生成。</p>
<h3 id="2-2-多任务预训练方案"><a href="#2-2-多任务预训练方案" class="headerlink" title="2.2 多任务预训练方案"></a>2.2 多任务预训练方案</h3><p>为了使本文的预训练模型更加适合文本生成任务，本文也研究了一个多任务预训练的设置：（1）采样多个short spans, 目标是重构masked spans，该预训练任务对下游NLU任务有益处（2）采样单个 longer span，目标是回复该单个spans。该预训练任务对下游NLG任务有益处。</p>
<p>这种多任务预训练方案，在理解型任务，条件生成任务和具有共享参数的语言建模任务方面均有改善。</p>
<h3 id="2-3-pretrain-finetune-consistency"><a href="#2-3-pretrain-finetune-consistency" class="headerlink" title="2.3 pretrain-finetune consistency"></a>2.3 pretrain-finetune consistency</h3><p>在下游任务微调GLM时，受到以下两篇文章[1] [2] 的启发，构建为blank-filling generation的形式。每个任务都与一个人工制作的完形填空问题相关联，并且该模型可以预测完形填空的答案。例如，情感分类任务被重新构造为一个 <strong>“[SENTENCE]. It’s really __ ”.</strong> 这种格式的填空任务。对于”good” or “bad” 的预测暗示了情感是积极地还是消极地。</p>
<p>在这种格式下，GLM 在预训练和微调的一致中受益。因为<strong style="color:blue;">预训练和微调都涉及到以给定上下文来生成文本的方式来训练模型</strong>。因此，GLM相比于BERT-like models 更适合下游分类任务。<strong style="color:red;"><strong>yaya：这里的因此，好像不能推断出来</strong></strong></p>
<h2 id="3-贡献"><a href="#3-贡献" class="headerlink" title="3. 贡献"></a>3. 贡献</h2><p>本文的结构有三个主要的优势：</p>
<ul>
<li>在一个预训练模型上，可以在三种任务上都表现的很好。</li>
<li>由于 <strong style="color:blue;">pretrain-finetune consistency</strong>，在分类任务上，本文提出的模型相比 BERT-like models 性能更加优异。</li>
<li>可以自然的处理 <strong style="color:red;">variable-length blank filling</strong>，这对很多下游任务是很重要的。</li>
</ul>
<h2 id="4-Method"><a href="#4-Method" class="headerlink" title="4. Method"></a>4. Method</h2><h3 id="4-1-Model-Architecture"><a href="#4-1-Model-Architecture" class="headerlink" title="4.1 Model Architecture"></a>4.1 Model Architecture</h3><p>本文提出的结构 GLM 与 BERT很相似。Following Megatron-LM, 对BERT的结构做了两点改动。（1）rearrange the order of layer normalization and the residual connection。（2）replace the feed-forward network for token prediction with a linear layer。</p>
<h3 id="4-2-Autoregressive-Blank-Infilling"><a href="#4-2-Autoregressive-Blank-Infilling" class="headerlink" title="4.2 Autoregressive Blank Infilling"></a>4.2 Autoregressive Blank Infilling</h3><p>通过优化 autoregressive blank infilling 任务对GLM进行训练。</p>
<p>给定 an input text $\boldsymbol{x}=\left[x_{1}, \cdots, x_{n}\right]$，多个被采样 text spans {$s_{1},…,s_{m}$} ，每个span $s_{i}$ 是一系列连续的tokens $\left[s_{i, 1}, \cdots, s_{i, l_{i}}\right]$。text spans 的数量和长度取决于预训练目标（将会在下文中被介绍）。</p>
<p>该模型以自回归的方式从损坏的文本中预测 span 中丢失的 tokens，这意味着在预测 span 中丢失的 tokens，模型可以访问损坏的文本<em>和</em>先前预测的spans。为了充分捕捉不同span之间的相互依存关系，我们随机地排列span的顺序。yaya: 以下公式中 $\boldsymbol{s}_{\boldsymbol{z}_{&lt;i}}$ 被随机排列了，并不是按照其在句子中的顺序。</p>
<p>预训练目标为：$\max _{\theta} \mathbb{E}_{\boldsymbol{z} \sim Z_{m}}\left[\sum_{i=1}^{m} \log p_{\theta}\left(\boldsymbol{s}_{z_{i}} \mid \boldsymbol{x}_{\text {corrupt }}, \boldsymbol{s}_{\boldsymbol{z}_{&lt;i}}\right)\right]$</p>
<p>该任务与SpanBERT 的区别在于 <strong>模型不知道span中丢失tokens 的数量</strong>。</p>
<p>具体来说，我们使用以下技巧实现了自动回归的空白填充任务。输入令牌分为两部分。A部分包含损坏的文本$x_{corrupt}$ ,其中采样的text span 被替换为 [MASK] 令牌。B部分由masked span 中的tokens 组成。A部分中的 tokens 可以 attend to A中的所有tokens ，但不能 attend to B中的任何tokens 。B部分中的tokens 可以 attend to A中的tokens 及其在B中的先行词，但不能attend to B中的任何后续位置。</p>
<p><strong style="color:red;">与原始Transformer 模型中的decoder 相似</strong>，span中的tokens被补充两个特殊token [START]和 [END]，以这种方式，本文提出的模型可以同时学习（1）一个双向encoder（PART A）和（2）一个单向decoder (PART B)。如下图2所示。</p>
<p><img src="https://i.loli.net/2021/03/21/i4AEV3J2psDv1aT.png" alt="image-20210321135425429"></p>
<h4 id="4-2-1-2D-Positional-Encoding"><a href="#4-2-1-2D-Positional-Encoding" class="headerlink" title="4.2.1 2D Positional Encoding"></a>4.2.1 2D Positional Encoding</h4><p>每个 token 都使用两个 position ids 进行编码。</p>
<p>第一个 position id 代表corrupted text 中的位置。对于B中的token，它是对应的[MASK] token的position。</p>
<p>第二位置id表示intra-span position。对于A中的令牌，第二个位置ID为0。对于B中的令牌，范围为1到span的长度。</p>
<p>这两个 position ids  通过两个单独的 embedding table 投影到两个位置向量中，并添加到 input embeddings 中。</p>
<h3 id="4-3-Pre-Training-Objectives"><a href="#4-3-Pre-Training-Objectives" class="headerlink" title="4.3 Pre-Training Objectives"></a>4.3 Pre-Training Objectives</h3><p>采样：the masked spans make up 15% of the original tokens.</p>
<p>span leagth:  drawn from a Poisson distribution with $\lambda$= 3</p>
<p>与其他BERT样式的模型类似，GLM 对 short spans 进行掩码，适用于NLU任务。 但是，我们对单个预训练模型可以同时处理NLU和text generation 感兴趣。</p>
<p>我们进一步研究了<em>多任务预训练</em>设置，第二个目标：生成更长文本。并与GLM联合优化。具体来说，我们采样了a single span 覆盖原始文本长度的50％–100％。跨度长度是从均匀分布中采样的。以与原始目标相同的方式定义新目标。唯一的区别是只有一个跨度，但跨度更长。</p>
<h3 id="4-4-Finetuning-GLM"><a href="#4-4-Finetuning-GLM" class="headerlink" title="4.4 Finetuning GLM"></a>4.4 Finetuning GLM</h3><h4 id="NLU-task"><a href="#NLU-task" class="headerlink" title="NLU task"></a>NLU task</h4><p><strong>对于NLU 任务，以前的PLMs 存在预训练-微调目标不一致的问题</strong>， 具体解释如下：</p>
<p>先前的方法处理NLU任务，通常采用将预训练模型得到的representation送入一个线性分类层中来预测答案。对于token classification: 使用 token representation；对于 sentence classification：使用 [CLS] token representation。但是对于预训练任务采用的是cloze filling task 。这就导致了预训练-微调目标不一致的问题。</p>
<p>本文中，将NLU中的分类任务定义为 blank filling task。</p>
<p>给定一个标注样本（$x$, y），经由一个包含了 single mask token 的 pattern。</p>
<p>将输入文本 $x$ 映射成一个 cloze question $c(x)$ 。情感分类任务被重新构造为一个 <strong>“[SENTENCE]. It’s really [MASK] ”.</strong>  </p>
<p>标签 $y$ 也映射为填空问题的答案，称为 verbalizer $v(y)$ 。在情感分类任务中消极和积极被映射到单词“好”或“坏”。</p>
<p>Therefore, the conditional probability of $y$ given $\boldsymbol{x}$ is</p>
<script type="math/tex; mode=display">
p(y \mid \boldsymbol{x})=\frac{p(v(y) \mid c(\boldsymbol{x}))}{\sum_{y^{\prime} \in \mathcal{Y}} p\left(v\left(y^{\prime}\right) \mid c(\boldsymbol{x})\right)}</script><p>where $\mathcal{Y}$ is the label set. Then we can finetune GLM with the cross entropy loss.</p>
<h4 id="NLG-task"><a href="#NLG-task" class="headerlink" title="NLG task"></a>NLG task</h4><p>对于文本生成任务，可以直接的将GLM作为一个自回归模型来使用。</p>
<p>给定的上下文构成了输入的A部分，其中有一个[MASK]结尾的令牌。然后，GLM自动在B部分中生成文本。我们可以将预训练的GLM直接应用于无条件生成，也可以在下游的有条件生成任务上微调GLM。</p>
<p><img src="https://i.loli.net/2021/03/21/k3E8uCchorg5LO9.png" alt="image-20210321151303074" style="zoom:80%;"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] [It’s Not Just Size That Matters] Small Language Models Are Also Few-Shot Learners</p>
<p>[2] Exploiting Cloze Questions for Few Shot Text Classification and Natural Language Inference</p>
<h1 id="智源"><a href="#智源" class="headerlink" title="智源"></a>智源</h1><p><img src="https://i.loli.net/2021/05/31/5iPEkVlSW6JOX1R.png" alt="image-20210531141056347" style="zoom:67%;"></p>
<p><img src="https://i.loli.net/2021/05/31/aeMzL5sy28A6Oj1.png" alt="image-20210531141431038" style="zoom: 67%;"></p>
<p><img src="https://i.loli.net/2021/05/31/q7yzipXa1RTUoZe.png" alt="image-20210531141522110" style="zoom: 67%;"></p>
<p><img src="https://i.loli.net/2021/05/31/JcnGQjioAmLXDkg.png" alt="image-20210531141536365" style="zoom: 67%;"></p>
<p><img src="https://i.loli.net/2021/05/31/PnBrkNesYhzFRMi.png" alt="image-20210531141619653" style="zoom: 67%;"></p>
<p><img src="https://i.loli.net/2021/05/31/x8XETlYPb2od45A.png" alt="image-20210531141830670" style="zoom:67%;"></p>
<p><img src="https://i.loli.net/2021/05/31/ABFUgp1xrDv8nRL.png" alt="image-20210531141846681" style="zoom:67%;"></p>
<p><img src="https://i.loli.net/2021/05/31/tYlRNrnOvUE4BTZ.png" alt="image-20210531142047997" style="zoom:67%;"></p>
<p><img src="https://i.loli.net/2021/05/31/ywNpmPQY387eD2k.png" alt="image-20210531142137420" style="zoom:50%;"></p>
<p><img src="https://i.loli.net/2021/05/31/RETjgnHZM896ASN.png" alt="image-20210531142213537" style="zoom:67%;"></p>
<p><img src="https://i.loli.net/2021/05/31/zjlOPUJpVcFHQBk.png" alt="image-20210531142354926" style="zoom:67%;"></p>
<p><img src="https://i.loli.net/2021/05/31/bPFnzMH5SONEtgU.png" alt="image-20210531142440078" style="zoom:67%;"></p>
<p><img src="C:\Users\shiyaya\AppData\Roaming\Typora\typora-user-images\image-20210531142521384.png" alt="image-20210531142521384" style="zoom:67%;"></p>
<p><img src="https://i.loli.net/2021/05/31/ZkH6OSD7cCzMFTw.png" alt="image-20210531142733913" style="zoom:67%;"></p>
<p><img src="https://i.loli.net/2021/05/31/AdwjNaiIEux45p3.png" alt="image-20210531142944070" style="zoom:67%;"></p>
<p><img src="https://i.loli.net/2021/05/31/SHE4RONT9M6fo1J.png" alt="image-20210531143059560" style="zoom: 67%;"></p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>An Empirical Study of Unsupervised Evaluation Metrics for Dialogue Response Generation</title>
    <url>/2020/07/01/An-Empirical-Study-of-Unsupervised-Evaluation-Metrics-for-Dialogue-Response-Generation/</url>
    <content><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>本文对 <code>对话响应生成系统的评估指标</code> 进行研究，这些对话响应生成系统没有监督标签。当前常采用的metric 采用了机器翻译任务中的metric，以将模型的生成响应与单个目标响应进行比较。</p>
<p>但是，本文发现，这些指标与非技术性Twitter领域中的人为判断之间的关联非常弱，而在技术性Ubuntu领域中则根本没有。（yaya: 即与human judgement的一致性很差）</p>
<p>本文提供定量和定性结果，<strong style="color:red;">突出显示现有指标中的特定弱点</strong> ，并为将来开发更好的对话系统自动评估指标提供建议。</p>
<h3 id="现有指标的缺陷"><a href="#现有指标的缺陷" class="headerlink" title="现有指标的缺陷"></a>现有指标的缺陷</h3><ul>
<li>从例子出发来进行阐述</li>
</ul>
<p>BLEU、METEOR、ROUGE，这些 metric 假设有效的答案与地面真实答案的单词重叠很大。对于对话系统，这是一个强有力的假设，在对话系统中，对给定上下文的有效响应空间存在很大差异。如下边的例子。</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ggbjo3dqgzj30rc0f3tam.jpg" style="zoom: 33%;"></p>
<p>在本文中，我们针对多种响应生成模型，研究了几种<strong>自动评估指标的得分</strong>与对话响应质量的<strong>人工判断</strong>之间的相关性。（即，也是进行了human judgement 数据的收集）</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ggbjvhzcnmj31gb0k24d8.jpg" style="zoom:50%;"></p>
<p>我们表明，这些指标在面向聊天的Twitter数据集上只有很小的正相关，而在技术性Ubuntu Dialogue语料库上则根本没有相关。</p>
<p>我们的结果表明，研究界必须改变这些指标，并强调需要一种与人类判断更紧密相关的新指标。</p>
]]></content>
  </entry>
  <entry>
    <title>An End-to-End Baseline for Video Captioning</title>
    <url>/2019/04/20/An-End-to-End-Baseline-for-Video-Captioning/</url>
    <content><![CDATA[<h3 id="积累梯度那里没有看明白-—-解决内存占用多的问题"><a href="#积累梯度那里没有看明白-—-解决内存占用多的问题" class="headerlink" title="积累梯度那里没有看明白 — 解决内存占用多的问题"></a>积累梯度那里没有看明白 — 解决内存占用多的问题</h3><p>我认为可能是积累 loss, 直到达到某一个batch size才进行反向传播<br>说是为了解决内存占用多的问题，可是这样，就解决了吗？？？</p>
<h3 id="灵魂反问"><a href="#灵魂反问" class="headerlink" title="灵魂反问"></a>灵魂反问</h3><p>为什么要是end-to-end，我最终需要的是一个效果比较好的模型，但是为了只得到这样的一点提升，反而会需要很多的GPU计算资源。这个end-to-end fine-tune 是否有必要。</p>
<h3 id="目前方法存在的问题"><a href="#目前方法存在的问题" class="headerlink" title="目前方法存在的问题"></a>目前方法存在的问题</h3><p>encoder：比如 CNN， 一般是在不同任务上的其他数据集上进行预训练的，之后，在训练video captioning任务时，得到的video/image feature就不再fine tune。这样得到的结果是次优的。<br>目前改进这一缺陷的文章有：[1][2][3]，他们尝试捕捉不同帧之间的动态时域，但是，他们没有从根本上改变一个事实：视频描述任务需要一个与该任务相关的特征。</p>
<h4 id="当前没有人去fine-tune-encoder的原因"><a href="#当前没有人去fine-tune-encoder的原因" class="headerlink" title="当前没有人去fine-tune encoder的原因"></a>当前没有人去fine-tune encoder的原因</h4><p>（1）because of the amount of memory required to process  video data for each batch。是因为每个批次都要处理视频数据，所需要的存储空间会很大。<br>（2）batch sizes for video captioning can become very high (e.g. 512), making training  prohibitive on a small number of GPUs。同时，视频描述的批次一般都比较大，使得所需要的GPU数量会很多。</p>
<h4 id="本文提取出的解决方案——即训练过程"><a href="#本文提取出的解决方案——即训练过程" class="headerlink" title="本文提取出的解决方案——即训练过程"></a>本文提取出的解决方案——即训练过程</h4><p>In this paper we address this issue by accumulating gradients over multiple steps, to update parameters only after  the required effective batch size is achieved.<br>在多步积累梯度，并只在达到有效的批次大小之后(当神经网络训练完512个examples)，才进行梯度更新。<br>这种训练方案相比于分别训练两部分收敛速度会慢，因为所需的迭代次数增加了。但是这里采用了一个加速训练过程的方案，先分别训练encoder和decoder，然后再end-to-end进行fine-tune。</p>
<h4 id="主要的贡献"><a href="#主要的贡献" class="headerlink" title="主要的贡献"></a>主要的贡献</h4><ol>
<li>可以得到与具体任务（视频描述）相关的特征</li>
<li>积累梯度来限制GPU存储消耗，因此可以处理大批次，这是基于RNN的decoders所需的。</li>
<li>使用了两阶段的训练来加速训练</li>
<li>为未来的工作，创建了一个简单的baseline</li>
</ol>
<h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><ol>
<li>先预训练encoder，例如利用图像识别、行为识别等</li>
<li>冻结encoder的参数，在视频描述任务上训练decoder，直到在验证数据集上表现出比较好的效果</li>
<li>整个网络，端到端的训练，冻结Inception-ResNet-v2中的BN层，由于该过程中占用的内存较多，作者采用了一种方法：accumulating gradients over multiple steps, to update parameters only after  the required effective batch size is achieved. </li>
</ol>
<ul>
<li>需要注意的是，在2. 3. 阶段的训练过程中，SA-LSTM都是使用target words(ground truth)作为输入，而不是使用之前的预测。</li>
</ul>
<h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p> Inception-ResNet-v2[5] as an encoder，and a modified version of  Soft-Attention LSTM as a decoder.<br> <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2ad637ykjj30hy0h677d.jpg">    </p>
<ul>
<li>decoder<ul>
<li>输入LSTM的input: <strong>x<sup>t</sup></strong> ：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2aeagi7o3j30a30280sl.jpg">    <ul>
<li>该step 生成的word：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2aeiriwanj30jd014mx7.jpg"></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>soft-attention这里，原文是采用attention机制进行加权求和 ，这里与原soft-attention[2] 略有不同。</p>
<ul>
<li><p>原soft-attention论文：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2aeagheogj308o03ct8l.jpg">     </p>
</li>
<li><p>现修改为：（增加了β<sub>t</sub>）</p>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2aeagka0rj30h504dq37.jpg"><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2aeaggzpdj309302xdfq.jpg">   </p>
<ul>
<li><font color="#0099ff" size="5" face="黑体">这里与Figure2 图中显示的结构并不一致，这里是全权求和，但是在图中却是concatenate !</font>

</li>
</ul>
<ul>
<li>还有一些其他的修改<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2aes6w62rj30il09xwgp.jpg"></li>
</ul>
<h3 id="实验效果"><a href="#实验效果" class="headerlink" title="实验效果"></a>实验效果</h3><ul>
<li>step1 : encoder先训练，然后固定encoder的参数，训练decoder的参数，不进行联合训练</li>
<li>step2：在step1的基础上，联合训练encoder-decoder。</li>
<li>MSR-VTT的实验结果<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2ajqfodpkj30kl0b9acc.jpg">  </li>
<li>MSVD的实验结果<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2ajqfqhbjj30ks0icn0q.jpg"></li>
</ul>
<h4 id="yaya：-本文step1训练效果比较好的原因（相较于soft-attention-lstm-原论文）"><a href="#yaya：-本文step1训练效果比较好的原因（相较于soft-attention-lstm-原论文）" class="headerlink" title=" yaya： 本文step1训练效果比较好的原因（相较于soft-attention lstm 原论文）"></a><font color="#0099ff" size="5" face="黑体"> yaya： 本文step1训练效果比较好的原因（相较于soft-attention lstm 原论文）</font></h4><p>这里step1的意思是：encoder、decoder 分开训练，并不进行联合训练</p>
<ol>
<li>该文使用的 Inception-ResNet-v2作为encoder来提取特征。会比其他论文中使用的encoder更复杂。</li>
<li>初始化的细节<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2ak8as8u4j309703pglo.jpg"></li>
<li>对SA-LSTM[2]而言，进行了一些修改：<br>（1）frame features 转为一个特征向量，使用的注意力机制，但是该文在soft-attention的基础上，还增加了一个系数β<sub>t</sub><br>（2）LSTM的内部结构的计算公式增加了一项，如下图<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2ajg7vn8rj31fi0ci427.jpg"><br>（3）在生成word时，主要差别就是E[y<sub>t-1</sub>]前边是否有权重的问题<ul>
<li>soft-attention 使用的公式：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2aeiriwanj30jd014mx7.jpg"></li>
<li>但是在本文中使用的公式为：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2ajjxtsplj30d103v74i.jpg"><ul>
<li>但是就该文3.3.2节中说：These changes are inspired by  the original code repository by Yao et al [2]，也就是有可能人家的源代码和在论文中提到的不一致。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1] Video captioning with  transferred semantic attributes. CVPR, 2017<br>[2] Describing videos by exploiting temporal  structure. ICCV, 2015.<br>[3] Task-driven dynamic fusion: Reducing ambiguity in video description. CVPR, 2017.<br>[4] Show and  tell: Lessons learned from the 2015 mscoco image captioning challenge. TPAMI, 2016.<br>[5] Inception-v4, inception-resnet and the impact of residual  connections on learning. AAAI, 2017</p>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>Attacking Visual Language Grounding with Adversarial Examples: A Case Study on Neural Image Captioning</title>
    <url>/2020/05/10/Attacking-Visual-Language-Grounding-with-Adversarial-Examples-A-Case-Study-on-Neural-Image-Captioning/</url>
    <content><![CDATA[<h4 id="对抗样本的影响"><a href="#对抗样本的影响" class="headerlink" title="对抗样本的影响"></a>对抗样本的影响</h4><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1genh1kz7svj30i40dpag7.jpg" alt="Fig_stopsign_2_small.png"></p>
<p>图1，在image RGB 上添加了一些扰动，结果使得captioning model的输出也发生了很大的变化。基于此，发现了两个问题。（1）我们的结果指出了在tested image captioning systems中的致命问题。（2）captioning model 中的对抗性例子突出了 人与机器之间visual language grounding 的不一致，表明当前的机器视觉和感知机制可能存在缺陷。</p>
<h4 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h4><ul>
<li>本文提出了一种<strong>设计对抗样本</strong>的方法</li>
<li>本文的这种对抗样本可以拿去用来分析captioning model 的鲁棒性-</li>
<li>本文，还利用 对抗样本，来做什么了，有没有做一些对抗性的训练？？</li>
</ul>
]]></content>
      <categories>
        <category>图像描述</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>BERTScore: Evaluating Text Generation with BERT</title>
    <url>/2020/04/01/BERTScore-Evaluating-Text-Generation-with-BERT/</url>
    <content><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>我们提出BERTScore，这是一种用于文本生成的自动评估指标。</p>
<p>类似于通用指标，BERTScore计算候选句子中每个token与参考中每个token的相似性得分。但是，我们不是使用精确匹配，而是使用上下文化的BERT embedding 来计算相似度。</p>
<p>我们对几种机器翻译和图像字幕基准进行了评估，结果表明BERTScore与人为判断的关联性比现有指标更好，通常甚至大大超过特定于任务的监督指标。</p>
<h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><p>在本文中，我们将重点放在句子级别的生成评估上，并提出了：BERTScore，这是一种基于预训练的BERT上下文嵌入 （bert）的评估指标。 BERTScore将两个句子之间的相似度计算为它们的标记之间的余弦相似度的加权汇总。</p>
<p>基于n-gram matching metric 的常见缺陷：</p>
<ul>
<li><p>semantically-correct phrases are penalized because they differ from the surface form of the reference.</p>
<p>解决： In contrast to string matching (e.g., in BLEU) or matching heuristics (e.g., in METEOR), we compute similarity using contextualized token embeddings, which have been shown to be effective for paraphrase detection  </p>
</li>
<li><p>n-gram models fail to capture distant dependencies and penalize semantically-critical ordering changes.</p>
<p>解决： contextualized embeddings are trained to effectively capture distant dependencies and ordering  </p>
</li>
</ul>
<p>实验结果：（1）In machine translation, BERTSCORE shows stronger system-level and segment-level correlations<br>with human judgments than existing metrics on multiple common benchmarks.（2）BERTSCORE is well-correlated with human annotators for image captioning, surpassing SPICE.</p>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><ul>
<li>见论文，比较好理解</li>
</ul>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul>
<li>Moverscore: Text generation evaluating with contextualized embeddings and earth mover distance  <ul>
<li>同样尝试使用contextual word embeddings  来构建一个metric.</li>
</ul>
</li>
<li>Putting evaluation in context: Contextual embeddings improve machine translation evaluation. In ACL, 2019.  </li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>BART</title>
    <url>/2021/02/19/BART/</url>
    <content><![CDATA[<h1 id="BART-Denoising-Sequence-to-Sequence-Pre-training-for-Natural-Language-Generation-Translation-and-Comprehension"><a href="#BART-Denoising-Sequence-to-Sequence-Pre-training-for-Natural-Language-Generation-Translation-and-Comprehension" class="headerlink" title="BART: Denoising Sequence-to-Sequence Pre-training for Natural Language Generation, Translation, and Comprehension"></a>BART: Denoising Sequence-to-Sequence Pre-training for Natural Language Generation, Translation, and Comprehension</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul>
<li>本文提出了一个<strong>denoising autoencoder</strong> (BART)来预训练一个 sequence-to-sequence model。It is implemented as a sequence-to-sequence model<br>with a bidirectional encoder over corrupted text and a<br>left-to-right autoregressive decoder</li>
<li>BART 通过两点来训练：（1）使用一个<strong>arbitrary noising function</strong> 来对原始文本添加噪声。（2）让模型去学习重构原始文本。</li>
<li>BART使用<strong>一个标准的 transformer-based neural machine translation architecture</strong>。由于采用了 <strong style="color:blue;">bidirectional encoder</strong> 可以看做是对BERT的推广，由于其采用了 <strong style="color:blue;">the left-to-right decoder</strong> 也可以看做是对GPT2的推广，同时也采用了许多现在广泛使用的预训练方案。</li>
<li>本文对许多 noising approaches 进行评估，发现最好的方案是对原始的句子进行打乱顺序。本文采用了一个 novel in-filling scheme，<strong>使用spans of text 来代替 a single mask token</strong>。</li>
<li>实验结果：（1）当对文本生成进行微调之后，BART 对生成式任务的性能尤其的好。BART对理解型任务也表现很好。（2）BART与RoBERTa的性能相匹配，在 GLUE 和 SQuAD 上有可比较的training resources，在一系列  abstractive dialogue, question answering, and summarization tasks 取得了最新成果，并在ROUGE上获得了多达6个点的提升。（3）BART在机器翻译任务上，仅使用 target language 来预训练。在BLEU 指标上，获得了比 back translation system 1.1个点的提升。</li>
<li>消融实验：使用BART framework，采用不同的预训练方案，来确定影响了最终任务性能的关键因素是什么。</li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul>
<li>现存方法的一个问题：However, these methods typically focus on particular types of end tasks (e.g. span prediction, generation, etc.), limiting their applicability.<br>yaya: 现存的方法可以只限定对某一类任务有效，如只对 comprehensive tasks有效，而对 generation tasks无法使用。</li>
<li><p>在本文中，提出了一个可以结合 <strong style="color:red;">bidirectional</strong> and <strong style="color:blue;">auto-regressive</strong> Transformers. BART是使用<strong style="color:blue;">序列到序列</strong>模型构建的<strong style="color:red;">去噪自动编码器</strong>，BART可以适用于非常广泛的最终任务。</p>
</li>
<li><p>本文提出框架的优点：噪声的灵活性，可以将任意转换应用于原始文本，包括更改其长度。</p>
</li>
<li><p>本文对许多 noising approaches 进行评估，发现最好的方案是 shuffling the order of the<br>original sentences。本文采用了一个 novel in-filling scheme，使用spans of text 来代替 a single mask token。<br>本文提出的方法通过强制模型对更多的总体句子长度进行推理，并对输入进行更远距离的转换，从而泛化了BERT中的两个预训练任务（word masking and next sentence prediction）</p>
</li>
<li><p>BART还开辟了关于微调的新思路。本文提出了一种新的机器翻译方案，其中BART模型堆叠在其他几个transformer layers 之上。这些层经过培训，从而将外语从本质上翻译为噪声英语，可以通过BART进行传播，从而将BART用作预训练的目标方语言模型。</p>
</li>
</ul>
<h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><p><strong>BART</strong> is a denoising autoencoder that maps a corrupted document to the original document it was derived from. </p>
<p>It is implemented as <strong>a sequence-to-sequence model</strong> with <strong>a bidirectional encoder</strong> over corrupted text and <strong>a left-to-right autoregressive decoder</strong>. For pre-training, we optimize the negative log likelihood of the original document.</p>
<p><img src="https://i.loli.net/2021/02/19/BCSUOQkGX5KcJTR.png" alt="image-20210219151202969" style="zoom:50%;"></p>
<h2 id="Pre-training-BART"><a href="#Pre-training-BART" class="headerlink" title="Pre-training BART"></a>Pre-training BART</h2><p>Unlike existing denoising autoencoders, which are tailored to specific noising schemes, BART allows us to apply any type of document corruption.</p>
<p>解释：BERT 对句子中的token进行随机掩码，采用的特定类型的 noising schemes，而 BART 可以应用任意类型的corruption。<strong>极端情况下，当原句中的所有信息都丢失时，BART可以看做是一个 language model。</strong></p>
<p>本文采用了 几个先前提出的变换，和几个自己新提出的变换。</p>
<p><img src="https://i.loli.net/2021/02/19/LxrawUIdKp8TyFX.png" alt="image-20210219152433064"></p>
<p>（1）Token Masking.</p>
<p>（2）Token Deletion. 模型必须去决定哪个在位置丢失了。</p>
<p>（3）Text Infilling. 采样了多个 text spans, spans lengths 从一个泊松分布（$\lambda$ = 3）中随机采样。每个span被替换成一个[MASK]。<strong>Text infilling teaches the model to predict how many tokens are missing from a span.</strong> yaya:仅仅是预测[MASK 位置处有几个tokens，而不需要预测具体点的tokens是什么]</p>
<p>（4）Sentence Permutation. 根据停止符，将一个document分成多个句子，然后打乱句子的顺序，</p>
<p>（5）Document Rotation. A token is chosen uniformly at random, and the document is rotated so that it begins with that token. This task trains the model to identify the start of the document.</p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>BERT-ATTACK Adversarial Attack Against BERT Using BERT</title>
    <url>/2020/12/01/BERT-ATTACK-Adversarial-Attack-Against-BERT-Using-BERT/</url>
    <content><![CDATA[<h1 id="复旦大学李林阳：应用预训练模型实现对抗样本生成的高效方法"><a href="#复旦大学李林阳：应用预训练模型实现对抗样本生成的高效方法" class="headerlink" title="复旦大学李林阳：应用预训练模型实现对抗样本生成的高效方法"></a>复旦大学李林阳：应用预训练模型实现对抗样本生成的高效方法</h1><p>针对离散数据（例如文本）的对抗攻击比连续数据（例如图像）更具挑战性，因为很难使用基于梯度的方法生成对抗样本。当前成功的文本攻击方法通常在字符或单词级别上采用启发式替换策略，替换时难以保持语义一致性和语言流畅性。在本文中，作者提出了BERT-Attack，这是一种高质量且有效的方法，可以使用以BERT为例的MLM预训练语言模型来生成对抗性样本。作者使用BERT对抗其微调模型和其他预训练模型，以误导目标模型，使其预测错误。作者的方法在成功率和扰动百分比方面均优于最新的攻击策略，并且生成的对抗性样本很流利，并且在语义一致。而且作者的方法计算成本低，可以大规模生成。</p>
<p>本期AI TIME PhD直播间，我们有幸邀请到了复旦大学 NLP group2019级研究生李林阳分享他的观点。</p>
<p>李林阳：复旦大学 NLP group2019级研究生；导师为邱锡鹏教授；</p>
<hr>
<h2 id="一、针对文本任务的攻击"><a href="#一、针对文本任务的攻击" class="headerlink" title="一、针对文本任务的攻击"></a><strong>一、针对文本任务的攻击</strong></h2><p>尽管深度学习取得了成功，但最近的研究发现神经网络容易受到对抗样本的攻击，这些对抗样本是对原始输入进行细微扰动而制成的。尽管对抗性样本对于人而言几乎不可察觉，但是它们会误导神经网络进行错误的预测。针对对抗性攻击的学习可以提升神经网络的可靠性和健壮性，在计算机视觉领域，攻击策略及其防御措施都得到了很好的探索，但由于语言的离散性，对文本的对抗性攻击较为困难，难以保证语法流利且语义一致。</p>
<p><img src="https://i.loli.net/2020/12/01/S3DQcwvOEAt1uma.jpg"> </p>
<p> 表1 BERT-Attack方法生成样本的例子</p>
<p>当前对文本的成功攻击通常采用启发式规则来修改单词的字符，并用同义词替换单词。</p>
<p>之前的研究包括使用word embedding生成替换词；对原有句子的短语进行添加或删除；使用人工构建的规则进行词语替换。<strong>尽管上述方法取得了良好的效果，但在攻击成功率，语法正确性和语义一致性等方面，仍有很大的改进空间</strong>。此外，这些方法的替换策略通常很简单，受限于特定任务。</p>
<p>本文提出了一种有效且高质量的对抗样本生成方法：BERT-Attack，使用BERT作为生成器生成对抗样本。BERT-Attack的核心算法包括<strong>两个阶段</strong>：<strong>在给定输入序列中查找易受攻击的单词，然后用如BERT的生成器来生成易受攻击单词的替代词。</strong> BERT能够捕捉文本的上下文语义，因此生成的样本更为流畅且合理。作者将BERT这样的MLM语言模型用作生成器，并找到让BERT模型得到最大错误预测风险的扰动。另外，本文的方法只需要一次生成器前向，而且无需反复使用语言模型对对抗样本进行评分，速度有一定改进。表1展示了该攻击方法在几个数据集上的生成文本样例。</p>
<h2 id="二、BERT-ATTACK攻击方法"><a href="#二、BERT-ATTACK攻击方法" class="headerlink" title="二、BERT-ATTACK攻击方法"></a><strong>二、BERT-ATTACK攻击方法</strong></h2><p><img src="https://i.loli.net/2020/12/01/cOpDH2hWr81uzMS.png" alt="image-20201201154053279"></p>
<p>图1. BERT-ATTACK替换策略一步的样例</p>
<p>本文提出BERT-Attack，它使用原始BERT模型制作对抗性样本以对抗微调的BERT模型。对抗样本的生成包括两个步骤：（1）找出针对目标模型的易受攻击的单词，（2）用语义相似且语法正确的单词替换它们，直到成功攻击为止。具体而言：</p>
<p><strong>1.寻找易受攻击词(Vulnerable Words)</strong></p>
<p>作者给句子中的每一个词一个评分，得分与易受攻击程度呈正比，该评分按照去掉该词的句子在判别器上的输出结果的扰动程度给出。作者使用目标模型（微调的BERT或其他神经模型）的logit输出作为判别器。易受攻击词定义为序列中对最终输出logit有重要影响的单词。令表示输入语句，表示目标模型输出的正确标签y的logit，重要性得分定义为</p>
<p>$I_{w_{i}}=o_{y}(S)-o_{y}\left(S_{\backslash w_{i} j}\right.)$</p>
<p>其中，</p>
<p>$S_{\backslash w_{i}}=\left[w_{0} ; \ldots ; w_{i-1} ;[M A S K] ; w_{i+1} ; \ldots\right]$</p>
<p>就是将该词替换成“[MASK]”。然后，对降序排名，获取其中的前百分之的词组成可替换词表，记为L。</p>
<h2 id="2-BERT生成器的优点"><a href="#2-BERT生成器的优点" class="headerlink" title="2.BERT生成器的优点"></a><strong>2.BERT生成器的优点</strong></h2><p>找到易受攻击的单词后，将列表L中的单词一一替换，以寻找可能误导目标模型的干扰。以前的替换方法包括同义词词典，POS检查器，语义相似性检查器等。但是因为替换的时候只有词表，不考虑上下文，因此需要用传统语言模型给替换单词的句子打分。由于换一个词就得评价一次，时间成本比较高。</p>
<p>作者利用BERT进行单词替换，可确保所生成的句子相对流利且语法正确，还保留了大多数语义信息。此外，掩码语言模型的预测是上下文感知的，因此可以动态搜索扰动，而不是简单的同义词替换。而且针对一个词而言，仅通过一个前向即可产生候选文本，无需再用语言模型来对句子评分，提升了效率。</p>
<h2 id="3-替换策略"><a href="#3-替换策略" class="headerlink" title="3.替换策略"></a><strong>3.替换策略</strong></h2><p><img src="https://i.loli.net/2020/12/01/MIsY1JPptlRxGB5.png" alt="image-20201201153433807" style="zoom:50%;">图2 BERT-ATTACK替换算法</p>
<p>如图1所示，作者输入原句子给BERT，并根据BERT输出生成候选词。<strong style="color:red;">注意这里不用[MSAK]替换被攻击词语</strong>，其原因作者给出了如下解释：1. 有些词语替换后，和原句子几乎一样流畅但是语义可能变更。例如给定一个序列“I like the cat”，如果遮盖cat这个词，那么MLM模型很难预测原始单词cat，因为如“I like the dog”一样很流畅。2. MASK掉给定的单词后，每个候选词都需要运行一遍BERT前向，时间成本太高。</p>
<p>令M代表BERT模型，为原序列，是利用BERT的分词器分完词的序列，将H输入BERT中得到输出预测。使用top-K策略选择可能的替换词预测，其中K是超参数。作者遍历所有候选易攻击词表L生成替换词表。</p>
<p>由于BERT使用字节对编码（BPE）分词，候选词可能会被分开，因此还需要将所选单词与BERT中相应的子单词对齐。</p>
<p>针对未被分开的单个单词，作者使用相应的前K个预测候选逐一尝试替换，并使用NLTK过滤其中的停用词，另外对于情感分类任务候选词可能包括同义词和反义词，作者使用同义词词典过滤反义词。然后将替换完成的句子重新输入判别器，如果判别器给出与原label相反的判断那么输出该句子作为攻击句；否则，从筛选出的候选词中选择一个对logit影响最大的。</p>
<p>针对字词组（sub-word 应该不能翻译为字词组），由于无法直接获取其替代词，作者使用子词组合中所有词的预测中找到合适的词替代。作者首先使用MLM模型分析整个词组的易攻击程度，然后再选出词组的top-k组合。剩余过程与单个单词一致。</p>
<p><strong>三、实验结果</strong></p>
<p><strong>3.1 数据集和评价指标</strong></p>
<p>为了衡量所生成样本的质量，作者设计了几种评估指标：</p>
<p>●成功率（success rate）：攻击样本的判别器准确率。</p>
<p>●扰动百分比（perturbed percentage）更改文本的占比。</p>
<p>●每个样本的查询数量（query number per sample）一个样本生成对抗样本的需要访问判别器的次数。</p>
<p>●语义相似度（semantic similarity）使用通用句子编码器（Universal Sentence Encoder）评价的句子相似度。</p>
<p><img src="https://i.loli.net/2020/12/01/jgXqBTRfJYniZFe.png" alt="image-20201201153907478" style="zoom:50%;">表2 实验结果</p>
<p><strong>3.2 实验结果</strong></p>
<p>如表2所示，BERT-Attack方法成功欺骗了其下游的微调模型。在文本分类和自然语言推断任务中，经过微调的BERT均无法正确地对生成的对抗样本进行分类，攻击后的平均准确度低于10％。同时，扰动百分比小于10％，明显小于以前的工作，BERT-Attack方法更有效且更不易察觉。查询数量也要少得多。</p>
<p>另外可以观察到，由于扰动百分比非常低，因此通常更容易攻击评论分类任务。BERT-Attack仅替换少数几个单词就可能误导判别器。由于平均序列长度相对较长，因此判别器倾向于仅按序列中的几个词进行判断，这不是人类预测的自然方式。因此，这些关键字的干扰将导致目标模型的预测不正确，从而揭示了该模型的脆弱性。</p>
<p><strong>3.3人工验证</strong></p>
<p>为了进一步评估生成的对抗性样本，作者人工评估了流利性，语法以及语义保留方面生成的样本的质量。</p>
<p><img src="https://i.loli.net/2020/12/01/oDVS914hYZWJNje.png" alt="image-20201201153955115" style="zoom:50%;"></p>
<p>作者要求三名标注人员对生成的对抗性样本和原始序列的混合句子的语法正确性进行评分（1-5分），然后将原始文本和对抗文本混在一起进行人工预测。在IMDB和MNLI数据集中，作者分别选择100个原始样本和对抗样本验证。对于IMDB，将多数类作为人类预测标签，对于MNLI，则使用标注人员之间的平均分数。从表2中可以看出，对抗性样本的语义分数和语法分数接近原始样本。MNLI<strong>任务数据长且更加复杂（存在句子对（sentence pair）之间，重复出现的词汇较多，而基于替换的对抗样本则破坏了这种相同词汇的对应关系</strong>），使标注人员难以正确预测，因此其准确性要比简单的句子分类任务低。作者同样做了大量消融实验，实验结果表明该对抗方法生成的样本迁徙性强，生成速度快。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>在这项工作中，作者提出了一种高质量有效的BERT-Attack方法，以使用BERT<strong>掩蔽语言模型（masked-LM）生成对抗性样本。</strong>实验结果表明，该方法在保持最小扰动的同时，取得了较高的成功率。然而，从屏蔽语言模型生成的候选者有时可能是反义词或与原始单词无关，从而导致语义损失。因此，增强语言模型以生成更多与语义相关的扰动可能是将来完善BERT-Attack的一种可能解决方案。</p>
<hr>
<blockquote>
<p>整理：李键铨<br>排版：杨梦蒗<br>审稿：李林阳</p>
</blockquote>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>[Behind the Scene] Revealing the Secrets of Pre-trained Vision-and-Language Models</title>
    <url>/2021/03/05/Behind-the-Scene-Revealing-the-Secrets-of-Pre-trained-Vision-and-Language-Models/</url>
    <content><![CDATA[<h3 id="本文研究的任务"><a href="#本文研究的任务" class="headerlink" title="本文研究的任务"></a>本文研究的任务</h3><p>最近Transformer-based 大规模预训练模型推动了 多模态任务的发展，比如，ViL-BERT，LXMERT and UNITER。然而，对于使它们取得成功的<strong>内部机制</strong>知之甚少。为了揭示内部机制，本文提出了VALUE（Vision-And-Language Understanding Evaluation），一组精心设计的<strong>探测任务</strong>（probing task, eg: Visual Coreference Resolution, Visual Relation Detection），可推广到标准的预训练V + L模型， 破译多模式预训练的内部运作方式（例如，在各个attention heads 中获得的隐性知识，通过上下文化多模式嵌入学习的 inherent cross-modal alignment）。</p>
<h3 id="本文的实验发现"><a href="#本文的实验发现" class="headerlink" title="本文的实验发现"></a>本文的实验发现</h3><p>经由这些探测任务，通过对每个原型模型体系结构的广泛分析，我们的主要观察结果是：（i）预训练的模型在推理过程中表现出对文本而不是图像的关注。 （ii）存在专门为捕获cross-modal interactions 而设计的 a subset of attetion heads（iii）在多个预训练模型中学习的注意力矩阵显示出图像区域和文本单词之间的<strong>潜在对齐</strong>，表现出<strong>一致的模式</strong>。 （iv）绘制的注意力模式(attention patern)揭示了图像区域之间的视觉可解释的关系。 （v）纯粹的语言知识也被有效地编码在注意力集中。 这些宝贵的见解可指导未来的工作，以设计更好的模型架构和多模式预训练的目标。</p>
<h3 id="1-What-is-the-correlation-between-multimodal-fusion-and-the-number-of-layers-in-pre-trained-models"><a href="#1-What-is-the-correlation-between-multimodal-fusion-and-the-number-of-layers-in-pre-trained-models" class="headerlink" title="1. What is the correlation between multimodal fusion and the number of layers in pre-trained models?"></a>1. What is the correlation between multimodal fusion and the number of layers in pre-trained models?</h3><p>可视化每层的embeddings (regions and tokens), 并使用 k-means算法来聚类（k=2），然后measure the difference between the formed clusters and ground-truth visual/textual clusters via Normalized Mutual Information (NMI), an unsupervised metric for evaluating differences between clusters.</p>
<ul>
<li>ground-truth visual/textual clusters, 是什么？？？？</li>
</ul>
<p><img src="https://i.loli.net/2021/04/04/r24Dx6oI7qfG8dB.png" alt="image-20210404171353836" style="zoom:50%;"></p>
<p><strong>结论</strong>： For (a) Multimodal Fusion Degree, clustering analysis between image and text representations shows that in single-stream models like UNITER, as the network layers go deeper, the fusion between two modalities becomes more intertwined. However, the opposite phenomenon is observed in two-stream models like LXMERT.</p>
<h3 id="2-Which-modality-plays-a-more-important-role-that-drives-the-pre-trained-model-to-make-final-predictions"><a href="#2-Which-modality-plays-a-more-important-role-that-drives-the-pre-trained-model-to-make-final-predictions" class="headerlink" title="2. Which modality plays a more important role that drives the pre-trained model to make final predictions?"></a>2. Which modality plays a more important role that drives the pre-trained model to make final predictions?</h3><p><strong>结论：</strong>For (b) Modality Importance, by analyzing the attention trace of the [CLS] token, which is commonly considered as containing the intended fused multimodal information and often used as the input signal for downstream tasks, we nd that the nal predictions tend to depend more on textual input rather than visual input.</p>
<h3 id="3-What-knowledge-is-encoded-in-pre-trained-models-that-supports-cross-modal-interaction-and-alignment"><a href="#3-What-knowledge-is-encoded-in-pre-trained-models-that-supports-cross-modal-interaction-and-alignment" class="headerlink" title="3. What knowledge is encoded in pre-trained models that supports cross-modal interaction and alignment?"></a>3. What knowledge is encoded in pre-trained models that supports cross-modal interaction and alignment?</h3><p><strong>结论：</strong>For (c) Cross-modal Interaction, we propose a Visual Coreference Resolution task to probe its encoded knowledge.</p>
<h3 id="4-What-knowledge-has-been-learned-for-image-to-image-intra-modal-interaction-i-e-visual-relations"><a href="#4-What-knowledge-has-been-learned-for-image-to-image-intra-modal-interaction-i-e-visual-relations" class="headerlink" title="4. What knowledge has been learned for image-to-image (intra-modal) interaction (i.e., visual relations)?"></a>4. What knowledge has been learned for image-to-image (intra-modal) interaction (i.e., visual relations)?</h3><p>For (d) Image-to-image Interaction, we conduct analysis via Visual Relation Detection between two image regions.</p>
<h3 id="5-Compared-with-BERT-do-pre-trained-V-L-models-eectively-encode-linguistic-knowledge-for-text-to-text-intra-modal-interaction"><a href="#5-Compared-with-BERT-do-pre-trained-V-L-models-eectively-encode-linguistic-knowledge-for-text-to-text-intra-modal-interaction" class="headerlink" title="5. Compared with BERT, do pre-trained V+L models eectively encode linguistic knowledge for text-to-text (intra-modal) interaction?"></a>5. Compared with BERT, do pre-trained V+L models eectively encode linguistic knowledge for text-to-text (intra-modal) interaction?</h3><p>结论：For (e) Text-to-text Interaction, we evaluate the linguistic knowledge encoded in each layer of the tested model with SentEval tookit [8], and compare with the original BERT [9]. Experiments show that both single- and two-stream models, especially the former, can well capture cross-modal alignment, visual relations, and linguistic knowledge.</p>
]]></content>
      <categories>
        <category>cross-modal</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
      </tags>
  </entry>
  <entry>
    <title>Batch Normalization(BN层)</title>
    <url>/2019/03/23/Batch-Normalization-BN%E5%B1%82/</url>
    <content><![CDATA[<p>参看：<a href="https://blog.csdn.net/donkey_1993/article/details/81871132" target="_blank" rel="noopener">https://blog.csdn.net/donkey_1993/article/details/81871132</a><br>参看：<a href="https://zhuanlan.zhihu.com/p/34879333" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34879333</a></p>
<h2 id="BN层的原理"><a href="#BN层的原理" class="headerlink" title="BN层的原理"></a>BN层的原理</h2><ul>
<li>在训练阶段，输入到网络中的是mini batch<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1chneox3hj30dv0bddgx.jpg"><br>解析：</li>
<li><p>Normalization操作我们虽然缓解了ICS问题，让每一层网络的输入数据分布都变得稳定，但却导致了数据表达能力的缺失。也就是我们通过变换操作改变了原有数据的信息表达（representation ability of the network），使得底层网络学习到的参数信息丢失。另一方面，通过让每一层的输入分布均值为0，方差为1，会使得输入在经过sigmoid或tanh激活函数时，容易陷入非线性激活函数的线性区域。  </p>
</li>
<li><p>因此，BN又引入了两个可学习（learnable）的参数  γ与β  。这两个参数的引入是为了恢复数据本身的表达能力，对规范化后的数据进行线性变换，即<img src="https://www.zhihu.com/equation?tex=%5Ctilde%7BZ_j%7D%3D%5Cgamma_j+%5Chat%7BZ%7D_j%2B%5Cbeta_j" alt="\tilde{Z_j}=\gamma_j \hat{Z}_j+\beta_j">。特别地，当  γ<sup>2</sup>=σ<sup>2</sup> ， β=μ 时，可以实现等价变换（identity transform）并且保留了原始输入特征的分布信息。</p>
</li>
</ul>
<h2 id="测试阶段如何使用Batch-Normalization？"><a href="#测试阶段如何使用Batch-Normalization？" class="headerlink" title="测试阶段如何使用Batch Normalization？"></a>测试阶段如何使用Batch Normalization？</h2><p>我们知道BN在每一层计算的  μ与σ<sup>2</sup>都是基于当前batch中的训练数据，但是这就带来了一个问题：我们在预测阶段，有可能只需要预测一个样本或很少的样本，没有像训练样本中那么多的数据，此时 μ与σ<sup>2</sup>的计算一定是有偏估计，这个时候我们该如何进行计算呢？</p>
<p>利用BN训练好模型后，我们保留了每组mini-batch训练数据在网络中每一层的<br> μ<sub>batch</sub>与σ<sup>2</sup><sub>batch</sub> 。此时我们使用整个样本的统计量来对Test数据进行归一化，具体来说使用均值与方差的无偏估计：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cmu_%7Btest%7D%3D%5Cmathbb%7BE%7D+%28%5Cmu_%7Bbatch%7D%29" alt="\mu_{test}=\mathbb{E} (\mu_{batch})"></p>
<p><img src="https://www.zhihu.com/equation?tex=%5Csigma%5E2_%7Btest%7D%3D%5Cfrac%7Bm%7D%7Bm-1%7D%5Cmathbb%7BE%7D%28%5Csigma%5E2_%7Bbatch%7D%29" alt="\sigma^2_{test}=\frac{m}{m-1}\mathbb{E}(\sigma^2_{batch})"></p>
<p>得到每个特征的均值与方差的无偏估计后，我们对test数据采用同样的normalization方法：</p>
<p><img src="https://www.zhihu.com/equation?tex=BN%28X_%7Btest%7D%29%3D%5Cgamma%5Ccdot+%5Cfrac%7BX_%7Btest%7D-%5Cmu_%7Btest%7D%7D%7B%5Csqrt%7B%5Csigma%5E2_%7Btest%7D%2B%5Cepsilon%7D%7D%2B%5Cbeta" alt="BN(X_{test})=\gamma\cdot \frac{X_{test}-\mu_{test}}{\sqrt{\sigma^2_{test}+\epsilon}}+\beta"></p>
<p>另外，除了采用整体样本的无偏估计外。吴恩达在Coursera上的Deep Learning课程指出可以对train阶段每个batch计算的mean/variance采用<a href="[https://zhuanlan.zhihu.com/p/29895933](https://zhuanlan.zhihu.com/p/29895933"><font color="#0099ff" size="5" face="楷体"> 指数加权平均</font></a>)来得到test阶段mean/variance的估计。</p>
<h2 id="Batch-Normalization的优势"><a href="#Batch-Normalization的优势" class="headerlink" title="Batch Normalization的优势"></a>Batch Normalization的优势</h2><p>Batch Normalization在实际工程中被证明了能够缓解神经网络难以训练的问题，BN具有的有事可以总结为以下三点：</p>
<p><strong>（1）BN使得网络中每层输入数据的分布相对稳定，加速模型学习速度</strong></p>
<p>BN通过规范化与线性变换使得每一层网络的输入数据的均值与方差都在一定范围内，使得后一层网络不必不断去适应底层网络中输入的变化，从而实现了网络中层与层之间的解耦，允许每一层进行独立学习，有利于提高整个神经网络的学习速度。</p>
<p><strong>（2）BN使得模型对网络中的参数不那么敏感，简化调参过程，使得网络学习更加稳定</strong></p>
<p>在神经网络中，我们经常会谨慎地采用一些权重初始化方法（例如Xavier）或者合适的学习率来保证网络稳定训练。<br>当学习率设置太高时，会使得参数更新步伐过大，容易出现震荡和不收敛。但是使用BN的网络将不会受到参数数值大小的影响。<br>在使用Batch Normalization之后，抑制了参数微小变化随着网络层数加深被放大的问题，使得网络对参数大小的适应能力更强，此时我们可以设置较大的学习率而不用过于担心模型divergence的风险。</p>
<p><strong>（3）BN允许网络使用饱和性激活函数（例如sigmoid，tanh等），缓解梯度消失问题</strong></p>
<p>在不使用BN层的时候，由于网络的深度与复杂性，很容易使得底层网络变化累积到上层网络中，导致模型的训练很容易进入到激活函数的梯度饱和区；通过normalize操作可以让激活函数的输入数据落在梯度非饱和区，缓解梯度消失的问题；另外通过自适应学习 γ与β又让数据保留更多的原始信息。</p>
<p><strong>（4）BN具有一定的正则化效果</strong></p>
<p>在Batch Normalization中，由于我们使用mini-batch的均值与方差作为对整体训练样本均值与方差的估计，尽管每一个batch中的数据都是从总体样本中抽样得到，但不同mini-batch的均值与方差会有所不同，这就为网络的学习过程中增加了随机噪音，与Dropout通过关闭神经元给网络训练带来噪音类似，在一定程度上对模型起到了正则化的效果。</p>
<p>另外，原作者通过也证明了网络加入BN后，可以丢弃Dropout，模型也同样具有很好的泛化效果。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Beam Search</title>
    <url>/2021/03/15/Beam-Search/</url>
    <content><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. <strong>前言</strong></h2><p>自然语言处理任务中，如机器翻译、对话、文本摘要等，都涉及到序列生成。文本序列生成解码过程中有用到 greedy search、维特比算法、beam search等。</p>
<h2 id="2-Beam-Search-介绍"><a href="#2-Beam-Search-介绍" class="headerlink" title="2. Beam Search 介绍"></a>2. Beam Search 介绍</h2><p>beam search尝试在广度优先基础上进行进行搜索空间的优化（类似于剪枝）达到减少内存消耗的目的。</p>
<ul>
<li><strong>算法过程</strong></li>
</ul>
<p>定义词表大小是V，beam size是 B，序列长度是L。</p>
<p>假设V=100，B=3：</p>
<ol>
<li><p>生成第1个词时，选择概率最大的3个词（假设是a，b，c），即从100个中选了前3个；</p>
</li>
<li><p>生成第2个词时，将当前序列a/b/c分别与词表中的 100个词组合，得到 3*100个序列，从中选 3个概率最大的，作为当前序列（假设现在是am，bq，as）；</p>
</li>
<li><p>持续上述过程，直到结束。最终输出3个得分最高的。</p>
</li>
</ol>
<ul>
<li><strong>算法复杂度</strong> O(B×V×L)</li>
</ul>
<p>在第2步，要计算 B×V次。序列长度是L，生成长度为L的序列，计算 B×V×L 次。</p>
<h2 id="3-算法评价"><a href="#3-算法评价" class="headerlink" title="3. 算法评价"></a>3. 算法评价</h2><ul>
<li><strong>优点</strong></li>
</ul>
<p>(1) 减少计算开销。相对于广度优先搜索，广搜每次都要保留所有可能的结果，复杂度是  $O(V^L)$指数级。</p>
<ul>
<li><strong>缺点（第3部分详细讲）</strong></li>
</ul>
<p>(1) 数据下溢</p>
<p>(2) 倾向于生成短的序列</p>
<p>(3) 单一性问题</p>
<ul>
<li><strong>Beam size 设置</strong></li>
</ul>
<p>(1) B越大</p>
<p>优点：可考虑的选择越多，能找到的句子越好</p>
<p>缺点：计算代价更大，速度越慢，内存消耗越大</p>
<p>(2) B越小</p>
<p>优点：计算代价小，速度快，内存占用越小</p>
<p>缺点：可考虑的选择变少，结果没那么好</p>
<h2 id="4-问题解决"><a href="#4-问题解决" class="headerlink" title="4. 问题解决"></a>4. 问题解决</h2><h3 id="4-1-数据下溢"><a href="#4-1-数据下溢" class="headerlink" title="4.1 数据下溢"></a>4.1 数据下溢</h3><p>求序列概率的时候，序列概率是多个条件概率的乘积$P(y^{<1>} y^{<2>} \ldots y^{T_{y}})=P(y^{<1>} \mid x) P(y^{<2>} \mid x, y^{<1>}) \ldots P(y^{T_{y}} \mid x, y^{<1>} \ldots, y^{T_{y}-1})$.</1></1></2></1></2></1></p>
<p>每个概率都小于1甚至远远小于1，很多概率相乘起来，会得到很小很小的数字，会造成数据下溢，即数值太小，计算机的浮点表示不能精确储存。</p>
<p><strong>解决</strong>：<strong>将最大化的乘积式取对数</strong>，由 $\log M^{*} N=\log M+\log N$ 公式可得，上述需要最大化的王积式可以转化为:</p>
<p><img src="https://i.loli.net/2021/04/07/8EfxMgsC43zmqSb.png" alt="image-20210407205434424" style="zoom: 50%;"></p>
<p>即乘积的log变成了log的求和，最大化这个log的求和值能够得到同样的结果，并且不会出现 数值下溢和四舍五入。</p>
<h3 id="4-2-倾向于生成短的序列"><a href="#4-2-倾向于生成短的序列" class="headerlink" title="4.2 倾向于生成短的序列"></a>4.2 倾向于生成短的序列</h3><p>生成的句子序列越长，对数概率相加的结果就越小（越为负值）, 所以倾向于生成短序列。 对序列长度进行惩罚，降低生成短序列的倾向。</p>
<p><strong>解决方法：</strong> 对数概率相加的结果, 除以序列长度 $L$ 。<br>实践中，通常采用更柔和的方法, 在 $L$ 上加上指数 $a \in(0,1),$ 即 $L^{a},$ 例如 $a=0.7$ 。如果 $a=1, \quad L^{a}=L$ 就相当于完全用长度来归一化; 如果 $a=0, \quad L^{a}=1$ 就相当于完全没有 归一化, $a \in(0,1)$ 就是在完全归一化和没有归一化之间。</p>
<p>或者更加复杂一点：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">norm</span> = self.opt.beam_search_norm</span><br><span class="line"><span class="attr">candidate_logprob</span> = (beam_logprobs_sum[q] * t ** norm + local_logprob) / ((t+<span class="number">1</span>) ** norm)</span><br></pre></td></tr></table></figure>
<h3 id="4-3-单一性问题"><a href="#4-3-单一性问题" class="headerlink" title="4.3 单一性问题"></a><strong>4.3 单一性问题</strong></h3><p>beam search 有一个大问题是输出的 $B$ 个句子的差异性很小，无法体现语言的多样性（比如文本摘要、机器翻译的生成文本，往往有不止一种表述方式）。</p>
<p><strong>解决方法：</strong> 分组 加入相似性惩罚。diverse beam search 来自<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1610.02424.pdf" target="_blank" rel="noopener">论文</a></p>
<p>具体如下：选择 Beam size 为 $B$，然后将其分为 $G$组，每一组就有 $B/G$个beam。每个单独的组内跟 beam search很像，不断延展序列。同时通过引入一个dissimilarity 项来保证组与组之间有差异。</p>
<p><img src="https://i.loli.net/2021/03/15/VQDxijZcGtzlEph.png" alt="image-20210315161115581" style="zoom: 50%;"></p>
<p>如上图所示，B = 6, G=3，每一组的beam width为2。</p>
<p>组内与 beam search 很像：从t-1到 t 时刻，不断的减少搜索空间（如同beam search一样）。</p>
<p>组间差异：对于t=4时刻，我们先对第一组输出y（t=4），然后我们开始对第二组输出y（t=4），但是第二组y（t=4）的score不仅取决于第二组之前的y（t=3），也取决于其与第一组的相似程度。以此类推，在t=4时刻对于第三组的输出，我们从上图可以看到其score的打分标准。这儿对于其 dissimilarity 项的计算采用的办法是 hamming diversity，这个理解起来很简单，比如这个时刻可能输出的词在上面的组出现过，我们就对这个词的分数-1，如果这个时刻可能输出的词在上面组没有出现过，我们就对这个词的分数不惩罚。</p>
<ul>
<li><strong>DBS算法：</strong></li>
</ul>
<p><img src="https://i.loli.net/2021/03/15/DdS1XPZvoEptVgw.png" alt="image-20210315161139107" style="zoom: 50%;"></p>
<p>DBS算法</p>
<ul>
<li><strong>附：</strong>很多论文里有对 beam search的改进，主要是针对生成序列的<strong>多样性</strong>的。多样性问题，在对话里很常见。</li>
</ul>
<h2 id="5-其他相关问题："><a href="#5-其他相关问题：" class="headerlink" title="5. 其他相关问题："></a><strong>5. 其他相关问题</strong>：</h2><h3 id="5-1-训练的时候需要-Beam-Search-吗？"><a href="#5-1-训练的时候需要-Beam-Search-吗？" class="headerlink" title="5.1 训练的时候需要 Beam Search 吗？"></a><strong>5.1 训练的时候需要 Beam Search 吗？</strong></h3><p>不需要。因为训练的时候知道每一步的正确答案，没必要进行这样的搜索。</p>
<h3 id="5-2-为什么不用贪心搜索"><a href="#5-2-为什么不用贪心搜索" class="headerlink" title="5.2 为什么不用贪心搜索?"></a>5.2 为什么不用贪心搜索?</h3><p>贪心搜索相当于 Beam Search 中 B=1的情况，每次只选择概率最大的词，容易陷入局部最优，但我们真正需要的是一个序列，我们希望整个序列的概率最大。</p>
<h3 id="5-3-维特比算法"><a href="#5-3-维特比算法" class="headerlink" title="5.3 维特比算法"></a>5.3 维特比算法</h3><p>维特比算法是用动态规划的思想。简单来说就是：从开始状态之后每走一步，就记录下<strong>到达该状态的所有路径的概率最大值</strong>，然后以此最大值为基准继续向后推进。显然，如果这个最大值都不能使该状态成为最大似然状态路径上的结点的话，那些小于它的概率值（以及对应的路径）就更没有可能了。</p>
<p>Beam Search与Viterbi算法虽然都是解空间的剪枝算法，但它们的思路是不同的。Beam Search是对状态迁移的路径进行剪枝，而 Viterbi 算法是合并不同路径到达同一状态的概率值，用最大值作为对该状态的充分估计值，从而在后续计算中，忽略历史信息（这种以偏概全也就是所谓的Markov性），以达到剪枝的目的。<br>从状态转移图的角度来说，Beam Search是空间剪枝，而Viterbi算法是时间剪枝。</p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Beyond Accuracy: Behavioral Testing of NLP Models with CheckList</title>
    <url>/2020/10/28/Beyond-Accuracy-Behavioral-Testing-of-NLP-Models-with-CheckList/</url>
    <content><![CDATA[<p>转载：<a href="https://dy.163.com/article/FH8NB44C0511DPVD.html" target="_blank" rel="noopener">https://dy.163.com/article/FH8NB44C0511DPVD.html</a></p>
<p>现在，ACL2020各个奖项都已悉数公布，对此AI科技评论做了详细报道。其中，最受人瞩目的当属最佳论文奖，今年该奖项由微软团队的 《Beyond Accuracy: Behavioral Testing of NLP Models with CheckList》一举拿下。</p>
<p>　　小编看到论文题目的第一眼就觉得哪些有些不对，于是赶紧通读了一下文章，嗯~确实不太对，这貌似和之前我们熟悉的NLP“大力出奇迹”的模型套路不太一样啊？</p>
<p>　　那么这篇论文到底讲了什么呢，又何以摘得桂冠呢？</p>
<p>　　论文解读以外，我们进一步对论文的第二作者吴彤霜进行了专访，以更深入地了解最佳论文团队背后的工作。</p>
<h3 id="论文方法一览"><a href="#论文方法一览" class="headerlink" title="论文方法一览"></a><strong>论文方法一览</strong></h3><p>　　我们从论文的题目入手来了解一下这篇论文在讲什么。</p>
<p>　　首先是”Beyond Accuracy”：这是在说要超越Accuracy，这里Accuracy说的是NLP模型在各大数据集和任务上跑出的准确率，也即是性能的一种度量。</p>
<p>　　那既然要超越它总要有一个理由:</p>
<p>　　1.评估所用的训练-验证-测试划分集来估计模型的准确性时保留的数据集往往不全面。</p>
<p>　　2.测试集中往往包含与训练数据相同的偏差，这种方式可能高估了模型在真实世界的性能</p>
<p>　　3.通过Accuracy一刀切的方式很难找出模型失败在哪里，以及如何修复它。</p>
<p>　　对此本文提出的Beyond 方式又是如何呢？</p>
<p>　　Behavioral Testing of NLP Models with CheckList！也即用CheckList对NLP模型做行为测试。</p>
<h4 id="1、We-should-test-NLP-models"><a href="#1、We-should-test-NLP-models" class="headerlink" title="1、We should test NLP models"></a><strong>1、We should test NLP models</strong></h4><p>　　训练NLP模型的主要目标之一是泛化，虽然Accuracy是评价泛化的主要方法，但它往往高估了NLP模型的性能，用于评估模型的替代方法要么侧重于单个任务，要么侧重于特定的行为，benchmark的准确性不足以评估NLP模型。</p>
<p>　　除此之外许多额外的评估方法已经被提出来了，例如评估对噪声或对抗性变化的鲁棒性、公平性、逻辑一致性、可解释、诊断数据集和交互式错误分析。然而，这些方法要么侧重于单个任务，如问答或自然语言推理，要么侧重于一些能力（如鲁棒性），因此没有提供关于如何评估模型的全面指导。</p>
<p>　　因此在这这篇论文中，作者提出了CheckList(检查表)，一种新的评估方法和配套工具，用于NLP模型的综合行为测试。</p>
<h4 id="2、Software-engineering-gt-NLP"><a href="#2、Software-engineering-gt-NLP" class="headerlink" title="2、Software engineering-&gt;NLP"></a><strong>2、Software engineering-&gt;NLP</strong></h4><p>　　软件工程研究提出了测试复杂软件系统的各种范式和工具。特别是“行为测试”（黑盒测试）是指在不了解内部结构的情况下，通过验证输入输出行为来测试系统的不同能力。虽然有明显的相似之处，但软件工程的许多见解还没有应用到NLP模型中。</p>
<p>　　作者借鉴软件工程中行为测试的原理提出了CheckList：一种和模型、任务都无关的测试方法，它使用三种不同的测试类型来测试模型的各个功能。</p>
<p>　　作者用三个任务的测试来说明检查表的效用，识别商业和SOTA模型中的关键错误。在一项用户研究中，一个负责商业情绪分析模型的团队在一个经过广泛测试的模型中发现了新的、可操作的bug。在另一个用户研究中，使用CheckList的NLP实践者创建了两倍多的测试，发现的bug几乎是没有检查表的用户的三倍。</p>
<p>　　<img src="https://i.loli.net/2020/10/28/qk64rwGIt1lBJWE.png" alt="img"></p>
<p>　　图1</p>
<h4 id="3、What-is-CheckList"><a href="#3、What-is-CheckList" class="headerlink" title="3、What is CheckList"></a><strong>3、What is CheckList</strong></h4><p>　　CheckList包括一个通用语言能力和测试类型的矩阵，有助于全面的测试构思，以及一个快速生成大量不同测试用例的软件工具。从概念上讲，用户通过填写矩阵中的单元格来“检查”模型（图1），每个单元格可能包含多个测试。CheckList应用了“测试与实现脱钩”的行为测试原则，即将模型视为一个黑盒，允许对不同数据上训练的不同模型进行比较，或者对不允许访问训练数据或模型结构的第三方模型进行比较。</p>
<h4 id="4、What-to-test：capabilities"><a href="#4、What-to-test：capabilities" class="headerlink" title="4、What to test：capabilities"></a><strong>4、What to test：capabilities</strong></h4><p>　　CheckList通过提供适用于大多数任务的语言能力列表，指导用户测试什么。CheckList引入了不同的测试类型，比如在某些干扰下的预测不变性，或者一组“健全性检查”的性能。</p>
<p>　　虽然测试单个组件是软件工程中的常见实践，但现代NLP模型很少一次只构建一个组件。相反，CheckList鼓励用户考虑如何在手头的任务上表现出不同的自然语言能力，并创建测试来评估这些能力的模型。例如，词汇+POS能力取决于一个模型是否具有必要的词汇，以及它是否能够恰当地处理具有不同词性的单词对任务的影响。对于情绪，我们可能需要检查模型是否能够识别带有积极、消极或中性情绪的单词，方法是验证它在“这是一次很好的飞行”等示例上的行为。</p>
<p>　　基于此，作者建议用户至少考虑以下性能（capabilities）：</p>
<p>　　词汇+POS（任务的重要单词或单词类型）</p>
<p>　　Taxonomy（同义词、反义词等）</p>
<p>　　健壮性（对拼写错误、无关更改等）</p>
<p>　　NER（正确理解命名实体）</p>
<p>　　公平性</p>
<p>　　时态（理解事件顺序）</p>
<p>　　否定</p>
<p>　　共指（Coreference），</p>
<p>　　语义角色标记（理解诸如agent、object等角色）</p>
<p>　　逻辑（处理对称性、一致性和连词的能力）。</p>
<p>　　通过以上，CheckList实现包括多个抽象，帮助用户轻松生成大量测试用例，例如模板、词典、通用扰动、可视化和上下文感知建议。然而此功能列表并非详尽无遗，而是用户的一个起点，用户还应提供特定于其任务或域的附加功能。</p>
<h4 id="5、How-to-test"><a href="#5、How-to-test" class="headerlink" title="5、How to test"></a><strong>5、How to test</strong></h4><p>　　作者提示用户使用三种不同的测试类型来评估每个功能：最小功能测试、不变性和定向期望测试（矩阵中的列）。</p>
<p>　　1）最小功能测试（MFT）:它是受软件工程中单元测试的启发的一组简单的示例（和标签）的集合，用于检查功能中的行为。MFT类似于创建小而集中的测试数据集，尤其适用于在模型使用快捷方式处理复杂输入而不实际掌握功能的情况下进行检测。</p>
<p>　　<img src="https://i.loli.net/2020/10/28/2bFIGQ17wgVB3su.png" alt="img"></p>
<p>　　2）不变性测试（INV）：当对输入应用保留标签的扰动并期望模型预测保持不变时。不同的功能需要不同的扰动函数，例如，更改NER情感功能的位置名称，或者引入输入错误来测试健壮性能力。</p>
<p>　　<img src="https://i.loli.net/2020/10/28/c4Wa9IZzusY1Kj7.png" alt="img"></p>
<p>　　3）定向期望测试（DIR）：与不变性测试类似，只是标签会以某种方式发生变化。例如，我们预计，如果我们在针对某家航空公司的推文末尾添加“You are lame.”（图1C），情绪不会变得更积极。</p>
<p>　　<img src="https://i.loli.net/2020/10/28/Y78FjaetnpdgOJb.png" alt="img"></p>
<h4 id="6、可视化效果"><a href="#6、可视化效果" class="headerlink" title="6、可视化效果"></a><strong>6、可视化效果</strong></h4><p>　　调用test.visual_summary()</p>
<p>　　<img src="https://dingyue.ws.126.net/2020/0711/f079207eg00qdafs60095d200hr005pg00it0061.gif" alt="img"></p>
<p>　　在代码中调用suite.summary()（与test.summary相同）或suite.visual_summary_table() 显示测试结果如下：</p>
<p>　　<img src="https://dingyue.ws.126.net/2020/0711/c3640090g00qdafs701u7d200hr00bcg00it00c0.gif" alt="img"></p>
<p>　　模型保存和加载：精简至极！</p>
<p>　　<img src="https://i.loli.net/2020/10/28/KQDGslUnygeLESV.png" alt="img"></p>
<h4 id="7、更方便的大规模生成测试用例"><a href="#7、更方便的大规模生成测试用例" class="headerlink" title="7、更方便的大规模生成测试用例"></a><strong>7、更方便的大规模生成测试用例</strong></h4><p>　　用户可以从头开始创建测试用例，也可以通过扰动现有的数据集来创建测试用例。从头开始可以更容易地为原始数据集中可能未充分表示或混淆的特定现象创建少量高质量测试用例。然而，从头开始编写需要大量的创造力和努力，这通常会导致测试覆盖率低或者生成成本高、耗时长。扰动函数很难编写，但同时生成许多测试用例。为了支持这两种情况，作者提供了各种抽象，从零开始扩展测试创建，并使扰动更容易处理。</p>
<h4 id="8、使用CheckList测试SOTA模型"><a href="#8、使用CheckList测试SOTA模型" class="headerlink" title="8、使用CheckList测试SOTA模型"></a><strong>8、使用CheckList测试SOTA模型</strong></h4><p>　　作者通过付费API 检查了以下商业情绪分析模型：微软的文本分析、谷歌云的自然语言和亚马逊的Constract。我们还检查了在SST-23（acc:92.7%和94.8%）和QQP数据集（acc:91.1%和91.3%）上微调的BERT base和RoBERTa base。对于MC，作者使用了一个经过预训练的大BERT 微调阵容，达到93.2 F1。</p>
<p>　　<img src="https://i.loli.net/2020/10/28/pn7OqdKUx4shRLD.png" alt="img"></p>
<h4 id="9、测试商业系统"><a href="#9、测试商业系统" class="headerlink" title="9、测试商业系统"></a><strong>9、测试商业系统</strong></h4><p>　　作者联系了负责微软服务销售的通用情绪分析模型的团队（表1中的q）。由于它是一个面向公众的系统，模型的评估过程比研究系统更全面，包括公开可用的基准数据集以及内部构建的重点基准（例如否定、emojis）。此外，由于该服务已经成熟，拥有广泛的客户群，因此它经历了许多错误发现（内部或通过客户）和后续修复的周期，之后在基准测试中添加了新的示例。</p>
<p>　　作者的目标是验证检查表是否会增加价值，即使在这样的情况下，模型已经用当前的实践进行了广泛的测试。</p>
<p>　　作者邀请小组参加了一个持续约5小时的检查表会议。该团队集思广益地进行了大约30个测试，涵盖了所有功能。</p>
<p>　　从质量上讲，该小组称检查表非常有用：</p>
<p>　　（1）他们测试了他们没有考虑过的能力；</p>
<p>　　（2）他们测试了他们考虑过但不在benchmark中的能力；</p>
<p>　　（3）甚至他们有基准的能力（例如否定）也用检查表进行了更彻底和系统的测试。</p>
<p>　　他们发现了许多以前未知的错误，他们计划在下一个模型迭代中修复这些错误。最后，他们表示，他们肯定会将检查表纳入他们的开发周期，并要求访问我们的实现。</p>
<h4 id="10、用户研究"><a href="#10、用户研究" class="headerlink" title="10、用户研究"></a><strong>10、用户研究</strong></h4><p>　　作者进行了一项用户研究，以在一个更可控的环境中进一步评估检查表的不同子集，并验证即使是没有任务经验的用户也能获得洞察并发现模型中的错误。</p>
<p>　　尽管用户在使用CheckList时不得不解析更多的指令和学习新的工具，但他们同时为模型创建了更多的测试。</p>
<p>　　在实验结束时，作者要求用户评估他们在每个特定测试中观察到的失败的严重程度，研究结果令人鼓舞：有了检查表的子集，没有经验的用户能够在2小时内发现SOTA模型中的重大缺陷。此外，当被要求对检查表的不同方面进行评分时（1-5分），用户表示，测试环节有助于他们进一步了解模型，功能帮助他们更彻底地测试模型，模板也是如此。</p>
<p>　　评估特定语言能力的一种方法是创建挑战性数据集。我们的目标不是让检查表取代挑战或基准数据集，而是对它们进行补充。CheckList保留了挑战集的许多优点，同时也减轻了它们的缺点：用模板从头开始编写示例提供了系统控制，而基于扰动的INV和DIR测试允许在未标记的自然发生的数据中测试行为。</p>
<p>　　最后用户研究表明，CheckList可以轻松有效地用于各种任务：用户在一天内创建了一个完整的测试套件进行情绪分析，两个小时内创建了的MFTs，这两个都揭示了之前未知的严重错误。</p>
<h3 id="专访吴彤霜：最佳论文何以花落此家"><a href="#专访吴彤霜：最佳论文何以花落此家" class="headerlink" title="专访吴彤霜：最佳论文何以花落此家"></a>专访吴彤霜：最佳论文何以花落此家</h3><p>　　到这里我们大概明白了这篇论文到底在讲什么，但是我们还是心存疑惑，何以它能获得最佳论文殊荣？</p>
<p>　　<strong>以下为专访实录：</strong></p>
<p>　　<strong>AI 科技评论：</strong>首先恭喜您和您的团队斩获ACL2020最佳论文！我们想先了解一下这项工作的完成大概花了多长时间，把软件测试带入NLP模型检测的想法是最近才有的吗还是说之前就有了最近才实现？</p>
<p>　　<strong>吴彤霜：</strong>这个项目最早是一作快博士毕业时我们开始合作的，中间因为各种原因搁置了一段时间，实际做大概一年吧。引用软件测试应该可以算是一个新的想法。以前有很多nlp模型分析的论文本质上也可以说是我们论文里提到的那种“行为测试” (behavioral testing)，比如各种NLI challenge set。只不过这些工作大部分是针对某一个任务在做某个特定种类的分析，每次都要从头开始。我们工作其中的一个主要的一个贡献就是把这些分析做归一化，提供一个测试框架+开源系统。</p>
<p>　　<strong>AI 科技评论：</strong>这项测试系统是不是可以理解为对抗扰动系统啊？或者相比有什么优势呢？</p>
<p>　　<strong>吴彤霜：</strong>不变性测试 (INVariant test) 可以相当于扰动，就是模型在预测一个句子s和经修改后的版本s’时结果类似。CheckList还支持别的测试类别 (test type)：定向测试 (DIRectional test) 是用来测试预测结果的特定变化，最小功能测试 (Min Func Test) 不需要有配对的例子，只要一个能生成单个测试例句的模板就可以了。</p>
<p>　　只和INV（不变性测试 ）相比而言，现在NLP的大部分对抗句经常是在改拼写或者会产生乱码，比较难保证句子的连贯性，而能保证句子连贯性的居多是改近义词 (it’s a good movie -&gt; it’s a great movie)。CheckList因为允许自定义改写函数 (perturbation function)，所以可以更多样地测试模型的性能，比如看情感分析模型是否能辨认虚拟语气 (it’s a bad movie -&gt; it would have been a good movie)。这种测试也更系统化，因为可以生成很多对改写方法类似的句子/测试用例 (test case)。</p>
<p>　　当然相应的checklist的自动化就比较差，需要人来定义这些测试 :)</p>
<p>　　<strong>AI 科技评论：</strong>请问你们团队成员之前有过软件测试的经验吗，在CheckList的设计环节有什么亮点以及代码实现过程中有什么难点？</p>
<p>　　<strong>吴彤霜：</strong>应该不算有经验，没有在工业界实战过，顶多就是在软工课写单元测试，所以最开始其实也认真学习了一下软工 :)</p>
<p>　　设计上我觉得最大的亮点是对于性能 (capability) 的定义 。我们遇到一个瓶颈就是试图给每个NLP task设计需要测试的不同方面，但这样就非常繁琐，也失去了可拓展性。直到后来我们和其他researcher聊的时候意识到其实大部分的模型需要测试的“capability”基本比较稳定，只是不同任务里对标签的影响会有区别，比如[改主语]对NLI影响会比对情感分析要大。这样一个稳定的capability集合就让整个框架干净了很多。</p>
<p>　　开源上，其实NLP部分还是比较整洁的，但是为了让大家能比较流畅地在notebook里浏览和回顾test集，我们下了很大功夫研究怎们做交互插件，是一个大坑，但是最终效果还挺好看的，可以到readme里看看preview感受一下，哈哈。</p>
<p>　　写作上，因为marco在微软，我们很幸运能近水楼台找微软情感分析的工程组来做用户研究，让我们真的看到了CheckList在已经被认为是大规模测试过的模型仍然很有用。</p>
<p>　　<strong>AI 科技评论：</strong>很开心你们把这项工作开源，我想这项工作只是一个开始对吗？（大家都可以在你们开源的代码上进行哪些尝试和改进呢，比如自定义测试模板之类）</p>
<p>　　<strong>吴彤霜：</strong>最重要的是希望能看到大家提出的测试实例！其实比起很多NLP模型，CheckList是一个比较依靠人的力量的项目，测试者仔细设计实例才能用它最大程度暴露模型可能存在的缺陷。我们考虑的一个想法是希望可以做一个类似模型排行榜的测试榜，大家可以上传分享自己的测试集，甚至是顶或者踩别人的测试，最终让每个任务都能有一个比较稳定的测试集，也方便模型间的比较。</p>
<p>　　其次，我们也很期待看到大家会不会有关于如何让CheckList更自动化的想法，实现一键测试这个终极目标 :)</p>
<p>　　以及更研究向的：</p>
<p>　　我个人对于设计更稳定的测试也很感兴趣。CheckList对具体实例比较敏感，不同人在测试同一个模型性能时，如果实例设计不同，最终测试结果可能会有一些偏差。有没有什么交互手段能帮助测试者尽量穷尽一个性能所有的相关改写？甚至还有没有什么办法能慢慢形成一些自动的测试拓展？这个可能也和上面提到的自动化有一些关系。</p>
<p>　　最后测试带来的一个恒久不变的问题：so what？一个模型有问题之后，应该用什么样的标准来决定一个模型是不是可以被公开部署 (比如可能公平性测试的容错率可能远低于拼写错误)？应该如何改进它？</p>
<p>　　<strong>AI 科技评论：</strong>请问软件测试的思想只适用于NLP领域吗 ，在CV领域可行吗，应该怎么去设计测试系统？</p>
<p>　　<strong>吴彤霜：</strong>我相信是可行的！抽象来讲，本文图1的这种框架似乎能直接套用在CV上。</p>
<p>　　比如说一个最简单的狗和狼的分类，这个模型首先得能辨认有动物出现 (MFT)，然后改变图片的背景应该不影响预测 (INV)，但改变动物的头的形状应该是要影响的 (DIR)。vision里的“改写”效果其实比NLP好很多，也许更好用也说不定 :)</p>
<p>　　对设计系统而言，我觉得比较重要的是抽取基本组件。在NLP版本的CheckList里有一个重要组件就是写生成template/模板；也许在vision里则是需要提供一些基础像素之类的。</p>
<p>　　当然也可以考虑除了行为和单元测试之外的测试思想，比如如果是pipeline模型，考虑如何设计集成测试也许也会很有用 :)</p>
<p>　　<strong>AI 科技评论：</strong>可以简单介绍一下你们的团队成员吗，以及你们的近期工作、未来研究方向？</p>
<p>　　<strong>吴彤霜：</strong>隆重介绍一下没有出镜的一作吧，marco也是华大的博士，2018年毕业以后就加入了微软研究院，主要在做模型可解释性和分析，之前很有名的LIME（一种解释机器学习模型的方法——Local Interpretable Model-Agnostic Explanations）就是出自他手。除了CheckList，他今年在CVPR上也有一篇合作论文，是分析vqa model的稳定性的。现在主要在做vision模型的错误分析以及模型比较。</p>
<p>　　我们现在也在合作一个新工作，这项工作更多是关于如何人去探索模型的可解释性。虽然现在主要做的都是人如何检查模型，但是我们对于模型如何能反过来规范人或者帮助人也很感兴趣 :) 三四作Carlos和Sameer都是marco的导师，分别是ML和NLP的大佬。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>　　虽然CheckList目前也有一些不足比如CheckList不能直接用于非行为问题，例如数据版本控制问题、标记错误、注释器偏差、最坏情况下的安全问题或缺乏可解释性。</p>
<p>　　但是不可否认的是，使用CheckList创建的测试可以应用于任何模型，这使得它很容易被纳入当前的基准测试或评估pipeline中。用户研究表明，CheckList很容易学习和使用，对已经对模型进行了长时间测试的专家用户以及在任务中缺乏经验的实践者都很有帮助。</p>
<p>　　另外对吴同学的专访，我们相信， 本篇论文工作确实开创地把软件测试系统引入NLP模型的测试之中并且提供了完善的测试工具。 这将会给社区和企业带来很大的商业价值，比如CheckList测试工具将会节省很大的人力成本。</p>
<p>　　最后，我们相信，这种系统引进软件测试的思想也将会在CV乃至整个AI领域大有作为。</p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Blank Language Model</title>
    <url>/2020/12/30/Blank-Language-Model/</url>
    <content><![CDATA[<h3 id="yaya-序"><a href="#yaya-序" class="headerlink" title="yaya 序"></a>yaya 序</h3><h4 id="直接做文本填充任务的模型"><a href="#直接做文本填充任务的模型" class="headerlink" title="直接做文本填充任务的模型"></a>直接做文本填充任务的模型</h4><ul>
<li><p>目前已知的做文本填充的模型有ilm, BLM</p>
<blockquote>
<p><strong>ilm</strong>: <strong>(ACL 2020) Enabling Language Models to Fill in the Blanks</strong></p>
<p><strong>BLM</strong>:  <strong>(EMNLP 2020) Blank Language Models</strong></p>
<p>Text Infilling</p>
<p>Langsmith An Interactive Academic Text Revision System</p>
<p>MaskGAN Better Text Generation via Filling in the__</p>
<p> (ACL 2020) INSET Sentence Infilling with INter-SEntential Transformer</p>
</blockquote>
</li>
</ul>
<h4 id="直接可以做文本填充任务的模型"><a href="#直接可以做文本填充任务的模型" class="headerlink" title="直接可以做文本填充任务的模型"></a>直接可以做文本填充任务的模型</h4><ul>
<li><p>其次，做文本任务 对抗的一些任务，其实也可以看做文本填充</p>
<ul>
<li>AdvExpander Generating Natural Language Adversarial Examples by Expanding Text</li>
<li>BERT-ATTACK Adversarial Attack Against BERT Using BERT</li>
<li>Generate Your Counterfactuals Towards Controlled Counterfactual Generation for Text</li>
</ul>
</li>
<li><p>另外 padlepadle/ ERNIE 的预训练任务，不使用 sub-word 来随机掩码，而是使用 fragment来做随机掩码，其预训练模型，也是可以用来做文本填充的。但是可能性能没有那么可靠</p>
</li>
</ul>
<h3 id="BLM介绍"><a href="#BLM介绍" class="headerlink" title="BLM介绍"></a>BLM介绍</h3><p>来源： <a href="https://mp.weixin.qq.com/s/cVUT4FMpgqARuWf5dWY0bA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/cVUT4FMpgqARuWf5dWY0bA</a></p>
<p>讲者提出了填空语言模型（Blank Language Model, BLM），<strong>该模型通过动态创建和填充空白来生成序列</strong>。空白用于控制要扩展序列的那一部分，使BLM成为各种文本编辑任务的理想选择。<strong>该模型可以从单个空白或在指定位置带有空白的部分完成文本开始，迭代地确定要在空白中放入哪个单词以及是否插入新的空白，并在没有新的空白填充时停止生成。</strong>使用边缘似然的下界可以有效地训练BLM。在填充缺失文本的任务上，BLM在准确性和流利性方面均明显优于所有其他方法。在情感迁移和修复古文字的实验中，证明该框架具有广泛的应用潜力。</p>
<h4 id="一、动机：传统语言模型的局限性"><a href="#一、动机：传统语言模型的局限性" class="headerlink" title="一、动机：传统语言模型的局限性"></a><strong>一、动机：传统语言模型的局限性</strong></h4><p>传统的语言模型通常是从左到右对文本序列进行建模，其模式是，首先生成第一个词，然后以第一个词作为condition来生成第二个词，继而以第二个词为condition生成第三个词，如此迭代计算后一个词。</p>
<p>该方法的优势在于算法简单、有效。但大多情况下，并不需要从头开始生成文本，而是已有部分文本，想自动生成剩下的部分内容。比如，文本编辑，是基于已有的draft，修改文本中任意位置的内容；或是template filling，针对一些表格等具有固定格式的文件，比如医疗或者法律文件等进行填空；或是text restoration，比如一些文件可能在任意位置缺失相关内容，需要做的是复原损失部分。由于Left-to-Right Language Model仅仅考虑blanks左边的文本语境，不能很好地对这些应用进行建模。</p>
<p><img src="https://i.loli.net/2020/12/30/b4piu9OP6x3VINC.png" alt="image-20201230120139264" style="zoom:50%;"></p>
<p><strong>因此，讲者提出了Blank Language Model（BLM）</strong>，其输入形式为任意文本，blanks可存在于文本的任意位置；每一个blank可以对应任意多个单词；且BLM模型会结合上下文语境决定需要填充几个单词。BLM与Mask Language Model的区别在于，Mask Language Model的一个mask只能对应一个单词，因此如果预先不知道blank中间丢失多少个单词，就不能使用Mask Language Model来实现。</p>
<p><img src="https://i.loli.net/2020/12/30/uN759vob1MEhyRO.png" alt="image-20201230120251358" style="zoom:50%;"></p>
<h4 id="二、实现：什么是BLM"><a href="#二、实现：什么是BLM" class="headerlink" title="二、实现：什么是BLM?"></a>二、实现：什么是BLM?</h4><h4 id="1）BLM工作原理介绍"><a href="#1）BLM工作原理介绍" class="headerlink" title="1）BLM工作原理介绍"></a><strong>1）BLM工作原理介绍</strong></h4><p><strong>BLM具体是如何实现填空的呢？</strong>首先存在一个画布，有单词和blank，其中blank用来控制单词能被放置的位置；然后BLM模型在这个画布上动态进行修改，每一步都会选择一个待填充的blank。</p>
<p>由于每个blank可以对应任意数量的词，因此当填充这个word w之后，还要决定是不是只填一个字，或者在w左边、右边、还是两边各补上blank。由此每个blank就可以继续迭代，且被扩展成任意多个词，当没有blank留下，模型达到终止条件。其实现步骤如图3所示。</p>
<p><img src="https://i.loli.net/2020/12/30/41uMQY2dqSroxZD.png" alt="image-20201230120357144" style="zoom:50%;"></p>
<p>yaya 觉得以下这个例子更好一些</p>
<p><img src="https://i.loli.net/2020/12/30/1N9C5R4ecJM6ADB.png" alt="image-20201230120728774" style="zoom: 50%;"></p>
<p><strong>讲者举如下例子，进一步说明模型的实现步骤。</strong>原句是They also have <strong><strong> which </strong></strong>.通过从canvas中一步步选择合适的word和blank，直至句子中没有新的blank生成为止，实现句子填空。</p>
<p><strong>继而，讲者概括BLM的工作方式</strong>，类似于一个Grammar，如图4所示。其与传统语法<strong>Context-Free Grammar</strong>的区别在于：讲者所提出的模型在<strong>Production rules</strong>上面的概率分布是取决于模型参数和当前的<strong>context</strong>。</p>
<p><img src="https://i.loli.net/2020/12/30/ucYZU5Ld7T9tysv.png" alt="image-20201230120451316" style="zoom: 50%;"></p>
<h4 id="2）BLM框架介绍"><a href="#2）BLM框架介绍" class="headerlink" title="2）BLM框架介绍"></a>2）BLM框架介绍</h4><p>首先采用transformer模块，将input通过这个transformer以得到一系列的representation，每个representation包含有其context信息；</p>
<p>然后将所有blank位置的representation通过Linear project和softmax得到blanks上的distribution，选择其中一个（假设是第二个）；</p>
<p>进一步将被选中的blank representation投影到整个vocabulary，由此可预测一个词，比方说预测really；</p>
<p>最后，将blank representation和被预测词的word embedding进行拼接，都输入给一个MLP进行如图所示的四种情况分类。假设是第四种情况，得到<strong><strong> really </strong></strong>，然后将其fill到第二个Blank中，并继续这个过程直至没有新的blank生成。</p>
<p><img src="https://i.loli.net/2020/12/30/9jZpWxPyeuR3Cdn.png" alt="image-20201230121033747" style="zoom: 50%;"></p>
<p>从一个初始的blank到一个没有blank的complete text这个过程称为<strong>trajectory</strong>，包括每一步的canvas和action；每一步的action包括了choose a blank，predict a word 以及create new blanks。</p>
<p>如果一个句子有n个单词，那么会有n！种不同的trajectory都可以生成它，每一种trajectory对应着不同的word insertion order。如图6所示的trajectory就对应着word insertion order “3 1 10 6 2 8 4 7 5 9” 。</p>
<p>因此，生成一个句子x的概率就是以所有trajectory/word insertion order生成它的概率之和，公式中的Sn为所有的n排列。而给定order，就可以确定每一步的canvas和action，概率可相应分解为每一步的概率的乘积。</p>
<p><img src="https://i.loli.net/2020/12/30/k4ZMPjR5TmFycXA.png" alt="image-20201230130236667" style="zoom:50%;"></p>
<p><strong>如何高效的训练BLM呢？</strong>讲者对上述的likelihood进行估计，对等式两边取log，并借助图7中蓝色不等式可得到最终评估的loss。但同时讲者介绍到该训练方式与left-to-right language model相比并不高效，原因在于：Left-to-Right Language Model在一个pass中是同时计算了n个词的Loss，而上述公式在一个pass中只计算了一个action loss。</p>
<p>基于此，讲者进一步介绍到ctx,o只与word insertion order o的前t个词有关，因此可在一个pass中，将前t个order相同且在t+1时不同的trajectory进行组合，共同计算loss。同时由于EOt+2:n不会影响第t步的action和canvas，则可改写最终的loss表达，实现在一个pass中计算期望n/2个action loss。</p>
<p><img src="https://i.loli.net/2020/12/30/2xnYKAswB6RO47o.jpg" alt="图片"></p>
<p>综上所述，BLM的training的规则如图8所示。讲者通过一个实例，详细介绍了模型的训练过程，给定sentence x，先sample t，再sample order o1:t，由此可构建动态画布ctx,o，并按照图7的loss进行训练。</p>
<p><img src="https://i.loli.net/2020/12/30/lUAgSP1uOX9r7sH.png" alt="image-20201230130440892" style="zoom:50%;"></p>
<p>训练好BLM后，可采用greedy decoding或beam search来填充输入文本中的空白。需要注意的是，greedy decoding/beam search寻找的不是具有最大边缘似然p(x;θ)的sentence，而是具有最大联合似然p(x;o;θ)的sentence 和trajectory。</p>
<h4 id="三、实验"><a href="#三、实验" class="headerlink" title="　三、实验"></a>　三、实验</h4><p>讲者主要进行了4种不同的实验验证模型的有效性，分别为<strong>Text infilling，Ancient text restoration，Sentiment transfer以及Language modeling。</strong>下述针对<strong>Text infilling</strong>的实验进行阐述。</p>
<h5 id="1）Text-infilling"><a href="#1）Text-infilling" class="headerlink" title="1）Text infilling"></a>1）Text infilling</h5><p>选择Yahoo Answers（100k的文档，且最大长度的为200个单词）作为实验数据集；在该数据集上随机mask掉比例为r的tokens，将连续的masked tokens用blank代替，由此得到的数据集作为测试数据集。在评价指标方面，分别选择Accuracy和Fluency来评价模型的有效性。具体是指通过计算初始文档与模型filling后文档间的BLEU score表征Accuracy；采用经过预训练的Left-to-Right Language Model计算perplexity表征Fluency。</p>
<p><strong>讲者分别选择以下模型作为在Baseline models:</strong></p>
<p><strong>a.BERT+LM</strong></p>
<p>指采用BERT模型得到每一个blank的representation，并将其输入给Left-to-Right Language Model生成不同blanks对应的tokens。</p>
<p><strong>b.Masked Language Model with oracle length (MLM)</strong></p>
<p>由于模型需要知道每一个blank对应单词个数，因此给定oracle length数量的masked tokens来代替blanks；此外MLM模型同时预测masked tokens时是相互独立的，并没有考虑filling的部分之间的consistency，因此使用most-confident-first heuristic来autoregressively一个一个进行填写。</p>
<p><strong>c.Insertion Transformer (Stern et al., 2019)</strong></p>
<p>该模型支持动态单词插入，与BLM不同，该模型可在所有位置插入，因此强制模型只在指定位置进行插入，避免出现较高的失败率。</p>
<p><strong>d.Seq2seq-full/fill (Donahue et al., 2020)</strong></p>
<p>指直接输出infill之后的句子序列，或者直接输出代替blanks的tokens并用分隔符“|”划分。这两种方法具有较高的失败率。</p>
<p><img src="https://i.loli.net/2020/12/30/2LU8x5dlnCcOJmH.png" alt="image-20201230131800545" style="zoom:50%;"></p>
<p>图a)</p>
<p><img src="https://i.loli.net/2020/12/30/aZrSFqPjty67nXu.png" alt="image-20201230131732735" style="zoom:50%;"></p>
<p>图 b)</p>
<p>图9 Text infilling 实验结果</p>
<p>实验结果如图9所示，其中图a)说明当mask ratio 越来越高时，所有模型的BLUE score都会降低，同时BLM表现出最高的BLUE score；图b)中BLM与InsT模型的perplexity要低于original data的perplexity，且当mask ratio 越来越高时，模型最终的output比原始data要更加typical，则perplexity会越来越低。</p>
<h4 id="四、结论与展望"><a href="#四、结论与展望" class="headerlink" title="四、结论与展望"></a>四、结论与展望</h4><p>讲者提出了BLM可以用来灵活地生成文本，其生成方式是动态创建以及填充blanks。实验表明BLM模型在Text infilling，Ancient text restoration和Sentiment transfer上具有很好的表现。</p>
<p>BLM也具有广阔的应用前景，比如Template filling，information fusion以及assisting human writing；同时BLM也可被扩展为conditional model，可以用来edit和refine机器翻译，或者在dialogue中根据给定内容生成一句话；最后可以探究BLM跟MLM/BERT在representation的学习上的差异性。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/8ld6oicYkZZtRCNqJf5KRcmmFmYpBTS6hibiad1Gyib2x0Lt4qGWjuMCERiaGibUT5ibK0ezrHch0nMNJqDnibRgELdMRQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>图12 结论与展望</p>
<h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a><strong>参考文献：</strong></h3><p>Mitchell Stern, William Chan, Jamie Kiros, and Jakob Uszkoreit. 2019. Insertion transformer: Flexible sequence generation via insertion operations. arXiv preprint arXiv:1902.03249.</p>
<p>Chris Donahue, Mina Lee, and Percy Liang. 2020. Enabling language models to fill in the blanks. arXiv preprint arXiv:2005.05339.</p>
<h3 id="论文地址："><a href="#论文地址：" class="headerlink" title="论文地址："></a><strong>论文地址：</strong></h3><p><a href="https://arxiv.org/pdf/2002.03079.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/2002.03079.pdf</a></p>
<h3 id="Github地址："><a href="#Github地址：" class="headerlink" title="Github地址："></a><strong>Github地址：</strong></h3><p><a href="https://github.com/Varal7/blank_language_model" target="_blank" rel="noopener">https://github.com/Varal7/blank_language_model</a></p>
]]></content>
      <categories>
        <category>NLP</category>
        <category>Text-Filling</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Bottom-Up and Top-Down Attention for Image Captioning and Visual Question Answering</title>
    <url>/2021/03/15/Bottom-Up-and-Top-Down-Attention-for-Image-Captioning-and-Visual-Question-Answering/</url>
    <content><![CDATA[<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>人类视觉系统存在两种attention机制。Top-down attention由当前任务所决定，我们会根据当前任务（即VQA中的问题），聚焦于与任务紧密相关的部分。Bottom-up attention指的是我们会被显著的、突出的、新奇的事物给吸引。</p>
<p>以前的方法用到的visual attention mechanisms大都属于top-down类型，即取问题作为输入，建模attention分布，然后作用于CNN提取的图像特征（image features）。然而，这种方法的attention作用的图像对应于下图的左图，没有考虑图片的内容。对于人类来说，注意力会更加集中于图片的目标或其他显著区域，所以作者引进Bottom-up attention机制，如下图的右图所示，attention作用于object proposal。</p>
<p><img src="https://i.loli.net/2021/03/15/p8WFURqkGw6iIfC.png" alt="image-20210315150105258" style="zoom:50%;"></p>
<h2 id="Basic-idea"><a href="#Basic-idea" class="headerlink" title="Basic idea"></a>Basic idea</h2><p>Bottom-Up注意力机制: 即基于目标（objects）或显著区域（salient image regions）来计算attention。具体来说，bottom-up机制基于Faster R-CNN，得到图片中每个目标或显著区域的特征向量（feature vector）表示。</p>
<p>Top-Down机制: 取question作为输入，建模特征权重（feature weightings）或者说attention分布。</p>
<h2 id="概括："><a href="#概括：" class="headerlink" title="概括："></a>概括：</h2><p><strong>（1）Bottom-Up</strong><br>使用Faster R-CNN 中的R-CNN来得到object feature。<br><strong>（2）Top-Down Attention</strong><br>得到了该层的隐层状态，并与object features  中的每一个<strong>v<sub>i</sub></strong>来计算一个attention 系数。<br><strong>（3）对object features 进行attention 权重求和</strong><br>得到image feature<br><strong>（4）Decoder：language LSTM</strong><br>输出预测单词</p>
<p><img src="https://i.loli.net/2021/03/15/IcK4HYAsGwjzPqv.jpg" alt="img" style="zoom: 67%;"><br><img src="https://i.loli.net/2021/03/15/lqZx5tngfd9r2Gs.jpg" alt="img" style="zoom:50%;"></p>
<h2 id="Bottom-Up"><a href="#Bottom-Up" class="headerlink" title="Bottom-Up"></a>Bottom-Up</h2><ul>
<li><strong>主要介绍一下Faster R-CNN 的训练过程</strong><br>（1）首先Resnet-101 是在ImageNet上预训练的<br>（2）Faster R-CNN在MS COCO上进行预训练<br>rpn 的score classification loss，bbox regression loss<br>r-cnn 的score classification loss，bbox regression loss<br>（3）Faster R-CNN在Visual Genome上再进行预训练<br>为了得到更好的特征表达，增加一个预测属性的输出： </li>
<li><strong>具体的网络：</strong><br>To predict attributes for region i, we concatenate the mean  pooled convolutional feature vi with a learned embedding  of the ground-truth object class, and feed this into an additional output layer defining a softmax distribution over each  attribute class plus a ‘no attributes’ class.</li>
</ul>
]]></content>
      <categories>
        <category>图像描述</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>Bridging by Word Image Grounded Vocabulary Construction for Visual Captioning</title>
    <url>/2020/08/01/Bridging-by-Word-Image-Grounded-Vocabulary-Construction-for-Visual-Captioning/</url>
    <content><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>当前 普遍使用的 CNN-RNN 策略，基于整个 training dataset构建 vocabulary，但是，这会<strong>导致生成的句子中的 N-grams 也是在训练集中常见的</strong>，但是语义上却与given image 无关。</p>
<p>为了解决这个问题，本文提出了构建一个 image-grounded vocabulary。具体地，提出了一个 two-step approach，通过结合 visual information 和 relationships among words来构建 新的vocabulary。</p>
<p>并提出了两个策略在 text generation过程中<strong>利用</strong>构建的vocabulary。（1）generator 从image-grounded vocabulary中挑选words （2）soft-attention聚合 vocabulary information 到RNN cell 中来生成下一个单词。</p>
<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p>当前生成单词的方式，是从整个vocab 中select，但是当描述一个 particular image时，the possible words 应该是从一小部分单词集中挑选出来。因此，可以想一个方案，在image caption generation 过程中，有效的约束 word selection space。这将会解决 生成的句子中常常是 irrelavant n-gram problem. </p>
<p>本文，提出构建一个 image-grounded vocabulary，</p>
<h3 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a>Approach</h3><p>整个结构包括两个阶段：(1) image-grounded vocabulary construction, (2) text generation with vocabulary constraints.</p>
<p><strong>The image-grounded vocabulary</strong> constructor builds a  vocabulary related to a given image.</p>
<p><strong>The text generator</strong> with vocabulary constraints generates captions using the constructed vocabulary in two different ways. (1) words generated are strictly limited to those in the image-grounded vocabulary. (2) words in the image-grounded vocabulary are re-weighted within the RNN cell such that they are more likely to be generated.</p>
<h4 id="Image-Grounded-Vocabulary-Construction"><a href="#Image-Grounded-Vocabulary-Construction" class="headerlink" title="Image-Grounded Vocabulary Construction"></a>Image-Grounded Vocabulary Construction</h4><p>caption 中的单词，一般可以分类两类，一类是直接与image content 相关的单词（entities or objects depicted in the image），另一类是function words or words which 没有和image content 有直接的对应关系。</p>
<p>本文假设， directly-related words 可以由视觉信息来决定，而第二类单词，可以由第一类单词之间的relationship 来决定。因此提出了两步策略来构建 image-grounded vocabulary。</p>
<ul>
<li><p>第一步</p>
<p>使用 <code>From captions to visual concepts and back</code> 中提到的方法，获取 textual concept as H.</p>
<p>H中words 与 image 的相关性分布：</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ghbctjwumaj30cz02ga9z.jpg" style="zoom:33%;"></p>
</li>
<li><p>第二步</p>
<p>计算  full vocabulary <code>V</code> 中单词的 相关性分数，</p>
<p>The probability distribution of words in <code>V</code>:</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ghbd1t40doj30if03b3yt.jpg" style="zoom:33%;"></p>
</li>
</ul>
<p>本文挑选 top k words 来构成 <strong style="color:red;">the image-grounded vocabulary ($W_i$) </strong>for given image.</p>
<h4 id="Text-Generation-with-Vocabulary-Constraints"><a href="#Text-Generation-with-Vocabulary-Constraints" class="headerlink" title="Text Generation with Vocabulary Constraints"></a>Text Generation with Vocabulary Constraints</h4><p>提出了两个不同的策略来利用 the image-grounded vocab-ulary $W_i$ 和 word relevance distribution  $S_i^{(V)}$ : 一种，使用$W_i$ 作为 hard constraint; 另一种，聚合每个单词的相关性到 RNN cell 来生成 caption.</p>
<p><strong>Generator with Hard Constraint</strong></p>
<p>正常的方法，是生成 full vocab 的 概率分布，然后取 argmax。</p>
<p>但是在 hard constraint 下，生成 $W_i$ 的概率分布，再取 argmax。</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ghbdj6x0ruj30m402haa0.jpg" style="zoom: 50%;"></p>
<p>对于在 $W_i$ 中没有出现的单词，打掩码：a mask operation $m_i$ is introduced  to replace the $j_{th}$ value in the vector with 1 if $w_j$ is not found in $W_i$ 。</p>
<p><strong>Generator with Soft Constraint </strong></p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ghbdt8khggj31cg0mw4i2.jpg" style="zoom:50%;"></p>
<p>图中展示的 image-grounded vocabulary 其实是 $S_i^{V}$</p>
<p>结合到RNN cell: </p>
<p>这个新的 RNN cell 结合了image-grounded vocabulary，因此，会更加容易生成该vocab中的单词。</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ghbe0h10qcj30pt0avmy9.jpg" style="zoom:33%;"></p>
]]></content>
      <categories>
        <category>图像描述</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>Bridging the Gap between Vision and Language Domains for Improved Image Captioning</title>
    <url>/2021/07/18/Bridging-the-Gap-between-Vision-and-Language-Domains-for-Improved-Image-Captioning/</url>
    <content><![CDATA[<p>本文认为视频描述模型分两步：</p>
<p> 1) first link the image modality to the text modality.</p>
<p>2) generate a semantically and grammatically correct descriptive sentence based on such textual guided visual information.</p>
<p>但是 目前的captioning models将这两步都融合在一个模块中，即decoder。由于视觉和语言领域之间的巨大差异，这类模型中的解码器必须将其大部分能力用于执行步骤1），从而分散注意力，无法高质量地完成步骤2）。</p>
<p>因此，本文conduct the step 1) in the encoder by enriching image features with textual concepts. Specifically, we provide complete semantics information for the image features. In implementations, our approach consists of a Textual Distilling Module (TDM) and a Textual Association Module (TAM).</p>
<p>The TDM focuses on distilling textual concepts to the corresponding visual objects. Since the textual concepts are single words and only represent a fraction of a semantics, we further introduce the TAM to group related concepts to form a complete semantics. For instance, we group three separated concepts “woman”, “tennis” and “playing” into a phrase “woman playing tennis”. </p>
<blockquote>
<p>yaya: 所以<font color="blue"><strong>其实TAM的提出完全是因为TDM存在不足</strong></font>。这恰恰也是本文的缺陷。因为即便TAM把相关的概念组合到一起，也存在失误的问题，毕竟没有显式的监督。</p>
</blockquote>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p><img src="https://i.loli.net/2021/07/19/MygTjfGBRxeCt9W.png" alt="image-20210719123527662"></p>
<h4 id="Image-Encoder-and-Concept-Extractor"><a href="#Image-Encoder-and-Concept-Extractor" class="headerlink" title="Image Encoder and Concept Extractor"></a>Image Encoder and Concept Extractor</h4><p>对于图像特征，使用在VIsual-Genome上预训练的 Region-CNN model （Bottom-Up and Top-Down）.</p>
<p>对于 textual concepts, 使用 弱监督多示例学习方法： From Captions to Visual Concepts and Back。具体而言，是在MS-COCO caption 数据集上的1000个视觉概念上训练的。提取的视觉概念包括 objects, attributes, 和 relationships。对于每张图片，提取20个文本概念， 集合 $T=\left\{w_{1}, w_{2}, \ldots, w_{m}\right\} \in \mathbb{R}^{m \times e}$ where $w_{i} \in \mathbb{R}^{e}$ refers to the embedding of the $i^{t h}$ concept.</p>
<h3 id="Textual-Distilling-Module"><a href="#Textual-Distilling-Module" class="headerlink" title="Textual Distilling Module"></a>Textual Distilling Module</h3><p>使用注意力机制来选择与图像最相关的 top-K 文本概念。</p>
<blockquote>
<p>yaya: 其实没有必要，毕竟上一步提取到的textual concepts 就是与该图像最相关的内容。而且说是叫蒸馏，也没有任何蒸馏的操作!!!</p>
</blockquote>
<h3 id><a href="#" class="headerlink" title=" "></a> </h3><h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><p>整体比较水，但是写作水平比较好。</p>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>Bridging the Gap between Training and Inference for Neural Machine Translation</title>
    <url>/2021/03/15/Bridging-the-Gap-between-Training-and-Inference-for-Neural-Machine-Translation/</url>
    <content><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>本文是ACL 2019 的 最佳长文奖。</p>
<p><strong style="color:red;">论文主要解决神经网络在翻译领域，训练和测试时所用的上文信息不同造成的偏差问题。</strong></p>
<p><strong>论文提出了新的训练方法，而非新的模型。读完之后，发现这种方法适用于许多领域的训练-测试不匹配的问题，如：阅读理解、语言模型。</strong></p>
<h2 id="2-存在的问题"><a href="#2-存在的问题" class="headerlink" title="2. 存在的问题"></a>2. 存在的问题</h2><p>传统的神经机器翻译有两个问题：</p>
<ul>
<li><strong>exposure bias</strong> （训练和测试时所用的上文信息不同的问题）</li>
<li><strong>overcorrection</strong>（过度矫正）</li>
</ul>
<h3 id="2-1-exposure-bias"><a href="#2-1-exposure-bias" class="headerlink" title="2.1 exposure bias"></a>2.1 exposure bias</h3><p>那么，什么叫<code>训练和测试时所用的上文信息不同的问题</code>呢？</p>
<p>训练时, 无论上一步模型的预测输出是什么，在当前步decoder模型的输入都是ground truth word的，即：模型的输入都是正确的，如：<strong>are</strong> 。</p>
<p><img src="https://i.loli.net/2021/03/14/tMrJqWR1huDFHQ4.png" alt="image-20210314192737439" style="zoom:33%;"></p>
<p>在测试时，由于没有正确答案，所以用模型预测的上一个字的结果作为输入，如：is、 you 。</p>
<p>这就导致了在测试时，<strong>如果在某个地方预测错，那么之后模型的输入都是错误的</strong>，这就造成了错误会一直累积；或许模型在某个地方所预测的是另一种翻译的词，但是在训练时没有碰到过这种情况，所以模型无法进行处理。</p>
<p>这种偏差叫做<code>exposure bias</code>。</p>
<h3 id="2-2-overcorrection"><a href="#2-2-overcorrection" class="headerlink" title="2.2 overcorrection"></a>2.2 overcorrection</h3><p>训练翻译模型时，还会碰到另一个问题：<strong>overcorrection</strong>（过度矫正）</p>
<p>什么意思呢？</p>
<p><img src="https://i.loli.net/2021/03/15/k8USC1drMGB6Jwh.png" alt="img"></p>
<p>当模型在第三个位置预测出‘abide’时，为了让这句话的loss最小，模型之后会预测 with the rule，但是 abide with the rule 是错误的；正确的应该是 abide by the rule。</p>
<p>注解: abide 与 by 搭配，而不是与with 搭配。</p>
<h2 id="3-Method"><a href="#3-Method" class="headerlink" title="3. Method"></a>3. Method</h2><p><img src="https://i.loli.net/2021/03/14/QLSZEk4dqNln6jV.png" alt="image-20210314193828727" style="zoom:50%;"></p>
<p>为了消除或减轻train阶段和infer阶段的差别, 论文提出从真实的词 $y_{t-1}^{*}$ 和预测的词 $y_{t-1}^{\text {oracle }}$ 中抽样, decoder根据抽样的词来预测下一个词 $y_{t}$ 。使用论文提出的方法, 在时间步 $t$ 预测 $y_{t}$ 分为三步:</p>
<p><img src="https://i.loli.net/2021/04/08/lZw4sXbeunLGBfq.png" alt="image-20210408132802746"></p>
<h3 id="3-1-Oracle-Word-Selection"><a href="#3-1-Oracle-Word-Selection" class="headerlink" title="3.1 Oracle Word Selection"></a>3.1 Oracle Word Selection</h3><p>传统的方法中， decoder会根据上一个时间步真实的 $y_{t-1}^{*}$ 来预测 $y_{t}$ 。</p>
<p>为了消除train阶段的infer阶段的 差别，可以从预测的词中选择oracle word $y_{t-1}^{\text {oracle }}$ 来代替 $y_{t-1^{\circ}}^{*}$ </p>
<p>一种方法是每个时间步采用词级别的 greedy search来生成oracle word, 称为word-level oracle(WO)。另一种方法是采用beam-search, 扩大搜索空间, 用句子级的衡量指标(如：BLEU)对beam-search的结果进行排序，称为sentence-level oracle(SO).</p>
<h4 id="3-1-1-Word-Level-Oracle"><a href="#3-1-1-Word-Level-Oracle" class="headerlink" title="3.1.1 Word Level Oracle"></a>3.1.1 <strong>Word Level Oracle</strong></h4><p><img src="https://i.loli.net/2021/03/14/oJlrVILE6FgkcyM.png" alt="image-20210314200245535" style="zoom: 33%;"></p>
<p><img src="https://i.loli.net/2021/03/14/wc7Ql4js39KBCXg.png" alt="image-20210314200310765" style="zoom:33%;"></p>
<p>选择 $y_{t-1}^{\text {oracle }}$ 最简单直观的方法是, 在时间步$t$-1 , 选择公式 $P_{t-1}$ 中概率最高的词作为 $y_{t-1}^{\text {oracle }},$ 如Fig.2所 示。 为了获得更健壮的 $y_{t-1}^{\text {oracle }}$, 更好地选择是使用<a href="https://www.cnblogs.com/initial-h/p/9468974.html" target="_blank" rel="noopener">gumbel max技术</a>来从分类分布中进行抽样, 如 Fig.3所示。<br>具体地讲, 将gumbel noise <strong style="color:blue;">$\eta$</strong> 作为正则化项加到decoder的预测概率分布上，进而再做softmax操作。</p>
<p>$\eta=-\log (-\log u)$<br>$\tilde{o}_{j-1}=\left(o_{j-1}+\eta\right) / \tau$<br>$\tilde{P}_{j-1}=\operatorname{softmax}\left(\tilde{o}_{j-1}\right)$</p>
<p>其中变量 $u \sim U(0,1)$ 服从均匀分布。 $\tau$ 为温度系数, 当 $\tau \rightarrow 0$ 时， 公式(8)的softmax()逐渐相当于<br>$\operatorname{argmax}()$ 函数 $;$ 当 $\tau \rightarrow \infty$ 时, $\operatorname{softmax}()$ 函数逐渐相当于均匀分布。</p>
<p>则 $y_{t-1}^{\text {oracle }}$ 为：$y_{j-1}^{\text {oracle }}=\operatorname{argmax}\left(\tilde{P}_{j-1}\right)$</p>
<p>需要注意的是gumbel noise $\eta$ 只用来选择oracle word，而不会影响train阶段的目标函数。</p>
<h4 id="3-1-2-Sentence-Level-Oracle"><a href="#3-1-2-Sentence-Level-Oracle" class="headerlink" title="3.1.2 Sentence Level Oracle"></a>3.1.2 <strong>Sentence Level Oracle</strong></h4><p>在每一次训练前，模型先用 beam search找到最好的 k 个候选翻译，然后将这 k 句话与正确答案计算 BLEU得分，取得分最高的当作备选句子。</p>
<p>有了备选句子后怎么办？比如，模型现在要预测第四个词，那么模型的输入是第三个词，这第三个词可以是正确译文的第三个词（传统做法）、可以是模型所预测的第三个词（Word Level）、也可以是这句备选句子的第三个词（Sentence-Level）。</p>
<p>现在有一个问题： 如果备选句子的长度与答案的长度不一样怎么办，这样备选句子与ground truth不是一一对应的了，那么这样的替换就没有意义了，因为我们希望这个词和对应答案的词是意思相近的或者是近义词。</p>
<p>作者给出了办法：</p>
<p>beam search在生成句子时，直到模型预测出结尾符<eos>才结束。</eos></p>
<p>假设ground truth的长度是 n ：</p>
<p>1、若模型在 n 之前就预测出<eos>结尾符，那么，我们选择概率第二的作为预测词。</eos></p>
<p>2、若模型在 n 时没有预测出<eos>结尾符，那么，我们选择<eos>结尾符，并使用它的概率。</eos></eos></p>
<p>作者的思路就是这样，然后就是最小化每一个字与<strong>ground truth</strong>对应字的负似然对数。</p>
<p>是与<strong>原始的ground truth</strong>的词计算loss！！！ 而不是与替换了的词，这个替换只发生在模型的输入。</p>
<h3 id="3-2-Sampling-with-Decay"><a href="#3-2-Sampling-with-Decay" class="headerlink" title="3.2 Sampling with Decay"></a>3.2 Sampling with Decay</h3><p>在train阶段刚开始时，抽中真实的词 $y_{j-1}^{*}$ 的概率比较大，随着模型逐渐收敛，抽中预测的词 $y_{j-1}^{\text {oracle }}$ 的概率变大，让模型有能力处理”过度纠正的问题”。</p>
<p>在训练的初始阶段, 如果过多地选择 $y_{t-1}^{\text {oracle }},$ 会导致模型收敘速度慢; 在训练的后期阶段，如果过多地选择 $y_{t-1}^{*},$ 会导致模型在train阶段没有学习到如何处理infer阶段的差别。 </p>
<p>因此，好的选择是：在训练的初始阶段， 更大概率地选择 $y_{t-1}^{*}$ 来加快模型收敛，当模型逐渐收敛后, 以更大概率选择 $y_{t-1}^{\text {oracle }},$ 来让模型学习到如何处理infer阶段的差别以及让模型有能力处理”过度纠正的问题”。从数学表示上，概率 $p$ 先大后逐渐衰减，$p$ 随着训练轮数 $e$ 的增大而逐渐变小。</p>
<p>$p=\frac{\mu}{\mu+\exp \left(\frac{e}{\mu}\right)}$</p>
<p><img src="https://i.loli.net/2021/03/15/H6U7Dc5wP8KAsNG.png" alt="image-20210315173055286" style="zoom: 67%;"></p>
<h3 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h3><p>本文主要的两点贡献：</p>
<p>(1) word level oracle selection</p>
<p>(2) sampling with decay</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://zhuanlan.zhihu.com/p/76227765" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/76227765</a></p>
<p><a href="https://spring-quan.github.io/2019/08/02/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E3%80%8ABridging-the-Gap-between-Training-and-Inference-for-Neural-Machine-Translation%E3%80%8B/" target="_blank" rel="noopener">https://spring-quan.github.io/2019/08/02/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E3%80%8ABridging-the-Gap-between-Training-and-Inference-for-Neural-Machine-Translation%E3%80%8B/</a></p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>C3D</title>
    <url>/2019/04/09/C3D/</url>
    <content><![CDATA[<h2 id="pytorch-中"><a href="#pytorch-中" class="headerlink" title="pytorch 中"></a>pytorch 中</h2><h3 id="Conv2d"><a href="#Conv2d" class="headerlink" title="Conv2d"></a>Conv2d</h3><p><a href="https://pytorch.org/docs/stable/nn.html#conv2d" target="_blank" rel="noopener">https://pytorch.org/docs/stable/nn.html#conv2d</a><br>the shape of input:  <font size="5," color="#0099ff">batch×channel×height×width</font></p>
<h2 id="Conv3d"><a href="#Conv3d" class="headerlink" title="Conv3d"></a>Conv3d</h2><p><a href="https://pytorch.org/docs/stable/nn.html#conv3d" target="_blank" rel="noopener">https://pytorch.org/docs/stable/nn.html#conv3d</a><br>the shape of input: <font size="5," color="#0099ff">batch×channel×depth×height×width</font></p>
<h2 id="C3D-用于行为识别-1-2"><a href="#C3D-用于行为识别-1-2" class="headerlink" title="C3D 用于行为识别[1][2]"></a>C3D 用于行为识别[1][2]</h2><p>[1] C3D 的网络结构</p>
<ul>
<li>输入： bs×3×<font size="5," color="#0099ff">16</font>×H×W，即输入一个长为16的视频序列clip， 实际是 bs×3×16×12×12</li>
<li>输出： bs×feature_size</li>
</ul>
<p>对于一个video，含有N帧，则将这N帧分成16帧的clips，每相邻的两个clips重叠8帧，然后将这些clips得到的fc6 activations 进行平均得到video feature，进而送入分类层得到video class label</p>
<h2 id="解读论文Learning-Spatio-Temporal-Features-with-3D-Residual-Networks-for-Action-Recognition"><a href="#解读论文Learning-Spatio-Temporal-Features-with-3D-Residual-Networks-for-Action-Recognition" class="headerlink" title="解读论文Learning Spatio-Temporal Features with 3D Residual Networks for Action Recognition"></a>解读论文<code>Learning Spatio-Temporal Features with 3D Residual Networks for Action Recognition</code></h2><h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><ul>
<li>当前行为识别的方法，参数量不能过多的原因是，现在可以用于训练的数据集较小，一旦参数量过大，使得模型过拟合</li>
<li>但是，现在有了kinetics 这样的大型数据集，这时，便可以提出一个参数量大的model</li>
</ul>
<h3 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h3><ul>
<li>生成一个用于 spatio-temporal recognition的标准预训练模型</li>
</ul>
<h3 id="关于image-size-部分的介绍"><a href="#关于image-size-部分的介绍" class="headerlink" title="关于image size 部分的介绍"></a>关于image size 部分的介绍</h3><ul>
<li>截取帧时，固定长宽比，并设置高为360（resneXt是240），</li>
</ul>
<h4 id="train"><a href="#train" class="headerlink" title="train"></a>train</h4><ul>
<li>以一个 16 连续帧组成的clip来代表 video</li>
<li>先以最小边为尺寸进行裁剪（裁剪为一个正方形），然后再进行resize 112</li>
<li>为了数据增强，这里有三个trick  (1) 最小边=min(height, weight) * sacle (2) 选取哪个区域进行裁剪，有五种选择 四个角和中心 (3)以50%的概率进行随机水平翻转</li>
</ul>
<h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><ul>
<li>一个video 去选择 没有重叠的所有 16 连续帧，然后对这所有的clip的得分进行取平均作为video的得分</li>
<li>不再进行数据增强</li>
<li>先按照最小边，固定长宽比进行缩放</li>
<li>再 中心裁剪成指定的 <code>112*112</code></li>
</ul>
<h3 id="分析-resnet34-c3d-比-rgb-i3d-差的原因"><a href="#分析-resnet34-c3d-比-rgb-i3d-差的原因" class="headerlink" title="分析 resnet34-c3d 比 rgb-i3d 差的原因"></a>分析 resnet34-c3d 比 rgb-i3d 差的原因</h3><ol>
<li><p>rgb-i3d 使用了64个GPU，可能他们使用的batch size 也比较大。而 resnet34-c3d 仅使用了4个GPU，256 batch size。</p>
</li>
<li><p>rgb-i3d 使用的 clip 分辨率为：3 × 64 × 224 × 224.  而 resnet34-c3d 的 clip 分辨率为 3 × 16 × 112 × 112 。    </p>
<p>即，i3d 使用连续的 <strong>64</strong> 帧组成一个clip，并且 image 分辨率为 <strong>224</strong>，</p>
<p>而， resnet c3d 使用连续的 <strong>16</strong> 帧组成一个clip，并且 image 分辨率为 <strong>112</strong>，</p>
</li>
</ol>
<h2 id="解读论文Can-Spatiotemporal-3D-CNNs-Retrace-the-History-of-2D-CNNs-and-ImageNet"><a href="#解读论文Can-Spatiotemporal-3D-CNNs-Retrace-the-History-of-2D-CNNs-and-ImageNet" class="headerlink" title="解读论文Can Spatiotemporal 3D CNNs Retrace the History of 2D CNNs and ImageNet?"></a>解读论文<code>Can Spatiotemporal 3D CNNs Retrace the History of 2D CNNs and ImageNet?</code></h2><h3 id="Goal-1"><a href="#Goal-1" class="headerlink" title="Goal"></a>Goal</h3><ul>
<li>本文的目的是为了验证当前存在的数据集是否足够支撑训练一个很深的3d网络</li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1] Learning Spatio-Temporal Features with 3D Residual Networks for Action Recognition .  ICCV 2017<br>[2] Can Spatiotemporal 3D CNNs Retrace the History of 2D CNNs and ImageNet?  CVPR 2018</p>
]]></content>
      <categories>
        <category>行为识别</category>
      </categories>
      <tags>
        <tag>行为识别</tag>
      </tags>
  </entry>
  <entry>
    <title>CLIPScore: A Reference-free Evaluation Metric for Image Captioning</title>
    <url>/2021/04/20/CLIPScore-A-Reference-free-Evaluation-Metric-for-Image-Captioning/</url>
    <content><![CDATA[<h2 id="1-本文研究的任务"><a href="#1-本文研究的任务" class="headerlink" title="1. 本文研究的任务"></a>1. 本文研究的任务</h2><ul>
<li>图像描述的评价指标</li>
</ul>
<h2 id="2-目前存在的问题"><a href="#2-目前存在的问题" class="headerlink" title="2. 目前存在的问题"></a>2. 目前存在的问题</h2><ul>
<li>当前图像描述的评价指标(automatic metrics )都是基于 predicted caption 与 reference 之间的文本匹配。但是人类进行评价时是直接将图片与prediction进行对比。即 automatic metrics与 human evaluation的评价方式是不一样的</li>
<li>reference的收集需要耗费人力，且较慢</li>
<li>reference是有限的，并不能覆盖所有可能的描述。因此，这些automatic metrics 更加<strong>偏向于</strong>reference中出现的单词，对于新的且正确的单词会给予错误的<strong>惩罚</strong>。</li>
</ul>
<h2 id="3-Motivation"><a href="#3-Motivation" class="headerlink" title="3. Motivation"></a>3. Motivation</h2><p>本文提出使用 clip model 来作为 图像描述的reference-free metric，基于以下两点原因：</p>
<ul>
<li><p><strong>基于在WMT上的借鉴：</strong>在多语言机器翻译任务中，提出了使用多语言模型（M-BERT), 计算 source-target 之间的相似性，作为reference free metric 来评估机器翻译。因此，可以使用image-text matching model 来计算image 与 predicted caption 之间的相似性。</p>
</li>
<li><p>CLIP，ALIGN，这种模型以 <strong>zero-shot</strong> 的方式展示出了在image-text matching task 上的优异性能。因此CLIP可以作为一个现成的(<strong>off-the-shelf</strong>) 的reference-free caption evaluation。</p>
</li>
</ul>
<h2 id="4-本文的贡献"><a href="#4-本文的贡献" class="headerlink" title="4. 本文的贡献"></a>4. 本文的贡献</h2><ul>
<li>提出一个 评估图像描述的 reference-free metric（CLIPScore, CLIP-s）。<br>另外提出了一个增强版本(RefCLIPScore,)，可以结合reference。</li>
<li>一个信息增益的分析实验，证明了CLIP-S 与 other metrics（B_4, Cider, Meteor， ViLBERTScore-F）是互相补充的。</li>
<li>实验验证CLIP-S对恶意构建的图像标题是敏感的，其中一个名词短语被换成了一个可信的（但不正确的）单词。</li>
<li><p>构建一个从未在网上公开发布过的图像语料库，以检验CLIP-S是否能够重建人类对从未见过的图像的判断。</p>
</li>
<li><p>最后，我们在四个与直接场景描述(direct scene description)不同的案例研究中评估CLIP-S。在两种情况下，CLIP-S效果很好。 它与<strong>Twitter</strong>上的alt-text质量评级实现了高度关联，并展示了对<strong>clipart images+captions</strong>进行推理的惊人能力。对于<strong>新闻标题</strong>的生成，基于参考的方法与人类的判断有最好的相关性。 而且，对于由<strong>社交媒体上的语言使用所激发的情感性标题</strong>，即使是基于参考的指标也是不足的。</p>
</li>
</ul>
<h2 id="5-实验"><a href="#5-实验" class="headerlink" title="5. 实验"></a>5. 实验</h2><h3 id="5-1-Performance-on-a-set-of-literal-image-description-corpora"><a href="#5-1-Performance-on-a-set-of-literal-image-description-corpora" class="headerlink" title="5.1 Performance on a set of literal image description corpora"></a>5.1 Performance on a set of literal image description corpora</h3><h4 id="Caption-level-Likert-Judgments"><a href="#Caption-level-Likert-Judgments" class="headerlink" title="Caption-level Likert Judgments"></a>Caption-level Likert Judgments</h4><ul>
<li>BERT-S  是指 BERTScore: Evaluating text generation with BERT</li>
<li>BERT-S++ 是指 Improving image captioning evaluation by considering inter references variance.</li>
</ul>
<p><img src="https://i.loli.net/2021/04/21/8A2W4u7EalDmTYL.png" alt="image-20210421104120105"></p>
<p><img src="https://i.loli.net/2021/04/21/OUaqp5JvolduweY.png" alt="image-20210421104130443"></p>
<p><img src="https://i.loli.net/2021/04/21/3n72RmIfBZFUcza.png" alt="image-20210421104218527"></p>
<h4 id="Pairwise-Ranking-on-Pascal-50S"><a href="#Pairwise-Ranking-on-Pascal-50S" class="headerlink" title="Pairwise Ranking on Pascal-50S"></a>Pairwise Ranking on Pascal-50S</h4><p><img src="https://i.loli.net/2021/04/21/ck1xFipoPAEf74m.png" alt="image-20210421104150925"></p>
<h4 id="System-level-Correlation-for-MSCOCO"><a href="#System-level-Correlation-for-MSCOCO" class="headerlink" title="System-level Correlation for MSCOCO."></a>System-level Correlation for MSCOCO.</h4><p>该文章作者提出，该数据其实仅有12个数据，数据量太少，用来评估相关性，其实是不准确的。但是还是做了这方面的实验。</p>
<p>在M1 和 M2 上，CLIP-S achieves Spearman $\rho_{M 1} / \rho_{M 2}=.59 / .63$ and RefCLIP-S achieves $\rho_{M 1} / \rho_{M 2}=.69 / .74$ </p>
<h3 id="5-2-Sensitivity-of-CLIP-S-to-hallucination"><a href="#5-2-Sensitivity-of-CLIP-S-to-hallucination" class="headerlink" title="5.2 Sensitivity of CLIP-S to hallucination"></a>5.2 Sensitivity of CLIP-S to hallucination</h3><p>先前的研究（Object hallucination in image captioning）表明，人类在给human打分时，会更加偏向于caption是否正确，而不是caption是否足够具体(全面)。因此，了解评价指标是否以及如何处理包含不正确的 “幻觉 “(incorrect “hallucinations,”)的图像描述，例如，对未描述的物体的引用，是很重要的。</p>
<p>本文使用FOIL数据集（FOIL it! find one mismatch between image and language caption），来测试CLIPScore对检测描述中潜在的微妙不准确的细节有多敏感。这个语料库由MSCOCO的reference进行修改后组成，其中有一个名词短语被对抗性地换掉，以使caption不正确，例如，将 “摩托车 “换成 “自行车”。</p>
<p><img src="https://i.loli.net/2021/04/21/Kqsab4TN7lC3OJX.png" alt="image-20210421111246841"></p>
<h3 id="5-3-Sensitivity-of-CLIP-S-to-memorization"><a href="#5-3-Sensitivity-of-CLIP-S-to-memorization" class="headerlink" title="5.3  Sensitivity of CLIP-S to memorization"></a>5.3  Sensitivity of CLIP-S to memorization</h3><p>以上数据集的成功表现，可能存在一种风险，即在评估时使用的数据已经在预训练时看到过。可能是在CLIP的预训练数据中包含了 COCO，Flickr 这种数据。为了消除这个疑虑，本文收集了250图片，这些图片没有上传到网上。然后使用Microsoft Azure Cognitive Services 和 Discriminability objective for training descriptive captions 这两个工具为每张图片生成两个预测的描述，然后，组织3个author去分析，哪个预测更好。</p>
<p>CLIP-S 实验了86%的 accuracy（人类的一致性92%）。</p>
<h3 id="5-4-评价指标之间的冗余和互补"><a href="#5-4-评价指标之间的冗余和互补" class="headerlink" title="5.4 评价指标之间的冗余和互补"></a>5.4 评价指标之间的冗余和互补</h3><p><img src="https://i.loli.net/2021/04/21/B1OvP7LW5ycr4u2.png" alt="image-20210421114103630"></p>
<p>6个常用的metrics (B_1, B_4, Meteor, Rouge, Cider, Spice)</p>
<p>4个新的metrics (TIGER, BERTScore, ViLBERTScore-F, and CLIP-S/RefCLIPS)</p>
<p>在这10个评价指标上，执行greedy前向搜索，开始时为一个空集，选择最有信息量的metric 添加到集合中来。关于信息增益的考量：根据线性回归模型，一个指标与人类判断的additional (增加)相关性有多大。（yaya: 当前步，引入一个metric到集合中来，可以带来多少相关性的提升）</p>
<p><strong>yaya: 具体实现细节不是很清楚，可以等代码开源之后看看</strong></p>
<h2 id="6-Other-Captioning-Domains"><a href="#6-Other-Captioning-Domains" class="headerlink" title="6. Other Captioning Domains"></a>6. Other Captioning Domains</h2><ul>
<li><p>Alt-Text ratings from Twitter</p>
</li>
<li><p>Abstract-50S</p>
</li>
<li>Personality Captions</li>
<li>News Image Captioning</li>
</ul>
<h2 id="7-Future-Work"><a href="#7-Future-Work" class="headerlink" title="7. Future Work"></a>7. Future Work</h2><ul>
<li><p>consider CLIP-S as a reinforcement learning reward for literal caption generators<br><strong>以clipscore 作为reward来做强化学习，提升captioning tasks</strong></p>
</li>
<li><p>explore whether a small amount of labelled human rating data could help CLIP-S adapt to domains where it struggles, e.g., engagingness prediction.</p>
<p><strong>用human ratings data来提升CLIP-S 作为评价指标的性能，从而提升对于一些目前它比较困难的领域。</strong></p>
</li>
</ul>
<h2 id="8-yaya"><a href="#8-yaya" class="headerlink" title="8. yaya"></a>8. yaya</h2><font color="red">由于clip的预训练过程对文本添加了前缀，类似”A photo of"。因此，在本文CLIPScore 中，对candidate captions也添加了前缀：“A photo depicts"</font>

]]></content>
      <categories>
        <category>cross-modal</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
      </tags>
  </entry>
  <entry>
    <title>[COCO-LM] Correcting and Contrasting Text Sequences for Language Model Pretraining</title>
    <url>/2021/03/04/COCO-LM-Correcting-and-Contrasting-Text-Sequences-for-Language-Model-Pretraining/</url>
    <content><![CDATA[<p>转自：<a href="https://zhuanlan.zhihu.com/p/353624306" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/353624306</a></p>
<p>该篇文章2021年2月16日上传，提出了一种新的预训练模型的框架，个人认为<strong>COCO-LM结合了许多当下比较新进的思想，在后bert时代，一定程度上突破了对BERT模型传统的预训练方法</strong>。</p>
<p>We present COCO-LM, a new self-supervised learning framework that pretrains Language Models by COrrecting challenging errors and COntrasting text sequences. COCO-LM employs an auxiliary language model to mask-and-predict tokens in original text sequences. It creates more challenging pretraining inputs, where noises are sampled based on their likelihood in the auxiliary language model. COCO-LM then pretrains with two tasks: <strong style="color:blue;">The first task, corrective language modeling</strong>, learns to correct the auxiliary model’s corruptions by recovering the original tokens. <strong style="color:blue;">The second task, sequence contrastive learning</strong>, ensures that the language model generates sequence representations that are invariant to noises and transformations. In our experiments on the GLUE and SQuAD benchmarks, COCO-LM outperforms recent pretraining approaches in various pretraining settings and few-shot evaluations, with higher pretraining efficiency. Our analyses reveal that COCO-LM’s advantages come from its challenging training signals, more contextualized token representations, and regularized sequence representations.</p>
<p><img src="https://i.loli.net/2021/03/04/xOA857rdWJktsEY.png" alt="FireShot Capture 018 -  - arxiv.org"></p>
<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p>在标准语言模型预训练框架内，可以观察到PLM在下游任务上的the empirical performance 仅随着参数大小和预训练成本的指数增长而线性提高，<strong>这是不可持续的</strong>，因为PLM已达到数万亿个参数。</p>
<p>最近的研究揭示了现有预训练框架的某些固有局限性，这些局限性可能导致这种亚线性效率（sublinear efficiency）。【1】一个挑战是，<strong>使用随机更改的文本</strong>（<em>例如</em>，randomly masked tokens）进行预训练会<strong>产生许多非信息性信号</strong>，经过一定程度的预训练后它们不再有用。【2】另外一个挑战是，在 token level 进行预训练不会在 sequence level 上显式学习语言语义，并且在预训练过程中，<strong>Transformers可能无法有效地推广到 higher level 的语义 。</strong></p>
<p>在本文中，我们旨在通过一个<strong>新的自我监督学习框架</strong>COCO-LM来克服这些限制。该框架通过使用 more challenging noises 来 COrrecting and COntrasting text sequences，进而预训练语言模型。</p>
<p>【1】leverages an auxiliary language model，to corrupt text sequences by <strong>sampling more contextually plausible noises</strong> from its masked language modeling (MLM) probability. COCO-LM revives a language modeling task, corrective language modeling (CLM), which pretrains the Transformer to <strong>not only detect the challenging noises in the corrupted texts, but also correct them via a multi-task setting.</strong></p>
<p>【2】To improve the learning of sequence level semantics, COCOLM introduces a sequence level pretraining task, sequence contrastive learning (SCL), that uses contrastive learning to enforce the pretraining model to <strong>align the corrupted text sequence and its cropped original sequence close</strong> in the representation space, while away from other random sequences.</p>
<h3 id="COCO-LM框架延续了ELECTRA预训练模型的思想"><a href="#COCO-LM框架延续了ELECTRA预训练模型的思想" class="headerlink" title="COCO-LM框架延续了ELECTRA预训练模型的思想"></a>COCO-LM框架延续了ELECTRA预训练模型的思想</h3><p>ELECTRA预训练模型主要应用了GAN对抗神经网络的思想，不了解的小伙伴们可以参考一些其他资料，这里我简单说一下我的理解。</p>
<p>GAN对抗神经网络在CV领域上应用比较成熟，在CV的应用上GAN主要包括两个神经网络模型：一个是生成式模型G，一个是判别式模型D。生成式模型的作用是通过随机噪声生成和原始样本相似的数据（注意这里是通过随机噪声），判别式模型的作用是判断给定的实例是真实实例还是人为伪造的（也就是生成式模型所生成的）。那么这里就包含了对抗的思想，即生成式模型的目的是能够生成欺骗判别式模型的实例，判别式模型的目的是判别给定的实例是否是人为伪造的。</p>
<p>ELECTRA当中引用了这样的“对抗”思想，将判别式模型引入到了模型的预训练之中。像BERT、ROBERTA、XLNET等等预训练模型都属于生成式模型，在输入上用 [MASK] 遮蔽掉部分 tokens，再训练一个模型以重建出原始的 tokens。而ELECTRA预训练模型使用了判别式模型，其效果也出乎意料的好。</p>
<blockquote>
<p>ELECTRA: Pre-training Text Encoders as Discriminators Rather Than Generators</p>
</blockquote>
<p>ELECTRA模型的主要思想也是包括了两个神经网络模型：一个生成式模型G，一个生成式模型D。生成式模型G是MLM（Masked Language Model）模型，给定一个真实样例（GAN的生成式模型给定的是随机噪声），用 [MASK] 遮蔽掉部分 tokens，生成替换的tokens；判别式模型D判断输入中每个 token 是否是由生成器生成。其过程如图所示：</p>
<p><img src="https://i.loli.net/2021/03/04/V7kIJGSo3L1m5ua.png" alt="image-20210304111201636" style="zoom:50%;"></p>
<p>通过实验表明这种新的预训练任务比 MLM 更高效，该任务定义于全部的输入 tokens，而非仅仅被遮蔽掉的那一部分小小的输入子集。</p>
<p>在COCO-LM模型中<strong>Corrective Language Modeling (CLM)</strong>也延续了这样的思想。</p>
<h3 id="COCO-LM模型引入了对比学习的思想"><a href="#COCO-LM模型引入了对比学习的思想" class="headerlink" title="COCO-LM模型引入了对比学习的思想"></a>COCO-LM模型引入了对比学习的思想</h3><p>我认为是非常非常棒的创新点。最近刚好再看对比学习的相关paper，更多的是在CV领域中使用了对比学习，而COCO-LM刚好将对比学习带入到了NLP领域中。</p>
<p>什么是对比学习呢？</p>
<p>对比学习是一种自监督的学习方法。其主要思想我的理解是，把正样本距离拉近，正样本与负样本距离拉远。对比学习的例子如下：</p>
<ul>
<li>给每个例子绘制两个独立的增强函数</li>
<li>使用两种增强机制，为每个示例生成两个互相关联的视图</li>
<li>让相关视图互相吸引，同时排斥其他示例</li>
</ul>
<p><img src="https://i.loli.net/2021/03/04/A3wEY1gPnTxIOaQ.jpg" alt="SimCLR论文解读- 知乎" style="zoom:33%;"></p>
<p>如上图，（Z1，Z2），（Z3，Z4）…（Z2n-1，Z2n）这些可以看作正例对，而Z1可以与除Z1、Z2的任何实例组成负例对，如（Z1，Z3）（Z1，Z4）等等。那么这样一个实例X，在一个大小为N的batch里便可以产生一个正例，以及N-1个负例，那么这个 loss 就可以看做是一个 N 分类问题，实际上就是一个交叉熵，由此可以进行网络模型的训练。</p>
<p>以上是我认为COCO-LM框架比较出色的地方，框架的一些细节还需要进一步的理解，之后会进一步的更新，欢迎知乎各位巨佬一起讨论~</p>
<h3 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h3><ul>
<li><p>在预训练任务中，引入了对抗扰动，且通过对比学习的思想来训练。</p>
</li>
<li><p>这种扰动+对比学习的思想，在vision-text pretraining model 中是否有使用？</p>
</li>
<li>本篇的idea 是如何来的，motivation 是什么？</li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>CLIP4Clip: An Empirical Study of CLIP for End to End Video Clip Retrieval</title>
    <url>/2021/04/20/CLIP4Clip-An-Empirical-Study-of-CLIP-for-End-to-End-Video-Clip-Retrieval/</url>
    <content><![CDATA[<p><a href="https://github.com/ArrowLuo/CLIP4Clip" target="_blank" rel="noopener">code</a></p>
<h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><p>将 CLIP的知识迁移到 video-text retrieval 任务中，但是存在以下几个问题：</p>
<ul>
<li>图像的特征对于 video-text retrieval 是足够的吗？</li>
</ul>
]]></content>
      <categories>
        <category>cross-modal</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
      </tags>
  </entry>
  <entry>
    <title>[COOT] Cooperative Hierarchical Transformer for Video-Text Representation Learning</title>
    <url>/2021/04/03/COOT-Cooperative-Hierarchical-Transformer-for-Video-Text-Representation-Learning/</url>
    <content><![CDATA[<p>这篇文章发表在 NeurIPS 2020，同时做 video-text retrieval and video captioning task.</p>
<p><img src="https://i.loli.net/2021/04/03/c8m4XTZtS6NE7hJ.png" alt="image-20210403102956324" style="zoom:50%;"></p>
<p><img src="https://i.loli.net/2021/04/04/IXfubaGzPV21sEt.png" alt="image-20210404124021644" style="zoom:50%;"></p>
<h2 id="本文的方法"><a href="#本文的方法" class="headerlink" title="本文的方法"></a>本文的方法</h2><p><font color="red"><strong>To model intra-level cooperation</strong></font>, we introduce <strong>an attention-aware feature aggregation layer (Attention-FA)</strong> to focus on temporal interactions between low-level entities (Figure 1-Attention-FA).<br>This component replaces traditional sequence representation aggregation methods in transformers such as using a [CLS] token [11, 14, 15, 19] or mean pooling [25] with an attention-aware fusion. It leverages temporal context to encourage important entities to contribute more to the final representation of a sequence of frames or words.</p>
<p><font color="red"><strong>For the inter-level cooperation</strong></font>, we introduce <strong>a contextual attention module(Contextual transformer)</strong>, which enforces the network to highlight semantics relevant to the general context of the video and to suppress the irrelevant semantics. This is done by modeling the interaction between low-level (clips-sentences) and high-level entities (global contexts), as shown in Figure 1-green region.</p>
<p>In addition to this architectural contributions, we introduce <strong style="color:red;">a new cross-modal cycle-consistency loss</strong> to enforce interaction between modalities and encourage the semantic alignment between them in the learned common space. We show that enforcing two domains to produce consistent representations leads to substantially improved semantic alignment.</p>
<h3 id="An-attention-aware-feature-aggregation-layer-Attention-FA"><a href="#An-attention-aware-feature-aggregation-layer-Attention-FA" class="headerlink" title="An attention-aware feature aggregation layer (Attention-FA)"></a>An attention-aware feature aggregation layer (Attention-FA)</h3><ul>
<li>简单来说，就是以自身（sentence/clip）特征计算一个权重，然后权重求和得到（paragraph/video）特征。</li>
</ul>
<p><img src="https://i.loli.net/2021/04/04/PtqSgLAi2Ky6Fc7.png" alt="image-20210404143442057" style="zoom:50%;"></p>
<h3 id="cross-modal-cycle-consistency-loss-lt-strong-gt"><a href="#cross-modal-cycle-consistency-loss-lt-strong-gt" class="headerlink" title="cross-modal cycle-consistency loss&lt;/strong&gt;"></a>cross-modal cycle-consistency loss&lt;/strong&gt;</h3><p>sentences of  a paragraph, clip of a video</p>
<p>给定一个第$i$ 个 sentence embedding， 计算其与 clips 之间的关系 $\alpha_i$，然后由$\alpha_i$权重求和计算得到soft nearest neighbor.</p>
<p>由该soft nearest neighbor, 计算其与 sentences 之间的关系 $\beta_j$, 然后由$\beta_j$计算 soft location: $\mu=\sum_{j=1}^{m} \beta_{j} j$</p>
<p>The sentence embedding  is semantically cycle consistent if and only if it cycles back to the original location.</p>
<p>Our objective is the distance between the source location $i$ and the soft destination location $\mu .$</p>
<script type="math/tex; mode=display">
\ell_{C M C}=\|i-\mu\|^{2}</script><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><ul>
<li><p>探究本文提出的 the attention-aware feature aggregation (AF), the Contextual Transformer (CoT), and the cross-modal<br>cycle-consistency loss (CMC) 的作用</p>
<ul>
<li>对比 COOT+ CLS/AVG/MAX  和 COOT+AFA, 可以发现，AFA是有效的</li>
<li>对比 COOT+AFA X X  和 COOT+AFA √ X, 可以发现，CMC是有效的，但是效果其实没有那么明显</li>
<li>对比 COOT+AFA √ X 和  COOT+AFA √ √，可以发现，CoT是有效的</li>
</ul>
<p><img src="https://i.loli.net/2021/04/04/NlfV3giYjohSDbn.png" alt="image-20210404141458907" style="zoom:50%;"></p>
</li>
</ul>
<ul>
<li><p>在ActivityNet-caption dataset 上与最新方法对比</p>
<p><img src="https://i.loli.net/2021/04/04/1C26nJMLsBlwdEP.png" alt="image-20210404142959158" style="zoom:50%;"></p>
</li>
<li><p>在 YouCook2 dataset  上与最新方法对比</p>
<ul>
<li>利用howto100m进行预训练是有用的。</li>
</ul>
<p><img src="https://i.loli.net/2021/04/04/bmDwJnpIBXPHA1j.png" alt="image-20210404143035311" style="zoom:50%;"></p>
</li>
<li><p>验证本模型学到的特征包含了有意义的信息，对于其他任务(e.g., video captioning )也是有效的。</p>
<p>在 MART [2] 上使用了本文提出的特征，实验结果如下：</p>
<p><img src="https://i.loli.net/2021/04/04/Em3ILM27ueTbCOa.png" alt="image-20210404145023633" style="zoom: 50%;"></p>
<p><img src="https://i.loli.net/2021/04/04/i71VYerR8gZSWCj.png" alt="image-20210404144942155" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><ul>
<li>对我的启发： the attention-aware feature aggregation (AF)是有用的，可以借鉴。</li>
<li>本文不仅使用了普通的ranking loss, 本文提出的循环一致损失，还使用了【1】提出的 一个损失</li>
<li>本文仅在 activitynet-caption 和 youcook2 上做了实验。</li>
<li>To apply the cycle-consistency loss, we found that sampling 1 clip per video and 1 sentence per paragraph works best.<br>这句话，是什么意思？？？？</li>
<li>本文的方法可能更加适合于 paragraph-video 的匹配任务。</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1]  Bowen Zhang, Hexiang Hu, and Fei Sha. Cross-modal and hierarchical modeling of video and text. In ECCV, 2018.</p>
]]></content>
      <categories>
        <category>cross-modal</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
      </tags>
  </entry>
  <entry>
    <title>CV vs PIL</title>
    <url>/2019/03/20/CV-vs-PIL/</url>
    <content><![CDATA[<h2 id="PIL"><a href="#PIL" class="headerlink" title="PIL"></a>PIL</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line">pil_image = Image.open(<span class="string">'test.jpg'</span>) <span class="comment"># 图片是360x480 宽x高  </span></span><br><span class="line">print(type(pil_image)) <span class="comment"># out: PIL.JpegImagePlugin.JpegImageFile  </span></span><br><span class="line">print(pil_image.size)  <span class="comment"># out: (360,480) # w,h  </span></span><br><span class="line">print(pil_image.mode) <span class="comment"># out: 'RGB'  </span></span><br><span class="line">  </span><br><span class="line">pil_image = np.array(pil_image,dtype=np.float32) <span class="comment"># image = np.array(image)默认是uint8  </span></span><br><span class="line">print(pil_image.shape) <span class="comment"># out: (480, 360, 3)  </span></span><br><span class="line"><span class="comment"># 神奇的事情发生了，w和h换了，变成(h,w,c)了  </span></span><br><span class="line"><span class="comment"># 注意ndarray中是 行row x 列col x 维度dim 所以行数是高，列数是宽</span></span><br></pre></td></tr></table></figure>
<blockquote>
<pre><code>输出结果：
&lt;class &#39;PIL.JpegImagePlugin.JpegImageFile&#39;&gt;
(360, 480)
RGB
(480, 360, 3)
</code></pre></blockquote>
<p>这里截图在pycharm下调试的信息（未转化成numpy array之前）</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g193y86ko4j30lt0ixmy8.jpg">  </p>
<blockquote>
<p>可以看到PIL.Image读出的image格式为（w,h,c）且image.mode = ‘RGB’<br>并且由代码的注释可以看到，当PIL.Image转化成numpy.array格式之后，image.size将转为（h,w,c）,c 仍为“RGB”</p>
</blockquote>
<h2 id="CV"><a href="#CV" class="headerlink" title="CV"></a>CV</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line">cv_image = cv2.imread(<span class="string">'test.jpg'</span>)  </span><br><span class="line">print(type(cv_image)) <span class="comment"># out: numpy.ndarray  </span></span><br><span class="line">print(cv_image.dtype) <span class="comment"># out: dtype('uint8')  </span></span><br><span class="line">print(cv_image.shape) <span class="comment"># out: (360,480, 3) (h,w,c) 和skimage类似  </span></span><br><span class="line"><span class="comment"># print(image) # BGR</span></span><br></pre></td></tr></table></figure>
<h2 id="为了比较PIL-和-CV"><a href="#为了比较PIL-和-CV" class="headerlink" title="为了比较PIL 和 CV"></a>为了比较PIL 和 CV</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(cv_image == pil_image)</span><br></pre></td></tr></table></figure>
<p>可以看到 分别是 False True False<br><strong>原因是PIL提取的是“RGB”，而CV提取的是“BGR”</strong><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g194ap1lw4j306d07zmx0.jpg"></p>
<p>综上，可以凝练为以下几点：</p>
<ol>
<li>PIL提取的是PIL.image类型的数据（w,h,c），通道是“RGB”。</li>
<li>将该数据转为numpy.array之后，得到的是（h,w,c），通道仍是“RGB”。</li>
<li>CV提取的是numpy.array类型的数据（h,w,c），注意通道是“BGR”。</li>
</ol>
<ul>
<li>再</li>
<li>在pytorch中输入的image模式是“RGB”</li>
<li>在caffe中输入的是“BGR”</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pytorch_normalze</span><span class="params">(img)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    https://github.com/pytorch/vision/issues/223</span></span><br><span class="line"><span class="string">    return appr -1~1 RGB</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    normalize = tvtsf.Normalize(mean=[<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>],</span><br><span class="line">                                std=[<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">    img = normalize(t.from_numpy(img))</span><br><span class="line">    <span class="keyword">return</span> img.numpy()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">caffe_normalize</span><span class="params">(img)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    return appr -125-125 BGR</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    img = img[[<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>], :, :]  <span class="comment"># RGB-BGR</span></span><br><span class="line">    img = img * <span class="number">255</span></span><br><span class="line">    mean = np.array([<span class="number">122.7717</span>, <span class="number">115.9465</span>, <span class="number">102.9801</span>]).reshape(<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    img = (img - mean).astype(np.float32, copy=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> img</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Cross-modal Coherence Modeling for Caption Generation</title>
    <url>/2020/04/22/Cross-modal-Coherence-Modeling-for-Caption-Generation/</url>
    <content><![CDATA[<h4 id="现在图像描述中存在的问题"><a href="#现在图像描述中存在的问题" class="headerlink" title="现在图像描述中存在的问题"></a>现在图像描述中存在的问题</h4><ul>
<li>标注方式上：让工作人员标注出image 对应的text。</li>
<li>这导致的问题：（1）Unfortunately, such dedicated annotation efforts cannot yield enough data for training robust generation models; the resulting generated captions are plagued by content<br>hallucinations (Rohrbach et al., 2018; Sharma et al., 2018) that effectively preclude them for being used in real-world applications. </li>
</ul>
]]></content>
      <categories>
        <category>图像描述</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>[DeepFuse] HKU’s Multimodal Machine Translation System for VMT’20</title>
    <url>/2021/02/26/DeepFuse-HKU%E2%80%99s-Multimodal-Machine-Translation-System-for-VMT%E2%80%9920/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/02/26/bTNP7oqc3nxXfMV.png" alt="image-20210226154022062" style="zoom:50%;"></p>
<p>VATEX： video-guided machine translation(EN-&gt;CH) Challenge</p>
<p>ACL 2020 workshop <a href="https://alvr-workshop.github.io/2020/index.html" target="_blank" rel="noopener">https://alvr-workshop.github.io/2020/index.html</a></p>
<h3 id="以前方法存在的问题"><a href="#以前方法存在的问题" class="headerlink" title="以前方法存在的问题"></a>以前方法存在的问题</h3><p>以前的image-guied Machine Translations, 在encode 阶段，往往单独对 视觉信息和语言信息进行编码。然后，在decode 阶段使用attention将视觉信息结合进来。模态之间的信息仅仅进行了浅融合。</p>
<h3 id="本文提出的方案"><a href="#本文提出的方案" class="headerlink" title="本文提出的方案"></a>本文提出的方案</h3><p>本文中，提出了一个 video-augmented encoder，以此，获得一个multi-modal representation 来作为decoder的输入。使用attention 机器在多个层融合了多模态的表征。</p>
<p>实验证明，这种深融合方法相比于之前的浅融合方法要更加的有效。</p>
<h3 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h3><p><img src="https://i.loli.net/2021/02/26/7qgti5pwnDkcWNZ.png" alt="image-20210226160753355" style="zoom:50%;"></p>
<p>本文提出的visual-augmented encoder 如图1所示，encoder 包括L=6层相同的层。</p>
<p>将sentence表征为一个embedding的输入序列： $\mathbf{X}=x_{1}, x_{2}, \ldots, x_{n}$</p>
<p>将 video 使用I3D提取clips的特征，表征为segment-level feature 的序列：$\mathbf{E}=e_{1}, e_{2}, \ldots, e_{m}$</p>
<h4 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h4><p>The encoder process the input X and E as follows:</p>
<p>【1】input X 输入<strong>Multi-Head attention and Feed Forward</strong> 这两个sub layers， 得到 $H^L$</p>
<p>【2】在video-encoder attention module, 使用$H^L$ 作为 query 来选择与query 相关的 video representation。 </p>
<p>$\overline{\mathcal{H}}=$ Attention $\left(\mathbf{H}^{L}, \mathbf{K}_{E}, \mathbf{V}_{E}\right)$</p>
<p>【3】使用权重求和来得到多模态特征：</p>
<p>$\mathcal{H}=\mathbf{H}^{L}+\lambda \overline{\mathcal{H}}$， where，$\lambda=\operatorname{sigmoid}\left(\mathbf{W}_{\lambda} \overline{\mathcal{H}}+\mathbf{U}_{\lambda} \mathbf{H}^{L}\right)$</p>
<p>【4】最后的输出是：$\operatorname{LayerNorm}\left(\mathbf{H}^{L}+\mathcal{H}\right)$</p>
<p>【yaya】最后一步，似乎是有问题，因为，这样多模态特征，似乎就是加了两遍 $H^L$</p>
<h4 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h4><p>遵循transformer 中 decoder的设计，存在L=6个相同的层。</p>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><h4 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h4><p>学习率的变化曲线：lrate $=d_{\text {model }}^{-0.5} \cdot \min \left(K^{-0.5}, K \cdot N^{-1.5}\right)$，where K is the current number of step and N=4000 is the number of warm-up steps.</p>
<h4 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h4><p>（1）<strong>lstm</strong>: Text-only LSTM-based encoderdecoder NMT </p>
<p>（2）<strong>vatex</strong>: The LSTM-based videoguided machine translation system proposed in VATEX<br>（3）<strong>Transformer</strong>: standard text-only transformer architecture proposed by “Attention is all you need.”</p>
<p><img src="https://i.loli.net/2021/02/26/ZD7SxmKUBMA3tIE.png" alt="image-20210226170500065" style="zoom:33%;"></p>
<ul>
<li>相比于text-only transformer 有一个显著的提高。证明了，使用深层融合来结合视觉信息的有效性。</li>
</ul>
<h3 id="收获与总结"><a href="#收获与总结" class="headerlink" title="收获与总结"></a>收获与总结</h3><ul>
<li><p>本文的关键是提出了使用transformer 的结构来融合文本和视觉信息。</p>
</li>
<li><p>在image-guided machine translation 任务中，也存在两篇使用co-attention 来融合两个模态信息的。如下：</p>
<blockquote>
<p>[1] (ACL 2020) Multimodal Transformer for Multimodal Machine Translation</p>
<p>[2] (ACL 2020) A Novel Graph-based Multi-modal Fusion Encoder for Neural Machine Translation 【Graph Fusion】</p>
</blockquote>
</li>
</ul>
<p>【Graph Fusion】与本文相比，encoder 的设计方式不同，但是decoder的设计是相同的。关于不同：【Graph Fusion】首先对两个模态各自self-attention 而后再根据graph edge 进行co-attention。而本文对视觉信息没有进行self-attention，仅对语言信息进行了self-attention, 在co-attention步骤中也没有显示的graph edge,而是采用了隐式的全连接。</p>
]]></content>
      <categories>
        <category>cross-modal</category>
        <category>video-guided MT</category>
      </categories>
      <tags>
        <tag>cross-modal,video-guided MT</tag>
      </tags>
  </entry>
  <entry>
    <title>Cross-Batch Memory for Embedding Learning</title>
    <url>/2021/04/02/Cross-Batch-Memory-for-Embedding-Learning/</url>
    <content><![CDATA[<p>转载自：<a href="https://zhuanlan.zhihu.com/p/139187724" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/139187724</a></p>
<p>转载的原因：</p>
<ul>
<li>此篇论文与 MoCo 的思路非常的相似</li>
<li>其实度量学习的思想也是可以用于 跨模态检索任务中的，毕竟跨模态检索做的也是度量任务。<br>目前看到有两篇论文已经这样做了：<ul>
<li>HiT Hierarchical Transformer with Momentum Contrast for Video-Text Retrieval</li>
<li>Memory Enhanced Embedding Learning for Cross-Modal Video-Text Retrieval</li>
</ul>
</li>
</ul>
<p>码隆科技今年在 CVPR 多有斩获。在大会论文接受率仅有 22%、被称为“十年来最难的一届”的情况下，有两篇论文入选 CVPR 2020，其中本文 Cross-Batch Memory for Embedding Learning为口头报告论文（Oral）。口头报告论文是 CVPR 官方核定的含金量最高的论文，以 CVPR 2019 为例，投稿的 5160 篇论文中，仅有约 5.6% 获评口头报告论文。同时，作为以技术为先的人工智能企业，码隆科技和往年一样，是 CVPR 2020 的金牌赞助商。</p>
<p>本篇论文提出了 XBM 方法，能够用极小的代价，提供巨量的样本对，为 pair-based 的深度度量学习方法取得巨大的效果提升。这种提升难例挖掘效果的方式突破了过去两个传统思路：加权和聚类，并且效果也更加简单、直接，很好地解决了深度度量学习的痛点。XBM 在多个国际通用的图像搜索标准数据库上（比如 SOP、In-Shop 和 VehicleID 等)，取得了目前最好的结果。</p>
<p><strong>我们的算法研究员也在知乎上针对这篇论文撰写了一版更为通俗有趣的解读文章。感兴趣的话，可以点击下方直达。</strong></p>
<p><a href="https://zhuanlan.zhihu.com/p/136522363" target="_blank" rel="noopener">王珣：跨越时空的难样本挖掘zhuanlan.zhihu.com<img src="https://i.loli.net/2021/04/02/xsgfovFm5TVaCyq.jpg" alt="图标"></a></p>
<p><strong>论文</strong>：Cross-Batch Memory for Embedding Learning</p>
<p><strong>地址</strong>：<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1912.06798" target="_blank" rel="noopener">https://arxiv.org/abs/1912.06798</a></p>
<h2 id="背景和动机"><a href="#背景和动机" class="headerlink" title="背景和动机"></a><strong>背景和动机</strong></h2><p>难例挖掘是深度度量学习领域中的核心问题，最近有颇多研究都通过改进采样或者加权方案来解决这一难题，目前主要两种思路：第一种思路是在 mini-batch 内下功夫，对于 mini-batch 内的样本对，从各种角度去衡量其难度，然后给予难样本对更高权重，比如 N-pairs、Lifted Struture Loss、MS Loss 使用的就是此种方案。第二种思路是在 mini-batch 的生成做文章，比如 HTL、Divide and Conquer，他们的做法虽然看上去各有不同，但是整体思路有异曲同工之处。大致思路都是对整个数据集进行聚类，每次生成 mini-batch 不是从整个数据集去采样，而是从一个子集，或者说一个聚类小簇中去采样。这样一来，由于采样范围本身更加集中，生成的 mini-batch 中难例的比例自然也会更大，某种程度上也能解决问题。然而，无论是第一种方法的额外注重难样本，还是第二种方法的小范围采样，他们的难例的挖掘能力其实依然有一个天花板——那就是 mini-batch 的大小。这个 mini-batch 的大小决定了在模型中单次迭代更新中，可以利用的样本对的总量。因此，即使是很精细的采样加权方法，在 mini-batch 大小有限的情况下，也很难有顶级的表现。我们在三个标准图像检索数据库上进行了实验，基于三种标准的 pair-based 方法，我们发现随着 mini-batch 变大，效果（Recall@1）大幅提升。实验结果如下图：</p>
<p><img src="https://i.loli.net/2021/04/02/XnEsAeKYZ78Sak3.png" alt="image-20210402165727364"></p>
<p>可以看出，随着 mini-batch 的增大，效果有显著提升。但是，在实际工业应用中 mini-batch 越大，训练所需要的 GPU 或 TPU 就越多，即使计算资源有充分保证，在多机多卡的训练过程中，如何在工程上保证通信的效率也是一个有挑战的问题。</p>
<h2 id="特征偏移"><a href="#特征偏移" class="headerlink" title="特征偏移"></a><strong>特征偏移</strong></h2><p>由此，我们希望另辟蹊径，得以在 mini-batch 有限的情况下，也能获得充足的难例样本对。首先，必须突破深度度量学习一直以来的一个思维局限——仅在对当前 mini-batch里的样本对两两比较，形成样本对。以此我们引入了 XBM（Cross-batch Memory）这一方法来突破局限，跨越时空进行难例挖掘，把过去的 mini-batch 的样本提取的特征也拿过来与当前 mini-batch 作比较，构建样本对。</p>
<p><img src="https://i.loli.net/2021/04/02/gzBpr4V6MLxbPCd.jpg" alt="img"></p>
<p>我们将样本特征随着模型训练的偏移量，称之为特征偏移（Feature Drift）。从上图我们发现，在训练的一开始，模型还没有稳定，特征剧烈变化，每过 100 次迭代，特征偏移大约 0.7 以上。但是，随着训练的进行，模型逐步稳定，特征的偏移也变小。我们称这个现象为慢偏移（Slow Drift），这是我们可以利用的一点。</p>
<h2 id="方法梗概"><a href="#方法梗概" class="headerlink" title="方法梗概"></a><strong>方法梗概</strong></h2><p>我们发现，虽然在训练的前 3K iterations，mini-batch 过去的提取特征与当前模型偏差很大，但是，随着训练时间的延长，过去的迭代里所提取过的特征，逐渐展示为当前模型的一个有效近似。我们要做的不过是把这些特征给存下来，每个特征不过是 128 个 float 的数组，即便我们存下了过去 100 个 mini-batch 的特征，不过是6400个（假设 batch size = 64）float 数组，所需要不过是几十 MB 的显存。而它带来的好处是显而易见的，我们能够组成的样本对的个数是仅仅利用当前 mini-batch 的一百倍。即便这些特征不能高精准地反映当前模型的信息，但是只要特征偏移在合理的范围内，这种数量上带来的好处，可以完全补足这种误差带来的副作用。具体来看，我们的 XBM 的方法架构大致如下：</p>
<p><img src="https://i.loli.net/2021/04/02/ixCLyrXDOHwck8u.jpg" alt="img"></p>
<p>伪代码如下：</p>
<p><img src="https://i.loli.net/2021/04/02/yWbPMmZtnerAHV3.jpg" alt="img"></p>
<p>我们的 XBM 从结构上非常简单清晰。我们先训练一个 epoch 左右，等待特征偏移变小。然后，我们使用 XBM：一个特征队列去记忆过去 mini-batch 的特征，每次迭代都会把当前 mini-batch 提取出来的新鲜特征加入队列，并把最旧的特征踢出队列，从而保证 XBM 里的特征尽量是最新的。每次去构建样本队列的时候，我们将当前 mini-batch 和 XBM 里的所有特征都进行配对比较，从而形成了巨量的样本对。如果说 XBM 存储了过去 100 个 mini-batch，那么其所产生的样本对就是基于 mini-batch 方法的 100 倍。不难发现，XBM 其实直接和过去基于样本对的方法结合，只需要把原来的 mini-batch 内的样本对换成当前 mini-batch 和 XBM 的特征构成的样本对就可以了。所以，我们通过 XBM 这种存储特征的机制，能够让不同时序的 mini-batch 的特征成功配对。</p>
<h2 id="消融实验一"><a href="#消融实验一" class="headerlink" title="消融实验一"></a><strong>消融实验一</strong></h2><p><img src="https://i.loli.net/2021/04/02/Be4GvZMLxiCbEyt.jpg" alt="img"></p>
<p>首先，我们在三个常用的检索数据集，和三个基于样本对的深度学习的方法上，使用 XBM 进行测试，同时控制其他的设置全部不变。我们发现，XBM 带来的效果很明显。尤其是在最基本的对比损失（Contrastive Loss）上，可以看到，本来这个方法只利用 mini-batch 内的样本时，其效果并不显著，但是 XBM 带来了显著的效果提升。在三个数据集， Recall@1 都至少提升 10 个点，尤其是 VehicleID 数据集的最大（Large）测试集，效果提升了 22 个点，从 70.0 到 92.5。</p>
<h2 id="消融实验二"><a href="#消融实验二" class="headerlink" title="消融实验二"></a><strong>消融实验二</strong></h2><p><img src="https://i.loli.net/2021/04/02/VD6UHdejXizlyTf.jpg" alt="img"></p>
<p>关于 mini-batch 的大小对结果的影响， 从上图可发现三点：</p>
<p><strong>1.</strong> 无论是否使用 XBM，mini-batch 越大，效果越好；</p>
<p><strong>2.</strong> XBM 方法即便是使用很小的 batch (16)， 也比没有 XBM 使用大的 batch (256) 效果好；</p>
<p><strong>3.</strong> 由于 XBM 本身可以提供正样本对，所以可以不一定要用 PK sampler 来生成 mini-batch，而是可以直接使用原始的 shuffle sampler，效果相似。</p>
<h2 id="计算资源消耗"><a href="#计算资源消耗" class="headerlink" title="计算资源消耗"></a><strong>计算资源消耗</strong></h2><p>下图我们展示了在 SOP 上训练 XBM 时的计算资源消耗，即便把整个训练集（50K+）的特征都加载到 XBM，不过需要 0.2GB 的显存；而如果是使用增大 batch 的方法，会额外需要 15GB 显存，是 XBM 的 80 倍，但是效果的提升比 XBM 差很多。毕竟 XBM 仅仅需要存特征，特征也是直过去的 mini-batch 的前向计算的结果，计算资源的需求很小。</p>
<p><img src="https://i.loli.net/2021/04/02/ATGEJLXR9UjWCN6.jpg" alt="img"></p>
<h2 id="对比-SOTA"><a href="#对比-SOTA" class="headerlink" title="对比 SOTA"></a><strong>对比 SOTA</strong></h2><p>与最近的深度度量学习方法对比，我们在四个检索数据库上效果均大幅提升，这里仅列出 VehicleID 的效果，其他数据集的效果见原论文。</p>
<p><img src="https://i.loli.net/2021/04/02/veWF2knBIuEogwj.jpg" alt="img"></p>
<p>简单来说，不同于部分文章中使用更好的网络结构，更大的输出维度，或者更大的 mini-batch 来提升效果，强行 SOTA。我们列出 XBM 在 64 的 mini-batch 在不同的主干网络下及各种维度下的效果，其效果一直是最好的。</p>
<p><strong>另外，我们的方法也将整理开源，地址在：</strong></p>
<p><strong><a href="https://link.zhihu.com/?target=https%3A//github.com/MalongTech/research-xbm" target="_blank" rel="noopener">https://github.com/MalongTech/research-xbm</a></strong></p>
<p><strong>论文地址在：</strong></p>
<p><strong><a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1912.06798" target="_blank" rel="noopener">https://arxiv.org/abs/1912.06798</a></strong></p>
<p><strong>期待与更多研究者共同学习交流。</strong></p>
<h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a><strong>可视化</strong></h2><p><img src="https://i.loli.net/2021/04/02/TIxiYh9LDWnUq4s.jpg" alt="img"></p>
<p>更多可视化见论文补充材料，有更多实例说明效果。</p>
<h2 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a><strong>总结与展望</strong></h2><p>第一，本文提出的 XBM 方法能够记住过去的特征，使得模型的训练不再仅仅依靠当前 mini-batch 的样本，而是可以跨越时空进行样本配对。从而用极小的代价，提供了巨量的样本对，为 pair-based 的深度度量学习方法取得了巨大的效果提升。这种提升难例挖掘效果的方式，也是突破了过去两个传统思路：加权和聚类，并且效果也更加简单、直接，很好地解决了深度度量学习的痛点。</p>
<p>第二，其实 Memory 机制并不是本文原创，但是用 Memory 来做难例挖掘是一个全新的尝试。同样在 CVPR 2020 获得 Oral，也是由 Kaiming He 作为一作的 MoCo 也是这种思路。<font color="red"><strong>本文的方法其实可以认为是 MoCo 在 ｍ=0 的特例</strong></font>，Kaiming 通过动量更新 key encoder，可以直接控制住特征偏移。作者认为，这种方法还会在很多任务带来提升，不局限于 Kaiming 的自监督表示学习，以及此前我们一直关注研究的度量学习（或者说监督表示学习）。</p>
<p>第三，在本文中，虽然 XBM 在所有的 pair-based 的方法都有提升，但是明显在对比损失（Contrastive Loss）上提升最大，具体原因待考。另外，我们也把在无监督表示上表现很好的 infoNCE 方法用到了深度度量学习，但效果并不显著。作者认为这两个问题的答案是同一个，且有值得深究的价值，希望在后续研究中进行进一步跟进探索。</p>
]]></content>
      <tags>
        <tag>metric learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Describing like Humans on Diversity in Image Captioning</title>
    <url>/2020/07/17/Describing-like-Humans-on-Diversity-in-Image-Captioning/</url>
    <content><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>当前的automatic metric 仅仅评估 generated caption 与 human annotations 之间的相似性。</p>
<p>但是，一张图片中包含很多内容和细节，不同的人对 image content 会有不同的兴趣点，则 human captions 也会不同。</p>
<p>基于此，仅仅去评估accuracy 是不足以评估captioning models的性能的。生成的captions 的多样性也应该考虑进来。</p>
<p>本文，针对 多样性-diversity 提出了一个评价指标。</p>
<h3 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h3><ul>
<li>即，该文要评价的系统 是可以生成多个caption的系统。是来评估，生成的这几个captions 之间的多样性是怎样的。</li>
<li>本文提到一句话：The drawback of using retrieval model is that the fluency of the captions could be poor [20], and using a very large weight for the retrieval reward will cause the model to repeat the distinctive words.</li>
</ul>
<h3 id="以下转自知乎"><a href="#以下转自知乎" class="headerlink" title="以下转自知乎"></a>以下转自知乎</h3><p><a href="https://zhuanlan.zhihu.com/p/67904095" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/67904095</a></p>
<p>这周读了CVPR 2019一篇有关测试Image Captioning多样性的文章，<a href="https://link.zhihu.com/?target=http%3A//arxiv.org/abs/1903.12020" target="_blank" rel="noopener">Describing like humans: on diversity in image captioning</a>，其主要的亮点是用Latent semantic analysis (LSA)方法来定量地衡量多样性。</p>
<h3 id="Latent-semantic-analysis-LSA"><a href="#Latent-semantic-analysis-LSA" class="headerlink" title="Latent semantic analysis (LSA)"></a>Latent semantic analysis (LSA)</h3><p>1990年的论文<a href="https://link.zhihu.com/?target=http%3A//lsa.colorado.edu/papers/JASIS.lsi.90.pdf" target="_blank" rel="noopener">Indexing by latent semantic analysis</a>最早在信息检索领域提出了LSA，其原理比较简单，核心思想是利用SVD来提取文本的潜在语义信息。</p>
<p>在Image Captioning这个特定的应用场景中，对于一张图片，假设有 <img src="https://www.zhihu.com/equation?tex=m" alt="[公式]"> 条与之相关的caption，且词汇表的总数为 <img src="https://www.zhihu.com/equation?tex=d" alt="[公式]"> ，则这组caption可以用一个 <img src="https://www.zhihu.com/equation?tex=d+%5Ctimes+m" alt="[公式]"> 的矩阵 <img src="https://www.zhihu.com/equation?tex=M" alt="[公式]"> 表示，其中的每个列向量是一条caption的bag-of-words表示。 对 <img src="https://www.zhihu.com/equation?tex=M" alt="[公式]"> 应用SVD进行分解，得到： <img src="https://www.zhihu.com/equation?tex=M+%3D+USV%5E%5Ctop" alt="[公式]"> 。 参考Quora上<a href="https://link.zhihu.com/?target=https%3A//www.quora.com/What-is-an-intuitive-explanation-of-singular-value-decomposition-SVD%23" target="_blank" rel="noopener">对SVD的讨论</a>，我们可以认为，SVD的最大作用是找到数据的“pattern”：</p>
<ul>
<li><img src="https://www.zhihu.com/equation?tex=U" alt="[公式]"> 的每一个列向量代表一种pattern，在这里可以引申为一个topic；</li>
<li>singular values <img src="https://www.zhihu.com/equation?tex=S%3Ddiag%28%5Csigma_1%2C...%2C%5Csigma_m%29" alt="[公式]"> （ <img src="https://www.zhihu.com/equation?tex=%5Csigma_1%3E%5Csigma_2%3E...%3E0" alt="[公式]"> ）则代表这些pattern对原数据的影响程度。当 <img src="https://www.zhihu.com/equation?tex=%5Csigma_1" alt="[公式]"> 明显大于其他所有 <img src="https://www.zhihu.com/equation?tex=%5Csigma_i" alt="[公式]"> 时，表示原数据仅仅受一种pattern“支配”，体现了较差的多样性；而当所有 <img src="https://www.zhihu.com/equation?tex=%5Csigma_i" alt="[公式]"> 都趋向于一致时，表示原数据由 <img src="https://www.zhihu.com/equation?tex=m" alt="[公式]"> 种pattern共同组成，说明原来的 <img src="https://www.zhihu.com/equation?tex=m" alt="[公式]"> 个caption彼此之间差异较大，体现了丰富的多样性。</li>
</ul>
<p>因此，文章认为，一组caption的多样性可以用 <img src="https://www.zhihu.com/equation?tex=r+%3D+%5Cfrac+%7B%5Csigma_1%7D+%7B%5Csum%5Em_%7Bi%3D1%7D%5Csigma_i%7D" alt="[公式]"> 度量。结合上面的分析， <img src="https://www.zhihu.com/equation?tex=r" alt="[公式]"> 的值域是 <img src="https://www.zhihu.com/equation?tex=%5B1%2Fm%2C+1%5D" alt="[公式]"> ，为了把多样性映射到 <img src="https://www.zhihu.com/equation?tex=%5B0%2C+1%5D" alt="[公式]"> ，文章对 <img src="https://www.zhihu.com/equation?tex=r" alt="[公式]"> 进行了对数变换，得到最终的多样性分数 <img src="https://www.zhihu.com/equation?tex=div+%3D+-%5Clog_m%28r%29" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=div" alt="[公式]"> 越大表示多样性越强。</p>
<h3 id="结合CIDEr的核方法"><a href="#结合CIDEr的核方法" class="headerlink" title="结合CIDEr的核方法"></a>结合CIDEr的核方法</h3><p>根据SVD的定义，得到的singular value等于矩阵 <img src="https://www.zhihu.com/equation?tex=K+%3D+M%5E%5Ctop+M" alt="[公式]"> 的eigenvalue的平方根。可以把 <img src="https://www.zhihu.com/equation?tex=K" alt="[公式]"> 看作一个核矩阵，其中的元素 <img src="https://www.zhihu.com/equation?tex=K_%7Bij%7D" alt="[公式]"> 表示caption <img src="https://www.zhihu.com/equation?tex=i" alt="[公式]"> 和caption <img src="https://www.zhihu.com/equation?tex=j" alt="[公式]"> 的相似度，因此，完全可以应用核方法（Kernelized Method），直接构造出一个 <img src="https://www.zhihu.com/equation?tex=K" alt="[公式]"> ，然后通过 <img src="https://www.zhihu.com/equation?tex=K" alt="[公式]"> 的eigenvalue计算出 <img src="https://www.zhihu.com/equation?tex=div" alt="[公式]"> 。 CIDEr是一个度量两个句子相似度的指标，主要从n-gram和TF-IDF的角度来进行度量，比起上述基于bag-of-words的方法，它显得更加合理。所以文章把CIDEr作为核函数，即 <img src="https://www.zhihu.com/equation?tex=K_%7Bij%7D+%3D+CIDEr%28c_i%2C+c_j%29" alt="[公式]"> ，从而得到另一种多样性分数，称为Self-CIDEr。</p>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>文章对多个Image Captioning模型进行了Accuracy和Diversity的测试，分别用常规的CIDEr和上述的Self-CIDEr度量。实验结果如下，其中的红色五角星代表人类标记员的表现，可以看到，人类的标记结果很好地兼顾了Accuracy和Diversity，与实际的情况相符。</p>
<p><img src="https://pic2.zhimg.com/80/v2-27a4cd22fa5acf55682d4b77d742311e_1440w.jpg" alt="img"></p>
<p>但这还不足以充分证明文章这种度量方法的合理性，于是文章计算了自动化多样性指标与人工标注的多样性分数之间的相关度，结果如下：</p>
<p><img src="https://pic4.zhimg.com/80/v2-8546e7cad02e0de2e3a5448e109049f0_1440w.jpg" alt="img"></p>
<p>其中的mBLEU-mix计算了一组caption内部的平均相似度，被一些研究者用来简单地度量多样性，但从这个实验结果可以看到，mBLEU-mix与人工标注的相关度远不如该文章提出的基于LSA的方法，证明了后者的合理性。同时，应用了核方法的Self-CIDEr又优于朴素的LSA。</p>
]]></content>
      <categories>
        <category>图像描述</category>
        <category>评价指标</category>
      </categories>
      <tags>
        <tag>评价指标</tag>
      </tags>
  </entry>
  <entry>
    <title>DirectQE Direct Pretraining for Machine Translation Quality Estimation</title>
    <url>/2020/12/24/DirectQE-Direct-Pretraining-for-Machine-Translation-Quality-Estimation/</url>
    <content><![CDATA[<p>AAAI2021论文：基于数据生成的机器翻译质量评估方法</p>
<p>来源：<a href="https://mp.weixin.qq.com/s?__biz=Mzg3ODA0NTA2OA==&amp;mid=2247484204&amp;idx=1&amp;sn=1b24bb494110fff68beedde3cb422066&amp;chksm=cf18f1cff86f78d9bdd2d883201af98c4296ec45fe8fae91509421b226ccee923ae7bd158451&amp;mpshare=1&amp;scene=1&amp;srcid=1224CwmzTjgig5X1t5fCbU0T&amp;sharer_sharetime=1608779809453&amp;sharer_shareid=ab44667880fa06ced8bfa560d1d64d36&amp;key=22efb95c8c04cdfbe43c8f83a69b76927ad01c4ab53016600f84450f07570ee6fb6b4747790c342eb1180e349f3fbc3fa8a1ab1219b80a6d725aacd79413c692d47bc3d763cd18ca87eaf3dd823648170186d2f2873bc5c2ef24ff36d3b519a54723506b60b7d4161912fd28659694c1100797e597da6bfe583dad4ef0c80802&amp;ascene=1&amp;uin=MjQwOTk2MzUwOA%3D%3D&amp;devicetype=Windows+10+x64&amp;version=6300002f&amp;lang=zh_CN&amp;exportkey=A8kVBtMx05%2Bw41YTdHRse0I%3D&amp;pass_ticket=5UOCG2UJoSjTMMc7Gh82YYMCZ5iDMMdAZnDIpIDdHbP7%2FsA%2FS9I%2B%2FHaK1%2BTsQBXL&amp;wx_header=0" target="_blank" rel="noopener">南大NLP</a></p>
<h3 id="研究问题"><a href="#研究问题" class="headerlink" title="研究问题"></a>研究问题</h3><p>目前机器翻译在各个领域得到广泛应用，不同的机器翻译系统，对于同样的原文句子可能会给出不同的翻译结果（如表1所示），质量有好有坏。该如何自动评价译文的翻译质量呢？</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>原文</th>
<th>黄河之水天上来，奔流到海不复回</th>
</tr>
</thead>
<tbody>
<tr>
<td>翻译1</td>
<td>The water of the Yellow River comes from the sky, rushes to the sea and never returns</td>
</tr>
<tr>
<td>翻译2</td>
<td>The Yellow River never comes back to the sea</td>
</tr>
<tr>
<td>翻译3</td>
<td>The Yellow River comes from the sky, runs to the sea and never comes back</td>
</tr>
<tr>
<td>翻译4</td>
<td>The water of the Yellow River came from the sky and ran to the sea</td>
</tr>
<tr>
<td>翻译5</td>
<td>The water of the Yellow River comes from the sky, and the waves rush to the East China Sea and never look back</td>
</tr>
</tbody>
</table>
</div>
<p>表格 1：机器翻译的不同结果</p>
<h3 id="研究现状"><a href="#研究现状" class="headerlink" title="研究现状"></a>研究现状</h3><p>目前的评价指标主要有两类。一类需要依赖参考译文，比如BLEU、TER、Meteor等，主要依赖机器翻译译文和参考译文之间的匹配程度，<strong style="color:red;">但参考译文在现实应用场景下往往难以获取。</strong>第二类评价指标不需要依赖参考译文，如质量评估Quality Estimation (QE)，仅通过原文和机器译文对翻译质量进行估计。</p>
<p>QE的粒度有很多种，包括词级别、句子级别、短语级别、文档级别等，<strong style="color:red;">本文主要关注词级别与句子级别QE任务。</strong>词级别QE将译文中的每一个词标记为“Ok”或“Bad“；句子级别QE给每一个句子标注一个[0, 1]之间的打分（0表示很好，1表示很差），这些标记都由人工标记得到，或基于人工编辑结果得到。表2展示了一个英-中语向的QE数据示例。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>原文（英）</th>
<th>this insubordination earned him a now famous reprimand from the King .</th>
</tr>
</thead>
<tbody>
<tr>
<td>机器译文（中）</td>
<td>这种 <strong style="color:blue;">不 服从命令</strong> 的 态度 使 他 <strong style="color:blue;">赢得 了 国王 现在 著名</strong> 的 <strong style="color:blue;">训斥</strong> .</td>
</tr>
<tr>
<td>词级别标记</td>
<td>O B B O O O O B B B B B O B B</td>
</tr>
<tr>
<td>句子级别标记</td>
<td>0.6429</td>
</tr>
</tbody>
</table>
</div>
<p>表格 2：QE数据示例（WMT20英-中）</p>
<p>早期QE任务依赖人工设计的特征，例如原文、译文中的单词数量，词频等，但是该方法的适应性较弱，效果较差。<strong style="color:red;">随后有研究者使用神经网络对QE数据进行端到端建模，取得了一定的成绩。</strong>神经网络需要大规模数据进行训练，但是<strong style="color:red;">QE数据由于需要人工进行标记，暂时规模较小</strong>（万句级别），这限制了神经网络的训练。<strong style="color:red;">目前最流行的QE模型利用知识迁移技术，从无QE标记但具有大规模（百万句级别）的平行语料中迁移QE任务所需要的知识。</strong></p>
<p>Predictor-Estimator是一种流行的基于知识迁移的QE框架，它是一种两阶段模型（如图一所示）。第一阶段，预测器（Predictor）将在平行语料上进行预训练，其预训练任务一般为“词预测”类型的任务。第二阶段，使用预测器提取QE句对的特征，通过评估器（Estimator）学习如何在这些特征上拟合QE标记。</p>
<p><img src="https://i.loli.net/2020/12/30/hLHD7IOQgznTZJd.png" alt="image-20201230101547991" style="zoom:33%;"></p>
<p>我们可以使用神经机器翻译模型NMT（Kim et al. 2017, Fan et al. 2018, Zhou et al. 2019）或者预训练语言模型PLM（Kepler et al. 2019, Kim et al. 2019）来作为预测器，使用LSTM模型作为评估器。</p>
<p><strong style="color:red;">该框架的问题在于，其两阶段之间存在差异，包括数据的差异和训练目标的差异。</strong> 数据的差异是指，<strong style="color:blue;">预测器</strong>在大规模平行语料上训练，平行语料由原文和正确译文组成；<strong style="color:blue;">评估器</strong>在QE数据上训练，句对由原文和包含错误的机器翻译译文组成。训练目标的差异是指，预测器是在做“词预测”任务；评估器是在预测词和句子的质量。那么预测器的预训练过程与目标QE任务存在差异，会导致学习不到QE任务真正需要的知识，无法充分利用大规模双语平行数据。</p>
<h3 id="本文提出的方法"><a href="#本文提出的方法" class="headerlink" title="本文提出的方法"></a>本文提出的方法</h3><p>QE模型的现存问题主要是，1.大规模神经网络训练参数依赖大量数据；2.数据分布及训练目标的差异可能对两阶段训练带来不利影响。</p>
<p>为了解决这两个问题，我们采取的改进方向是：</p>
<ol>
<li><p>使用相同/相似的数据进行预训练；</p>
</li>
<li><p>使用相同/相似的预训练目标。</p>
</li>
</ol>
<p>QE数据中包含一些翻译噪音，QE的训练目标需要质量标签。那么如何基于平行语料，获得带有一定噪音的数据，并且可以获得噪音数据的质量标签？</p>
<p>我们的解决方法是，<strong style="color:green;">首先基于平行数据训练生成器（generator）进行词改写任务；接着对平行语料进行词改写，从而引入一定量的可控噪音并利用可控噪音自动生成质量标签。最终可以将这些生成数据提供给判别器（detector）直接为QE任务进行预训练。</strong> 接下来具体介绍生成器的训练与生成过程。</p>
<p>首先，我们以Masked Language Model (MLM)的方式训练生成器。给定平行句对，随机的隐藏（mask）译文中某个位置的词，然后让模型预测被隐藏的词（如图2所示）。</p>
<p><img src="https://i.loli.net/2020/12/30/UfN9cyzTM8CZb6n.png" alt="image-20201230101626106" style="zoom: 50%;"></p>
<p>生成器训练结束后，我们将使用生成器对平行语料进行转化，具体分为两个步骤。</p>
<ol>
<li>生成伪造机器翻译译文。给定平行语料并隐藏译文中某个位置的词，让生成器进行预测并输出概率分布，根据概率分布采样新的词替换被隐藏词（如图3所示），即完成了对被隐藏词的改写。</li>
</ol>
<p><img src="https://i.loli.net/2020/12/30/HJvEwk2ZhzyC7KB.png" alt="image-20201230101742561" style="zoom:50%;"></p>
<ol>
<li><p>生成对应标签。</p>
<p>根据译文中的词是否被改写来获得词级别标签（见公式1）。</p>
<p>根据译文中被改写词的比例获得句子级别标签q’（见公式2）。</p>
<p>公式1： $o_{j}^{\prime}=\left\{\begin{array}{ll}1, &amp; \text { if } y_{j}=y_{j}^{\prime} \\ 0, &amp; \text { otherwise }\end{array}\right.$</p>
<p>公式2： $q^{\prime}=1-\frac{\operatorname{sum}\left(\mathbf{O}^{\prime}\right)}{\operatorname{len}\left(\mathbf{O}^{\prime}\right)}$</p>
</li>
</ol>
<p>通过生成器，我们能够将大规模平行语料转化为更大规模的伪造QE数据。比起平行译文，伪造的机器翻译译文在数据分布上与QE中的译文更加接近。同时，伪造QE数据针对每一个词有表示“是否由机器生成“的标签，对整个句子有表示”句子改写程度“的标签，形式上与QE数据类似。<strong style="color:green;">基于大规模伪造QE数据以及真实QE数据，我们将使用同样的训练目标，对判别器（Detector）分别在伪造数据上进行预训练、在真实数据上微调参数。最终也只需要使用判别器来做QE分数预测。</strong></p>
<blockquote>
<p>即，生成的数据，仅仅是在estimator 上提供预训练数据</p>
<p>即本文，并没有对 predictor做改动，是对estimator 的训练策略上做了改动</p>
</blockquote>
<p>我们对比了Predictor-Estimator框架中的两种具体实现。一种是基于NMT的QE模型，具体实现仿照QE Brain模型(Fan et al. 2018)；一种是基于PLM的QE模型，具体使用的PLM模型来自于huggingface。在本文的实现中，我们所提出的<strong>DirectQE</strong>参数量是最小的。</p>
<p>实验结果如表3，4，5所示，可以发现我们的模型在绝大多数情况下都是具有优势的。</p>
<p>表格 3：单模型结果（英-德）</p>
<p><img src="https://i.loli.net/2020/12/30/4OZDeJgo7CmGX5l.png" alt="image-20201230102042709"></p>
<p>表格 4：集成模型结果（英-德）</p>
<p><img src="https://i.loli.net/2020/12/24/UkC5rKy9ZoWh8Ab.png" alt="image-20201224114950396" style="zoom:33%;"></p>
<p>表格 5：单模型结果（英-中、英-俄）</p>
<p><img src="https://i.loli.net/2020/12/24/87bizODk5VYjdxQ.png" alt="image-20201224115010524" style="zoom: 25%;"></p>
<p>为了找出我们模型性能具体的增长点，我们按照错误词的比例划分了真实QE数据集，并评估了模型在数据每个部分的性能。如图4所示，在翻译质量存在问题时（错误词比例&gt;12.5%），DirectQE的性能更好。</p>
<p>图表 4：模型在不同错误比例数据上的性能对比</p>
<p><img src="https://i.loli.net/2020/12/30/SOFaCUxnjHIuV4X.png" alt="image-20201230101815866"></p>
<p>为了研究预训练使用的数据分布对QE性能的影响，我们使用基于NMT的QE模型，并且将其中训练预测器用到的平行语料替换为生成器制造的伪造机器翻译译文，其余部分均保持不变。从表6中可以看出，使用伪造译文的模型性能有所上升，说明对于QE任务而言，使用伪造译文预训练比平行译文更好。</p>
<p>表格 6：使用伪造译文/平行译文训练基于NMT的QE系统</p>
<p><img src="https://i.loli.net/2020/12/24/r2zCSgNepfovnET.png" alt="image-20201224115311979" style="zoom: 33%;"></p>
<p>为了研究预训练数据质量对QE性能的影响，我们测试了不同质量的数据下QE性能，这里数据质量具体指是译文质量，可以体现在替换词比例上（在相同替换策略下，替换词比例越大，译文质量越差）。从图5中可以看出，伪造译文质量太好或者太坏都不利于最终QE的性能。伪造译文质量太好（替换比例很低），句子将接近于平行语料本身，数据中几乎没有噪音；而伪造译文质量太差时，会破坏句子结构，与真实QE译文数据分布有较大差异。图5中红点表示使用随机噪音替换被隐藏词，此时的译文质量很差，可以看到QE性能也很低。</p>
<p>图表 5：不同伪造译文质量下的QE模型性能</p>
<p><img src="https://i.loli.net/2020/12/30/kSiwhoP47EzGx9Y.png" alt="image-20201230101837656" style="zoom: 33%;"></p>
<p>在固定规模的平行语料上，生成器每一次采样会产生不同的伪造QE数据，最终用于训练判别器的数据规模是超百万级别的，且更多样化。为了研究多样性的价值，我们使用生成器产生了固定数量的伪造QE数据，对比了在固定生成的数据上以及持续生成的数据上预训练的模型性能。结果（图6）显示，<strong style="color:red;">伪造QE数据的多样性对提升模型性能来说很重要。</strong></p>
<p>图6：</p>
<p><img src="https://i.loli.net/2020/12/30/nh5G1rxMRPpDgmO.png" alt="image-20201230101857603" style="zoom:50%;"></p>
<p>词级别QE任务需要判别当前词的质量，那么模型在建模当前词时，包含更多当前词的信息是有必要的。为了体现模型隐层表示含有当前词信息的多与少，我们计算了隐层表示与当前词之间的互信息（模型指判别器/预测器）。在图7中可以看到，DirectQE学到的表示中包含有更多当前词的信息。</p>
<p>图表 7：模型隐层表示 v.s. 当前词信息</p>
<p><img src="https://i.loli.net/2020/12/30/b43AOK7aHm1QklR.png" alt="image-20201230101937525" style="zoom:33%;"></p>
<p>假设当模型针对下游任务进行微调时，模型的隐层表示改变越小，则原始的表示更适合该下游任务。为了研究是否DirectQE可以学习到更加适合QE任务的表示，我们测试了在真实QE数据上微调前后，DirectQE和基于NMT的QE模型的隐层表示之间的相似度。表7显示，DirectQE隐层表示的相似度较高，说明DirectQE可以学到更加适合QE任务的表示。</p>
<p>表格 7：微调前后隐层表示变化</p>
<p><img src="https://i.loli.net/2020/12/30/F5c2lrWGv8wuMnP.png" alt="image-20201230101958503" style="zoom:33%;"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>大规模的QE模型需要大规模数据进行参数训练。现有的两阶段方法，由于数据和训练目标差异，无法最大化利用大规模平行语料知识。我们提出一种直接为QE模型进行预训练的框架（DirectQE）——使用生成器由平行语料得到伪QE数据，而后使用判别器，在伪QE数据上进行预训练，并且使用真实QE数据微调。我们模型的优势是，参数规模更小，模型性能更好，并且易于使用。</p>
<p>未来，我们将考虑使用更多样化的方式来构造伪QE数据，进一步缓解数据差异带来的影响，最大程度利用大规模语料，提升QE模型性能。</p>
<h3 id="可查看的参考文献"><a href="#可查看的参考文献" class="headerlink" title="可查看的参考文献"></a>可查看的参考文献</h3><ul>
<li><p>Predictor-Estimator: Neural Quality Estimation Based on Target Word Prediction for Machine Translation</p>
<p><a href="https://unbabel.github.io/OpenKiwi/cli/train_predictor_estimator.html" target="_blank" rel="noopener">https://unbabel.github.io/OpenKiwi/cli/train_predictor_estimator.html</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Egoshots, an ego-vision life-logging dataset and semantic fidelity metric to evaluate diversity in image captioning models</title>
    <url>/2020/04/01/Egoshots-an-ego-vision-life-logging-dataset-and-semantic-fidelity-metric-to-evaluate-diversity-in-image-captioning-models/</url>
    <content><![CDATA[<h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><ul>
<li><p>当前的image caption dataset 存在的问题</p>
<p>图像字幕模型已经能够生成语法正确且易于理解的句子。但是，大多数字幕传达的信息有限，因为所使用的模型是在数据集上训练的，而该数据集并未为日常生活中存在的所有可能的对象提供字幕。由于缺少先验信息，因此大多数字幕仅偏向场景中出现的少数几个对象，因此限制了它们在日常生活中的使用。在本文中，我们试图证明当前现有图像字幕模型的偏向性，并提出一个新的图像字幕数据集<em>Egoshots</em>，由978张不带字幕的现实生活图像组成。我们进一步利用最先进的预训练图像字幕和对象识别网络来注释我们的图像并显示现有作品的局限性。</p>
</li>
<li><p>当前的standard metric存在的问题</p>
<p>此外，为了评估所生成字幕的质量，我们提出了一种新的图像字幕度量标准，即基于对象的<em>语义保真度</em>（SF）。现有的图像字幕度量标准只能在存在其相应注释（reference captions）的情况下评估字幕。但是，SF允许评估为图像生成的字幕而没有注释，这对于现实生活中生成的字幕非常有用。</p>
</li>
</ul>
<h4 id="SF"><a href="#SF" class="headerlink" title="SF"></a>SF</h4><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gdel85qhz8j30se0g97eb.jpg" alt="搜狗截图20200401212845.png"></p>
<h4 id="Annotation-Pipline-and-Sementic-Fidelity-Metric"><a href="#Annotation-Pipline-and-Sementic-Fidelity-Metric" class="headerlink" title="Annotation Pipline and Sementic Fidelity Metric"></a>Annotation Pipline and Sementic Fidelity Metric</h4><ul>
<li><p>annotation pipline</p>
<p>使用三个预训练好的caption model: Show Attend And Tell (SAT), nocaps: novel object captioning at scale (NOC), and Decoupled Novel Object Captioner (DNOC) 在新的数据集Egoshots上进行captioning 任务。</p>
</li>
<li><p>sementic fidelity metric</p>
<p>我们提出了一种称为<em>语义保真</em>度的新图像字幕指标。SF考虑了两个元素：1）生成的字幕与图像中检测到的对象的语义接近度； 2）相对于检测到的对象实例数量的对象多样性。假设有一个最新的准完美对象检测器，通过考虑这两组（带字幕和检测到的）实体（即对象）之间的语义亲密性，当一个模型输出的caption中包含了并没有出现在image scene中的objects时，将进行惩罚。</p>
<p>公式：<img src="http://ww1.sinaimg.cn/large/006uWRWVly1gdelh0afpej3055021a9x.jpg" alt="搜狗截图20200401213725.png"></p>
<p>对于图像i，si是其预测字幕c i中的名词词与OD检测到的对象名词之间的语义相似性，＃O是O O D的基数，＃N是名词的数量（表示对象in N i）存在于caption i中。SF的范围为[0，1]：SF接近1的字幕传达更多信息，并且在语义上更接近于要字幕的场景（就字幕所涉及的对象而言）。</p>
<p>关于si的计算：Recent works (Mikolov et al., 2013; Conneau et al., 2017) show the ability of word embeddings that is transforming a word into its vectored form efficiently capture the semantic closeness of two given words. The SF metric uses this approach to calculate such semantic similarity between the noun words and objects in an image.</p>
<p>上述公式存在一个假设：that #O ≥ #N (Assumption 1) for all images. This approach to compute SF will work only assuming robust object detectors satisfying enough scene annotation granularity.  </p>
<p>同时为保证分母不为0，还需要一个假设：Assumption 2: #O ！= 0 (i.e., the object detector can at least detect one object in the image). </p>
<h4 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h4></li>
<li><p>在上述新提出的metric中，如果使用SF执行字幕评估，则良好通用化且鲁棒的对象检测模型将扮演最重要的角色。（a well generalized and robust object detection model plays the most important role if<br>the evaluation of captions is performed using SF. ）</p>
</li>
<li>在物体检测器发生故障的情况下，度量是不可靠的。由于SF将无法惩罚字幕模型，因为它不能依赖忠实（即足够鲁棒）的对象检测器（＃O = 0，假设2损坏），因此无法应用SF。</li>
</ul>
<h4 id="Appendix-指标限制"><a href="#Appendix-指标限制" class="headerlink" title="Appendix: 指标限制"></a>Appendix: 指标限制</h4><ul>
<li><p>我们必须注意到度量标准的一些局限性，应加以补充/扩展为（1）解释字幕的动词和其他句法元素（当前只考虑了名词）；（2）根据解释的质量对字幕进行评分，并考虑图像中相同类型的对象相对于字幕中存在的对象的数量。诸如（Cohen17）之类的特定计数模型是有关如何增强此处提出的无标签数据集注释管道的特定示例。</p>
<p>应该在更有针对性的应用程序使用案例中评估指标，例如，在诸如导航，对目标用户（如盲人）的有用性。</p>
</li>
</ul>
<h4 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h4><ul>
<li>其实本文尝试使用一个open-domain dataset 来测试在 in-domain 上训练的captioning model的泛化性能。但是这本身就存在问题！因为，model本身就会受限于训练数据，因此这里却希望它有很强的泛化性能，这本身就太难为model了。<code>eg: 不能要求一个学了小学课程的人来做高中生的题目</code></li>
</ul>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul>
<li><p>Tomas Mikolov, Ilya Sutskever, Kai Chen, Gregory S. Corrado, and Jeffrey Dean. </p>
<p>Distributed Representations of Words and Phrases and their  Compositionality. In NIPS, 2013. </p>
</li>
<li><p>Alexis Conneau, Guillaume Lample, Marc’Aurelio Ranzato, Ludovic Denoyer, and Herve J ´ egou. ´<br>Word Translation Without Parallel Data. ArXiv, abs/1710.04087, 2017 </p>
</li>
<li><p>Joseph Paul Cohen, Genevieve Boucher, Craig A. Glastonbury, Henry Z. Lo, and Yoshua Bengio.<br>Count-ception: Counting by Fully Convolutional Redundant Counting. In The IEEE International<br>Conference on Computer Vision (ICCV) Workshops, Oct 2017. </p>
</li>
</ul>
]]></content>
      <categories>
        <category>图像描述</category>
        <category>评价指标</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>End-to-End Learning of Visual Representations from Uncurated Instructional Videos</title>
    <url>/2020/12/30/End-to-End-Learning-of-Visual-Representations-from-Uncurated-Instructional-Videos/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/12/30/yfHDiZusbKvM2AY.png" alt="image-20201230171856275" style="zoom:67%;"></p>
<p><img src="https://i.loli.net/2020/12/30/C1HmZXKLzFlBDGM.png" alt="image-20201230171925959" style="zoom:67%;"></p>
<p><img src="https://i.loli.net/2020/12/30/3AudkSImHtnrwha.png" alt="image-20201230172037294"></p>
]]></content>
      <categories>
        <category>Video Pre-trained Models</category>
      </categories>
      <tags>
        <tag>Video Pre-trained Models</tag>
      </tags>
  </entry>
  <entry>
    <title>Evaluating Models&#39; Local Decision Boundaries via Contrast Sets</title>
    <url>/2021/02/19/Evaluating-Models-Local-Decision-Boundaries-via-Contrast-Sets/</url>
    <content><![CDATA[<p><strong>论文标题：</strong>Evaluating Models’ Local Decision Boundaries via Contrast Sets</p>
<p><strong>论文链接：</strong><a href="https://arxiv.org/abs/2004.02709" target="_blank" rel="noopener">https://arxiv.org/abs/2004.02709</a></p>
<p><strong>数据集：</strong><a href="https://allennlp.org/contrast-sets" target="_blank" rel="noopener">https://allennlp.org/contrast-sets</a></p>
<p><strong>Main Contribution：</strong>训练集与测试集 i.i.d 的假设使得模型很难泛化，文章提出了在原始测试集构建 contrast test set 的方法，可以真实的评估模型的语言能力。</p>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a><strong>Motivation</strong></h2><p>这里用了一个 toy example 和一个真实示例来表示作者想要提出并解决的问题。</p>
<p><strong>Toy Example</strong></p>
<p>考虑二维的情况，下图中的两分类问题需要一个非常复杂的 decision boundary。</p>
<p><img src="https://i.loli.net/2021/02/19/sfK5PyknNElIVoJ.png" alt="image-20210219175052164" style="zoom:33%;"></p>
<p>但是在很多情况下，由于采样的 biased，我们很可能得到如下的数据集：</p>
<p><img src="https://i.loli.net/2021/02/19/PBUDYm6LK7S3IN5.png" alt="image-20210219175104378" style="zoom:33%;"></p>
<p>网络通过一个很简单的 decision boundary 就可以将它们分类，而由于训练测试数据集独立同分布，虽然这个 decision boundary 非常差，但它在测试集表现得非常好。理想情况下，如果我们完整采样整个数据集，所有问题都迎刃而解，但这显然是很难做到的。为了正确的测试模型的能力，作者提出了对测试集做 perturbation 的方法：对测试集的每一个实例，我们生成一系列与之类似的测试样本（Contrast Set：下图中的灰色圆圈）。</p>
<p><img src="https://i.loli.net/2021/02/19/CdF9GOxAJe2aEv3.png" alt="image-20210219175121207" style="zoom:33%;"></p>
<p><strong>Complex NLP Task</strong></p>
<p>我们很难用图把 NLP task 中存在的问题进行描述，但是有很多工作支撑了这一观点。比较有意思的示例为在 SNLI 数据集中，表明单词”睡觉”，”电视”和”猫”几乎从来没有同时出现数据中，但是它们经常出现在 contradiction 的例子中。所以 model 很容易的学到“同时出现’睡觉’和’猫’的句子都是 contradiction sentence，并且这一分类标准工作得很好”。 </p>
<p>在初始数据收集过程中完全消除这些差距将是非常理想化的，在一个非常高维的空间中，语言有太多的可变性。相反，该文使用 Contrast Set 来填补测试数据中的空白，从而给出比原始数据提供的更全面的评估。</p>
<h2 id="Contrast-sets"><a href="#Contrast-sets" class="headerlink" title="Contrast sets"></a><strong>Contrast sets</strong></h2><p>假设我们现在为测试样本 构建 Contrast Set，有两个要点 (i) 构建样本距离与  小于某个阈值。(ii) Label 与 <strong>不一致</strong>。下图是在 NLVR2 数据集上的一些实例，在这里，句子和图像都通过一些很简单的方式进行修改（例如，通过改变句子中的一个词或找到一个相似但有区别的词），从而使输出标签发生变化。</p>
<p><img src="https://i.loli.net/2021/02/19/tlN7BZIVnDCsYed.png" alt="image-20210219175240236" style="zoom:50%;"></p>
<p>我们需要注意，contrast set 和 adversarial examples 是不一样的，对抗样本的目的是对句子/图像做 perturbation，但是保持原标签不变。 </p>
<p>不过文章中如何计算样本距离，阈值的确定，label 是否发生变化，都是由 expert 给出的。</p>
<h2 id="How-to-Create-Contrast-Sets"><a href="#How-to-Create-Contrast-Sets" class="headerlink" title="How to Create Contrast Sets"></a><strong>How to Create Contrast Sets</strong></h2><p>作者用了三个数据集来展示 Contrast Sets 的构造过程。</p>
<p><strong>DROP</strong></p>
<p>DROP 是一个阅读理解数据集，旨在涵盖对段落中的数字进行组合推理，包括过滤、排序和计数，以及进行数值运算。数据主要来自 (i) Wikipedia (ii) 美国足球联赛的描述。(iii) 人口普查结果说明。(iv) 战争摘要。作者发现数据集中存在明显的 bias，比如一旦问题是”How many…”，结果很多情况都是 2。关于事件顺序的问题通常遵循段落的线性顺序，而且大部分问题不需要理解。 </p>
<p>作者从三个方面改进这个数据集：</p>
<ul>
<li>关于足球联赛的问题往往需要推理和比较（比如询问两场比赛得分的差值），但是其他类型的数据很少需要推理比较，因此作者为他们提供额外的需要推理比较的问题；</li>
<li>将问题的部分语义颠倒，类似于 shortest 变为 longest, later 变为 earlier, How many countries 变为 which countries 等等；</li>
<li>改变事件发生的顺序，使得与事件顺序相关的问题推理难度增加。</li>
</ul>
<p><strong>NLVR2</strong></p>
<p>给模型一对图像与一个句子，判断这句话正确与否。这个数据集的特点在于 compositional reasoning，我们需要模型理解图像中的物体的属性，物体与物体的关系，物体与场景的关系。 </p>
<p>我们通过修改句子或用网络搜索中获得自由许可的图片替换其中一张图片来构建 NLVR2 的 Contrast Set。 </p>
<p>比如将句子”The leftimage contains twice the number of dogs as theright image”改为“The left image containsthree timesthe number of dogs as the right image”。或者对一个图像对，将原本 4 条狗的图像换成其他数目。也可以对一些量词比如”at least one”改为”exactly one”，或者实体”dogs”改为”cats”，或者属性”yellow”改为“red”。</p>
<p><strong>UD  Parsing</strong> </p>
<p>这是一个 dependency parsing 的数据集。作者想要通过这个数据集证明 Contrast set 不仅在 high-level 的 NLP 任务中有效，也在语义分析的任务中有效。具体方法可以查看原文。</p>
<p><img src="https://i.loli.net/2021/02/19/CzWXEFJs63dDHAq.png" alt="image-20210219175335245"></p>
<p>可以看到，再加上 Contrast Set 之后，SOTA models 的性能都有了显著的下降。</p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP,evaluation</tag>
      </tags>
  </entry>
  <entry>
    <title>FPN</title>
    <url>/2019/08/01/FPN/</url>
    <content><![CDATA[<ul>
<li><a href="https://vision.cornell.edu/se3/wp-content/uploads/2017/07/fpn-poster.pdf" target="_blank" rel="noopener">poster</a></li>
<li><a href="https://blog.csdn.net/WZZ18191171661/article/details/79494534" target="_blank" rel="noopener">某篇博客</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Exploiting Cloze Questions for Few Shot Text Classification and Natural Language Inference</title>
    <url>/2021/04/06/Exploiting-Cloze-Questions-for-Few-Shot-Text-Classification-and-Natural-Language-Inference/</url>
    <content><![CDATA[<h2 id="1-存在的问题"><a href="#1-存在的问题" class="headerlink" title="1. 存在的问题"></a>1. 存在的问题</h2><p>当前的语言模型都依赖大量的数据，但是在现实中，大量的标注数据是很难获取的(cost) 。因此，在少样本下的训练方式需要被研究。</p>
<h2 id="2-本文的点"><a href="#2-本文的点" class="headerlink" title="2. 本文的点"></a>2. 本文的点</h2><ul>
<li>本文出发点：将任务描述 （task description）组合到模型的输入中，会使得任务变得简单。</li>
<li><p>通过本文提出的Pattern-Exploiting Training (PET)，<strong>将输入样本转为cloze-style phrases。并以半监督的方式来训练</strong>。具体的分为以下三步：</p>
<ul>
<li>(1) 首先设计了几种pattern, 对于不同的pattern，在小的训练集上以cloze-style的方式进行训练。</li>
<li>(2) 使用(1)中训练出来的多个模型的集成，来为未标记样本添加soft labels。</li>
<li>(3) 使用(2) 中<font color="red">扩充的伪标签数据 Finetune 一个<strong>常规</strong></font> 的（非 MLM 的）模型。</li>
</ul>
</li>
<li><p>在多语言的不同任务集上，本文表明，给定少量到中等数量的标记示例，本文提出的PET的表现大幅优于无监督方法、监督训练和强半监督基线。</p>
</li>
</ul>
<h2 id="3-PET"><a href="#3-PET" class="headerlink" title="3. PET"></a>3. PET</h2><p>We define a <strong>pattern</strong> to be a function $P$ that takes $\mathrm{x}$ as input and outputs a phrase or sentence $P(\mathbf{x}) \in V^{*}$ that contains exactly one mask token, i.e., its output can be viewed as a cloze question. </p>
<p>We define a <strong>verbalizer</strong> as an injective function $v: \mathcal{L} \rightarrow V$ that maps each label to a word from $M$ ‘s vocabulary. We refer to $(P, v)$ as a pattern-verbalizer pair (PVP).</p>
<h3 id="3-1-PVP-Training-and-Inference"><a href="#3-1-PVP-Training-and-Inference" class="headerlink" title="3.1 PVP Training and Inference"></a>3.1 PVP Training and Inference</h3>]]></content>
      <categories>
        <category>NLP</category>
        <category>few-shot learning</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>few-shot learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Fill-in-the-Blank as a Challenging Video Understanding Evaluation Framework</title>
    <url>/2021/04/13/Fill-in-the-Blank-as-a-Challenging-Video-Understanding-Evaluation-Framework/</url>
    <content><![CDATA[<h2 id="本文研究的任务"><a href="#本文研究的任务" class="headerlink" title="本文研究的任务"></a>本文研究的任务</h2><p>本文提出了一个新的任务，给定一段视频和一个带有blank的文本，目标是对blank进行补充。该任务的目的是测试系统（模型）对视频的理解。</p>
<p>In this task, given a video and a blanked caption, the model needs to generate the missing phrase.</p>
<h2 id="目前存在的问题"><a href="#目前存在的问题" class="headerlink" title="目前存在的问题"></a>目前存在的问题</h2><p>迄今为止，有关语言知识的视频理解的工作主要解决了两个任务：（1）<strong>使用多项选择题的方式来做视频VQA任务</strong>，当前模型的性能一般表现都相对较好，这是因为多项选择的方式，使得候选答案是容易获得的；（2）<strong>视频描述任务</strong>，通常会以开放式评估框架来对生成的caption进行评估，但是这种评估方式存在缺陷。比如，如果prediction的形式与reference有所不同，则prediction可能被认为是不正确的。</p>
<p>因此，在本文中，提出了一个fill-in-the-blanks任务来作为 视频理解评估框架，以解决以上的问题。这种任务形式，更加符合现实生活中，是没有预先给定多项选择的。</p>
<h2 id="fill-in-the-blank-task-的优势"><a href="#fill-in-the-blank-task-的优势" class="headerlink" title="fill-in-the-blank task 的优势"></a>fill-in-the-blank task 的优势</h2><ul>
<li>相比于 多项选择的video VQA 更加符合现实场景</li>
<li>不会遇到 video captioning 评估存在偏差的问题</li>
<li>fill-in-the-blank data 是可以自动生成的，因此训练数据的规模是可以无限增大的</li>
</ul>
<h2 id="构建数据集"><a href="#构建数据集" class="headerlink" title="构建数据集"></a>构建数据集</h2><p>我们通过两个步骤来构建这个 “填空 “视频数据集。 (1)数据生成，我们编制了大量的视频-字幕对，并有选择地挖去某些<strong>名词</strong>（multi-word spans）。 (2)数据标注，AMT workers 为这些空白提供<strong>额外</strong>的有效答案。（收集这种附加注释的主要原因是为了说明语言的自然多样性，并为每个空白有多个备选答案。）</p>
<p><strong>数据来源：</strong>we generate our training, validation, and test data starting with the VATEX v1.1 training set, a random subset of size 1,000 from the validation set, and a random subset of size 1,000 from the test set, respectively.</p>
<p><img src="https://i.loli.net/2021/04/13/dHsFYELJyvQunef.png" alt="image-20210413180750120" style="zoom: 50%;"></p>
<h2 id="本文设计的方法"><a href="#本文设计的方法" class="headerlink" title="本文设计的方法"></a>本文设计的方法</h2><p>本文设计了两种encoder: 早期融合encoder 和 后期融合encoder</p>
<p><img src="https://i.loli.net/2021/04/13/pJkgYWhMsncd7TN.png" alt="image-20210413183537583"></p>
<p>考虑到 <strong>T5</strong> 可以填充可变长度的blanks的能力，因此使用 <strong>T5</strong> 来初始化本文的多模态模型。</p>
<p>对于early fusion model: 使用T5-base weights。</p>
<p>对于late fusion model: 使用 T5-base 来初始化 text encoder 和 decoder。使用两个一层transformer 来作为video encoder 和 multimodal transformer encoder。</p>
<p>特殊字符：the special token <strong><extra_id_0></extra_id_0></strong> is used to represent the blanked phrase, and <strong>&lt;\s&gt;</strong> is used to separate the text and video sequences。</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>本文提出了两个baseline:</p>
<ul>
<li>使用最频繁的answer作为预测：“a man”</li>
<li>Text-based Transformer (T5): 使用text-only model来测试该文构建数据集的language bias</li>
</ul>
<p>评估指标（Evaluation Metrics）</p>
<ul>
<li><p>exact match： we count a generated text string as correct if it has at least one string-level match among the provided annotations.</p>
</li>
<li><p>token-level F1：we compute the token overlap (true positives) between the generated text string and each annotation, normalize by the sum of the true positives and average of the false negatives/positives, then compute the maximum across all annotations. </p>
</li>
</ul>
<h3 id="本文数据集的-langauge-bias如何"><a href="#本文数据集的-langauge-bias如何" class="headerlink" title="本文数据集的 langauge bias如何"></a>本文数据集的 langauge bias如何</h3><ul>
<li>T5 fine-tuned 结果与 下面 multimodal models的结果相差不多，可以看到其实语言偏置还是很大的。</li>
</ul>
<p><img src="https://i.loli.net/2021/04/13/Pmf9nKMXdWvqAN8.png" alt="image-20210413185634092"></p>
<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><ul>
<li><p>(1) 仅对 noun phrase 挖空，(2) 只挖了一个空，都是对任务的简化，使得该任务变得简单。</p>
</li>
<li><p>文中图表说明，最频繁的名词是 man, person。这是这个数据集的 language bias。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>cross-modal</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
      </tags>
  </entry>
  <entry>
    <title>Finding It: Weakly-Supervised Reference-Aware Visual Grounding in Instructional Videos</title>
    <url>/2019/12/02/Finding-It-Weakly-Supervised-Reference-Aware-Visual-Grounding-in-Instructional-Videos/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>From Recognition to Cognition: Visual Commonsense Reasoning</title>
    <url>/2020/05/16/From-Recognition-to-Cognition-Visual-Commonsense-Reasoning/</url>
    <content><![CDATA[<h4 id="Visual-Commonsense-Reasoning-VCR"><a href="#Visual-Commonsense-Reasoning-VCR" class="headerlink" title="Visual Commonsense Reasoning (VCR)"></a>Visual Commonsense Reasoning (VCR)</h4><p>VCR: Given an image, a list of regions, and a question, a model must answer the question and provide a rationale explaining why its answer is right. </p>
<p>标注数据：为了避免生成式问题中评价指标的缺陷，本任务设计成 <strong>选择题</strong> 任务，即，提供一个image，一个question，多个answer，该任务要求从多个答案中选择一个正确的答案。对于correct answer：给定一张图片，要求AMT workers 写一个question，一个answer。对于wrong answer：使用adversarial matching 来获得其余的negative answer。</p>
<h4 id="The-Motivation-of-Adversarial-Matching"><a href="#The-Motivation-of-Adversarial-Matching" class="headerlink" title="The Motivation of Adversarial Matching"></a>The Motivation of Adversarial Matching</h4><p>在构建数据集时，常常存在两种挑战：</p>
<ul>
<li><p><strong>A crucial challenge</strong> in constructing a dataset of this complexity at this scale is how to avoid <strong>annotation artifacts</strong>. </p>
</li>
<li><p><strong>A recurring challenge</strong> in most recent QA datasets has been that human-written answers contain unexpected but distinct <strong>biases</strong> that models can easily exploit. 现实世界中的偏置</p>
</li>
</ul>
<p>通常，这些<strong>偏见</strong>非常明显，以至于模型无需看问题就可以选择正确的答案。</p>
<h4 id="Adversarial-Matching"><a href="#Adversarial-Matching" class="headerlink" title="Adversarial Matching"></a>Adversarial Matching</h4><p>negative answer的生成可以在correct answer上进行改造，但是这个过程非常耗钱，更甚，可能会引入annotation artifacts，subtle patterns that are by themselves highly predictive of the ‘correct’ or ‘incorrect’ label. 【1，2，3】</p>
<p>The key idea of Adversarial Matching is to <strong>recycle</strong> each correct answer for a question exactly three times — as a <strong>negative answer</strong> for three other questions.  这样每个answer 将会有1/4的机会是正例。这可以<strong>解决掉 answer-only bais 的问题</strong>，从而避免了模型总是选择 most generic answer. </p>
<p>在为每个image 选择negative answer时，希望<strong>negative answer: relevant as possible to the context/question (so that they appeal to machines), while they cannot be overly similar to the correct response (so that they don’t become correct answers incidentally).</strong> </p>
<p>因此计算一个weight，能够同时考虑到与query中的questeion相关度大，但是与query 的correct answer的相似性小。在本文中使用bert来计算相关度，用ESIM+ELM来计算相似性。</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1geuprb6zmvj310305qwfg.jpg"></p>
<p>为了获得多个negative answer，需要执行多次的双向匹配。为了确保nagetive pairs是多样性的，在依次获得negative answer的过程中，在下一次从其他的image中查找negative answer时，需要遍历当前所有的negative answer，然后取最大值。（replace the similarity term with the maximum similarity between a candidate response rj and all responses currently assigned to qi.）</p>
<h4 id="Language-Priors-and-Annotation-Artifacts-Discussion"><a href="#Language-Priors-and-Annotation-Artifacts-Discussion" class="headerlink" title="Language Priors and Annotation Artifacts Discussion"></a>Language Priors and Annotation Artifacts Discussion</h4><p><strong>Answer Priors</strong>: A model can select a correct answer without even looking at the question. </p>
<p><strong>Non-Visual Priors ：</strong>A model can select a correct answer using only non-visual elements of the question. </p>
<p>这些priors可能是来自于现实世界中的偏置，比如，当问消火栓是什么颜色的，模型常常预测出，红色。这是由于现实世界中消火栓是红色的。 </p>
<p>又可能来自于annotation artifacts ， 人们在编写class-conditioned answers 时出现的模式。比如：标注者经常使用否定之类的方式写与句子相矛盾的句子。</p>
<ul>
<li><strong>实验证明，对抗匹配的方式，可以帮助消除 artificial bias。</strong> </li>
</ul>
<h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><ol>
<li>The effect of different writing tasks on linguistic style: A case study of the ROC story cloze task.  </li>
<li>Annotation artifacts in natural language inference data. </li>
<li>Hypothesis Only Baselines in Natural Language Inference. </li>
</ol>
]]></content>
      <categories>
        <category>cross-modal</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
      </tags>
  </entry>
  <entry>
    <title>Frozen in Time: A Joint Video and Image Encoder for End-to-End Retrieval</title>
    <url>/2021/06/18/Frozen-in-Time-A-Joint-Video-and-Image-Encoder-for-End-to-End-Retrieval-1/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>cross-modal</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
      </tags>
  </entry>
  <entry>
    <title>Frozen in Time: A Joint Video and Image Encoder for End-to-End Retrieval</title>
    <url>/2021/05/29/Frozen-in-Time-A-Joint-Video-and-Image-Encoder-for-End-to-End-Retrieval/</url>
    <content><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p> text-to-video-retrieval</p>
<h2 id="当前存在的问题"><a href="#当前存在的问题" class="headerlink" title="当前存在的问题"></a>当前存在的问题</h2><ul>
<li>这一领域的挑战包括: (1) 视觉结构的设计和 (2) 训练数据的性质，因为现有的大规模视频-文本训练数据集，如HowTo100M，是有噪声的，因此只有通过大量的计算才能实现有竞争力的性能。</li>
</ul>
<h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><ul>
<li>【训练使用的数据集】针对上述提到的问题，本文提出了一个端到端的可训练模型，该模型利用大规模的图像描述和视频描述数据集。该模型可以灵活的在图像-文本，视频-文本数据集上进行训练，可以是单独的方式或者是组合的方式。</li>
<li>【模型结构】本文提出的模型是对最近的ViT和Timesformer架构的改编和扩展，由空间和时间上的 attention 组成。</li>
<li>【训练方案】使用课程学习的训练方式（由易到难），开始时将图像视为视频的 “冻结 “快照，然后在视频数据集上训练时逐渐学会关注越来越多的时域上下文。</li>
</ul>
]]></content>
      <categories>
        <category>cross-modal</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
      </tags>
  </entry>
  <entry>
    <title>Full Instructions</title>
    <url>/2020/07/01/Full-Instructions/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>GAN简介</title>
    <url>/2020/07/30/GAN%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<blockquote>
<p>From: <a href="https://blog.csdn.net/shanlepu6038/article/details/84335117?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">GAN（一）:基本框架</a></p>
</blockquote>
<p>一个GAN包含两部分，一个generator,一个discriminator（互相对抗）<br>generator和discriminator就像是猎食者和猎物之间的关系，一个产生图片，一个辨别图片的真假，互相促进，使得最终产生的图片接近realistic</p>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><ol>
<li><p>随机初始化 generator 和 discriminator</p>
</li>
<li><p>In each training iteration：</p>
<ul>
<li><p>固定generator，更新discriminator</p>
<p>Discriminator learns to assign high scores to real objects and low scores to generated objects.</p>
</li>
<li><p>固定discriminator， 更新generator</p>
</li>
</ul>
</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gh9bgltng3j30hu0djage.jpg"></p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p><strong>G和D是互相促进的：</strong>G的目的是产生的图像让D感到模糊不知道该分成realistic（看起来像是现实的）还是fake（看起来是假的），D的目的是将realistic和fake的图像准确分辨。所以G产生的图像会越来越真，D的辨别能力会越来越强，最终达到一个平衡。</p>
<p>P<sub>data</sub> 表示真实数据的分布，P<sub>g</sub> 表示generator产生的分布，最终的目的就是让P<sub>g</sub> 的分布尽可能的和P<sub>data</sub> 相同。<br>我们用D(x)表示真实图像经过discriminator后的分数，G(z)表示随机变量z经过generator后产生的图像，那么有：D(G(z)) 表示generator产生的图像经过discriminator后的分数</p>
<p>第一阶段，固定 generator，更新discriminator，最大化下面对的这个式子：</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gh9bxggo1rj30gv01lwf1.jpg"></p>
<p>第二阶段，固定discriminator，更新generator，最大化下面的这个式子：</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gh9bxgfqjnj30ad01s3yt.jpg"></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>GPT Understands, Too</title>
    <url>/2021/04/06/GPT-Understands-Too/</url>
    <content><![CDATA[<p>转载：苏剑林. (Apr. 03, 2021). 《P-tuning：自动构建模版，释放语言模型潜能 》[Blog post]. Retrieved from <a href="https://kexue.fm/archives/8295" target="_blank" rel="noopener">https://kexue.fm/archives/8295</a></p>
<h2 id="1-P-tuning：自动构建模版，释放语言模型潜能"><a href="#1-P-tuning：自动构建模版，释放语言模型潜能" class="headerlink" title="1. P-tuning：自动构建模版，释放语言模型潜能"></a>1. P-tuning：自动构建模版，释放语言模型潜能</h2><p>在之前的文章<a href="https://kexue.fm/archives/7764" target="_blank" rel="noopener">《必须要GPT3吗？不，BERT的MLM模型也能小样本学习》</a>中，我们介绍了一种名为Pattern-Exploiting Training（PET）的方法，它通过人工构建的模版与BERT的MLM模型结合，能够起到非常好的零样本、小样本乃至半监督学习效果，而且该思路比较优雅漂亮，因为它将预训练任务和下游任务统一起来了。然而，人工构建这样的模版有时候也是比较困难的，而且不同的模版效果差别也很大，如果能够通过少量样本来自动构建模版，也是非常有价值的。</p>
<p>最近Arxiv上的论文<a href="https://arxiv.org/abs/2103.10385" target="_blank" rel="noopener">《GPT Understands, Too》</a>提出了名为P-tuning的方法，成功地实现了模版的自动构建。不仅如此，借助P-tuning，GPT在SuperGLUE上的成绩首次超过了同等级别的BERT模型，这颠覆了一直以来“GPT不擅长NLU”的结论，也是该论文命名的缘由。</p>
<h3 id="1-1-yaya-与本文相关的文献"><a href="#1-1-yaya-与本文相关的文献" class="headerlink" title="1.1 yaya-与本文相关的文献"></a>1.1 yaya-与本文相关的文献</h3><p>All NLP Tasks Are Generation Tasks: A General Pretraining Framework<br>GPT Understands, Too<br>How Many Data Points is a Prompt Worth<br>It’s Not Just Size That Matters:  Small Language Models Are Also Few-Shot Learners</p>
<h2 id="2-什么是模版-Pattern"><a href="#2-什么是模版-Pattern" class="headerlink" title="2. 什么是模版(Pattern)"></a>2. 什么是模版(Pattern)</h2><p>所谓PET，主要的思想是借助由自然语言构成的模版（英文常称Pattern或Prompt），将下游任务也转化为一个完形填空任务，这样就可以用BERT的MLM模型来进行预测了。比如下图中通过条件前缀来实现情感分类和主题分类的例子：</p>
<p><img src="https://i.loli.net/2021/04/06/Pov8T9D2a7Xur41.png" alt="通过特定模版将情感分类转换为MLM任务" style="zoom:33%;"></p>
<p>以上，通过特定模版将情感分类转换为MLM任务</p>
<p><img src="https://i.loli.net/2021/04/06/QyFxiS7RWTNGMK9.png" alt="通过特定模版将新闻分类转换为MLM任务" style="zoom:33%;"></p>
<p>以上，通过特定模版将新闻分类转换为MLM任务</p>
<p>当然，这种方案也不是只有MLM模型可行，用GPT这样的单向语言模型（LM）其实也很简单：</p>
<p><img src="https://i.loli.net/2021/04/06/GBAsIiEjOdvuSKp.png" alt="通过特定模版将情感分类转换为LM任务" style="zoom:33%;"></p>
<p>以上，通过特定模版将情感分类转换为LM任务</p>
<p><img src="https://i.loli.net/2021/04/06/lXsUG8bhfc4amLn.png" alt="通过特定模版将新闻分类转换为LM任务" style="zoom:33%;"></p>
<p>以上，通过特定模版将新闻分类转换为LM任务</p>
<p>不过由于语言模型是从左往右解码的，因此预测部分只能放在句末了（但还可以往补充前缀说明，只不过预测部分放在最后）。</p>
<p>某种意义上来说，这些模版属于语言模型的“探针”，我们可以通过模版来抽取语言模型的特定知识，从而做到不错的零样本效果，而配合少量标注样本，可以进一步提升效果，这些在<a href="https://kexue.fm/archives/7764" target="_blank" rel="noopener">《必须要GPT3吗？不，BERT的MLM模型也能小样本学习》</a>中已经比较详细讨论过了。</p>
<p>然而，前面已经说了，对于某些任务而言，<strong style="color:red;"><strong>人工构建模版并不是那么容易的事情</strong></strong>，模型的优劣我们也不好把握，而不同模型之间的效果差别可能很大，在这种情况下，人工标注一些样本可能比构建模版还要轻松得多。<strong style="color:red;">所以，如何根据已有的标注样本来自动构建模版，便成了一个值得研究的问题了。</strong></p>
<h2 id="3-P-tuning"><a href="#3-P-tuning" class="headerlink" title="3. P-tuning"></a>3. P-tuning</h2><p>P-tuning重新审视了关于模版的定义，放弃了“模版由自然语言构成”这一常规要求，从而将模版的构建转化为连续参数优化问题，虽然简单，但却有效。</p>
<h3 id="3-1-模版的反思"><a href="#3-1-模版的反思" class="headerlink" title="3.1 模版的反思"></a>3.1 模版的反思</h3><p>首先，我们来想一下“<strong style="color:red;">什么是模版</strong>“”。直观来看，模版就是由自然语言构成的前缀/后缀，通过这些模版我们使得下游任务跟预训练任务一致，这样才能更加充分地利用原始预训练模型，起到更好的零样本、小样本学习效果。</p>
<p><strong style="color:red;">等等，我们真的在乎模版是不是“自然语言”构成的吗？</strong></p>
<p>并不是。本质上来说，我们并不关心模版长什么样，<strong style="color:red;">我们只需要知道模版由哪些token组成，该插入到哪里，插入后能不能完成我们的下游任务，输出的候选空间是什么。</strong>模版是不是自然语言组成的，对我们根本没影响，“自然语言”的要求，只是为了更好地实现“一致性”，但不是必须的。于是，P-tuning考虑了如下形式的模版：</p>
<p><img src="https://i.loli.net/2021/04/06/SNYaqglG1LvJsMu.png" alt="img" style="zoom:33%;"></p>
<p>以上，<strong><strong style="color:blue;">P-tuning直接使用[unused*]的token来构建模版，不关心模版的自然语言性</strong></strong></p>
<p>这里的[u1]～[u6]，代表BERT词表里边的<strong style="color:red;">[unused1]～[unused6]</strong>，也就是用几个从未见过的token来构成模板，这里的token数目是一个超参数，放在前面还是后面也可以调整。接着，为了让“模版”发挥作用，我们<strong style="color:red;">用标注数据来求出这个模板</strong>。</p>
<h3 id="3-2-如何去优化"><a href="#3-2-如何去优化" class="headerlink" title="3.2 如何去优化"></a>3.2 如何去优化</h3><p>这时候，根据标注数据量的多少，我们又分两种情况讨论。</p>
<p><strong>第一种，标注数据比较少。</strong>这种情况下，我们固定整个模型的权重，只优化[unused1]～[unused6]这几个token的Embedding，换句话说，其实我们就是要学6个新的Embedding，使得它起到了模版的作用。这样一来，因为模型权重几乎都被固定住了，训练起来很快，而且因为要学习的参数很少，因此哪怕标注样本很少，也能把模版学出来，不容易过拟合。</p>
<p><strong>第二种，标注数据很充足。</strong>这时候如果还按照第一种的方案来，就会出现欠拟合的情况，因为只有6个token的可优化参数实在是太少了。因此，我们可以放开所有权重微调，原论文在SuperGLUE上的实验就是这样做的。读者可能会想：这样跟直接加个全连接微调有什么区别？原论文的结果是这样做效果更好，可能还是因为跟预训练任务更一致了吧。</p>
<p><img src="https://i.loli.net/2021/04/06/bJ2oPygslG3MhCN.png" alt="P-tuning在SuperGLUE上的表现"></p>
<p>以上，P-tuning在SuperGLUE上的表现</p>
<p>此外，在上面的例子中，目标token 如 “很”、“体育”是认为选定的，那么它们可不可以也用[unused$<em>$] 的token代替呢？答案是可以，但也分两种情况考虑：1、在标注数据比较少的时候，人工来选定适当的目标token效果往往更好些；2、在标注数据很充足的情况下，目标token用[unused$</em>$]效果更好些，因为这时候模型的优化空间更大一些。</p>
<h3 id="3-3-增强相关性"><a href="#3-3-增强相关性" class="headerlink" title="3.3 增强相关性"></a>3.3 增强相关性</h3><p>在原论文中，P-tuning并不是随机初始化几个新token然后直接训练的，而是通过一个小型的LSTM模型把这几个Embedding算出来，并且将这个LSTM模型设为可学习的。这样多绕了一步有什么好处呢？原论文大概的意思是：<strong>LSTM出现的token表示相关性更强，某种程度上来说更像“自然语言”（因为自然语言的token之间不是独立的），此外还能防止局部最优</strong>。我在Github上进一步向作者确认了一下（参考<a href="https://github.com/THUDM/P-tuning/issues/5" target="_blank" rel="noopener">这里</a>），效果上的差别是通过LSTM多绕一步的方法可以使得模型收敛更快、效果更优。</p>
<p>然而，这样多了一个LSTM，总感觉有些别扭，而且实现上也略微有点麻烦。按照作者的意思，LSTM是为了帮助模版的几个token（某种程度上）更贴近自然语言，但这并不一定要用LSTM生成，而且就算用LSTM生成也不一定达到这一点。<strong>笔者认为，更自然的方法是在训练下游任务的时候，不仅仅预测下游任务的目标token（前面例子中的“很”、“新闻”），还应该同时做其他token的预测。</strong></p>
<p>比如，<strong>如果是MLM模型，那么也随机mask掉其他的一些token来预测；如果是LM模型，则预测完整的序列，而不单单是目标词</strong>。这样做的理由是：因为我们的MLM/LM都是经过自然语言预训练的，所以我们（迷之自信地）认为能够很好完成重构的序列必然也是接近于自然语言的，因此这样增加训练目标，也能起到让模型更贴近自然语言的效果。经过笔者的测试，<strong>加上这样辅助目标，相比单纯优化下游任务的目标，确实提升了效果。</strong></p>
<h2 id="4-实验与效果"><a href="#4-实验与效果" class="headerlink" title="4. 实验与效果"></a>4. 实验与效果</h2><p>所谓“talk is cheap, show me the code”，又到了喜闻乐见的实验时间了。这里分享一下P-tuning的实验结果，其中还包括笔者对P-tuning的实现思路，以及笔者在中文任务上的实验结果。</p>
<h3 id="4-1-停止的梯度"><a href="#4-1-停止的梯度" class="headerlink" title="4.1 停止的梯度"></a>4.1 停止的梯度</h3><p>怎么实现上述的P-tuning算法比较好呢？如果是放开所有权重训练，那自然是简单的，跟普通的BERT微调没有什么区别。关键是在小样本场景下，如何实现“只优化几个token”呢？</p>
<p>当然，实现的方法也不少，比如为那几个要优化的token重新构建一个Embedding层，然后拼接到BERT的Embedding层中，然后训练的时候只放开新Embedding层的权重。但这样写对原来模型的改动还是蛮大的，最好的方法是尽可能少改动代码，让使用者几乎无感。为此，笔者构思了一种用<code>stop_gradient</code>简单修改<code>Embedding</code>层的方案，大体上是将<code>Embedding</code>层修改如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PtuningEmbedding</span><span class="params">(Embedding)</span>:</span></span><br><span class="line">    <span class="string">"""新定义Embedding层，只优化部分Token</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, inputs, mode=<span class="string">'embedding'</span>)</span>:</span></span><br><span class="line">        embeddings = self.embeddings</span><br><span class="line">        embeddings_sg = K.stop_gradient(embeddings)</span><br><span class="line">        mask = np.zeros((K.int_shape(embeddings)[<span class="number">0</span>], <span class="number">1</span>))</span><br><span class="line">        mask[<span class="number">1</span>:<span class="number">9</span>] += <span class="number">1</span>  <span class="comment"># 只优化id为1～8的token</span></span><br><span class="line">        self.embeddings = embeddings * mask + embeddings_sg * (<span class="number">1</span> - mask)</span><br><span class="line">        <span class="keyword">return</span> super(PtuningEmbedding, self).call(inputs, mode)</span><br></pre></td></tr></table></figure>
<p>变量经过<code>stop_gradient</code>算子后，在反向传播的时候梯度为0，但是前向传播不变，因此在上述代码中，前向传播的结果不会有变化，但是反向传播求梯度的时候，梯度不为0的token由<code>mask</code>变量控制，其余token的梯度都为零，因此就实现了只更新部分token。</p>
<p>完整代码可见：</p>
<blockquote>
<p><strong>Github：<a href="https://github.com/bojone/P-tuning" target="_blank" rel="noopener">https://github.com/bojone/P-tuning</a></strong></p>
</blockquote>
<p>对了，原论文也开源了代码：</p>
<blockquote>
<p><strong>Github：<a href="https://github.com/THUDM/P-tuning" target="_blank" rel="noopener">https://github.com/THUDM/P-tuning</a></strong></p>
</blockquote>
<h3 id="4-2-测试与效果"><a href="#4-2-测试与效果" class="headerlink" title="4.2 测试与效果"></a>4.2 测试与效果</h3><p>前面已经分享了原作者在SuperGLUE上的实验结果，显示出如果配合P-tuning，那么：<strong style="color:red;">1、GPT、BERT的效果相比直接finetune都有所提升</strong>；<strong style="color:red;">2、GPT的效果还能超过了BERT。</strong>这表明GPT不仅有NLG的能力，也有NLU能力，可谓是把GPT的潜能充分“压榨”出来了，当然BERT配合P-tuning也有提升，说明P-tuning对语言模型潜能的释放是较为通用的。</p>
<p>原论文的实验比较丰富，建议读者仔细阅读原论文，相信会收获颇多。特别指出的是原论文的Table 2最后一列，当预训练模型足够大的时候，我们的设备可能无法finetune整个模型，而P-tuning可以选择只优化几个Token的参数，因为优化所需要的显存和算力都会大大减少，所以<strong>P-tuning实则上给了我们一种在有限算力下调用大型预训练模型的思路</strong>。</p>
<p><img src="https://i.loli.net/2021/04/06/BMTubQ4AvSJperz.png" alt="P-tuning在各个体量的语言模型下的效果" style="zoom: 50%;"></p>
<p>以上，P-tuning在各个体量的语言模型下的效果</p>
<p>当然，笔者一直以来的观点是“没有在中文上测试过的算法是没有灵魂的”，因此笔者也在中文任务上简单测试了，测试任务跟<a href="https://kexue.fm/archives/7764" target="_blank" rel="noopener">《必须要GPT3吗？不，BERT的MLM模型也能小样本学习》</a>一致，都是情感分类的小样本学习，测试模型包括BERT和GPT，两者的候选模版分别如下图：</p>
<p><img src="https://i.loli.net/2021/04/06/SJfYPAulG4Lt7km.png" alt="笔者在中文情感分类上使用的“BERT+P-tuning”模版" style="zoom:33%;"></p>
<p>以上，笔者在中文情感分类上使用的“BERT+P-tuning”模版</p>
<p><img src="https://i.loli.net/2021/04/06/DV5OrLdygc3wxfn.png" alt="笔者在中文情感分类上使用的“GPT+P-tuning”模版" style="zoom:33%;"></p>
<p>以上，笔者在中文情感分类上使用的“GPT+P-tuning”模版</p>
<p>注意，对于LM模型，前缀的引入非常重要，只引入后缀时效果会明显变差；而对于MLM模型，前缀的效果通常也优于后缀。总的效果如下表：</p>
<p><img src="https://i.loli.net/2021/04/06/3N8TOk1YsmpSbHc.png" alt="image-20210406111755122" style="zoom:50%;"></p>
<p>其中“小样本”只用到了“少量标注样本”，“无监督”则用到了“大量无标注样本”，“半监督”则用到了“少量标注样本+大量无标注样本”，“P-tuning”都是小样本，PET的几个任务报告的是最优的人工模版的结果，其实还有更差的人工模版。从小样本角度来看，P-tuning确实取得了最优的小样本学习效果；从模版构建的角度来看，P-tuning确实也比人工构建的模版要好得多；从模型角度看，P-tuning确实可以将GPT的分类性能发挥到跟BERT相近，从而揭示了GPT也有很强的NLU能力的事实。</p>
<h2 id="5-进一步理解"><a href="#5-进一步理解" class="headerlink" title="5. 进一步理解"></a>5. 进一步理解</h2><p>这一节将会介绍笔者对P-tuning的进一步思考，以求从多个维度来理解P-tuning。</p>
<h3 id="5-1-离散-vs-连续"><a href="#5-1-离散-vs-连续" class="headerlink" title="5.1 离散 vs 连续"></a>5.1 离散 vs 连续</h3><p>在P-tuning之前，也已经有一些在做模版的自动构建，如<a href="https://arxiv.org/abs/1911.12543" target="_blank" rel="noopener">《How Can We Know What Language Models Know?》</a>、<a href="https://arxiv.org/abs/2010.15980" target="_blank" rel="noopener">《AutoPrompt: Eliciting Knowledge from Language Models with Automatically Generated Prompts》</a>等，但<strong>它们搜索的都是在离散空间下搜索的自然语言模版</strong>，所以效果有所限制，并没有取得特别突出的结果。</p>
<p>相反，P-tuning放弃了“模版由自然语言构成”这一要求，从而将其变成了可以简单梯度下降求解的连续参数问题，效果还更好。同时，这一改动意味着P-tuning突出了模版的本质——即模版的关键在于它是怎么用的，不在于它由什么构成——给人一种去芜存菁、眼前一亮额的感觉，确实值得点赞。</p>
<h3 id="5-2-Adapter"><a href="#5-2-Adapter" class="headerlink" title="5.2 Adapter"></a>5.2 Adapter</h3><p>我们还可以从Adapter的角度来理解P-tuning。BERT出来后不久，Google在论文<a href="https://arxiv.org/abs/1902.00751" target="_blank" rel="noopener">《Parameter-Efﬁcient Transfer Learning for NLP》</a>中提出了一种名为Adapter的微调方式，它并不是直接微调整个模型，而是固定住BERT原始权重，然后在BERT的基础上添加一些残差模块，只优化这些残差模块，由于残差模块的参数更少，因此微调成本更低。Adapter的思路实际上来源于CV的<a href="https://arxiv.org/abs/1705.08045" target="_blank" rel="noopener">《Learning multiple visual domains with residual adapters》</a>，不过这两年似乎很少看到了，也许是因为它虽然提高了训练速度，但是预测速度却降低了，精度往往还有所损失。</p>
<p><strong>在P-tuning中，如果我们不将新插入的token视为“模版”，是将它视为模型的一部分，那么实际上P-tuning也是一种类似Adapter的做法，<strong style="color:red;">同样是固定原模型的权重，然后插入一些新的可优化参数</strong>，<strong style="color:purple;">同样是只优化这些新参数，只不过这时候新参数插入的是Embedding层</strong>。因此，从这个角度看，P-tuning与Adapter有颇多异曲同工之处。</strong></p>
<h3 id="5-3-为什么有效"><a href="#5-3-为什么有效" class="headerlink" title="5.3 为什么有效"></a>5.3 为什么有效</h3><p>然后，还有一个值得思考的问题：为什么P-tuning会更好？比如全量数据下，大家都是放开所有权重，P-tuning的方法依然比直接finetune要好，为啥呢？</p>
<p>事实上，提出这个问题的读者，应该是对BERT加个全连接层的直接finetune做法“习以为常”了。很明显，不管是PET还是P-tuning，它们其实都更接近预训练任务，而加个全连接层的做法，其实还没那么接近预训练任务，所以某种程度上来说，P-tuning有效更加“显然”，反而是加个全连接层微调为什么会有效才是值得疑问的。</p>
<p>去年有篇论文<a href="https://arxiv.org/abs/2010.03648" target="_blank" rel="noopener">《A Mathematical Exploration of Why Language Models Help Solve Downstream Tasks》</a>试图回答这个问题，大致的论证顺序是：</p>
<blockquote>
<p>1、预训练模型是某种语言模型任务；</p>
<p>2、下游任务可以表示为该种语言模型的某个特殊情形；</p>
<p>3、当输出空间有限的时候，它又近似于加一个全连接层；</p>
<p>4、所以加一个全连接层微调是有效的。</p>
</blockquote>
<p>可以看到，该论文的假设主要是第2点，其实就是直接假设了下游任务可以表达为类似PET的形式，然后才去证明的。所以这进一步说明了，PET、P-tuning等才是更自然的使用预训练模型的方式，加全连接直接finetune的做法其实只是它们的推论罢了，也就是说，PET、P-tuning才是返璞归真、回归本质的方案，所以它们更有效。</p>
<h2 id="6-简单的总结"><a href="#6-简单的总结" class="headerlink" title="6. 简单的总结"></a>6. 简单的总结</h2><p>本文介绍了P-tuning，它是一种模版的自动构建方法，而通过模版我们可以从语言模型中抽取知识，完成零样本、小样本等学习任务，并且效果往往还更好。借助P-tuning，GPT也能实现优秀的NLU效果，在SuperGLUE上的表现甚至超过了BERT。除此之外，P-tuning还一种在有限算力下调用大型预训练模型的有效方案。</p>
<h1 id="智源"><a href="#智源" class="headerlink" title="智源"></a>智源</h1><p><img src="https://i.loli.net/2021/05/31/x3uXTm5QU47IKZF.png" alt="image-20210531133837040" style="zoom:50%;"></p>
<p><img src="https://i.loli.net/2021/05/31/5tbaTcxr8FCivUL.png" alt="image-20210531133920627" style="zoom:50%;"></p>
<p><img src="https://i.loli.net/2021/05/31/NWXjCMk4zsIVubE.png" alt="image-20210531134146305" style="zoom:50%;"></p>
<p><img src="https://i.loli.net/2021/05/31/7j3lW4vrfcVIwgU.png" alt="image-20210531134313255" style="zoom:50%;"></p>
<p><img src="https://i.loli.net/2021/05/31/VKDJZYjpRd63UWP.png" alt="image-20210531134449585" style="zoom:50%;"></p>
<p><img src="https://i.loli.net/2021/05/31/5gzWlk74Z18Exf3.png" alt="image-20210531134511330" style="zoom:50%;"></p>
<p><img src="https://i.loli.net/2021/05/31/8FK6wd1Ez9pouLC.png" alt="image-20210531134639415" style="zoom:50%;"></p>
<p><img src="https://i.loli.net/2021/05/31/vqU6M3CftRNSbh2.png" alt="image-20210531134820215" style="zoom:50%;"></p>
<p><img src="https://i.loli.net/2021/05/31/Wn2Qw4A1bOZLXpI.png" alt="image-20210531134929428" style="zoom:50%;"></p>
<p><img src="https://i.loli.net/2021/05/31/qlV85o9kDLza6Fj.png" alt="image-20210531134943431" style="zoom:50%;"></p>
<p><img src="https://i.loli.net/2021/05/31/Ya8I5cBEC7OmURA.png" alt="image-20210531135052454" style="zoom:50%;"></p>
<p><img src="https://i.loli.net/2021/05/31/pRGmzBlJ6DiW7Uf.png" alt="image-20210531135156520" style="zoom:50%;"></p>
<p><img src="https://i.loli.net/2021/05/31/TEhUFRkCWa3nX6Z.png" alt="image-20210531135528640" style="zoom:50%;"></p>
<p><img src="https://i.loli.net/2021/05/31/65buBKrIaRnPgJX.png" alt="image-20210531135651006" style="zoom:50%;"></p>
<p><img src="https://i.loli.net/2021/05/31/rAc7YBSuMXk12se.png" alt="image-20210531135716122" style="zoom:50%;"></p>
<p><img src="https://i.loli.net/2021/05/31/kd1PwMIaQHWoNRA.png" alt="image-20210531135826044" style="zoom:50%;"></p>
<p><img src="https://i.loli.net/2021/05/31/Ley1OMGqgDaJpsF.png" alt="image-20210531140027073" style="zoom: 50%;"></p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>GEM: A General Evaluation Benchmark for Multimodal Tasks</title>
    <url>/2021/06/22/GEM-A-General-Evaluation-Benchmark-for-Multimodal-Tasks/</url>
    <content><![CDATA[<h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><ul>
<li><p>类似于 GLUE，SuperGLUE 这种 language evaluation benchmark 可以评估纯语言预训练模型的能力，但是多模态方向上，多模态预训练模型的能力还没有相关的benchmark，本文提出了 <font color="red">多模态任务上 evaluation benchmark：<strong>GEM</strong>。</font></p>
</li>
<li><p>本文的多模态任务，包括 image-text <strong>GEM-I</strong>; video-text <strong>GEM-V</strong>。同时相比于当前存在的多模态数据集（例如 MSCOCO，Flickr30K，YouCook2, MSR-VTT）， <font color="red"><strong>GEM</strong> 规模上更大，且涵盖多种语言。</font></p>
</li>
<li><p>本文提供了两个多模态多语言预训练模型, <a href="https://arxiv.org/abs/2006.02635" target="_blank" rel="noopener">M3P</a> and <a href="https://arxiv.org/abs/2002.06353" target="_blank" rel="noopener">m-UniVL</a> 作为 GEM 的baseline. M3P是一个现成的多语言， image-text 预训练模型，m-UniVL是 本文对video-text预训练模型 UniVL 做的扩展</p>
</li>
</ul>
<h2 id="相关论文"><a href="#相关论文" class="headerlink" title="相关论文"></a>相关论文</h2><p>总结一下多模态预训练模型中，<strong>包含多语言</strong>的一些模型。</p>
]]></content>
      <categories>
        <category>cross-modal</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub+Hexo 搭建个人网站详细教程</title>
    <url>/2019/02/21/GitHub-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26625249</a></p>
<p><a href="https://blog.csdn.net/xuezhisdc/article/details/53130328" target="_blank" rel="noopener">https://blog.csdn.net/xuezhisdc/article/details/53130328</a></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>node.js 使用 12 版本</p>
<h3 id="部署在本地"><a href="#部署在本地" class="headerlink" title="部署在本地"></a>部署在本地</h3><ul>
<li><p>部署</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo clean</span></span><br><span class="line"><span class="attribute">hexo g -s</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用端口 5000</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">hexo s -<span class="selector-tag">p</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="增加本地搜索功能"><a href="#增加本地搜索功能" class="headerlink" title="增加本地搜索功能"></a>增加本地搜索功能</h3><h4 id="自定义站点内容搜索"><a href="#自定义站点内容搜索" class="headerlink" title="自定义站点内容搜索"></a>自定义站点内容搜索</h4><ol>
<li><p>安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-generator-searchdb <span class="comment">--save</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑博客配置文件，新增以下内容到任意位置：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">search:</span></span><br><span class="line"><span class="symbol">      path:</span> search.xml</span><br><span class="line"><span class="symbol">      field:</span> post</span><br><span class="line"><span class="symbol">      format:</span> html</span><br><span class="line"><span class="symbol">      limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑主题配置文件，启用本地搜索功能：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p><a href="https://www.jianshu.com/p/44e211829447" target="_blank" rel="noopener">https://www.jianshu.com/p/44e211829447</a></p>
<p><a href="http://npm.taobao.org/package/hexo-blog-encrypt" target="_blank" rel="noopener">http://npm.taobao.org/package/hexo-blog-encrypt</a></p>
<p><a href="https://github.com/MikeCoder/hexo-blog-encrypt/" target="_blank" rel="noopener">https://github.com/MikeCoder/hexo-blog-encrypt/</a></p>
]]></content>
      <categories>
        <category>杂类</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Going Beneath the Surface: Evaluating Image Captioning for Grammaticality, Truthfulness and Diversity</title>
    <url>/2020/07/02/Going-Beneath-the-Surface-Evaluating-Image-Captioning-for-Grammaticality-Truthfulness-and-Diversity/</url>
    <content><![CDATA[<h3 id="yaya-总结"><a href="#yaya-总结" class="headerlink" title="yaya 总结"></a>yaya 总结</h3><ul>
<li>本文提出了一个 GTD ， Grammaticality, Truthfulness and Diversity 三个方面对captioning model 进行评价，为未来 captioning model metric 提供了一个探索的方向。</li>
<li>本文需要特别说明的是，（1）本文是在自己设计的一个diagnostic dataset 上进行的实验，并不是在真实的captioning dataset 上进行的实验。（2）本文并没有提出一个具体可用的评价指标，而是提出了一个类似于协议的东西，即，本文主要是探究，在未来的评价指标里，需要去评估captioning model 的哪些层面，来弥补当前评价指标的不足，与当前的评价指标做一个互为补充！（英文： GTD, consider it as an evaluation protocol covering necessary aspects of the multifaceted captioning task, rather than a specific metric.）</li>
<li>该文选用 diagnostic dataset的原因：  <ul>
<li>The primary motivation is to reduce complexity which is considered irrelevant to the evaluation focus, to enable better control over the data, and to provide more detailed insights into strengths and limitations of existing models.</li>
</ul>
</li>
<li>该文不提出一个具体的评价指标：<ul>
<li>这得抨击一下啊。。。这给未来的研究提供了一个方向。但是，，，，feel is bad</li>
</ul>
</li>
</ul>
<h3 id="yaya学到了"><a href="#yaya学到了" class="headerlink" title="yaya学到了"></a>yaya学到了</h3><h2 id="使用ERG进行语法分析，若能够获得语法分析，则该句子在语法上被认为是格式正确的。反之。。"><a href="#使用ERG进行语法分析，若能够获得语法分析，则该句子在语法上被认为是格式正确的。反之。。" class="headerlink" title="- 使用ERG进行语法分析，若能够获得语法分析，则该句子在语法上被认为是格式正确的。反之。。"></a>- 使用ERG进行语法分析，若能够获得语法分析，则该句子在语法上被认为是格式正确的。反之。。</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><ul>
<li><strong style="color:red;">【当前评价指标存在的问题】</strong>: 当前存在的评价指标，只去关注于a candidate caption and<br>a set of reference captions之间的相似性，但是不去检查 generated caption 与 当前视觉内容之间的相关性。</li>
<li>本文提出了一个为 image captioning task 设计的 evaluation framework. 目的是直接评估生成caption的语法性、真实性和多样性(GTD).</li>
<li>使用本文新提出的evaluation framework 为 image caption models 进行评估, 并在多个数据集上进行测试，来证明本文提出的评估框架的潜力。</li>
<li>本文用实验来证明，与 <strong>diagnostic dataset</strong> 结合使用，本文的GTD 评估框架可以提供对 caption model 的 能力以及限制(capabilities and limit)的进一步思考。并补充 standard evaluations 的不足。</li>
<li></li>
</ul>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><ul>
<li>BLEU，METEOR，ROUGLE，CIDEr基于 n_gram 的评价指标仅能够评价cadidate caption 与 reference caption之间的<strong>表面相似性</strong>，</li>
<li>SPICE，将 captions转化为 graph-based 语义表达，进而来评估候选与参考之间的<strong>语义相似性</strong>。</li>
</ul>
<p><strong style="color:red;">automatic metric 使用的依据 (reference captions 来作为参照的使用依据)</strong></p>
<ul>
<li>【1】The rationale behind these evaluation metrics is that human reference captions serve as an approximate target and comparing model outputs to this target is a proxy for how well<br>a system performs. Thus, a candidate caption is not directly evaluated with respect to image content, but compared to a set of human statements about that image.</li>
<li>这里存在一个假设条件，即假设认为 human reference captions 是一个近似的target. 将caption model 输出与该target 进行比较是评估该model 性能好坏的一个proxy。基于这种假设，一个candidate caption 可以不直接与image content进行比较评估，而是与人类对image的statements 进行比较。</li>
</ul>
<p><strong style="color:red;">reference captions based automatic metric 存在的缺陷</strong></p>
<ul>
<li>reference-based metrics</li>
<li>由于视觉场景存在多个objects 和 relations，进而存在多个具有多样性的合理描述。但是由于reference caption 数量的限制，未必能够对图片的完整内容进行充分的描述。因此用reference captions 来近似替代 image 的内容是令人怀疑的。</li>
<li>当前存在的评价指标对于真实世界的 captioning评估是非常有用的，这是不可置疑的。这些方法仅关注于近似的表面比较，限制了对captioning models 学习过程和最终行为的进一步分析 。</li>
</ul>
<p><strong style="color:red;">本文提出的解决办法</strong></p>
<ul>
<li>为了解决这个问题，本文提出了几个原则性的评估准则，来对image captioning model 的语法性，真实性，多样性进行评估。这几个准则对应着image captioning systems的必要需求：（1）输出是符合语法规则的（2）对于image, 输出的陈述是对的（3）输出是多样化的, 反映training captions 的可变性。</li>
<li>GTD 当前只能在人造的数据上进行实际的评估。本文设计了一系列的数据集来进行图像描述的评估。我们将这个诊断评估数据集称为ShapeWorldCE. </li>
<li>BLEU 和 SPICE 不能捕捉 true caption-image agreement in all scenarios, 但是 GTD 对于现有模型如何很好地应对各种视觉环境和语言构造，却能有一个细粒度的观测。</li>
</ul>
<h3 id="GTD-evaluation-framework"><a href="#GTD-evaluation-framework" class="headerlink" title="GTD evaluation framework"></a>GTD evaluation framework</h3><ul>
<li>将GVD视为涵盖多方面字幕任务的必要方面的评估协议, 而不是一个具体的评估指标。</li>
<li><p><strong style="color:red;">【Grammaticality】</strong></p>
<ul>
<li>在一般情况下，对语法的完全准确的评估本身是一项艰巨的任务，但在诸如我们的诊断语言数据这样的非常有限的情况下，变得更加可行。【即在真实场景下的数据集是无法实现的？！！！】</li>
<li>如果我们使用ERG获得语法分析，则该句子在语法上被认为是格式正确的。</li>
</ul>
</li>
<li><p><strong style="color:red;">【Truthfulness】</strong></p>
<ul>
<li>candidate caption 与 image content 之间是否相容。</li>
</ul>
</li>
<li><p>truthfulness, that is, whether a candidate caption is compatible with the content of the image it is supposed to describe.  </p>
</li>
<li><p><strong style="color:red;">【Diversity】  </strong></p>
<h3 id="一些实验结果的分析"><a href="#一些实验结果的分析" class="headerlink" title="一些实验结果的分析"></a>一些实验结果的分析</h3></li>
<li>越高的BLEU得分，并不意味着准确性的提高。 换句话说，与reference captions的重叠度高（high n_gram overlap），并不代表语义内容是正确的. 仅仅是由于reference caption的词表有限所致。<strong>具体的分析可以查看论文实验部分：Correlation between the BLEU/SPICE scores and the<br>ground truth.</strong></li>
<li>虽然CNN可以为视觉任务提供丰富的视觉表达，但是对于多模态任务，其是否可以满足<br>但是这种浓缩的视觉表达对于需要higher-level 场景理解，视觉推理的多模态任务是否足够充分，仍然是一个开放性问题。</li>
<li>生成句子的多样性受到训练数据是否多样性的影响</li>
<li>未来的工作：本文发现：the caption agreement 并不总是随着训练损失的下降而提高。<br>理想情况下，训练目标应该与模型最终被评估的方式保持一致。在未来，计划实现一个GTD-aware loss,进而研究如何把GTD信号融合到训练过程中。</li>
</ul>
]]></content>
      <categories>
        <category>图像描述</category>
        <category>评价指标</category>
      </categories>
  </entry>
  <entry>
    <title>Graph Matching Networks for Learning the Similarity of Graph Structured Objects</title>
    <url>/2019/12/20/Graph-Matching-Networks-for-Learning-the-Similarity-of-Graph-Structured-Objects/</url>
    <content><![CDATA[<ul>
<li>ICML 2019</li>
</ul>
<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><ul>
<li>本文主要是提出了一种 新的方法来计算图的相似度问题</li>
<li>普通的方法分别单独计算 graph vector，而后再计算graph 之间的相似性</li>
<li>新提出的方法在计算  graph vector 时考虑了 cross graph matching vector来得到 更具有判别性的 graph vector，从而更好的用于 计算 graph similarity.</li>
</ul>
<h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><ul>
<li>Graph Edit Distance（GED）：文中对问题进行了简化，两个graph（G1, G2），相同数量的节点数和边数, 如何变动一个图中的edge(i, j) 到 edge(i’, j’) 才能使两个graph 完全一样。以下是 GED=1 的例子。</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ga3ats0xyzj308p07jaaw.jpg" alt="搜狗截图20191220170651.png"></p>
<ul>
<li>该文主要是想解决graph 的相似性问题，而不是真正的要求解出来需要几步的 graph edit distance。因此对问题做了如下的设定：<code>positive pair:（原图G，对G变动一条边：G1）</code>，<code>negative pair: （原图G，对G变动两条边：G1）</code></li>
<li>positive pair 认为这两个 graph 是相似的，label=1; 而negative pair认为两个graph 是不相似的, label=-1。</li>
</ul>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ga3b3udt8bj30pe0bsgnq.jpg" alt="搜狗截图20191220171642.png"></p>
<ul>
<li><p>一般的计算两个graph之间的相似性问题采用上图中的左图的方法，分别单独计算出 graph vector，而后再计算 vector space similarity</p>
</li>
<li><p>而本文：计算两个graph之间的匹配，然后互相作为补充特征（cross-graph matching vector），得到更加 <strong>discriminative</strong>  graph representation， 从而更加有效的graph 之间的相似度问题。</p>
</li>
<li>yaya: 文中使用的是 <code>difference between node_i and its closest neighbor in the other graph</code>  来计算  <code>cross-graph matching vector</code> 。我认为还可以有其他的方法或许会更加有效。</li>
</ul>
]]></content>
      <categories>
        <category>图卷积网络</category>
      </categories>
      <tags>
        <tag>图卷积网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Graph R-CNN for Scene Graph Generation</title>
    <url>/2019/03/24/Graph-R-CNN-for-Scene-Graph-Generation/</url>
    <content><![CDATA[<p>这是ECCV 2018 场景图生成 的一篇文章。<br>写在前面，本文使用的GCN网络与“Graph Attention Networks”一致，都是计算两个节点之间的attention来计算邻接矩阵中的元素值，更新节点特征的公式是AXW。</p>
<ul>
<li><strong>查看本文的原因，主要是想看，其是如何提取relation feature的，但是文中仅使用了union box feature 作为relation feature。较为朴素！</strong>————————-不好</li>
<li><strong>同时也将relation 作为node放入graph 中，但是是object feature 与 realtion feature之间的混合graph，与“Auto-Encoding Scene Graphs for Image Captioning”一样采用的是异构图</strong>  </li>
<li><strong>文中对W<sup>sr</sup>Z<sup>r</sup>α<sup>sr</sup>， 为该node<sub>i</sub>与所有的relation nodes之间计算的注意力系数，并不合理，因为object 可能仅有一两个relation，怎么可能与所有的relation有关系呢</strong>—————————————不好（后又考虑了一下，可能没有关系的直接算0，就不再计算attention了）</li>
</ul>
<p>思索良久，终于发现是哪里不对了，一般的情况下，都是X’=AXW，这样的形式，以 X 为中心，更新X的特征，而Z<sub>i</sub><sup>r</sup>的更新公式中是以Z<sup>o</sup>为中心，因此是不是有些不对头呢？？？</p>
<p>本文的<strong>两个主要的贡献</strong>：</p>
<ol>
<li><strong>GCN</strong> with attention 用于scene graph generate 任务。Updating each object and relationship representation based on its neighbors</li>
<li>对于N个object ,若两两配对，则会产生N×N个relation，数量是N的二次，数量很多，但是很多又是没有必要的，以前的工作采用随机采样的方式，但是本文提出了<strong>RePN 网络来采样relation</strong>。</li>
<li>提出了一个新的用于scene graph generate 的评价指标，SGGen+（不是笔者关注的内容，因此此处忽略了对SGGen+的介绍）</li>
</ol>
<h2 id="场景图生成任务的主要步骤"><a href="#场景图生成任务的主要步骤" class="headerlink" title="场景图生成任务的主要步骤"></a>场景图生成任务的主要步骤</h2><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1dxanmhpfj312o08p75l.jpg">    </p>
<ol>
<li>P( V|I )  指：在给定image的情况下，去得到 <strong>object proposals</strong><br>使用pytorch 版本[1]的faster R-CNN来得到 bbox，类似于[2]，采用分段训练的方式，先对faster R-CNN进行预训练，然后，固定faster r-cnn参数，训练整个场景图生成网络。  </li>
<li>P( E|V, I ) 指：在给定image 和 bbox的情况下来得到 <strong>relation proposals</strong><br>如果假设每个object proposals 之间都会有一个relation，则有N×N个relation，或者是说，有N×N个object pairs。但是含有很多不合适的relation（本身这object pairs 之间不存在关系，但是却指定了某种关系），因此本文提出使用ReRN 网络来采样得到 relatedness relations。</li>
<li>P( R,O|V,E,I ) 指： 在给定image，object proposals以及relation proposal之后，得到object label 和 relation label。<br>一般的方法是采用iterative refinement process[2]，本文使用的是用GCN来迭代。</li>
</ol>
<ul>
<li>overview<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1dy02tb1zj31du0crajb.jpg"></li>
</ul>
<h2 id="Object-Proposal"><a href="#Object-Proposal" class="headerlink" title="Object Proposal"></a>Object Proposal</h2><p>使用faster r-cnn来提取<strong>object proposals</strong>，并得到相对应的一维特征向量（<strong>pooled feat</strong>），faster r-cnn 使用类别可知，则可以得到每个object 对应的<strong>label</strong><br>使用</p>
<h2 id="Relation-Proposal-Network"><a href="#Relation-Proposal-Network" class="headerlink" title="Relation Proposal Network"></a>Relation Proposal Network</h2><p>输入： <strong>labels</strong> of object pairs<br>输出：relatedness relations/ m 个object pairs<br>主要的步骤见下图：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e8ud0p66j32v311qjyg.jpg"></p>
<h2 id="Attention-GCN"><a href="#Attention-GCN" class="headerlink" title="Attention GCN"></a>Attention GCN</h2><h3 id="Formulation"><a href="#Formulation" class="headerlink" title="Formulation"></a>Formulation</h3><ul>
<li>与GAT的公式是一致的，具体可以参看论文GAT[ 3]，<strong>α<sub>i</sub></strong> 是注意力系数<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e8wl8yubj30f60360sr.jpg" style="zoom:60%"><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e8wl8m92j30gn04sjrp.jpg" style="zoom:60%"></li>
</ul>
<h3 id="aGCN-for-Scene-Graph-Generation"><a href="#aGCN-for-Scene-Graph-Generation" class="headerlink" title="aGCN for Scene Graph Generation"></a>aGCN for Scene Graph Generation</h3><ul>
<li>只构建一个graph，在这个graph中，object是node，relation也是node。<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e98pvy7aj30dh0cq0t3.jpg" style="zoom:60%">  </li>
<li><p>用skip代表object node之间的连接；构建的是有向边；捕捉了三中类型的连接：<br><strong>object &lt;—&gt; relationship</strong>， <strong>relationship &lt;—&gt; subject</strong> and <strong>object &lt;—&gt; object</strong><br><strong>s</strong>=subjects, <strong>o</strong>=objects, and <strong>r</strong>=relationships<br>object and relationship features as  <strong>Z<sup>o</sup></strong> and <strong>Z<sup>r</sup></strong><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e9gaiumnj30vp0dg0v2.jpg" style="zoom:60%"><br>对上图的解读：<br>（1）虽说是一个图，但是进行了两个aGCN的计算，使用的object and relationship node representation是什么？文中说，visual aGCN 使用visual feature 来进行计算，semantic aGCN 使用pre-softmax outputs来进行计算。（没看懂）<br>（2）WZα公式是GCN的计算公式，</p>
<ul>
<li>以 <strong>W<sup>skip</sup> Z<sup>o</sup> α<sup>skip</sup></strong> 为例，<strong>W<sup>skip</sup></strong> 是可学习参数，<strong>Z<sup>o</sup></strong> 是object nodes feature 组成的矩阵（d,N），<strong>α<sup>skip</sup></strong> 是一个向量，为该 node<sub>i</sub>与所有的object nodes之间计算的注意力系数，维度为(1,N）（N个objects）</li>
<li>以 <strong>W<sup>sr</sup> Z<sup>r</sup> α<sup>sr</sup></strong> 为例，<strong>W<sup>sr</sup></strong> 是可学习参数，<strong>Z<sup>r</sup></strong> 是realtion nodes feature 组成的矩阵（d,m），<strong>α<sup>sr</sup></strong> 是一个向量，为该node<sub>i</sub>与所有的relation nodes之间计算的注意力系数，维度为(1,m）（m个realtion）</li>
<li>以 <strong>W<sup>rs</sup> Z<sup>o</sup> α<sup>rs</sup></strong> 为例，<strong>W<sup>rs</sup></strong> 是可学习参数，<strong>Z<sup>o</sup></strong> 是object nodes feature 组成的矩阵（d,N），<strong>α<sup>rs</sup></strong> 是一个向量，为该relation<sub>i</sub>与所有的object nodes之间计算的注意力系数，维度为(1,N）（N个objects）  </li>
</ul>
<p>（3）需要注意的是，<strong>α<sub>ii</sub></strong>=1，这将使得，每一行想加不为1</p>
</li>
</ul>
<h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1ea7p889dj313l0dzwj3.jpg"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] A faster pytorch implementation of faster  r-cnn. <a href="https://github.com/jwyang/faster-rcnn.pytorch" target="_blank" rel="noopener">https://github.com/jwyang/faster-rcnn.pytorch</a><br>[2] Scene graph generation by iterative message passing<br>[3] Graph Attention Networks<br>[3] Graph Attention Networks</p>
]]></content>
  </entry>
  <entry>
    <title>Grounded Situation Recognition</title>
    <url>/2020/03/31/Grounded-Situation-Recognition/</url>
    <content><![CDATA[<h4 id="Grounded-Situation-Recognition-Task"><a href="#Grounded-Situation-Recognition-Task" class="headerlink" title="Grounded Situation Recognition Task"></a>Grounded Situation Recognition <strong>Task</strong></h4><h5 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h5><ul>
<li><p>以前的situation recognition task: </p>
<p><strong>Situation Recognition</strong> is the task of recognizing the activity happening in an image, the actors and objects involved in this activity, and the roles they play. Semantic roles describe how objects in the image participate in the activity described by the verb. </p>
<p>While situation recognition addresses <strong><em>what</em></strong> is happening in an image, <strong><em>who</em></strong> is playing a part in this and <strong><em>what</em></strong> their roles are, it does not address a critical aspect of visual understanding: <strong>where</strong> the involved entities lie in the image. </p>
</li>
<li><p>本文：We address this shortcoming and present <strong>Grounded Situation Recognition (GSR)</strong>, a task that builds upon situation recognition and requires one to not just identify the situation observed in the image but also visually ground the identified roles within the corresponding image.</p>
</li>
</ul>
<h4 id="Challenge-of-Grounded-Situation-Recognition-GSR"><a href="#Challenge-of-Grounded-Situation-Recognition-GSR" class="headerlink" title="Challenge of Grounded Situation Recognition (GSR)"></a>Challenge of Grounded Situation Recognition (GSR)</h4><ul>
<li><em>语义显著性</em>：与识别图像中的所有实体不同，它需要在呈现的<strong>主要活动的背景下</strong>识别关键对象和参与者。</li>
<li><em>语义稀疏性</em>：GSR存在语义稀疏性问题，  在训练中很少见到role and groundings 的许多组合。这一挑战要求模型从有限的数据中学习。</li>
<li><em>Ambiguity</em>：将角色定位到图像中通常需要消除在同一类别下的多个观察到的实体之间的歧义。</li>
<li><em>Scale</em>：grounded entities 的比例尺变化很大，图像中也缺少某些实体（在这种情况下，模型负责检测这种缺失）。</li>
<li><em>Hallucination</em>：标记语义角色并grounding 通常需要弄清物体的存在，因为它们可能被完全遮挡或不在屏幕上。</li>
</ul>
<h4 id="Situations-With-Groundings-SWiG-dataset"><a href="#Situations-With-Groundings-SWiG-dataset" class="headerlink" title="Situations With Groundings (SWiG) dataset"></a>Situations With Groundings (SWiG) dataset</h4><p><a href="https://prior.allenai.org/assets/project-content/gsr/gsr_banner.png" target="_blank" rel="noopener"><img src="https://prior.allenai.org/assets/project-content/gsr/gsr_banner.png" alt="SWiG examples">A sample of images from the SWiG dataset</a></p>
<p>We present the Situations With Groundings (SWiG) Dataset for training and evalutation on the GSR task. This dataset builds upon the <a href="https://homes.cs.washington.edu/~ali/papers/SituationRecognition.pdf" target="_blank" rel="noopener">Situation Recognition dataset</a> presented by Yatskar et al. The SWiG dataset contains approximately 125,000 images. Each image is associated with one verb. Three different annotators then label each <strong>entity</strong> in the frame associated with that <strong>verb</strong> and mark the <strong>location</strong> of the entity in the image. All three labels for each role are given in the SWiG dataset as well as an average of the three localizations.</p>
]]></content>
  </entry>
  <entry>
    <title>Grounded Video Description</title>
    <url>/2019/05/10/Grounded-Video-Description/</url>
    <content><![CDATA[<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><ul>
<li>这是CVPR 2019 做视频描述的一篇文章，该文的主要贡献是对已有的ActivityNet dense caption数据集进行加强—-对其中的帧进行了object bbox的标注，这就为视频描述任务增加了非常有用的信息。</li>
<li>总的来说，<font color="#dd00dd">该文的出发点是：1. 利用object 信息来生成句子. 2. 希望生成的句子中的名词，在video中可以找到相对应的证据(object)。</font><br></li>
<li>grounded-based video description model ：联合生成的单词，并微调在description中生成的object。可以探索这种显式的监督对视频描述带来的益处，并与无监督（可能利用region feature，但是没有 penalize grounding）的方法进行对比。</li>
</ul>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><ul>
<li>video输出的句子中提到的object，并没有在该video中实际存在。那么为什么有这种现象，是因为前的视频描述模型是基于先验知识，在之前的训练过程中，存在一个视频与该视频有 similar contexts，从而使得输出的单词中涵盖了训练video中的obejct，而不是该video本身的object，导致了该现象。</li>
<li>因此本文的工作： 将句子中的名词与视频中的object一 一对应起来，这样就可以建立sentence 与 evidence of video 之间的联系。<br>这样可以<font color="#0099ff" size="5">在视频描述模型中使用这些object 信息</font>，同时，<font color="#0099ff" size="5">还可以评估模型</font>（“teaching models to explicitly rely on the corresponding evidence in the video frame  when generating words and evaluating how well models   are doing in grounding individual words or phrases they  generated.”）。<br>如：该模型生成的句子中的名词与已经标注的object是否是一 一对应的（即便一个模型说出争取的sentence，比如一个男孩正在玩耍，但是如果video中有多个个男孩，那么该sentence输出的一个男孩是指向哪一个呢？）。</li>
</ul>
<h2 id="标注bbox时的细节"><a href="#标注bbox时的细节" class="headerlink" title="标注bbox时的细节"></a>标注bbox时的细节</h2><ul>
<li>“we collect ActivityNet-Entities (short as ANet-Entities) which  grounds or links noun phrases in sentences with bounding  boxes in the video frames.”<br>“we only  annotate a single frame of the video for each noun phrase” 。<br>即， 是对照着已有的sentence中的名词对其进行加框(bbox)，而不是对该video中的所有示例进行标注。对于sentence中的一个名词只在一帧上进行标注（稀疏标注） </li>
</ul>
<h2 id="调研工作"><a href="#调研工作" class="headerlink" title="调研工作"></a>调研工作</h2><h3 id="1-结合object-feature-做captioning任务"><a href="#1-结合object-feature-做captioning任务" class="headerlink" title="1. 结合object feature 做captioning任务"></a>1. 结合object feature 做captioning任务</h3><ul>
<li><strong>当前的方法</strong>，主要是两步：（1）使用off-the-shelf 或者是fine-tuned 的 object detector 来得到 object proposals （2）对object features采用动态attention，或者是对region进行分类，然后送入 decoder中。</li>
<li><strong>存在的问题</strong>，使用现成的object detector 将会使得到的object proposals 更偏向于 source dataset , 而不是偏向于当前的视频描述target dataset。一种解决方案是针对于target dataset 来fine-tune object detector。但是这种那个方案需要大量的标注，尤其是对于video，数据量会更大，</li>
<li>因此提出了<font color="#0099ff" size="5" face="黑体">本文的方法(给出了fine-tune obejct detector的改进方案)</font>：“Instead of  fine-tuning a general detector, we transfer the object classification knowledge from off-the-shelf object detectors to  our model and then fine-tune this representation as part of  our generation model with sparse box annotations. ”。</li>
<li>在文章中的4.4节开头给出了具体的实现：已经得到了bbox，现在的目的是想要得到the class probability distribution for each region. 将在visual genome上预训练的detector迁移到我们的<strong>object classifier</strong> 任务上，另外关于classes集合，假定我们已经有了K个类别，则我们在Visual Genome中根据最近距离找到与其对应的classes。  定义一个softmax( Wx+b )的分类层，W 和 b 的初始化是预训练的detector的最后一个线性层（分类层）的参数值（W应该是根据找出的K个类别按照索引抽出的一个矩阵）。<h3 id="2-object-attention"><a href="#2-object-attention" class="headerlink" title="2. object attention"></a>2. object attention</h3></li>
<li>某些作者指出，attention model关注的region和人类的关注点并不一致，增加attention supervision几乎不能提高性能。另一方面，在feature map attention 上增加监督，是有益处的。</li>
<li>在该文作者的实验中，region attention with supervision 并不能带来性能的提升，作者分析，这可能是由于缺少object context 信息，因此<font color="#0099ff" size="5" face="黑体">该文作者在attention model中引入了基于context encoding 的self-attention</font>，这将会使得信息能够在被采样的视频帧中的regions 传递(我理解的是，region feature 不仅仅是单纯的从fc层中提取到的信息，同时也结合了其余信息来得到 grounding-aware region encoding， 在文章的4.3 以及 4.4节有关于<strong>R<sup>~</sup></strong> 的定义)。 </li>
</ul>
<h2 id="Description-with-Grounding-Supervision"><a href="#Description-with-Grounding-Supervision" class="headerlink" title="Description with Grounding Supervision"></a>Description with Grounding Supervision</h2><ul>
<li>这个框架包括三个模块: <strong>grounding</strong>, <strong>region attention</strong> and <strong>language generation</strong>.<br>grounding： 对于生成的word， 从video中检测到对应的visual clue。<br>region attention: 动态的将visual clue 形成一个high-level的视觉内容的表达，并将其送入decoder。   </li>
<li>这里包括三种方式来结合object-level supervision: <strong>region classification</strong>,  <strong>object grounding (localization)</strong>, and <strong>supervised attention</strong>.  </li>
<li><strong>（我的理解，supervised attention直接针对attention中的系数，查看与真实的对应关系，设计的这个loss对于视频描述生成由益处；object grounding 涉及到了region attention中的系数，因此与描述生成有一定的关联，反向传播可能是有益处的；region classification中设计的loss： 它的反向传播会更新M<sub>s</sub>( R ), 进一步作用于region encoding, 进一步作用于region attention 和 language generate；）</strong></li>
</ul>
<h3 id="Language-Generation-Module"><a href="#Language-Generation-Module" class="headerlink" title="Language Generation Module"></a>Language Generation Module</h3><ul>
<li>本文的decoder 部分采用 [1] 中提到的decoder，与bottom up[3] 的结构大致近似，但是<strong>在[1]中</strong>第二层 language lstm的输入部分，不仅包括attention of region feature， 还包括attention of 最后一个卷积层k girds的特征。对应到本文的视频描述任务上，第二层language lstm的输入，不仅包括attention of region features ，还包括 attention of frames features。即region attention 和 temporal attention</li>
<li>需要注意的是该文中使用的<font color="#0099ff" size="5" face="黑体">temporal attention</font>是[2]中提到的self-attention context encoder with Bidirectional GRU (Bi-GRU)，而不是[1]中使用的attention机制。</li>
<li><font color="#0099ff" size="5" face="黑体">region attention</font>采用的就是bottom up 中的attention结构</li>
<li>下面将[1] 中的原图贴一下：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2x5hlq801j30l20ezq4v.jpg">   </li>
</ul>
<h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><h3 id="Region-proposal-and-features"><a href="#Region-proposal-and-features" class="headerlink" title="Region proposal and features"></a>Region proposal and features</h3><p>For each frame, we use a Faster  R-CNN detector [24] with ResNeXt-101 backbone [30] for  region proposal and feature extraction (fc6). The detector is  pretrained on Visual Genome。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] Neural baby talk. In CVPR 2018.<br>[2] End-to-end dense video captioning with masked transformer. In CVPR 2018.<br>[3] Bottom-up and top-down attention for image captioning and  visual question answering. In CVPR 2018.</p>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>Hierarchical Boundary-Aware Neural Encoder for Video Captioning</title>
    <url>/2019/02/22/Hierarchical-Boundary-Aware-Neural-Encoder-for-Video-Captioning/</url>
    <content><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0g5c5cwmxj30l00mh45o.jpg"><br>In this paper, we focus on the video encoding stage. we propose a recurrent network which can learn to adapt its temporal structure to input data.Our network is the first proposal which exploits temporal segments in<br>video captioning。<br>在这篇文章中，给出了一个循环视频编码方案，该方案可以发现和利用视频的分层结构。不同于经典的编码解码方法（视频由一个循环层来连续的编码），我们提出了一个新颖的LSTM单元， 其可以识别帧/段之间非连续的点，相应地修改编码层的时间连接。</p>
<h2 id="Encoder-Model"><a href="#Encoder-Model" class="headerlink" title="Encoder Model"></a>Encoder Model</h2><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0g57reyepj316c0m7k74.jpg">  </p>
<ul>
<li><strong>traditional lstm network</strong><br>使用LSTM来获得video feature，将每个frames 按每time step 依次送入LSTM，最后一个LSTM cell 的hidden state 用来得到video feature。  <ul>
<li><strong>Time Boundary-aware LSTM network</strong> <strong><em>(ours)</em></strong><br>figure1 与 figure2 结合来看，存在BD（boundary detection ）来检测该帧是否为一个边界（an appearance or action change），若BD检测到存在一个边界，则<strong>保存当前LSTM的输出</strong>，并开始一个新的LSTM（即，hidden state and the cell memory 被重新初始化）。这就确保了在边界之后的输入数据，不受边界之前数据的影响。<br>经过对all frames of video 进行这样的操作，于是得到可变长度的输出 (s1; s2; …; sm), m是检测到segments的数量。<br>这组输出又经过另外一个LSTM层（称为第二LSTM层），第二LSTM层的hidden state 作为整个视频的特征（参考figure1）。<br>Decoder model</li>
</ul>
</li>
</ul>
<hr>
<p>A Gated Recurrent Unit (GRU) layer</p>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>Gumbel-Softmax Trick和Gumbel分布</title>
    <url>/2021/03/15/Gumbel-Softmax-Trick%E5%92%8CGumbel%E5%88%86%E5%B8%83/</url>
    <content><![CDATA[<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><ul>
<li><p>由于最近看到的几篇论文中都有提及到gumble softmax的操作，因此想要具体了解一下。</p>
</li>
<li><p>用到gumbel softmax 的论文包括以下几篇</p>
<ul>
<li><p>解决不可微分问题</p>
<p>【ICCV 2019】Learning to Assemble Neural Module Tree Networks for Visual Grounding</p>
<p>【arXiv: 2101.12059v1】VX2TEXT: End-to-End Learning of Video-Based Text Generation From Multimodal Inputs</p>
<p>【arXiv: 2103.08862】Gumbel-Attention for Multi-modal Machine Translation</p>
<blockquote>
<p><strong>Categorical reparameterization with gumbel-softmax.</strong>  ICLR 2017</p>
</blockquote>
</li>
<li><p>在概率分布上添加gumble noise，再从新的概率分布上以概率检索样本</p>
<p> Bridging the Gap between Training and Inference for Neural Machine Translation</p>
<blockquote>
<p><strong>A* sampling.</strong> NIPS 2017</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>来源:  <a href="https://www.cnblogs.com/initial-h/p/9468974.html" target="_blank" rel="noopener">https://www.cnblogs.com/initial-h/p/9468974.html</a></p>
<p>之前看MADDPG论文的时候，作者提到在离散的信息交流环境中，使用了Gumbel-Softmax estimator。于是去搜了一下，发现该技巧应用甚广，如深度学习中的各种GAN、强化学习中的A2C和MADDPG算法等等。只要涉及在离散分布上运用重参数技巧时(re-parameterization)，都可以试试Gumbel-Softmax Trick。</p>
<p>  这篇文章是学习以下链接之后的个人理解，内容也基本出于此，需要深入理解的可以自取。</p>
<ul>
<li><a href="http://amid.fish/humble-gumbel" target="_blank" rel="noopener">The Humble Gumbel Distribution</a></li>
<li><a href="https://hips.seas.harvard.edu/blog/2013/04/06/the-gumbel-max-trick-for-discrete-distributions/" target="_blank" rel="noopener">The Gumbel-Max Trick for Discrete Distributions</a></li>
<li><a href="https://casmls.github.io/general/2017/02/01/GumbelSoftmax.html" target="_blank" rel="noopener">The Gumbel-Softmax Trick for Inference of Discrete Variables</a></li>
<li><a href="https://www.zhihu.com/question/62631725/answer/201338234" target="_blank" rel="noopener">如何理解Gumbel-Max trick？</a></li>
</ul>
<p>  这篇文章从直观感觉讲起，先讲Gumbel-Softmax Trick用在哪里及如何运用，再编程感受Gumbel分布的效果，最后讨论数学证明。</p>
<h2 id="一、Gumbel-Softmax-Trick用在哪里"><a href="#一、Gumbel-Softmax-Trick用在哪里" class="headerlink" title="一、Gumbel-Softmax Trick用在哪里"></a>一、Gumbel-Softmax Trick用在哪里</h2><h3 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h3><p>  通常在强化学习中，如果动作空间是离散的，比如上、下、左、右四个动作，通常的做法是网络输出一个四维的one-hot向量(不考虑空动作)，分别代表四个动作。比如 [1,0,0,0] 代表上，[0,1,0,0] 代表下等等。而具体取哪个动作呢，就根据输出的每个维度的大小，选择值最大的作为输出动作, 即argmax(v)。</p>
<p>  例如网络输出的四维向量为v=[−20,10,9.6,6.2]，第二个维度取到最大值10，那么输出的动作就是[0,1,0,0]，也就是下，这和多类别的分类任务是一个道理。但是这种取法有个问题是不能计算梯度，也就不能更新网络。通常的做法是加softmax函数，把向量归一化，这样既能计算梯度，同时值的大小还能表示概率的含义。softmax函数定义：$\sigma\left(z_{i}\right)=\frac{e^{z_{i}}}{\sum_{j=1}^{K} e^{z_{j}}}$</p>
<p>  那么将v=[−20,10,9.6,6.2]通过softmax函数后有σ(v)=[0,0.591,0.396,0.013]，这样做不会改变动作或者说类别的选取，同时softmax倾向于让最大值的概率显著大于其他值，比如这里10和9.6经过softmax放缩之后变成了0.591和0.396，6.2对应的概率更是变成了0.013，这有利于把网络训成一个one-hot输出的形式，这种方式在分类问题中是常用方法。</p>
<p>  但是这么做还有一个问题，这个表示概率的向量σ(v)=[0,0.591,0.396,0.013]并没有真正显示出概率的含义，因为一旦某个值最大，就选择相应的动作或者分类。比如σ(v)=[0,0.591,0.396,0.013]和σ(v)=[0,0.9,0.1,0]在类别选取的结果看来没有任何差别，都是选择第二个类别，但是从概率意义上讲差别是巨大的。所以需要一种方法不仅选出动作，而且遵从概率的含义。</p>
<p>  很直接的方法是依概率分布采样就完事了，比如直接用<code>np.random.choice</code>函数依照概率生成样本值，这样概率就有意义了。这样做确实可以，但是又有一个问题冒了出来：这种方式怎么计算梯度？不能计算梯度怎么用BP的方式更新网络？</p>
<p>  这时重参数(re-parameterization)技巧解决了这个问题，<a href="https://casmls.github.io/general/2017/02/01/GumbelSoftmax.html" target="_blank" rel="noopener">这里</a>有详尽的解释，不过比较晦涩。简单来说重参数技巧的一个用处是把采样的步骤移出计算图，这样整个图就可以计算梯度BP更新了。之前我一直在想分类任务直接softmax之后BP更新不就完事了吗，为什么非得采样。后来看了VAE和GAN之后明白，还有很多需要采样训练的任务。这里举简单的VAE(变分自编码器)的例子说明需要采样训练的任务以及重参数技巧，详细内容来自<a href="https://www.bilibili.com/video/av20165127" target="_blank" rel="noopener">视频</a>和<a href="http://kvfrans.com/variational-autoencoders-explained/" target="_blank" rel="noopener">博客</a>。</p>
<h3 id="Re-parameterization-Trick"><a href="#Re-parameterization-Trick" class="headerlink" title="Re-parameterization Trick"></a>Re-parameterization Trick</h3><p>  最原始的自编码器通常长这样：</p>
<p><img src="C:\Users\shiyaya\Desktop\1428973-20180813165000500-1207992534.jpg" alt="img" style="zoom: 67%;"></p>
<p>  左右两边是端到端的出入输出网络，中间的绿色是提取的特征向量，这是一种直接从图片提取特征的方式。<br>  而VAE长这样:</p>
<p><img src="https://i.loli.net/2021/03/18/yO5L9kCMPhrwJub.png" alt="image-20210318135149420"></p>
<p>  VAE的想法是不直接用网络去提取特征向量，而是提取这张图像的分布特征，也就把绿色的特征向量替换为分布的参数向量，比如说均值和标准差。然后需要decode图像的时候，就从encode出来的分布中采样得到特征向量样本，用这个样本去重建图像，这时怎么计算梯度的问题就出现了。<br>  重参数技巧可以解决这个问题，它长下面这样:</p>
<p><img src="https://i.loli.net/2021/03/18/27e1EIhVFfWyJKi.png" alt="img" style="zoom:67%;"></p>
<p>假设图中的 $x$ 和 $\phi$ 表示VAE中的均值和标准差向量, 它们是确定性的节点。而需要输出的样本 $z$ 是带有随机性的节点， 重参数就是把带有随机性的 $z$ 变成确定性的节点, 同时随机性用另一个输入节点 $\epsilon$ 代替。<br>例如，这里用正态分布采样, 原本从均值为 $x$ 和标准差为 $\phi$ 的正态分布 $N\left(x, \phi^{2}\right)$ 中采样得到 $z_{\circ}$ 现在将其转化成从标准正态分布 $N(0,1)$ 中采样得到 $\epsilon$ , 再计算得到 $z=x+\epsilon \cdot \phi_{\circ}$ 这样一来, 采样的过程移出了计算图, 整张计算图就可以计算梯度进行更新了，而新加的 $\epsilon$ 的输入分支不 做更新，只当成一个没有权重变化的输入。</p>
<p>到这里，需要采样训练的任务实例以及重参数技巧基本有个概念了。</p>
<h3 id="Gumbel-Softmax-Trick"><a href="#Gumbel-Softmax-Trick" class="headerlink" title="Gumbel-Softmax Trick"></a>Gumbel-Softmax Trick</h3><p>VAE的例子是一个连续分布(正态分布)的重参数，离散分布的情况也一样，首先需要可以采样，使得离散的概率分布有意义而不是只取概率最大的值，其次需要可以计算梯度。那么怎么做到的，具体操作如下：</p>
<p>对于n维概率向量$\pi$, 对$\pi$对应的离散随机变量 $x_{\pi}$ 添加Gumbel噪声，再取样$x_{\pi}=\arg \max \left(\log \left(\pi_{i}\right)+G_{i}\right)$<br>其中, $G_{i}$ 是独立同分布的标准Gumbel分布的随机变量，标准Gumbel分布的CDF为$F(x)=e^{-e^{-x}}$</p>
<p>这就是<strong style="color:red;">Gumbel-Max trick</strong>。可以看到由于这中间有一个argmax操作，这是不可导的。所以用softmax函数代替之，也就是<strong style="color:red;">Gumbel-Softmax Trick</strong>，而$G_{i}$ 可以通过Gumbel分布求逆从均匀分布生成，即 $G_{i}=-\log \left(-\log \left(U_{i}\right)\right), U_{i} \sim U(0,1)$</p>
<p>算法流程如下：</p>
<ul>
<li><p>对于网络输出的一个 $n$ 维向量 $v$ （predict logits）, 生成 $n$ 个服从均匀分布 $U(0,1)$ 的独立样本 $\epsilon_{1}, \ldots, \epsilon_{n}$</p>
</li>
<li><p>通过 $G_{i}=-\log \left(-\log \left(\epsilon_{i}\right)\right)$ 计算得到 $G_{i}$</p>
</li>
<li><p>对应相加得到新的值向量 $v^{\prime}=\left[v_{1}+G_{1}, v_{2}+G_{2}, \ldots, v_{n}+G_{n}\right]$</p>
</li>
<li><p>通过Softmax函数</p>
</li>
</ul>
<script type="math/tex; mode=display">
\sigma_{\tau}\left(v_{i}^{\prime}\right)=\frac{e^{v_{i}^{\prime} / \tau}}{\sum_{j=1}^{n} e^{v_{j}^{\prime} / \tau}}</script><p>计算概率大小得到最终的类别。其中 $\tau$ 是温度参数。</p>
<p>temperature控制着softmax的soft程度，温度越高，生成的分布越平滑（接近这里的均匀分布）；温度越低，生成的分布越接近离散的one-hot分布（argmax）。因此，<strong>训练时可以逐渐降低温度，以逐步逼近真实的离散分布。</strong></p>
<p><strong>yaya: 其实这里的 gumbel softmax 不是针对网络输出$v$ 进行一个离散采样，而是对 $v$ 添加噪声之后，再取softmax，而后得到新的概率分布，而这个新的概率分布也不是去argmax, 而是对于每个 $v_i$ 重新分配一个概率权重。其优点在于可以调控 temperature， 当温度低时，近似做了argmax 采样</strong></p>
<p>直观上来说，Gumbel-Softmax就是在原来的输出上加入了一个噪声，对于强化学习来说，在选择动作之前加一个Gumbel扰动，相当于增加了探索度，感觉上是合理的，而同时他又能保证采样是对原分布的逼近。对于深度学习的任务来说，添加随机性去模拟分布的样本生成，也是合情合理的。</p>
]]></content>
      <categories>
        <category>杂类</category>
      </categories>
      <tags>
        <tag>杂类</tag>
      </tags>
  </entry>
  <entry>
    <title>HiT Hierarchical Transformer with Momentum Contrast for Video-Text Retrieval</title>
    <url>/2021/04/02/HiT-Hierarchical-Transformer-with-Momentum-Contrast-for-Video-Text-Retrieval/</url>
    <content><![CDATA[<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><ul>
<li><p>当前基于 transformer architecture 的 跨模态检索，仅仅使用最后一层的embeddings。 不同的层有不同的特诊特性，却没有被利用。</p>
</li>
<li><p>端到端的训练机制限制了负样本的交互仅能在一个mini-batch 中被执行（负样本的数量受到限制）。</p>
</li>
</ul>
<h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><ul>
<li>提出了一个新颖的hierarchical transformer 来做 video-text retrieval。在feature-level（第一层） 和 semantic-level（最后一层） 来实现分层跨模态对比匹配。</li>
<li>受到MOCO的启发，在跨模态学习中使用Momentum Cross-modal Contrast（<strong>MCC</strong>），以使能 大规模的负样本交互，这种方式对生成更加精确且有判别力的表达是有贡献的。</li>
</ul>
<p>本文的 momentum encoder 与 论文“Memory Enhanced Embedding Learning forCross-Modal Video-Text Retrieval”的思想很一致</p>
<h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="https://i.loli.net/2021/04/02/uTMwEnhAfIVgixm.png" alt="image-20210402161043011"></p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><ul>
<li><p>在各个数据集上的实验效果</p>
<p><img src="https://i.loli.net/2021/04/02/PrfJab2l3kLcxmg.png" alt="image-20210402164510842" style="zoom:50%;"></p>
<p><img src="https://i.loli.net/2021/04/02/rps6KOJ31wBnitX.png" alt="image-20210402164527524" style="zoom:50%;"></p>
</li>
<li><p>使用不同维度下的MCC的效果对比</p>
<p><img src="https://i.loli.net/2021/04/02/25nEX687HBZSqVN.png" alt="image-20210402164404377" style="zoom:50%;"></p>
</li>
<li><p>InfoNCE loss vs Triplet Ranking loss</p>
<p><img src="https://i.loli.net/2021/04/02/4LPx5Nh1nIAgaGf.png" alt="image-20210402164121908" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><p>值得注意的是本文使用的是 dual encoding的方法，</p>
<p>对 video feature 和 sentence feature 分别使用各自的transformer获得特征。</p>
]]></content>
      <categories>
        <category>cross-modal</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
      </tags>
  </entry>
  <entry>
    <title>Hierarchical Global-Local Temporal Modeling for Video Captioning</title>
    <url>/2019/07/23/Hierarchical-Global-Local-Temporal-Modeling-for-Video-Captioning/</url>
    <content><![CDATA[<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><ul>
<li>使用object features能够更好地检测出action 和 关键的Object</li>
</ul>
<h3 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h3><ul>
<li><p>两个LSTM层</p>
</li>
<li><p>global : frame features and C3D features</p>
</li>
<li><p>local : objects </p>
</li>
</ul>
<h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><ul>
<li>Top Down decoder<ul>
<li>Bottom LSTM：mean of regions</li>
<li>Top LSTM : attention of  regions</li>
</ul>
</li>
<li><p>Grounded video description的decoder：</p>
<ul>
<li>Bottom LSTM：mean of  fc+motion</li>
<li>Top LSTM: attention of  regions and attention of  fc+motion</li>
</ul>
</li>
<li>==Hierarchical Global-Local Temporal Modeling（本文） ==<ul>
<li>Bottom LSTM：attention of fc+motion</li>
<li>Top LSTM: attention of regions</li>
<li>本文不一样的地方是在Bottom LSTM的输入也加入了attention</li>
</ul>
</li>
</ul>
<h3 id="提取特征"><a href="#提取特征" class="headerlink" title="提取特征"></a>提取特征</h3><ul>
<li>等间隔提取帧的特征</li>
<li>由于帧之间的间隔，会使得没有运动信息，所以再使用C3D来补充运动信息（以该该为中心，提取16帧，输入C3D中）</li>
<li>object features: faster rcnn 去掉rcnn部分的类别/分数预测，提取head_to_heal处的pooled_feats</li>
</ul>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>How Many Data Points is a PromptWorth?</title>
    <url>/2021/03/20/How-Many-Data-Points-is-a-PromptWorth/</url>
    <content><![CDATA[<p>转载：<a href="https://mp.weixin.qq.com/s/vX6o4lJKP4ajVfGSw8-tqg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/vX6o4lJKP4ajVfGSw8-tqg</a></p>
<blockquote>
<p>今天介绍的是一篇 NAACL’21 新鲜出炉的工作！NAACL 上周四出的结果，这篇工作本周一上传 arxiv，周二被王苏小哥哥发现，周三拜读了一下，今天就来和大家分享啦！！</p>
</blockquote>
<p>给大家提个问题：如果训练样本只有几百条，这时候我们该怎么办呢？</p>
<p>传统的 RNN 在这个样本大小下很难被训练好，自然地，我们会想到使用预训练模型，在其基础上进行 finetune。具体来讲，就是将预训练模型作为模型的底层，在上面添加与当前任务特点相关的网络结构。这样就引入了预训练的知识，对当前任务能产生很大的帮助。</p>
<p><img src="https://i.loli.net/2021/03/21/QodMJ9GWgv6fcUy.png" alt="微信截图_20210321123106" style="zoom:33%;"></p>
<p>除了预训练的知识，是不是还有其他的信息我们没有用上呢？近年来，越来越多的人在使用另一种 finetune 方法，即<strong>结合具体场景，设计新的 finetune 任务形式，从而将与当前任务相关的提示信息（prompt）引入模型</strong>。我们大名鼎鼎的 GPT 系列就是这么干的。比如我们拿 GPT3 做 QA 的 finetune，直接喂给他一串“<em>Question：问题内容 Answer：</em>”，剩下的答案部分就让 GPT3 自己填完。</p>
<p><img src="https://i.loli.net/2021/03/21/s8DHwgmNJY7Ryvk.png" alt="image-20210321123155512" style="zoom: 33%;"></p>
<p>这类 finetune 技巧虽然陆续被使用，但并没有人论证：<strong>这种做法相比于传统的 finetune 方法，真的能带来提升吗</strong>？如果答案是肯定的，<strong>那么究竟能提升多少呢（能否量化这种提升）？</strong></p>
<p>今天这篇来自 Huggingface 的文章就填补了上述两个问题的答案。他们通过大量实验证明：<strong>引入提示信息和多标注几百条数据带来的性能提升是相当的</strong>！所以，下次老板只给少量样本，就要你 finetune 模型——不要慌！我们今天又多学了一个 trick！</p>
<p><strong>论文题目</strong>:<br><strong><em>How Many Data Points is a Prompt Worth?</em></strong></p>
<p><strong>论文链接</strong>:<br><em><a href="https://arxiv.org/abs/2103.08493" target="_blank" rel="noopener">https://arxiv.org/abs/2103.08493</a></em></p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>前文提到，这一类 finetune 是将任务对应的输入改写成新的完形填空格式，让模型预测 <mask> 部分的词，作为抽取任务的答案或者生成任务的结果。这种方法不需要改变模型结构、没有额外的参数，简直不要太方便！</mask></p>
<h3 id="引入描述集合"><a href="#引入描述集合" class="headerlink" title="引入描述集合"></a>引入描述集合</h3><p>本文对这类方法进行了进一步简化：不要求 <mask> 处生成任意的文本，而是只需要完成类似于有选项的完形填空任务。这里的选项是固定的几个词，我们称之为描述集合（verbalizer），不同任务会有不同的描述集合。</mask></p>
<p>比如，对于判断题的阅读理解任务，就可以将阅读文本、问题和 <mask> 拼接，让预训练模型直接预测 <mask> 属于描述集合 {yes, no} 中的哪一种描述：</mask></mask></p>
<blockquote>
<p>小明天天码代码码到天明 [SEP] <strong>小明有女朋友吗？</strong> <mask></mask></p>
</blockquote>
<p>其中前半部分是阅读文本，后面<strong>加粗</strong>的部分是问题。模型只需要判断 <mask> 属于描述集合 {yes, no} 中的哪一种。</mask></p>
<p>可能读到这里，大家会疑惑：直接拼起来搞一个 True / False 的二分类不就好了嘛，何必让模型填空呢？嘿嘿，这恰好是作者的用意：通过让模型填空，<strong>模型可以习得描述集合中标签文本的语义信息</strong>。</p>
<h3 id="引入提示信息"><a href="#引入提示信息" class="headerlink" title="引入提示信息"></a>引入提示信息</h3><p>直接拼接是最朴素的，但这能让模型知道自己在做什么任务嘛？为此，作者引入了<strong>提示信息</strong>（prompt）。</p>
<p>还是判断题的阅读理解任务，对文章 和问题 ，作者将他们与一些固定的词进行整合，以此输入模型，让模型预测 <mask> 。作者提出了三种整合方式：</mask></p>
<p><img src="https://i.loli.net/2021/03/21/QEPwMG7bfI2UzNH.png" alt="image-20210321123632246" style="zoom: 33%;"></p>
<p>没错，就是这么简单！这些固定的词作为提示信息，让模型了解当前在做的任务；同时，提示词文本的含义也对于模型的理解产生了一定的帮助。</p>
<p>除了单选阅读理解，这篇文章还关注了文本蕴含、多选阅读理解、指代销歧等共六个任务。对于不同的任务，有不同的提示信息与输入格式：</p>
<p>对于文本蕴含任务，可以将前提 (premise, ) 与假设 (hyphothesis, ) 通过提示信息整合，作者提出了两种整合方式：</p>
<p><img src="https://i.loli.net/2021/03/21/k1ul7icFX69IKnL.png" alt="image-20210321123241288" style="zoom: 33%;"></p>
<p>这样就只需要让模型预测 <mask> 属于描述集合 {yes, no, maybe} 中的哪一种，以此判断前提能否支撑假设。</mask></p>
<p>对于指代销歧任务，可以将句子 、带标记的介词 与名词 通过提示信息整合：</p>
<p><img src="https://i.loli.net/2021/03/21/sRZIGzn2Pg76mpd.png" alt="image-20210321123253166" style="zoom: 33%;"></p>
<p>这样就只需要让模型预测 <mask> ，以此判断介词是否指代名词。这里的描述集合是不受限制的，即让模型在 <mask> 处预测指代的名词 。</mask></mask></p>
<p>其他任务也采用类似的整合方式，感兴趣可以参考原文～</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>作者发现，这种使用提示信息的整合方式，在低资源的情况下对模型性能有非常大的提升！</p>
<p>比如在阅读理解任务的 BoolQ 数据集上，作者将使用提示信息整合的 finetune 方法与增加一层分类层的 finetune 方法进行了对比。下图是在使用不同数量的样本训练时，模型准确率的对比。</p>
<p><img src="https://i.loli.net/2021/03/21/31cqsF5Q7VoSeLX.png" alt="image-20210321123431996" style="zoom:50%;"></p>
<p>可以发现，在数据量比较小的时候，使用提示信息整合的 finetune 方法（黄色）比增加一层分类层的 finetune 方法（紫色）有更好的表现。</p>
<p>在某些任务上，这种表现的提升是惊人的：</p>
<p><img src="https://i.loli.net/2021/03/21/WCo9uUakm1rOH8N.png" alt="image-20210321123504144" style="zoom:50%;"></p>
<p>这是在指代销歧任务的 WSC 数据集上的实验结果。在水平方向看，<strong>仅使用 25 个样本，就达到传统 fintune 方法使用 300 个样本才能达到的效果！</strong></p>
<p>此外，作者还进行了一系列的消融实验，得到一些有意思的结论：</p>
<ol>
<li>模型通过预测 <mask> 属于描述集合中的哪种，以此完成任务。如果将这里改为不带语义的单纯的分类，性能也会有所下降。</mask></li>
<li>作者为每个任务都提供了多种整合提示信息的方式，但是发现，不同方式的区别对性能影响甚微。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章对基于提示信息的 finetune 方法在进行了大量实验，证明了这类方法在低资源的情况下性能大幅优于传统方法。这种 finetune 的思路应该是可以应用于各类 NLP 下游任务的。尤其是低资源场景下，应该会非常有帮助。如果老板真的只给几百条数据让训练模型，这样的方法说不定就有奇效！</p>
]]></content>
      <categories>
        <category>NLP</category>
        <category>few-shot learning</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>few-shot learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Human-like Controllable Image Captioning with Verb-specific Semantic Roles</title>
    <url>/2021/03/25/Human-like-Controllable-Image-Captioning-with-Verb-specific-Semantic-Roles/</url>
    <content><![CDATA[<h2 id="本文研究的内容"><a href="#本文研究的内容" class="headerlink" title="本文研究的内容"></a>本文研究的内容</h2><p>Controllable Image Captioning</p>
<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>目前存在的objective control signals忽视了理想控制信号的两个必不可少的特征：</p>
<ul>
<li>Event-compatible</li>
</ul>
]]></content>
      <categories>
        <category>cross-modal</category>
        <category>image captioning</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
        <tag>image captioning</tag>
      </tags>
  </entry>
  <entry>
    <title>I3D</title>
    <url>/2019/04/09/I3D/</url>
    <content><![CDATA[<ul>
<li>参考:<a href="https://zhuanlan.zhihu.com/p/34919655" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34919655</a></li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1wgkib11aj310b0ew77m.jpg">  </p>
<h3 id="训练和预测"><a href="#训练和预测" class="headerlink" title="训练和预测"></a>训练和预测</h3><ul>
<li>写在前面，方便看，哈哈哈哈</li>
<li>video 以25帧/秒的帧率来提取关键帧</li>
<li>在训练时，以64帧组成的snippets进行训练。</li>
<li>在测试时，同样以64帧组成的snippets进行测试，但是对于该video上的所有的snippet的预测结果进行取平均作为该video的预测结果</li>
</ul>
<h3 id="方法1：ConvNet-LSTM"><a href="#方法1：ConvNet-LSTM" class="headerlink" title="方法1：ConvNet+LSTM"></a><strong>方法1：ConvNet+LSTM</strong></h3><ul>
<li>该方案主要考虑到cnn在图像分类领域的成功以及LSTM对于序列建模的能力，很自然提出将两者结合起来的方案。如果只是用cnn的话，需要对每一帧都提取特征，然后将视频的所有帧特征进行总汇，以此来表达对视频的表示，显然这样做忽略的时间结构特征。而LSTM可以处理长时间依赖的问题，可以对视频从第一帧开始建模直到最后一帧，使用cnn网络对每帧提取特征，然后将特征送入LSTM来捕捉时间特征，最后一帧的输出用来对视频特征表示。<br>  LSTM往往依赖cnn的最后一层特征最为输入，因此不能够捕捉到<code>low-level motion</code>的特征，而且对于遍历整个视频也很难去训练。<h3 id="方法2：3D-ConvNets"><a href="#方法2：3D-ConvNets" class="headerlink" title="方法2：3D ConvNets"></a><strong>方法2：3D ConvNets</strong></h3></li>
<li><code>3D ConvNets</code>是对视频建模最自然的方式，和标准cnn区别在于由<code>2d conv</code>变为<code>3d conv</code>，来捕捉<code>spatio-temporal feature</code>。想法很好，但目前遇到一些问题，问题一：<code>3D ConvNets</code>的<code>3d conv</code>多了一个维度，参数量有较大增加，这将会很难去训练。问题二：没有利用那些Imagenet上成功的预训练模型来迁移学习，往往使用层数少的cnn在小数据集上从头训练。简要说就是要利用已有预训练模型，要减少参数或增大数据集。<br>  论文中实现了C3D（与原版略有差异）有8 conv layer、5 pooling layer 和 2 fc layer，并在所有圈卷积层和fc层加bn。输入是16×112×112（通过crop方法），将第一个pooling layer对时间的stride由1变成2，为了可以减少memory和允许更大batch。<h3 id="方法3：Two-Stream-Networks"><a href="#方法3：Two-Stream-Networks" class="headerlink" title="方法3：Two-Stream Networks"></a><strong>方法3：Two-Stream Networks</strong></h3></li>
<li>该方案利用短的视频段来建模，用每个clip的预测分数平均的方式（其实C3D也是类似），但不同的是输入，包括一张RGB和10张<code>optical flow</code>(其实是5张，x/y两个方向，运动特征)。模型能使用<code>two-branch</code>方式，利用预训练的imagenet模型，最后将预测结果平均下（最原始的，或者在最后softmax做融合），这样建模的模型比较好训练，同时也能获得更高的分数。  </li>
<li>模型的两个输入流也可以在后面的cnn层来进行融合，以提升相同，同时可以<code>end-to-end</code>训练。论文实现一个类似的two-stream方案，在最后一层用<code>3d conv</code>将spatial和flow特征进行融合。<h3 id="方法4：Two-Stream-Inflated-3D-ConvNets"><a href="#方法4：Two-Stream-Inflated-3D-ConvNets" class="headerlink" title="方法4：Two-Stream Inflated 3D ConvNets"></a><strong>方法4：Two-Stream Inflated 3D ConvNets</strong></h3></li>
<li>该方案是论文提出的，出发点是要利用imagenet的预训练模型，同时利用<code>3d conv</code>来提取<code>RGB stream</code>的<code>temporal feature</code>，最后再利用<code>optical-flow stream</code>提升网络性能，也就大融合的方案（把有效的技巧都用上）。  </li>
<li>通过对预训练的<code>2D conv</code>增加temporal维度，把N×N的filter变为N×N×N。简单的办法就是对N×N的filter重复复制N遍，并归一化，这样多的出发点是短期内时间不变性的假设，姑且把这当成<code>3D filter</code>初始化的一种策略吧。  </li>
<li>池化操作怎么膨胀？stride怎么选？主要依赖感受野尺寸，如果图像水平方向和竖直方向相等，那么stride也相等，而且越深的特征感受野越大。但是考虑到时间因素，对称感受野不是必须的，这主要还是依赖帧率和图片大小。时间相对于空间变化过快，将合并不同object的边信息，过慢将不能捕捉场景变化。  </li>
<li>虽然3D conv能够捕捉motion信息，但是与光流优化的方式和效果还是不一样，因此使用<code>two-stream</code>的方式构建，并分开训练两个网络。</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-34f1d3ac14884d5c9114d4e9383c2e89_hd.jpg" alt></p>
<hr>
<ul>
<li><p>数据集不同，评测结果也不同。flow在UCF-101上效果比HMDB-51、kinetics上好（有更多camera运动的原因）。<br><img src="https://pic2.zhimg.com/80/v2-e719a0a3a022e348838d4b6a5c0b8a55_hd.jpg" alt></p>
</li>
<li><p>在imagenet上训练后迁移到kinetics和直接在kinetics上的对比，迁移后的效果好，说明RGB流起的作用大。整体上I3D模型参数更少，更深，训练输入在时间和空间维度上都比C3D大。<br><img src="https://pic3.zhimg.com/80/v2-b358535638c000de801577fc84296252_hd.jpg" alt></p>
</li>
</ul>
]]></content>
      <categories>
        <category>行为识别</category>
      </categories>
      <tags>
        <tag>行为识别</tag>
      </tags>
  </entry>
  <entry>
    <title>Image Caption 常用评价指标</title>
    <url>/2019/03/24/Image-Caption-%E5%B8%B8%E7%94%A8%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Improving Neural Machine Translation with Soft Template Prediction</title>
    <url>/2021/06/06/Improving-Neural-Machine-Translation-with-Soft-Template-Prediction/</url>
    <content><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>机器翻译</p>
<h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><p>受到人类翻译过程和其他领域基于模板和基于语法的方法启发，微软亚洲研究院提出了一种使用<strong>从语法树结构中提取的模板</strong>作为<strong>软目标模板</strong>来指导翻译过程的方法 ST-NMT。</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>尽管近年来神经机器翻译（NMT）取得了长足的进步，但大多数神经机器翻译模型直接从源文本生成翻译。受到人类翻译过程和其他领域基于模板和基于语法的方法的成功启发，我们提出了一种使用从语法树结构中提取的模板作为软目标模板来指导翻译过程的方法。为了学习目标句子的句法结构，我们采用语法分析树来生成候选模板，并将模板信息融合到编码器-解码器框架中，同时利用模板和源文本生成翻译。实验表明，我们的模型在四个数据集上明显优于基线模型，证明了软目标模板的有效性。</p>
<h2 id="软模板预测"><a href="#软模板预测" class="headerlink" title="软模板预测"></a>软模板预测</h2><p>近年来，神经机器翻译取得了巨大的进步，但常规的神经机器翻译模型一般直接把源语言文本翻译到目标语言文本。但实际上，我们知道人类在翻译一句话时通常是先对目标文本的句型或者结构有一个大致的想法，然后再将源语言文本翻译成为目标语言文本，并不是直接逐词进行翻译。</p>
<p>通常我们在进行造句训练的时候，最开始老师会教给我们一些句型，例如 “sb. like doing sth; There be…” 等，然后让我们做练习。下图是一个中英翻译训练教材的内容，要求根据以下句型将中文翻译到英文。</p>
<p><img src="https://i.loli.net/2021/06/06/ipqb2FWnoZxsufz.png" alt="img" style="zoom:50%;"></p>
<p><em>图1：中英翻译训练教材内容</em></p>
<p>受到人类翻译过程的启示，我们提出了使用从句法分析树提取模板作为软目标语言模板来指导翻译过程的方法。为了学习目标句子的句法结构，我们采用句法分析树来生成候选模板。如图2所示，我们首先根据源语言文本预测将要用到的目标语言的模板，这里 “我喜欢打篮球”，很容易想到 “sb. like doing sth” 这个句型，随后我们根据源语言和模板来生成翻译。</p>
<p><img src="https://i.loli.net/2021/06/06/UnaNz1vmtAidhTQ.png" alt="img" style="zoom:50%;"></p>
<p><em>图2：使用软目标模板指导翻译过程示例</em></p>
<p>基于这一核心思想以及模板方法在机器摘要、问答和其他文本上取得的成功。我们假设目标句子的候选模板可以指导句子翻译过程。我们将这些从句法分析树中提取的模板作为软模板，由 S, NP, VP 这些具有句子结构信息和目标语言组成。这里模板是“软 (soft) ”的，因为我们<strong>并不强制要求生成的目标语言翻译一定是完全基于模板来生成</strong>，这里的模板仅仅是提供一种参考来对翻译提供一定的帮助。</p>
<p>为了更有效地使用软模板，我们引入了基于目标语言软模板的神经机器翻译模型 (Soft Template-based NMT，ST-NMT)，它可以使用源文本和软模板来预测最终的翻译。我们的方法可以分为两个阶段。在第一阶段，通过使用源文本和从句法分析树中提取的模板，训练一个标准的 Transformer 模型来专门预测软目标模板。在第二阶段，我们使用两种编码器，包括软目标模板编码器和源语言编码器，以对源文本和模板进行编码并生成最终翻译。</p>
<h2 id="目标软模板预测"><a href="#目标软模板预测" class="headerlink" title="目标软模板预测"></a>目标软模板预测</h2><p><img src="https://i.loli.net/2021/06/06/MSToYB93vDrqCwz.png" alt="img" style="zoom:50%;"></p>
<p><em>图3：从分析树中抽取模板</em></p>
<p>在此过程中，通过使用源语言 S 和模板 T 数据，我们对 P(T|X) 建模，使得我们能够根据源语言对模板进行预测。为了构造源语言-模板数据集，我们使用句法分析树来解析目标语言文本并获得树形结构。然后，我们裁剪超过一定深度的节点，并将裁剪后的子树按照原有顺序还原回去得到模板数据。通过这些操作，我们获得了源语言-模板平行训练数据，并训练了 Transformer 模型 P(T|X) 来预测软目标模板。</p>
<p>语法解析树可以显示整个句子的结构和语法信息，利用语法来区分终端（terminal nodes）和非终端节点（non-terminal nodes）。更确切地说，非终端节点由属于非终端节点集合 S，而终端节点属于目标语言节点集合 V。S={V, VP, NP, …, ASBR} 等代表语法成分的标记和 V={There, are, …, people} 包含目标语言单词。如 图3 所示，句子“有人在奔跑”通过语法解析树生成树形结构。在这种情况下，非终端节点集合S0={S, NP, VP, EX, VBP, NP, DT, NNS, VBG} 和终端节点集合 V0={There, are, some, people, running}。我们的模板 T={t1, t2, t3, t4} 是有序序列，由终端节点和非终端节点组成。在这种情况下，t1=There, t2=are, t3=VP, t4=NP。我们的模板是提取特定深度的子树，并使用位于子树的叶节上的终端和非终端节点来生成模板。</p>
<p>为了预测软目标模板，我们根据源文本和提取的模板的训练数据来训练一个Transformer 模型。Transformer 模型读取源文本，并使用束搜索预测软目标模板。然后，我们选择束搜索的前 K 个结果作为模板。</p>
<p><strong>选择子树的深度是一个权衡。在图3中，当深度等于1是一种特殊的情况，此时模板仅具有一个符号 S。模板 S 无法提供任何有用的信息。另一个特殊情况是当深度大于6时，“There are some people running” 此时模板只有终端节点。该模板仅包含目标语言单词，不能提供任何其他信息。而当深度等于4时，模板为 “There are VP NP”。该模板包含句子句法和结构信息，适用于我们的方法。</strong></p>
<p>使用 Transformer 模型 P(T|X)，我们需要构造伪训练数据(源语言文本、目标语言文本、目标软模板)，而不是通过语法分析树直接提取的模板。给定源文本 X，我们使用 P(T|X) 通过束搜索来生成排名靠前的目标语言软模板 T。最后，我们得到三元组训练数据 (源语言文本、目标语言文本、软模板）为下一阶段做准备。</p>
<h2 id="ST-NMT模型"><a href="#ST-NMT模型" class="headerlink" title="ST-NMT模型"></a>ST-NMT模型</h2><p>我们的模型首先通过源语言 Transformer 编码器以读取源语言序列 X=(x1, x2, x3, …, xn)并生成模板序列 T=(t1, t2, t3, …, tm) 由模板 Transformer 解码器提供。如图3所示，我们的模型使用源语言 Transformer 编码器和模板 Transformer 编码器，分别对源语言序列 X 和模板序列 T 进行编码，最终解码器生成最终翻译。我们的方法主要包括两个阶段：（1）训练数据由基于选区的解析树构造。然后，我们采用标准的 Transformer 将源文本转换为下一代软目标模板。（2）基于源文本和预测的软目标模板，我们使用两个编码器分别将两个序列编码为隐藏状态，并使用目标语言解码器生成最终翻译。</p>
<p><img src="https://i.loli.net/2021/06/06/Lz1C5HU7uFwle6K.png" alt="image-20210606102157632"></p>
<p><em>图4：ST-NMT 模型</em></p>
<p>给定三元组训练数据（源语言文本，目标语言文本，软模板）后，我们使用源语言文本和软模板生成目标语言文本如下公式。源语言 Transformer 编码器和软模板Transformer 编码器将输入序列 X 和由目标语言单词和非终端节点组成的模板 T 映射到隐层向量。然后，与两个编码器交互的 Transformer 解码器生成最终翻译 Y，即：</p>
<p><img src="https://i.loli.net/2021/06/06/qFu6TDtBbhQOXnf.png" alt="image-20210606102328094" style="zoom: 33%;"></p>
<p>基于源语言编码器隐藏层状态和软模板编码器隐藏层状态，目标语言 Transformer 解码器使用编码器-解码器多头注意共同使用源语言和模板信息来生成最终翻译 Y。此外，目标序列解码器使用两组注意力机制参数用于不同的编码器。解码器分别使用源语句上下文 X=(x1, …, xm)和目标模板上下文 T=(t1, …, tn)，然后我们的模型通过关注源上下文和模板上下文获得两个隐藏状态,在这里，我们使用门控单元融合了包含源语言信息的隐藏层状态和包含模板信息的隐藏层状态，如下所示：</p>
<p><img src="https://i.loli.net/2021/06/06/2omSktuZxNEUYeC.png" alt="image-20210606111455578" style="zoom:50%;"></p>
<p><img src="https://i.loli.net/2021/06/06/F4RvzfdciHe3Jr8.png" alt="image-20210606111502794" style="zoom:50%;"></p>
<p>与常规 NMT 相似，为了使模型能够预测目标序列，我们使用最大似然估计来更新模型参数。当我们在不使用模板 Transformer 编码器的情况下训练 P(Y|X) 时，我们仅需要优化以下损失函数:</p>
<p><img src="https://i.loli.net/2021/06/06/BZDHSQC19LhXlOA.png" alt="image-20210606120505997" style="zoom:50%;"></p>
<p>我们使用模板 Transformer 编码器训练 P(Y|X,T) 时，损失函数可以通过以下公式计算：</p>
<p><img src="https://i.loli.net/2021/06/06/kvnLlAHoF42XbcG.png" alt="image-20210606120523147" style="zoom:50%;"></p>
<p>在实践中，我们发现优化这两个目标可以使得模型更易于训练避免收到模板中噪声的干扰，并获得较高的 BLEU 分数，因为存在一些影响翻译质量的低质量模板。<strong>通过同时优化两个目标，我们可以减少某些低质量模板的影响并提高模型的稳定性。</strong>为了平衡这两个目标，我们的模型在两个目标上同时进行了迭代训练，如下所示：</p>
<p><img src="https://i.loli.net/2021/06/06/BrkEVRDWHZen41L.png" alt="image-20210606120604504" style="zoom:50%;"></p>
<h2 id="实验与分析"><a href="#实验与分析" class="headerlink" title="实验与分析"></a>实验与分析</h2><p>为了证明该方法的有效性，我们在多个数据集和多个语种进行了实验，包括 IWSLT14 德语-英语翻译任务，WMT14 英语-德语翻译任务，LDC 中英翻译任务和 ASPEC 日中翻译任务。实验表明，与基线模型相比，我们的方法取得了更好的结果，这表明软目标模板可以有效地指导翻译过程并提供积极的影响。同时我们的方法可用于不同规模、不同语种、不同领域的数据集。</p>
<p><img src="https://i.loli.net/2021/06/06/EfX8xaJeFYLzpDb.png" alt="image-20210606120732113" style="zoom:50%;"></p>
<p><em>表1：LDC 中英翻译任务结果</em></p>
<p><img src="https://i.loli.net/2021/06/06/19RGWj5xsK7HzXV.png" alt="image-20210606120755429" style="zoom: 50%;"></p>
<p><em>表2：WMT14 英语-德语翻译任务结果</em></p>
<p><img src="https://i.loli.net/2021/06/06/2HjICRYAgV9db5L.png" alt="image-20210606120824797" style="zoom:50%;"></p>
<p><em>表3：IWSLT14 德语-英语翻译任务结果</em></p>
<p><img src="https://i.loli.net/2021/06/06/e4hJ8gaKn3xmXwz.png" alt="image-20210606120844581" style="zoom:50%;"></p>
<p><em>表4：ASPEC 日中翻译任务结果</em></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这项工作中，我们提出了一种利用源文本和软模板生成翻译的机器翻译模型。我们的方法可以从子树中提取模板，该子树是从语法分析树的特定深度得到的。然后，我们使用 Transformer 模型来预测源文本的软目标模板。进一步，我们结合了源文本和模板信息来指导翻译过程。我们将软模板神经机器翻译模型（ST-NMT）与其他基线模型在多个数据集上进行比较。实验结果表明，ST-NMT 可以显著提高翻译性能。</p>
<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><ul>
<li>其实也可以构造成 hard target, 强硬使其输出为对应的span</li>
<li>但是如果这样的话，soft target 是作为辅助信息，影响力 (&gt;=0)。如果使用强硬的，则影响力可能为&lt;0</li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Improving Image Captioning with Conditional Generative Adversarial Nets</title>
    <url>/2020/07/31/Improving-Image-Captioning-with-Conditional-Generative-Adversarial-Nets/</url>
    <content><![CDATA[<p>From:  <a href="https://zhuanlan.zhihu.com/p/39890390" target="_blank" rel="noopener">GAN in Image Captioning</a></p>
<h3 id="Improving-Image-Captioning-with-Conditional-Generative-Adversarial-Nets"><a href="#Improving-Image-Captioning-with-Conditional-Generative-Adversarial-Nets" class="headerlink" title="Improving Image Captioning with Conditional Generative Adversarial Nets"></a><strong>Improving Image Captioning with Conditional Generative Adversarial Nets</strong></h3><h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><p>本文提出了一种新的基于条件生成对抗网络的图像字幕框架，作为传统的基于增强学习(RL)的编解码结构的扩展。为了应对不同的目标语言的指标之间不一致的评价问题，，论文设计了两种鉴别器网络来自动地、逐步地确定生成的描述是人工描述的还是机器生成的。</p>
<p>生成器是采用传统图像描述的模型，<strong>在强化学习自我批判算法（SCST）下进行优化</strong>。</p>
<p>由于基于CNN和RNN的结构各有其优点，因此引入了两种鉴别器结构。</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gha02tza7dj31im0hvtk0.jpg"></p>
<h4 id="CNN-discriminator："><a href="#CNN-discriminator：" class="headerlink" title="CNN discriminator："></a><strong>CNN discriminator：</strong></h4><p>（1）首先创建了一个feature map,编码了图像与句子特征。</p>
<p>（2）接着采用了m组有不同窗大小，核数目的卷积核来获取不同的特征，</p>
<p>（3）然后把所有特征作max pooling操作再联结在一起，并用一个highway架构提升性能。</p>
<p>（4）最后激活特征通过全连接层与sigmoid 转换来获得决策器的输出。输出在[0,1]之间。</p>
<h4 id="RNN-discriminator："><a href="#RNN-discriminator：" class="headerlink" title="RNN discriminator："></a><strong>RNN discriminator：</strong></h4><p>基于RNN的决策器采用了一种标准的LSTM架构，把图像特征输入到第一个LSTM，接下来输入的LSTM是输入是单词编码信息。最后通过全连接层与softmax层获得RNN决策器的输出。</p>
<h4 id="固定G，更新D："><a href="#固定G，更新D：" class="headerlink" title="固定G，更新D："></a>固定G，更新D：</h4><p>Discriminator的目标函数为：</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gha04mt3u7j31m4070tal.jpg"></p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gha02tyrdqj31j50kxdv1.jpg"></p>
<h4 id="固定D，更新G"><a href="#固定D，更新G" class="headerlink" title="固定D，更新G"></a>固定D，更新G</h4><p>设计reward，以强化学习来更新generator。</p>
<p>在强化学习的设定下，本文采用GAN与RL结合的reward来权衡<strong style="color:red;">图像描述的保真度</strong>（在评价标准下获得高得分）与<strong style="color:red;">自然性</strong>（生成描述符合人类的风格）。</p>
<blockquote>
<p><strong style="color:blue;">这也是本文主要的创新点，结合 保真度 的评价</strong></p>
</blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gha06jgm6tj31e409cmz3.jpg" style="zoom: 50%;"></p>
<h4 id="整个算法的伪代码如下："><a href="#整个算法的伪代码如下：" class="headerlink" title="整个算法的伪代码如下："></a>整个算法的伪代码如下：</h4><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gha09ceqgkj30ns0wg13f.jpg" style="zoom: 50%;"></p>
<h3 id="GAN-image-captioning-task"><a href="#GAN-image-captioning-task" class="headerlink" title="GAN + image captioning task"></a>GAN + image captioning task</h3><p><strong>[1703.06029] Towards Diverse and Natural Image Descriptions via a Conditional GAN</strong></p>
<p><strong>[1703.10476] Speaking the Same Language Matching Machine to Human Captions by Adversarial Training</strong></p>
<p><strong>[1705.00930] Show, Adapt and Tell Adversarial Training of Cross-domain Image Captioner</strong></p>
<p><strong>[1805.00063] Improved Image Captioning with Adversarial Semantic Alignment</strong></p>
<p><strong>[1804.00861] Generating Diverse and Accurate Visual Captions by Comparative Adversarial Learning</strong></p>
]]></content>
      <categories>
        <category>图像描述</category>
        <category>GAN</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>Improving Image Captioning Evaluation by Considering Inter References Variance</title>
    <url>/2020/07/26/Improving-Image-Captioning-Evaluation-by-Considering-Inter-References-Variance/</url>
    <content><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><ul>
<li><p>one-to-one metrics的方法存在缺陷：without considering the intrinsic variance between ground truth captions.  </p>
<p>bertscore 是最新的one-to-one metric， 可以实现与human很好的相关性，但是如果一些问题可以解决的话，可以能够进一步的提升性能。</p>
<p>本文则基于 bertscore，提出了一个新方法。</p>
</li>
</ul>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><ul>
<li><p><strong>当前的评价指标</strong>—over penalize：对于M个reference，metric 通过one-to-one 的方式得到M个得分，通过 pooling 操作，得到最终得分。<br>但是不同的reference caption关注到image的不同方面，因此会存在 variance。所以基于 pooling 的操作，太过简单。</p>
<p>如果度量标准仅查看一个参考字幕，那么为这种过度惩罚而寻找补救措施是一项挑战。</p>
</li>
<li><p><strong>bertscore</strong>—under penalize</p>
<p>由于在计算 bertscore 时，采用了贪婪搜索的方式，而且对于每个reference word, pick 一个最大值，这里有可能 没有candidate word 与 reference word相匹配，却给了一个高分。因此，导致 under-penalize</p>
</li>
<li><p><strong>分析</strong>： In one-to-one evaluation，尽管很难直接考虑所有reference，但可以使用来自预训练语言模型的上下文嵌入将references 合并为单个reference。</p>
</li>
</ul>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><ul>
<li><p>3.1  Preliminary concept of references<br>combination  </p>
</li>
<li><p>3.2 Mismatch detection with overlap and<br>cosine similarity  </p>
</li>
<li>3.3 The combination of references  </li>
<li>3.4 Importance of different words</li>
<li>3.5 Summary and metric formula   </li>
</ul>
]]></content>
      <categories>
        <category>图像描述</category>
        <category>评价指标</category>
      </categories>
      <tags>
        <tag>评价指标</tag>
      </tags>
  </entry>
  <entry>
    <title>Instructions</title>
    <url>/2020/06/20/Instructions/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
U2FsdGVkX19J/b9NQjaaydw7vadZf7kK9sYaum92CPhZts6m4cG4dClbEw+m0hkqtJA+FoNAffAGme+ez3SJL3j7+mAnZhDXeJO+56tf9lmiaw6alR4suKyR5G1whSDLEeVmGZrTSX3zUmeANjYJvVrznC+3D6321N7/Z23fQ0TaYD2RyfUlYAJbYYZdmvlKjUUZZcwTsxXO1ioClCUln3Pnv+ztNTe9njJoRFXy83NoJLngSdJDpgOYIXVEBsTuZxGh8HgM4v43J4AqUkuFnp+ixL6VxZ34N+ldbpCsH8OkCRk6pX+QV90Oh4kc8lblPgyISdSGV0JGvQLMVoWHW6LZKk3bWSMC3yEuFajSfuznxJZcyJ6FnOgwuFhIWCeHPrip1Chdq5tcJoNFrrivbDslhGRIYE9GKMbDm+2FY3AVuIHgqxnnTsp8F65CDTQNr60wPLYCqiFU1bO+U9y7gbfAEXVTL7hISHhbUGmDYZwx6pJxR9ihbJ8uoAepTGAZhGE4oMOxPRhzJ6qFYTyt/Va+Nz6C5PUg2EQ9S2ZjNwipxPcY94f6dJjGSe7rxqsIaRUqFjF5ny+IOqV9oNiyFfbfpkBa6CUWFurl6VkR3CTeLC3BKW7zJygaZP57sGh0Jq5vr8P2sV5Tvj7ENdAdmWunwbK4xqRpoBPGmIXCQqyZQwhbWlCXx2CE8fFg7j+fX8StLvWFu8b0bQDPyJ6xdk8UbP2LaB5BkG6JJf2qJqZQmle3a37vxDpqUFr3c3Wr9Tmgp+riy8uawalDEXSWDf5dXQE5ypJ81zo8YigxPnJZFFrnxRiqmXrblJoAoTtBcYuIJdGYQSlHPT06UAxyMgWTVnK1xGWlbmV3OsERqaw2s7twkv+i94dhKXI39b96QWH0A5UyuiaDTj4b+0bI6RcIRfvSgfKZ8yT9Vcl0+stDHbw86ZSqtayEGRPhOQfhbPUcSrsqnNB4bcKh9nfnPKNSDcvgEQWHkBViBnA/vZN2MtF/lmkIgJJqI0qxdlglRZYEn878WFG6Iis0zxFlO0IxIy75xplY8y9aQuVuMfoJdahhEd5rm8J5LqJi2zpY+bdQB/eKy+tNpx5J3/1nuR5zT0R8Xn+8ampfP3OOx7IbjzvVHlyRRmdaCqaG2E2+VcQUd04DE4k7EGEWLyi5evpaGqFIFLSw6zN4js7wkl/8JPX8gVWCkMpY3fHzc0yr+9T7VpDkmn/tAYc5sXzV9474ySf+CABYfe1xmUntJv7Hna07U/PJZxQlRIlEQlAgjn/qSEKjpC3SKCAepFHIUm4vfF0n3Zforcsd+ImgJ0ENQZm6ImHrRyXOjacwjw8M16zPPHR3A3lXyG+0L4VLG7mWe97624PbtVJFMw84iUGf5ev6l0VpsNErhB69pUGP38cio3nuL5NPaEYM8OJ3LhqPW10zLYX+EEiVTx2ENH1DkoPQF7J2Pd6eckbsRjL6xWYl/IStBKy+kpJnPdhwXId8jeLSHa2XBHTS5l7/YPwCCkHSBz7hRqfnmlG7Vkzh/IBFSfyr8m8h10Ski7jYk1j/ccf1ZOVB6xKWHzJlTBIPG73pWUMaHGkBY7+bE10OCx2cUpCMBrORsrbRpGrRfpMqK1JA7VmhzmrdRkTvlKsg1GQ4o8TmuKPRWalIUPFgZVo2wAbpPF4tBu6N1Dva3CF/vOP3f8gM0RfwJ23knv/9jTHieUZiDSeVKiqVzpbcFiG4qqLmPQ4oyvtmiSBDZOn0sZtEeIS+/XmNEt4JF5HP5NXj/+cd7b0iB3VRf3dzy+oDmAKv4WB+irYAmuR65dtPhWuIH752W4zOYsYkIeVYk6EHo3aVFABz7+ZDwZwk8Yy3SInjLsdd92IF8cKFpYRKwEHMd+jIqXp3xxTeFCxPYZc0y7iLk9W6jE01ZkGu3pR1pfGuNCtIoQv1KaeJcCnN5mMpN/F0cz2uQuoXJqiAL8GfOrXXrYyryUzTq4sFNCU8Cj1iTlEvbGNvFNTs3UrqPqt7Nd3u8P2IKjuIKKcyLHvcGLlp69HUpJJEWqZj37zrWKUin0Sb2eWYpDnAFkPv7SHqpAVyiU41LHh7k5bmFPUJVur4DfeA9Q/HLmKGJfuvaa0Tk/2DOge4zeiktkMie5X9nLZz3gJ5wnTza0IfaMtk6zT2U8VNYksYFk9au5j7rAIMtXYAcZ9e9GEMSoRQnpz368TGolG4JFSlfis9QauzR/giFb3kdyrDf+2z37JhAGvJr+Fbxr4od9qAyEocQgHjTG/BTDmZLyinqJ1LRiB3LZ5xVIMDwqWIJHbbdlqeYe+xqU0ybhpvlbf5fJo9/AL42CDBQs1N8PlFSIyhl6RnaCsKlNyebLextaeua03sVZObuiPus8kHQJ5scI4vQ1goiF9FXOp8CEVyNridZxFp92gbainYjobAPauj8cD7jGUyg9mzxs1PCgzcCXDVof6vC5lA9v3l/OHH5FVf4bRaQLBahxd+7aBCD+ZmcQHVfQubUZXTsVRDuTLV7QhDi9IPSxMo5iyYAtRMm9FIygFNLQBcQm9Dlq+5WqBl36VhyDRiTCdyM7DFW2WH2otkaW2nT9OzpiC7Gez9fTQL8aveNVxIgz5zRhSYTSp2Zs1m6rD/jQJIYEVf+RX69kvh42CCVOR4es9Ugxoz1ZQR4ueF/9KTkHAEnDL7R8xdEyoXFl27y1ZiyrAfLxHQ8EY4LdsXhQFwF4GGVwAkC8kUvS79audVo0kSRCDVChRVA3I4PK+UqTyNNp3lYrYsyAnLqHOkpvIGb1s30EZSwBIkAeaiiRWkrT68O0EzrrQ8iw+5zLobMVmXZLjx66LOpP9Q42b5CtvJBOo6jCPM5F5pZQgLXnjY+tV4WvV2dt8R0gIPFvk7vRWRq0dDf1vlDAYLHgX0KQ+s/GpcAoz9if65xZxG9rYMpeWkK9lOUQulc8l88nxJnX4rn+9UXoNsXx/ww9JG6aqBmENRkwfJzViJyNZ027BWWt2wXytYZBbxWT6X0Jf3EinY04iPFkxN4GuBR6ajVQNavVVhAbGlZByOK6z7fOyO8bmUuz30DAQqjLk5VW5+3mNrgeWCWZkP6vrFfR1GgJI8tFLErW3ToRKhCzKW3RYEggDfjGAtNrQYxeekV/foghAWcR/fP4ExePh9CSa5LKqr2JGynBuUJnCzMD4kIie3qjWiiRYanm7sEzMDsd7+jGqosYO8yFKBdYt1ibffa1abBZnt3/i+ea8bHBXHQyj1IjhWUff+9uogiWpWOBV8mo2YOTUrKl5nxNUyaZyZ2A2SC+QZhGrTSqj/2vyFAai5PdBA4eLTYNpBIEb/aICNw/Cy7eXqWHbdz/M1dDV2mvMdi6R7/SahtOM2U/thzPGsJNXZGusxPoOc0v6Nd5g2epmNLC8WEmG3aGJdD6wi8bSQS9mUi5JXChEOABMbE5203XQ4yAxT8kmVR9V1nOeG50KbJQlQjQJ2qH09G13N9505g7atRDHBJNTmLwe9rei2Rkn9RAEKy/jdbaWzfxYqq9KZxFh9innNnlpMEt3HNsplpVLEzJvN9krt2SLvySLsNyE4Xu9RvWQPbAyJgPfsm2wrYVx4f559hV7HQoIwhLzvrKGUfOcdQcr+e1qRKk7LdFlNM6ASySGjtamdcVbYfGmftJeKeDtWYlokcd0pBTVN8ATV8sDyQQVyyqGOC44WwewlMpjzTK+zOavWdofRz4ubZ6g1JA7tV3nsg/m8fSHia+LkaBIZupp+ViHodgybUPbqYB8qDesP7AV58zYqec784i1jMqP1CD1iGUV9ht7y0jHJwWk+n/5AtqZcuqq900Jv+WhRVkFZD7YNQhuNDqR8iyFppCNVRuszn6R7VBqqBJeLH9wsyVLunQnn5IEvV9ETA6tgm3Ys8aQkMEzuXSAZ7ran+5RH8USjlytZTzmDeD6jwnMcZcBaP9H7pZpNFUvNJZ+bwf5OudpvHr3vB0V2k0QFNDXz/StEGUgfvPpMxA4tnkDglt2empxcPQCz7N4s8MM2DvusjOwCbY0V2NSZqwkawipZzD8TzcqrFG+msC5TuaFJ8XStiD8ksG5+CGRaSScr/ZusyF3MWjBX9JEVf8QRnNWkro611kNcJVFst2sIIAOQz4jDC68kI/yQY7JdAwBpv7CFwr4NNtKRW83M0YrkdZ5RwIYhkZz+sfqES6yTyg+ZSqWylryyXCWmtCvDH2j0K9X5l3zJOI5iYicFjGPRIqKyOr9AWo2rra0g4z8jx2+v6Kf0Rp5G0u/fvTDxbJCZOlQL5CvhAWqU4mXSBf8hDvTvLKwja05FLfyfJg+L5+avGoy8i7/pGpoPSAhFFv0xnYGPc6yQGIof+1hOyn7d7/LEy/BYFs+yN84MiMFNvcE/tskKyGBBO9PjVhg0c4/MneVC8uE6wGDvhbuZ2wpYM3B28rWwP7qCqafWTa4/6snE2U0R56YjBAeO1423gfiqtpuUR6pdZODHASLZmBBQ14yFdLuUECWpEuvPKN+QFJH1QJDMiPk5p40cB+X+QZmmUFt+jYsfx4KBPhua1cWPkcLUZQbFo1o9TEU+FbzekT/5NK2V7dY25ytYFtHv01XZlt22vnSq1ZTz4VbXOCFVZNu2BeKsV0NlheYUcfeFreMHveoxXf3G7TUg5QJWR4+3v7mJLnaDMHrk+uhEU6UpIpqDriJuwcBXhRC3HEW4u4YsB1YOtrQ6KcZSzMIiDeQJNH40JWYEv0uOppWAkP4jqcNlrKEjmct2kxNziouwKFgbTkiqeZVdrpr50tUAQZ9E+QINWvlriWtdAiVAL3Dg4mOVwkFF+a3/INjJvHE8kwXE2qSoEmVq5H5fPhMfCcUXrcY69TrtltJohThKg7+se9tqf1/Z4AzH01PqbT0hMhDe3q+cxjhCzKBlVAYAEgEhJPbbU3nJ+YbUiHw6XWQ2n+5/2r7DPJUSh6HTp2t7Mu2GPlKdNTaC4cjon6DxBriuEIyOPGwdhy8eY1umm9WDjno9GB/zkv4EvYdFwaZlUsZZoNJbnG/1mt/i1TmUj8XwXh8g4Weag5cUe3Lx5DpgWuLzTNqmgtTygUeZofw2dnWiNvNvEUASrUaZwum+TqFfzOmm/Ypf9n/nrM39NTNh2jm9T5QVskKL5Unnv0hAOpCF4geOLyqe0qupAcUe9n352mmbVRCzkiisiawhexpi3DSBBW8eDel9PLat0wQ7b9Cnx8FQH3hCQjqltD0Z+LNWJWVWfz319IruNjUwmVLlHGv/6cebGvCd7mK6yXPwhHe4XZ4U63iNHFyAMe5AK8EGu8vPsCIMB08BmH4Yk5kEod+7CF+qte7FfppLk4hZ6/RII+9Dh2Qo2mMJ88cLb60iNRi7bLCwqUfDQtWAV3s83XPESNVKK8PTzIPZvCnBguW2UgMOH+QlBKa7XGzVYNvMoV98K7gpibaqx3NioAS5KrWC6cubqEBYBF0uX+DlE1MJlcid8FzQnBeK1VwsMd1/A3M5g6zkioURb9z3wxDCQJq+MvYYmo5vsV9L56zJelCqKPRmHGHUDthH/ZVtWbkVe0IcSMizGFHiagKNWdbRSi2c9BL+nYfJxBizR8GNTv21gL7JE7Vs9S/RXCQwmDW5Wx4QJNj5OtQMLydtUsxHWLycw74szuFKwS+sbbhPpNw+fHYhud06CZpxgqrVzA3BoyBVpbt56TRXPKRB2pZOoharUAYGT5G3YbGC9GtsSo5s1uvH1aOwQMkDBZh3ND2K4yaGR8ulvZUmgtk7L94lsr0shxCeoM7sgpMhDju90zRveC6CQVI1fp3RQOERqImS5pyPZ8bomG+eaC2TRy9GQitvquKG3fgv9WwsysVoQNEovHDyhHjf6asqKJMIpMjq7KU4/ysOTIz/KvAXxcfU7fW9T34fW7iWZ/odLpWOHnWFesi15pdefioDNjCwXZyGzB+oVweChd56nBRGZuNMyUIjuNlvWP2Cf9f0KUSuOBdAkPQ8/EhgI7qwfxi1EmJgyybplHxzo/vA/NbZwnEVQMpQPtboI1XdM4BEDfxJz1z0CdBslD9fLOHCLVjTvNRWy1wztvK+CP93fb4b55bIWbPXsLX7vIwObqPcVMRGI5PqKVQyLDWw/f4ixCENF7pnuFjatZD/pzANheX9G2/8v4QWQ1TmNyVP0hWPviyr+V55N/xlm5x0A69q8LO+0AMH/4ZaQaEsXL0xaLD09VD1JbQg/wiQ/yTd1EIJ2I1h/SyFTUbr/S0WYwfMjWjvWZt5hwbws8tQtq6EG0EvdUvSlZXcLJyEk9Hx2CA8evFsdeBAo/LfBh8DGKaNPYShtQg76PzSg3ZnbFPeVDJOXL8kxRL6g5zYlwlf6MjtbzPdtx+x3+jv9HGUWYq7zszHXiUNDn7sf0CamH/y9vBaF7yGeYLZyErg9QBhsYo3hBs9jEvT7HOKAu6YSFl8RBR5t8vlWjJhHkDvz/HWHER5YV0EqkLIkpcFkBaPnSKyJwzR48AZeAI2EPFm5gYw9nQB4H6jGZa5/8meczqbzbfD29R9ek7W5Wf9BqPRt0kKJbfYNrJzsusxk3Um7btJdx3rVcsGfEssCdB6pnIAGmnWUPazZnulls8eTKoUZlCfoAgR1l4AkRQxWsbZZk3ob2kz3+qiwiNguvrgcTdVQBP93GOlXR8EaHiZ/7LQYaL0nT4FnzZQCLYxNtiajpCxjfczxZqaC+KJoJtULFnObd0AEeTC5fYZTZZA5qEIh+7Zi2vV6SFtq1/NvnsTCP2VccImyyD6dbHyKk8ISX+RlxOBXi/1w0OSThCyA0AXGC4s96o6irpRl/VNS81Q194vpubuCNQlY9jX1ZpkfWPo68uL11ZsOOwTDTcip/RWEKMxAwuLl87YahKe2mtkCqR4AhHjgVog9h6JRwVkK2CQ/WNgeORQblUwrFMV3N/NLyLckVJMYLsCuFY3ut3d8OEju3AbVIe65Zm7E3rh9FEY/irhX8ZRNeem29swVEVYWkr/tmPDokfv5eRYofOU9pcdLZiNLJskoOi9Zy9s4f16/8owrCC+B4ZnmKdw+1+HZNDOkvVXE9WhI2aV7ZcSqxlExz9IHQvoy+OEpUybRY0iV1Tzq5dWFHN2ioC12TU/30EQAGviAxlhINuuMXjkn8JoSBxmzqjzS9wpD4XNwBCyhs2kCVioIl4l9ltN1qnbr5N4QR+/jEpx5j3vgBd9+d3CrgPxfm09G2IAK7mRH26XITiFvpGiBPcbiSx/edK0HtlaZQnn2aMsQ6RDgnSFLHyQ+Qk97j5LoneZ7dfBA+vqAKLt5qp3jEqMX1PRBQTGu0InDeqLjVnDuuGPbmXuWLhFjL2IolRgQa4HknJt4nzUViVS59805/K9p+BuCNObeswQJeKJQ4JivmW/aoWFf+62E8npoDv0SGZJMu/6GaUY2ilxsBfdvnW4PqkXzvam2u6QMduuPwuayy1KNRekHWYdW3xwAvTxM0Of1hJZmHX6FpH8J3bcUyBTteBRQhHJU/jnc8r8UfqjGtr03C5hkDnoMuD7UbkesPdfIiql5KnZ39Ygyb9bSV0eT8QLRSLx87V1fp+f3DhALMPa7cfCchM7rptdEixa9GWNnT58AomRt2lZHQddP07RgULT1KfsFtsXBxpOPsbIvgeE5fO+27UW00YRVYcELMSMCHn63K9gUYKZAW7TZ0FRAf+aXW8yWABdH9tOC3ekP144KPKaGpqjOLzEOkcwV0A0QY1mZr9cm/HXIlXOHyw7acWbQwPN8ecMo88XZyC+KTX/9NglJl4sBPbszkX/72NzdsS1x3w8rmtEjPItOaoCFbhw/igJtLqXKn1igB8N4yBzIqVYD9CyYUCJy32w80yyts3oCddFzQIajHfDW6AdMgvi5J6Wb17VZb8/ljWyt1xw9eFC+QdPWA8YV2RhJUsN4spaXhT6mBf7eRmQtcAH5hU16E5zeXTEzOwKMIsXp2JSOzoaYO7FSaZgSaA4SqAnd2kSxDrJYLDJPojIpNgmwtT0dJSpwQjRkRrEur4Ywn4MFeXqifPQFRa8Fx9TiohLx8YFFkSiNt2eAtAF4QsfTuTyXgLEH1Brm//KaXaZPZ5OHA5qF74tiPOy+QgCm2H6RuLLMBir8x3ckCXlLP336xHDmLAuqntg2AnMf2hCxbbN0W4UvA5i+t9xtF7DJlwkvXT+xLtK83kBURMbUus1KoaY33ibZkui2I1nyE8xNKAMVlFr1ABPTJ/gI51+pNo1mwG2hHW+R0wqAbxPzdPGYJ6Di4tsYWD6Y/J2PlNGs4gFaMGtsfJJtwx+a118GASHtRrP1/hpLb6VbomIUAyG7LwxuN8YM1289nWoxGb8sDCDk7pkGn7QZieb9CS9eG6pWR/cwljRlUjaUC2qg3AUxZuvsxy/DUhJaeeL4qSkIhuZ/ioJKHFMx0nk/1qjBBKjzpJDkG58h4cM9k3qs4LiukMhmv+hzplc2PX77N2fknWbF+vKQccEoIT/D3m85hSCY6W68ecEJgowEcF5pqNS04+nKQa+O1kz51MmdEEAvYPjZxTZthIjIO+7t7i0HTW7PBWXs7e4DXHJ4Q+IZLCzNJpmE6X+F/ChO7YA4mrCb41uZuNnGD2i8vTAeKxnCc0ncK/cgtWEG2yQmlo6bha03bsC9ygUrIpFMPuBsrl7U9Igr7y2TSyf9B4XQKxHWmSYlB5ZkEzTp6D6e5lM3pjt3c6OyEXI+kmD66X6gm9I2x2nMxZ3UTFtJl+Mkr6ZqAo4wgJPsHd71CiihPs1HkuarOcDC3bPceUCocTnbNAV/QQumepFipu/RHdKPmlEJrbrmSI1eFELUh40l8WKQbtXVc75IfQMZdmqTcvYfKZLZedx6nZ2p7FXTvIoyUn3t/4kJpNTyO5JW1eFy8B58kMV2KJtFgFOjLNyKOWORK0skRH1Qh4n8a8QKdNMFXo0M18Z88pS0EhxybewvxLTMRCEzdm0ncw/x60kjl5Trcybw5maFvv7QPuiZKBzBM7nMn+7dZRBcvORjvYVV9ij9Yu12MoEGHaCXMrYgyho4o66YRIsbxCBNjbCj1QUt1bJsJA+JzITbu0X2b1mCejpHKRNnhxHgBr3jmW9qenydMyKrwF/4t5RMIF0RywbX4Urh8g9aiwwK0P/UpOAgfws3aANABJHur5XfdFlJw+vSp0V2QL8UL38M7a1dTXtzu7EQ8wgZITF+vdR0k9eUyhxhEfJTrAwlKkaorduZdpEwRyn+glG6C+QSy2ysTx6LmqPE4BjFxyHfWGVk282TshUz043oiUQD8UoDRQ3ZicOI9lYCbAWK+MksLYe5uzdttcM4omsFQdyUN4ow7JOzVxiVHLfVo1f1pmY9LLty0xRjQR81vEUi5so9zckiGAeh2bo6po01Ap2zLzNbG7eF3RKIFXJUQU1n6ghVjLJdO0HSlIGhjbpdOt8Vqcvy8q/Hu84tWymLAh/dpI5F9+l+gTGSkYs0+uhyR2RzzkAzPmjo5oHqchm3ZzTxmcnoB659LwFHQ9lZnkJ+GEXiTqFdYrjgMogXXsa9t7HbR4TpCBC0gP5fmP3n7mTUgowcOgS/BoV8hdyccIhyzKeUt3PxNcPoVmRCBV6fR29oIvW7xEQx8pfdIfWc2A7VG8p2cPbRlTLZ5ngmTckbsY0cj35F1h9JGMP5INmHRgH/Q/QoYJ20CrB3QmJb/hl/wiBZPLe3viZ3CClAwYKQpAHELAClTUiUatStCSGpj1HAl97uiyKLvJ2fEKhKlcEJGsBOJaNl/bbKHCsJHrziKtw56ozALuzk9kilQJhgB6g1oAMwr54WEnrU8r4qB9CVxnjl6jSE3/WalAv6FnUkaPXR+ZJ+dnWLsW38Ert5RFJj5CwZIoyeZK6nBgAfKKuzW0n5g35/THBDfgEDAel7HB166cXr9FM2mrPxk4LtI8IO8pOBw+AYufkna2fplyuV+iXzEQvyQCSlp1z7Tj95TsRCpD35b8YDBMRSrKOd79llP5sA66l8j/uSCbAhi14ka847m38VFCkKTVUcUxopCADorcsWQfK1R2cb74K/FNpERTmuVB8SJHIEmnuJCTIbeE55wvAqcCGhMlbfQNqfLmJsRel7Hlqifk0nbRx00MBdJ713CDBEYOu/21yFMRAUUv/R5CaNEcpQ5XDck2VXLFxzDNJvVEREvEWAgSl11ly8YESTyGFbAZJlk+iqtc1HkTdR0xBHXmxmqU1usYq6tFsgg40RpaOKZ7KfVzentCZYE/rqJIOJHlOOKsBwccAEBJg4v58ruIqmAdjOw0lRxM1Pn6jmq8WtcUkp5AzfHa5/At0i4FBSoJCWhcb84VSA84GKDVId3QH7izskVuLgVXy0bQkK9YaMbUmKE2ZeaVntHDTbZOcluvMwgd+F94UfEYEeMZH8AaY0XryeN+lZ3MTVkiZdJg3ZvLQ0TZGTrQUd4NTdGibNZfaMLq5Qr+Kg80iSwhPUyk4VBUToMZqkT5H26shwU/ZIOBAxVt3zVImpfGA/uFG8lXQaac/fo3IbKFiaYBb/zsF+LALca/BqvGzUEzOfJ4ThRMROZhjbxTvCPeBipRFhuZGrhmg0YI3lUbx7BQdctmMYfNPZEUfrYkl92R5ui9wGVqH+qRKa2l+vruuabqTOWE6RzwddpQQQ6AqkMZCen9qx8YV/EmND3RNPHbP3KDkKbielO/pRGoiEAJTOU/h2AZ+i8uSDyr1wGEIX+Ji8Gme0ywymhCh3afIjfyqaewS3pw5mcGdvX076RoJUqfZsAI34ux3i68R9HIvRFivVQ6w5Qwpy/QtJi61tp4ataT0XJSsH0DK6QQkk9VNc/wxBY+0Ux/2Nx17gRTBfw3XgP2Ggh+EVQ9caqV/9ddntMNWTo76kxBwZY2S/diS9bYSIDSvPfHzRZcAcZ4M4XLu+/898K8+Pc59OTmeZBmkS+RleQEEfejYBMPlISxzT5sDQ/BDexVx0XSbWQr0R8CjgFeUtGTQEAy+2ipu6ou8KvzUh3jnONboPSq7G/bGJvsYPvvnL37vGAegoRnjfZCDO1pLOHwcjY6SJ/qQsp2B4U+jUjivioQyJoDKP9WKXftHsxU44ySYG5TaMowEiWQ9Hi203acoy79/+KFL+emmkb44zUzoUDsMQKCwOqG78iE/V1C+EwOQz1u1N7Hu6IU25WCmyIiPNFjOY87iKQVBPoHe79R18gD49mSVb79HPxsQqcJKXgTTiNA3O74heexaIpjiZ5eGRnEX6/ysu5i8jQ4VA2WUdhSlOkK1rVMghnQyYObxktInm/AARc2zpas6EVbfknI5h2I4Ok6xcCdGHpvxafsK7FgW1afsAv3N/KEGgEXrudzZDSg9zv8BczoWfv+y4h3xXOQnA/fnQt1jVIKAMsNHcQbKe/WKykjkdTqEtvULPDGYmanfxSi7tAq72bN2b5KFidQQhvTqU22LoqQCKjAxCin1un6bkZ97DKKvpwFVoS8eta/A0lEFp46+GfJQZYej9ZVqFWuWo0Rg0h5rOYQMfGGtgQUXUeZB1VMXpLtmTXhW1XutVHadTVQcO7lc1IHgSGWxLVpcU+0ghfI9TGqp8vqpUdpxDW75uJ/MQUhBveSw0ZxfFqTVlxMQ7fXl9ewjAMHCQLLtsZG7gIB6xY3jPTNPCegFs/aumugFepuZFUHFQd2LpusAgFivo63f09Hep6DenC1O+zoLQJ9BQm80L+b2krL4ekhsGHhcMMJG/0Ffs8/8+b21NfLs5kK9lTj0hvdem1rgjhQVCu8bnhfkuSabHov8iDBPZwA3XTnMKmGc0io9PIj4oIhPuRws3q9fmF4rH+2qb8cKeoR78SW0W3JXbcigTk1t7nGdwpQaWITsxpC8a/063p+mtbNlkhHBIz9au5Y0GNQ+jqXYV6DFZm84JFmFoYW55yV3/pI77tg+ZamtLj66v8dBNMhMMoPMey33B0MoEz3No3K1LMi3AW0dSeYHvrz/pjgNw/GC6URW+XAs3hxeQc2bPn8xYVJhCZ05NE+v3Z8+tRRBAihcn9tnGl58rZ9322su1Yy5eBcfvgsqKxE0rzlFbX1bnn2H58DrBO09JKowAw+OZ3B2LhMNoSj8ner+7nZ2TRY3DXEMv2V3jN+UVFF50V1B5A9YuHAE/1cBkFWto2QzfTJIcmkMbNJbA7S9sDxwG99U6AFsFWsQOl/AAV+p+8H8eDstUovdYc3/3ZblCbTSf5pzvfx5+H9xh79PyuliPix1wtqbLPgVI9UhtYFZM4bEhA663A6FHrUkRH85+nfIwlmwMZMn+ZQB0E34uoLPsSrM4lYm3LEGdrVYU+f/yE4qybBVCVMwJUnFHO09MQAzSSilVEMOj46hiB3EZenSHYtWTJBaXZ+tCs4tRCj8DwQud7oD+34VTS6rB56z7+J12mxK79g5gO3r+66vz5dtii2StVjpgrBMkRNlzCtlQe3g3nKOVJsq26ErVOrvjeHgnJH17Gf+l10TM51z69UKf4FarvZVDmbKskTWOCFFpiKp0HfRXyXvuk9prYexhhF8NUAobqDntZaFvdvqLZWZkG9c0Zr8GCN9a6bkJ6mQvMmyDeBCUhOViVtr+x9U9+KSeVQttZEJdnsbCkWvN+dvWjC53EA/JbBIluD1L7KtM/9870c6tfiMr6+dGVupQBZOB3aLvxo2nrcOtxansfgWy9QnG6e2Sbl91qSld9UTKEJcyocH2gPKdGbcrsSFRAHMXcxQPj1m4Ge+54yGBD7JaowWshB5OoBz06WmhITUoSu7dQyaINqoGuBqQQEgME8pYpVzn2Omd6m055oABaO9xjFu2c+EdGJq+Cnvfj2K+6UQFimsOlT9WK+BxIvuf3EDtlA1BxOObVcQz/gPgL4lNFgqtRJc+Ke3yRF8kBGRi0i2Lv77WodL++goYG3j17xlyRE3RCTIJFMf70ntjhSgBvN1Kd4cXaF66Cyqs6sLZoGzzbzNT701XWjw965nJLiADV+bfk3Id7j4MTYqgJZRQrUDhG8DhM/9kTGr4iq0WTYAjUaywxSaM2D3VRPI9PC4Qc0rdtpLQxWOWznjb4BjrBVxz+o5ygBAqZqkGt0O+q9lzcBWy4NJ/4wa9kQ4Y5EYyJVaFD38ZgYTMSh6ZTSYeoDkgNok6yI9LEg7IgRwgeRwzEHWxI1MJj+TglljQXv0R7EX7AIaTxaFeDVmResuDzMx+ge+yT9oIIus+Z11Vwc/cBWttSWMZX3kHDvSkVRyXM1G1GdglIFxUv+pZOEEHeIqANGlZ0dbazgcQ08kC4RM8VrEsz6xIhW1H5RnnIr6sSpomHU9Fj3KZonPGA3ZGwL0+DjxRmEQyQluXiM8HwsEMqYlIfwYAnDZcqOXgbTy08Ilx5RdVFi6rM3+k8meYU+yzU7LksBzxDSVl4eHzRZ+8dLORWuHwXJ5Z60f3aewYloZ+4t3zt14Tbn1r8rPxR9bRuu+ILpYZiDoc6pgfkJ5C4GQ7HfuQRF5+VlbftcwOo20fid9+QNe2i7yHRVEoFLFhOQXYlsSwMJKWHmD5hXKPuPEwH2bZKUBjgurllXENGeEZhFBPxOhtRg1FWr+PXa2VgmWSvdYPaEh/vFdKgYeP21HWrVwWss/xCz++tRC0funa3zGZFjci0wYGtPdcWk0CLOKFJaVBvwbfmW9BGIBPldMBC1tSf4M25VTz60lMlEjUuOnlVLFi2Z+4f+WaBOwGVM/4qsVJku1WWXFGpaXLZdgjXF4VMINEj32BPqndYHNJJ/pfcJKPEMT//SZFX4vM9cY81ekOWPeillthbvwYNagWZJOwUz5bGmFOWHHf/kMo7gQRYZODkzmvyA+SwMvgaIBj+/d6Smnks+6wzYGngyGXcWF/X/5UQO0XXPGO0isM0ojRDzKa6i+L45PeShqvernEbfyX8105lIIcezKdNk5ritXHSz0CkVQ5pbDYECGv8LNowtC+22ej4aZ6qecWlHMeLN6PO9vXXNJV6bZ/dYoqTnGkQXfciegUf8kLcTjEOWQiVvaVbWqzBi/t0Hzt//WPGK4jk7lGsLjdl9z+329fiYfK8LHkePp3WZFUDs4zuS2FEVCwZanhXAa0FPo8rLUXz4rlLF803ZoMa5GnGeXr5FZC/RBBAAPlHldx3kKb+EilBf/nsar1R3vodGJ3TpgSgXnhnk3oF6vpgjO4rkjGNxCMdNMv9cr0FWOFGFg9uoutJo8VRQ6k4FCse8Wr/hDyzVYwBgzmiWhzPU214htIb6MjKyQ3RB4CV5y4oifJhboKWFKubAJrcoiRYdOnPxnpUCxcKf4v2dKLqzopnDSZl6t2Ca6gG5yaa2NW3eEnK02bTo+zO11t5ddAFkcjmkVya8UVK6i5UxfYhwFQ82Box420QgBKqbhAm8NY3hCCCEQEZVNk8WGPaYPrYb/sflyN8m2Y/R/ATVN+cmSKc+FT2GW7yBf60xYA2DoGi204fVxao+uObvlgOCmSgkSeZ8jQAbgbeYvnbrEQ/MmoP/L31gz447LBtbGsNZhAYVUcKJw/mtIcWq6azzv5GoJorKDOqKfvPWuczHe1gBnTuomjXa0oDyz7gKQy/FuOZtYk1dRcUMRGA2QQinfqmh9ktx+sjEuLIugm3zAf5JCaGzD345MKVFm+e8NnJdJfsNtMCf5vyNHGwdO/QyOVsZyGFMeMoqm4jwPlKMSci04VyphKsTMg5A9+5YuIs/e1Yyt7KjSzpSmsWB96IfIeEI2n7TsEWVBnAPZpL8dufAzWytilIyidLqveUJd3vgqHjf6uXvlqtiiwr1w/agRX0qbn9WPGxAA1X52gkjyXli2MS6jtRGMl++2hDRb407Uba9bAppANdgHRcqzz31oZEOane7LkRPzkn0yaDJt91UuHDX2u0uXtgN7EkAeK9JmBcTb9JHPMKTSLBN2PQmJIr076/O5hVaQpZvNsUpa9qhjaWG3cZzqgMuHGHK2NNo3ozj3GI7B8ASe3OOag9FSTreEKjolnZzDwqL2izuaPcC4S/zGY4QqZczSORXoOpJZurnBehwjuMCKwjsD/NWOv8Rul90P18kTl6Nswj1CFaJZJkKRSJdXGrZ4b70iH2ugzUpF3WlKORzSURq5noH9z9RokCuA2pYVa8YNJKLw9wsUNX0jW4iOs/zJM7kc8jzx2ROeU+XzKPS9FU2fI+aS8ndxw2UbjbRe8z1GB7RuCpLCLXEf07SJjP/3T2MEnGkVX0yKDHU3ARgNRxZnZJSPeVePQaswN85qbRbrcWKw8jWbn2GtAEv9/ftNEyL3/Rku/kE8/igirng9Xv0jbz3fGd+YNAel6OjE9b4T4TI06LeWI5ogyKAzY9M15zVPWOodvV9mWmHk/vgA+A2nTSD18D0BUY/UuDAEQqua0j0Uk4BZ4tPpv10GsfdlxwFwZLybZRaSHbAMhr9tJY2GwhA0fL1Zm1f9thzNQafYFZaTJEanMeAtTM6f7Mtf5/ttXzPFOTWA+mDJBusXdvtusq7M4HB0Okd2qRf1FG7lm8K24+DSNLJbTmB8Iu3vIGBgcXNj+K0VpmjfgiuR0dbZbbCoQu/yacMirWTltSbNm7P/vr9yiOHvnSVeM8ICZqybI1i+dumhKqNWe3wZyiUH6XQKnjpPUcVfUhCh1dK4UZSwKg5rp3L8Anah3OiJucqJr+W16srZc/JKHA7KMkaAgqlqHIH+rH1xtBUSnc58xSm+Ljbo19xqUuDC+qximu2AhNnbig1aurvu39LoCrzNqiFRZCGw/XcmL9jcwxhqOQvhBsS0imY6lMLvUhyT3CibMXOSEFPoXdPgbFSdyQZQ3cG089n6B99cUmtIJX8/MfQK8FldH39hEuFnYhqHUjS8eu16OxiSpKbIoZ9h0ad7MGSSFXzGQmIPv0n/3ohhO73dJscZaU1edKx739x9usbJjyTvDHUQ+/F1LMbTLiC7vGyKjJibhwXd2wwaKZ2/hPmH1r+ssmv9KeNXUeUxZ4/HTeaeAANfaHZWpPQ2omMbIju2b3SECGpY/NRhq0zgLVuTf86qBmXl7jvLpWpa37bgekVgegvjRp847H0DZDQhHjbVSHadqUAQGMXnrd/5q9nYY+k1U+hHv322ASzeHEwsCABCA0TrQcgU0rHLJIXNUZBg7dqS84I7pe6weB9zW7fGhWrgLunRNbwJ/3viYqi+K79jWF01J+hHXHTj0vTzx39QxkYwH4yhpJFfO3c4fzHiO2eJknE6fmxrYWFvuIFGT7s7SjpwA2fkDdHPeU4dxr+h9tMt3qPN09nXxfivFeZmeopj/8CjoGDh8NaceQj77q4+Hru4BjyFwgTchPXGX+/PGxZ6jc+9cgXt7Yq/3XMgveWhsx57EMV+IhsNmKKV0mzLjpw+LTGv6ZUi09tlm5sqIt8Yo0/cE+mfb2xMSDK/FGdoT/jOycgBCcdR+bek0UaE709QUZJCANEj6eW6ptqBYqo/tcJ37NxGEe4RHpMPBdeYppRjt4NKj5mJCrMVlk/+LPTCBLWasfgfbJ49Ks0aI5T9DeqALnq7xN2lai7meXh5fysexW1gBmyoHbpRGEqo+tJnxe+pSWEXHfXDEL9pMwTxHPx2DsU/WUl2fd+GLmEBNLl67YLAtFdbk3EJ/pMUI30KRF0jU3R8SnOR0NroQmMROonnIi3JBgS3zj6BP8U+GJL2yE/PjuvCOI3/8iYurSZx6JtfVN3Z6sWyBfVyBBpj9iTLwhKGoJxEtO+utAej5+hH6+XS9YskeFtt8E1WzgAXq8FHaygVcJgjFCLMaa+YYoebASSWGYw0A4k8eOrDkdESaEZituripSvXrcR0KSX/nYXGKhhADvHEb9cauhZhSJjgzXC9rz0fkExv69SjqT0/aaKcndOPgwCm40wbOX/3NiSVfAJ0WHu1T2XqLRhyS94aFh/jNTC0GOvu4WDfHDed2nEvQbfXSZnOsbuzMAFoQgtxxNOZC0TFUNQPbyyNPUSEgJEnPMAQOP9dXnFaNGJq9lBrkY5luUe2qkns+BcVww+i8P1898wAaRKbuj5IWsBRKio4Zced2epYO/N9I/dFIs1dWPrU71qbXHUUHlTtWn3qQ8Z1Y5NCeGZwwJiJPGukUZb2Eg5pukdRPVCWz2iePbMvcvjEjAqh1zUMtTFKrVbrtBCzm4awItpUPyTUqd8oKmW6OldG7daD4o3Mx5clfnW0YH9SqNT7kqn8ZqeRUWovgcYoi+j6MNg5SGyYaoiKYIC50G99QZC/wwSY3lshCYjyle5caSV/QaZgzLFee4TxaJeoqG3JTP8xKm2bu5GBN/KNxFXbcqmrWpfpYyK5a4NofUd1pCPQ0gr4go8ypW7/4ukv4ijMVwWTETFnnJpkSMJ3sLSCvKc9stbDinWONSenqHp81rQ8HQ/l38noU/7jx78ET1r8Lb9iLoC6rL6jrMzqC+6okTPWKXMtx1dSf8XhiqjdE2+P70VxefJJKYQiqgURc1+4nixW7OvQ8frc779ZPZlSNAh/hYFW+/9njOxPtWc4E087h+fDt5x3dLuU4ZMbEmiZzl8pl1Ewdltmx+BxTDArh71Ma70yzNipczYypGDGFYAO10J2RnBPXlRgUZmfTrMX3yZNGXh9i7yM7vLiGkl3yTXYrkv9OspihYylOah+nAaQkMmtUzMX2mPqxSUsiTYUzbubHJWrRZ80bmblRbtWjDnmIcLjFFJXyQeptxIQ00Q70udn2G9xSrJG+X6c82/bjVzxw5KBkLfSSfY4rPxUnRnRItEgJW/RlO6zRUJaSgIoqs/bfiPgdqR+vjttOAmHQcRPsTXPJ5hDZM9Hy/0OSU9ww+r7ppyVCRjHtDJn/g3QN4F80TKJ1+AHN6lyu+ZzJ9byG6Up2hZoiRWlwa636RRbGjPu0zvYAcEXRSckNKyyby959EA/bGDsxPSwLbQi0Bi9S4qPLuW3zwbrehswqmv8HLBHIubToWbyrvzUjkifkwAByIYaYJ6i2KQb0UI1nhyq8F0yjcsj14M+i9W4Pk3tkI02L1UKyVbocgAXRT3hubofQ5IegKZ6jhvvuQrvwd93oA2AN54s/pP8eziQbcKmrrWyDOprtXzBRkiA1qhQ00O/KZ8Ut31VyT8qe9FkaRZSoKilgGnJZyocH4HjKwFGVpHR0YhBSue1D2WcuxXrHeVCKmeRQ1RygYc8v6zgGlGFgHG//VNBZbr5yItEi/TWEHlX+3mzGLvosAC/G21Bofssgpq1CKoFSFP2MQ95ba0/jsd8uK8soS0cYBpp1WUiecyy4s4NIRnyzn6VQGEaTwr3WnhaHHnYjCdSbOqrvpu0ajMDBrPmghGb1q39+AiaEFLtSEG1xHEICgsVUZCDeUXTmF9bGR8O1SvAX9rJmtNFc0nJprlKcR7R/irf2fJA8ZFfccwSweh7oWbIfeUY9Gd7O9umTw3+01TDfu9NMU1U/MgSVx3OdgsGJWT3gbUT8DqUbIGMyH03tWdp1+cQazsOBOud6kEbjRJzlnorgpdMjNTJgxEJPYlnYPiYU0FxYMo88jo5e3CVFPBGCNFarHTvvW5ESUZJ2IvH6UgUbksAbgIR+/Yxx8KTeogz9JYq/OpSc5xgCzQPHZsikmy3AjFpc599gIQM37Dzx9mwB/pCu6xU5P1p+bxuDh9XA0cj58gv/oW8BTsk4281JE780mwZoS0SVdxbHLnHk8ATURc67TdYJb+sEYivdnDJvYmPkXTZFGH9PjY4+eoHFVSB2iknUfh6SeafoDgbYYALPAXEStQU1TvVfajdKIqoCsLsWfCbJklI132dTyZNN3IPjcqSCYoulM8mjB3UE2lg/RRgNlynn+EtC3vy9uglycBMuPY3+uVo/L0CGUqhAc1OBCdOmvIzwO3D5cjrS8rD8KCmxDRTBV7FoIBwTv7Lf4PWIq1TC81i3VheDUiZ3aeXYOPb34UKcRfmSPzjzzNkLXeKWkAyoGWG3E1vVm6k3ASMRttVm8Fiyip4aNyQrWNy6oBx/uFhB7HAUc1Fid5rHVo+hYKazdHUm3iIPENs+Oc5NUy6jJdw5Jqn0Jm0HRvOJEuCW/v6siIfvtKBcCOfdggpqsb74b0yOZEO9plE+SgzkxZ7Z4lIrW6oOh2gn2DkMoKg0thmViUE1HNl3Zq3IXjyMf7Gq90hGSU1/OBsqdzgPSUkXi7ZzgAPVh1vpEjc+6f95bESz95hDIlOfngB6PmNwm/M1RCo6KAAAgqHqhE9Fj7er8BF+lKXfVb7LXkqQPLSU2w7kLZWE5HvjjRkmNcfBvski0SZPD/v2ABsozOtCMP6nffKSKEL592DkhuxhatloCHtUMZ7Vxc6ttMGM1nqB+goY+47diJJpid+SZwHv+emtGK5WEWoyCSRtA6YrpIijyyDHMVgGil2tpkxjk8T8O3Ru+eGau1r8ae5/nLNpTKX2+BDUZJs473esL7A1IpCItWjR7jsFUgZSpKGIj5+NiTpozftNoY/+cU1YNEiscfbS1ttJoTXupbHfaySmMhCErfL9EsgQO+sPHjgLK3LmhSvWv+qZTiahM5rZuemfgyKK0PzO1ytgVqdYQC1Aa6GgxiYAAFVPwrRcf2tRCvXh7Ul0p3QZspzNdycWzUR16e4ByB8LXwXuQxSR31tcsdGGPmKArv2AO2mRJXls8HpXvAFyOSPPWY6PbwJmDAoakzlV2pP/RQfXgitNTF32iHMIIQllHqNasF8cfuWMylsawhBZa8QDVCC3xLNruKrwOBezGpqbcpxlT3EmDKlQ0MOJvJE+OST06IPZw+Fvc2qnJxq/8gc0kLrw75WOxRheWmQJu1nfqCLPvrWUJvELztn8olxoQDRtspuNcq5x2HJgfyeO1XQDKZXoUd0sXzkB8KDX6jteeKeiDXesoafGnxhKzVh2NXKO8xbcrDCTiXy94AfkKQFkTAB1MrfDbOKRdFkLi/K9Iw39yj+LVSwkCypSoyWpT28lgxFcGj03wlkYtXFGI5mCUUoss+WXe+iHJhzDgP4Htnqm+2cr6j0C1fxJ6kHgZYJ8A6PDXpRc8ejzSlvYc83XtiBEzlEnjWafZvQTUxgnnhw4pRgxkiM1l95xK+XrtbLvkmt4xg8i8l8oL06NxctIHd4yE/rulaWZik4q8jIjil9TiaJY27U9aLN7ljNUVwNuOblm7Vb0/QcUoeWC4GzkB5dclpXMRdye92KK1v0TQdMiaIEaUwdlpujo69Sy/tTNlse6Xu3tFOwaHZJH68lo8wOl9HNw86vH/taNW5LfrH8lvJzVeAj5Zqrs2OtuIwCXjbyw4kcZC+PEesKb/gYUZjsSnK3Ot7e3vjsYX5ZArfN8p9OSwAruSC2Q2jr26KeSSeh6e2G7qhNN6EnkQYT5hdLZ6so0omlHF3r+o9Kd22mbNGCVlIAaaXGn0rHikhZ9QltTeg03gY/NjXykGwoh84ASMCiauzdQoi89100b5tSchtKJFjZq/2b2t3rTL4JaWFBCPm1inMSNlvAEJao9bQvTUWuyBXcxXWMZfrbHy4yN4ixHJ3IMPHhwTJX/Rk8o+Pgsjr17kI4f83Ve2lJj5EJUtSE1tDv70vQsZ04IRKarnG7LVIHNqy/OsxmVCZqeAiA3xzXKmIgSI55bwe0lzSWIzz9LPIspwbw7qPIwIAxrX61drAihHkoRb+daFQxylEzWzODZH1kMiTlf4OCLkKvx2739OoOj8MBw8zMVBvfGfpiNFbXXrTz7K3qEOKP0zbSe5jKSuXn5dwXMnKMORyeTViwyz7yo/ygBarl5hMu3aq/SZL0SwfYdIwspK6AgsGviMRZzNugnNQ6MVk34kvzw/U+Qnj7HzxS/mEOne2D7GzbHL4QthELL40bfDBwRL18+02ssmNOmO7UcUtGmjBvUOqmgtXTcFe0Xkn2aT6TdtAIcDORhFUJzCu7y+ee2qGrpw8kKnMrSPDeAKi7rQDBDxlmKs/7klvbG4i/0eunudBR7FGUKg/awQWVAToDoTQ+409plE7C/L6d+YwXemEI7yKXMzoAtohny8e733RajoTJZfdQ4x5HTocHosqmPdGlXtCUw304w7lCxTHupipk7glAOUdg1mG2loiZV92MBSCRsR9f4YASHeX7ASjGf1O14eOe4XpUx3+6ARL1wPYtsgYGiDhv6b72Q4YxYWniatlAHL5ItLVJQ3bLWrwguiUqjifD2dW6F0oS6o31RkUmtFg/PcFNQaYiYLRPxXyBeKvHacBkGQuqEmXQuN4ubPf+nSbFYy41YE9VYKpgVeuEOzytCzVcsMoCODLTqVW954fQHgTlIq9jNkU5GwqOdDG+DBIfRoSO77CHIOI2Kic0GVCSJBbiLQbF8qxKOz+kVYrcKoBCncwAfVsNyjgnm0BbwIfR8duERnJnlnp+qbWhrkpW2x4uVPnuvMU0d9KQfSA9KVXa3X6YXMePuKdAo5PrVMNp25B0ncAmdNxLZRilUky8pQt4poozeix5XvByg38YEpeZtiHVdVHUxesoxov8L5nseCbhIJZc0kvUSdl6hg2ERwdcaJ5sZ5nylD93F3ugKFKngXe+VA4qjMIRurIwPT9wNXuwAH4dHADiP7VD6O0XtHWbz7cobwMnd4djpd00NR/f++IbSoTyUMshreH94XjhQHwYM6/y8IFuwsoi3lLTZ3LKrB5oM5UA6oDDzbbEcSKPOuy9ZZfMa8NWPXc6pV/dEUHUu6yjvseAabcfsAgRjSRCmlNlubvhH8rJvgYn178KuS4/D47jxgoEFC184Jqd3uBPs166P7WxF/HZLnhTLM/YGvgO8EO4OSmowHbJmiVQpBQG7ZQ1ysWlzZw1lgvuusMEWL924Qe9rc1KqSO28fhIRCikDL+ARCKE5j0sElyRl5wybDMb8Mo9M6m12YxjGzGbbIoCChK97NWERjxeEKkn96JC7f/S6n3d+JecsUm80JqV5rBfNc6/4RKrQ9slRVkwguEoz4SHdqQx7WDzU5J29Ttz11vG/fPYwzYz5QukKZ03A6h1agq1bScG0YhIckULeiw9LFbEXd2wPT/4uKKcqpPAlDXFYz6uZYZq06pE+rJNBHOqYQ9SVX8W1sjlOGPs7aKcQ24pT+E5+PuWJ6KHZr9idKWhIS5z8vD/ZT4PpjaQ6l/ZFfvyjijuH0QKeNp8YIMBkz7oQX7cs0r+I+T4wucrQ27pAuCXPnirMFd60sBRv1yrbWHDe9/tYBS8npCz7caP4onxfAe/GeAYvAQgKQ16huSPZYMv+2ej3WRqI9HbHGu9BT9MR/eJ6Ytp+rFyc8aGRafFxHLU4xzqh6wNfuzR8VMzN6Yjvp7sED7aJg1rEQBkt6GaEq5NbFD2hLFLazzGdz+ojVIwT3FZ5rmqDlXCvdiGeD/VKtVbS+USX+iqikVUp5heAVD8rgooqfZB2qDOZVA7gdNdqnRyVapUCxF4X7oMLT1Ae9YgSxQ7W7xKmYnn6GVwoVaiIjuO/6yShO5Zk6H7vlaNpQbC9H0YwEeVFKTm+sdgJA2xHyCmHg+RCG8xcsdrSVJ/3haiMgJFQDCLYQmfdvp5qtPfUbFgm46MgXFcXJ2rxbTN6zc3i9qchF/+f+aE0tAnu+lCdCfz64iXgMwg2anJPjo3rX1gvL6So72FDzNONwNRdLYJzfleouatzOiGZNh0+fDIcqgJCh8wwvrR9pWWKeFBh1RGytyLRbDu/qyETH+1vtf9A6zMtGj7ZcTlFDKEV9UNYZiF51l6G2hKebsGYy1o7i2kydZy75FhD73Z0KVxCRmOapkd4f+6UgfDPi1dmz8opc9Ol/phGLMgwUcnf05hvnW5FOXaYF9VtHfnruqSTpS0dnKe7us9lHweZh53Fh3gEU21GHMWLuL7p4aAfOINIS0+0ppwyuywmBYrtIA7MnXWkWHp3mp3LDKwUA5OHETCFA9GOtfa2W2u9En7xDWfyrpzvaYmPORK4a9Pg+++hHp02sEZe0p09ErfP6hHa7PjI1OVR9lpVF71KEA5UeiFtT6vRpWai4PeJfxy2AJ7Xw3tvB4+lXhScdMYkpjQlnq1JyPG2YCx3ZQvIXv9R+JBgByLg24JyegW+crgs8PbMhZHiPqpmQRNjf0hMbTthbNQOOv+dME0CGGngCkHdRhFKu8Nop6Zot8S/wuCOUZhWmXz1ymjtL8AzsnvEiPgoB1wXogLZjRV6wyLNJxhm3SoO62Ggt0rPujFRErWX2+BinEEn3Te10/yoR+JmZuVPDu+tLXx41TqqWbKhV6CET8shP6n82/4cPGSjZZO4HSHcgEHdSPA5jeOvYHmfwWccYc6ECjKLpJoBMPbjU07MwmGV4CRjtZw+x0d+yCLB8T+RgChrpBr6+53uM1E7zHlFhyndjAox3LPUgS2qXt4DFRx08vQURsq6pTsm6382qaSni8I9kCc9nPURRVHRFQtMsl2P8P/w1XMjMM0gRd8aWRiegZn6xrGFCw0IroxVCjYhmZWTmKKzYc+MbtIC//iUTwfUjhh7X8ck1w0+ySeERC4I5AGVKIuL6zNFQm0k2lwzvX6bOVTqAC9f8kG0AJTHnTkoAMXIPkYepKJrS4uBvL4z1q/v8sDOUfB3YlvEFQLyCvE23Gx5qXT3QvQHsNm3V/i3uPDaHma1sfjL6fPHMgoMUslEnKIEb6zTNPSmxdYo1OEnO2m6Zjyc+vjBWkGEKJu4kbP0Wo7ff+BM3c+6UJHKG6+I6m7hnXeL0YSHRHpKVnIIsthfdKhOnllRo7ZYqGYfxgNmKnOSfKIuy+kqgGcBa7vboGUNs79gWL35136Pceg73kyZA2nnP6qyRmIne72HaR+pub2slW3h8PfErIRhtwzYvADhiShlpkpYtYk4cicj/TBntyHFl66EuFCctGTxytva9KMxvoI+dZgx3xNUZOPCpVdv17K/76CYlhbMzAjLfL8S0ga/RDVVoZ2DzpCFdv0bKe7+2XuvIltvEpRSvIniUA9qXtVT8tZJyAhOgUzR+P5w5h6SMtQK+fOO45jrUMiJBBhK2ANEpkfkjqX+fqtnj+zAo0g7D9Q80RI9gteesxQ3TsYD+Ra3kuTn9V9CTNsl/gxoEeUFvbH+ww3SD3r8XfC5a4WkLBlatM7oKrLqx89js6sptgNlKlWN7g+Mz8/KN8VfxbdPTCr2eCSPEypZMhtKXMX4m5Lg63xdrWWrscQKliU2ApdqNtAfEPl+nqTmGco7zGUYlBM/ue2Chu3OtHA75NREoGzJD0lrkwzZ50yBj4F/bJpGMHuD31gG8/tHOK0BIGhGYtBUZVpRvcTEHVD7DisZMHohwPE2CdC1DJyDaQaPpyB/M5iebnTS/gclMSs8eKNH+QddWHSzh52b9p68I/oRIsPJvTUdTZX0IVnoq9cfiZTHGeISFzVrX1Yp9jLCJCf5e4i/RTjJQ+uf4MhgowLTCWAfS+0SQ3IdbdzQ0dN5qa0ibQ1MmhjdFfLQo1we62TcnVfhDeDp5zp4iu3agyMJ8SDHG1pFT7I9eR2njQvRK0oD8pihzc4EigWy+94BMf7MN8vU9//z8mrMr8TbHk/uUXBE5mFM3P+31ZZO9AOtEXurFHJ0y5yFXjmrBy5qk1tG8MF+iigUvltkh/mlGPHZJU0VEjYnEl3LMfhmMR2rqynUdE3oOwpL+pzdlRBhyRqhYIfUyTYMy0QrSeqvwj43W7ZBqlQwqW3KXpYvSpL7UFdUkcXTIvWEcE3LNhWnOaFQpG3R2OAt8qYEgygqtYgn1TV0F9yLquXzq/o9wgiHqu+XFg7V1nmK+1JinIT6F5JJOFdTVmyDJtf54qJpzU3VNxyUyt6RWnEl2pKS7R1wq+N9NKSSewMZbbMPc1qEmtTYprAnVmqdv2Ls1UFUxdY2U/8xu3NINjP1rJpBVfyN1nBYEtLV8Y1DGHEZpo+Kgzb36JptFQjUJ+P6Zq3eevHyxHl1VvbBKo8j4AvViMXwgIZKPGs/0mYxuz7b2GXhPM4DyBESpQPb/Fp7841xWWpNEQRmuIhL8Mx+EZrc2ceUQVRZH0cJoN6V7JUUo1+YUv2IcSWqKLr7e+oRcv4DIUQV4STgLTSZRYLFtfvMO9cCc9uNI7YiRw0hEABX2sffjeX+CTeIrcskQ3PquFSvqhqQ2Dg5yG39IRdABWPeoOiV6kLSNrR5duyNm7BVQObZa77n153VpPl/tAf4z1FGKhcFd6UxTKUkdBuCAAzmaccF1LcREsIEXxZ6/iXaqeZKlf9pXxHgQjnQTQIX6jitc8YO+cbuNtr1RosE8E0DRs6Ym73NE8b6LsGogNjZ/Za1grM9a66dQYLkn7g5P8VaDlBOSi8fSVa124cx//Rx+lVh/NMFBoatHiuUEh5xdpw2hGLVELOrMGqVoG6eVf5gxKKHUh/rEUL6jYw50kWTOG5KeDt8Q7JzvPOOIhUW0GoYUaMIV3ZZu+m4fJcSpaZ5LBPqn+eSjQWbQBa0tD+V0OKCixHpa3Vspln9oBpdmrE/T2lfhhyZcbCBJT64tGG8WQrxqr04m+eCLfklLVrMFPhU+8j5iasfzndbCplnacwvQ7jiwrTpzJAUTHsiwMtRtL3XrBGTbQrdeNhFMJ2SpFuqZeMSVOwR3ibePwgOgCmczRxv+L8vPTf770btXVirSh6mIhxAi9ztn3HZMtBSxYio/6N8H8RYKAuPqkO0IFoEuX8R7wv49PCiWXVrXF8nDX2i6g76ihC1Vz3hXY2tMID/Zi1dY3Bidr4npoYCBlXFAdEkDIoWOG9H1gWRa9bfnVSR4Se/kX1i3GtC30xereHZXjEh68MGqoXzs8Ea3GOnjJFaML0iQuo5cMDx/kPKSk4jpUlpdYgdVzMezyELAYLhvxyK6xR8QZGVBTzAYNCFa/qX72IIo72ycGqpTHO3yXyO0U3eoTtIXrca8XW03Js1nSX4FroT9wk85aDOmvAaxUybSsy3k+oRYg1rnUa00Y1noLyW2So4ZKuHknZMgUc++Q6+sq3ATolh9ySQ6U7JUsjFO8NfNQS2u+sW704FBEmi+8Cg+Lw4d3CC3dqtK2MDbjIG2JEtal4cC3wn7skHC1E3m1JyrfongIe+b6Heheey40Gu9ufqj6z/hgg1YhFkMnS1J3gt3BOq2irBHuVPNaGUWHjckEmVotY6lifD4GA6FdCw9bf07wR+HTy83E0cN8mP382OmUCwGT+dx2NlqdHd5qgFFGM8sLVOpXWJ4aGxXHo773AWnTss2p9YtLB9BmZrexasrGODZhUaoUGpJFC5B52DR1d1YcIEcaFXsFwf/g0OoJ9j9BEqUYQpNl6XqBTfViPaI/Xsc/WBMaQ0dK3IDm6aAcnNjyKclq8O5MM3llpLAEAB+jTPu1GGtV2ra0lRq1lCQ+4bRzEKWPSHpwqBHX9YaHWEuO/uytjH+vorMlyW4SWV0MTo/8a6Zcw0BHP7eLeIrkNmR7yQIjlrLWokdZ9z+sDCzqotVl3ihbyEGxbWAbflY1591JKRIwcMIXK/ccoohxNEu/mYB6MHFcEBcGEmcTqy8pz54mOEqt3X1FRPzVlZXjiUYlwCA6HOqRJL+yxEvG1BZtSVQBMuky3V90aiNKA4gXLmKJ5p8TEh14sTriyfKJPNxGTmNjmN8kGH5m/clqk9Ibcds1zIWcUulgf3XgFD1ReOP1mKUjIKYQ1VbtHDRWEKut+w83MuITlyS+6O/FyGzALV1paEeQ4YngtDHsOdCpra+obfQ/zRIMfIjBoDcbj2yFJffkJpsIzK9hVNN8kDoz+g5D185vodFyhfNvnijXMAORvkMplR/b13jwT1iBQpomHHtSXrKvlO648RzMAKe441g304AF/016KDtomexGNbl1X2bLiZA/eWddPfu7PdPHl7qUnAOZMgh64mqLwC4icuEpfycntT/gzHF1OiMyeXLRrzPyPvnW2B8QBqstCAXuZ7UVxOEG3zIDFLYk0xiNFiOAnyELwOvYalTUICukjAurMonj+N9GZysIYTc/yJJXHKDsnflTSLjuOieVeZj4jfAODa5lWOEBdTEQ0+8phrwp5Szu12ghUgwxDNvcz/PCR+xxsddo1MxH7PnYcClKNtNgcbvC2xLjBkFl2b/1mJqf+UXgCPSk+5mWaVUVsP3qshWdDWy2Bp2EI9XKNdpz/Uz+zyYxF16FacaqZW/8dvUgUkDchQG7z2LbWcB+98ueLe6aMAoPI7mln7ySsNNkP9K3OiZVn3pvngPkTy5Y5i1RTwIOQVxLlUhCYxevOIQZad83kRAfHzaZz2wMnrDYUtT3AlZyL4IFc2ITr4Q4c3kzR2a0MWTG9Wi+mlMEL0K/Rmh5Sx/C2zXV73EwPzEiJqzNrzfWkUqyRO4j/srBX5lOEh2bsGRff+fja4LmZkizjuT/oMtcJ7hwfQxEyoq3GbcPpRY0lvSTzMMH02q8Rp4e45lihruv49ULEu7I5/O0v6pzbR/t60h1fDcGTBMFDlK7OwT6PrNR3dRoO/9Nb87wxKHrHu1yHJV2SPIoq4WilQSnVfkTA/T/kYRJKJcU2kV66fRyI4koFE0Ue9nhzwGHWFN5SOStFghRgSE7yv1Jz+vUWlA4E2u7dFUeecp8BCAhN4dDOuVXu8MlLU/zuoKUKZsLtdwkhUIMeMcR6+JqwhOAjeRFCNtLip2UpFfaQ4M6lpsc5DCv/0dKLiVufB3SRFVuL8LqhKE3ABVw39t+wfLJKLP6DlgxWg7V4ElqGlveU1aC5PYu+x0gSTI1fbtKO2rhcuYBglvrOJvUq7GDQkFt3RJpu+hWKY0YTAmq4whtwTWpB16UuG38dHiZiZUX/Txj8hAfWKi+6ttZ4nYuaGQ9cCIRQXqblFvNkF/e/wxX3DvuA54p9bqr4baAf11uUfHC5PAco+dLbKIRLyW96tg9q8adnZnjJcnvyUCqBNhnUViGBNbkiUHzb0oBOpIvPln2wIqPQd+woPoHYnRMPMYiEx6WrD3N3Kgg0ephm5ACC54x6oK2/D6nBB7PbiXkn/YXuRAx2cQ4ORa7IjUSRg4KXkY5mC7PFnmCm2QLlQyMmzCrsa7KuUXC931xCfiOKbYQQr9lDV+lyI76EiRvTgcfASooq+kvs3paeu3uTZ5/SVwZwnlO7VrpqNLxB8q79gvad06CkW2jS9hFzQAl6NFB3Rlj2islTihDCMC3CnSoC1v3hIVfCmkmpahmou2xbDCgr1+KUEXXQspgq2uYVkmfQNk2z6Y8+UvWI1QiPEM3bk9r870Gkv5ScbNcQAOR5/C/mZpNq4jTPvahQkbE0GoYfZjbijyLkEtH/eV8B5562y7LhSGw/Zag9Cx1jDG44hBcDPf+qP4vrFySYvSVlRyB+u0gzQA2V0iv7UADKkKsvcC0bk4ZWuImr3jAjzCFlEhkZ15fZaXRyZ0koOZR09DJnj8FTuYVml+T82KWqgD8D90m+gRn46wfvQQZ5IwviVIcXQ2Y+mwH0yA78VYnl4YwfGbFwBJ9iZwREENJaEBYCJPGO8K2LZvXVkuPs+e2ziF78e76Wmlc4+/Wdo5yszEj8lnK8Sk0C/EWKcF4CxT6ZX39yqhFQr77Ic2Bjhy/qpM4R0aXmPNY58ZmWt/NClg6pxX0+M5XbgpUzOW6D27ED4hooq98Gi+NGsVLNkA8vKfKklkejKGzRrsnMZd2/zmEo9kQQw3d8rrJyCXNqiE3DmHZMlcb6N8NUvTHs4jmQ5/Ljk7dhm6tyODZEVzowXLtow0DlTAMdTB5i/Pr02FwkZEvAS3kXFtsbWe12XVKmSkjQPTsl13g3U2cJCQf7ZcbOvXxJ9NnHvADXmlH8vPRUPMlb5pwogzq+DfUP/8aVVUVOTs+9jBP3kz1FIJfWfheTlzF+xFZiUer7fGtEjTc+dh4tkvztLesl/5zbmmwhZJcK/BMgZ7ChNnTMKnweDBniObia8TkE03nMc8TtHrIjYCTgKao6nLRUS/pLhaCsEtTca/z169U+EnbEEYBuegUPK3N6sf+ct2NjsyuYPxavvS+m7DtHmrfkaE2Emat9PjcCAXP5uG+X6GvG9ZHzkbokCnam/1ybMrORuEbYoruZXoSdZlSe8VaTZq+2ddVEcNDqeXg5NSGQtIF8VY1RzxXzAkcwv+N4kZFVak8B11REmosId64UBGS0U3SlP4v9h7ytYyxPWXT4FWjOUw/y7g5vGYzn2APwf9kc43XByti79MPUi05mUhwPrwriBiKBR41BGICRfMde76YBqGyi1HQWyQt7/HCnby5yr5q2h4gJauVJrAhNaZ1DHoPDADZVdlO9HsZ0v2/Ocfk0g2Serw/GxzC/WROkus195C4GE0TB5Es6RlvGITDtbV90mFkXog5K1jC+ihuuxEPneqyp1jJMKEIrHpOAMdGocQMslnjFwrjLVRX3T8EyAp3MFD6XCBpNT2EUr8ecjuR2M8JESgFHS+qk3lCBZNYfO6DroqcSiejUwMOyLvWObQUe5qvuA0e+H+RBuFSqjl04SC7TYiNYqiVxykTwcLdKJsnf9zBzMrsHQBRSubKj8xwrfPGSC99MIHq9C6lprEnyNpUcoGb5OkXEzoJf6yWM7VZAHpqwP+Meivk7uiLa6SVRohKV0A6CfJLKUerVlRHGnGnyWLcxlBfS06ZBh6SRiqpf4oiVT7hn5xrCwRDeeba084QhMARbR7GDqM+VJXmlYUnEzJw1fjX3N4XK6OUyGbyng+4SidEMxna0oKUaUkcB8ml9picE/2E3Oo0hZlJjx8flrjJ69LdHdzGZDoZsKnEayXSDg/qpRFCF3yzpYXjJo8fNWzk4FqNqqHePKhzlCsJboKwWAX2vdtyBxJBXfVRojh7sfrzthqb8Smu5BLRCUclK1nrwbEiRYEkEVdhm7O3n6fIEd4dfHA8rS/KP7IDQQjAVI33ppO2XjA4TW2dqedwUZPjp8RGFYZiqwrlynivxWF78DBmapkRtZLpRmW4dIzK1zSBfXLVlc15SOT7Tjgjmde/1zZX5CH6Pigf+RbKAi9lPYqTO2DpV+r0kwpliakc9ww7MH8jRhN6WBjGZpItkMbS/rFpA3f7I01C9p/TZlkoL2oOWIVp5DeSxtFaDCTVTVE0oSXSE72d3oTG8Z1vkf1rtiX1KJyII8S9OPjc+Ilqtd32TXw6BeOGEMZn/sg0u1Twe8NgUPME3UbJn5hH4tRo+ZPJH5ePkqjD6feu/CEvEGdRh7YUsdIgg2pzAZrrEtSVXls+QGDfawYLjfWbZZpghpy03iYXfs+PDuGMkoajSyV5G/Ur5PskNHlpeRPcruMAqjEx2CLXKf11KalC8tLK2qip17cmYVRiVyzOEYJAS5U4Oh3roseTbv9xHdX1BKSfsy894yk0r3KrXD/doY+YeTY5ibD2WJPKndPVFtUMjsYKtqdxxY1tRz4YAcAmT2cksDyFGPtcn+y1JJXmub/aI2UjfuJO2GzxBRYv7cDrCglgEzSQBJHLyRnnpJJt/K58rPt14nLompXg8mctluyX1JLBL0tCiwsWr1lof+D7UhryI1VdV/DsFGFy8wy3CgDEkDq7P3DA1uPtknkgq75snW1XAI97RKzGbZWKECUBVua2moDmt1h9fHv+y6oNBzAQQgkFhOqq2rGdCEgrKLXCMg7DUAtu92kYHytzrngdJIole+Ey2lJfpnxQp3Kcl+VErJdj4uMYH5EoSohbqyoYVSnhdNOcCL60UavWmuG9dXg3Qf6gOuK6IMtMlcU4bJ88YAC2CmSiwb9ybi6XbrQiUUTsLs8Lt7Xbm2AZ+5OYZtABP01TWFqACeyAA4oXMxeRGwR2BmIJnkIojEuF2HlKy9/I02KrUpbXwXusqdpo1z1nEPzy7dfh9dtR9UQ79tAkUIYaww1kSEUTzxgclUUuTYu1Uua77Mv0UJRGR1HG5IcJZ80aVMscmfu/okCv1l8nrbGx53xsjP24mPZRPijjgiIkUaNOAuunOWwCU3UANbDB8DheTQByvcBc30rzJ/L/gysWmx8vyYJNpT16tEEpDiqD92hZ4i74ira1Fg1TwCyhZspsGS5ndWTn85NW7i+Y10kOhCqN6x93l8mTnz6Z+8CgG32jme/lMGC0J+C4tmkGo+bU52Ae78Hms8WSOwdTLty/IHhnyTBoSayxJjfMFNltqQLgPKmtaUOhsBGgIcBFIE55jmrFKASG8IwtQouS4OWSMBouJ/rokqAV2aV+7qbrkuJqPiG0M53kFfN1mfViQMrviJopwi7J9MGzXsgEI5xkoVHTeT1RnQ7cCA3MfZsNeSrfPJ40Yvu8UJtyBFkSzzyi3Tzub7rm/OJVUzTXtmF9hY7eyfNHjVVqB/cVnxL7afQ73nHfkasc0PyRxX/piGqNXa6lSaiBAFeUboke84JbmmuU+rP32+L4CKeL/kHPf02Kh8B0mTvucTbZcOcP8D/A5nvb55SqzBF8mtt0G0ozypQHMF9QBnJmPHt8KteJCDKhZabsblyF7pkj3WJTpALJnuOtACIorfkL0t4kYEgIVmpijVhDEiN4DtbQdVhCz2Gjg5jxvQ46sWwBg1k8ZmqGALNwZjgFIH3rLjkeb4fmGXgrDQytUVO8jur7M9jkZK9QT2GXB+bzVVJCHehywxznQxMkoMXJefpgeV4DLKeGPr9hS1HHkuKhUODKxGwguw9BX+q0TKD321qk+FpDfKk2K4aFZpTx+PZfg+II5NnWMW1+JpJx4TpYpffDolfN9yj4NyQngPkJSWf9lrti43OYO6pCeE4+nHrPlfCz06jmpyB54CrMZ5ubsW4DaWrmWOzhqDIP+AKTzF80yluCoBN96qf1ad97359w4ERf9TZDpr1aDwzfCMGJ2a7gTT250yyPdv19nF0BDztnkK35k7ZXX07RLVlhtHvqwuV2zq9cWpBIJtDuY6EMW7DD6K5ny/urE3F0vEvvkTh9n3Nu/F5D91+yiTSfQzPJv1YXuYg3PSfOWp+ioGN1noXWs2RhN4WInV+eEGmgWdPzz27jLaNvxoXudbFfshZKmB/ZGaKpsSSeBBgNdHRrneD/982ZLlPTEtfsHf3FILTxqgXKO7gJDJEPqJl2UUmVsvFnXupPfpCvWc1LdNFi73J9aPXw2wMU/nPe/QuPOdkgWJW+Lto0ytioN9j3EjayNNg1NJwl5bd3Ks9g25RQZfhNiF393wQfIPs0Wfdvw2W9KBt3gYygDDtpVqi9icziB485kgmhve4lHUk8vd/JJkm1AzwF4Qf6xTOF7JQfNo9CHl5zrXBdX7VY1fP7CpBawKy2FwrIto5pfTHEpQfq/6M7C2tJWGwm9Z/DFer+EoorHduyYMVMV+1BpTC701jibDJrFefO4AF27wGgx/PK7d4RVHvoYZsjhkLKFxeYGGPE3RdxCehKfumQD59RyBH2IMjB8EXLjIefOjlgfNB+PG8xKl4+ndkZ/RnBurRc25WwoF1/JVEgyA5ovYeP2ih00EPkWfvVTZ10oExl1L9vmvxym88VcjjmLg47O3yXXRXy3IOIQ/dxbRRsfJjt0bjdkggnIHPPZJfIr4/MRWU3MX/4sj5aT4qm37IcYVSt6seE2jrOp4AaaSybNrZOtyl5BarmD3qmnonGMNCAEuYlVWzSCsnDrPwVNGqsXnuX08iWkFPLOTMBiTL82YH2lbfl5bOFULaTLjMZzAE0iAqS1Z/2pc2jtOOCo9SF3NktFXJHygmUQDQ3yWrdwKw3wXcOFkgNoDmDQX1x2Le6VKL5KVNMCV99VjcMzLTWsfnCXnkhZlN0XCVSZkyza4cKpjZm4f906KaD/EDHvD5h2pSQTXAyoF3pg+SohrOjIa1gId43Qewv8YokXsoV6AQCrG1Ei9xDSEHE7PxNI30UUq4NXPtIbBauLu1BxUQd8du11beSSCj1KaFwLJ7ACrfDOGNIcte3jnqf6WSFpsmFDnnSsl6ymhWtUlAXclC1FCWRdTvJkLaxHdTgfoCcruMJJppWampj0CV4/6o7trAiZ0L7Cmw0SCe7mHJAYIYBwKUC0V+AIS5UHOfakPvf3G6gRJua67PwZQCSfFo2SGA+4x5RWcxJ3IybuexCNB/+o15GCf9WCLEzsug91tF1zsw4z0HxibYD1HI3xFwc3epvImaE75rUxQad8CYf05EhiyS87ixtjnuWioHsDhrMHwi3DmZxwbYHgVLcNcVChGXTl/38rsJBazhYLlBtDVr0OAOdyHpmUy09JbdOb/K3o/qo/WFlfXnMKN7ZEs0A8mPsy2afoWY1k+eYWDx7nZ+yTW/PyDmLfAqRq/Z4/0rpDnHw2HfQXc3PfDBpLaqq1U0zHASWjTeYVqpQH/Yp38OqX+6avWiXAx60A73Iq6pzfuHUlgBnRWls1W/GBecMC9sQkllGGjf4/1CgSbv0LvKVcqWxYU3slWH3Sia/rb4GnfxGgh7yicQYE1BFGtVolN1z2Taed819lCsg3BIcdKg5UT+ukcjM0cavU9bp8tQAhM4E2TAP7FHq74dKu/XqvFrWTMuJjlsCcFhPcLUFf6LHpPZHCayRpiNnmGYqf1oi1dKKKbDw49kXFQJHLddvkcx2aQnGiqupy4AKtra99/36C3dOxsaPxGagtGSq2X+ktIUXZyeRCW9SQYZh3GtooRzYBzW2V1v9xcu3p9TazafagVcy1aF5VRia/pwNz72UH0JDMn2+uOLUkPdwEhV0NOt82jDvz+JKS6Y9HnvpUsrD2+pdLvm730tpraxwqWS7Z54ckHeU8RwlfYLgfhk39N5xHqbdNAm8O09dfFlBZF5wCdon0VTfh5xAJeVm3+Pu9fUPl6KY43J1e76GZ3/oS565TKBCWq+xbx48gQJyZxHdIe5XsLElPqx0wedOBfp2L83c6HV05f+M9h/r9yyGrUH/uJNx1aVa6EYKISyOz0yc8hAljoyNNBzfudKx1sxQR3TPwU5NPoDfo49Pi/XpyRmqWUV/b2v0lI5/QcpfChkUBeqT0x7Nw486BzZxSkgpNlG+aNqwdzvcsVu09bGCbdIEQnn+AE9zX8hWDnqt4En+f5fobPBGbINMJnKFz2izBDBNqKu+HsVRqZN2Z0nJWBvZmB3ozRC1io/XhbVo7sZNMlblqPooBBBelU3dU/RCiAa2FuPesrZtPxhTO04iQPMHHgFvESpJY0Q9S5xh7w4MxXxjZ/Dsyc69OuJ0X7o6ab6YiU9HTWMpWYAWrwf5BsOzc+mWn5kcGDUmevioBtEp1tnq0xqEmDKMxd5AlmLG+WeTDWrX0JrlkSmbn9IZXVv0jfGuC/YTj7q2ir76bXypt0vVmUbxeCv8RmMiUt0oRT2iDJgnbUCEM6QJA/wvfX1DpX58O2jGC4cOjfPD0hgStI2xZrEqqNcj91im5N7bRI2P0fK7qyx3KfxisJPO3jLm5rmIJa22xmHE9GcmVPSxdCmUeRuDm9/WTz0IvpY7h2sO0FmBBbSGoWhuPh5a0DH9D0go/im3NAjPLl5YKp7KZKkujm9NZUWe0cVv7QXxVwMsbv1UfrJESvDigu1i2cDkyI29DFNb+jZCvEWR/tEsWUkFe8CewLuxf5JFu3o422VZmrZgfoRBDPuCHziL6kOunZQbgrbhyGvai/6XlfEwfuSUgjeDUG13jMALaE4XlvGTzUHALZzdXoC2tN8v4l9sUXUJGamM0W7CdDHf3muHABOShDylXPjZQjkK4tCd4fNWSwJy57GZ2QzpV6DwaIw993NViMLUHkywMyLJRzQ/tdopBxQ2smf8LLWWUkdaCEewWDVOutq/pNwFDUI7cQlIRG2y+RJIpzRwEkS39MwFKM2R6dK11zGFHse9grDdWVyGbRqqIQIuWZcka7YWs2gpGg/kUQy2ywj1FRL3ymJm4XqvUrTNcqUZbeBXNdCT4rQnWPCuCIapenBZCzdKzUgNh8bS7VfyVQk/yVMR8jZ1bxAptCRczOcK41oU5lF5hnOa9ukR1ALElR9x96Tjxyti/+U6MNJEyr58uWOujXBY4XrXRmDd0aK9gW/UbPpse+TXwd+eT/L2dqAM3mvbN6dW82aUq+5ioOmVE0qgq1wFYqNNReGPUgu56fQESTEQFP5zDRs1B4jxuOti5ED4vJ4NDkpTD9BiGGeaFEYChJ3kQRuOjfnceuTXexVOqDtkWoFhz+7gnWY83OuoB5V2Nyk+I3yp7QD4i1pt0Vif1aqQw/v2vhSUZWQ7Zu0dbChvCb5+boSLMlWu/NyBxBKblY8+fRqegiepgl7wicb9m/xxYtt07TkOpXTszH3BE8SAMEDlb+k0D59IcD6WkTRrgE1PffU1VX8voK8Nqw+hwMQhNHE96I8XH2fQqiEoUq5pemSEC9HltSRscjoOgEpj4udjDM7Sd1waYYqAVWGNvvLJyPscM/hSNzZbA8FK6V2k0jzPd4nnLZe2ItVj9tkoJwxGDpj0N6kgKoihQLkXFyfhtNg4qosIbnrrEGxb9hqofVzcZss8B9C8aO83m0W+VZ6+gCgaSls4DrnUcqC41H3NSliDOOAMV+qUGVmiP6nnejuJNsfqNtAKKZbMbjjyBLP9QdT666PwXH7KX/ld+7HEVbRDYpdwwbBy934aYJE5mV99EtutuL+bqvVgFR8G8+GQC4EAhJcc1K6+dYPYrPjZObWB2Kxwia8GISRdZ3U6bIUexD2ieNmO9smGfG0/8Oj3icO+TptSLRJTr3uNuBW23Ff1riZqhFVm4STC7Om6bSTMBBwt03IeXyfsHN5iJrFtk7onTWhqkwDd+WzLnF97ihNzvsW4LKFpNsuxCASKYQfyu0GdBlYflDHum55rYdi3IEZBWzKa0DZ493NG90MV74sXx4+HsYBezXnYC7F+S4KCC5iOgW5RPJJpKVVbbFvvRakRqa5+yPFVBDGCHxuKU6MiaO6ThhVVHnVKh4PAdqiloC1HEagDD/R0m/yOAWw9M/b9YY05zc4zMnvQzpVAbMP9V/EDWBmIdetsmlgc+GnjXWSuybCNLBDU5L+ixsdhYBxkV4xaTIXsneqiVSr7WoDQFRHmjtZQO/eBeQrl0lAzMc9Spkk0ym/fZmKSxdOOsyztCwuRY4uRJWoiQDLPuf5LO1G1RR0AR3hgWmkH1KaLAz7BNCTLg9H4wURM5X8ziVmJs8yZWv3Flsoe4cnv0Rfp4T/RD6iYaSWTOGotIG/RizkgogNJHRASoOG9Szg3oewSRyIgnevU/Cbg5w2BHXz/qY+8sqbNcpIErkvJdJYvudL3R3HGZCaVETVmn0REwnVeV5tGjbBgZmafthjrb9tK2qY1eHHb0tQgpfCZrgRLHWHSl9xHUC63k4OOafOeQVN7CUr+1pxm2Fwyt3cbpb4HNAQrn/acnoUOpXoNOsvfsEMTvGrkpDOkcKzj0J4gk+QLh8qwVvD7t+PgUszMjxIJGdous5ShO7Tkbrq5wj9o106BVoK/AcHVJB0w8AniTz6g0jMlIdeBOn9/+ZQ35hhYyR84BSj0haYsqAG09X8vz8Vtv/31xcmdd5DrtBOeNQUnID4Bi5ua7+HA0OU4keu+kUmbfzYMNlxQjpEz6blPIs8z20BjKIzp369tQ8i7Q+4Rkkjm3/wNejrmmjpltpwCuZcgsTdQ9MDuvL0sX85xC3G5sAtjHQJ3bY/xVmLgi1oKAJ8nHakEogB+6SUnqEgpMEdpP34cDC01elJwIJDXste4b+r7FjVHsOQijGT+S/D6fRz68vfkvh6OG070IvsAAfEkmK1uvdU15JFC7fJfS7Q0XRzqars2GpMojwaFzBpdQwBazQ5xzTGwi3I0pz8esBxfuJAmFWYEEEb7uv/wByziVDQYpQ/PLeUQhzzsjag9oQc4fqmAjdY/JzO+mbyVipK7JHDgTFfj6g/y3BBAzeXhznhyyK7ZxbJeLqS+xWb1L1/1/f0BhqBhd3momY5lJcq9HpTgmtaKBYupTMoWGYzoc6XcKlX//KML/7WgK5Ax9Teupf0BJSv7EjuLMZFH6IvBl/dNsvebfhIpJ/qJ9zTRueP6co+GqIMcwScnNmYf1JXQ6/KxF+E398EMFruE9mXzud9pLHtI/f6lJcg5J9yNJhOCyW6AIJpp/GxK5hkq/pMvaQh4NXaKQ0InQ3qAE3KqbUAcjKVx+tMrpTWmf3bGnhdk3uDMGiIhAmSFLzgcLH/vjgB9pd4fDm8do1CQCQ/QvfIRfs3BZ2JN07pvFg81qYNkGkXm1L9hWTbzBM87aN60kCw8iM9cqPdoEjJLPsVwegz+QG5DUuJmIQi/DmJbMNRzs9xZfL8/Ei3AaPt4xSNdfrOZqwvDVupgpBZgR6h4D6mIrrN2LykthXmlIXA4oPkpN2cl9fLzBKV1OLitMtm4z4uEzPIMhElaxq+W8zLMhfzYx+aLusVaQ6FPNxjIs4/PNFO5DX6QGFW/JCN8jijifDBdaoxLYQRlmZ5lNTkOgWYbFo4sWVSVGt+zKjjkTQoR0BxgTnbdhxQPRNFDbVbMflepxckJki3xMgZIwU55kcFL2I8sa1SgV+vf5tZRNXu6bSgqBFNuZP6g2qd7r+8aKw/cmeWFnccw1lzPC4RZQU3xI+AkTVnZkc8uy0S6go0001SW5igrpear7RKI187BK1mdZqBGrEAyZmag2Oo7lcFmAS9HAOzcrmzBLNzDWt9Wt1ZoJ5Prwbp+qVfF/2Os45g7ePXRFcARt5T+s8VUbx7+RRGPiqKo0BnRd/wgv5K5J5PJkClh116hqk+MfAF9v9IQsP1MWlGJarvJwMv1mV2PxfbEOnlULucrJZmb+RRt7jDbcJUMtfMBxg9hC/A2DvNWgkYHhqTSHgM9pixxMuVlrbLYhhRQsGnOhMnOnS+TDelkqNOgWzy/8oNFOOc8EJn8Ca81tpnIL7LS5RaVLj+B7y4/tMof4ZoeZQXKY0uybWiMTT6eJCGkN43w22+bMMz0DZDjLXSHzrjxXgCtjtOUOvjflEVJ+RdTuqEV2vu5oQI3ki9JQcfOx7c9Ie+VVT7je7xXgrKQcFZ4AH8UD4BY7zrFmWJx16YalCFyJgtSCtfUAPeDADucuC4jVGaldJ2jANlwlSooBqzR3BgfxHkd0DnNJYI0k5CG6yPuBXYCXfooW48/FpM2D7/TlU+RosdQoO4MRwjA0Gl6TlkrE4lExFhNm9qvxigp5RCRYDNuA3AuSdS5RMmTaCX6yPbT3LWe1YuhQISlmwtXhaQ2cu2IsFo6bVVMovH5EDg8do/uIcHKJ5TV6jQopcFMfKz/2Wv2ynfQlShVVEaArPTp4LKh0Tir8o26olmAH1JJcN8MmwOThgWzT526Flqe6rM0BfFsYaBA4yASvPiRCquC0zoCoOG65xKaCvfleMKiMOJLOrjbVXPZvx3H4PbfYKxjjeG6tKJx+scC6LTHR6pJTK3i9ZLaDA1+NIgc9tYYBCr5AvckKZWz1jMT9l1G+hVlUOdUhK9zo3AF+rWGkdNVAXZOfpbV6c1M/vCttxgDrL1qoB3yFlRUXqMXg3baGVI6+KrCcWM7BgOvU0n5lZ0kJW3SpYmnfyTHS/ipTmY2WxC9ZLn7AEffUv323QIS1J/HLNxAIqb4flKNpbDA4a9TJ4oJZPIDnsX/vH1Pidk4hKZtvYddwptVruiq3nV1WuIbCwwAcSj29vpSI4ZcrIzE8zlz0eXto+FvenqKc9CPjmA9xWMrccozDOkclY/4fjLM/ocZUo+kCm1s4Cjb2HW30dkIZO7xXdev17hnZEFtMY1w8YMuAmDDkhKlwI/54tZ+TDhlX7qRRXfOa72LsvViUiQ6SeMhujZjpmCa2vb+ZqO7MO+gMxZbOeSJJQXmptrnHckS8nvzlSE2RNhoNr6kgYnQWepZS9tfJCgGMz/MgfpMVK5NPlfkT4aH4yyidRvdhvjR7UK+kUaQN1SgnEIn4LIEpmwRaZIukC0o1g1JNg3+4JazFcpVPRQ7h0iEzJ9A3umbCiB9+FUB5LT6dG4nsDN6avWitujqDwc+agx2yB2GV3FU8SqcOEWUExb0Noby/RyfZTTf4z/d2RkWvj7WLdeK9Tf0VxwAoB5CW4nM5tp5S0tE1jGcjCYnlZ/cUohXmM5mrV7a6EpU9wSjC4SisCiC80crg9eJGxc3VX9p/5upQpGKf9cbH2HAXSxR3kckz11wy53qULVoOoFxq8tUmBq6K/hpEHckm6rkAsYYqgWmCuuYGEdI4tZRrssSv/GIOLZd+d4tdD23dWS1jMMUoUUu+46Y5NiUd8WL+b9JZBtmxmYJIK0qkTyQAnCrYGJbx5jkmckyNX4HPn4MRVa+4FEWTJKWfNT4Qym15AWWhgr4UMc60YrlcQFL6oGbZxL8jwozs0AhGKPXulA/umM0DgJu5cQZTxVPcJEH2fNePyr3oosBD9RuqPWrkoxNHfA90CSs9QulaCpI3ucQ6YMtw7Ir9PIPxx13qfs6rqcCDuv5haXExvMv8/FlQgbZkO4JVG00APhuKWUyuTEjFLbLhcTZPORgeaFAztWSDuQ3gIff8rnctX6KFvkxULnBt45NRkmbuHgo9fAi0Yhi4a+vcPoZwHb02RxFppppWuwoyg4YQAP58c7Ng9gK39F0MbTAZlyxYYBx/Jz7KAukNVAgRG7PT09VyEvt+WJ9duTRiJ4u3eVr+4o+iIr5ksr1e76QYHSdaWR2X5ZNTwz33kJ5Lu83JQe7P6Gyjw0EayZQWxXDcuhL+t1GeJY+OZeesgdvOSJwJPCdj7Vbd8/7hJJ6Q2MDRmzojaG1dsZkvN3xohTIuwMO6KfRzB3cfgZE/1N+1I2W1E96AydUQEGJRvWFGwj/oCopQmjwp27iLaQZhKupgLKzd6b0gUXaICldsg5jIoXfSCFwD6xV7v1tTw+ReQHXFPLQhe3Sxx+YKrA1itPxRo7G5yFo4O5XAe1Mirdqfm0AXU3JkoQ+NQanTvh7BVJ5t+z0TjVzfvOqiwJwgmUC8t/Y1rZJvuLMYjry19F6y7bawDhW/KgqJGAgGKQrLOxH1wKfTXvJota8ki/jmiCaC6iK0E13vPz2F3WpDx1ZJ5kh0TJRbxQjSW1owMdtXsS/1+GVDkysQQt+6dp7ocAR7NFf0WSCuqTf0bkhoM0VKMzG9eTtwbprvAo2d9bcAnxYYYO0bqP8ZhbO+E9LY6Wv4FAUB5Tz5yEhSnFL5xJXJoR1SgQChGd0uOHYmUA3msZ4hFsSRjx3xHMorpkWqe48+HXfkbR58vqpIo9GM8r43rK47Ld6eiJk+zYGGGbctMQJyNP+fzb2jr9lhgUUkm7GXzJBNWzzO5533/LXV03d9EXbNnDpVPL1uIbEQVnc1ST2IIs/o0Vz9csL6DdVVPgcqN5q5wGf407Goqz2r5EgVCIfr61rK9ICR+soVUFWV7PREL2gSDtXsxwuNZxy1XbpN6lhy64R5bbfRKqe+NpoY0UWqu0FLdauensJCWoKQO96aGpn2svwCWVl5J6ZBWEij5M8DgYVB3s45wpKeNawwqFjTUWnn7OceA/o8doyyriJwFkJIbmWnBgyK5C/x7YOl6RN1z3P2HwIw1NkbG5Hz+M0GUyzkIDH5Gy7WYh+bCBKb3Ivo9Rp4wH+OadU9MseGbGVwXHxk5GRFcS68vod+/TH5nSzHlWjEtEuD558TtacOpvZAECQ/zb/XtJ0k1WS93aVgU1CT50Bwp073XXPanr7FSJLKp2eY0rHM1N8M1bd9V8gB1OEuvpeG9kMb/+zCiOW0hR2rY/eNqLfcZmkQUoXkzuWJgVmzM0HGuYT+n0SqIO5g1hR5bolDVTffTV5SAhwSG+ki2rjUnBKOJaceMrzk5ceTHMncmjwS/l3b9UkHRT5KZYsaXdS0FQiuBuDsOjnTolIjqYUqkbchtIgyxYkSm+RJSnPCW8ipJdrt4RQ/iVeNaALvYd1gx+k0j3spifpUN0UUYA1IB+DNAyJ6/V38wpM5LokBVhUU/OefjLXvl0I/3QGHoFmXmTbv6EQDUefqvnka/r2w5E5dDRA2xrZg0CS1WrUQN8743t1/geDe65PqQ/zgsqr0rd4bdqMPKxl9OT7j1OvE76yFmnRG/sTw67JqWgcGOSxkri5HF2Xe57sanD+KibphLjnpykSz0jyiXezmCpMTz4P6LMmHIont7gK6Y3mfOTZGF14OPMIIthZ/Q6E10PPzhtj3yn6g0vVvfbaGBU839fq4yORFqepKUkPYfMQJJcIjc0OzpxtTZYB/UcLLzbTdnkU+v/eo12vk1sOPUzMTgl8w0dhaNuU51EgP6oWRMMVxAMg8ML3PbVWmnp5V2YklBFq7vlkG4AmX2pnWfuB3/bLSdLKpeVZG3MEs2eIb623h5eLS09E1ooSuc32H75sQ5HmtYC8/DwcKhg07ORrb5LJEtogGUefkIMUWJCYrzLcGoNSh9zsW0Wa8Q6KLV5ralIixno/4KmRoecNeN/oAuARz4+gCct84UD/Y88ntrjwJhCu9SfMhKMzynR2xGyZ5TqJNkSYsluyaEYsn0SFDZdVI8QBch0py57qIltLSrxIcrhIck14f+7qY8+z2guX/GF/RSwW5p+jkAM8Ru7BMjIGbLcLiENOrh30CLww+XKtmQ2aW9rIGjAxTPc9jNLvfYqWs2UTnkqhZIeklnm7G3uHViisc+oFodwpN54g/+z0o9r5IpUnr8EtCAnoEAcSfHTYFoWMDGbKhFNlQ6UVYak4q+1rozrcrB+Lu6OS1XlBl2VKkh+wifHYNR/u7Da6eZjvCkYQ/YeNRORJEdrEXmHdPb/ColM0ycIk09qIOVBbg9RLCA/H6q58swh4vm8NW1D8F3Sgre4pY1XAI+Q1jgAO5GPTc2WpkiGMGHZJ8oJis9qrhWk1oUmHwloFbgpdlhob3qDVEGZz2d7aIKS7ZDcfE6snlbuzHRbY97mtdOKijl7XiH1C+LvhG4R0+w5GJ43omlUTnU9cqniIX5Bvi/KpmqR3qxs0uJBHkepN+Kgm+RrkHtAmk313tRyj23yBqWnmi4m18jBrdGmGkk+eF+nW+z8CgDiEAwpSQ7brKlABSejdpXI7nki3aTwHUH7YUm2513Zxu3MKOLd7hW+LK2Hg4pK5IRBwMmsmf5VcC6FjKfamtudTpMQ2DKagnFGKysCu6groSSOINTyTrXNvMCAis4S1TzCFK8afY1qoXDnjNxYvHttEakY0h0tL6F8y4kV1xa3RZET5sM39RJN8oHOa99P4ShawT9smp0LbCrEjIpIir9b4AB/BFbKROeUgrcGDStaAu6WS40aUUdYPkmEC6LyheGfW2JAY0YBNTkNpB0QxpYq6vw5poqjc79VNpECURpHRYoi3kflNuuT4xvE2dIlxwfp3XH+4csH+oGJ7LX7JITsYmwNrSNpShzOQX1A3dxc9ew+KryzV2LK3CXq2Xr4vXjWPb/34Qc7CHXhMUNhMNxK4WX1tLbLpUZbvDSog0+PGmzRdCNjATYc94PSbKTLG9hXyMAw+B+lCBVU9Hp5THoXF+SVedkeXxwXRcThyWo3NHIJbsueF2+49hfUXaeLLUvUZ/EobFjUbQWgif0sf4ERbrFeD7x4EMlWhcRfw6VRYAB+H2nP6CE8iFyb/YiPwntcP0jHMjQtT10ELzFopaLtPPknbN5X2Yvd3z+2b5Bz4AcfgjhUfefOsvEQoUCz6GfOlHhx8A3Or3B/+uy8aILdZGm0qm2zmQT1VysagpFdMjHiEJ/hnoxJXfXAVIFgD/eQoUrSRx9jpiEkNRV+k0U/3OK4z7jpMDVca7tWHXAsZ6g9cthWjhgu6sf1i1MBJO/OzaZnO680zcxbDhquib0ZYItbZf+f98yoN15t/2t7M7ODcqKQmCVIq+PKB0+50kfJoTRPYYE0ljl2U35dz+rgzAUg8m3SuVqvsrSSw7DeLhqy799neNMSlA+REVkSJsBXU6negyrPhYAAwr2z7TrABMokYJIVlN56Yu9KMdkxsnl1yCZzI1t7RDPFJRe/87acUsbWd5xcXa+ohoARVhyx6uRVizFCbHWp5zpv30Hc2Snq+4SJPtfKNlSNwSxh43qcNl9z1fQeXF4NBOlcta0fCDfxkzdw6uC0WDgq6Ri3nDWkLumE8kOoGycx2XBgtyau5OF1rYITPoUHjViSyYjxxONcVcG9gXp0drlDqPhvwwNmJMJtHf3qZRtkQxgHZ/mXrDD8MANO/nWoDjbtuy4daHMa+FKPADvWGlfH63ddLG7+V3eLW7rI7s6SgGy+O9ilLSnqEIKpWYM33TXnRYqash5cnl+9A6BpR9H2zwAPZBDZps8aGqkYTGV1ZbxnSAHH0J5HQE0KglxfGYNkUYv/lpyE8HeFHo4Onf4YWJXUweG1Bp76hrwvVaA6pT6S7cSxeX5fPVGoHWLJLbGfcxc5Mqu7b6qVkihECryM88lVgtgrKaDMIccp5D9wrtiPTf81jf2uqK41V5WLmEqGSXZHxSmr5Z4I5nJuCEIWG3TmlqIZBAMwU1fhwXoGcaVo6+MgUJ8V638ThrnmBV2P5zPro4uxNoGPPpvVe/lcdKHvXcuAwotjL23D5Ap+UE80kvudi6jmWM1687WEcsoJFZ6UNd/crpEsYEXK65fMWxFaJKMPgDlzJ1WbTmRHTONBa7d9Ye+2vTgHzoz9oIDqp8uIfmKvXjV/Qaut8PI9/9rd2UJofWJZic2vIpFi2at8N4fMbPSvFTyLMBRLSt9eUof8fCxhWIJ2HcL3s8NBJj6lG8/MrRRnJ/TWpgwEXDL+7nhT8I/qFMVT4pjEAgpRxitetf+EqvS+YscsGb8aq5Gn0NceD5WNXzyrK/BZ3nt69ljGPLz5AcSzlkeybOfLJtugVtsMWhbnjSOUcaBas5YI7hKThz6DZkLipfEsJZcMO83caKNkqqgW1JEHnXyCc4BKpQu9d78Oq2IS03ubrolGnRwdui2jetYSYq2XnfO7t3wR6WP7mm1s33MhGgA+Vp9Q2MMf3YSlAlh4phnQv9jhVF9vOO83h0iRa1BtqvNYVCY1Sg1rFJscfKl7xgmvqvQioNHGqupfk+b5LxJ+3bgmGQgDZy/8gUFDbY7zTjk3tCvQ8i553y5SfuyxnPIgnxCAQKoeMfa31FeapREX6X40TcjS94/NE17tGGIJa0VStInrudE63/MXWmZKGxbMeWGMlu83li+3qUx6MkIb73QTU/kq+x7yp1nlRsIPGZFPRsvALWgHkYyURcV6uidmuswXUzedZ5+awP6/rIbiQnEY1BJfnfC1wPMtuxIWc64uyA1my6dvP0RPi7nA7VB2k/NV21Prn2JxL8qJEyMiUW0hHqe50HnLd4ceKX6h05TSobo+RmmxhCpAFhdeF7eG6mHs0azuurpr/cnrIUcp36uMd2s0i4/Y7htonClWDyK+jr+c6LY+cql0FvRVhvRfZ1hXawKVeIkDFhdcqmG0n7NnOPIC4Yf6UCu9wC9dun1/JRwhQnI0SSGne8EI/LlcpNb1axGQTqxXtEPlfH0/UcnrrXEauHgd1HElYEqwrTKF3HQlNflSQ2QoaIXDzfiQpQkX0a1VsVWNzZ+7f8uITyLrON9YgWmjcAwahmceSqFCSnpiKZnIWpd/Wgjywehfeczg+QzTV9Jt6Dn87IBjDEsPGzq2UNsK6sVjtx03vtTaiwQMM53J0xXk2309gXLFvle0y/JyYkGHHM8UH/HC1bfxY69xFUsah+Dykpvo8TNN5ZJpU9TzLcR88sc3kvHDZ4LA5FBZlBzr5RGviZuW/AcosE/h8wadEPLBWRTriMIS1xQYIvDRxSeQ+Xm69McGLX3eAQOdMLDcHZ8eAjzdCNahh0kFPy3RCYZ2o1X0jAOXoV73BwhOJWKp4cOaK+DaKNaWsZbDQhsmI9TjKM2lgbOyqnJdeI/56lLnWhwJy2g0PUFE56lm6nC3YLap0ACAlYvTCFlXYEhRVFyJ904+LY4bez3o75DkROir5fJDvRHouMPSYcS7EM5QpgxtHRaWxs3g==
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>Improving Translation Robustness with Visual Cues and Error Correction</title>
    <url>/2021/03/17/Improving-Translation-Robustness-with-Visual-Cues-and-Error-Correction/</url>
    <content><![CDATA[<h2 id="本文研究的任务"><a href="#本文研究的任务" class="headerlink" title="本文研究的任务"></a>本文研究的任务</h2><p>多模态机器翻译任务中对噪声样本的鲁棒性。</p>
<p>神经机器翻译模型对输入噪声很脆弱。当前的鲁棒性技术大多使模型<strong>适应</strong>现有的嘈杂文本，但是这些模型通常在<strong>遇到看不见的噪声</strong>时会失效，并且在clean  text 上的性能会下降（即相比于那些普通的模型，使用噪声样本来扩充数据的模型，其在clean text 上的性能会下降）。</p>
<h2 id="本文提出的点"><a href="#本文提出的点" class="headerlink" title="本文提出的点"></a>本文提出的点</h2><p>（1） 模型上：引入了<strong><em>视觉上下文</em></strong>的概念，以提高针对嘈杂文本的翻译鲁棒性。</p>
<p>（2）多任务：通过<strong>将纠错作为辅助任务</strong>来提出一种新的<strong><em>纠错训练</em>方案</strong>，以进一步提高鲁棒性。</p>
<p>实验证明，在 English-French and English-German 翻译任务上，（1）对于训练中遇到的噪声以及未遇到的噪声都有很好的鲁棒性。（2）同时保持了在 clean text 上的翻译质量。</p>
<h3 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h3><ul>
<li>不是重点来做 MMT model 的，略过</li>
</ul>
]]></content>
      <categories>
        <category>cross-modal</category>
        <category>image-guided MT</category>
      </categories>
      <tags>
        <tag>cross-modal,image-guided MT</tag>
      </tags>
  </entry>
  <entry>
    <title>[It’s Not Just Size That Matters] Small Language Models Are Also Few-Shot Learners</title>
    <url>/2021/03/20/It%E2%80%99s-Not-Just-Size-That-Matters-Small-Language-Models-Are-Also-Few-Shot-Learners/</url>
    <content><![CDATA[<p>转载：<a href="https://www.sohu.com/a/422484297_500659" target="_blank" rel="noopener">https://www.sohu.com/a/422484297_500659</a></p>
<p>显然，这标题对标的就是 GPT-3，于是笔者饶有兴趣地点进去看看是谁这么有勇气挑战 GPT-3，又是怎样的小模型能挑战 GPT-3？经过阅读，原来作者提出通过适当的构造， <strong>用 BERT 的 MLM 模型</strong>也可以做小样本学习，看完之后颇有一种“原来还可以这样做”的恍然大悟感。在此与大家分享一下。</p>
<h2 id="冉冉升起的MLM"><a href="#冉冉升起的MLM" class="headerlink" title="冉冉升起的MLM"></a><strong>冉冉升起的MLM</strong></h2><p>MLM，全称“Masked Language Model”，可以翻译为“掩码语言模型”，实际上就是一个完形填空任务，随机 Mask 掉文本中的某些字词，然后要模型去预测被 Mask 的字词，示意图如下：</p>
<p><img src="https://i.loli.net/2021/03/20/izGapk4S6ZRqgFI.png" alt="img" style="zoom:50%;"></p>
<p>▲ BERT的MLM模型简单示意图</p>
<p>其中被 Mask 掉的部分，可以是直接随机选择的 Token，也可以是随机选择连续的能组成一整个词的 Token，后者称为 WWM（Whole Word Masking）。</p>
<p>开始，MLM 仅被视为 BERT 的一个预训练任务，训练完了就可以扔掉的那种，因此有一些开源的模型干脆没保留 MLM 部分的权重，比如 brightmart 版 [3] 和 clue 版 [4] 的 RoBERTa，而哈工大开源的 RoBERTa-wwm-ext-large [5]则不知道出于什么原因随机初始化了 MLM 部分的权重，因此如果要复现本文后面的结果，这些版本是不可取的。</p>
<p>然而，随着研究的深入，研究人员发现不止 BERT 的 Encoder 很有用，预训练用的 MLM 本身也很有用。</p>
<p>比如论文 <strong>BERT has a Mouth, and It Must Speak: BERT as a Markov Random Field Language Model</strong>[6]指出 MLM 可以作为一般的生成模型用，论文 <strong>Spelling Error Correction with Soft-Masked BERT</strong>[7] 则将 MLM 用于文本纠错。</p>
<p>笔者之前在 的实验也表明 MLM 的预训练权重也可以当作 UniLM 来用做 Seq2Seq 任务，还有一文将 MLM 的思想用于无监督分词和句法分析了。可以说 MLM 已经是大放异彩了。</p>
<h2 id="将任务转成完形填空"><a href="#将任务转成完形填空" class="headerlink" title="将任务转成完形填空"></a><strong>将任务转成完形填空</strong></h2><p>在本文里，我们再学习 MLM 的一个精彩应用：用于小样本学习或半监督学习，某些场景下甚至能做到零样本学习。</p>
<p>怎么将我们要做的任务跟 MLM 结合起来呢？很简单， <strong>给任务一个文本描述，然后转换为完形填空问题</strong>即可。举个例子，假如给定句子“这趟北京之旅我感觉很不错。”，那么我们补充个描述，构建如下的完形填空：</p>
<blockquote>
<p> <strong>__</strong>满意。这趟北京之旅我感觉很不错。</p>
</blockquote>
<p>进一步地，我们限制空位处只能填一个“很”或“不”，问题就很清晰了，就是要我们根据上下文一致性判断是否满意，如果“很”的概率大于“不”的概率，说明是正面情感倾向，否则就是负面的，这样我们就将<strong>情感分类问题</strong>转换为一个完形填空问题了，它可以用 MLM 模型给出预测结果，而 MLM 模型的训练可以不需要监督数据，因此理论上这能够实现零样本学习了。</p>
<p><strong style="color:blue;">多分类问题</strong>也可以做类似转换，比如<strong>新闻主题分类</strong>，输入句子为“八个月了，终于又能在赛场上看到女排姑娘们了。”，那么就可以构建：</p>
<blockquote>
<p> 下面播报一则<strong>__</strong>新闻。八个月了，终于又能在赛场上看到女排姑娘们了。</p>
</blockquote>
<p>这样我们就将新闻主题分类也转换为完形填空问题了，一个好的 MLM 模型应当能预测出“体育”二字来。</p>
<p>还有一些<strong style="color:blue;">简单的推理任务</strong>也可以做这样的转换，常见的是给定两个句子<strong>，判断这两个句子是否相容</strong>，比如“我去了北京”跟“我去了上海”就是矛盾的，“我去了北京”跟“我在天安门广场”是相容的，常见的做法就是将两个句子拼接起来输入到模型做，作为一个二分类任务。如果要转换为完形填空，那该怎么构造呢？一种比较自然的构建方式是：</p>
<blockquote>
<p>我去了北京？<strong>__</strong>，我去了上海。</p>
<p>我去了北京？<strong>__</strong>，我在天安门广场。</p>
<p>其中空位之处的候选词为 是 的 不 是 。</p>
</blockquote>
<h2 id="Pattern-Exploiting-Training"><a href="#Pattern-Exploiting-Training" class="headerlink" title="Pattern-Exploiting Training"></a><strong>Pattern-Exploiting Training</strong></h2><p>读到这里，读者应该不难发现其中的规律了，就是给输入的文本增加一个前缀或者后缀描述，并且 Mask 掉某些 Token，转换为完形填空问题，这样的转换在原论文中称为 <strong>Pattern</strong>，这个转换要尽可能与原来的句子组成一句自然的话，不能过于生硬，因为预训练的 MLM 模型就是在自然语言上进行的。</p>
<p>显然同一个问题可以有很多不同的 Pattern，比如情感分类的例子，描述可以放最后，变成“这趟北京之旅我感觉很不错。<strong><strong>满意。”；也可以多加几个字，比如“觉得如何？</strong></strong>满意。这趟北京之旅我感觉很不错。”。</p>
<p>然后，我们需要构建预测 Token 的候选空间，并且建立 Token 到实际类别的映射，这在原论文中称为 <strong>Verbalizer</strong>，比如情感分类的例子，我们的候选空间是 很 不 ，映射关系是 很 正 面 不 负 面 ，候选空间与实际类别之间不一定是一一映射，比如我们还可以加入“挺”、“太”、“难”字，并且认为 很 挺 太 正 面 以 及 不 难 负 面 ，等等。</p>
<p>不难理解，不少 NLP 任务都有可能进行这种转换，但显然这种转换一般只适用于 <strong>候选空间有限</strong>的任务，说白了就是只用来做 <strong>选择题</strong>，常见任务的就是 <strong>文本分类</strong>。</p>
<p>刚才说了，同一个任务可以有多种不同的 Pattern，原论文是这样处理的：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>对于每种 Pattern，单独用训练集 Finetune一个 MLM 模型出来；</span><br><span class="line"><span class="bullet">2. </span>然后将不同 Pattern对应的模型进行集成，得到融合模型；</span><br><span class="line"><span class="bullet">3. </span>用融合模型预测未标注数据的伪标签；</span><br><span class="line"><span class="bullet">4. </span>用伪标签数据 Finetune 一个常规的（非 MLM 的）模型。</span><br></pre></td></tr></table></figure>
<p>具体的集成方式大家自己看论文就行，这不是重点。这种训练模式被称为 <strong>Pattern-Exploiting Training（PET）</strong>，它首先出现在论文 <strong>Exploiting Cloze Questions for Few Shot Text Classification and Natural Language Inference</strong>。</p>
<p><strong style="color:blue;">yaya: 与 这篇论文思想很类似：How Many Data Points is a PromptWorth? （arXiv: 2103.08493v1）</strong></p>
<p>本文要介绍的这篇论文则进一步肯定和完善了 Pattern-Exploiting Training 的价值和结果，并整合了多任务学习，使得它在 SuperGLUE 榜单上的小样本学习效果超过了 GPT3。两篇论文的作者是相同的，是一脉相承的作品。</p>
<p><img src="https://i.loli.net/2021/03/20/dOMZNLsKykIDioQ.png" alt="img"></p>
<p>▲ PET在SuperGLUE上的小样本学习的结果</p>
<p>不过要吐槽一个点是，上图中 PET 的 223M 参数，所用的模型是 ALBERT-xxlarge-v2，事实上称 ALBERT 为“小模型”是一种很耍流氓的行为，因为它前向计算的速度并没有得到任何提升。ALBERT-xxlarge 共有 12 层，层与层之间参数是共享的，就前向计算而言，它应该等价于约 2700M（12 倍）参数的 GPT 才对。</p>
<h2 id="中文实践，检验效果"><a href="#中文实践，检验效果" class="headerlink" title="中文实践，检验效果"></a><strong>中文实践，检验效果</strong></h2><p>要真正确认一个方法或模型的价值，看论文的实验表格是不够的，论文给出的实验结果谁都不好说能否复现，其次就算英文上能复现也不代表中文上有价值，因此最实际的还是亲自动手做实验验证。下面是笔者的实验代码，供读者参考：</p>
<p>Github 地址：</p>
<p><a href="https://github.com/bojone/Pattern-Exploiting-Training" target="_blank" rel="noopener">https://github.com/bojone/Pattern-Exploiting-Training</a></p>
<p>我们将从以下几个角度来探讨 PET 的可行性：</p>
<p>\1. 直接利用现成的 MLM 模型效果如何？ <strong>（零样本学习1）</strong></p>
<p>\2. 用“大量无标签数据”微调现成的 MLM 模型效果如何？ <strong>（零样本学习2）</strong></p>
<p>\3. 用“小量标签数据”微调现成的 MLM 模型效果如何？ <strong>（小样本学习）</strong></p>
<p>\4. 用“小量标签数据+大量无标签数据”微调现成的MLM模型效果如何？ <strong>（半监督学习）</strong></p>
<p>下面主要给出 <strong>情感二分类</strong>的实验结果。另外还有一个新闻主题的多分类，代码也放到 Github 了，其结果是类似的，就不重复陈述了。</p>
<h3 id="4-1-零样本学习1"><a href="#4-1-零样本学习1" class="headerlink" title="4.1 零样本学习1"></a><strong>4.1 零样本学习1</strong></h3><p>这里主要探索的是给输入文本补上对应的 Pattern 后，直接基于现成的 MLM 模型进行预测，预测的准确率。由于构建模型的整个过程都不涉及到标签数据监督训练，因此这算是一种“零样本学习”。我们需要比较的是不同 Pattern、不同 MLM 模型上的效果：</p>
<p>下面是实验的几个 Pattern，其中空位处候选词语都为“很”和“不”：</p>
<p>P1：____满意。这趟北京之旅我感觉很不错。</p>
<p>P2：这趟北京之旅我感觉很不错。____满意。</p>
<p>P3：____好。这趟北京之旅我感觉很不错。</p>
<p>P4：____理想。这趟北京之旅我感觉很不错。</p>
<p>P5：感觉如何？____满意。这趟北京之旅我感觉很不错。</p>
<p>至于 MLM 模型，则是下面几个：</p>
<p>M1：Google 开源的中文版 BERT Base：</p>
<p><a href="https://github.com/google-research/bert" target="_blank" rel="noopener">https://github.com/google-research/bert</a></p>
<p>M2：哈工大开源的 RoBERTa-wwm-ext Base：</p>
<p><a href="https://github.com/ymcui/Chinese-BERT-wwm" target="_blank" rel="noopener">https://github.com/ymcui/Chinese-BERT-wwm</a></p>
<p>M3：腾讯 UER 开源的 BERT Base：</p>
<p><a href="https://share.weiyun.com/5QOzPqq" target="_blank" rel="noopener">https://share.weiyun.com/5QOzPqq</a></p>
<p>M4：腾讯 UER 开源的 BERT Large：</p>
<p><a href="https://share.weiyun.com/5G90sMJ" target="_blank" rel="noopener">https://share.weiyun.com/5G90sMJ</a></p>
<p>实验结果如下表（验证集/测试集）：</p>
<p><img src="https://i.loli.net/2021/03/20/8Yg2qH5CXoFPkcx.png" alt="img"></p>
<p>可以观察到，不同的 Pattern、不同的预训练模型之间还是有一定的差异的，整体而言 Large 版本的效果要明显好于 Base 版本的模型，说明像 GPT 到 GPT2 再到 GPT3 一样，还是把模型做得更大会更好。</p>
<p>此外，这还有可能说明实际上 MLM 还没有被充分训练好，或许是因为 BERT 这种 Mask 掉一部分的训练方式过于低效了，可能用 修改 Transformer 结构，设计一个更快更好的 MLM 模型 一文提到的改进版 MLM 会更好。</p>
<h3 id="4-2-零样本学习2"><a href="#4-2-零样本学习2" class="headerlink" title="4.2 零样本学习2"></a><strong>4.2 零样本学习2</strong></h3><p>看完上述结果，读者可能会想到：如果我用领域内的数据继续预训练 MLM 模型，那么能不能提升效果呢？答案是：能！下面是我们的实验结果，算力有限，我们只在 RoBERTa-wwm-ext（上述的 M2，继续预训练后的模型我们称为 M2+ 无监督）的基础上做了比较：</p>
<p><img src="https://i.loli.net/2021/03/20/Y8CdHbW1cjqByrD.png" alt="img"></p>
<p>要注意的是，这里我们只是用领域内的数据继续做 MLM 训练，这个过程是无监督的，也不需要标注信号，因此也算是“零样本学习”。同时，从到目前为止的结果我们可以看出，给输入本文加入“前缀”的效果比“后缀”更有优势一些。</p>
<h3 id="4-3-小样本学习"><a href="#4-3-小样本学习" class="headerlink" title="4.3 小样本学习"></a><strong>4.3 小样本学习</strong></h3><p>刚才我们讨论了无标签数据继续预训练 MLM 的提升，如果回到 PET 的目标场景，直接用小量的标签数据配合特定的 Pattern 训练 MLM 又如何呢？</p>
<p>这也就是真正的“小样本学习”训练了，这里我们保留约 200 个标注样本，构造样本的时候，我们先给每个句子补上 Pattern，除了 Pattern 自带的 Mask 位置之外，我们还随机 Mask 其他一部分，以增强对模型的正则。最终实验结果如下：</p>
<p><img src="https://i.loli.net/2021/03/20/qVFgDbyLQrXpZUt.png" alt="img"></p>
<p>结论就是除了“后缀式”的 P2 之外，其它结果都差不多，这进一步说明了“前缀式”的 Pattern 会比“后缀式”更有竞争力一些。在效果上，直接用同样的数据用常规的方法去微调一个 BERT 模型，大概的结果是 88.93 左右，所以基于 “MLP+Pattern” 的小样本学习方法可能带来轻微的性能提升。</p>
<h3 id="4-4-半监督学习"><a href="#4-4-半监督学习" class="headerlink" title="4.4 半监督学习"></a><strong>4.4 半监督学习</strong></h3><p>无监督的零样本学习和有监督的小样本学习都说完了，自然就轮到把标注数据和非标注数据都结合起来的“半监督学习”了。还是同样的任务，标注数据和非标注数据的比例大约是 1:99，标注数据带 Pattern，非标注数据不带 Pattern，大家都 Mask 掉一部分 Token 进行 MLM 预训练，最终测出来的效果如下：</p>
<p><img src="https://i.loli.net/2021/03/20/4QKcUYDtgAmeGqM.png" alt="img"></p>
<p>还是同样的，“后缀”明显比“前缀”差，“前缀”的效果差不多。具体效果上，则是肯定了额外的无标注数据也是有作用的。</p>
<p>直觉上来看，“前缀”比“后缀”要好，大体上是因为“前缀”的 Mask 位置比较固定，微弱的监督信号得以叠加增强？但这也不能解释为什么零样本学习的情况下也是“前缀”更好，估计还跟模型的学习难度有关系，可能句子前面部分的规律更加明显，相对来说更加容易学一些，所以前面部分就学习得更加充分？这一切都还只是猜测。</p>
<h3 id="4-5-汇总与结论"><a href="#4-5-汇总与结论" class="headerlink" title="4.5 汇总与结论"></a><strong>4.5 汇总与结论</strong></h3><p>将上述结果汇总如下：</p>
<p><img src="https://i.loli.net/2021/03/20/cpGqLZ2twR5z4di.png" alt="img"></p>
<p>读者还可以对比我们之前在文章 泛化性乱弹：从随机噪声、梯度惩罚到虚拟对抗训练 中用虚拟对抗训练（VAT）做半监督学习的结果，可以看到不管是零样本学习、小样本学习还是半监督学习，基于 MLM 模型的方式都能媲美基于 VAT 的半监督学习的结果。</p>
<p>我们在做短新闻多分类实验时的结果也是相似的。因此，这说明了 MLM 模型确实也可以作为一个优秀的零样本/小样本/半监督学习器来使用。</p>
<p>当然，基于 MLM 模型的缺点还是有的，比如 MLM 所使用的独立假设限制了它对更长文本的预测能力（说白了空位处的文字不能太长），以及无法预测不定长的答案也约束了它的场景（所以当前只能用于做选择题）。我们期待有更强的 MLM 模型出现，那时候就有可能在所有任务上都能与 GPT3 一较高下了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文介绍了 BERT 的 MLM 模型的一个新颖应用：配合特定的描述将任务转化为完形填空，利用 MLM 模型做零样本学习、小样本学习和半监督学习。</p>
<p>在原论文的 SuperGLUE 实验里边，它能达到媲美 GPT3 的效果，而笔者也在中文任务上做了一些实验，进一步肯定了该思路的有效性。整个思路颇为别致，给人一种“原来还可以这样做”的恍然大悟感，推荐大家学习一下。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://arxiv.org/abs/2005.14165" target="_blank" rel="noopener">https://arxiv.org/abs/2005.14165</a></p>
<p>[2] <a href="https://arxiv.org/abs/2009.07118" target="_blank" rel="noopener">https://arxiv.org/abs/2009.07118</a></p>
<p>[3] <a href="https://github.com/brightmart/roberta_zh" target="_blank" rel="noopener">https://github.com/brightmart/roberta_zh</a></p>
<p>[4] <a href="https://github.com/CLUEbenchmark/CLUEPretrainedModels" target="_blank" rel="noopener">https://github.com/CLUEbenchmark/CLUEPretrainedModels</a></p>
<p>[5] <a href="https://github.com/ymcui/Chinese-BERT-wwm" target="_blank" rel="noopener">https://github.com/ymcui/Chinese-BERT-wwm</a></p>
<p>[6] <a href="https://arxiv.org/abs/1902.04094" target="_blank" rel="noopener">https://arxiv.org/abs/1902.04094</a></p>
<p>[7] <a href="https://kexue.fm/archives/7661" target="_blank" rel="noopener">https://kexue.fm/archives/7661</a></p>
<p>[8] <a href="https://arxiv.org/abs/2001.07676" target="_blank" rel="noopener">https://arxiv.org/abs/2001.07676</a></p>
<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><p>不懂的问题：</p>
<ul>
<li><p>mask 一个 Span, 多个空位然后逐词预测？？</p>
</li>
<li><p>在 [MASK] 位置 预测空间是多大？整个vocabulary ??</p>
</li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
        <category>few-shot</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>few-shot</tag>
      </tags>
  </entry>
  <entry>
    <title>LM-MLC 一种基于完型填空的多标签分类算法</title>
    <url>/2021/07/08/LM-MLC-%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E5%AE%8C%E5%9E%8B%E5%A1%AB%E7%A9%BA%E7%9A%84%E5%A4%9A%E6%A0%87%E7%AD%BE%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>转载：<a href="https://mp.weixin.qq.com/s/1VnR1zQ4LWnUDl6USdxVhQ#" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/1VnR1zQ4LWnUDl6USdxVhQ#</a></p>
<p>同样一篇基于 PET， 模板的方式来做NLP任务的论文</p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a><strong>1 前言</strong></h2><p>本文主要介绍本人在全球人工智能技术创新大赛【赛道一】设计的一种基于完型填空(模板)的多标签分类算法：LM-MLC，该算法拟合能力很强能感知标签关联性，在多个数据集上测试表明该算法与主流算法无显著性差异，在该比赛数据集上的dev效果很好，但是由于比赛期间事情多，没有好好在test集做测试。</p>
<p>个人认为该算法根正苗红，理论上可以获得更好的效果，因此做个开源，抛砖引玉，希望有人能提出更为有效的改进。本次开源的代码可读性较强，也有较高的扩展性，本人把LM-MLC可做的修改均写成超参形式，方便各位做测试。</p>
<p>Github：<a href="https://github.com/DunZhang/LM-MLC" target="_blank" rel="noopener">https://github.com/DunZhang/LM-MLC</a></p>
<h2 id="2-多标签分类任务"><a href="#2-多标签分类任务" class="headerlink" title="2 多标签分类任务"></a><strong>2 多标签分类任务</strong></h2><p>NLP里的多标签分类任务，输入多为一段文本，输出该文本的的标签。比如在新闻类型分类中，一篇新闻可以同时有”军事”、”政治”和”历史”三个标签，再举个例子，疾病分类中，一位患者可以既感冒又咳嗽。</p>
<p>多标签分类任务依据数据特点又可以划分为多种类型。</p>
<h3 id="2-1-文本长度"><a href="#2-1-文本长度" class="headerlink" title="2.1 文本长度"></a>2.1 文本长度</h3><p>文本长度会直接影响到算法的选择，长度过长对算法语义理解要求会变高，如果长度超过512个字符，就不好直接使用BERT，需要分段编码或使用其他算法(LSTM、XLNET等)。文本过长也使得训练时间变长，着实影响到了穷逼的炼丹进度。</p>
<h3 id="2-2-内容是否加密"><a href="#2-2-内容是否加密" class="headerlink" title="2.2 内容是否加密"></a>2.2 内容是否加密</h3><p>大部分数据集是未加密的，直接可以看到原文。少部分数据集做了脱敏处理，原字词会被替换为数字或其他符号。虽说保护了隐私，但是对算法要求变高了，因为无法使用预训练模型，也没有办法做错误分析。为了达到更好的效果，需要对此类数据集继续做预训练，然后基于该预训练模型微调多标签分类任务。上文中我说的比赛就是做了加密处理。</p>
<h3 id="2-3-标签数量"><a href="#2-3-标签数量" class="headerlink" title="2.3 标签数量"></a>2.3 标签数量</h3><p>多标签分类数据集标签数量有多有少，少则几个多达上千(比如知乎看山杯数据集)，标签数量多少也会影响到算法的选择，标签数量过多时，多标签分类任务也可以考虑转化为搜索任务，此外标签数量过多时，往往会有严重的类不平衡问题，这在设计算法时也是需要考虑的。</p>
<h3 id="2-4-标签关联性"><a href="#2-4-标签关联性" class="headerlink" title="2.4 标签关联性"></a>2.4 标签关联性</h3><p>有些数据集的标签之间会存在相关性，比如新闻分类中，关于军事的新闻可能也会和政治有关系，疾病分类中，如果得了高血压，就有可能影响到视网膜。所以对于有关联的标签，算法如能考虑到标签的关联性，那么理论上效果是可以提升的，LM-MLC算法里就认真探索了标签关联性。</p>
<h2 id="3-自然语言处理中的完型填空"><a href="#3-自然语言处理中的完型填空" class="headerlink" title="3 自然语言处理中的完型填空"></a><strong>3 自然语言处理中的完型填空</strong></h2><p>先说一说完型填空，即一段文本，挖掉几个词，让模型去猜挖掉的词是什么，其实这就是遮挡语言模型。我们可以借助完型填空完成一些自然处理任务，关于这块的介绍，苏建林的两篇博客：博客1，博客2介绍的细致、精彩，因此我就不再过多叙述。</p>
<p>为了便于理解，我举个完型填空做新闻分类的例子，待分类文本是：美国攻打伊拉克，是因为萨达姆偷了布什家的高压锅 ，我们在该段文本后(或前面)加上如下一段话：这是关于[MASK]的新闻，这样完整的进入BERT的输入就是：[CLS]美国攻打伊拉克，是因为萨达姆偷了布什家的高压锅，这是关于[MASK]的新闻[SEP], 我们只要让模型判断掩掉的词是什么即可，如预测词是军事，那么分类结果就是军事，通常情况下候选词是全体标签。</p>
<p><img src="https://i.loli.net/2021/07/08/Eybwgr72T4D6tQz.png" alt="640" style="zoom:50%;"></p>
<h2 id="4-LM-MLC-把完型填空用在多标签分类数据集上"><a href="#4-LM-MLC-把完型填空用在多标签分类数据集上" class="headerlink" title="4 LM-MLC:把完型填空用在多标签分类数据集上"></a><strong>4 LM-MLC:把完型填空用在多标签分类数据集上</strong></h2><p>说了那么多背景知识，下面开始正式介绍LM-MLC算法。</p>
<h3 id="4-1-模板构建"><a href="#4-1-模板构建" class="headerlink" title="4.1 模板构建"></a><strong>4.1 模板构建</strong></h3><p>上文举得例子是关于分类的，那么对于多标签分类任务要如何构建模板呢，很自然的可以加入如下模板：”有标签1：[MASK],有标签2：[MASK],有标签3：[MASK]”, 该[MASK]预测的词就是：YES或NO。一图胜千言，我们假设是在新闻多标签分类任务，共有三个标签分别是”军事”,”政治”和”历史”，假设文本是：美国攻打伊拉克，那么输入就是：</p>
<p><img src="https://i.loli.net/2021/07/08/BXYNRLdHau9jC7l.png" alt="640" style="zoom:50%;"></p>
<p>人工构建模板是一个困难的事情，模板选取很关键，模板是很不稳定的，因此本算法使用了P-tuning的做法，把模板变为[unused*]或者自己在bert的vocab中新建一些词汇，总之就是让模型自己去寻找最佳模板，所以上图输入可以进一步修改为如下形式：</p>
<p><img src="https://i.loli.net/2021/07/08/abroHAk3t7B12sY.png" alt="640"></p>
<p>至于[MASK]前后放多少未使用字符，模板位置，不同标签是否使用不同[MASK]等就是各种微小改动，具体可以看开源代码，均以超参形式存于代码中，可以一次试个够。</p>
<h3 id="4-2-模型架构"><a href="#4-2-模型架构" class="headerlink" title="4.2 模型架构"></a><strong>4.2 模型架构</strong></h3><p>本次博客主要还是抛砖引玉，想把方法公开了和各位讨论，本次所用模型都是极为简单的，没有使用任何比赛的trick，主要提供思想。</p>
<h4 id="4-2-1-Baseline模型架构"><a href="#4-2-1-Baseline模型架构" class="headerlink" title="4.2.1 Baseline模型架构"></a><strong>4.2.1 Baseline模型架构</strong></h4><p>本模型的Baseline模型就是基于BERT的，模型架构极为简单，CLS向量后接全连接层，然后过Sigmoid层作为每个tag的分数。损失函数可以选用最基础的BCELoss。多提一句，也可以当成分类任务做，用交叉熵优化，但其实看公式，其实是差不多的，本人就懒得折腾了。</p>
<h4 id="4-2-2-LM-MLC模型架构"><a href="#4-2-2-LM-MLC模型架构" class="headerlink" title="4.2.2 LM-MLC模型架构"></a><strong>4.2.2 LM-MLC模型架构</strong></h4><p>模型架构图前面已经有了，再用文字描述下：基础部分还是BERT，获取TokenEmbedding后使用gather方法提取[MASK]的embedding，然后通过Sigmoid获取每个标签的分数，同样使用BCELoss损失函数。</p>
<h3 id="4-3-如何训练"><a href="#4-3-如何训练" class="headerlink" title="4.3 如何训练"></a><strong>4.3 如何训练</strong></h3><p>最简单的训练方式就是一次掩盖掉所有的标签然后全部预测，此类方法适合标签没有关联性的数据集。如果标签之间存在关联性，肯定要通过一部分标签值来预测余下的标签值，这也是LM-MLC算法的核心，很多方法都是围绕这个点设计的。</p>
<p>如何判断标签之间有无关联性呢，方法很简单，取训练集的标签值购置01向量，然后计算统计相关系数即可，根据系数值和下表判断相关性：</p>
<p><img src="https://i.loli.net/2021/07/08/gbGJ4LmNfHtYKch.png" alt="图片"></p>
<p>在训练过程中，要把一部分[MASK]改为YES或NO，这种方式让模型在对[MASK]标签做预测时不仅能感知到哪些标签值是0哪些标签值是1以及哪些标签是待预测的。在本算法中使用了[MASK]的真实值，相当于teacher-force-learning，同时为了提升模型的鲁棒性，会以1%的概率故意给错标签，实测这个trick还是挺关键的。</p>
<p>想要完整实现该思想时，要考虑好多细节，本人想了3种实现策略，但是也没找到最优解，我把思路和逻辑一一罗列出来供大家参考讨论。</p>
<p>思路一，全随机 在训练时随机掩盖一部分标签，让模型进行预测并计算损失损失。</p>
<p>思路二，固定掩盖顺序 假设有四个标签，掩盖顺序为1-&gt;2-&gt;3-&gt;4，那么可能的掩盖顺序是：1，12，123，1234，这种方法在预测时也要使用相同的方式去预测，掩盖顺序目前没有发现最优解。</p>
<p>思路三，UniLM 把标签作为生成任务，通过修改AttentionMask的方式来实现，即以UniLM的形式去训练，这个我没有尝试，因为这种方式已经不再是完型填空的范畴了，欢迎大家尝试。</p>
<p>本人比较推荐思路一，在实验中思路一的效果也是不错的</p>
<h3 id="4-4-如何预测"><a href="#4-4-如何预测" class="headerlink" title="4.4 如何预测"></a><strong>4.4 如何预测</strong></h3><p>预测时的基本思想是先预测一个标签，然后在该标签预测结果的基础上继续预测其他标签。那么最重要的问题就是如何确定预测顺序，有如下几种预测方法：</p>
<p>方法1：随机，即随机确定一个顺序，不足在于不同顺序会影响性能上下浮动约2个百分点</p>
<p>方法2：固定顺序，即按照固定顺序预测，难点在于顺序难以确定 </p>
<p>方法3：Top-P,每一次选取模型置信度最高的标签作为首先预测的标签，效果尚可 </p>
<p>方法4：搜索算法，使用遗传算法等搜索算法选取一个在dev上效果最号的预测顺序作为最终顺序，也可以不用搜索算法，直接random几百次找个最好的也行</p>
<p>方法3效果还行，方法4可提升逼格发论文。</p>
<h3 id="4-5-如何进一步提升效果"><a href="#4-5-如何进一步提升效果" class="headerlink" title="4.5 如何进一步提升效果"></a><strong>4.5 如何进一步提升效果</strong></h3><p>在当前预训练+微调的框架下，有一个简单有效的方法那就是不要停止预训练，即把预训练模型在微调数据集上继续做预训练，然后再做微调，该方法以获得ACL2020最佳论文荣誉提名，具体参见Don’t Stop Pretraining:Adapt Language Models to Domains and Tasks。</p>
<p>为什么我说LM-MLC是根正苗红呢，因为完形填空他完美契合mlm预训练任务，都是预测[MASK], 我总结两个使用该思想的方法：</p>
<p>常规做法：先继续预训练，然后微调</p>
<p>联合训练：同时做Word Mask(mlm 任务)和Label Mask(完形填空任务)，然后把loss加一起，可以适当提高Label Mask的权重</p>
<p>本人是使用第二种，因为这两个任务实在是太契合了，通常我是微调25轮，其中前15轮联合训练，后10轮task-specific的训练，不能所有轮数都联合训练，那不然预测和训练的数据又会不一致。</p>
<h3 id="4-6-小结"><a href="#4-6-小结" class="headerlink" title="4.6 小结"></a><strong>4.6 小结</strong></h3><p>LM-MLC算法最大的缺点是不支持标签数量过多，假设有100个标签，模板长度为2，再加上自身MASK，那么光标签模板就占了300的长度，而BERT的输入长度限制为512，所以数据集标签多了是无法使用该方法的。</p>
<p>此外，由于时间精力有限，几乎没有找到合适的存在标签关联的数据集，所以对于标签关联性的一些构想还是缺少验证的，这种数据集怕是要手工构建了，绝大多数数据集都是标签无关，因此直接全部掩盖掉，全部预测就行了。</p>
<h2 id="5-简单实验"><a href="#5-简单实验" class="headerlink" title="5 简单实验"></a><strong>5 简单实验</strong></h2><p><strong>数据集介绍</strong></p>
<p>全球人工智能技术创新大赛【赛道一】比赛数据集，是关于医疗影像描述文本的，输出为哪些部位有异常，初赛是17分类，复赛在17分类的基础上又多了12标签分类，本人把复赛初赛复赛数据集合并到一起，当成17多标签分类任务来做。数据集不太方便提供下载。</p>
<p><strong>AAPD数据集</strong>，这是开源的数据集，我分析AAPD数据集并没有较强的标签关联性，搞不懂为啥SGM多标签分类算法要用这个训练集。。。</p>
<p><strong>Stackoverflow数据集</strong>，Stackoverflow的帖子都是带有tag的，截图如下，但是该数据集不能直接获得，需要去该网站（<a href="https://archive.org/details/stackexchange）下载，可能需要梯子，然后手工清洗后作为训练集，清洗代码可以见我另外一个开源库DomainSpecificThesaurus。或者先用我清洗的10W数据集，下载链接请往后看。" target="_blank" rel="noopener">https://archive.org/details/stackexchange）下载，可能需要梯子，然后手工清洗后作为训练集，清洗代码可以见我另外一个开源库DomainSpecificThesaurus。或者先用我清洗的10W数据集，下载链接请往后看。</a></p>
<p><strong>RCV1-V2数据集</strong>，也是开源数据集，标签间也没啥关联性，而且看着文本总感觉很奇怪。</p>
<p>我提供了AAPD数据集、清洗后的Stackoverflow数据集和RCv1-v2数据集，下载地址：</p>
<p><a href="https://drive.google.com/file/d/1qNOfb4WX7TpTSPuhGIAAvzAbOc1MbHCO/view" target="_blank" rel="noopener">https://drive.google.com/file/d/1qNOfb4WX7TpTSPuhGIAAvzAbOc1MbHCO/view</a></p>
<p><strong>实验结果</strong></p>
<p>因为硬件资源有限，本人工作也较忙，没有做太多的实验，这里把有记录的比赛数据集结果和AAPD数据集测试结果贴出来。</p>
<p>全球人工智能技术创新大赛【赛道一】的测试结果：</p>
<p><img src="https://i.loli.net/2021/07/08/mqOFiescWHYvM3J.png" alt="图片"></p>
<p>AAPD数据集的测试结果：</p>
<p><img src="https://i.loli.net/2021/07/08/DmXbY1r7us8UFoc.png" alt="图片"></p>
<p>简单解释下四个方法的含义：</p>
<p>Baseline: BERT+FC, 详情见上文或源码</p>
<p>Baseline+mlm: 与mlm联合训练，即mlm_loss+bce_loss</p>
<p>LM-MLC: 基于完形填空的多标签分类算法，就本人所设计算法</p>
<p>LM-MLC: 与mlm联合预训练，详情见上文或源码</p>
<p>前前后后做了很多实验，客观来说，实验结果不太符合预期，效果在其他数据集上没有显著性提升，还是挺郁闷的，抛砖引玉，希望读者能提出的改进意见。不过该方法也没有明显差于其他方法，在以后比赛中作为一种融合模型还是可以滴。</p>
<h2 id="6-代码介绍"><a href="#6-代码介绍" class="headerlink" title="6 代码介绍"></a><strong>6 代码介绍</strong></h2><p>Github开源地址：<a href="https://github.com/DunZhang/LM-MLC代码做了好多修改，力求简洁易用，同时具有较强的可读性和可扩展性，文中提到的好多点都做成了超参形式，欢迎试水" target="_blank" rel="noopener">https://github.com/DunZhang/LM-MLC代码做了好多修改，力求简洁易用，同时具有较强的可读性和可扩展性，文中提到的好多点都做成了超参形式，欢迎试水</a></p>
<p><img src="https://i.loli.net/2021/07/08/HEIkqPGivCL5r7y.png" alt="图片"></p>
<p>目录结构及文件名含义如下：</p>
<p><img src="https://i.loli.net/2021/07/08/UT5K6DJNX12fIeb.png" alt="图片"></p>
<h2 id="7-TODOList"><a href="#7-TODOList" class="headerlink" title="7 TODOList"></a><strong>7 TODOList</strong></h2><p>数据集，多标签分类数据集实在是太少了，需要多搞点数据集尤其是中文数据集和标签相关的数据集</p>
<p>UnilM，可以考虑试一试，文本部分全部交互，标签逐个生成</p>
<p>考虑标签本身的语义信息，比如经济标签，经济二字本身就是有语义信息的</p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>(LSTM-E)Jointly Modeling Embedding and Translation to Bridge Video and Language</title>
    <url>/2019/02/22/LSTM-E-Jointly-Modeling-Embedding-and-Translation-to-Bridge-Video-and-Language/</url>
    <content><![CDATA[<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><p>本文的主要贡献：</p>
<ol>
<li>同时使用了action feature of C3D and frames features。但是由于对C3D的特征也采用了mean pooling的方法，有缺陷，对action 特征的一种破坏。</li>
<li>提出了relevance loss ， 来加强整个句子的语义与视觉特征之间的关系。  </li>
</ol>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>目前存在的方法，依据给定的先前的单词以及视觉信息，来生成words，但是并没有利用句子语义与视觉内容之间的关系，导致生成的句子可能上下文是正确的，但是语义是错误的。<br>如 figure1，LSTM model 生成的句子是a man is riding a horse，逻辑上是没有错误的，但是语义却错了，图中出现的是woman 而不是man。<br>　　<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0f0qr6d2ij30lq0biq8s.jpg" width="500" hegiht="313" align="center"></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>  简单介绍LSTM-E：LSTM-E可以同时利用LSTM学习和视觉-语义embedding。LSTM 学习是为了在给定先前的单词以及视觉特征的基础上，最大化生成下一个单词的概率，后者是为了生成视觉-语义embedding，来加强整个句子的语义与视觉特征之间的关系。<br>  <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0f87gorc9j316d0kr11m.jpg" title="overview">  </p>
<ul>
<li><strong>Overview</strong><br>2D/3D 卷积神经网络被用来提取视频frames/clips的特征，平均池化来得到视频的特征。<br>基于视频特征<strong><em>v</em></strong>和句子语义<strong><em>s</em></strong>，生成sentences的<strong>LSTM model</strong> 和<strong>视觉-语义embeddeing model</strong> 联合学习。</li>
<li><strong>The sprit of LSTM-E</strong><br>在coherence和relevance之间的相互增强下来生成sentences。<strong><em>coherence:</em></strong>表达了生成words与视频内容之间的相关关系，由LSTM优化完成。<strong><em>relevance:</em></strong>整个句子的语义与视频内容之间的关系，由视觉-语义embeddeing model来度量。通过联合学习coherence和relevance，期望生成的句子在语境和语义上是正确的。</li>
<li><strong>说人话</strong><br>由两个model组成，一个是sequence learning 都有的coherence loss ，来最大化生成next word的似然概率；另一个是本文添加的relevance loss，通过优化视频特征与生成句子之间的差距，使得生成的句子语义上能对应video的内容。即同时考虑了句子单词之间的上下文关系，也考虑了句子语义与视频内容之间的关系。</li>
<li><strong>contribution</strong><br>提出了relevance loss !  </li>
</ul>
<h2 id="Video-Description-with-Relevance-and-Coherence"><a href="#Video-Description-with-Relevance-and-Coherence" class="headerlink" title="Video Description with Relevance and Coherence"></a>Video Description with Relevance and Coherence</h2><ul>
<li><strong>Visual-Semantic Embedding: Relevance</strong><br><strong><em>v</em></strong> 和 <strong><em>s</em></strong> 分别是视频的特征和sentences的特征（即，都是已知的），Ts和Tv用来降维到相同的维度，为了度量视频内容与句子语义之间的相关性，一个自然地方法是计算embedding之间的距离，因此定义relevance loss:<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0f8zoni8tj30bc01pmx2.jpg" 　style="zoom:45%"></li>
<li><strong>Translation by Sequence Learning: Coherence</strong><br>coherence loss：即为在给定视频特征的条件下，生成sentences的最大似然概率。<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0f9l8bbvoj30ph02pglq.jpg" style="zoom:50%"><br>由overview的图可知，在实际的情况下LSTM的输入是：第一个LSTM输入是视频特征，其余的是前一个time step 生成的单词（在train时：是caption中给定的第t个单词，在test时：是前一个time step 生成的单词）。因此似然函数可以具体的表示为：  　　<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0f9lgy6nfj317806fgm5.jpg" style="zoom:40%"></li>
</ul>
<h2 id="Joint-Modeling-Embedding-and-Translation"><a href="#Joint-Modeling-Embedding-and-Translation" class="headerlink" title="Joint Modeling Embedding and Translation"></a>Joint Modeling Embedding and Translation</h2><ul>
<li><strong>simultaneously minimizing the relevance loss and coherence loss.</strong><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0fa1y3nkgj30nu05pq3p.jpg" style="zoom:70%"></li>
<li><p><strong>LSTM结构 </strong><br>这里有多种方式来结合visual content 和 word of last time step。法一：each time step 都输入视频特征；法二：只在第一步输入视频特征。但是在[ 1 ]中指出，由于网络可以显式地利用噪声和更容易覆盖，所以每次输入图像都会产生劣质的效果。 因此，采用第二种方法，在给定视频特征v 和相对应的 sentence W ≡ [w0, w1, …, wNs]，LSTM的更新步骤如下：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0fcc8tiqej30z708l0t3.jpg"><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0faic2fuzj30n508njs2.jpg" style="width: 50%; height: 50%"><br>在初始的第一步，视频特征作为LSTM的输入；在第二步，&lt;#start#&gt;开始的标志作为LSTM的输入，同时接受上一步的hidden state, cell state，以后每一步，都将上一步生成的word 作为输入，直至生成&lt;#end#&gt;。<br>从第二步开始，使用LSTM cell 的hidden state 来预测 word( 对于LSTM output 与 hidden[0] 是一样的，参考：<a href="https://mp.csdn.net/postedit/87516958" target="_blank" rel="noopener">https://mp.csdn.net/postedit/87516958</a>)</p>
<blockquote>
<p><code>output, hidden = self.rnn(input, hidden)</code></p>
</blockquote>
</li>
</ul>
<h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><ul>
<li><strong>dataset</strong><br>MSVD:<br>Microsoft Research Video Description Corpus (YouTube2Text) , which contains 1,970 YouTube snippets. There are roughly 40 available English descriptions per video. In our experiments, we follow the setting used in prior works, taking 1,200 videos for training, 100 for validation and 670 for testing.</li>
<li><strong>result</strong><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0fcs7kt8cj31ap0bhgow.jpg"></li>
<li><strong>The effect of hidden layer size</strong><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0fcvqbzvsj30qz09x760.jpg" style="width: 70%; height: 70%">  </li>
</ul>
<h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>a visual-semantic embedding space is additionally incorporated into LSTM learning. In this way, <strong>a global relationship between the video content and sentence semantics</strong> is simultaneously measured in addition to <strong>the local contextual relationship between the word at each step and the previous ones</strong> in LSTM learning. On the popular YouTube2Text dataset, the results of our experiments demonstrate the success of our approach, outperforming the current state-ofthe-art models </p>
<h2 id="Future-Work"><a href="#Future-Work" class="headerlink" title="Future Work"></a>Future Work</h2><p>视频作为一个时域序列，未来将会探究使用RNN来获得更好的特征；另外，如果有更大的数据集，更多的video sentences pairs ，那么可以使用更深的RNN，来得到更好的视频描述</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] O. Vinyals, A. Toshev, S. Bengio, and D. Erhan. Show and tell: A neural image caption generator. In CVPR, 2015.</p>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>(LSTM_TSA)Video Captioning with Transferred Semantic Attributes</title>
    <url>/2019/03/03/LSTM-TSA-Video-Captioning-with-Transferred-Semantic-Attributes/</url>
    <content><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>在这篇文章中，我们提出了一个 Long Short-Term Memory with Transferred Semantic Attributes （LSTM-TSA）model，这是一个新颖的结构，可以将从images 和 videos 中学习到的transferred semantic attributes  结合到 encoder - decoder 结构中去。</p>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>Learning Video Representations from Correspondence Proposals</title>
    <url>/2019/07/26/Learning-Video-Representations-from-Correspondence-Proposals/</url>
    <content><![CDATA[<h3 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h3><ul>
<li>与Non-local 类似，都是在现有CNN（2D， 3D）模型中加入一个设计的模块</li>
</ul>
<h3 id="CPNet-介绍"><a href="#CPNet-介绍" class="headerlink" title="CPNet 介绍"></a>CPNet 介绍</h3><p>（1）在CNN的某一层，得到了<code>T*H*W*d</code>的特征，这<code>T*H*W</code>个特征，是经过conv来的，即一个特征，返回到原图对应的是一个块（区域）的特征。   </p>
<p>（2）类似于graph 中的邻接矩阵的操作，计算这个<code>T*H*W</code>个节点之间的相似性，相似性近的前K个（且不在同一帧），认为他们之间存在对应关系，即找到了一个区域对应到其他帧的对应区域。   </p>
<p>（3）将原区域，与对应区域的特征，与他们之间的位置关系，输入到MLP中，得到了一个更新的特征。对每个对应区域都采取这样的操作，得到K个特征。取max，得到了一个鲁棒的特征（可以去掉不是对应块区域的特征，即去掉噪声）。   </p>
<p><img src="https://i.loli.net/2019/07/26/5d3a7afee6b0178187.png" alt="搜狗截图20190726120054.png" title="搜狗截图20190726120054.png"></p>
<ul>
<li>是不是跟Non-Local很像，==CP Module就是融合了相似区域的特征，对原区域的特征进行更新。==</li>
</ul>
<h3 id="Non-local-vs-CPNet"><a href="#Non-local-vs-CPNet" class="headerlink" title="Non-local  vs   CPNet"></a>Non-local  vs   CPNet</h3><ul>
<li><p>在toy dataset （figure4）上设计了toy model（两层 CNN）,将现有的三个SOTA model以及自己设计的CPNet上进行试验</p>
</li>
<li><p>可以看到 I3D，ARTNet ，TRN三个模型的效果都不是很好</p>
</li>
<li>ARTNet ，TRN 是由于只使用了两个卷积层，不能捕捉长范围的运动信息</li>
<li>Non-local 可以捕捉长范围的运动信息，但是为什么效果还是不好：==NL block 没有加进去位置信息==（作者这么说的原因，就是因为在他们的CP module中有position information）</li>
</ul>
<p><img src="https://i.loli.net/2019/07/26/5d3a6c44659ae30922.png" alt="搜狗截图20190726102546.png" title="搜狗截图20190726102546.png"></p>
<h3 id="CPNet-可以退化成这三个model-没看懂-之后可以结合代码再深入分析"><a href="#CPNet-可以退化成这三个model-没看懂-之后可以结合代码再深入分析" class="headerlink" title="CPNet 可以退化成这三个model: ( 没看懂 ,之后可以结合代码再深入分析)"></a>CPNet 可以退化成这三个model: ( 没看懂 ,之后可以结合代码再深入分析)</h3><p><img src="https://i.loli.net/2019/07/26/5d3a889e2ce0b69830.png" alt="搜狗截图20190726125811.png" title="搜狗截图20190726125811.png"></p>
]]></content>
      <categories>
        <category>行为识别</category>
      </categories>
      <tags>
        <tag>行为识别</tag>
      </tags>
  </entry>
  <entry>
    <title>Large-Scale Zero-Shot Image Classification from Rich and Diverse Textual Descriptions</title>
    <url>/2021/03/22/Large-Scale-Zero-Shot-Image-Classification-from-Rich-and-Diverse-Textual-Descriptions/</url>
    <content><![CDATA[<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><ul>
<li><p>【目前常用的benchmark都比较小，且常常使用手工标注的类别属性作为补充数据。但是这种类型的补充数据，由于是手工标注的因此很难扩展到大规模数据集上（eg: ImageNet）。因此，目前在ImageNet 这样的大规模数据集上的零样本学习性能比较差】</p>
<p>ZSL benchmarks mostly cover either a very <strong>small</strong> or narrow set of classes, where <strong>human-made class attributes</strong> are often used as auxiliary data. Unfortunately, on ImageNet, where such attributes are not available, the performance is still very low.</p>
</li>
<li><p>【小规模数据集提供的类别有限，有可能训练集，测试集都是动物类别，无法评估模型在一个新颖类别上的性能，比如汽车。因此对于零样本学习任务，有必要发展一个大规模的数据集】</p>
<p>The large-scale setup enables us to study the main challenges of a more realistic and practical zero-shot image classification scenario and study the generalization of models to novel groups of classes (e.g., animal species in general), not only  individual classes (e.g., specific animal species).</p>
</li>
</ul>
<h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><ul>
<li><p>不对算法进行改进，而是研究 补充数据类型（auxiliary data type）对性能的影响。为 ImageNet class 收集对应的 wikipedia article，作为text descriptions。本文是第一个在大规模数据集上使用文本描述的。</p>
</li>
<li><p>在 ImageNet mp500 测试集上，使用本文提供的wikipedia文本描述作为补充数据，性能上取得了很大的提高，比以往的方法都好。</p>
</li>
<li>以前的小数据集受到类别有限的限制，无法评估在新颖类别上的泛化性。在本文提出的数据集上，证明了当前的ZSL model 的泛化性是比较差的。</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>Image Classification</category>
      </categories>
      <tags>
        <tag>Image Classification</tag>
      </tags>
  </entry>
  <entry>
    <title>Learning to Compose Topic-Aware Mixture of Experts for Zero-Shot Video Captioning</title>
    <url>/2020/09/15/Learning-to-Compose-Topic-Aware-Mixture-of-Experts-for-Zero-Shot-Video-Captioning/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>Learning to Contrast the Counterfactual Samples for Robust Visual Question Answering</title>
    <url>/2021/03/12/Learning-to-Contrast-the-Counterfactual-Samples-for-Robust-Visual-Question-Answering/</url>
    <content><![CDATA[<p>转自：<a href="https://blog.csdn.net/weixin_45347379/article/details/112182143" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45347379/article/details/112182143</a></p>
<p>学习对比反事实样本，以实现稳健的视觉问答<br>Learning to Contrast the Counterfactual Samples for Robust Visual Question Answering<br>在阅读本文之前，一定要阅读论文：Counterfactual Samples Synthesizing for Robust Visual Question Answering（简称CSS）</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><img src="https://i.loli.net/2021/03/12/gODk8QFCNWaUsVP.png" alt="image-20210312175656070"></p>
<p>文章的方法主要包括三个部分：（1）一个基本的VQA模型。（2）一个事实和反事实样本合成（CSS）模块。（3）一个对比学习（CL）目标。</p>
<h4 id="第一部分和第二部分"><a href="#第一部分和第二部分" class="headerlink" title="第一部分和第二部分"></a><strong>第一部分和第二部分</strong></h4><p>属于CSS已经实现的，主要作用在于：</p>
<p>（1）并通过多分类的方法预测答案，并产生图中右上方基本VQAloss。</p>
<p><img src="https://i.loli.net/2021/03/12/z3Q52bActwqMhov.png" alt="在这里插入图片描述"></p>
<p>（2）得到（I, I+, I-）和（Q, Q+, Q-），</p>
<p><img src="https://i.loli.net/2021/03/12/din9DctNLV1EORo.png" alt="在这里插入图片描述"></p>
<h4 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a><strong>第三部分</strong></h4><p>以（I, I+, I-）为例，将（I, I+, I-）和Q喂给VQA模型，分别产生原始样本的嵌入mm（V, Q）作为anchor（a），事实样本的嵌入mm(V+, Q)作为positive（p），反事实样本嵌入mm(V-, Q)作为negati（n）<br>利用余弦相似度作为评分函数，对正样本输出高值，对负样本输出低值，公式如下：</p>
<p><img src="https://i.loli.net/2021/03/12/XIjKWu7szqi3A4w.png" alt="在这里插入图片描述"></p>
<p>同样的方法得到anchor和negative之间的评分s(a, n), 这就相当于图中展示的，拉近原始图像与事实区域图像的关系，推远原始图像与反事实区域的距离。<br>对比损失定义为：（这就是图片下方得到的Contrastive loss）</p>
<p><img src="https://i.loli.net/2021/03/12/CY4OJ7PZmD9Eaud.png" alt="在这里插入图片描述"></p>
<p>最后，这种对比损失与基础分类损失的加权总和弥补了整体损失：</p>
<p><img src="https://i.loli.net/2021/03/12/8GL3BxlSEpAg951.png" alt="在这里插入图片描述"></p>
<p>虽然文章说，<strong style="color:red;">这种方法能够使模型学习他们之间的关系，并从更有因果关系的方面预测正确答案。</strong>但是，个人感觉如果仅仅使以上方法，并不能从理论上提高模型的能力。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><img src="https://i.loli.net/2021/03/12/wAmbOSxRU97dN12.png" alt="在这里插入图片描述"></p>
<h3 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h3><ul>
<li>看了本文博客之后，没有看原文，个人任务这种方法有限，</li>
<li>可能模型的设计上，是有新意的，使用对比学习来增强VQA模型的性能，但是往往自己做的时候会收效甚微</li>
</ul>
]]></content>
      <categories>
        <category>cross-modal</category>
        <category>VQA</category>
      </categories>
      <tags>
        <tag>cross-modal,VQA</tag>
      </tags>
  </entry>
  <entry>
    <title>Learning to Generate Grounded Visual Captions without Localization Supervision</title>
    <url>/2019/12/01/Learning-to-Generate-Grounded-Visual-Captions-without-Localization-Supervision/</url>
    <content><![CDATA[<h3 id="ICLR-2020-under-view"><a href="#ICLR-2020-under-view" class="headerlink" title="ICLR 2020 under view"></a>ICLR 2020 under view</h3><h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><ul>
<li><p>问题：在captioning 任务中，当前的评价指标并不能很好的反应生成的句子与该视频之间的契合度（Groud），有可能生成的句子只是基于在训练过程中学习到的priors（一种统计特性，而不是基于该视频本身）</p>
</li>
<li><p>当前模型对于 groud 这个任务，存在的困难：（1）由于当前的 language model 常使用 attention 机制来关注某一个 region，以此来预测下一个生成的单词。换句话说，就是在不知道将会生成什么单词的情况下，却要先定位region， 另外，一篇论文 [1] 提出，attention机制关注的region与人类所关注的并不一致（2）更难的是：传入 attention网络的是 RNN 的 hidden_state，由于 RNN 的记录历史的特性，这个输入包括的是过去所有的信息，而不是针对于某一个individual word。  </p>
</li>
</ul>
<h3 id="Contributions"><a href="#Contributions" class="headerlink" title="Contributions"></a>Contributions</h3><ul>
<li>不同于 GVD，该文不使用 annotation bbox 作为监督信号，而是使用了 decoder + localizer + redecoder的结构来自我监督（self-supervision）</li>
<li>由于其自监督的特性，在一些infrequent word上该文的方法比监督的方法，效果更好</li>
<li>不仅使用一般的为每个 object class 计算 grounding accuracy， 还提出了一个新的指标：为每个sentence 计算grounding accuracy。</li>
</ul>
<h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><ul>
<li><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g9heo6n8glj318k0lp0ze.jpg" alt="搜狗截图20191201183637.png"></p>
</li>
<li><p><strong>分阶段训练</strong></p>
</li>
<li>（1）正常的 encoder-decoder先训练 ~30个epoch</li>
<li>（2）在正常的基础上进行添加。 （a）<strong>re-localize</strong>: language_lstm 会得到y1, y2, …, yT 个预测的序列，将这些序列作为attention机制中的 查询向量，赋给每个region一个attention系数，这样就可以在每一个step重构attention系数分配，这样也解决了motivation中提到的问题，即attention是由某一个individual word 而计算得来的。（b）每个step 有了attention对齐之后的attention_region， 再输入到language_LSTM中，得到<strong>再次预测的sequence of word</strong>。</li>
<li><p>在这第二阶段，就是两个loss 交叉熵损失进行权重加和来训练</p>
</li>
<li><p>可以发现一个问题，对于visual-words 和 non-visual-words都进行了re-localize。实际上对于，on a 等这类词汇，并不需要在image中找到 grounded region。 该文作者在补充材料里给出了一些额外的实验， eg, 将这些non-visual words 进行抑制，不计算reconstruction loss, 或者给这些localized region representation重新赋给invalid representaion。但是实验表明，在Flickr30 上性能（caption and ground）有提升，但是在 activity上（caption 没变化，ground下降）。</p>
</li>
<li>但是作者并没有给出分析，我个人总觉得实验设计的不完善，分析的也不多。</li>
</ul>
<h3 id="Measuring-grounding-per-generated-sentence"><a href="#Measuring-grounding-per-generated-sentence" class="headerlink" title="Measuring grounding per generated sentence"></a>Measuring grounding per generated sentence</h3><ul>
<li>提该指标的原因：（Such metrics （F1all, F1loc） are extremely stringent as captioning models are generally biased toward certain words in the vocabulary, given the long-tailed distribution of words. ）</li>
</ul>
<h3 id="Analysis-Grounding-performance-when-using-a-better-object-detector"><a href="#Analysis-Grounding-performance-when-using-a-better-object-detector" class="headerlink" title="Analysis:  Grounding performance when using a better object detector."></a>Analysis:  Grounding performance when using a better object detector.</h3><ul>
<li>在 Flickr30k Entities 上进行实验，分析 better detector 对 grounding性能的影响</li>
<li>（1）使用 GT box (ubrealistically) ，进行实验，发现 caption metric 和 grounding accuracy都有提升</li>
<li>（2）在 Flickr30k上训练一个detector（之前使用的是在 visual genome上训练好的），进行实验，发现，使得caption metirc下降，（作者分析：由于在本数据集上进行训练，得到的 the ROI features and their associated object predictions 更偏向于 该数据中的  the annotated object words 却不能很好地泛化以预测 diverse captions， 从而导致了captioning 指标下降）</li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1] Abhishek Das, Harsh Agrawal, Larry Zitnick, Devi Parikh, and Dhruv Batra.  <strong>Human attention in visual question answering: Do humans and deep networks look at the same regions?</strong>  Computer Vision and Image Understanding, 163:90–100, 2017. </p>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>[Less is More] CLIPBERT for Video-and-Language Learning via Sparse Sampling</title>
    <url>/2021/03/18/Less-is-More-CLIPBERT-for-Video-and-Language-Learning-via-Sparse-Sampling/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>cross-modal</category>
        <category>end-to-end</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
        <tag>end-to-end</tag>
      </tags>
  </entry>
  <entry>
    <title>Learning to Evaluate Image Captioning</title>
    <url>/2020/05/09/Learning-to-Evaluate-Image-Captioning/</url>
    <content><![CDATA[<h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><p>本文提出一个可学习的图像描述评价指标。</p>
<p><strong>Motivation</strong>: 由于当前的评价指标不是很完美，不能处理句子中存在的所有的病理行为，或者是说，当遇到某些病理行为时，则不能正常工作，比如，SPICE对字幕的语义很敏感，但往往会忽略其句法质量，SPICE倾向于对带有重复子句的长句子给予高分。每个评估指标都有其众所周知的盲点，基于规则的指标通常不灵活，无法应对新的病理病例。</p>
<p>因此本文提出，使用几种数据增强的方式，来扩展出很多的存在特征几种病理问题的对抗样本，并纳入训练过程中，使得训练出来的评价指标对于这些对抗样本更加的鲁棒。（即，可以识别出这些对抗样本的能力）</p>
<h4 id="How-to-Use-the-Proposed-Metric-in-Practice"><a href="#How-to-Use-the-Proposed-Metric-in-Practice" class="headerlink" title="How to Use the Proposed Metric in Practice"></a>How to Use the Proposed Metric in Practice</h4><p>由于涉及到需要学习 ，则评价指标的训练的数据分布 与 被测试的captioning dataset 之间存在差异。</p>
<p>本文解决: 假设要评估 coco  <strong>test</strong> captioning, 则将该份submission 分成两半，一半用于scratch 训练该评价指标，另外一半则使用该训练好的评价指标得到得分；然后交替，则得到了所有的得分！</p>
<h4 id="Future-Work"><a href="#Future-Work" class="headerlink" title="Future Work"></a>Future Work</h4><ul>
<li>(1) One direction of future work could aim to capture the heterogeneous nature of human annotated captions and incorporate such information into captioning evaluation.  <strong>Human annotated captions 带有人的个性</strong></li>
<li>(2) Another direction for future work could be training a caption generator together with the proposed evaluation metric (discriminator) in a generative adversarial setting. <strong>captioning model 与提出的评价指标，一起生成对抗的训练</strong></li>
<li>(3) Finally, gameability is definitely a concern, not only for our learning based metric, but also for other rule-based metrics. Learning to be more robust to adversarial examples is also a future direction of learning based evaluation metrics.  <strong>对 对抗样本更加的鲁棒，是基于学习的评价指标的一个未来的方向</strong></li>
</ul>
]]></content>
      <categories>
        <category>图像描述</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>[LightningDOT] Pre-training Visual-Semantic Embeddings for Real-Time Image-Text Retrieval</title>
    <url>/2021/03/18/LightningDOT-Pre-training-Visual-Semantic-Embeddings-for-Real-Time-Image-Text-Retrieval/</url>
    <content><![CDATA[<h2 id="1-任务"><a href="#1-任务" class="headerlink" title="1. 任务"></a>1. 任务</h2><p>本文发表在 NAACL 2021，本文要研究的内容是如何提高 <strong>Image-text retrieval 任务的计算效率。</strong></p>
<h2 id="2-存在的问题"><a href="#2-存在的问题" class="headerlink" title="2. 存在的问题"></a>2. 存在的问题</h2><p>基于预训练的跨模态模型取得了很好的进展，但是在测试阶段存在<strong>推理速度慢</strong>的问题。 主要是由于Transformer 结构中的cross-modal attention 造成的巨大的计算消耗。 这种延迟以及计算消耗使其很难在实际中应用。</p>
<p>下图可视化了近年来 ITR task 的研究进展，（a） 早期，使用CNN和RNN分别提取视觉和语言特征，然后使用dot-product 来计算similarity。 （b）后来有人提出使用faster-RCNN 和 RNN 分别提取两个模态的特征，使用使用cross-attention，最后再计算相似性。（c）随着BERT的发展，有人使用BERT扩展出 V+L BERT 模型。(d) 由于cross-modal attention 是耗时的，因此，本文中提出去掉cross-modal 这个模块。</p>
<p><img src="https://i.loli.net/2021/03/18/fdU3lxwpkZo8yuG.png" alt="image-20210318143100485" style="zoom:50%;"></p>
<h2 id="3-本文的点"><a href="#3-本文的点" class="headerlink" title="3. 本文的点"></a>3. 本文的点</h2><ul>
<li>本文希望可以重新回归到 <strong>dot-product</strong> 这个简单的操作。本文中使用dot product 来做多模态融合，而不是使用计算量的self-attention。同时，为了利用有效的多模态嵌入学习，本文在两个encoder上都使用 [CLS] token。</li>
<li><p>通过消除模态之间耗时的交叉注意力，该模型可以在推理过程中学习视觉语义嵌入而无需在每个图像-文本对之间进行广泛匹配。此外，通过消除对图像-文本对的实时计算的依赖，我们可以一次<strong>离线地独立地</strong>计算所有图像和文本嵌入，并将这些嵌入重新用作新查询的<strong>缓存索引</strong>。</p>
</li>
<li><p>LightningDOT通过预先训练<strong>三个新颖的学习目标</strong>：Visual-embedding fused MLM (namely VMLM), Semantic-embedding  fused MRM (namely SMRM) and a cross-modal retrieval objective (namely CMR).</p>
<p>前两个预训练任务（VMLM 和 SMRM）是为了确保跨模态信息可以被获取到。CMR是为了鼓励模型在预训练阶段获得多模态融合。</p>
</li>
<li><p>重新排名（re-ranking）机制</p>
</li>
</ul>
<p>Note: 本文不是从模型压缩的角度来解决问题。</p>
<h2 id="4-贡献"><a href="#4-贡献" class="headerlink" title="4. 贡献"></a>4. 贡献</h2><p>提出了一个简单有效的方法，在不牺牲accuracy 的情况下，LightningDOT 可以数千倍的加速推理时间。</p>
<p>我们的工作是在基于预训练视觉语义嵌入，实现低延迟的实时跨模式检索的第一个已知工作。</p>
<h2 id="5-Method"><a href="#5-Method" class="headerlink" title="5. Method"></a>5. Method</h2><p><img src="https://i.loli.net/2021/03/18/kASuJa8xc6hYFne.png" alt="image-20210318175408610" style="zoom: 67%;"></p>
<p>在本节中，我们介绍LightningDOT框架，该框架由两个深层的Transformer作为图像和语言编码器。我们首先介绍三个预训练任务，然后介绍从<strong>离线特征提取</strong>到<strong>在线即时检索</strong>的 <strong>推理流程（inference pipline）</strong>。</p>
<p>图像编码器得到region features: $f_{\theta_{V}}(\mathbf{v})=\mathbf{h}=\left\{\mathbf{h}_{0}, \ldots, \mathbf{h}_{N}\right\}\left(\mathbf{h}_{j} \in \mathbb{R}^{d}\right)$</p>
<p>语言编码器得到token representations: $f_{\theta_{L}}(\mathbf{w})=\mathbf{z}=\left\{\mathbf{z}_{0}, \ldots, \mathbf{z}_{T}\right\}\left(\mathbf{z}_{j} \in \mathbb{R}^{d}\right)$</p>
<p>regard the output [CLS] embedding <strong><strong style="color:red;">$h_0$</strong> as global image representation</strong>, and <strong><strong style="color:red;">$z_0$</strong>as global text representation</strong></p>
<h3 id="5-1-Model-Pre-training"><a href="#5-1-Model-Pre-training" class="headerlink" title="5.1 Model Pre-training"></a>5.1 Model Pre-training</h3><h4 id="Visual-embedding-Fused-Masked-Language-Modeling-VMLM"><a href="#Visual-embedding-Fused-Masked-Language-Modeling-VMLM" class="headerlink" title="Visual-embedding Fused Masked Language Modeling (VMLM)"></a>Visual-embedding Fused Masked Language Modeling (VMLM)</h4><p>设有M个 masked tokens</p>
<p>对于 sentence $t$ and image $i$ ， The loss function of VMLM can be formulated as:</p>
<p>$\mathcal{L}_{\mathrm{VMLM}}(t, i)=-\log P_{\theta}\left(\mathbf{w}_{\mathbf{m}} \mid \mathbf{w}_{\backslash \mathbf{m}}, i\right)$<br>$=-\frac{1}{M} \sum_{k=1}^{M} \log P_{\theta_{\mathrm{mlm}}}\left(\mathbf{w}_{\mathbf{m}_{k}} \mid \mathbf{z}_{\mathbf{m}_{k}}+\mathbf{h}_{0}\right)$</p>
<p>其中 $z$ 是 hidden state。</p>
<p>Note： 这里的 +$h_0$ 是显式的加和，而不是使用cross-modal attention.</p>
<h4 id="Semantic-embedding-Fused-Masked-Region-Modeling-SMRM"><a href="#Semantic-embedding-Fused-Masked-Region-Modeling-SMRM" class="headerlink" title="Semantic-embedding Fused Masked Region Modeling (SMRM)"></a>Semantic-embedding Fused Masked Region Modeling (SMRM)</h4><p>$\mathcal{L}_{\mathrm{SMRM}}(i, t)=\mathcal{D}_{\theta_{\mathrm{mrm}}}\left(\mathbf{v}_{\mathbf{m}}, f_{\theta_{V}}\left(\mathbf{v}_{\backslash \mathbf{m}}\right), t\right)$<br>$=\frac{1}{M} \sum_{k=1}^{M} \mathcal{D}_{\theta_{\mathrm{mrm}}}\left(\mathbf{v}_{\mathbf{m}_{k}}, \mathbf{h}_{\mathbf{m}_{k}}+\mathbf{z}_{0}\right)$</p>
<p>这里的 $\mathcal{D}_{\theta_{\mathrm{mrm}}}$ 代表两个损失，一个是使用L2 distance 的 掩码区域特征回归，另外一个是用KL散度的掩码区域分类。</p>
<h4 id="Cross-modal-Retrieval-Objective-CMR"><a href="#Cross-modal-Retrieval-Objective-CMR" class="headerlink" title="Cross-modal Retrieval Objective (CMR)"></a>Cross-modal Retrieval Objective (CMR)</h4><p>The similarity score between query t and image i is defined as:</p>
<p>$S(t, i)=\left\langle\mathbf{z}_{0}, \mathbf{h}_{0}\right\rangle$</p>
<p>损失函数：</p>
<p>$\mathcal{L}_{\mathrm{IR}}^{(t)}=-\log \frac{e^{S\left(t, i_{1}\right)}}{\sum_{k=1}^{n} e^{S\left(t, i_{k}\right)}}$</p>
<p>$\mathcal{L}_{\mathrm{TR}}^{(i)}=-\log \frac{e^{S\left(i, t_{1}\right)}}{\sum_{k=1}^{n} e^{S\left(i, t_{k}\right)}}$</p>
<p>$\mathcal{L}_{\mathrm{CMR}}(B)=\frac{1}{2 n} \sum_{k=1}^{n} \mathcal{L}_{\mathrm{TR}}^{\left(i_{k}\right)}+\mathcal{L}_{\mathrm{IR}}^{\left(t_{k}\right)}$</p>
<h3 id="5-2-Real-time-Inference"><a href="#5-2-Real-time-Inference" class="headerlink" title="5.2 Real-time Inference"></a>5.2 Real-time Inference</h3><p>以text-to-image retrieval 作为样例来介绍 real-time inference pipline：</p>
<p>（1）离线图片特征提取与编码；（2）text query 在线检索；（3）使用top-retrieval images 做在线重拍</p>
<h4 id="Offline-Feature-Extraction"><a href="#Offline-Feature-Extraction" class="headerlink" title="Offline Feature Extraction"></a>Offline Feature Extraction</h4><p>首先使用 image encoder 来处理数据集中的所有图片，并存储其 global image representation 进入索引的内存中供以后使用。</p>
<p>整个image-to-index 过程，包括 faster rcnn 提取特征 以及 image transformer encoder 都是离线处理的。</p>
<h4 id="Online-Retrieval"><a href="#Online-Retrieval" class="headerlink" title="Online Retrieval"></a>Online Retrieval</h4><p>对于 text query, 使用language encoder 提取特征，然后依次计算与每个图片的相似度。图片将会被排序。实际中，人们感兴趣的是前top-k 检索结果。</p>
<p>使用FAISS来优化检索。</p>
<p>类似地，对于文本检索，可以通过简单地为所有句子预先计算嵌入并使用图像作为查询来应用相同的体系结构</p>
<h4 id="Re-ranking"><a href="#Re-ranking" class="headerlink" title="Re-ranking"></a>Re-ranking</h4><p>为了进一步提高检索结果，本文通过采用可选的<strong>重新排名模型</strong>提出了一种两阶段方法。</p>
<p>第一阶段，使用LightingDOT来检索 top-M images(or texts)。</p>
<p>第二阶段，使用一个性能更好的检索模型（通常比较慢）来重新排序从第一阶段检索到的 top-M pairs.</p>
<p>实验证明，可以同时从性能和效率两方面受益。</p>
<h2 id="6-Experiments"><a href="#6-Experiments" class="headerlink" title="6. Experiments"></a>6. Experiments</h2><h3 id="6-1-Results-on-Flickr30K-and-COCO"><a href="#6-1-Results-on-Flickr30K-and-COCO" class="headerlink" title="6.1 Results on Flickr30K and COCO"></a>6.1 Results on Flickr30K and COCO</h3><p><img src="https://i.loli.net/2021/03/18/TpcoUY7Zjel39dM.png" alt="image-20210318175824380" style="zoom: 50%;"></p>
<ul>
<li><p>在仅使用一阶段排序的情况下：</p>
<ul>
<li>相比于不使用预训练的模型，性能上有显著提升 CAAN (SOTA method with cross-attention）</li>
<li>与使用预训练的模型相比，UNITER，性能上仅下降了一点，但是速度上有600/1900倍的提升(Flickr30K/COCO)</li>
</ul>
</li>
<li><p>使用两阶段排序：</p>
<ul>
<li>性能上相比于一阶段有提升，同时比单纯的UNITER模型有 46-95倍速度的提升，</li>
</ul>
</li>
</ul>
<h3 id="6-2-Speed-amp-Space-Improvement"><a href="#6-2-Speed-amp-Space-Improvement" class="headerlink" title="6.2 Speed &amp; Space Improvement"></a>6.2 Speed &amp; Space Improvement</h3><ul>
<li><p>检索图像，比较推理速度差异</p>
<p>以 UNITER_base 作为比较对象。</p>
<p>SCAN，是一个不使用预训练的模型，但是采用了cross-modal attention.</p>
<p><img src="https://i.loli.net/2021/03/18/umlFqkgLfyKQ6Cx.png" alt="image-20210318180604083" style="zoom: 33%;"></p>
</li>
<li><p>扩大搜索池，性能仍然很好</p>
<p><img src="https://i.loli.net/2021/03/18/jelLQRdcFwWpaEU.png" alt="image-20210318180918374"></p>
</li>
</ul>
<h3 id="6-3-Ablation-Studies"><a href="#6-3-Ablation-Studies" class="headerlink" title="6.3 Ablation Studies"></a>6.3 Ablation Studies</h3><ul>
<li><p>观察各个模块的作用</p>
<p>(1) 【R-CNN only】不使用 image encoder, 直接使用 faster rcnn 提取的特征</p>
<p>(2)【 “+Image Encoder”】</p>
<p>(3)【+PT】 MLM+MRM+CMR 上预训练， 注意本文采用的预训练方案是 VMLM+SMRM+CMR</p>
<p><img src="https://i.loli.net/2021/03/18/ewAYK8M6idSBvEb.png" alt="image-20210318181810013" style="zoom: 33%;"></p>
<p><strong style="color:blue;">yaya: 其实，本文提出的预训练任务带来的提升并不明显。</strong></p>
</li>
<li><p>观察各个预训练任务的作用</p>
<p><img src="https://i.loli.net/2021/03/18/OkTcr9IVbxYBPgu.png" alt="image-20210318182135676" style="zoom: 50%;"></p>
<p>预训练任务对于本文提出的模型是有提升的，但是，提升的显著性似乎没有那么大。</p>
<p><strong style="color:blue;">yaya: 奇怪，为什么 这个 PT(ALL) 与 上个表Table 4 中的LightingDOT结果 不一致呢都？都是在Flickr30k validation上的结果</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>cross-modal</category>
        <category>Image-Text Retrieval</category>
        <category>real time</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
        <tag>Image-Text Retrieval</tag>
        <tag>real time</tag>
      </tags>
  </entry>
  <entry>
    <title>MDETR - Modulated Detection for End-to-End Multi-Modal Understanding</title>
    <url>/2021/07/07/MDETR-Modulated-Detection-for-End-to-End-Multi-Modal-Understanding/</url>
    <content><![CDATA[<h2 id="研究内容"><a href="#研究内容" class="headerlink" title="研究内容"></a>研究内容</h2><p>将目标检测与下游任务结合起来，端到端的训练</p>
<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p><code>物体检测</code>构成了大多数最先进的<code>多模式理解系统</code>的一个组成部分，通常作为一个黑箱来检测图像中的<code>固定概念词汇</code>。 这种流行的使用目标检测的方法没有考虑到下游的多模态理解任务，而且往往是性能的瓶颈。</p>
<p>此外，目标检测模型通常被冻结。这不仅阻碍了模型感知能力的进一步完善，而且还限制了它只能接触到检测到的物体，而不是整个图像。 这种 “流水线 “式的方法限制了与其他作为上下文的模态的共同训练。 在视觉语言设置中，它意味着 resulting system 的词汇限制在检测器的类别和属性上。 因此，这样的系统不能识别可以用自由格式文本表达的新概念组合。</p>
]]></content>
      <categories>
        <category>cross-modal</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
      </tags>
  </entry>
  <entry>
    <title>[MDMMT] Multidomain Multimodal Transformer for Video Retrieval</title>
    <url>/2021/03/22/MDMMT-Multidomain-Multimodal-Transformer-for-Video-Retrieval/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Masked Non-Autoregressive Image Captioning</title>
    <url>/2021/06/06/Masked-Non-Autoregressive-Image-Captioning/</url>
    <content><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>以 Non-Autoregressive 的方式来做 Image Captioning</p>
<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><ul>
<li><p>自回归的方式做生成任务存在的问题</p>
<p>自回归解码导致了一些问题，如连续的错误积累、生成缓慢、不恰当的语义和缺乏多样性。 </p>
<p><strong>顺序解码很容易从训练数据中 copy tokens 来提高语法准确性</strong>，这很容易造成语义错误，而且在图像字幕的生成方面缺乏多样性。</p>
</li>
<li><p>非自回归的方式</p>
<p>非自回归解码已被提出来解决神经机器翻译（NMT）的生成速度较慢的问题。但直接应用到多模态描述生成任务上不是很直接：由于对真实目标分布的间接建模，不可避免地引入了另一个问题，被称为 “多模态问题”。</p>
<p>多模态问题【网络】：一种特殊的<strong>问题</strong>，其中不存在唯一的全局解决方案。可以在搜索空间周围找到多个全局优化或一个具有多个局部优化（或峰值）的全局优化。即，一对多问题。</p>
<p>多模态问题【本文】：完全的条件独立会导致对真实目标分布的近似度低。complete conditional independence results in the poor approximation to the true target distribution。</p>
</li>
</ul>
<h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><p>本文提出 masked non-autoregressive decoding 来解决 自回归解码 和 非自回归解码 中存在的问题。</p>
<ul>
<li><p>训练阶段</p>
<p>对于输入句子，以几种 （K） 比例进行掩码。</p>
</li>
<li><p>在推理阶段</p>
<p>在推理过程中，从一个<strong>完全被掩盖</strong>的序列到一个<strong>完全没有被掩盖</strong>的序列，以一种合成的方式，分几个 （K） 阶段平行地生成字幕。</p>
</li>
</ul>
<p>实验证明，我们提出的模型可以更有效地保留语义内容，并可以生成更多样性的标题。</p>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p><img src="https://i.loli.net/2021/06/06/GagfcOSPqskTiEW.png" alt="image-20210606152813892"></p>
<h3 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h3><p>使用CNN提取的特征图，或者是 使用目标检测器检测得到的 object features.</p>
<h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><p>与传统的Tansformer 来做seq-to-seq 是一样的，只是移去了 decoder的 autoregressive mask ， 即decoder 中的每个token，是双向attention。</p>
<h3 id="Masked-non-autoregressive-decoding"><a href="#Masked-non-autoregressive-decoding" class="headerlink" title="Masked non-autoregressive decoding"></a>Masked non-autoregressive decoding</h3><p>如图1</p>
<p>训练阶段，以 K 种比例进行掩码，比如 K = [1, 0.6, 0.2],其中 k=1, 代表全部掩码</p>
<p>测试阶段，使用 K stage，从全部掩码到部分掩码，来一步一步的优化caption。</p>
<details>
<summary>细节-增强鲁邦性</summary>
我们还以一定比例的随机词来替代 [MASK] token 或 ground-truth token。 在我们的实验中，由于标题的长度相对较短，我们只是在每个非完全屏蔽的输入序列中用一个随机的词替换一个词。 使用随机词可以增强标记的上下文表示，并通过在训练期间引入噪声标记来提高推理过程的稳健性，因为模型在推理的早期阶段很容易产生错误的标记。
</details>




<h3 id="作者分析"><a href="#作者分析" class="headerlink" title="作者分析"></a>作者分析</h3><p>我们提供了更多的分析和讨论，关于模型在不同比例的掩蔽序列中所学习的内容，以及模型在推理过程中不同阶段的预测。 我们进一步讨论了自回归和屏蔽式非自回归解码之间的内在差异。</p>
<ul>
<li><p>在训练阶段</p>
<ul>
<li>掩码的比例大时，会输出视觉单词</li>
<li>掩码的比例小时，会对语法进行修正</li>
</ul>
</li>
<li><p>在测试阶段</p>
<p>在推理过程中，the masked non-autoregressive 解码过程很好地反映了模型在训练过程中所学习的内容。 在早期阶段，该模型倾向于在语言组织较差的图像中生成包含高频率（如 “a”、”on”）和突出的视觉线索（如物体、颜色名词和重要动词）的caption，而在后期阶段，该模型可以通过采用训练好的双向语言模型来选择最合适的词来连接子序列的两边，从而生成语义和语法上正确的标题。 如图1 </p>
</li>
<li><p>自回归和屏蔽式非自回归解码之间的内在差异</p>
<p>在推理过程中，自回归解码和掩码非自回归解码的区别在于掩码非自回归解码自然接近人类的语言生成。更具体地说，人类首先在大脑中生成视觉场景的关键词，然后选择其他词来连接不同的部分，并按照语言规则组成整个句子。这是一个<strong>先视觉再语言</strong>的生成过程，视觉信息奠定了字幕的基础，语言信息辅助以组合的方式而不是顺序的方式形成最终的字幕，这样会更好地保留有意义的语义信息。<strong>掩码非自回归解码一步生成整个句子，因此前面标记的质量不会显着影响后面的标记，这从根本上缓解了自回归解码中存在的顺序错误累积</strong>。相比之下，自回归解码是一个从左到右逐字的生成过程，因此后面步骤生成的标记在很大程度上取决于前面步骤的标记，一旦前面的标记不合适，就容易出现顺序错误累积。更糟糕的是，它只有一次机会生成整个标题，而无法调整前面不适当的标记。因此，自回归解码在保持流畅性方面相当不错，但难以准确说出图像丰富的显着语义内容。</p>
</li>
</ul>
<h2 id="Inference-rules"><a href="#Inference-rules" class="headerlink" title="Inference rules"></a>Inference rules</h2><ul>
<li><p>推理阶段每个 stage, 如何确定mask 哪些token？或者保留哪些token ?</p>
<p><strong>保留信息量最大的 token</strong> 并屏蔽每个阶段生成的字幕中的其他位置以生成新的屏蔽输入序列至关重要。</p>
<p>在本文中，我们采用了一种直接的方法。在这种方法中，在这种方法中，那些不包括在高频率的标记集中的 tokens (tf-idf的思想) ，以及具有高概率且与迄今所选标记不重复的 tokens ，被指定为高度优先保留的 tokens 。例如，在图 <a href="https://www.arxiv-vanity.com/papers/1906.00717/#S3.F1" target="_blank" rel="noopener">1中</a>，我们保留了第一阶段输出序列的 “二”、“鸭子”、“游泳” 和“水”。此外，对最后阶段生成的 caption 进行处理，选择与之前选择的 tokens 不重复的 tokens 。 </p>
</li>
<li><p>推理阶段，caption的长度是如何确定的？</p>
<p>关于推理过程中 length of caption 的确定, 我们首先计算训练数据中的长度的分布情况，然后从这个分布中选择一个随机的长度 T 作为标题。 随后。由T个 [MASK] token 组成的序列被送入模型，这样，一个完整的标题就可以最终被解码。 另一个选择是，我们直接为所有图像设置一个固定的序列长度。 该模型将根据长度自动强制生成粗略或精细的标题，但具有类似的语义信息。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>cross-modal</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
      </tags>
  </entry>
  <entry>
    <title>Mask-Predict: Parallel Decoding of Conditional Masked Language Models</title>
    <url>/2021/06/06/Mask-Predict-Parallel-Decoding-of-Conditional-Masked-Language-Models/</url>
    <content><![CDATA[<p>Facebook发表在EMNLP 2019上的工作</p>
<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>机器翻译</p>
<h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><p>非自回归的生成方式</p>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p>这篇文章将masked language model和iterative refinement进行了结合。并提出了更精确的解码方法。</p>
<p>具体来说，在训练时，这篇文章采用了和masked language model一样的设定。即，随机mask掉目标语句中的一些单词作为decoder input，mask的策略也和Bert中的一致。而decoder output则是这些位置上被mask掉的原始单词。其中，与Bert对每个句子固定mask掉15%的单词不同的是，这篇文章中被mask单词的数目是在从1到句子长度的范围中随机选取的。这样做的好处会在decoding时显现出来。</p>
<p><img src="https://i.loli.net/2021/06/06/bBgAcQlLFVSt6Es.jpg" alt="img"></p>
<p>图二：Mask-Predict 解码示意图</p>
<p>在预测时，这篇文章提出了基于mask and predict的解码方法，是文章的主要贡献。其实在masked language model这个框架下，解码方法是水到渠成的，即每次迭代时，都在当前翻译结果上mask掉一些词，再预测这些词即可。这里有几个点需要特别考虑。一是如何决定mask掉哪些词。文中给出的解决方法是选取top k个解码时置信度最小的词，把他们mask掉再重新预测。二是如何确定mask掉多少个词，也就是如何选取k。文中给出了基于迭代次数递减的策略，即<strong>在第一次解码时，将所有位置都置为[MASK]</strong>，同时预测所有位置的词。<strong>在之后解码迭代中，按照随迭代次数线性衰减的方式确定需要mask的单词个数</strong>：</p>
<p>$n=N \cdot \frac{T-t}{T}$</p>
<p>其中N是目标语句的长度，T和t则分别是总的迭代次数和当前迭代次数。上图中展示了解码过程的一个例子。</p>
<p>上面提到对每个句子，训练时每个epoch确定被mask单词数目时都是随机从 [1，句子长度] 中选取得到的。由于在解码时，被mask单词的个数是线性递减的，即会从 [句子长度，1] 依次递减。因此，训练时这样选取被mask单词的数目可以增加模型的capacity，让模型能处理任意个单词被mask掉时的情况，从而更符合解码时的策略，减少bias并达到更好的效果。</p>
<p>在确定目标语句的长度时，这篇文章采用了与上篇文章相同的方法，即通过encoder output来预测目标语句的长度，和golden目标语句的长度作为额外的loss function单独训练。</p>
<h2 id="Results"><a href="#Results" class="headerlink" title="Results"></a><strong>Results</strong></h2><p><img src="https://i.loli.net/2021/06/06/xongXjtwZciSe42.jpg" alt="img" style="zoom:50%;"></p>
<p>从上表中可以看到，这篇文章在WMT14 En-De和WMT16 En-Ro上均达到了SOTA。但有一点存疑的是，由于文章中也采用了knowledge distillation来训练non-autoregressive模型，而其采用的autoregressive teacher模型均为比较强的模型（28.6 on WMT14 En-De and 34.28 on WMT16 En-Ro），没有控制变量采用和baseline相同效果的autoregressive teacher。而一般来说，teacher越强训练出的non-autoregressive模型也会越强，因此<strong>这篇文章良好的效果应该也有一部分是得益于其选择了较强的teacher</strong>。</p>
<p>文中也做了在WMT17 En-Zh上的实验，以及对迭代次数和mutiple length candidates的分析，这里就不一一赘述了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Iterative refinement无疑是一个改善 $O(1)$非自回归模型的良好方向，在增加了有限的复杂度（通常是 $O(10)$)的代价下，非自回归模型的翻译质量得到了大幅提高。在这个方向中， Mask-Predict这篇文章给出了一个优良的解码范例，即每次迭代并不会预测所有的单词，而是预测置信度较低的数个单词。</p>
<p>但这样的解码范例也可能并不是最优的。因为模型给出的概率上的置信度有时候并不会反应真正的翻译质量。如何证明/设计与翻译质量挂钩的解码策略也是一个值得思考的问题。</p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Memory-Attended Recurrent Network for Video Captioning</title>
    <url>/2019/07/25/Memory-Attended-Recurrent-Network-for-Video-Captioning/</url>
    <content><![CDATA[<h3 id="词频"><a href="#词频" class="headerlink" title="词频"></a>词频</h3><p>“&gt; =3”的保留</p>
<p>MSR-VTT :11K   MSVD:4K</p>
<h3 id="Attention-Decoder"><a href="#Attention-Decoder" class="headerlink" title="Attention Decoder"></a>Attention Decoder</h3><ul>
<li><p>采用SA-LSTM的结构</p>
</li>
<li><p>细节：</p>
<ul>
<li><p>==共享attention==<br>由于需要对frames_feature ==(L帧)==  与 C3D_feature ==（L帧 -&gt; L/16个特征向量）== 都进行attention，这里进行了共享attention，好处：   &lt;/br&gt;  </p>
<p>（1）将2D 和 3D 特征映射到相似的特征空间  &lt;/br&gt;</p>
<p>（2）像是一种正则化，减少了参数，避免过拟合  &lt;/br&gt;  </p>
</li>
<li><p>降维<br>将2D 和 3D 的2048维度的特征，降维到512</p>
</li>
</ul>
</li>
</ul>
<h3 id="Attended-Memory-Decoder"><a href="#Attended-Memory-Decoder" class="headerlink" title="Attended Memory Decoder"></a>Attended Memory Decoder</h3><ul>
<li><p>当前模型的不足：</p>
<ul>
<li>现有的模型在生成word的时候，只依赖于当前video的信息，而不能依赖于那些，出现过该单词的其他video的信息</li>
<li>生成下一个单词，仅依赖于video信息和当前单词，没有建模相邻两个单词之间的兼容性（没看懂）</li>
</ul>
</li>
<li><p>具体的memeory设计详见论文</p>
</li>
</ul>
<h3 id="Attention-Coherent-Loss-AC-Loss"><a href="#Attention-Coherent-Loss-AC-Loss" class="headerlink" title="Attention-Coherent Loss (AC Loss)"></a>Attention-Coherent Loss (AC Loss)</h3><ul>
<li>将C3D 输入的L帧作为1个time interval,希望对一个time interval 中的frames feature 的attention系数值相近</li>
<li>仅对frames_features 的attention 系数，计算这样的一个loss</li>
</ul>
<p><img src="https://i.loli.net/2019/07/25/5d397582d36f640160.png" alt="搜狗截图20190725172350.png" title="搜狗截图20190725172350.png"></p>
]]></content>
  </entry>
  <entry>
    <title>Maxout Networks</title>
    <url>/2019/02/27/Maxout-Networks/</url>
    <content><![CDATA[<p>本文是蒙特利尔大学信息与信息技术学院的几位大牛2013年在ICML上发表的一篇论文，提出了一种叫maxout的新模型，到目前用的比较少，可能这个算法参数个数会成k倍增加(k是maxout的一个参数)。文中提到这样命名的原因：（1）它的输出是一组输入的最大值（2）它与dropout是天然的组合。</p>
<p>文章首先肯定了dropout的意义，从音频分类到超大规模物体识别都有很好的改进，同时提出不应该把dropout作为一个适用于任意模型的轻微性能增强，而是通过直接设计一个模型来提高dropout能力，作为模型平均技术，可以获得最好的性能。</p>
<p>Dropout：</p>
<ul>
<li>dropout可以训练集成模型，它们共享参数并近似的对这些模型的预测进行了平均。它可以被当作一种通用的方法用在任何一种MLP和CNN模型中，但是在论文中，由于dropout的模型平均过程没有被证明，因而一个模型最好的性能的获得，应该通过直接设计这个模型使之可以增强dropout的模型平均的能力。使用了dropout的训练过程和一般的SGD方法完全不同。dropout在更新时使用更大的步长最有效，因为这样可以在不同的训练子集上对不同的模型有明显的影响来使得目标函数有持续的波动性，理想情况下整个训练过程就类似于使用bagging来训练集成的模型（带有参数共享的约束）。而一般的SGD更新时会使用更小的步长，来使得目标函数平滑的下降。对于深度网络模型，dropout只能作为模型平均的一种近似，显式的设计模型来最小化这种近似误差也可以提高dropout的性能。</li>
<li>dropout训练的集成模型中，所有模型都只包括部分输入和部分隐层参数。对每一个训练样本，我们都会训练一个包括不同隐层参数的子模型。dropout与bagging的相同点是不同的模型使用不同数据子集，不同点是dropout的每个模型都只训练一次且所有模型共享参数。</li>
<li>对于预测时如何平均所有子模型的问题，bagging一般使用的是算数平均，而对dropout产生的指数多个子模型则并非显而易见。但是如果模型只有一层 <img src="https://www.zhihu.com/equation?tex=p%28y+%7C+v%3B%CE%B8%29%3Dsoftmax%28v%5E%7BT%7D%2Bb%29" alt="p(y | v;θ)=softmax(v^{T}+b)">作为输出（p(y | v;θ)的几何平均），则最终的预测分布就是简单的 <img src="https://www.zhihu.com/equation?tex=softmax%28v%5E%7BT%7DW%2F2%2Bb%29" alt="softmax(v^{T}W/2+b)">，即指数多个子模型的平均预测就是完整模型的预测仅仅将权重减半而已。这个结果只能用在单softmax层的模型中，如果是深层模型如MLP，那么权重减半的方法只是几何平均的一种近似。</li>
</ul>
<p>Maxout是深度学习网络中的一层网络，就像池化层、卷积层一样等，我们可以把maxout 看成是网络的激活函数层。我们假设网络某一层的输入特征向量为：X=（x1,x2,……xd），也就是我们输入是d个神经元。Maxout隐藏层每个神经元的计算公式如下：</p>
<p><img src="https://www.zhihu.com/equation?tex=h_%7Bi%7D%3D%5Cmax_%7Bj+%5Cin+%5B1%2Ck%5D%7D%7Bz_%7Bij%7D%7D" alt="h_{i}=\max_{j \in [1,k]}{z_{ij}}"></p>
<p>上面的公式就是maxout隐藏层神经元i的计算公式。其中，k就是maxout层所需要的参数了，由我们人为设定大小。就像dropout一样，也有自己的参数p(每个神经元dropout概率)，maxout的参数是k。公式中Z的计算公式为： <img src="https://www.zhihu.com/equation?tex=z_%7Bij%7D%3Dx%5E%7BT%7DW_%7B..ij%7D%2Bb_%7Bij%7D" alt="z_{ij}=x^{T}W_{..ij}+b_{ij}"> ，权重w是一个大小为(d,m,k)三维矩阵，b是一个大小为(m,k)的二维矩阵，这两个就是我们需要学习的参数。如果我们设定参数k=1，那么这个时候，网络就类似于以前我们所学普通的MLP网络。</p>
<p>我们可以这么理解，本来传统的MLP算法在第i层到第i+1层，参数只有一组，然而现在我们不怎么干了，我们在这一层同时训练n组参数，然后选择激活值最大的作为下一层神经元的激活值。下面还是用一个例子进行讲解，比较容易搞懂。</p>
<p>（1）以前MLP的方法。<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0ldm6b5ujj30ix08mdg0.jpg"></p>
<p>其中 f 就是我们所谓的激活函数，比如Sigmod、Relu、Tanh等。</p>
<p>(2)Maxout 的方法。如果我们设置maxout的参数k=5，maxout层就如下所示：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0ldmxgg2zj30n60e33zh.jpg"></p>
<p>相当于在每个输出神经元前面又多了一层。这一层有5个神经元。<br>所以这就是为什么采用maxout的时候，参数个数成k倍增加的原因。本来我们只需要一组参数就够了，采用maxout后，就需要有k组参数。</p>
<ul>
<li>对MLP而言，2个输入节点先构成5个“隐隐层”节点，然后在5个“隐隐层”节点中使用最大的构成了本层的一个节点，本层其他节点类似。<strong>实现技巧：</strong><code>maxout</code>和<code>relu</code>唯一的区别是，<code>relu</code>使用的max(x,0)是对隐层每一个单元执行的与0比较最大化操作，而<code>maxout</code>是对5个“隐隐层”单元的值执行最大化操作。如果将“隐隐层”单元在隐层展开，那么隐层就有20个“隐隐层”单元，<code>maxout</code>做的就是在这20个中每5个取一个最大值作为最后的隐层单元，最后的隐层单元仍然为4个。这里每5个取一个最大值也称为最大池化步长（max pooling stride）为5，最大池化步长默认和“隐隐层”个数相等，如果步长更小，则可以实现重叠最大池化。实现的时候，可以将隐层单元数设置为20个，权重维度（2，20）偏置维度（1，20），然后在20个中每5个取一个最大值得到4个隐层单元。</li>
<li>对于CNN而言，假设上一层有2个特征图，本层有4个特征图，那么就是将输入的2个特征图用5个滤波器卷积得到5张仿射特征图（affine feature maps），然后从这5张仿射特征图每个位置上选择最大值（跨通道池化，pool across channels）构成一张本层的特征图，本层其他特征图类似。<strong>实现技巧：</strong><code>relu</code>使用的max(x,0)是对每个通道的特征图的每一个单元执行的与0比较最大化操作，而<code>maxout</code>是对5个通道的特征图在通道的维度上执行最大化操作。而如果把5个特征图在本层展开，那么本层就有20个特征图，<code>maxout</code>做的就是在这20个中每5个取在通道维度上的最大值作为最后的特征图，最后本层特征图仍然为4个。同样最大池化步长默认为5。实现的时候，可以将本层特征图数设置为20个，权重维度（20，2，3，3）偏置维度（1，20，1，1），然后在20个中每5个取一个最大特征图得到4个特征图。<strong>注意：</strong> 对于CNN而言，在maxout输出后如果连接一个一般的降采样最大池化层，则可以将这个降采样最大池化融合进跨通道池化中，即在仿射特征图的每个池化窗口中选择最大值（相当于同时在通道间和空间取最大值）。这样就可以在maxout网络中省略显式的降采样最大池化层。</li>
</ul>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><ol>
<li>MNIST</li>
</ol>
<p>排列不变限制的MNIST（MNIST with permutation invariant，即像素排列顺序可以改变，输入的数据是2维的），使用两个全连接maxout层再接上一个softmax层，结合dropout和权重衰减。验证集选取训练集中后10000个样本。在得到最小的验证集误差时记录下前50000个样本的训练集对数似然L，接着在整个60000样本的训练集上<strong>继续训练</strong>直到验证集的对数似然达到L。<em>0.94%</em></p>
<p>无排列不变限制的MNIST（MNIST without permutation invariant，即像素排列顺序不变，输入的数据是3维的），使用三个卷积maxout层，之后接上空间最大池化层，最后接上一个softmax层。还可以使用扩充数据集的方法进一步提高。<em>0.45%</em></p>
<p>\2. CIFAR-10</p>
<p>预处理：全局像素归一化和ZCA白化</p>
<p>过程与MNIST类似，只是将继续训练改为了<strong>重新训练</strong>，因为继续训练的学习率很低训练太久。</p>
<p>使用三个卷积maxout层，之后接上全连接maxout层，最后接上一个softmax层。<em>13.2%</em>（不使用验证集数据）<em>11.68%</em>（使用验证集数据）<em>9.35%</em>（使用平移、水平翻转的扩充数据集）</p>
<p>\3. CIFAR-100</p>
<p>超参数使用和CIFAR-10一样</p>
<p><em>41.48%</em>（不使用验证集数据）<em>38.57%</em>（使用验证集数据）</p>
<p>\4. SVHN</p>
<p>验证集为训练集每类选取400个样本和额外集每类选取200个样本，其他的为训练集。</p>
<p>预处理：局部像素归一化</p>
<p>使用三个卷积maxout层，之后接上全连接maxout层，最后接上一个softmax层（同CIFAR-10）。<em>2.47%</em></p>
<h2 id="maxout对比relu"><a href="#maxout对比relu" class="headerlink" title="maxout对比relu"></a>maxout对比relu</h2><ul>
<li>跨通道池化可以减少网络状态并减少模型所需要的参数。</li>
<li>对于maxout，性能与跨通道池化时滤波器数量有很大关系，但对relu，性能与输出单元的数量没有关系，也就是relu并不从跨通道池化中受益。</li>
<li>要让relu达到maxout的表现，需要使之具有和maxout相同数量的滤波器（即使用比原来k倍的滤波器，同样也要k倍的relu单元），但网络状态和所需要的参数也是原来的k倍，也是对应maxout的k倍。</li>
</ul>
<h2 id="模型平均"><a href="#模型平均" class="headerlink" title="模型平均"></a>模型平均</h2><ul>
<li>单层softmax有对模型进行平均的能力，但是通过观察，多层模型中使用dropout也存在这样的模型平均，只是有拟合精度的问题。</li>
<li>训练中使用dropout使得maxout单元有了更大的输入附近的线性区域，因为每个子模型都要预测输出，每个maxout单元就要学习输出相同的预测而不管哪些输入被丢弃。改变dropout mask将经常明显移动有效输入，从而决定了输入被映射到分段线性函数的哪一段。使用dropout训练的maxout具有一种特性，即当dropout mask改变时每个maxout单元的最大化滤波器相对很少变化。</li>
<li>maxout网络中的线性和最大化操作可以让dropout的拟合模型平均的精度很高。而一般的激活函数几乎处处都是弯曲的，因而dropout的拟合模型平均的精度不高。</li>
</ul>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ul>
<li>训练中使用dropout时，maxout的优化性能比relu+max pooling好</li>
<li>dropout使用更大的步长最有效，使得目标函数有持续的波动性。而一般的SGD会使用更小的步长，来使得目标函数平滑的下降。dropout快速的探索着许多不同的方向然后拒绝那些损害性能的方向，而SGD缓慢而平稳的朝向最可能的方向移动。</li>
<li>实验中SGD使得relu饱和在0值的时间少于5%，而dropout则超过60%。由于relu激活函数中的0值是一个常数，这就会阻止梯度在这些单元上传播（无论正向还是反向），这也就使得这些单元很难再次激活，这会导致很多单元由激活转变为非激活。而maxout就不会存在这样的问题，梯度在maxout单元上总是能够传播，即使maxout出现了0值，但是这些0值是参数的函数可以被改变，从而maxout单元总是激活的。单元中较高比例的且不易改变的0值会损害优化性能。</li>
<li>dropout要求梯度随着dropout mask的改变而明显改变，而一旦梯度几乎不随着dropout mask的改变而改变时，dropout就简化成为了SGD。relu网络的低层部分会有梯度衰减的问题（梯度的方差在高层较大而反向传播到低层后较小）。maxout更好的将变化的信息反向传播到低层并帮助dropout以类似bagging的方式训练低层参数。relu则由于饱和使得梯度损失，导致dropout在低层的训练类似于一般的SGD。</li>
</ul>
<h2 id="总结文中的点"><a href="#总结文中的点" class="headerlink" title="总结文中的点"></a>总结文中的点</h2><ul>
<li>单个<code>maxout</code>激活函数可以理解成一种分段线性函数来近似任意凸函数（任意的凸函数都可由分段线性函数来拟合）。它在每处都是局部线性的（k个“隐隐层”节点都是线性的，取其最大值则为局部线性，分段的个数与k值有关），而一般的激活函数都有明显的曲率。</li>
<li>如同MLP一样，maxout网络也可以拟合任意连续函数。只要<code>maxout</code>单元含有任意多个“隐隐层”节点，那么只要两个隐层的maxout网络就可以实现任意连续函数的近似。</li>
<li>maxout网络不仅可以学习到隐层之间的关系，还可以学习到每个隐层单元的激活函数。</li>
<li>maxout放弃了传统激活函数的设计，它产生的表示不再是稀疏的，但是它的梯度是稀疏的，且dropout可以将它稀疏化。</li>
<li>maxout没有上下界，所以让它在某一端饱和是零概率事件。</li>
<li>如果训练时使用dropout，则dropout操作在矩阵相乘之前，而并不对<code>max</code>操作的输入执行dropout。</li>
<li>使用maxout会默认一个先验：样本集是凸集可分的。</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Memory Enhanced Embedding Learning for Cross-Modal Video-Text Retrieval</title>
    <url>/2021/04/02/Memory-Enhanced-Embedding-Learning-for-Cross-Modal-Video-Text-Retrieval/</url>
    <content><![CDATA[<h2 id="本文研究的任务"><a href="#本文研究的任务" class="headerlink" title="本文研究的任务"></a>本文研究的任务</h2><ul>
<li>视频文本跨模态检索</li>
</ul>
<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>本文提出的问题其实也是度量学习中的一个关键问题，对于一个anchor, 为了在一个mini-batch中看到更多的负样本，一个简单的方法是扩大batch size，计算量就提升了。</p>
<p>针对此问题，有人提出了 memory bank, 将整个训练集中的样本特征预先提取出来，存储起来，每个epoch更新一次。Memory Bank 虽然可以保留足够多的样本进行 negative采样，但是其中存储的图像特征都是过去的 encoder 编码的特征。由于 Memory Bank 容量很大，导致了采样的特征具有不一致性（是由不同的encoder产生的）。</p>
<h3 id="MOCO"><a href="#MOCO" class="headerlink" title="MOCO"></a>MOCO</h3><p>鉴于此，MoCo 使用一个队列来存储和采样 negative 样本，队列中存储多个<strong>近期</strong>用于训练的 batch 的特征向量。队列容量要远小于 Memory Bank，但可以远大于 batch 的容量。本文提出了将队列作为一个动态的，而非静态的 Memory Bank。队列在不断的进行更新，新的训练batch入队列后，最老的训练batch 出队列。这里入队列的并不是图像本身，而是图像特征。</p>
<p>训练时, Anchor 样本记为 $x^{q}$ (query), 经过 encoder 网络 $f_{q}$ 进行编码得到 $q=f_{q}\left(x^{q}\right)$<br>o 随后从队列中采样了 $K+1$ 个样本 $\left\{k^{0}, \ldots, k^{K}\right\}$ 作为key。这些 key 是用不同的队列 encoder 网络 $f_{k}$ 进行编码得到的。由于 $f_{k}$ 的变化非常缓慢, 因此虽然 $\left\{k^{0}, \ldots, k^{K}\right\}$ 是通 过不同 encoder 编码的，编码器导致的差异会非常小。具体的，本文使用一种 Momentum 更新 的方式来更新 $f_{k},$ 其参数是对 Query Encoder 的平滑拷贝：<br>$\theta_{k}=m \theta_{k}+(1-m) \theta_{q}$<br>其中 $m=0.999,$ 表示 $\theta_{k}$ 呈现一种缓慢的变化。这种更新方式类似于 Q-learning 中 target-Q冈络更新。</p>
<p>下图形式化的表示了三种结构, end-to-end, memory-bank和MoCo的区别。MoCo的特点 是: $\quad(1)$ 用于 negative 采样的队列是动态的 (2) 用于 negative 样本特征提取的编码器与用于 query提取的编码器不一致，是一种Momentum更新的关系。而在memory-bank中两个编码器 是一致的。 (3) 与Memory Bank类似, NCE 产生的损失并不影响 $f_{k},$ 只影响 $f_{q}$ 。原因是 $x^{k}$ 样本一般是 $x^{q}$ 样本的几倍, 更新 $f_{k}$ 的代价很大（例如在 end-to-end中 $),$ 因此 Memory-Bank 和 MoCo 都不更新 $f_{k}$ 。</p>
<p><strong>在实验中，大的动量（例如0.999）往往效果好于小的动量（例如0.9），意味着缓慢变化的key encoder是利用好队列的关键所在。</strong></p>
<p><img src="https://i.loli.net/2021/04/02/ymTscqK8Q5Fpkua.png" alt="image-20210402122243715"></p>
<h2 id="本文的方法"><a href="#本文的方法" class="headerlink" title="本文的方法"></a>本文的方法</h2><ul>
<li>基于此思想，本文提出了用于跨模态检索任务中的 mementum cross-modal memory bank。</li>
</ul>
<h2 id="启发"><a href="#启发" class="headerlink" title="启发"></a>启发</h2><p>相关领域的知识是可以互相借鉴的。</p>
<p>跨模态检索领域，是可以从<strong>对比学习的无监督视觉表达学习</strong>，<strong>度量学习</strong>，等任务中借鉴的。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>MOCO： <strong>Momentum</strong> contrast for unsupervised visual representation learning</p>
<p><strong>InfoNCE</strong>: Representation learning with <strong>contrastive</strong> predictive coding.</p>
]]></content>
      <categories>
        <category>cross-modal</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
      </tags>
  </entry>
  <entry>
    <title>Motion Guided Spatial Attention for Video Captioning</title>
    <url>/2019/07/28/Motion-Guided-Spatial-Attention-for-Video-Captioning/</url>
    <content><![CDATA[<h3 id="当前的问题"><a href="#当前的问题" class="headerlink" title="当前的问题"></a>当前的问题</h3><ul>
<li>spatial attention 很少有人去探索</li>
<li>motion information 被利用通常是使用3D-CNNs来作为另外一种模态</li>
</ul>
<h3 id="本文的工作"><a href="#本文的工作" class="headerlink" title="本文的工作"></a>本文的工作</h3><ul>
<li>两个贡献： MGSA、GARU</li>
<li>The proposed MGSA utilize motion information between consecutive frames by applying CNN to stacked optical flows. </li>
<li>In addition, a gated recurrent unit named GARU is designed to adaptively relate spatial attention maps across time.<br><img src="https://i.loli.net/2019/07/28/5d3d877e9c0d546970.png" alt="搜狗截图20190728193057.png" title="搜狗截图20190728193057.png">    </li>
</ul>
<h3 id="Encoder-部分我的理解"><a href="#Encoder-部分我的理解" class="headerlink" title="Encoder 部分我的理解"></a>Encoder 部分我的理解</h3><ul>
<li>对一个video 采取N帧，对这N帧提取appearences feature，得到<code>N*H*W*D</code>的特征向量</li>
<li>以每帧为中心，采取连续的M帧，这M帧计算optical flow，并将这个<code>N*M</code>帧的optical flow images送入CNN中，得到<code>N*H*W*1</code>的特征向量。</li>
<li>==构造一个长度为N的GRU时域序列，每次送入一帧==  appearence feature 和 optical flow cnn feature，并得到一个输出,维度为<code>H*W</code>，</li>
<li>该输出作为一个attention系数，并与 ==当前帧== frame feature 相乘。得到一个为该帧的每个像素点（<code>H*W</code>）分配的权重系数。即进行加权求和，则可以得到该帧的spatial attention</li>
</ul>
<h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><p><img src="https://i.loli.net/2019/07/28/5d3d87b91afaa36288.png" alt="搜狗截图20190728193156.png" title="搜狗截图20190728193156.png" width="440px" height="400px">    </p>
<h3 id="Experimental-results"><a href="#Experimental-results" class="headerlink" title="Experimental results"></a>Experimental results</h3><ul>
<li>这里只是想提一点，就是有一些论文在MSR-VTT上的实验结果，是使用了==音频信息==。<br><img src="https://i.loli.net/2019/07/28/5d3d80835814750581.png" alt="搜狗截图20190728190107.png" title="搜狗截图20190728190107.png"></li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><p>基于 spatial attention的 video captioning model</p>
</li>
<li><p>Li, X.; Zhao, B.; and Lu, X. 2017. MAM-RNN: multi-level attention model based RNN for video captioning. In IJCAI, 2208–2214. </p>
</li>
<li><p>Yang, Z.; Han, Y.; and Wang, Z. 2017. Catching the temporal regions-of-interest for video captioning. In ACM MM, 146–153. attention, spatial. </p>
</li>
</ul>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>Multi-task Collaborative Network for Joint Referring Expression Comprehension and Segmentation</title>
    <url>/2020/03/30/Multi-task-Collaborative-Network-for-Joint-Referring-Expression-Comprehension-and-Segmentation/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>Multi-Label Image Recognition with Graph Convolutional Networks</title>
    <url>/2019/08/02/Multi-Label-Image-Recognition-with-Graph-Convolutional-Networks/</url>
    <content><![CDATA[<h3 id="Motivation：建模-label-之间的依赖"><a href="#Motivation：建模-label-之间的依赖" class="headerlink" title="Motivation：建模  label 之间的依赖"></a>Motivation：建模  label 之间的依赖</h3><ul>
<li>使用GCN来建模label之间的依赖</li>
<li>有向图</li>
<li>每个节点用 label 的词向量来表达</li>
</ul>
<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><h4 id="GCN"><a href="#GCN" class="headerlink" title="GCN"></a>GCN</h4><ul>
<li><p>GCN 的输入：GCN 的 输入是label的word embedding，使用预训练的glove vector，如果label 是含有多个词的，那么对这多个词的词向量取平均，</p>
</li>
<li><p>GCN的输出<code>C*D</code>是为了得到一个分类器，<code>C</code>是类别数，<code>D</code>是image representation的维度，</p>
</li>
<li><p>邻接矩阵：a<sub>ij</sub>用条件概率来表示：当label<sub>i</sub>出现时，label<sub>j</sub>出现的概率，因此这不是一个对称矩阵，具体地论文中还给出了更加细节的修改。</p>
</li>
</ul>
<h4 id="image-representation"><a href="#image-representation" class="headerlink" title="image representation"></a>image representation</h4><ul>
<li>使用 ResNet101 得到 conv5层的输出，再经过全局池化得到一个<code>D</code>维度的特征向量</li>
</ul>
<h4 id="multi-label-classifier"><a href="#multi-label-classifier" class="headerlink" title="multi-label classifier"></a>multi-label classifier</h4><ul>
<li>将上两步的输出进行矩阵相乘，就可以得到 计算的multi-label</li>
</ul>
<p><img src="https://i.loli.net/2019/08/03/cdwYEWSF9q6tk3p.png" alt="搜狗截图20190802221229.png"></p>
<h3 id="不同点-vs-semi-supervised-gcn"><a href="#不同点-vs-semi-supervised-gcn" class="headerlink" title="不同点 vs semi-supervised gcn"></a>不同点 vs semi-supervised gcn</h3><p>1.</p>
<ul>
<li>不同于一般的GCN，输入节点的特征，和边，经过GCN之后，得到的是更新后的节点特征</li>
<li>本文GCN的输出<code>C*D</code>是为了得到一个分类器，<code>C</code>是类别数，<code>D</code>是image representation的维度，</li>
<li>GCN 的 输入是label的word embedding，使用预训练的glove vector，如果label 是含有多个词的，那么对这多个词的词向量取平均</li>
</ul>
<p>2.</p>
<ul>
<li>一般的GCN的邻接矩阵是预先定义好的，</li>
<li>但是本文的邻接矩阵：need to construct the <code>A</code> from scrach</li>
</ul>
]]></content>
      <categories>
        <category>图卷积网络</category>
      </categories>
      <tags>
        <tag>图卷积网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Motivation of Learning based Evaluation Metrics for Text Generation</title>
    <url>/2020/07/30/Motivation-of-Learning-based-Evaluation-Metrics-for-Text-Generation/</url>
    <content><![CDATA[<p>From : <strong>Evaluation of Text Generation: A Survey</strong></p>
<p>现在评估 text generation 的方法有三种：</p>
<p>(1) human-centric evaluation metrics, </p>
<p>(2) automatic metrics that require no training, </p>
<p>(3) machine-learned metrics. </p>
<h3 id="Human-centric-evaluation-metrics"><a href="#Human-centric-evaluation-metrics" class="headerlink" title="Human-centric evaluation metrics,"></a>Human-centric evaluation metrics,</h3><p>就是由人<strong>手工</strong>为 生成的文本进行打分，但是这种方式比较耗费人力</p>
<h3 id="Automatic-metrics-that-require-no-training"><a href="#Automatic-metrics-that-require-no-training" class="headerlink" title="Automatic metrics that require no training,"></a>Automatic metrics that require no training,</h3><ul>
<li><p>n-gram Overlap Metrics for Content Selection</p>
<ul>
<li><p>F-SCORE(F1)</p>
</li>
<li><p>BLEU</p>
</li>
<li><p>NIST</p>
</li>
<li><p>ROUGE</p>
</li>
<li><p>METEOR</p>
</li>
<li><p>HLEPOR</p>
</li>
<li><p>RIBES</p>
</li>
<li><p>CIDER</p>
</li>
</ul>
</li>
<li>Distance-Based Evaluation Metrics for Content Selection</li>
<li>n-gram-Based Diversity Metrics</li>
<li>Explicit Semantic Content Match Metrics<ul>
<li>SPICE </li>
</ul>
</li>
<li>Syntactic Similarity-Based Metrics</li>
</ul>
<h3 id="Machine-Learned-Evaluation-Metrics"><a href="#Machine-Learned-Evaluation-Metrics" class="headerlink" title="Machine-Learned Evaluation Metrics"></a>Machine-Learned Evaluation Metrics</h3><ul>
<li><p>Sentence Semantic Similarity Based Evaluation</p>
</li>
<li><p>Evaluating Factual Correctness</p>
</li>
<li>Regression-based Evaluation</li>
<li>Evaluation Models with Human Judgments</li>
<li>BERT-Based Evaluation</li>
<li>Composite Metric Scores</li>
</ul>
<p>由于语言的灵活性，GT texts 不可能覆盖所有的情况，下图展示了两个例子。在这两个任务中，给定输入，由模型生成的输出都是合理的，但它们与真实的输出不共享任何单词。</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gh954nipuej319z0k4q9z.jpg"></p>
<p>一种解决办法是使用 embedding based method，来衡量语义相似性，而非 word overlap。但是 embedding-based methods 不能解决 generated output 与 reference 语义不同的情况，如上图中 dialog 的例子。</p>
<p>在这种情况下，可以构建 machine-learned models (在 human judgment data上 进行训练) 来模拟 human judgments，进而评估output 的质量，例如事实正确性，自然性，流利性，连贯性等。</p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>[MultiSubs] A Large-scale Multimodal and Multilingual Dataset</title>
    <url>/2021/03/03/MultiSubs-A-Large-scale-Multimodal-and-Multilingual-Dataset/</url>
    <content><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="目前存在的问题"><a href="#目前存在的问题" class="headerlink" title="目前存在的问题"></a>目前存在的问题</h3><p>使用视觉信息对 language grounding 的计算模型的研究导致了许多有趣的应用，例如图像字幕，视觉问答和视觉对话。各种各样的多模态数据集（由图片和文本组成）被构建，并且用于不同的应用。大部分数据集，图像被标注了文本标签，但是没有提供应用文本或图像的上下文。</p>
<p>在 image captioning dataset 中，为每张图片标注了 sentence-level text。虽然这些句子为图片提供了strong concept，但是存在一个基本的缺点：每个 sentence-level text 将 image 看做一个整体，但是实际上，text 中的内容仅仅包含了image中的部分元素。这将使得很难学到视觉和文本中的元素的对应（correspondences between elements）。图像和文本之间的连接是多样的。比如，很难用单个句子描述整个图像或用单个图像说明整个句子。因此，为了了解单词和图像之间更好的基础（grounding），需要在图像和文本段之间建立<strong>更紧密的局部对应关系</strong>。</p>
<p>此外，文本仅限于非常特定的领域（图像描述），而图像也仅限于极少数和非常特定的对象类别或人类活动；这使得很难概括可能的现实世界场景的多样性。</p>
<h3 id="本文的解决办法"><a href="#本文的解决办法" class="headerlink" title="本文的解决办法"></a>本文的解决办法</h3><p>在本文中，提出了一个新的大规模 多模态和多语言的数据集 (MultiSubs)，可以促进 <strong style="color:red;"><strong>grounding words to images</strong> </strong>in the context of their corresponding sentences。如下图1。</p>
<p><img src="https://i.loli.net/2021/03/03/PCQZBX2DtnaFzAu.png" alt="image-20210303162030516" style="zoom: 33%;"></p>
<p>与以前的数据集相比，我们的基础单词不仅针对图像，而且还针对其在语言中的上下文用法，从而有可能对现实世界中的人类语言学习产生更深刻的见解。具体来说：（1）MultiSubs中的文本片段和图像具有更紧密的局部对应，便于学习文本片段及其对应的视觉表示之间的关联；（2）与图像字幕数据集相比，图像更通用，范围更广，并且不受特定域的限制；（3）每个给定的文本片段和句子都可以有多个图像；（4）文字包含类似于自由形式的真实世界文字的grammar ot syntax；（5）文本是多语言的，而不仅仅是单语言或双语的。</p>
<p>从电影字幕的平行语料库开始，我们提出了一种<strong>跨语言多模态消歧方法</strong>，通过利用并行多语言文本来消歧文本中单词的含义，来说明文本片段。如图2所示。</p>
<p><img src="https://i.loli.net/2021/03/03/wBsAvKgbT2LSk16.png" alt="image-20210303163357136"></p>
<p>据我们所知，目前尚未对在文本插图的上下文中对此进行探讨。我们还通过人工判断来评估数据集和 illustrated text fragments 的质量。</p>
<p>使用本文提出的MultiSubs 数据集，本文提出了两个不同的多模态任务：（1）A fill-inn-the-blank task：to guess a missing word from a sentence, with or without image(s) of the word as clues。（2）Lexical translation：在给定 source sentence 和与该source word 相关联的零个或多个图像的情况下，我们将带有句子上下文的 source word 翻译为外语中的target word。</p>
<h2 id="语料库和文本片段选择"><a href="#语料库和文本片段选择" class="headerlink" title="语料库和文本片段选择"></a>语料库和文本片段选择</h2><p><em>MultiSubs</em>基于OpenSubtitles 2016（OPUS）语料库，该语料库是从 OpenSubtitles 中获得的，涵盖了65种语言的movie subtitles。</p>
<blockquote>
<p>OpenSubtitles2016: Extracting large parallel corpora from movie and TV subtitles.</p>
<p>OpenSubtitles: Subtitles - download movie and TV Series subtitles. <a href="http://www.opensubtitles.org/" target="_blank" rel="noopener">http://www.opensubtitles.org/</a></p>
</blockquote>
<p>本文挑选了5类电影：冒险，动画，喜剧，纪录片和家庭。大多数 subtitles 是对话性的（对话）或叙事性的（故事叙事或纪录片）。进一步将字幕过滤为仅在OPUS中与来自语料库的前30种非英语语言中的至少一种字幕对接的英语字幕的子集。这样一来，总共有45,482个电影实例<em>≈</em>38M个英语句子。对于前30种语言，电影的数量从2,354到31,168不等。</p>
<p>我们的目标是选择可能“在视觉上可描绘”的文本片段，并因此可以用图像进行说明。我们首先将英语字幕通过spacy  POS （en_core_web_md）来提取名词，动词，复合名词和简单形容词名词短语。这些 text frgments 的图像可成像性评分是通过MRC心理语言学数据库PaetzoldSpecia：2016通过引导获得的 ; 对于多词短语，我们将每个单词的图像可比性得分平均，为每个未见单词分配零得分。我们 retain text fragments 的可成像性得分至少为500，这是通过人工检查单词的子集来确定的。删除掉仅出现一次的 text fragments 后，输出为一组144,168个唯一候选片段（超过1600万个实例）<em>≈</em>1100万个句子。</p>
<h2 id="Illustration-of-text-fragments"><a href="#Illustration-of-text-fragments" class="headerlink" title="Illustration of text fragments"></a>Illustration of text fragments</h2><h3 id="Cross-lingual-sense-disambiguation"><a href="#Cross-lingual-sense-disambiguation" class="headerlink" title="Cross-lingual sense disambiguation"></a>Cross-lingual sense disambiguation</h3><p>本文提出的text illustration approach 的关键直觉是：一个带有歧义的英语句子，在另外一种语言的parallel sentence 中 可能没有歧义。</p>
<p>【1】<strong>Cross-lingual word alignment</strong> </p>
<p>在选择正确的图像 to illustrate our candidate text fragments (nouns) 时，我们尝试了多达四种<em>目标</em>语言：<strong>西班牙语</strong>（<strong>ES</strong>）和<strong>巴西葡萄牙语</strong>（<strong>PT</strong>），以及<strong>法文</strong>（<strong>FR</strong>）和<strong>德文</strong>（<strong>DE</strong>）。对于每种语言，选择字幕，以使（i）每个字幕都与英语字幕对齐；（ii）每个都至少包含一个感兴趣的名词。对于英语和每个目标语言，我们在全组平行句（不管句子中是否含有候选片段）中训练 <strong><em>fast_align</em></strong> DyerEtAl：2013，以获得在两种语言中词与词之间的对齐 。<strong>这将生成一个字典，该字典将英语名词映射到目标语言中的单词。</strong>我们对此字典进行过滤，以删除不常见的目标短语（语料库的1％以下）对。我们还将目标语言中具有相同lemmas 的单词归为一组。</p>
<p>【2】<strong>Sense disambiguation</strong></p>
<p>source -&gt; target </p>
<p>将名词翻译成不同的词(in the target language) 并不一定意味着它是模棱两可的。target phrases 可以简单地是指代相同概念的同义词。因此，我们进一步尝试在target side 对同义词进行分组，同时还通过查看跨多语言语料库的对齐短语来确定正确的词义。</p>
<p>对于 word senses，我们使用<strong>BabelNet</strong> NavigliPonzetto：2012，这是一个大型语义网络和涵盖多种语言的多语言百科全书，并统一了其他语义网络。</p>
<p>为了帮助我们确定给定上下文中英语名词的正确含义，我们使用目标语言中平行句子中的对齐词来消除歧义。我们计算两个查询返回的BabelNet同义词集ID之间的交集。比如 bank(english) -&gt; banco(spanish) ，如果使用英语bank 来查询将得到 financial-bank 和river-bank，如果用西班牙语banco查询将得到 financial-bank。取这两个查询结果的交集。</p>
<p>如果仅针对一种语言对执行上述操作，则该目标语言可能不足以消除英语术语的歧义，因为该术语在两种语言中可能是歧义的。对于紧密相关的语言（例如葡萄牙语和西班牙语）尤其如此。因此，<strong>我们建议利用<em>多种</em>目标语言，以进一步提高我们消除英语单词歧义的信心</strong>。我们的假设是，更多的语言最终将允许识别单词的正确上下文。</p>
<p>更具体地说，我们研究了包含<strong>多达四种目标语言</strong>的并行句子的字幕。对于每个英语短语，我们保留所有实例之间的同义词集ID之间<strong>至少有一个交集的实例</strong></p>
<p>【3】<strong>Image Selection</strong></p>
<p>构造<em>MultiSubs</em>的最后一步是为每个歧义的英语术语分配至少一个图像，and by design the term in the aligned target language(s)。由于BabelNet通常为给定的同义词集ID提供多个图像，因此我们用与该同义词集关联的所有Creative Commons images 说明该term。</p>
<h2 id="Human-evaluation"><a href="#Human-evaluation" class="headerlink" title="Human evaluation"></a>Human evaluation</h2><p>为了定量评估我们的automated cross-lingual sense disambiguation cleaning procedure，我们收集了人类注释，<strong>以确定<em>MultiSubs</em>中的图像是否确实对预测填空任务中的遗漏单词有用</strong>。<strong>注释还可以作为任务的人工上限</strong></p>
<p>我们将注释任务设置为<em>The Gap Filling Game</em>（图 <a href="https://www.arxiv-vanity.com/papers/2103.01910/#S5.F5" target="_blank" rel="noopener">5</a>）。在此游戏中，用户尝试进行<strong>三种尝试来猜测从<em>MultiSubs</em>的句子中删除的确切单词</strong>。在<strong>第一次尝试</strong>中，游戏仅显示句子（以及遗漏单词的空白）。在<strong>第二次尝试</strong>中，游戏还会为丢失的单词提供一个图像作为线索。在第三次也是<strong>最后一次尝试</strong>中，系统将显示与缺失单词关联的所有图像。在每次尝试中，如果用户输入的单词与原始单词完全匹配，则用户将获得1.0分；否则，将按预先训练的CBOW word2vec MikolovEtAl：2013之间的余弦相似度计算得出的部分分值（介于0.0和1.0之间） 预测词和原始词的嵌入。当用户输入完全匹配的内容时，或者在用尽所有三个尝试之后（以先发生者为准），每个“转”（一个句子）都会结束。第二次和第三次尝试的得分乘以<em>惩罚因子</em>（分别为0.90和0.80），以鼓励用户尽早正确猜出该单词。用户单回合的得分是所有三个尝试中的最高分，每个用户的最终累积得分是所有带注释的句子中分的总和。该最终分数确定了游戏结束时（在预定的截止日期之后）的获胜者和亚军，他们两人都分别获得了亚马逊代金券。在游戏过程中，不会为用户提供确切的“当前最高得分”表，而是会为他们提供比其当前得分更低的所有得分的所有用户所占的百分比</p>
<h3 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h3><p>visual grounding of words</p>
<p>language grounding</p>
]]></content>
      <categories>
        <category>cross-modal</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
      </tags>
  </entry>
  <entry>
    <title>Multimodal Few-Shot Learning with Frozen Language Models</title>
    <url>/2021/07/09/Multimodal-Few-Shot-Learning-with-Frozen-Language-Models/</url>
    <content><![CDATA[<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>GTP-3, T5 给出的一些启发，在大规模数据上，以自回归的方式训练的语言模型和 prefix tunning 展示出了在<strong>小样本</strong>上学习<strong>新任务</strong>的能力。</p>
<p><strong><font color="red">本文中，我们展示出一个简单且有效的方法来迁移这种小样本学习能力到多模态的设置中（vision and language）。</font></strong> 本文中使用 image 替换纯语言模型中的前缀 prefix。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在这里，我们提出了Frozen，一种让预先训练好的语言模型获得视觉信息的方法，这种方法可以将它的小样本学习能力扩展到多模态环境中，而不改变其权重。 Frozen由一个经过训练的 <font color="red"><strong>神经网络 $\phi$​</strong> </font> 组成，将图像编码到一个<strong><font color="red">大型预训练语言模型 $\theta$ </font></strong>的单词嵌入空间中，这样语言模型就能为这些图像生成caption。 <strong>语言模型的权重保持不变</strong>，但梯度通过它进行反向传播, 从头开始训练图像编码器。</p>
<p><img src="https://i.loli.net/2021/07/09/oq9fuFkBjVCgm34.png" alt="image-20210709144031286" style="zoom:50%;"></p>
<font color="green">yaya: 由于预训练语言模型的预训练任务是自回归的生成式任务，因此，这里将其迁移到多模态任务时，也采用了image captioning 这种生成式任务。</font>

<p><img src="https://i.loli.net/2021/07/09/nDqWZCSiNExyjlk.png" alt="image-20210709144211177" style="zoom:50%;"></p>
<p>尽管Frozen是在单一的图像-文字对上训练的，但一旦训练好了，它就能对多个图像和文字的有序集合作出有效反应。 这使用户能够，例如 在评估其表现之前，用几个新的多模态任务的例子来 “提示 “它，或者在立即询问一个新的视觉类别之前 “教 “它这个类别的名称。</p>
<p>我们开发Frozen的目的不是为了在任何特定的任务上实现最大的性能，而且在许多情况下，它远远不是最先进的。 尽管如此，在没有看到这些基准所提供的少数训练实例的情况下，它在广泛的任务中的表现远远高于琐碎的基线。</p>
<p>总的来说，我们的贡献如下。 1. 我们提出了Frozen，一种模块化、可扩展和高效的方法，用于训练大型语言模型的视觉前端。 由此产生的组合模型保留了大型语言模型的所有能力，但也能以任意的顺序处理文本和图像输入。 2. 我们表明，这种模型将其快速适应任务的能力、百科全书式的知识和快速的概念结合从单纯的语言环境转移到了多模态环境中，并验证了用视觉和语言信息提示他们，严格来说比单纯用语言信息提示更有效。 3. 我们在一系列现有的和新的基准上对这些能力进行量化，为今后分析这些能力铺平道路。</p>
<h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>使用 Conceptual Captions dataset 来训练。仅仅微调$\phi$, 不微调 $\theta$。因为我们可用的图文对相比于预训练 $\theta$ 时用到的数据是相当少的。</p>
<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><p>没怎么看完，实验上，好像没有做image captioning 任务，比较奇怪。</p>
]]></content>
      <categories>
        <category>cross-modal</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
      </tags>
  </entry>
  <entry>
    <title>N-Gram模型</title>
    <url>/2020/10/27/N-Gram%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>转载：<a href="https://zhuanlan.zhihu.com/p/32829048" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32829048</a></p>
<h2 id="一、什么是n-gram模型"><a href="#一、什么是n-gram模型" class="headerlink" title="一、什么是n-gram模型"></a><strong>一、什么是n-gram模型</strong></h2><p>N-Gram是一种基于统计语言模型的算法。它的基本思想是将文本里面的内容按照字节进行大小为N的滑动窗口操作，形成了长度是N的字节片段序列。</p>
<p>每一个字节片段称为gram，对所有gram的出现频度进行统计，并且按照事先设定好的阈值进行过滤，形成关键gram列表，也就是这个文本的向量特征空间，列表中的每一种gram就是一个特征向量维度。</p>
<p>该模型基于这样一种假设，第N个词的出现只与前面N-1个词相关，而与其它任何词都不相关，整句的概率就是各个词出现概率的乘积。这些概率可以通过直接从语料中统计N个词同时出现的次数得到。常用的是二元的Bi-Gram和三元的Tri-Gram。</p>
<p>说完了n-gram模型的概念之后，下面讲解n-gram的一般应用。</p>
<h2 id="二、n-gram模型用于评估语句是否合理"><a href="#二、n-gram模型用于评估语句是否合理" class="headerlink" title="二、n-gram模型用于评估语句是否合理"></a><strong>二、n-gram模型用于评估语句是否合理</strong></h2><p>如果我们有一个由 m 个词组成的序列（或者说一个句子），我们希望算得概率 $P(w_1, w_2,…,w_m)$，根据链式规则，可得</p>
<p><img src="https://i.loli.net/2020/10/27/ye3X8vh6LcKTzjr.png" alt="image-20201027172437915"></p>
<p>这个概率显然并不好算，不妨利用马尔科夫链的假设，即当前这个词仅仅跟前面几个有限的词相关，<strong><em>因此也就不必追溯到最开始的那个词，这样便可以大幅缩减上述算式的长度\</em></strong>。即</p>
<p><img src="https://i.loli.net/2020/10/27/XjDPInlQY9GN7ZU.png" alt="image-20201027172458291" style="zoom: 67%;"></p>
<p><strong><em>这个马尔科夫链的假设为什么好用？我想可能是在现实情况中，大家通过真实情况将n=1，2，3，….这些值都试过之后，得到的真实\</em></strong>的效果和时间空间的开销权衡之后，发现能够使<strong><em>用。\</em></strong></p>
<p>下面给出一元模型，二元模型，三元模型的定义：</p>
<p>当 n=1, 一个一元模型（unigram model)即为 ：</p>
<p><img src="https://i.loli.net/2020/10/27/UMNPucLtdw3zxgo.png" alt="img"></p>
<p>当 n=2, 一个二元模型（bigram model)即为 ：</p>
<p><img src="https://i.loli.net/2020/10/27/UmZkyzIK4fws7Nj.png" alt="img"></p>
<p>当 n=3, 一个三元模型（trigram model)即为</p>
<p><img src="https://i.loli.net/2020/10/27/Vr1LZIG7snCvokK.png" alt="img"></p>
<p>然后下面的思路就很简单了，在给定的训练语料中，利用贝叶斯定理，将上述的条件概率值（<strong>因为一个句子出现的概率都转变为右边条件概率值相乘了</strong>）都统计计算出来即可。下面会给出具体例子讲解。这里先给出公式：</p>
<p><img src="https://i.loli.net/2020/10/27/locAQnW9bGpXa3K.png" alt="img"></p>
<p>对第一个进行解释，后面同理,如下：</p>
<p><img src="https://i.loli.net/2020/10/27/iGbljDacPTSWu92.png" alt="image-20201027172711422"></p>
<p>下面给出具体的例子。</p>
<h2 id="三、二元语言模型判断句子是否合理"><a href="#三、二元语言模型判断句子是否合理" class="headerlink" title="三、二元语言模型判断句子是否合理\"></a><strong><em>三、二元语言模型判断句子是否合理\</em></strong></h2><p><strong><em>下面例子来自于：\</em></strong><a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/baimafujinji/article/details/51281816" target="_blank" rel="noopener">自然语言处理中的N-Gram模型详解 - 白马负金羁 - CSDN博客</a>和《北京大学 常宝宝 以及 The University of Melbourne “Web Search and Text Analysis” 课程的幻灯片素材》</p>
<p>假设现在有一个语料库，我们统计了下面的一些词出现的数量</p>
<p><img src="https://i.loli.net/2020/10/27/ufWOseUyrAm9qV3.png" alt="img"></p>
<p>下面的这些概率值作为已知条件：</p>
<p><img src="https://i.loli.net/2020/10/27/G2Y6zKZNxBCitVo.png" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-a7c0d77143e0c997abd45e1535eaeb8c_1440w.jpg" alt="img"></p>
<p>$p(want|<s>) = 0.25$</s></p>
<p>下面这个表给出的是基于Bigram模型进行计数之结果</p>
<p><img src="https://i.loli.net/2020/10/27/G2Y6zKZNxBCitVo.png" alt="img"></p>
<p><img src="https://i.loli.net/2020/10/27/az7ewSWFYZGUbIu.png" alt="img"></p>
<p>例如，其中第一行，第二列 表示给定前一个词是 “i” 时，当前词为“want”的情况一共出现了827次。据此，我们便可以算得相应的频率分布表如下。</p>
<p><img src="https://i.loli.net/2020/10/27/9WhUqaZtcC3xDn7.jpg" alt="img"></p>
<p>比如说，我们就以表中的$p(eat|i)=0.0036$这个概率值讲解，从表一得出“i”一共出现了2533次，而其后出现eat的次数一共有9次，$p(eat|i)=p(eat,i)/p(i)=count(i,eat)/count(i)=9/2533 = 0.0036$</p>
<p>下面我们通过基于这个语料库来判断$s1=“<s> i want english food</s>” $ 与 $s2 = “<s> want i english food</s>“$哪个句子更合理：通过例子来讲解是最人性化的，我在网上找了这么久发现这个例子最好：</p>
<p><strong>首先来判断$p(s1)$</strong></p>
<p>$P(s1)=P(i|<s>)P(want|i)P(english|want)P(food|english)P(</s>|food)$</p>
<p>=$0.25×0.33×0.0011×0.5×0.68=0.000031$</p>
<p><strong>再来求$p(s2)$</strong></p>
<p>$P(s2)=P(want|<s>)P(i|want)P(english|want)P(food|english)P(</s>|food)$</p>
<p>=$0.25×0.0022×0.0011×0.5×0.68 = 0.00000002057$</p>
<p><strong>通过比较我们可以明显发现0.00000002057&lt;0.000031,也就是说s1= “i want english food&lt;/s&gt;”更像人话。</strong></p>
<p><strong>再深层次的分析，我们可以看到这两个句子的概率的不同，主要是由于顺序i want还是want i的问题，根据我们的直觉和常用搭配语法，i want要比want i出现的几率要大很多。所以两者的差异，第一个概率大，第二个概率小，也就能说的通了。</strong></p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Multimodal Transformer for Multimodal Machine Translation</title>
    <url>/2021/02/26/Multimodal-Transformer-for-Multimodal-Machine-Translation/</url>
    <content><![CDATA[<h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><p>多模态机器翻译任务，是从其他模态中引入信息（一般是静态的图像）来提高翻译质量。先前的方法没有考虑多个模态的相对重要性，它们常常平等对待文本和图像信息，并分别编码，但是这种方式，将会导致从图像中<strong>引入许多无关的信息</strong>。</p>
<p>在本文中，提出了一个multi-modal self-attention in Transformer 来解决上述的问题。本文提出的方法能够based on text to encode vision, 从而避免了编码图像中与文本无关的信息。</p>
<h1 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h1><ul>
<li>The focus of our work is to build a powerful encoder to incorporate the information from other modality.</li>
</ul>
<p><img src="https://i.loli.net/2021/02/26/4AnNwV85DpBkqZm.png" alt="image-20210226172540508" style="zoom:50%;"></p>
]]></content>
      <categories>
        <category>cross-modal</category>
        <category>image-guided MT</category>
      </categories>
      <tags>
        <tag>cross-modal,image-guided MT</tag>
      </tags>
  </entry>
  <entry>
    <title>Neural Baby Talk</title>
    <url>/2021/03/26/Neural-Baby-Talk/</url>
    <content><![CDATA[<h2 id="当前存在的问题"><a href="#当前存在的问题" class="headerlink" title="当前存在的问题"></a>当前存在的问题</h2><p>当前的模型缺少 visual grounding，比如，不能将生成的named concept 与 image 中的pixels相关联起来。</p>
<p>模型的关注点与人类的关注点不同，并且倾向于从训练数据中copy captionings，即，得到 Hallucination Objects。 </p>
<h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><p>本文提出了两步走策略来处理图像描述任务：（1）sentence template generation （2）slot filling with object detectors。</p>
<ul>
<li>First generatesa sentence ‘template’ with slot locations explicitly tied tospecific  image  regions.</li>
<li>These  slots  are  then  filled  in  by visual  concepts  identified  in  the  regions  by  object  detectors.</li>
</ul>
<p>整个结构是端到端可微分的。</p>
]]></content>
      <categories>
        <category>image captioning</category>
      </categories>
      <tags>
        <tag>image captioning</tag>
      </tags>
  </entry>
  <entry>
    <title>NLP: 自编码 and 自回归</title>
    <url>/2020/03/24/NLP-%E8%87%AA%E7%BC%96%E7%A0%81-and-%E8%87%AA%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<ul>
<li><p><a href="https://www.infoq.cn/article/4SRM7UMVS4GdD9A90wff" target="_blank" rel="noopener">https://www.infoq.cn/article/4SRM7UMVS4GdD9A90wff</a>      </p>
</li>
<li><p>这篇博文写的不错<br><a href="https://www.infoq.cn/article/4SRM7UMVS4GdD9A90wff" target="_blank" rel="noopener">https://www.infoq.cn/article/4SRM7UMVS4GdD9A90wff</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Neural Machine Translation with universal Visual Representation</title>
    <url>/2021/03/03/Neural-Machine-Translation-with-universal-Visual-Representation/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>为了降低Multi-modal NMT对有图像标注的翻译数据集的依赖，本文提出通过建立Topic-image Lookup Table的方式更高效地利用已有图像文本数据，并且在训练和测试NMT的时候通过Image Retrieval的方式获得图像信息，从而在更大规模的数据上训练Multi-modal NMT。</p>
<p>通过Retrieval的方式来扩充数据的工作其实有很多，比如这篇：<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1904.02331" target="_blank" rel="noopener">Extract and Edit: An Alternative to Back-Translation for Unsupervised Neural Machine Translation</a>。</p>
<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p>长期以来，机器翻译都只涉及到文本之间的转换，但实际上，人的感知功能可以是“多模态”的。</p>
<p><strong>本文提出一种通用的视觉表征，将图片信息融合到机器翻译模型中。</strong></p>
<p>使用这种视觉知识融合方法，<strong>不需要额外的<strong style="color:red;">双语-图片</strong>标注数据，模型就能够在多个数据集上取得显著的效果提升。</strong></p>
<h3 id="多模态与机器翻译"><a href="#多模态与机器翻译" class="headerlink" title="多模态与机器翻译"></a><strong>多模态与机器翻译</strong></h3><p>机器翻译是两种语言间的转换，比如“A dog is playing in the snow”翻译为中文就是“小狗在雪地里玩耍”。</p>
<p>但人类理解世界不只是用文字，还有视觉、听觉等感知能力；并且<strong style="color:blue;">翻译的过程需要保持“语义”不变</strong>。比如下面的图：</p>
<p><img src="https://i.loli.net/2021/03/03/31QcdLfykOoiCEX.jpg" alt="img" style="zoom:50%;"></p>
<p>讲中文的人会说“小狗在雪地里玩耍”，而讲英文的人会说“A dog is playing in the snow”。也就是说，人们对客观世界的本质认知是相同的，只是“方法”不同，体现在语言上，就是语法上的差异。</p>
<p>为此，我们可以假设<strong style="color:blue;">在机器翻译模型中，融入这种“客观的世界知识”，比如把图片信息加入，以此期望增强翻译能力。</strong>同时考虑文本和图片，这就是一种多模态。</p>
<p>然而，过去的翻译-图片研究大都需要大量的双语-图片标注数据，这在数据上成为一个研究的瓶颈。本文针对这种情况，<strong>提出“通用的视觉表示”，<strong style="color:red;">仅用单语-图片标注数据</strong>，就能显著提高机器翻译的效果。</strong></p>
<p>本文的方法<strong>在数据集EN-RO，EN-DE，EN-FR上均有约一个BLEU值的提高</strong>，这说明了本方法的有效性。</p>
<h3 id="本文贡献"><a href="#本文贡献" class="headerlink" title="本文贡献"></a>本文贡献</h3><ul>
<li>提出一种通用的视觉表示方法，无需双语-图片标注语料；</li>
<li>该方法<strong>可以在只有文本的数据集上使用</strong>；</li>
<li>实验证明了该方法效果提升的一致性。</li>
</ul>
<h3 id="通用视觉表示"><a href="#通用视觉表示" class="headerlink" title="通用视觉表示"></a><strong>通用视觉表示</strong></h3><p>首先我们有一个单语-图片数据集 $\mathcal{S}=\{X, E\}$，也就是，其中的每条数据都是一张图片 $e$ 和对图片的描述 $X_{e}=\left\{x_{1}, \cdots, x_{I}\right\},$ 把其中的停用词去掉后得到了 $X_{e}^{\prime}=\left\{x_{1}^{\prime}, \cdots, x_{J}^{\prime}\right\}$ 。</p>
<p>然后, 对 $X_{e}^{\prime}$ 中的每个词 $x_{j},$ 计算它在整个数据集 $\mathcal{S}$ 中的TF-IDF值， 然后取 $X_{e}^{\prime}$ 中TF-IDF值最大的前 $w$个词作为这个图片 $e$ 的主题词 $T_{e}$, 也就是和图片最相关的 $w$ 个词。</p>
<p>这样一来，<strong>每个图片e都有它主题词</strong> $T_{e},$ 同时，<strong>每个词都有可能同时是多个图片的主题词</strong>。我们可以把这看成一个 “主题词-图片” 查询表，输入一个词 $t$ ，就可以在表中查询以 $t$ 为主题的所有图片 $E_{t}=\left\{e_{1}, \cdots, e_{n}\right\}$。</p>
<p>那么，现在输入一个句子，我们就可以按照同样的步骤：</p>
<p>1.去除停用词；</p>
<p>2.计算每个词的TF-IDF；</p>
<p>3.取前$w$个TF-IDF最高的词；</p>
<p>4.在查询表中找到所有对应的图片；</p>
<p>5.按照出现次数的多少排序，取出前$m$个出现次数最多的图片（因为多个词可能对应同一个图片），得到集合 $G$</p>
<p>现在，这个图片集合 $G$ 就可以认为是和输入句子对应的视觉信息，可以用它去增强翻译效果了。下图是流程示意图：</p>
<p><img src="https://i.loli.net/2021/03/03/wMeWCU7jfD4NqIO.png" alt="image-20210303203731211" style="zoom: 50%;"></p>
<h3 id="在机器翻译中融合图片信息"><a href="#在机器翻译中融合图片信息" class="headerlink" title="在机器翻译中融合图片信息"></a><strong>在机器翻译中融合图片信息</strong></h3><p>为了把图片融合进去，我们首先用一个预训练的ResNet提取图片集$G$ 的表示，然后计算 $\bar{H}=$ Self-Attention $\left(H^{L}, K_{G}, V_{G}\right)$ 与 $H=H^{L}+\lambda \bar{H}$<br>这里, $H^{L}$ 是Transformer Encoder的最后一层, $K_{G}, V_{G}$ 是用ResNet得到的图片集的表示, $\lambda$ 使用<br>sigmoid 计算。<br>在Decoder端，直接把 $H$ 送入即可。融合步骤如下所示：</p>
<p><img src="https://i.loli.net/2021/03/03/SWYB4lDXt7ysVrO.png" alt="image-20210303204216912" style="zoom:50%;"></p>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a><strong>实验</strong></h3><p>我们在三个数据集上进行实验：WMT16 En-RO, WMT14 EN-DE和WMT14 EN-FR。这三个数据集大小从小到大增加，从而在不同大小的数据集上都能验证该方法。</p>
<p>下表是在这三个数据集上的结果，++表示显著更优。</p>
<p>可以看到，和基线模型(Trans.(base/big))相比，本文的方法(+VR)在三个数据集上都能得到显著的提升，平均提升约一个BLEU值。同时，只引入了很少的参数量，这就不会使训练时间几乎不会增加。</p>
<p><img src="https://i.loli.net/2021/03/03/F8z9SReVPkuNdov.png" alt="image-20210303205316435" style="zoom:33%;"></p>
<p>下表是在数据集Multi30K上的结果，这是一个多模态数据集。可以看到，即使在多模态设置下，本文方法依旧能够取得显著结果。</p>
<p><img src="https://i.loli.net/2021/03/03/taQRuKN6ElJYbLg.png" alt="image-20210303205337060" style="zoom:33%;"></p>
<p>最后，我们来看看每个句子对应的图片集 $G$ 的大小 $m$, 和手动控制参数 $\lambda$ 的影响。下图分别是两个因素的影响结果。从图片数量来看，并不是越多的图片数量越好, 也不是越少越好,而是在 $m=5 \sim 15$ 的区间较好。这是因为， <strong>过少的图片信息不充分, 过多的图片噪声太多。</strong></p>
<p>参数$\lambda$控制的是图片信息融合的程度，可以看到，无论融合多少，效果都比不融合图片信息要好，这说明多模态是有效果的。</p>
<p>而且，手动控制它都没有模型自动学习好，这也说明模型对不同的输入句子，需要的视觉信息也是不同的。</p>
<p><img src="https://i.loli.net/2021/03/03/De8nVYPabyIrBwE.png" alt="image-20210303205616909" style="zoom:33%;"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>本文提出了一种简单、有效的多模态视觉知识融合方法——首先构建从主题词到图片的查询表，然后对输入句子找到相关的图片，然后使用ResNet提取图片信息融入到机器翻译模型中。</p>
<p>使用这种方法，可以避免对大规模双语-图片数据的依赖。实验结果也表明，这种方法可以一致地提高翻译效果。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul>
<li><p>如果要翻译单语-图片数据集中没有的语言，可以怎么做？</p>
<p>比如$S$没有日语，我们可以用一个日语的image caption模型去自动标注每个图片的描述。</p>
<p>或者可以用X-日语的机器翻译得到图片翻译后的描述；或者直接用一个现有的词典，把图片的主题词直接翻译成日语。其他方法亦可。</p>
</li>
<li><p>在融合步骤，是否可以有其他的方法进行融合？</p>
<p>另外一个简单的方法是，把ResNet得到的图片表示和句子一起，送入Encoder，再像往常一样解码。</p>
</li>
<li><p><strong>你认为本文这种方法从逻辑上是否真的有效？为什么？</strong></p>
<p>见仁见智，笔者倾向于有效，但是作用不大，因为只从模型的角度难以验证图片和文本之间语义的相关性，至于效果的提升，有可能是ResNet和Aggregate的共同结果。</p>
<p>笔者认为，可以考虑加一个图片预测描述的任务，和翻译一起学习；再将ResNet替换为普通的CNN进行实验。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>cross-modal</category>
        <category>image-guided MT</category>
      </categories>
      <tags>
        <tag>cross-modal,image-guided MT</tag>
      </tags>
  </entry>
  <entry>
    <title>Neural Motifs: Scene Graph Parsing with Global Context</title>
    <url>/2019/09/18/Neural-Motifs-Scene-Graph-Parsing-with-Global-Context/</url>
    <content><![CDATA[<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><ul>
<li>给出了一个对 repeated structures 的量化分析</li>
<li>分析显示，（1）由object label对预测 relation label是有效的，但是反之却不成立。（2）在一个image graph中会出现重复的模板（eg：大象有耳朵，大象有鼻子，  XX has YY）</li>
</ul>
<h2 id="Models"><a href="#Models" class="headerlink" title="Models"></a>Models</h2><ul>
<li>给定 object feature 和 object label 来去预测 relation label</li>
</ul>
]]></content>
      <categories>
        <category>场景图解析</category>
      </categories>
      <tags>
        <tag>场景图解析</tag>
      </tags>
  </entry>
  <entry>
    <title>Non-Autoregressive Coarse-to-Fine Video Captioning</title>
    <url>/2021/03/19/Non-Autoregressive-Coarse-to-Fine-Video-Captioning/</url>
    <content><![CDATA[<p>发表在AAAI 2021</p>
<h2 id="现在存在的问题"><a href="#现在存在的问题" class="headerlink" title="现在存在的问题"></a>现在存在的问题</h2><ul>
<li>由于自回归解码（autoregressive decoding）导致的 <strong>slow inference speed</strong> </li>
<li>由于对视觉单词的训练不充分，而使得模型更加<strong>偏向于生成泛化性句子</strong>，缺乏细节和多样性。</li>
<li>此外，具有误差累积倾向的模型产生令人满意的字幕是具有挑战性的。 因此，还需要一种<strong>支持单词修改的灵活解码范例</strong>（decoding paradigm）。</li>
</ul>
<h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><p><img src="https://i.loli.net/2021/03/22/Kyegni76dZ4kCrH.png" alt="image-20210322164100678" style="zoom:33%;"></p>
<ul>
<li>我们提出了一种具有粗略至精细 （coarse-to-fine）字幕过程的基于非自回归解码（nonautoregressive<br>decoding）的模型</li>
<li><p><strong>For achieving inference speedup</strong>：employ a bi-directional self-attention based network as our language model for achieving inference speedup</p>
</li>
<li><p><strong>For improving caption quality：</strong>propose an alternative paradigm to decompose the captioning procedure into two stages,</p>
</li>
</ul>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p><img src="https://i.loli.net/2021/06/06/K7UPsboZR35kDA8.png" alt="image-20210606171106991" style="zoom:50%;"></p>
<p>（1）使用 <code>visual word generation</code>模块，来生成视觉单词，并以此来生成 a coarse-grained sentence “template”。（2）然后 使用合适的单词来 fill the blanks in the “template” 。（3）<strong>迭代 </strong>mask并重新考虑语言模型最没有信心的一些不适当的词，以确保句子的流畅性或捕捉更多的相关细节。</p>
<h3 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h3><p>使用 pre-trained 2D/3D CNNs 提取视觉特征。</p>
<h3 id="Length-Predictor"><a href="#Length-Predictor" class="headerlink" title="Length Predictor"></a>Length Predictor</h3><p>具体看论文</p>
<p><img src="https://i.loli.net/2021/06/06/NXBbIJYkq3F1lnC.png" alt="image-20210606171252873" style="zoom:50%;"></p>
<p><img src="https://i.loli.net/2021/06/06/EtCnDsgSXVTJ1Px.png" alt="image-20210606171304819" style="zoom:50%;"></p>
<h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><p>To obtain a non-autoregressive decoder, we adopt one-layer decoder of Transformer。(1) 移去 causal mask 使用双向attention。（2）图2中的虚线部分。</p>
<p>做了两处修改：</p>
<ul>
<li>按照MLM的方式，对 GT sentence, 进行随机掩码，然后补全。</li>
</ul>
<p><img src="https://i.loli.net/2021/06/06/CpGFWMm39Tohwas.png" alt="image-20210606165623746" style="zoom:50%;"></p>
<h3 id="Visual-Word-Generation"><a href="#Visual-Word-Generation" class="headerlink" title="Visual Word Generation"></a>Visual Word Generation</h3><p>使用上文提到的decoder 来作为 visual word generation.</p>
<p>给定一个长度为 $N$ 的 ground-truth sentence $Y^{<em>}$ ， 首先构建一个相对应的 <em>*target sequence</em></em> $Y^{\text {vis }}=\left\{y_{n}^{\text {vis }}\right\}_{n=1}^{N}$ as follows:</p>
<script type="math/tex; mode=display">
y_{n}^{v i s}=\left\{\begin{array}{ll}
y_{n}^{*} & \text { if } \operatorname{POS}\left(y_{n}^{*}\right) \in\{\text { noun, verb }\} \\
{[\text { mask }]} & \text { otherwise }
\end{array}\right.</script><p>where POS(·) denotes the part-of-speech of a word. </p>
<p>the decoder 在没有任何单词信息的提示下来强制预测  $Y^{\text {vis }}$, i.e., $Y_{o b s}^{v i s}=\varnothing_{[v i s]}$ (a sequence of the same special token $[v i s]$ in practice). </p>
<p>因此 visual word generation的损失函数如下：</p>
<p><img src="https://i.loli.net/2021/06/06/ZGmOiCVTnUFj3Ww.png" alt="image-20210606171720504" style="zoom:50%;"></p>
<script type="math/tex; mode=display">
\mathcal{L}_{v i s}=-\sum_{y \in Y^{v i s}} \log p_{\theta}\left(y \mid \varnothing_{[v i s]}, R\right)</script><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p><img src="https://i.loli.net/2021/06/06/mZIgPbAlh3doQkt.png" alt="image-20210606171854039" style="zoom:50%;"></p>
<h3 id="测试（Coarse-to-Fine-Captioning）"><a href="#测试（Coarse-to-Fine-Captioning）" class="headerlink" title="测试（Coarse-to-Fine Captioning）"></a>测试（Coarse-to-Fine Captioning）</h3><ul>
<li><p>第一步： 使用 visual word generation, 生成一个粗粒度的模板： “template” Y(0)</p>
</li>
<li><p>第二步：本文引入三种解码算法，来生成细粒度的描述：Mask-Predict (MP) (Ghazvininejad et al. 2019), Easy-First (EF) and Left-to-Right (L2R)</p>
<blockquote>
<p>Ghazvininejad, M.; Levy, O.; Liu, Y.; and Zettlemoyer, L. 2019. <strong>Mask-predict: Parallel decoding of conditional masked language models</strong>. In EMNLP-IJCNLP.</p>
<p><a href="https://shiyaya.github.io/2021/06/06/Mask-Predict-Parallel-Decoding-of-Conditional-Masked-Language-Models/" target="_blank" rel="noopener">https://shiyaya.github.io/2021/06/06/Mask-Predict-Parallel-Decoding-of-Conditional-Masked-Language-Models/</a></p>
</blockquote>
</li>
</ul>
<p><img src="https://i.loli.net/2021/06/06/ZvdTOPBbFp1e5GJ.png" alt="image-20210606184525396" style="zoom:50%;"></p>
<h2 id="Other-non-autoregressive"><a href="#Other-non-autoregressive" class="headerlink" title="Other non-autoregressive"></a>Other non-autoregressive</h2><ul>
<li>Masked Non-Autoregressive Image Captioning</li>
<li>Non-Autoregressive Image Captioning with Counterfactuals-Critical Multi-Agent Learning</li>
</ul>
<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><ul>
<li>本篇论文中存在的问题：训练和测试不一致，训练时给定的observed tokens 是GT，而在测试时，给定的</li>
</ul>
<p>observed tokens 是预测得到的。</p>
]]></content>
      <categories>
        <category>cross-modal</category>
        <category>video captioning</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
        <tag>video-captioning</tag>
      </tags>
  </entry>
  <entry>
    <title>Non-Autoregressive Image Captioning with Counterfactuals-Critical Multi-Agent Learning</title>
    <url>/2021/03/26/Non-Autoregressive-Image-Captioning-with-Counterfactuals-Critical-Multi-Agent-Learning/</url>
    <content><![CDATA[<h2 id="研究内容"><a href="#研究内容" class="headerlink" title="研究内容"></a>研究内容</h2><p>图像描述任务</p>
<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>目前的图像描述任务采用自回归的方式来生成序列，如下图中上部分表示，下一个单词的生成需要依据先前生成的单词。</p>
<p>这样的方式会导致：high inference latency, which is sometimes unaffordable for real-time industrial applications</p>
<p><img src="https://i.loli.net/2021/03/26/9biELph3vmCSzY1.png" alt="image-20210326112017198" style="zoom:50%;"></p>
<h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><ul>
<li>本文提出使用非自回归的方式来生成，如上图中的下部分。但是，直接采用最朴素的方式来自回归的生成句子，并用交叉熵损失来优化，会导致生成的句子中单词之间的交互较少，几乎没有。进而导致生成的句子一致性较差。</li>
<li>因此，本文提出将 非自回归图像描述任务作为一个多智能体强化学习系统来学习。target sequence 中的位置被看做是智能体，智能体之间联合起来，一起最大化整个句子的质量。</li>
<li>具体地<ul>
<li>以当前非自回归方式生成的序列与GT caption比较得到整个句子的得分，以sentence-level的得分来作为每个智能体的得分(reward)，</li>
<li>但是这种方式会导致每个智能体的奖惩力度相同，很难学习。因此本文提出了counterfactual baseline。即将该单词去掉，计算剩下句子的得分，作为该agent的reward。</li>
<li>由于每个agent的action空间是整个词汇表（非常大），因此，仅仅考虑最大概率的k个action。</li>
</ul>
</li>
</ul>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p><img src="https://i.loli.net/2021/03/26/9trOPQS1pekXFGW.png" alt="image-20210326112702445" style="zoom: 67%;"></p>
<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><p>没有细读论文，但是大体上是使用，多智能体强化学习来做非自回归图像描述任务。</p>
<p>这种以非自回归的方式来做text generation task的出发点就是自回归的方式推理速度慢。</p>
<p>但是非自回归的方式又会导致句子的一致性较差，因此，需要考虑一些方法来弥补这一不足。考虑的方式即为论文的创新点。</p>
]]></content>
  </entry>
  <entry>
    <title>NumPy 副本和视图</title>
    <url>/2019/03/13/NumPy-%E5%89%AF%E6%9C%AC%E5%92%8C%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="NumPy-副本和视图"><a href="#NumPy-副本和视图" class="headerlink" title="NumPy 副本和视图"></a>NumPy 副本和视图</h1><p><strong>副本（赋值）</strong>是一个数据的完整的拷贝，如果我们对副本进行修改，它不会影响到原始数据，物理内存不在同一位置。</p>
<p><strong>视图（引用）</strong>是数据的一个别称或引用，通过该别称或引用亦便可访问、操作原有数据，但原有数据不会产生拷贝。如果我们对视图进行修改，它会影响到原始数据，物理内存在同一位置。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>视图（引用）一般发生在：</strong></p>
<ul>
<li>1、numpy 的切片操作返回原数据的视图。</li>
<li>2、调用 ndarray 的 view() 函数产生一个视图。</li>
</ul>
<p><strong>副本一般发生在：</strong></p>
<ul>
<li>Python 序列的切片操作，调用deepCopy()函数。</li>
<li>调用 ndarray 的 copy() 函数产生一个副本。</li>
</ul>
<h2 id="yaya-举例："><a href="#yaya-举例：" class="headerlink" title="yaya 举例："></a>yaya 举例：</h2><p><strong>视图（引用）一般发生在：</strong></p>
<ul>
<li>1、numpy 的切片操作返回原数据的视图。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>)  <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b = a[:]   <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">10</span>  <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line">print(a)   <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line"><span class="comment"># 修改b数据值，将修改原数据a的值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>)  <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b = a[:]   <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b.shape = <span class="number">2</span>,<span class="number">3</span>  <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line">print(b)  </span><br><span class="line"><span class="comment"># [[0 1]</span></span><br><span class="line"><span class="comment">#  [2 3]</span></span><br><span class="line"><span class="comment">#  [4 5]]</span></span><br><span class="line">print(a)   <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line"><span class="comment"># 修改b数据形状，不会修改原数据a的形状</span></span><br></pre></td></tr></table></figure>
<ul>
<li>2、调用 ndarray 的 view() 函数产生一个视图。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>)  <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b = a.view()   <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">10</span>  <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line">print(a)   <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line"><span class="comment"># 修改b数据值，将修改原数据a的值</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>)  <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b = a[:]   <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b.shape = <span class="number">2</span>,<span class="number">3</span>  <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line">print(b)  </span><br><span class="line"><span class="comment"># [[0 1]</span></span><br><span class="line"><span class="comment">#  [2 3]</span></span><br><span class="line"><span class="comment">#  [4 5]]</span></span><br><span class="line">print(a)   <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line"><span class="comment"># 修改b数据形状，不会修改原数据a的形状</span></span><br></pre></td></tr></table></figure>
<p><strong>副本一般发生在：</strong></p>
<ul>
<li>Python 序列的切片操作，调用deepCopy()函数。</li>
<li>调用 ndarray 的 copy() 函数产生一个副本。</li>
</ul>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><h3 id="无复制-指向同一地址"><a href="#无复制-指向同一地址" class="headerlink" title="无复制 (指向同一地址)"></a>无复制 (指向同一地址)</h3><p>简单的赋值不会创建数组对象的副本。 相反，它使用原始数组的相同id()来访问它。 id()返回 Python 对象的通用标识符，类似于 C 中的指针。</p>
<p>此外，一个数组的任何变化都反映在另一个数组上。 例如，一个数组的形状改变也会改变另一个数组的形状。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np    </span><br><span class="line">a = np.arange(<span class="number">6</span>)   </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'我们的数组是：'</span>) </span><br><span class="line"><span class="keyword">print</span> (a) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'调用 id() 函数：'</span>) </span><br><span class="line"><span class="keyword">print</span> (id(a)) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'a 赋值给 b：'</span>) </span><br><span class="line">b = a  <span class="keyword">print</span> (b) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'b 拥有相同 id()：'</span>) </span><br><span class="line"><span class="keyword">print</span> (id(b)) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'修改 b 的形状：'</span>) </span><br><span class="line">b.shape =  <span class="number">3</span>,<span class="number">2</span>   </span><br><span class="line"><span class="keyword">print</span> (b) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'a 的形状也修改了：'</span>) </span><br><span class="line"><span class="keyword">print</span> (a)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">我们的数组是：</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">调用 id() 函数：</span><br><span class="line"><span class="number">4349302224</span></span><br><span class="line">a 赋值给 b：</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">b 拥有相同 id()：</span><br><span class="line"><span class="number">4349302224</span></span><br><span class="line">修改 b 的形状：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">a 的形状也修改了：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br></pre></td></tr></table></figure>
<h3 id="视图或浅拷贝"><a href="#视图或浅拷贝" class="headerlink" title="视图或浅拷贝"></a>视图或浅拷贝</h3><p>ndarray.view() 方会创建一个新的数组对象，该方法创建的新数组的维数更改不会更改原始数据的维数。但是修改新数组的数值将会更改原始数据的数值。</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  numpy  <span class="keyword">as</span>  np  </span><br><span class="line">a = np.arange(<span class="number">6</span>)  </span><br><span class="line"><span class="keyword">print</span>  (<span class="string">'我们的数组是：'</span>)  </span><br><span class="line"><span class="keyword">print</span>  (a)  </span><br><span class="line"><span class="keyword">print</span>  (<span class="string">'调用 id() 函数：'</span>)  </span><br><span class="line"><span class="keyword">print</span>  (id(a))  </span><br><span class="line"><span class="keyword">print</span>  (<span class="string">'a 赋值给 b：'</span>)  </span><br><span class="line">b = a  <span class="keyword">print</span>  (b)  </span><br><span class="line"><span class="keyword">print</span>  (<span class="string">'b 拥有相同 id()：'</span>)  </span><br><span class="line"><span class="keyword">print</span>  (id(b))  </span><br><span class="line"><span class="keyword">print</span>  (<span class="string">'修改 b 的形状：'</span>)  </span><br><span class="line">b.shape = <span class="number">3</span>,<span class="number">2</span>  </span><br><span class="line"><span class="keyword">print</span>  (b)  </span><br><span class="line"><span class="keyword">print</span>  (<span class="string">'a 的形状也修改了：'</span>)  </span><br><span class="line"><span class="keyword">print</span>  (a)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">数组 a：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">创建 a 的视图：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">两个数组的 id() 不同：</span><br><span class="line">a 的 id()：</span><br><span class="line"><span class="number">4314786992</span></span><br><span class="line">b 的 id()：</span><br><span class="line"><span class="number">4315171296</span></span><br><span class="line">b 的形状：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">a 的形状：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br></pre></td></tr></table></figure>
<p>使用切片创建视图修改数据会影响到原始数组：</p>
<h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np   </span><br><span class="line">arr = np.arange(<span class="number">12</span>) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'我们的数组：'</span>) </span><br><span class="line"><span class="keyword">print</span> (arr) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'创建切片：'</span>) </span><br><span class="line">a=arr[<span class="number">3</span>:] </span><br><span class="line">b=arr[<span class="number">3</span>:] </span><br><span class="line">a[<span class="number">1</span>]=<span class="number">123</span> </span><br><span class="line">b[<span class="number">2</span>]=<span class="number">234</span> </span><br><span class="line">print(arr) </span><br><span class="line">print(id(a),id(b),id(arr[<span class="number">3</span>:]))</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">我们的数组：</span><br><span class="line">[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br><span class="line">创建切片：</span><br><span class="line">[  <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span> <span class="number">123</span> <span class="number">234</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>]</span><br><span class="line"><span class="number">4545878416</span> <span class="number">4545878496</span> <span class="number">4545878576</span></span><br></pre></td></tr></table></figure>
<p>变量 a,b 都是 arr 的一部分视图，对视图的修改会直接反映到原数据中。但是我们观察 a,b 的 id，他们是不同的，也就是说，视图虽然指向原数据，但是他们和赋值引用还是有区别的。</p>
<h3 id="副本或深拷贝"><a href="#副本或深拷贝" class="headerlink" title="副本或深拷贝"></a>副本或深拷贝</h3><p>ndarray.copy() 函数创建一个副本。 对副本数据进行修改，不会影响到原始数据，它们物理内存不在同一位置。</p>
<h2 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np    </span><br><span class="line">a = np.array([[<span class="number">10</span>,<span class="number">10</span>],  [<span class="number">2</span>,<span class="number">3</span>],  [<span class="number">4</span>,<span class="number">5</span>]])   </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'数组 a：'</span>) </span><br><span class="line"><span class="keyword">print</span> (a) <span class="keyword">print</span> (<span class="string">'创建 a 的深层副本：'</span>) </span><br><span class="line">b = a.copy()   </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'数组 b：'</span>) </span><br><span class="line"><span class="keyword">print</span> (b) <span class="comment"># b 与 a 不共享任何内容   </span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">'我们能够写入 b 来写入 a 吗？'</span>) </span><br><span class="line"><span class="keyword">print</span> (b <span class="keyword">is</span> a) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'修改 b 的内容：'</span>) </span><br><span class="line">b[<span class="number">0</span>,<span class="number">0</span>]  =  <span class="number">100</span>   </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'修改后的数组 b：'</span>) </span><br><span class="line"><span class="keyword">print</span> (b) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'a 保持不变：'</span>) </span><br><span class="line"><span class="keyword">print</span> (a)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">数组 a：</span><br><span class="line">[[<span class="number">10</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>]]</span><br><span class="line">创建 a 的深层副本：</span><br><span class="line">数组 b：</span><br><span class="line">[[<span class="number">10</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>]]</span><br><span class="line">我们能够写入 b 来写入 a 吗？</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">修改 b 的内容：</span><br><span class="line">修改后的数组 b：</span><br><span class="line">[[<span class="number">100</span>  <span class="number">10</span>]</span><br><span class="line"> [  <span class="number">2</span>   <span class="number">3</span>]</span><br><span class="line"> [  <span class="number">4</span>   <span class="number">5</span>]]</span><br><span class="line">a 保持不变：</span><br><span class="line">[[<span class="number">10</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>]]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>Non-Autoregressive Neural Machine Translation</title>
    <url>/2021/06/07/Non-Autoregressive-Neural-Machine-Translation/</url>
    <content><![CDATA[<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p> <a href="https://homes.cs.washington.edu/~jkasai/2020-01-28/nat/" target="_blank" rel="noopener">https://homes.cs.washington.edu/~jkasai/2020-01-28/nat/</a></p>
<p>翻译版：<a href="https://zhuanlan.zhihu.com/p/110794460" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/110794460</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本篇博客针对当前使用<strong>非自回归</strong>方式处理<strong>机器翻译</strong>任务的相关论文进行总结。</p>
<h2 id="为什么要进行非自回归机器翻译？"><a href="#为什么要进行非自回归机器翻译？" class="headerlink" title="为什么要进行非自回归机器翻译？"></a>为什么要进行非自回归机器翻译？</h2><p>最近的一系列工作提出了非自回归机器翻译的方法 (NAT, <a href="https://arxiv.org/abs/1711.02281" target="_blank" rel="noopener">Gu et al. 2018</a>) 。NAT并行生成目标单词，这与标准自动回归翻译（AT）形成对比，后者可以预测以所有先前单词为条件的每个单词。虽然AT通常在相似配置下比NAT表现更好，但是NAT通过并行计算加快了推理速度。这种非自回归生成的一个非常成功的应用是Parallel WaveNet  (<a href="https://arxiv.org/abs/1711.10433" target="_blank" rel="noopener">Oord et al. 2017</a>)，将原始自回归Wavenet的速度提高了1000倍以上，并部署在了Google助手中。从NAT快速推断得到的收益可以允许在工业界的特定延迟和预算下部署更大，更深的Transformer模型。在这篇博客文章中，我将概述有关非自回归翻译的最新研究，并讨论我认为对进一步发展而言缺失或重要的内容。</p>
<h2 id="基本问题和可能的解决方法"><a href="#基本问题和可能的解决方法" class="headerlink" title="基本问题和可能的解决方法"></a>基本问题和可能的解决方法</h2><p>生成中的<a href="https://arxiv.org/abs/1711.02281" target="_blank" rel="noopener">多模式性(Multimodality)</a>对NAT提出了根本的挑战。我们都知道语言是高度多模态的(multimodal)。举一个小例子，英文句子<code>he is very good at Japanese</code>和<code>he speaks Japanese very well</code>是日语句子<code>彼は日本語が上手です</code>的两个有效译文。但是，看起很像的两个句子：<code>he speaks very good at Japanese</code>或<code>he is very good at very well</code>则没有任何意义。我们需要知道模型提交给它自己的两种可能的翻译是哪一种，但是在条件独立的解码中很难实现这一点。并行解码打破了条件依赖性，并经常导致输出不一致。文献中的一些工作已经提出解决NAT中Multimodality问题的方法。在这里，我对提出的方法进行了概括和分类。</p>
<h3 id="1-基于迭代（Iteration-based）的方法"><a href="#1-基于迭代（Iteration-based）的方法" class="headerlink" title="1. 基于迭代（Iteration-based）的方法"></a>1. 基于迭代（Iteration-based）<strong>的方法</strong></h3><p>解决并行解码问题的一种方法是迭代地优化模型输出(<a href="https://arxiv.org/abs/1802.06901" target="_blank" rel="noopener">Lee et al., 2018</a>; <a href="https://arxiv.org/abs/1904.09324" target="_blank" rel="noopener">Ghazvininejad et al., 2019</a>; <a href="https://homes.cs.washington.edu/~jkasai/2020-01-28/nat/Ghazvininejad et al., 2019" target="_blank" rel="noopener">Gu et al. 2019</a>; <a href="https://arxiv.org/pdf/2001.05136.pdf" target="_blank" rel="noopener">Kasai et al. 2020</a>)。在此框架中，我们放弃了完全可并行化的生成，而是在<strong>每次迭代中优化了先前生成的单词</strong>。由于通常我们所需的迭代次数比输出句子中单词的数量少得多，因此与自回归模型相比，迭代方法仍可以改善等待时间。这些论文均采用不同的方法进行细化，为了更清晰地理解，您可以参考<a href="https://arxiv.org/abs/1904.09324" target="_blank" rel="noopener">Ghazvininejad et al., 2019</a>  提出的一种典型的条件屏蔽语言模型（CMLM）。在给定源文本的情况下，使用目标端的BERT-style的掩蔽语言建模目标对CMLM进行训练，在推断中，我们Mask住<em>低置信度</em>的token，并在每次迭代中对其进行更新。 <a href="https://arxiv.org/pdf/2001.05136.pdf" target="_blank" rel="noopener">Kasai et al. 2020</a> 工作提出了DisCo Transformer，该Transformer可计算出这种掩盖语言建模MLM的有效替代方案。特别地，在给定其他reference token的任意子集的情况下，可以训练DisCo Transformer来预测每个输出token。可以将其视为一次模拟多个masking。我们证明了DisCo Transformer可以减少所需的迭代次数（从而减少解码时间），同时保持转换质量。</p>
<blockquote>
<p>[1] Deterministic Non-Autoregressive Neural Sequence Modeling by Iterative Refinement</p>
<p>[2] Mask-Predict: Parallel Decoding of Conditional Masked Language Models. Marjan Ghazvininejad, Omer Levy, Yinhan Liu, Luke Zettlemoyer</p>
<p>[3] Non-autoregressive Machine Translation with Disentangled Context Transformer. Jungo Kasai,  James Cross,  Marjan Ghazvininejad, Jiatao Gu</p>
</blockquote>
<h3 id="2-比NLL更好的训练目标"><a href="#2-比NLL更好的训练目标" class="headerlink" title="2. 比NLL更好的训练目标"></a>2. 比NLL更好的训练目标</h3><p>一些工作提出了对数负似然性NLL的替代损失函数。我的直觉是使用普通NLL损失进行训练无法捕捉高度多峰分布(multimodal distributions)的表征。这在某种程度上让人联想到生成对抗网络（GAN）中的对抗损失。在图像生成中，原始的L2重建损失将使模式崩溃并产生模糊的图像，当使用NLL损失训练NAT模型时，可能会发生类似情况。拟议的替代损失函数包括NAT模型与自回归教师之间的隐藏状态的距离(<a href="https://arxiv.org/abs/1909.06708" target="_blank" rel="noopener">Li et al. 2019</a>)，Ngram词袋差 (<a href="https://arxiv.org/pdf/1911.09320.pdf" target="_blank" rel="noopener">Shao et al. 2020</a>) 和辅助正则化 (<a href="https://arxiv.org/pdf/1902.10245.pdf" target="_blank" rel="noopener">Wang et al. 2019</a>). 。与基于迭代的方法相比，这一系列方法可以并行实现一次生成，但代价是性能大大降低。</p>
<h3 id="3-精简-部分的自回归解码"><a href="#3-精简-部分的自回归解码" class="headerlink" title="3. 精简/部分的自回归解码"></a>3. 精简/部分的自回归解码</h3><p>先前的工作还提出了将轻度或部分自回归模块整合到NAT模型中的方法。 <a href="https://arxiv.org/pdf/1803.03382.pdf" target="_blank" rel="noopener">Kaiser et al. 2018</a> 生成了较短序列的潜在变量，并在顶部进行了并行单词预测。Blockwise decoding和Insertion Transformer产生的局部自回归方式一个句子 (<a href="https://arxiv.org/abs/1811.03115" target="_blank" rel="noopener">Stern et al. 2018</a>, <a href="https://arxiv.org/abs/1902.03249" target="_blank" rel="noopener">2019</a>).  <a href="https://arxiv.org/abs/1910.11555" target="_blank" rel="noopener">Sun et al. 2019</a> 在变压器输出向量之上引入了factorized CRF层，并通过波束近似(beam approximation)进行了快速自回归解码。 <a href="https://arxiv.org/abs/1911.02215" target="_blank" rel="noopener">Ran et al. 2019</a> 引入了精简自回归源端重排序模块，以促进并行目标解码。请注意，他们还使用非自回归重排序模块显示了结果，但是性能却差得多。</p>
<h3 id="4-用潜在变量建模"><a href="#4-用潜在变量建模" class="headerlink" title="4. 用潜在变量建模"></a>4. 用潜在变量建模</h3><p>我们可以在此框架中解释许多模型。例如，可以将所有以预测长度(predicted length)为条件的NAT模型视为具有潜在变量的建模。但尤其是 <a href="https://arxiv.org/abs/1909.02480" target="_blank" rel="noopener">Ma et al. 2019</a>  使用生成流技术对目标句子的复杂分布进行建模。 <a href="https://arxiv.org/abs/1908.07181" target="_blank" rel="noopener">Shu et al. 2020</a> 开发出了具有确定性推论(deterministic inference)的连续潜在变量NAT模型。</p>
<h3 id="5-从自回归模型中蒸馏"><a href="#5-从自回归模型中蒸馏" class="headerlink" title="5. 从自回归模型中蒸馏"></a>5. 从自回归模型中蒸馏</h3><p>据我所知，几乎所有表现好的NAT模型都经过自回归模型 (e.g. <a href="https://arxiv.org/abs/1711.02281" target="_blank" rel="noopener">Gu et al. 2018</a>) 的序列级知识蒸馏(<a href="https://arxiv.org/abs/1606.07947" target="_blank" rel="noopener">Kim &amp; Rush 2016</a>）训练而成。虽然较大Transformer的蒸馏也有助于自回归机器翻译，尤其是在贪婪解码的情况下，但它的作用是是较大程度上简化NAT模型 (<a href="https://arxiv.org/pdf/2001.05136.pdf" target="_blank" rel="noopener">Kasai et al. 2020</a>)。 <a href="https://arxiv.org/abs/1911.02727" target="_blank" rel="noopener">Zhou et al. 2019</a> 研究了模型容量与蒸馏数据之间的关系，表明模型容量与蒸馏数据复杂性之间存在相关性。这表明知识蒸馏可以杀死原始数据中的某些模式，从而可以更好地训练NAT模型。</p>
<h2 id="悬而未决的问题和未来目标"><a href="#悬而未决的问题和未来目标" class="headerlink" title="悬而未决的问题和未来目标"></a>悬而未决的问题和未来目标</h2><p>在这里，我重点介绍了我个人好奇的非自回归机器翻译中的开放性问题。</p>
<ul>
<li><strong>我们需要蒸馏吗？</strong>蒸馏肯定是一次性的训练成本，但是如果每次更改训练数据或语言对时都必须这样做，则蒸馏成本可能会很高。我们是否可以利用原始数据获得合理的性能？</li>
<li><strong>我们需要预测目标长度吗？</strong>我仍然发现目标长度预测很奇怪。当前的许多NAT方法都要求目标长度预测并且以这个预测的长度作为条件。虽然长度预测为我们提供了在潜在变量空间中进行搜索的机会，但长度预测会破坏生成的灵活性。</li>
<li><strong>NAT可以胜过AT吗？</strong>我们已经看到，在相同的配置下，AT的性能通常优于NAT。但是，NAT可以做得更好吗？或者更实际的说，在相同的延迟预算下，NAT是否能明显胜过AT？NAT可以使用更大的配置。</li>
<li><strong>预训练和NAT。</strong>在非自回归机器翻译中使用大规模预训练的掩蔽语言模型MLM可能比在自回归翻译中使用更容易。NAT中的解码器（例如条件屏蔽语言模型）看起来更像BERT。</li>
<li><strong>训练和推理中的隔阂(bridge)。</strong>在迭代NAT框架中，<strong><strong style="color:red;">训练和推理之间经常会出现差距</strong></strong>。For example, a conditional language model (CMLM) is trained to predict masked tokens given the other <strong>gold</strong> observed tokens. 最近一项成功的尝试是对CMLM进行SMART训练 (<a href="https://arxiv.org/abs/2001.08785" target="_blank" rel="noopener">Ghazvininejad et al. 2020</a>) ，他们训练模型以从先前的预测误差中恢复。这种方法可普及到基于迭代的NAT。</li>
<li><strong>向结构化预测学习。</strong>NLP中已经在结构化预测（例如语法和语义解析）方面投入了很多精力。我们可以从结构化预测的方法中学习以更好地处理生成中的条件依赖性吗？训练和推理之间的上述差距是句法分析中研究的一个问题 (e.g. dynamic oracle, <a href="https://www.aclweb.org/anthology/C12-1059/" target="_blank" rel="noopener">Goldberg &amp; Nivre 2012</a>)。我怀疑从结构化预测中还会吸取更多教训。</li>
</ul>
<h2 id="ACL-2021"><a href="#ACL-2021" class="headerlink" title="ACL 2021"></a>ACL 2021</h2><p>【ACL findings】Progressive Multi-Granularity Training for Non-Autoregressive  Translation<br><strong>标题</strong>：非自回归翻译的渐进式多粒度训练</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://zhuanlan.zhihu.com/p/110794460" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/110794460</a></p>
<p><a href="https://homes.cs.washington.edu/~jkasai/2020-01-28/nat/" target="_blank" rel="noopener">https://homes.cs.washington.edu/~jkasai/2020-01-28/nat/</a></p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Object Hallucination in Image Captioning </title>
    <url>/2020/03/25/Object-Hallucination-in-Image-Captioning/</url>
    <content><![CDATA[<h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><ul>
<li>当前captioning task 存在的问题<ul>
<li>当前的caption model 目前存在的问题是，生成的句子中出现的object 常常是在corresponding vision scene 中没有出现到的。</li>
<li>当前使用的评价指标只能评估 candidate caption 与 gt captions 之间的一个相似性，不能捕捉到candidate caption 与 image information之间的relevance. </li>
</ul>
</li>
</ul>
<ul>
<li>因此本文进行的一个工作：<ul>
<li>We analyze how captioning model architectures and learning objectives contribute to object hallucination, explore when hallucination is likely due to image misclassification or language priors, and assess how well current sentence metrics capture object hallucination.  </li>
</ul>
</li>
</ul>
<h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><ul>
<li><p>（一）关于 object hallucination 的四点讨论</p>
<ul>
<li><p>从人类的角度</p>
<ul>
<li>丢失对显著物体的描述是一个 failure mode，但是captions is summaries，<strong>因此一般不期待其描述出场景中的所有的objects.</strong> 另外在人类的标注数据中，也不偏向于标注出所有出现在scene 中的objects</li>
<li>研究报告表明，human judgements 比较不待见那些caption中包含了image content中未出现的 object，<strong>Correctness is more important to human judges than specificity.   </strong></li>
<li>Many visually impaired who <strong>value correctness over coverage, </strong>hallucination is an obvious concern.  </li>
</ul>
</li>
<li>从模型的角度<ul>
<li>object hallucination  揭示了caption model 存在的一个问题，可能caption model并没有对视觉场景学习到一个很好的视觉表征，而是对损失函数过拟合。</li>
</ul>
</li>
</ul>
</li>
<li><p>（二）本文要研究的问题</p>
<ul>
<li>本文研究当前captioning models中存在的object hallucination现象</li>
<li>考虑了几个关键问题：<ul>
<li>(1) <strong>Which models are more prone to hallucination?</strong>  spanning different architectures and learning objectives.   <ul>
<li>一个新的评价指标来评估object hallucination：CHAIR (Caption Hallucination Assessment with Image Relevance)  </li>
</ul>
</li>
<li>(2) <strong>What are the likely causes of hallucination?   </strong><ul>
<li>造成object hallucination这一现象的原因主要有两点：visual misclassification and over-reliance on language priors  <ul>
<li>提出：image and language model consistency scores  </li>
</ul>
</li>
</ul>
</li>
<li>(3) <strong>How well do the standard metrics capture hallucination?</strong>  <ul>
<li>当前的评价指标并不能很好的捕捉到object hallucination 这一现象。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><h5 id="CHAIR-Metric"><a href="#CHAIR-Metric" class="headerlink" title="CHAIR Metric"></a>CHAIR Metric</h5><ul>
<li>同时使用GT sentence 和 coco image segmentation这两个信息 to measure object hallucination。</li>
</ul>
<p>  <img src="http://ww1.sinaimg.cn/large/006uWRWVly1gd7d25xmjcj30h605k0te.jpg" alt="搜狗截图20200326152719.png"></p>
<h5 id="Image-Consistency"><a href="#Image-Consistency" class="headerlink" title="Image Consistency"></a>Image Consistency</h5><ul>
<li>对比 <strong>caption model 与 image (alone) model</strong> 两个模型对于预测objects 之间的一致性误差。</li>
</ul>
<h5 id="Language-Consistency"><a href="#Language-Consistency" class="headerlink" title="Language Consistency"></a>Language Consistency</h5><ul>
<li>对比 <strong>caption model 与 sentence (alone) model</strong> 两个模型对于预测下一个word 之间的一致性误差。</li>
</ul>
<h4 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h4><h5 id="Which-Models-Are-More-Prone-To-Hallucination"><a href="#Which-Models-Are-More-Prone-To-Hallucination" class="headerlink" title="Which Models Are More Prone To Hallucination?"></a>Which Models Are More Prone To Hallucination?</h5><ul>
<li>一般情况下 ，在标准的evaluation metrics 上表现性能好的模型，在CHAIR metric 上也能表现的比较好，即object hallucination现象相对较弱。但是当模型基于 cider 进行强化学习的训练之后，则不是这种一致的现象。</li>
<li>（1）使用attention 的模型更加偏向于有较低的object hallucination；NBT模型在标准的evaluation metrics 上表现性能没有topdown-BB 好，但是CHAIR性能却更好，原因在于其使用的pre-trained  detector 与 captioning dataset is in a same domain 。</li>
<li>（2）当模型基于 cider 进行强化学习的训练之后，将会增加hallucination 的数量。</li>
<li>（3）LRCN Model 比 FC Model有更多的object hallucination，说明仅仅在第一个 time step 输入视觉特征，将会产生更少的object hallucination </li>
<li>（4）the GAN loss actually helps decrease hallucination.  the GAN loss encourages sentences to be human-like。</li>
<li>（5）CE loss: beam size 5, object hallucination 会比 lower beam size 小很多；self-critical loss: beam size sometimes leads to worse performance on CHAIR.   即object hallucination 数量会更多。</li>
</ul>
<h5 id="What-Are-The-Likely-Causes-Of-Hallucination"><a href="#What-Are-The-Likely-Causes-Of-Hallucination" class="headerlink" title="What Are The Likely Causes Of Hallucination?"></a>What Are The Likely Causes Of Hallucination?</h5><ul>
<li><p>We rely on the deconstructed TopDown models to analyze the impact of model components on hallucination  </p>
<ul>
<li>通过设计的 几个 deconstructed TopDown models 的分析可以看出，使得object hallucination 数量减少的原因是：due to access to feature maps with spatial locality, not the actual attention mechanism.  </li>
<li>LRCN Model 比 FC Model 有更多的object hallucination，说明仅仅在第一个 time step 输入视觉特征，将会产生更少的object hallucination 。作者在文中对这一现象给出的解释是，在每一步都输入视觉特征 fc_feature, 而不是 spatial feature, 这将导致对视觉特征的过拟合。</li>
</ul>
</li>
<li><p>Investigate what causes hallucination using the deconstructed TopDown models and the image consistency and language consistency scores. </p>
<ul>
<li>We note that models with less hallucination tend to make errors consistent with the image model, whereas models with more hallucination tend to make errors consistent with the  language model.  这说明有更少object hallutition 的models 有更强的能力从Image 中提取知识到句子生成过程中。</li>
<li>在Robust split 上进行实验发现，所有models之间的language consistency 差异度不大；相比于 Karpathy split，相对应下的models image consistency 有所下降。这是由于 Robust split 在测试集上，会出现 novel compositions of objects at test time. 使得所有的模型有很强的language prior.</li>
</ul>
</li>
<li><p>在训练过程中，分析FC model 的image/language consistency，结果发现在训练开始，与language model 的一致性更好，随着训练的结束，与 image model 的一致性更好。这说明，模型首先学习生成流畅的语言，而后再去学习结合视觉信息。</p>
<h5 id="How-Well-Do-The-Standard-Metrics-Capture-Hallucination"><a href="#How-Well-Do-The-Standard-Metrics-Capture-Hallucination" class="headerlink" title="How Well Do The Standard Metrics Capture Hallucination?"></a>How Well Do The Standard Metrics Capture Hallucination?</h5></li>
<li><p>作者分析了 standard metric 与 CHAIRs  之间的 pearsom correlation coefficient ，结果发现 SPICE 的一致性更好。</p>
</li>
<li><p>object hallucination can not be always predicted based on the traditional sentence metrics.  </p>
</li>
<li><p><strong>与当前使用的standard metrci 互为补充，可以提升与人类评分的一致程度。</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gd8997jm24j30gi08375g.jpg" alt="搜狗截图20200327100117.png"></p>
<p>这个意思是说，第一列，单独分析各个automatic metric 与 human judgement 的一致性。第二/三列，各个评价指标分别加上1-CHs/ 1-CHi 之后再与human judgement 计算一致性。可以发现，一致性得到提升。即 <strong>CHAIR is complementary to standard metrics</strong></p>
</li>
</ul>
<h5 id="Does-hallucination-impact-generation-of-other-words"><a href="#Does-hallucination-impact-generation-of-other-words" class="headerlink" title="Does hallucination impact generation of other words?"></a>Does hallucination impact generation of other words?</h5><ul>
<li>Hallucinating objects 影响句子生成的质量，不仅是由于 object 没有被正确的预测，也是由于hallucinated word 影响到了生成的其他的words.</li>
<li>通过比较TopDown 和 TD-Restrict 生成的句子可以分析这个现象。We find that after the hallucinated word is generated, the following words in the sentence are different 47.3% of  the time.  </li>
<li>一旦一个hallucination words 被生成，则其又会由于language prior(hallucinating a “cat” leading to hallucinating<br>a “chair”  )，产生更多的hallucination words 。</li>
</ul>
<h4 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h4><ul>
<li><p>the popular self critical loss increases CIDEr score, but also the amount of hallucination. </p>
</li>
<li><p>CHAIR complements the standard sentence metrics in capturing human preference( judgements ).  </p>
</li>
<li><p>Models with stronger image consistency frequently hallucinate fewer objects, suggesting that strong visual processing is important for  avoiding hallucination.  </p>
</li>
<li><strong>Advises for captioning task:</strong> 仅使用CE-loss/ standard sentence metrics来优化，不太能解决object hallucination 这个问题，若同时以 image relevance 来优化，会更好。</li>
</ul>
<h4 id="yaya-总结"><a href="#yaya-总结" class="headerlink" title="yaya 总结"></a>yaya 总结</h4><ul>
<li>在设计评价指标上给我的几点启发<ul>
<li>(1) 不需要要求machine generated caption 可以概括所有的objects which have been occurred in the vision scene</li>
<li>(2) machine generated caption 进行评价时，正确性比全面性更加重要</li>
</ul>
</li>
<li><p>本文的一个巧妙的点</p>
<ul>
<li>本文为了查看object hallucination，使用COCO的80个类。对于candidata caption 首先将其token， 然后调整成单数形式，然后使用同义词的思想，去跟COCO 的80个类别进行匹配。</li>
<li>另外对于GT sentences，也提出一个list，这个地方不太知道它说的什么意思？？？？？  </li>
</ul>
</li>
<li>GVD 好像也类似的提到过类似的思想</li>
<li>关于the image consistency and language consistency scores.<ul>
<li>在这个得分的计算方式上，是否还有什么可以改进的地方？</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>图像描述</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>Object Relational Graph with Teacher-Recommended Learning for Video Captioning</title>
    <url>/2021/03/13/Object-Relational-Graph-with-Teacher-Recommended-Learning-for-Video-Captioning/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>cross-modal</category>
        <category>video captioning</category>
      </categories>
      <tags>
        <tag>cross-modal,video captioning</tag>
      </tags>
  </entry>
  <entry>
    <title>On calibration of modern neural networks</title>
    <url>/2021/01/07/On-calibration-of-modern-neural-networks/</url>
    <content><![CDATA[<p>On Calibration of Modern Neural Networks</p>
<h2 id="Calibration-一个工业价值极大，学术界却鲜有研究的问题！"><a href="#Calibration-一个工业价值极大，学术界却鲜有研究的问题！" class="headerlink" title="Calibration: 一个工业价值极大，学术界却鲜有研究的问题！"></a>Calibration: 一个工业价值极大，学术界却鲜有研究的问题！</h2><p>原创 kid丶 <a href="javascript:void(0" target="_blank" rel="noopener">夕小瑶的卖萌屋</a>;) </p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>文 | kid丶(知乎作者)<br>编 | 夕小瑶</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>尽管深度学习给工业界带来了一波上线春天，但是总有很多比较难的业务，模型反复迭代后准确率依然达不到预期的产品标准，难以满足用户期望。</p>
<p>以下为工业界常见讨（si）论（b）场景：</p>
<p>R&amp;D小哥哥一顿调参输出，RoBERTa都用上了，终于将模型从80%准确率提升到了90%，但是PM小姐姐说，“不行！咱们必须要达到95%准确率才能上线！否则就是对用户和产品逼格的伤害！”</p>
<p>怎么办呢？</p>
<p>熟悉工业界上线套路的小伙伴马上就能给出答案，那就是 <strong><em>提高模型决策的阈值！</em></strong> PM小姐姐只是根据产品标准定义了模型准确率（或者说精确率，precision），但是并不在乎召回率有多高（毕竟模型只要没上线，就相当于召回率为0）。</p>
<p>那么基于上面的思路：假如模型的softmax输出可靠，比如二分类场景，模型softmax之后1类的输出是0.92，能表征模型有92%的把握说这是个正例，并且模型的这个把握是精准的，那么PM小姐姐说要达到95%准确率，那我们就疯狂提高模型的决策阈值就好了，这样把那些不确定性高的样本砍掉了，模型准确率自然就上来了。</p>
<p>然而，神经网络并不一定这么靠谱，你看模型的测试集输出的话，却常常发现模型要么以99.999的概率输出来判定正例，要么0.0001的概率输出来判定负例，基本没有样本落在0.1~0.9区间内。那么这时候上面的思路就失效了。</p>
<p>那么有没有办法<strong>让模型的softmax输出能真实的反映决策的置信度呢？</strong> 这个问题，就被称为Calibration问题（直译是叫“校准”）。</p>
<p>故事要从一篇发表于2017年的ICML顶会论文开始，目前这篇论文引用量1001。</p>
<p><strong>论文标题：</strong></p>
<p>On Calibration of Modern Neural Networks</p>
<p><strong>链接：</strong></p>
<p><a href="https://arxiv.org/pdf/1706.04599.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1706.04599.pdf</a></p>
<p>Arxiv访问慢的小伙伴可以在【<strong>夕小瑶的卖萌屋</strong>】后台回复关键词【<strong><em>0106</em></strong>】下载论文pdf~</p>
<h2 id="神经网络的-overconfidence"><a href="#神经网络的-overconfidence" class="headerlink" title="神经网络的 overconfidence"></a>神经网络的 overconfidence</h2><p><img src="https://i.loli.net/2021/01/07/cDzC2UkMQGL3y8I.png" alt="image-20210107121456693" style="zoom: 50%;"></p>
<p>首先，让咱们来思考一个普通图像分类任务。对于一张“koala”的图像，在经过神经网络后会得到 logits 输出 ，经过 softmax 层后得到对各类别的预测的后验概率，接着我们选择概率最大的类别（ koala）输出为最后的预测类别。这里，最终的预测类别 ，其对应的置信度为 。在大多情况下，我们只关心类别的预测 有多准，根本不 care 置信度是怎样的。然而，在一些实际应用场景下，置信度的度量也同样重要。例如：</p>
<p><img src="https://i.loli.net/2021/01/07/HILjXfdVBk7v1hw.png" alt="image-20210107121544230" style="zoom: 50%;"></p>
<p>如上图，对于自动驾驶中的目标识别任务，车辆的前方出现了一个人，神经网络会将其识别成塑料袋，此时输出的置信度为50%（低于阈值），则可通过其它传感器进行二次的正确识别（识别为人）。但想想看，若神经网络对塑料袋预测的置信度为90%会怎样？再例如：</p>
<p><img src="https://i.loli.net/2021/01/07/3CUylrwH4u6csDG.png" alt="image-20210107121606617" style="zoom:50%;"></p>
<p>使用 Resnet 模型简单的对一些图片任务进行训练，收敛后的模型对测试集的平均置信度高达80%-85%，然而只有将近70%的图片能被正确分对（红色代表分错，绿色代表分对）。这意味着啥？训练好的模型好像有点盲目自信，即出现 <strong>overconfidence</strong> 现象，或者可以称为模型的准确率和置信度不匹配（<strong>miscalibration</strong>）。</p>
<h2 id="预期校准误差（ECE）"><a href="#预期校准误差（ECE）" class="headerlink" title="预期校准误差（ECE）"></a>预期校准误差（ECE）</h2><p>直观的来看，模型的准确率应当和置信度相匹配。一个完美校准的模型可定义成如下所示：</p>
<p>即，模型置信度 等于概率 的条件下模型的预测 为真实标记 的概率同样也为 。因此，本文提出一个新的度量方式叫做 <strong>预期校准误差（Expected Calibrated Error, ECE）</strong> 来描述模型学习的匹配程度：很简单，其实就是将前面那个完美校准模型的等式写成差的期望的形式。我们将期望进一步展开可得到：</p>
<p>其中： 这里的 代表着一个个根据置信度区间划分的一个个桶（用来装样本的），如下图所示：</p>
<p><img src="https://i.loli.net/2021/01/07/KS6p2nRIhMdtgjv.png" alt="image-20210107121742204" style="zoom:50%;"></p>
<p>例如，我们将置信区间平均划分成5份，然后将样本按照其置信度挨个送到对应的桶中，分别计算每个桶中的平均置信度和准确率，两者的差值（Gap）的期望就是所定义的 <strong>ECE。</strong></p>
<p><strong>读到这的读者</strong>应该能逐步体会本文想干一件啥事了。本文首先引出这样一个问题，深度模型在学习过程中出现准确率和置信度的严重不匹配问题，接着提出了一个合理的评价指标来描述模型学习的匹配程度，所以接下来，它要提出方法来想办法<strong>最小化期望校准误差（ECE）。</strong></p>
<h2 id="什么原因导致神经网络出现准确率与置信度不匹配？"><a href="#什么原因导致神经网络出现准确率与置信度不匹配？" class="headerlink" title="什么原因导致神经网络出现准确率与置信度不匹配？"></a>什么原因导致神经网络出现准确率与置信度不匹配？</h2><p>然而 <strong>ECE</strong> 是没办法直接最小化的，因此本文尝试着做一些探索性的实验来观察啥因素会使得模型的 ECE 变大。本文分别从三个方面上去进行实验：</p>
<p><img src="https://i.loli.net/2021/01/07/kniAWZNqaVBwQPG.png" alt="image-20210107121834360"></p>
<p>▲网络复杂度对ECE的影响</p>
<p><strong>网络复杂度对 ECE 的影响：</strong> 首先，作者使用两个模型（LeNet和ResNet）分别对CIFAR-100数据集进行了训练，准确率分别为55.1%和69.4%，ResNet 在预测性能上完爆LeNet。然而，ResNet 置信度（右图蓝色+红色部分）的分布和准确率（右图蓝色部分）出现了严重的不匹配，导致二者的 Gap （红色部分）非常大。**注意完美校准模型的分布应当是蓝色部分刚好和对角线重合，且没有红色 Gap 部分。</p>
<p><img src="https://i.loli.net/2021/01/07/OQX8Ir64DqyBwdl.png" alt="image-20210107114831568" style="zoom: 33%;"></p>
<p>▲网络的宽度和深度对ECE的影响</p>
<p><strong>网络宽度和深度对 ECE 的影响：</strong> 在得知模型复杂度会影响模型的 ECE 后，作者紧接着做了网络宽度和深度对模型 ECE 和错误率（Error）的影响。可以看到，在控制变量前提下，单方面的增加网络的深度和宽度均会使得模型的 Error 降低，这是我们所期望的；然而，ECE也会同样的随着上升。<strong>换句话来说，一昧的增加模型复杂度能有效的提高模型的预测性能，但同样带来的问题是模型的 overconfidence 问题愈发严重。</strong></p>
<p><img src="https://i.loli.net/2021/01/07/v1S9YrfQBt5sl4O.png" alt="image-20210107114951774" style="zoom:33%;"></p>
<p>▲归一化和权重衰减对ECE的影响</p>
<p><strong>normalization 和 weight decay 对 ECE 的影响：</strong> 接着的实验也是我们为提高模型性能经常使用的 batch normalization 和 loss regularization。<strong>左图：</strong> 使用 batch normalization 会有效的提升模型的性能，但同时也会提升模型的 ECE。<strong>右图：</strong> weight decay 通常用来调节 L2 正则的权重衰减系数，随着其系数的增加相当于更多的强调模型参数 w 要尽可能的小，能有效的防止模型过拟合。<strong>该现象表明，模型越不过拟合，其ECE是越小的，也就是说模型越不会 overconfidence ；换句话说，模型对样本的拟合程度和对样本的置信度是息息相关的，拟合得越好，置信度越高，所以 ECE 越大。（个人理解，欢迎评论区指正~）</strong></p>
<h2 id="我们该如何对模型进行校准呢？"><a href="#我们该如何对模型进行校准呢？" class="headerlink" title="我们该如何对模型进行校准呢？"></a>我们该如何对模型进行校准呢？</h2><p><img src="https://i.loli.net/2021/01/07/8WvRUEQtXg6iseY.png" alt="image-20210107115025920" style="zoom:33%;"></p>
<p>作者接下来又做了一个很有意思的实验，在CIFAR-100上训练模型500个 epoch，其中在第250个 epoch 和第375个 epoch 下调节学习率，观察测试集上的 test error 和 test NLL 的变化情况。Test NLL 的定义如图中所示，它其实等价于测试集上的交叉熵。这个实验啥意思呢？我调节了一下学习率后，测试性能得到了提升，但是测试集上的交叉熵却出现了过拟合现象（出现了反常的上升现象）。<strong>有意思的点来了！</strong> 有人肯定会 argue 不是说好本文研究的是overconfidence嘛？即模型的置信度太高而准确率过低，这里对 NLL overfitting 岂不是好事，因为负对数似然上升了等价于模型的置信度的降低了。<strong>注意：这里的</strong> <strong>是对正确类上的置信度，而前面的实验是对预测类的置信度</strong> <strong>！其实认真想想，是一个意思，前面之所以 confident 很高的样本准确率很低，正是因为其在正确类别上的置信度太低导致的！！（这部分卡了很久）</strong></p>
<p>该结果可以表明，模型置信度和准确率的不匹配很大可能的原因来自于模型对 NLL 的过拟合导致的。所以，咋办呢？最小化 NLL 呗。</p>
<p><img src="https://i.loli.net/2021/01/07/gzr4juPYwMFyiSH.png" alt="image-20210107121901763"></p>
<p>此时，本文提出在验证集上对带 temperature 参数的 softmax 函数进行校准。即我们训练完模型后，最小化 NLL 来学习 temperature 参数，注意到对该项的优化并不会影响模型预测的准确率，只会对模型的 confidence 进行校准。最终的结果是这样的，详细可参考论文。</p>
<p><img src="https://i.loli.net/2021/01/07/dDNYosvc2tprZaE.png" alt="image-20210107115122188"></p>
<h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a><strong>讨论</strong></h2><p>上述得实验结果我觉得对很多研究领域都是很有启发意义的。</p>
<ol>
<li>模型的置信度应当是和准确率匹配的，这样的模型我觉得才是有意义的，否则以很高置信度进行很离谱的预测错误的模型会让人感觉这个模型好像什么都会、又好像什么都不会。</li>
<li>ECE 的指标是否能反应样本的一些性质，例如难易程度、是否为噪声等。</li>
<li>该文章是间接的去优化ECE的，能否有直接优化的形式，或者主动学习里面能否考虑这一点来挑选样本？</li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>On Semantic Similarity in Video Retrieval</title>
    <url>/2021/03/19/On-Semantic-Similarity-in-Video-Retrieval/</url>
    <content><![CDATA[<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><ul>
<li>当前的检索任务是目标实例进行检索（ target instance-based retrieval）（IVR），即，给定一个query caption，仅一个 origami video 被认为是正确的检索结果。但，实际上，数据集中的许多视频can be similar to the point of being identical。检索此类视频的顺序不应影响方法的评估。</li>
</ul>
<h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><p>本文提出 Semantic Similarity Video Retrieval（SVR），相比于 normal IVR 的不同点是：</p>
<ul>
<li>对于1个video，允许有多个captions与其 的相似度为1</li>
<li>如果 $sim(x_i, y_j)$ = $sim(x_i, j_k)$，$x_i$ 为 video set 中的一个video。则表示这两个caption被认为是与该video有相等的相关度。可以以任意的顺序来检索，并且不能被evaluation metric 惩罚。</li>
</ul>
<h2 id="Proxy-Measures-for-Semantic-Similarity"><a href="#Proxy-Measures-for-Semantic-Similarity" class="headerlink" title="Proxy Measures for Semantic Similarity"></a>Proxy Measures for Semantic Similarity</h2><p>video $x_i$ 与 caption $y_{i}$ 是ground truth pair。</p>
<p>定义video 与 other captions 的语义相似度为：corresponding caption 与 other captions 之间的语义相似度。</p>
<p>$S_{S}\left(x_{i}, y_{j}\right)=\left\{\begin{array}{ll}1 &amp; i==j \\ S^{\prime}\left(y_{i}, y_{j}\right) &amp; \text { otherwise }\end{array}\right.$</p>
<p>关于 $S^{\prime}$ ，本文使用了四种方式来度量文本之间的语义相似度：bag of words, part-of- speech knowledge, synset similarity and the METEOR metric。</p>
<h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p><img src="https://i.loli.net/2021/03/22/oMS76vcp2HX5DgK.png" alt="image-20210322144739237" style="zoom:50%;"></p>
<h2 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h2><p>the log-ratio loss :</p>
<blockquote>
<p>Tao Qin, Tie-Yan Liu, and Hang Li. A general approximation framework for direct optimization of information retrieval measures. Information retrieval, 2010. </p>
</blockquote>
<p>nDCG loss</p>
<blockquote>
<p>Sungyeon Kim, Minkyo Seo, Ivan Laptev, Minsu Cho, and Suha Kwak. Deep metric learning beyond binary supervision. In CVPR, 2019. </p>
</blockquote>
]]></content>
      <categories>
        <category>cross-modal</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
      </tags>
  </entry>
  <entry>
    <title>Object-aware Aggregation with Bidirectional Temporal Graph for Video Captioning</title>
    <url>/2019/07/27/Object-aware-Aggregation-with-Bidirectional-Temporal-Graph-for-Video-Captioning/</url>
    <content><![CDATA[<h3 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h3><ul>
<li>本文旨在于捕捉基于object的运动信息(capture object-based trajectory)，以前向流为例，以第一帧中的object regions 作为anchor， 来寻找在其他帧中相对应的regions， 计算该anchor 与 第i帧中的regions的相似性【相似性不仅考虑了特征相似性，还考虑了空间位置相似性】，然后相似性最大的那个region，认为是与anchor一致的objects， 然后将他们组成一组。反向流类似。  </li>
<li>这个捕捉运动信息的思想与 【Learning Video Representations from Correspondence Proposals】中的很相似。   </li>
</ul>
<h3 id="当前存在的问题"><a href="#当前存在的问题" class="headerlink" title="当前存在的问题"></a>当前存在的问题</h3><ul>
<li>当前的工作主要使用 global frame 或者是 salient regions而不是使用specific objects，那么将不能捕捉到每个object 的细节的时域动态。</li>
</ul>
<h3 id="文章的主要工作"><a href="#文章的主要工作" class="headerlink" title="文章的主要工作"></a>文章的主要工作</h3><h4 id="encoder"><a href="#encoder" class="headerlink" title="encoder"></a>encoder</h4><ul>
<li>constructs ==bidirectional temporal graph== to extract  the temporal trajectories for each object instance, which captures the detailed temporal dynamics in video content.    </li>
<li>==aggregation process on object regions==, which can capture the object-aware semantic information， 这里主要是得到了 VLAD[5, 6] representation   </li>
</ul>
<h4 id="decoder"><a href="#decoder" class="headerlink" title="decoder"></a>decoder</h4><ul>
<li><p>对object VLAD representation实施了temporal attention 和 object attention</p>
</li>
<li><p>对 frames VLAD representation 实施了 temporal attention</p>
</li>
<li><p>然后分别进行nn.linear 线性变换后，相加</p>
</li>
<li><p>再与word_embedding相加送入GRU</p>
</li>
<li></li>
<li><p><font color="#0099ff" size="5" face="黑体">前向流和后向流的融合：</font>在分别得到两流输出的word score 之后，进行 sum</p>
<p><img src="https://i.loli.net/2019/07/28/5d3d37324d6d283934.png" alt="搜狗截图20190728134820.png" title="搜狗截图20190728134820.png">   </p>
</li>
</ul>
<h3 id="本文的性能分析"><a href="#本文的性能分析" class="headerlink" title="本文的性能分析"></a>本文的性能分析</h3><ul>
<li>可以准确的描述video，比如关键的objects。</li>
<li><strong>但是！不能很好地去描述 objects 之间的交互</strong></li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li>【NetVLAD】Relja Arandjelovic, Petr Gronat, Akihiko Torii, Tomas Pajdla, and Josef Sivic. Netvlad: Cnn architecture for weakly supervised place recognition. In CVPR, pages 5297–5307, 2016.</li>
<li>【SeqVLAD】Youjiang Xu, Yahong Han, Richang Hong, and Qi Tian. Sequential video vlad: Training the aggregation locally and temporally. IEEE Transactions on Image Processing (TIP), 27(10):4933–4944, 2018</li>
</ul>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>Oscar: Object-Semantics Aligned Pre-training for Vision-Language Tasks</title>
    <url>/2020/04/16/Oscar-Object-Semantics-Aligned-Pre-training-for-Vision-Language-Tasks/</url>
    <content><![CDATA[<h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><ul>
<li>现在基于bert 来处理的vision-language task 存在的问题：现在的方将image region features 和 text features 拼起来，然后利用自我注意机制以暴力方式学习图像区域和文本之间的语义对齐。（1）<strong>由于没有显示的region 与 text poses之间的对齐监督，因此是一种弱监督的任务。</strong> （2）另外，vision region常常过采样(region之间有重叠)，从而带来噪声和歧义（由于重叠，导致region之间的特征区分性不大），这将会使得vision-language task任务更加具有挑战性。</li>
<li>本文通过引入从images中检测出的object tags 作为anchor points来减轻images 和 text 之间语义对齐的学习。</li>
<li>本文提出了一个新的vision-language pre-training method <strong>OSCAR</strong> ，设计训练样本是一个三元组：（word sequence, a set of object tags, and a set of image region features. ）</li>
<li>Motivated by: the salient objects in an image can be accurately detected by modern object detectors, and that these objects are often mentioned in the paired text.</li>
</ul>
<p><img src="https://i.loli.net/2021/03/24/4CDOtMWl29nxbef.jpg" alt="搜狗截图20200416190213.png"></p>
<h2 id="object-tags-对模型性能的影响"><a href="#object-tags-对模型性能的影响" class="headerlink" title="object tags 对模型性能的影响"></a>object tags 对模型性能的影响</h2><p><img src="https://i.loli.net/2021/03/24/pisT2h5IxnCwj1z.png" alt="image-20210324105618554"></p>
]]></content>
      <categories>
        <category>cross-modal</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
      </tags>
  </entry>
  <entry>
    <title>PPL-语句通顺</title>
    <url>/2020/10/27/PPL-%E8%AF%AD%E5%8F%A5%E9%80%9A%E9%A1%BA/</url>
    <content><![CDATA[<h3 id="语句通顺-一些调研"><a href="#语句通顺-一些调研" class="headerlink" title="语句通顺 - 一些调研"></a>语句通顺 - 一些调研</h3><ul>
<li><p>BERT模型通过在大量语料的训练可以判断一句话是否通顺</p>
</li>
<li><p>理解 NNLM <a href="https://zhuanlan.zhihu.com/p/65446874" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/65446874</a></p>
<p>以上推理就是</p>
<ol>
<li>用词汇的联合概率表达一个语句是否通顺；</li>
<li>将计算联合概率转换为计算条件概率；</li>
<li>将条件概率由不定长度的且一般较大的t维降到一般较小的n-1维;</li>
</ol>
</li>
<li><p><a href="https://blog.csdn.net/blmoistawinde/article/details/104966127" target="_blank" rel="noopener">https://blog.csdn.net/blmoistawinde/article/details/104966127</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/76912493" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/76912493</a></p>
</li>
</ul>
<h3 id="PPL-评价指标"><a href="#PPL-评价指标" class="headerlink" title="PPL-评价指标"></a>PPL-评价指标</h3><p>在得到不同的语言模型（一元语言模型、二元语言模型….）的时候，我们如何判断一个语言模型是否好还是坏，一般有两种方法：</p>
<p>1、一种方法将其应用到具体的问题当中，比如机器翻译、speech recognition、spelling corrector等。然后看这个语言模型在这些任务中的表现（extrinsic evaluation，or in-vivo evaluation）。但是，这种方法一方面难以操作，另一方面可能非常耗时，可能跑一个evaluation需要大量时间，费时难操作。</p>
<p>2、针对第一种方法的缺点，大家想是否可以根据与语言模型自身的一些特性，来设计一种简单易行，而又行之有效的评测指标。于是，人们就发明了perplexity这个指标。</p>
<p><img src="https://i.loli.net/2020/10/27/UcxVWKjtlCi5Tw7.png" alt="image-20201027113452950" style="zoom: 25%;"></p>
<p>困惑度（perplexity）的基本思想是：<strong>给测试集的句子赋予较高概率值的语言模型较好,当语言模型训练完之后，测试集中的句子都是正常的句子，那么训练好的模型就是在测试集上的概率越高越好，</strong></p>
<p>由公式可知，<strong>句子概率越大，语言模型越好，迷惑度越小。</strong></p>
<p>$P(W_1, W_2, … , W_t)$</p>
<p>= $P(W_t | W_{t-1}, … , W_2, W_1) * P(W_{t-1}, … , W_2, W_1))$</p>
<p>= $P(W_t | W_{t-1}, … , W_2, W_1)$ <em> $P(W_{t-1} | W{t-2}, …, W_2, W_1) $ </em> $ P(W{t-2}, …, W_2, W_1)$</p>
<p>= $P(W_t | W_{t-1}, … , W_2, W_1)$ <em> $ P(W_{t-1} | W_{t-2}, …, W_2, W_1) $ </em> $ … $ <em> $ P(W_2 | W_1) </em> P(W_1)$</p>
<p>一些 ngram 模型经 训练文本后在测试集上的困惑度值：</p>
<p><img src="https://i.loli.net/2020/10/31/bYtXO3hgJs8TE6f.jpg" alt="img" style="zoom: 50%;"></p>
<ul>
<li>求通俗解释NLP里的perplexity是什么？ - 习翔宇的回答 - 知乎 <a href="https://www.zhihu.com/question/58482430/answer/412012509" target="_blank" rel="noopener">https://www.zhihu.com/question/58482430/answer/412012509</a></li>
<li>也可以用交叉熵损失函数来表示</li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Pointing Novel Objects in Image Captioning</title>
    <url>/2019/07/26/Pointing-Novel-Objects-in-Image-Captioning/</url>
    <content><![CDATA[<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><img src="https://i.loli.net/2019/07/27/5d3c1676f301a18995.png" alt="搜狗截图20190727171628.png" title="搜狗截图20190727171628.png"></p>
<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul>
<li>当前的模型，都是以image-caption对来进行训练，因此训练模型只能输出in-domain objects，但是，在实际应用中有些图片含有丰富的信息，但是用现有的模型却不能充分的表达。   </li>
</ul>
<h4 id="解决1"><a href="#解决1" class="headerlink" title="解决1"></a>解决1</h4><ul>
<li>希望可以生成新的words,(没有出现在training dataset)   </li>
<li>本文提出了解决办法：用object learner 来扩增标准的deep caption 结构。即，由一个图像分类任务，则可以得到该图像中出现的obects。这可以作为一个补充信息，加入到当前现有的deep caption Model 中。   </li>
<li>具体地：（1）标准的LSTM decoder 会输出一个predicted word,  （2）objects learner 通过一个copying layer 也可以得到一个预测单词。那么该选谁，本文并不硬选择，而是软选择，即给一个系数，来给这两个分配个概率，然后加和。这个选择的过程称为 <strong>Pointing Mechanism</strong>   </li>
<li>loss:<br><img src="https://i.loli.net/2019/07/27/5d3c1c012cccc48971.png" alt="搜狗截图20190727173939.png" title="搜狗截图20190727173939.png">   </li>
</ul>
<h4 id="解决2"><a href="#解决2" class="headerlink" title="解决2:"></a>解决2:</h4><ul>
<li>希望将image中的所有信息，在句子中都可以覆盖到</li>
<li>提出了一个新的损失。target caption中含有 n词，即对应到image 中的 objects。那么希望生成的句子中含有的n词信息能够包含image中所有出现到的objects（即 target caption中的所有名词）</li>
<li>那么可以根据预测的单词是否生成了 target caption 中的名词，来计算损失（文章中这里在计算损失的时候忽略了语法结构，即不要求名词出现的在句子中的位置，只要求出现就可以）.   </li>
<li>loss:</li>
</ul>
<p><img src="https://i.loli.net/2019/07/27/5d3c1c754b56a83488.png" alt="搜狗截图20190727174134.png" title="搜狗截图20190727174134.png"><br><img src="https://i.loli.net/2019/07/27/5d3c1c7536e6674709.png" alt="搜狗截图20190727174147.png" title="搜狗截图20190727174147.png"> </p>
]]></content>
      <categories>
        <category>图像描述</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>Python:理解 yield 关键字</title>
    <url>/2019/02/25/Python-%E7%90%86%E8%A7%A3-yield-%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<pre><code>转载：https://liam.page/2017/06/30/understanding-yield-in-python/
</code></pre><h1 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h1><p>为了理解<a href="https://github.com/sususushi/reconstruction-network-for-video-captioning" target="_blank" rel="noopener">reconstruction-network</a> 代码中，如下代码是如何实现的，查看了此篇博客，并转载。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cycle</span><span class="params">(iterable)</span>:</span>  </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> iterable:  </span><br><span class="line">            <span class="keyword">yield</span> x</span><br><span class="line"></span><br><span class="line">train_data_loader = iter(cycle(MSVD.train_data_loader))</span><br><span class="line"><span class="keyword">for</span> iteration, batch <span class="keyword">in</span> enumerate(train_data_loader, <span class="number">1</span>):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> iteration == C.train_n_iteration:  </span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<p>解释：<strong>iter()</strong> 是python的一个函数，用来生成迭代器。而cycle中一整个for循环是对整个数据集调用一遍，而外部又有一个while true，该判断是一直成立的，则，会一直调用数据。因此此处不适用n_epoch 来停止加载数据，而是使用train_n_iteration。</p>
<hr>
<p>Python 是非常灵活的语言，其中 <code>yield</code> 关键字是普遍容易困惑的概念。</p>
<p>此篇将介绍 <code>yield</code> 关键字，及其相关的概念。</p>
<h2 id="迭代、可迭代、迭代器"><a href="#迭代、可迭代、迭代器" class="headerlink" title="迭代、可迭代、迭代器"></a>迭代、可迭代、迭代器</h2><h3 id="迭代（iteration）与可迭代（iterable）"><a href="#迭代（iteration）与可迭代（iterable）" class="headerlink" title="迭代（iteration）与可迭代（iterable）"></a>迭代（iteration）与可迭代（iterable）</h3><blockquote>
<p>迭代是一种操作；可迭代是对象的一种特性。</p>
</blockquote>
<p>很多数据都是「容器」；它们包含了很多其他类型的元素。实际使用容器时，我们常常需要逐个获取其中的元素。<strong>逐个获取元素的过程，就是「迭代」</strong>。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iteration</span></span><br><span class="line">a_list = [1, 2, 3]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a_list:</span><br><span class="line">    <span class="builtin-name">print</span>(i)</span><br></pre></td></tr></table></figure>
<p>如果我们可以从一个对象中，逐个地获取元素，那么我们就说这个对象是「可迭代的」。</p>
<p>Python 中的顺序类型，都是可迭代的（<code>list</code>, <code>tuple</code>, <code>string</code>）。其余包括 <code>dict</code>, <code>set</code>, <code>file</code> 也是可迭代的。对于用户自己实现的类型，如果提供了 <code>__iter__()</code> 或者 <code>__getitem__()</code> 方法，那么该类的对象也是可迭代的。</p>
<h3 id="迭代器（iterator）"><a href="#迭代器（iterator）" class="headerlink" title="迭代器（iterator）"></a>迭代器（iterator）</h3><blockquote>
<p>迭代器是一种对象。</p>
</blockquote>
<p>迭代器抽象的是一个「数据流」，是只允许迭代一次的对象。对迭代器不断调用 <code>next()</code> 方法，则可以依次获取下一个元素；当迭代器中没有元素时，调用 <code>next()</code> 方法会抛出 <code>StopIteration</code> 异常。迭代器的 <code>__iter__()</code> 方法返回迭代器自身；因此迭代器也是可迭代的。</p>
<h3 id="迭代器协议（iterator-protocol）"><a href="#迭代器协议（iterator-protocol）" class="headerlink" title="迭代器协议（iterator protocol）"></a>迭代器协议（iterator protocol）</h3><blockquote>
<p>迭代器协议指的是容器类需要包含一个特殊方法。</p>
</blockquote>
<p>如果一个容器类提供了 <code>__iter__()</code> 方法，并且该方法能返回一个能够逐个访问容器内所有元素的迭代器，则我们说该容器类实现了迭代器协议。</p>
<p>Python 中的迭代器协议和 Python 中的 <code>for</code> 循环是紧密相连的。</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">iterator</span> protocol <span class="keyword">and</span> <span class="keyword">for</span> <span class="keyword">loop</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> something:</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure>
<p>Python 处理 <code>for</code> 循环时，首先会调用内建函数 <code>iter(something)</code>，它实际上会调用 <code>something.__iter__()</code>，返回 <code>something</code> 对应的迭代器。而后，<code>for</code> 循环会调用内建函数 <code>next()</code>，作用在迭代器上，获取迭代器的下一个元素，并赋值给 <code>x</code>。此后，Python 才开始执行循环体。</p>
<h2 id="生成器、yield-表达式"><a href="#生成器、yield-表达式" class="headerlink" title="生成器、yield 表达式"></a>生成器、<code>yield</code> 表达式</h2><h3 id="生成器函数（generator-function）和生成器（generator）"><a href="#生成器函数（generator-function）和生成器（generator）" class="headerlink" title="生成器函数（generator function）和生成器（generator）"></a>生成器函数（generator function）和生成器（generator）</h3><blockquote>
<p>生成器函数是一种特殊的函数；生成器则是特殊的迭代器。</p>
</blockquote>
<p>如果一个函数包含 <code>yield</code> 表达式，那么它是一个生成器函数；调用它会返回一个特殊的迭代器，称为生成器。</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">def <span class="built_in">func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">def <span class="built_in">gen</span>():</span><br><span class="line">    yield <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>(<span class="built_in">type</span>(func))   <span class="meta"># &lt;class 'function'&gt;</span></span><br><span class="line"><span class="keyword">print</span>(<span class="built_in">type</span>(gen))    <span class="meta"># &lt;class 'function'&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>(<span class="built_in">type</span>(<span class="built_in">func</span>())) <span class="meta"># &lt;class 'int'&gt;</span></span><br><span class="line"><span class="keyword">print</span>(<span class="built_in">type</span>(<span class="built_in">gen</span>()))  <span class="meta"># &lt;class 'generator'&gt;</span></span><br></pre></td></tr></table></figure>
<p>如上，生成器 <code>gen</code> 看起来和普通的函数没有太大区别。仅只是将 <code>return</code> 换成了 <code>yield</code>。用 <code>type()</code> 函数打印二者的类型也能发现，<code>func</code> 和 <code>gen</code> 都是函数。然而，二者的返回值的类型就不同了。<code>func()</code> 是一个 <code>int</code> 类型的对象；而 <code>gen()</code> 则是一个迭代器对象。</p>
<h3 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield 表达式"></a><code>yield</code> 表达式</h3><p>如前所述，如果一个函数定义中包含 <code>yield</code> 表达式，那么该函数是一个生成器函数（而非普通函数）。实际上，<code>yield</code> 仅能用于定义生成器函数。</p>
<p>与普通函数不同，生成器函数被调用后，其函数体内的代码并不会立即执行，而是返回一个生成器（generator-iterator）。当返回的生成器调用成员方法时，相应的生成器函数中的代码才会执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">yield</span> x ** <span class="number">2</span></span><br><span class="line">square_gen = square()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> square_gen:</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure>
<p>前面说到，<code>for</code> 循环会调用 <code>iter()</code> 函数，获取一个生成器；而后调用 <code>next()</code> 函数，将生成器中的下一个值赋值给 <code>x</code>；再执行循环体。因此，上述 <code>for</code> 循环基本等价于：</p>
<figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line">genitor = square_gen.__iter__()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    x = geniter.<span class="keyword">next</span>()<span class="meta"> # Python 3 是 __next__()</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>
<p>注意到，<code>square</code> 是一个生成器函数；作为它的返回值，<code>square_gen</code> 已经是一个迭代器；迭代器的 <code>__iter__()</code> 返回它自己。因此 <code>geniter</code> 对应的生成器函数，即是 <code>square</code>。</p>
<p>每次执行到 <code>x = geniter.next()</code> 时，<code>square</code> 函数会从上一次暂停的位置开始，一直执行到下一个 <code>yield</code> 表达式，将 <code>yield</code> 关键字后的表达式列表返回给调用者，并再次暂停。注意，<strong>每次从暂停恢复时，生成器函数的内部变量、指令指针、内部求值栈等内容和暂停时完全一致</strong>。</p>
<h3 id="生成器的方法"><a href="#生成器的方法" class="headerlink" title="生成器的方法"></a>生成器的方法</h3><p>生成器有一些方法。调用这些方法可以控制对应的生成器函数；不过，若是生成器函数已在执行过程中，调用这些方法则会抛出 <code>ValueError</code> 异常。</p>
<ul>
<li><code>generator.next()</code>：从上一次在 <code>yield</code> 表达式暂停的状态恢复，继续执行到下一次遇见 <code>yield</code> 表达式。当该方法被调用时，当前 <code>yield</code> 表达式的值为 <code>None</code>，下一个 <code>yield</code> 表达式中的表达式列表会被返回给该方法的调用者。若没有遇到 <code>yield</code> 表达式，生成器函数就已经退出，那么该方法会抛出 <code>StopIterator</code> 异常。</li>
<li><code>generator.send(value)</code>：和 <code>generator.next()</code> 类似，差别仅在与它会将当前 <code>yield</code> 表达式的值设置为 <code>value</code>。</li>
<li><code>generator.throw(type[, value[, traceback]])</code>：向生成器函数抛出一个类型为 <code>type</code> 值为 <code>value</code> 调用栈为 <code>traceback</code> 的异常，而后让生成器函数继续执行到下一个 <code>yield</code> 表达式。其余行为与 <code>generator.next()</code> 类似。</li>
<li><code>generator.close()</code>：告诉生成器函数，当前生成器作废不再使用。</li>
</ul>
<h3 id="举例和说明"><a href="#举例和说明" class="headerlink" title="举例和说明"></a>举例和说明</h3><h4 id="如果你看不懂生成器函数"><a href="#如果你看不懂生成器函数" class="headerlink" title="如果你看不懂生成器函数"></a>如果你看不懂生成器函数</h4><p>如果你还是不太能理解生成器函数，那么大致上你可以这样去理解。</p>
<ul>
<li>在函数开始处，加入 <code>result = list()</code>；</li>
<li>将每个 <code>yield</code> 表达式 <code>yield expr</code> 替换为 <code>result.append(expr)</code>；</li>
<li>在函数末尾处，加入 <code>return result</code>。</li>
</ul>
<h4 id="关于「下一个」yield-表达式"><a href="#关于「下一个」yield-表达式" class="headerlink" title="关于「下一个」yield 表达式"></a>关于「下一个」<code>yield</code> 表达式</h4><p>介绍「生成器的方法」时，我们说当调用 <code>generator.next()</code> 时，生成器函数会从当前位置开始执行到下一个 <code>yield</code> 表达式。这里的「下一个」指的是执行逻辑的下一个。因此</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f123</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> f123(): <span class="comment"># 1, 2, and 3, will be printed</span></span><br><span class="line">    print(item)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f13</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">False</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> f13(): <span class="comment"># 1 and 3, will be printed</span></span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure>
<h4 id="使用-send-方法与生成器函数通信"><a href="#使用-send-方法与生成器函数通信" class="headerlink" title="使用 send() 方法与生成器函数通信"></a>使用 <code>send()</code> 方法与生成器函数通信</h4><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">def <span class="function"><span class="keyword">func</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        y = (yield x)</span><br><span class="line">        x += y</span><br><span class="line"></span><br><span class="line">geniter = <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">geniter.<span class="keyword">next</span>()  <span class="meta"># 1</span></span><br><span class="line">geniter.<span class="built_in">send</span>(<span class="number">3</span>) <span class="meta"># 4</span></span><br><span class="line">geniter.<span class="built_in">send</span>(<span class="number">10</span>)<span class="meta"># 14</span></span><br></pre></td></tr></table></figure>
<p>此处，生成器函数 <code>func</code> 用 <code>yield</code> 表达式，将处理好的 <code>x</code> 发送给生成器的调用者；与此同时，生成器的调用者通过 <code>send</code> 函数，将外部信息作为生成器函数内部的 <code>yield</code> 表达式的值，保存在 <code>y</code> 当中，并参与后续的处理。</p>
<p>这一特性是使用 <code>yield</code> 在 Python 中使用协程的基础。</p>
<h2 id="yield-的好处"><a href="#yield-的好处" class="headerlink" title="yield 的好处"></a><code>yield</code> 的好处</h2><p>Python 的老用户应该会熟悉 Python 2 中的一个特性：内建函数 <code>range</code> 和 <code>xrange</code>。其中，<code>range</code> 函数返回的是一个列表，而 <code>xrange</code> 返回的是一个迭代器。</p>
<blockquote>
<p>在 Python 3 中，<code>range</code> 相当于 Python 2 中的 <code>xrange</code>；而 Python 2 中的 <code>range</code> 可以用 <code>list(range())</code> 来实现。</p>
</blockquote>
<p>Python 之所以要提供这样的解决方案，是因为在很多时候，我们只是需要逐个顺序访问容器内的元素。大多数时候，我们不需要「一口气获取容器内所有的元素」。比方说，顺序访问容器内的前 5 个元素，可以有两种做法：</p>
<ul>
<li>获取容器内的所有元素，然后取出前 5 个；</li>
<li>从头开始，逐个迭代容器内的元素，迭代 5 个元素之后停止。</li>
</ul>
<p>显而易见，如果容器内的元素数量非常多（比如有 <code>10 ** 8</code> 个），或者容器内的元素体积非常大，那么后一种方案能节省巨大的时间、空间开销。</p>
<p>现在假设，我们有一个函数，其产出（返回值）是一个列表。而若我们知道，调用者对该函数的返回值，只有逐个迭代这一种方式。那么，如果函数生产列表中的每一个元素都需要耗费非常多的时间，或者生成所有元素需要等待很长时间，则使用 <code>yield</code> 把函数变成一个生成器函数，每次只产生一个元素，就能节省很多开销了。</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Quality Estimation for Image Captions Based on Large-scale Human Evaluations</title>
    <url>/2019/12/12/Quality-Estimation-for-Image-Captions-Based-on-Large-scale-Human-Evaluations/</url>
    <content><![CDATA[<h3 id="Quality-Estimation-QE-of-image-captions"><a href="#Quality-Estimation-QE-of-image-captions" class="headerlink" title="Quality Estimation (QE) of image-captions"></a>Quality Estimation (QE) of image-captions</h3><ul>
<li>本文提出了在图像描述领域一个新的问题，Quality Estimation。由于当前的 automatic metric 非常依赖 ground-truth references，因此当一个模型训练好后，若是对一个 unseen images which don’t have gt sentence 进行描述，则无法对该描述进行评价。    </li>
</ul>
<h3 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h3><h4 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h4><ul>
<li>（1）首先在 Conceptual Captions dataset  上训练多个 image-captioning model （这个数据集会在比 coco上训练的captioning model 更好），captioning model的差异可以体现在 image feature extraction model，object detection提取的object 数量，caption decoder。    </li>
<li>（2）以上的 image-captioning model 可以为一个image 提供多个 sentence，作者对image 进行了脱敏处理    </li>
</ul>
<h4 id="数据打分及处理"><a href="#数据打分及处理" class="headerlink" title="数据打分及处理"></a>数据打分及处理</h4><ul>
<li><p>（1）这些 image-caption pairs 放到 crowdsource.google上让大家对这些 captioning，进行评价：好、坏或者跳过。每个image-captioning pair 被分配给10个人进行打分     </p>
</li>
<li><p>（2）得到收集的 rating image-captioning pairs 之后，对 unique image，将10个评分进行处理， using the equation y = round(mean(ri) ∗ 8)/8.     </p>
</li>
</ul>
<h4 id="QE-Model"><a href="#QE-Model" class="headerlink" title="QE Model"></a>QE Model</h4><ul>
<li>本文作者设计了两个模型（并把这两个模型进行融合）来处理 QE task。一个是使用到 image-captioning model，两一个是不使用   </li>
<li>（1）使用image-captioning model：<strong>Confidence-based Features QE Model</strong><br><img src="http://ww1.sinaimg.cn/large/006uWRWVgy1g9txhzr2swj30yc0i642k.jpg" alt="搜狗截图20191212143453.png"></li>
<li>（2） 不使用 image-captioning model：<strong>Generation-independent Bilinear QE model</strong><br><img src="http://ww1.sinaimg.cn/large/006uWRWVgy1g9txhzmt4rj30xs0apq5u.jpg" alt="搜狗截图20191212143515.png"></li>
</ul>
<h4 id="Spearman’s-ρ-Analysis"><a href="#Spearman’s-ρ-Analysis" class="headerlink" title="Spearman’s ρ Analysis"></a>Spearman’s ρ Analysis</h4><ul>
<li>该文的主要目的就是希望在 没有gt sentence 的情况下，对 unseen-image 进行描述时，可以给出一个caption 的评分。或者是说，该captioning与 人类的描述的相近程度。</li>
<li>该任务也是希望提出一个 machine learning metric similar to human evaluation （trained-metric），则对该模型好坏的一个的评判就是这个模型给出的评分与人类评分的相近程度。</li>
<li>predict： 模型对image-caption pair 的评分， Gt:  人类给出的评分</li>
<li>指标：Spearman’s correlation.  <a href="https://github.com/ShiYaya/spearman-rank" target="_blank" rel="noopener">my github explanation</a></li>
</ul>
]]></content>
      <categories>
        <category>图像描述</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>R-Drop: Regularized Dropout for Neural Networks</title>
    <url>/2021/07/05/R-Drop-Regularized-Dropout-for-Neural-Networks/</url>
    <content><![CDATA[<p>来源：<a href="https://mp.weixin.qq.com/s/IvhGbFEMotpKJIUPExUklg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/IvhGbFEMotpKJIUPExUklg</a></p>
<p>关注 NLP 新进展的读者，想必对四月份发布的 SimCSE [1] 印象颇深，它通过简单的“Dropout 两次”来构造正样本进行对比学习，达到了无监督语义相似度任务的全面 SOTA。无独有偶，最近的论文《R-Drop: Regularized Dropout for Neural Networks》提出了 R-Drop，它将“Dropout两次”的思想用到了有监督任务中，每个实验结果几乎都取得了明显的提升。此外，笔者在自己的实验还发现，它在半监督任务上也能有不俗的表现。</p>
<p>小小的“Dropout两次”，居然跑出了“五项全能”的感觉，不得不令人惊讶。本文来介绍一下 R-Drop，并分享一下笔者对它背后原理的思考。</p>
<p><img src="https://i.loli.net/2021/07/05/fCjDeTwZyztI3s6.png" alt="image-20210705111612040" style="zoom:50%;"></p>
<p><strong>论文标题：</strong>R-Drop: Regularized Dropout for Neural Networks</p>
<p><strong>论文链接：</strong><a href="https://arxiv.org/abs/2106.14448" target="_blank" rel="noopener">https://arxiv.org/abs/2106.14448</a></p>
<p><strong>代码链接：</strong><a href="https://github.com/dropreg/R-Drop" target="_blank" rel="noopener">https://github.com/dropreg/R-Drop</a></p>
<h2 id="1-SimCSE"><a href="#1-SimCSE" class="headerlink" title="1. SimCSE"></a>1. SimCSE</h2><p>《中文任务还是 SOTA 吗？我们给 SimCSE 补充了一些实验》[1] 中，我们已经对 SimCSE 进行了介绍。简单来说，SimCSE 是 NLP 的一种对比学习方案，对比学习的标准流程是同一个样本通过不同的数据扩增手段得到的结果视为正样本对，而 batch 内的所有其他样本视为负样本，然后就是通过 loss 来缩小正样本的距离、拉大负样本的距离了。</p>
<p>所以难度主要集中在数据扩增手段上。对于 NLP 来说，我们很难人工构建保证语义不变的数据扩增，所以 SimCSE 干脆不人工进行数据扩增，而是通过“Dropout 两次”的方式来得到同一个输入的不同特征向量，并将它们视为正样本对。奇怪的是，这个简单的“Dropout 两次”构造正样本，看上去是一种“无可奈何”的妥协选择，但消融实验却发现它几乎优于所有其他数据扩增方法，令人惊讶之余又让人感叹“大道至简”。</p>
<p><img src="https://i.loli.net/2021/07/05/Z8UKsXLWCAyp3dO.png" alt="image-20210705112154737" style="zoom:50%;"></p>
<p>在实现上，SimCSE 也相当简单，所谓“Dropout 两次”，只需要将样本重复地输入到模型，然后计算相应的 loss 就行了，如上图所示。由于 Dropout 本身的随机性，每个样本的 Dropout 模式都是不一样的，所以只要单纯地重复样本，就可以实现“Dropout 两次”的效果。</p>
<h2 id="2-R-Drop"><a href="#2-R-Drop" class="headerlink" title="2. R-Drop"></a>2. R-Drop</h2><p>从结果上来看，SimCSE 就是希望 Dropout对模型结果不会有太大影响，也就是模型输出对 Dropout 是鲁棒的。所以很明显，“Dropout 两次”这种思想是可以推广到一般任务的，这就是 R-Drop（Regularized Dropout）。</p>
<h3 id="2-1-分类问题"><a href="#2-1-分类问题" class="headerlink" title="2.1 分类问题"></a>2.1 分类问题</h3><p>在笔者看来，R-Drop 跟 SimCSE 是高度相关的，甚至 R-Drop 应该是受到了 SimCSE 启发的，不过 R-Drop 论文并没有引用 SimCSE，所以这就比较迷了。</p>
<p><img src="https://i.loli.net/2021/07/05/PkRl8QUn2uC1W5j.png" alt="image-20210705112225164" style="zoom: 80%;"></p>
<p>具体来说，以分类问题为例，训练数据为 ，模型为 ，每个样本的 loss 一般是交叉熵：</p>
<p>$\mathcal{L}_{i}=-\log P_{\theta}\left(y_{i} \mid x_{i}\right)$</p>
<p>在“Dropout 两次”的情况下，其实我们可以认为样本已经通过了两个略有不同的模型，我们分别记为 和 。这时候 R-Drop 的 loss 分为两部分，一部分是常规的交叉熵：</p>
<p>$\mathcal{L}_{i}^{(C E)}=-\log P_{\theta}^{(1)}\left(y_{i} \mid x_{i}\right)-\log P_{\theta}^{(2)}\left(y_{i} \mid x_{i}\right)$</p>
<p>另一部分则是两个模型之间的对称 KL 散度，它希望不同 Dropout 的模型输出尽可能一致：</p>
<p>$\mathcal{L}_{i}^{(K L)}=\frac{1}{2}\left[K L\left(P_{\theta}^{(2)}\left(y \mid x_{i}\right) | P_{\theta}^{(1)}\left(y \mid x_{i}\right)\right)+K L\left(P_{\theta}^{(1)}\left(y \mid x_{i}\right) | P_{\theta}^{(2)}\left(y \mid x_{i}\right)\right)\right]$</p>
<p>最终 loss 就是两个 loss 的加权和：</p>
<p>$\mathcal{L}_{i}=\mathcal{L}_{i}^{(C E)}+\alpha \mathcal{L}_{i}^{(K L)}$</p>
<p>也就是说，它在常规交叉熵的基础上，加了一项强化模型鲁棒性正则项。</p>
<h3 id="2-2-一般形式"><a href="#2-2-一般形式" class="headerlink" title="2.2 一般形式"></a>2.2 一般形式</h3><p>可能有些读者会问非分类问题应该将 KL 项替换为什么，事实上原论文并没有在非分类问题上进行实验，不过这里可以补充一下。我们可以留意到：</p>
<p>$-\log P_{\theta}\left(y_{i} \mid x_{i}\right)=K L\left(\right.$ one_hot $\left.\left(y_{i}\right) | P_{\theta}\left(y \mid x_{i}\right)\right)$</p>
<p>所以，上述 只不过是 KL 散度的反复使用，它的一般形式是：</p>
<p>$\mathcal{L}_{i}=\mathcal{D}\left(y_{i}, f_{\theta}^{(1)}\left(x_{i}\right)\right)+\mathcal{D}\left(y_{i}, f_{\theta}^{(2)}\left(x_{i}\right)\right)+\frac{\alpha}{2}\left[\mathcal{D}\left(f_{\theta}^{(2)}\left(x_{i}\right), f_{\theta}^{(1)}\left(x_{i}\right)\right)+\mathcal{D}\left(f_{\theta}^{(1)}\left(x_{i}\right), f_{\theta}^{(2)}\left(x_{i}\right)\right)\right]$</p>
<p>因此对于非分类问题，我们将 换成适当的度量（而不是 KL 散度）即可。</p>
<h2 id="3-实验效果"><a href="#3-实验效果" class="headerlink" title="3. 实验效果"></a>3. 实验效果</h2><p>我们先来看看 R-Drop 的实验结果。</p>
<p>R-Drop 的主要超参有三个：batch_size, $\alpha$ 和 Dropout 概率。batch_size 一 般取决于我们的算力，对个人来说调整空间不大; 原论文的 $\alpha$ 从 $1 \sim 5$ 都有，笔者自己的实验中，则取了 $\alpha=4$, 也没细调。至于 Dropout的概率，跟笔者在《中文任务还是 SOTA 吗？ 我们给 $\operatorname{SimCSE}$ 补充了一些实验》 [1] 所选的一样，设为 $0.3$ 效果比较好。</p>
<h3 id="3-1-论文报告"><a href="#3-1-论文报告" class="headerlink" title="3.1 论文报告"></a>3.1 论文报告</h3><p>说实话，原论文所报告的 R-Drop 的效果是相当让人惊艳的，这也是笔者不得不要介绍一波 R-Drop 的主要原因。原论文在 NLU、NLG、CV 的分类等多种任务上都对 R-Drop 做了对比实验，大部分实验效果都称得上“明显提升”。</p>
<p>官方实现：<a href="https://github.com/dropreg/R-Drop" target="_blank" rel="noopener">https://github.com/dropreg/R-Drop</a></p>
<p>下面截图一部分实验结果：</p>
<p><img src="https://i.loli.net/2021/07/05/Ff3U5wNhAv9kEjz.png" alt="image-20210705112718166" style="zoom:50%;"></p>
<p>▲ R-Drop在机器翻译任务上的效果</p>
<p><img src="https://i.loli.net/2021/07/05/tVo7znGCKvUDN5m.png" alt="image-20210705112750407" style="zoom: 50%;"></p>
<p>▲ R-Drop在GLUE任务上的效果</p>
<p>特别地，在机器翻译任务上，简单的“Transformer + R-Drop”超过了其他更加复杂方法的效果：</p>
<p><img src="https://i.loli.net/2021/07/05/gm1UzqLS9pB5KIy.png" alt="image-20210705112819739" style="zoom: 50%;"></p>
<p>▲ 机器翻译任务上不同方法的对比</p>
<p>论文还包括自动摘要、语言模型、图像分类等实验，以及关于超参数的一些消融实验，大家仔细看原论文就好。总的来说，R-Drop 的这份“成绩单”，确实足以让人为之点赞了。</p>
<h3 id="3-2-个人尝试"><a href="#3-2-个人尝试" class="headerlink" title="3.2 个人尝试"></a>3.2 个人尝试</h3><p>当然，笔者坚持的观点是“没有在中文测试过的模型是没有灵魂的”，一般情况下笔者都是在中文任务上亲自尝试过之后，才会写作分享。</p>
<p>个人实现：<a href="https://github.com/bojone/r-drop" target="_blank" rel="noopener">https://github.com/bojone/r-drop</a></p>
<p>有中文监督任务上，笔者实验了两个文本分类任务（CLUE 榜单的 IFLYTEK 和 TNEWS）。</p>
<p><img src="https://i.loli.net/2021/07/05/6WdlENPmujJQh8y.png" alt="image-20210705112907796" style="zoom:50%;"></p>
<p>和一个文本生成任务（CSL 标题生成，参考 <a href="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&amp;mid=2247504805&amp;idx=2&amp;sn=e0e149112e3318bf65d309e32db356b2&amp;chksm=96ea0c25a19d8533ec3d623547b415a58072b353037ac4cd95c68d9dc67f6eb48370684dc6dd&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Seq2Seq 中 Exposure Bias 现象的浅析与对策</a>）：</p>
<p><img src="https://i.loli.net/2021/07/05/epuUgz8yJSC6jxY.png" alt="image-20210705112924382" style="zoom:50%;"></p>
<p>可以看到，R-Drop 的结果足以 PK 在<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&amp;mid=2247504686&amp;idx=2&amp;sn=087dc7e98ede7960b3baacb20d55ce40&amp;chksm=96ea0caea19d85b8dccc52f07763b82f4aaffda6dd4cbdd784e682f13de6a11c6ced5b8df96f&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">对抗训练浅谈：意义、方法和思考（附Keras 实现</a>）中介绍的著名正则化手段“对抗训练”和“梯度惩罚”了。</p>
<h3 id="3-3-实现要点"><a href="#3-3-实现要点" class="headerlink" title="3.3 实现要点"></a>3.3 实现要点</h3><p>相比于对抗学习等复杂正则化方法，R-Drop 的实现难度可谓是相当低了，这里以 bert4keras 为例，简单介绍一下如何将一个普通的训练脚本改为带 Dropout 的模式。</p>
<p>首先，是数据生成部分，改动如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">data_generator</span><span class="params">(DataGenerator)</span>:</span></span><br><span class="line">    <span class="string">"""数据生成器</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self, random=False)</span>:</span></span><br><span class="line">        batch_token_ids, batch_segment_ids, batch_labels = [], [], []</span><br><span class="line">        <span class="keyword">for</span> is_end, (text, label) <span class="keyword">in</span> self.sample(random):</span><br><span class="line">            token_ids, segment_ids = tokenizer.encode(text, maxlen=maxlen)</span><br><span class="line">            <span class="comment"># batch_token_ids.append(token_ids)</span></span><br><span class="line">            <span class="comment"># batch_segment_ids.append(segment_ids)</span></span><br><span class="line">            <span class="comment"># batch_labels.append([label])</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">                batch_token_ids.append(token_ids)</span><br><span class="line">                batch_segment_ids.append(segment_ids)</span><br><span class="line">                batch_labels.append([label])</span><br><span class="line">            <span class="comment"># if len(batch_token_ids) == self.batch_size or is_end:</span></span><br><span class="line">            <span class="keyword">if</span> len(batch_token_ids) == self.batch_size * <span class="number">2</span> <span class="keyword">or</span> is_end:</span><br><span class="line">                batch_token_ids = sequence_padding(batch_token_ids)</span><br><span class="line">                batch_segment_ids = sequence_padding(batch_segment_ids)</span><br><span class="line">                batch_labels = sequence_padding(batch_labels)</span><br><span class="line">                <span class="keyword">yield</span> [batch_token_ids, batch_segment_ids], batch_labels</span><br><span class="line">                batch_token_ids, batch_segment_ids, batch_labels = [], [], []</span><br></pre></td></tr></table></figure>
<p>然后，自定义一个新 loss：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.losses <span class="keyword">import</span> kullback_leibler_divergence <span class="keyword">as</span> kld</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">categorical_crossentropy_with_rdrop</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    <span class="string">"""配合上述生成器的R-Drop Loss</span></span><br><span class="line"><span class="string">    其实loss_kl的除以4，是为了在数量上对齐公式描述结果。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    loss_ce = K.categorical_crossentropy(y_true, y_pred)  <span class="comment"># 原来的loss</span></span><br><span class="line">    loss_kl = kld(y_pred[::<span class="number">2</span>], y_pred[<span class="number">1</span>::<span class="number">2</span>]) + kld(y_pred[<span class="number">1</span>::<span class="number">2</span>], y_pred[::<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">return</span> K.mean(loss_ce) + K.mean(loss_kl) / <span class="number">4</span> * alpha</span><br></pre></td></tr></table></figure>
<p>最后把模型的 Dropout 打开，并用这个 data_generator 和 categorical_crossentropy_with_rdrop 来训练模型就行了。</p>
<h2 id="4-个人理解"><a href="#4-个人理解" class="headerlink" title="4. 个人理解"></a>4. 个人理解</h2><p>看完了让人赏心悦目的实验结果后，我们来啃一下理论。原论文提供了对 R-Drop 的一个理论分析，大致意思是 R-Drop 会促进参数的同化，从而起到正则化作用。不过个人感觉这个解释并不直观，而且还不够本质。下面笔者试图提供 R-Drop 的另外几个角度的理解。</p>
<h3 id="4-1-一致性"><a href="#4-1-一致性" class="headerlink" title="4.1 一致性"></a>4.1 一致性</h3><p>R-Dropout 可以看成是 Dropout 的改进，那 Dropout 有什么问题呢? 其实 Dropout 是典型的训练和预测不一致的方法。具体来说， Dropout 在训练阶段往 $\left(\right.$ 某些层的) 输入加上了乘性噪声，使得模型从 $f_{\theta}(x)$ 变成了 $f_{\theta}(x, \varepsilon)$, 其中 $\varepsilon$ 的每个元素有 $\mathrm{p}$的概率为 0 ，剩下 1-p 的概率为 $1 /(1-\mathrm{p})$ ，训练目标就是：</p>
<p>$\mathbb{E}_{(x, y) \sim \mathcal{D}} \mathbb{E}_{\varepsilon}\left[l\left(y, f_{\theta}(x, \varepsilon)\right)\right]$</p>
<p>这样训练之后，我们应该用哪个模型预测最好呢？不确定，但如果损失函数是 $l_{2}$距离的话，那么我们可以推出最佳预测模型应该是：</p>
<p>$\mathbb{E}_{\varepsilon}\left[f_{\theta}(x, \varepsilon)\right]$</p>
<p><strong>推导：</strong>如果用$l_{2}$ 损失，此时单个样本的损失是：</p>
<p>$\mathbb{E}_{\varepsilon}\left[\left|y-f_{\theta}(x, \varepsilon)\right|^{2}\right]=|y|^{2}-2\left\langle y, \mathbb{E}_{\varepsilon}\left[f_{\theta}(x, \varepsilon)\right]\right\rangle+\mathbb{E}_{\varepsilon}\left[\left|f_{\theta}(x, \varepsilon)\right|^{2}\right]$</p>
<p>注意，现在我们的问题是“模型训练完后应该用什么函数来预测”，所以 $f_{\theta}(x, \varepsilon)$ 是常数， $\mathrm{y}$ 才是要优化的变量，这只不过是一个 二次函数的最小值问题，容易解得 $y=\mathbb{E}_{\varepsilon}\left[f_{\theta}(x, \varepsilon)\right]$ 时损失函数最小。</p>
<p>我们假定这个结果能泛化到一般情况。上式告诉我们，带 Dropout 的模型的正确步骤是“模型融合”：</p>
<p>对同一个输入多次传入模型中（模型不关闭 Dropout），然后把多次的预测结果平均值作为最终的预测结果。</p>
<p>但我们一般情况下的预测方式显然不是这样的，而是直接关闭 Dropout 进行确定性的预测，这等价于预测模型由“模型平均”变成了“权重平均”：</p>
<p>$f_{\theta}\left(x, \mathbb{E}_{\varepsilon}[\varepsilon]\right)=f_{\theta}(x, 1)=f_{\theta}(x)$</p>
<p>这里的 1 指的是全 1 向量。所以，我们训练的是不同 Dropout 的融合模型，预测的时候用的是关闭 Dropout 的单模型，两者未必等价，这就是 Dropout 的训练预测不一致问题。</p>
<p>现在，我们就不难理解 R-Drop 了，它通过增加一个正则项，来强化模型对 Dropout 的鲁棒性，使得不同的 Dropout 下模型的输出基本一致，因此能降低这种不一致性，促进“模型平均”与“权重平均”的相似性，从而使得简单关闭 Dropout 的效果等价于多 Dropout 模型融合的结果，提升模型最终性能。</p>
<h3 id="4-2-连续性"><a href="#4-2-连续性" class="headerlink" title="4.2 连续性"></a>4.2 连续性</h3><p>本文开头就提到 R-Drop 与 SimCSE 的相似性，事实上它还跟另外一个方法相当相似，那便是“虚拟对抗训练（Virtual Adversarial Training，VAT）”。（不过 R-Drop 也没引 VAT，难道就只有笔者觉得像吗？？）</p>
<p>关于 VAT 的介绍，大家可以参考笔者之前的文章<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&amp;mid=2247507771&amp;idx=1&amp;sn=b92559c624c7c58e77a11c89bec5e99a&amp;chksm=96ea00bba19d89adb05dd98193e7371d43f090fcaf6be401e01c0109beee7920e84cb13274c9&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">泛化性乱弹：从随机噪声、梯度惩罚到虚拟对抗训练</a>。简单来说，VAT 也是通过一个正则项，使得模型对扰动更加鲁棒，增强模型本身的连续性（小的变化不至于对结果产生大的影响）。它们不同的地方在于加扰动的方式，VAT 只把扰动加入到输入中，并且通过对抗的思想提升扰动的针对性；R-Drop 的扰动则可以施加到模型的每一层中，并且扰动是随机的。</p>
<p>有读者可能想到了，VAT 可是主打半监督训练的，那是不是意味着 R-Drop 也可以做半监督训练？这部分原论文并没有实验，是笔者自己做的实验，答案是确实可以，跟 VAT 类似，R-Drop 新增的 KL 散度项是不需要标签的，因此可以无监督训练，混合起来就是半监督了，效果也还不错。下面是笔者的实验结果：</p>
<p><img src="https://i.loli.net/2021/07/05/UT8bI3qG54D19wt.png" alt="image-20210705113103693" style="zoom:50%;"></p>
<p>可以看到，R-Drop 的半监督效果完全不逊色于 VAT，而且它实现比 VAT 简单，速度也比 VAT 快！看来 VAT 有望退休了～ 直觉上来看，虽然 R-Drop 的扰动是随机的，但是 R-Drop 的扰动更多，所以它造成的扰动也会放大，也可能比得上 VAT 经过对抗优化的扰动，所以 R-Drop 能够不逊色于 VAT。</p>
<h3 id="4-3-非目标类"><a href="#4-3-非目标类" class="headerlink" title="4.3 非目标类"></a>4.3 非目标类</h3><p>一个比较直接的疑问是，如果我的模型够复杂，单靠交叉熵这一项，不能使得模型对 Dropout 鲁棒吗？KL 散度那一项造成了什么直接的区别？</p>
<p>事实上，还真的不能。要注意的是，交叉熵的训练目标主要是：让目标类的得分大于非目标类的得分，这样模型就能正确地把目标类预测出来了（参考<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&amp;mid=2247505145&amp;idx=1&amp;sn=42467a5475b64d3031a46594261600d2&amp;chksm=96ea0b79a19d826fb7e040968bbe928daf528d38e63d916b05cbc60a5d350755e619abc2aff8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">将“softmax+交叉熵”推广到多标签分类问题</a>）。也就是说，如果只有交叉熵这一项，模型的训练结果顶多是：</p>
<blockquote>
<p>不同的 Dropout 下，目标类的得分都大于非目标类的得分。</p>
</blockquote>
<p>而不能做到：</p>
<blockquote>
<p>不同的 Dropout 下，每个类的得分一致。</p>
</blockquote>
<p>所以也就没有解决训练预测不一致的问题。从公式上来看，交叉熵（2）只跟目标类别有关，不关心非目标类的分布，假如目标类为第一个类别，那么预测结果是 [0.5, 0.2, 0.3] 或 [0.5, 0.3, 0.2]，对它来说都没区别。但对于 KL 散度项（3）来说就不一样了，每个类的得分都要参与计算，[0.5, 0.2, 0.3] 或 [0.5, 0.3, 0.2] 是有非零损失的。</p>
<h2 id="5-本文小结"><a href="#5-本文小结" class="headerlink" title="5. 本文小结"></a>5. 本文小结</h2><p>本文介绍了 R-Drop，它将“Dropout 两次”的思想用到了有监督任务中，每个实验结果几乎都取得了明显的提升。此外，笔者在自己的实验还发现，它在半监督任务上也能有不俗的表现。最后，分享了笔者对 R-Drop 的三个角度的思考。</p>
<h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h2><p>[1] <a href="https://kexue.fm/archives/8348" target="_blank" rel="noopener">https://kexue.fm/archives/8348</a></p>
]]></content>
      <categories>
        <category>NLP, ML</category>
      </categories>
      <tags>
        <tag>NLP, ML</tag>
      </tags>
  </entry>
  <entry>
    <title>REO-Relevance, Extraness, Omission: A Fine-grained Evaluation for Image Captioning</title>
    <url>/2020/07/02/REO-Relevance-Extraness-Omission-A-Fine-grained-Evaluation-for-Image-Captioning/</url>
    <content><![CDATA[<h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><ul>
<li>BLEU 和 CIDEr 是当前广泛使用的评价指标，来评估模型的整体性能。</li>
<li>但是这个<strong style="color:red;">得分往往不具备充分的信息量来说明被评估系统的specific errors.</strong></li>
<li>该文提出了一个细粒度的评估方法REO来自动的评估图像描述系统的性能。REO从三个层面来分析captions的质量：（1）与Ground Truth 的相关性（2）与ground truth 无关的额外性（3）在images 和 human references 中被忽略的元素。</li>
<li>在三个benchmark datasets上进行实验，本文提出的方法实现了与human judgments的高度一致性；与当前可用的评价指标相对比，该文提出的方法可以提供更加直观的评估结果。</li>
</ul>
<h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><ul>
<li><p>当前研究方法存在的问题</p>
<ul>
<li>当前自动的评估图像描述系统仍然是一个挑战，尤其是在量化图像描述系统生成的error仍有难度。</li>
<li>当前存在的评价指标可以分为两类，（1）rule-based metrics, 基于确切的字符串匹配。（2）learning-based metrics, 通过学习来预测test-caption 是人类生成的可能性。</li>
<li>大体上，先前的工作评估一个文本生成系统时，主要关注的是，相对于 ground truth data, 生成的description是否充分。虽然这个方面在之前的评价指标中已经被强调，但是当前存在的评价指标存在的一个共同的限制是，由于只能为caption quality 提供一个合成的分数，因此缺乏对 description errors的一个可解释性。缺乏这种细粒度的分析，开发人员便不能得到他们开发系统的确切的description errors.</li>
</ul>
</li>
<li><p>本文的解决办法：</p>
<ul>
<li>因此本文提出了一个称为REO的评估方法，从三个层面来评估caption, (1) Relevance: 相对于ground truth, candidate caption 与其相关性。(2) Extraness: 与ground truth 无关的额外性（3）Omission: 相对于在image content和 human references, condidate caption 中被忽略的元素。</li>
<li>如果将 caption generation看做image imformation embedding 的编码过程，我们可以通过根据有关图像内容的解码信息的<strong>相关性</strong>以及<strong>丢失或多余</strong>信息的数量来衡量解码过程的有效性，从而评估图像字幕系统。</li>
<li><strong>同时使用image 和 reference captions 作为评估的ground truth information</strong>, 本文的方法建立在一个由 grounding model 定义的共享的image-text embedding space， 该grounding model在一个大的benchmark数据集上进行预训练。</li>
<li>基于向量相似性来计算candidate caption 与 ground truth 之间的相关性。通过应用向量正交映射，来等同在candidate caption中携带的多余的和丢失的信息。</li>
</ul>
</li>
<li><p>实验部分</p>
<ul>
<li>在三个数据集上测试我们的方法，实验结果证明我们提出的方法与现存的评价指标相比，our method 与人类的评估更加一致。</li>
<li><strong style="color:red;"><strong>在本文的研究中发现，相对于caption与given image的相关性，人类标注者对caption中多余或者丢失的信息更加关注。</strong></strong></li>
<li>相比于单独仅仅使用image 或者 references作为ground truth, 同时使用效果更佳。</li>
</ul>
</li>
</ul>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><ul>
<li><p>Feature Extraction</p>
<ul>
<li>C: candidate caption; R: reference caption; V:region feature</li>
<li>Based on the SCAN model, extract the context information from the caption words for each detected region.</li>
</ul>
</li>
<li><p>Metric Scores</p>
<ul>
<li>具体的查看论文</li>
<li><strong style="color:red;">Relevance</strong> : The relevance between a candidate caption and a ground-truth reference based on the i-th region is computed by the cosine similarity</li>
<li><strong style="color:red;">Extraness</strong> : The extraness of C is captured by performing an orthogonal projection of a<sub>i</sub><sup>C</sup> to gi, which returns the vertical context vector a<sub>i</sub><sup>C</sup>? to represent the irrelevant content of C to the ground truth at the ith region.</li>
<li><strong style="color:red;">Omission</strong>: 类似于Extraness</li>
</ul>
</li>
</ul>
<h4 id="Experiments-Results"><a href="#Experiments-Results" class="headerlink" title="Experiments Results"></a>Experiments Results</h4><ul>
<li>==【yaya疑问】==<ul>
<li>关于pascal-50S 这个数据集，没太弄明白是怎么回事，如何计算accuracy</li>
<li>Kendall’s tau (τ) rank correlation 如何计算也不知道呢。。</li>
</ul>
</li>
<li><p><strong style="color:red;">【Can extra &amp; missing information be captured?】</strong></p>
<ul>
<li>在Extraness 和 Omission 这两个方面，本文提出的方法是用candidate caption 与 reference caption vector 上应用 orthogonal projection来计算 vector difference， 进而来得到Extraness/Omission representation。</li>
<li>但是这是<strong>一种</strong>本文设计的表征方式，为了评估该表征方式的合理性，本文作者又随机的采样了一些数据，手工标注出这些数据中真实的extraness和 omission。这样相当于得到了对于 extraness和omission的 ground truth</li>
<li>使用本文设计的方法而计算得到的 Extraness/Omission representation与 该文作者手工标注的  Extraness/Omission ground truth计算cosine similarity. 结果发现，相似度很高，说明本文提出的方法可以有效的捕捉 extraness和omission的表达。</li>
<li><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gc9jnm2041j30i90clq92.jpg" alt="搜狗截图20200226092626.png"></li>
<li>==【yaya疑问】== 该如何获得actual extraness E<sup>C</sup> 以及true omission O<sup>C</sup> 的特征表示？？？</li>
<li></li>
</ul>
</li>
<li><p><strong style="color:red;">【Do error-aware evaluation metrics help?】</strong></p>
<ul>
<li>相比于之前的评价指标，REO，尤其是extrance和omission, 在tau (τ) 上带来了显著的提高，</li>
<li>实验结果表明，human evaluation更加关注于候选caption 与 GT之间的无关性（相比于有关性而言）。</li>
<li>同时将image 和 reference captions作为 GT reference, 来评估candidate caption的效果好于单独使用这两个元素的效果。</li>
<li>human written descriptions 在单词的选择和句子的结构上更加灵活，当candidate caption与多样性的 reference  captions进行比较的时候，就会存在一个挑战。</li>
<li>extraness metric更加适合评估machine-generated captions</li>
<li>omission metric 更加适合评估testing data 是human-written descriptions</li>
<li></li>
</ul>
</li>
<li><p><strong style="color:red;">【What can we learn from the metric outputs?】</strong></p>
<ul>
<li>该段主要是想说明，本文提出的三个层面的评估，可以为开发者提供一个关于被开发模型的errors的具体分析，使开发者可以从evaluation score中分析model到底存在哪些specific error.</li>
<li>eg: 若generated caption是对图片内容的细节性描述，则Relevance 指标会提高，但是omission评价指标会降低.</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>图像描述</category>
        <category>评价指标</category>
      </categories>
  </entry>
  <entry>
    <title>Re-evaluating Evaluation in Text Summarization</title>
    <url>/2020/10/16/Re-evaluating-Evaluation-in-Text-Summarization/</url>
    <content><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><ul>
<li><p>ROUGE 在 text summarization 任务中被广泛使用，但是，关于ROUGE是否可能偏离human judgement 以及这种偏离可能改变有关baseline 和 proposed methods的相对优势得出的结论的讨论很少。</p>
</li>
<li><p>为了表征<strong>评估指标</strong>的相对优势，有必要执行meta-evaluation。</p>
<p>where a dataset annotated with human judgments is used to test the degree to which automatic metrics correlate there with.</p>
</li>
<li><p>现在存在关键问题：现有的人类判断数据集很少，尚不清楚<strong>现有指标</strong>在<em>当前得分最高的摘要系统</em>上的表现。</p>
</li>
<li><p>在本文中提出一个问题：摘要模型中模型开发的快速发展是否需要我们<strong>重新评估</strong>用于文本摘要的<strong>评估过程</strong>。因此，在本文中，收集了一个large benchmark 来用于 meta-evaluating summarization metrics。</p>
<ul>
<li><p>数据来源于：25 top-scoring extractive and abstractive summarization systems on the CNN/DailyMail dataset.</p>
</li>
<li><p>Automatic: traditional metrics (e.g. ROUGE) and modern semantic matching metrics (e.g.  BERTScore, MoverScore).</p>
</li>
<li><p>Manual evaluations: 使用轻量级金字塔方法（Shapira等，2019），我们将其用作summarization systems 和 automated metrics的黄金标准。（yaya: 收集的human judgements 既可以作为评判systems好坏的标准，也可以作为评判metrics好坏的标准）</p>
<blockquote>
<p>Ori Shapira, <strong>Crowdsourcing lightweight pyramids for manual summary evaluation.</strong>  NAACL 2019</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="标注过程"><a href="#标注过程" class="headerlink" title="标注过程"></a>标注过程</h3><ul>
<li>对于一个document，仅存在一个reference，对该reference, 提取SCUs, 如下表展示出来的所示。该步骤由作者本人完成。</li>
<li>对于该document 的 candidate summary, 查看 SCUs 是否出现在 candidate summary 中，并标注为 “present” 或者是 “not present”。该步骤的操作由4个workers共同完成。</li>
<li>对于 each documents，查验是否存在 noisy worker, 即对于一个SCU，大多数认为其”present”，但是他却认为”not present”，在该document的大多数SCUs中他的annotations都与众数不同，则定义为 noisy workers，并将其标注的结果去除掉。</li>
</ul>
<p><img src="https://i.loli.net/2020/10/16/m7Cxl6hnvOwPeSc.png" alt="image-20201016121420397"></p>
<h3 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h3><p>本文想要研究的核心问题：“does the rapid progress of model development in summarization models require us to re-evaluate the evaluation process used for text summarization?”</p>
<p>因此本文从四个方面 to meta-evaluate current metrics。(1) evaluate all systems; (2) evaluate top-k strongest systems; (3) compare two systems; (4) evaluate individual summaries.</p>
<h4 id="evaluate-all-systems"><a href="#evaluate-all-systems" class="headerlink" title="evaluate all systems"></a>evaluate all systems</h4><p><img src="https://i.loli.net/2020/10/16/Cy7RSaKrP6XOUnY.png" alt="image-20201016160058531" style="zoom:33%;"></p>
<p>通过对比不同的metrics 在 system level 的相关性发现，在不同的数据集上，metrics的相关性，性能并不一致。</p>
<blockquote>
<p>that metrics run the risk of overfitting to some datasets</p>
</blockquote>
<p>本文建议，在不同的数据集上，使用不同的metric来评估该数据集上不同的systems 的性能好坏</p>
<h4 id="evaluate-top-k-strongest-systems"><a href="#evaluate-top-k-strongest-systems" class="headerlink" title="evaluate top-k strongest systems"></a>evaluate top-k strongest systems</h4><p><img src="https://i.loli.net/2020/10/16/Zfn4Hh6g8uG5eXM.png" alt="image-20201016160240565"></p>
<p>结论：当 top-systems 数量较少时，或者说数量不稳定时，不同的metrics在同一个数据集上的效果也不稳定。</p>
<h4 id="compare-two-systems"><a href="#compare-two-systems" class="headerlink" title="compare two systems"></a>compare two systems</h4><p>we only have 100 annotated summaries to compare any two systems, sys1 and sys2, we use paired bootstrap resampling,</p>
<p>对于人类在sys1/2 上对所有的summaries 都有一个得分。</p>
<p>现，要比较两个system, 若有95%以上的confidence认为sys1 better than sys2, 则 ytrue=1, 否则 ytrue=2, 如果confidence&lt;95%, ytrue=0.</p>
<p>同理，对于所有的metrics, 通过同样的方式，也可以有此比较得分 ypred。</p>
<p>现有 J 个systems, 则可以得到 J<em>(J-1)/2 个compaired paris. 即，得到 长度为 J</em>(J-1)/2的mask.</p>
<p>计算 ytrue_mask 与 ypred_mask 的F1score.即可评估metrics在 compare two systems上的性能与human 的一致性。</p>
<p><img src="https://i.loli.net/2020/10/16/ys241wqHUpGmltO.png" alt="image-20201016161340716" style="zoom:33%;"></p>
<p>结论：Different metrics are better suited for different datasets. For example, on the CNNDM datasets, we recommend using R-2 while, on the TAC datasets, we recommend using JS-2.</p>
<h4 id="evaluate-individual-summaries"><a href="#evaluate-individual-summaries" class="headerlink" title="evaluate individual summaries"></a>evaluate individual summaries</h4><p><img src="https://i.loli.net/2020/10/16/iWLrRBSITJGpMoN.png" alt="image-20201016162009349" style="zoom: 50%;"></p>
<ul>
<li>以上三个实验都是system-level , 此实验是 summary-level</li>
</ul>
<p>分析：在不同的数据集上，同一metrics的性能不一致。如，R_1在TAC上与human相关性较低，但是在CNNDM上相关性较高。</p>
<p>另，前有文章表明，automatic metrics趋向于在system level 与 human的相关性较好，但是在 instance-level (summary-level) 相关性较差。我们进行实验发现，这种现象仅在TAC-2009 上表现明显。</p>
<p>结论：autometrics 在 summary-level 与 system-level 上的性能是一样的。</p>
<blockquote>
<p>Even though some metrics might be good at comparing summaries, they may point in the wrong direction when comparing systems</p>
</blockquote>
<p>另外，<strong>some metric在不同的数据集上的性能是不同的，因此是有必要在不同的数据集上测试各个评价指标的有效性</strong></p>
<h3 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h3><ul>
<li>（1）metric的选择不仅取决于不同的任务（例如，摘要，翻译），而且还取决于不同的数据集（例如，TAC，CNNDM）和应用程序场景（例如，系统级别，摘要级别）。未来的meta-evaluating 工作应调查效果这些设置对指标性能的影响。</li>
<li>（2）指标很容易在有限的数据集上过拟合。多数据集meta-evaluate 可以帮助我们更好地了解每个指标的特殊性，从而在各种情况下获得更好的指标选择。</li>
<li>（3）我们收集的人工判断可以用作监督，以实例化最近提出的预训练-然后-微调框架（最初用于机器翻译）（Sellam等，2020），学习一个强大的文本摘要指标。</li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
        <category>评价指标</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>SPICE</title>
    <url>/2019/03/25/SPICE/</url>
    <content><![CDATA[<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><h3 id="Ubuntu下安装Stanford-CoreNLP"><a href="#Ubuntu下安装Stanford-CoreNLP" class="headerlink" title="Ubuntu下安装Stanford CoreNLP"></a><a href="https://blog.csdn.net/Hay54/article/details/82313535" target="_blank" rel="noopener">Ubuntu下安装Stanford CoreNLP</a></h3>]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>[Retrieve Fast, Rerank] Smart Cooperative and Joint Approaches for Improved Cross-Modal Retrieval</title>
    <url>/2021/03/23/Retrieve-Fast-Rerank-Smart-Cooperative-and-Joint-Approaches-for-Improved-Cross-Modal-Retrieval/</url>
    <content><![CDATA[<h2 id="现存的问题"><a href="#现存的问题" class="headerlink" title="现存的问题"></a>现存的问题</h2><ul>
<li>本文主要研究基于预训练跨模态模型<ul>
<li>pretrained from scratch and less scalable</li>
<li>huge retrieval latency</li>
</ul>
</li>
</ul>
<h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><ul>
<li>为了同时提高模型<strong>性能</strong>与<strong>效率</strong>。提出了一个新颖的微调框架，可以将任意预训练的 text-image 多模态模型转化为一个有效的检索模型。</li>
<li>该框架基于对检索和重新排序进行协作，该方法结合了：（1）双胞胎网络分别对语料库的所有项目进行编码，从而实现有效的初始检索； 2）交叉编码器组件，用于对检索到的小项目集进行更细微（即更智能）的排名。 </li>
<li>我们还建议通过共享权重共同微调这两个分量，从而产生一个参数更有效的模型。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>(SGAE)Auto-Encoding Scene Graphs for Image Captioning</title>
    <url>/2019/03/16/SAGE-Auto-Encoding-Scene-Graphs-for-Image-Captioning/</url>
    <content><![CDATA[<p>本文是CVPR2019 的关于图像描述的文章，主要让我关注的原因是用到了scene graph 和 GCN，这也是本文最大的创新点。但是本文利用的是saptial GCN（悄悄说，构建的graph节点数量少，而且是异质的，不如说是多方面融合信息已达到丰富信息的目的 :-) ）</p>
<ul>
<li>后记<br>这里讲一下图卷积中spatial  gcn①②③ 与 spectral gcn ④⑤⑥<br>①Learning task-dependent distributed representations by backpropagation through structure.<br>②A new model for  learning in graph domains<br>③The graph neural network model<br>④Spectral networks and locally connected networks on graphs.<br>⑤Deep convolutional networks on graph-structured data.<br>⑥Semi-supervised classification with graph convolutional networks</li>
</ul>
<p>关于这篇论文采用的graph  convolutional network：采用的数</p>
<ul>
<li>为什么这样说？<br>本文提到了两类graph，一类是sentence scene graph，另一类是image scene graph，而在这两类下，又进行细分为relationship、attribute、object graph。但是，每个graph 中节点是异质的，比如在relationship graph中，obejct<sub>a</sub>， obejct<sub>b</sub>，relationship<sub>ab</sub>构成了一个graph，目的是来更新relationship embedding。从我的角度来看，只是融合相关信息来更新某一目标的特征，与graph无关。  </li>
<li>写在最前面，我个人的理解，在得到graph 节点的embedding 之后，就要输入gcn layer 来更新特征，这里，gcn layer 的表达公式可以这样理解： 该graph中所有的节点v<sub>i</sub>，经过concatenate之后，再经过一个全连接层。<br>gcn(.) = fc( concatenate(v1, v2, … , vn) )**</li>
</ul>
<p>下面说正文：</p>
<h1 id="General-encoder-decoder-network-for-image-captioning"><a href="#General-encoder-decoder-network-for-image-captioning" class="headerlink" title="General encoder-decoder network for image captioning"></a>General encoder-decoder network for image captioning</h1><ul>
<li><p>目前一般的encoder-decoder network for image captioning 是<strong>CNN提取image的特征，然后RNN来生成句子</strong>，例如下图所示。<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14r211sidj30kb0fy0v3.jpg" style="zoom:80%"></p>
</li>
<li><p>进一步有<strong>加入attention</strong> [1]，下图是提取14×14×512 feature map of the fourth  convolutional layer，然后 flatten to 196 × 512 before feed into decoder。在输入到decoder时对这196个feature vector进行attention的加权求和。<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14rdh7wg7j33ak1ep7wj.jpg" style="zoom:50%"></p>
</li>
<li><p>也有<strong>提取images 中的object，以此来提取显著信息，对object feature 进行attention的加权求和并送入decoder</strong>。具体地，使用RPN 的ROI pooling来提取objects feature，然后对LSTM的每一个step ,对这所有的object features进行attention操作，再作为输入送入LSTM[2]。如下图<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14u74yahwj30q30modsg.jpg" style="zoom:70%"></p>
</li>
</ul>
<h1 id="本文的encoder-decoder-baseline"><a href="#本文的encoder-decoder-baseline" class="headerlink" title="本文的encoder-decoder baseline"></a>本文的encoder-decoder baseline</h1><h2 id="1-Encoder"><a href="#1-Encoder" class="headerlink" title="1. Encoder"></a><strong>1.</strong> <strong>Encoder</strong></h2><p>本文有两个encoder ： image-encoder；sentence-encoder<br>本文sentence-encoder  是用来预训练Dictionary，并共享给 image-encoder。但是在baseline中不用GCN/MGCN 和 Dictionary，因此image-encoder与sentence-encoder 之间是没有交集的。（我猜测 baseline中没有用到sentence-encoder）</p>
<p><strong>（1）对于image encoder 得到object embedding，relationship embedding , attribute embedding。</strong></p>
<p>如何得到object embedding，relationship embedding , attribute embedding？</p>
<ul>
<li>object detector : 采用与[1]一致的方式来训练faster r-cnn， 0.7的阈值 for proposal NMS， 0.3的阈值for object NMS。Faster R-CNN在visual genome上预训练，预训练之后，对proposals采取0.7的IoU阈值进行NMS，对objects 采取0.3的IoU阈值进行NMS，对每个image，采取10-100个object。使用RoI pooling 来提取object features，该object features 将作为后边relationship classifier 和attribute classifier的输入。</li>
<li>relationship classifier：使用在[5] 中提到的LSTM结构来作为关系分类器，来为两个object 分配一个relationship label。</li>
<li>attribute classifier : 为某个object 分配属性标签，将该object feature输入fc-relu-fc-softmax网络，则得到属性标签。</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14vip74y0j311l09eq4y.jpg" style="zoom:60%">      </p>
<ul>
<li><p>以上三个输出的所有构成一个image scene graph  </p>
</li>
<li><p>需要说明以上三个是在<strong>Visual Genome数据集</strong>上预训练的，该数据集具有丰富的scene graph 标注，含有obejct’s categories，obejct’s attributes and pairwise relationships，因此可以用来训练目标检测器、属性分类器、关系分类器。但是由于这些标注含有很多噪声，因此采用一定的措施进行过滤：对于在数据集中出现超过2000次的objects，attributes，relationships保留下来，其余的去掉。经过这样的处理，则得到305个objects类，103个属性类，64个关系类  </p>
</li>
<li><p>经过分类器得到 label 之后，还需要得到相对应的embedding: <strong>u<sub>o</sub> , u<sub>r</sub> , u<sub>a</sub></strong> 。<br>其中 label 的维度472 = 305 + 103 + 64，即object/realation/attribute label的one hot vector 维度是三种节点的总类别数。<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14w80gi8tj30w70ik0xu.jpg" style="zoom:70%">  </p>
</li>
</ul>
<p><strong>（2）对于sentence encoder 使用[6] 来得到 parse scene graph，进而得到object embedding，relationship embedding , attribute embedding</strong><br>注意这里的sentences使用的是<strong>MS COCO</strong>中的caption，而不是Visual Genome中的caption。同样对其进行过滤，过滤掉在all parsed scene graph中出现的objects、attributes、relationships次数少于10的，则剩下5364个objects类，1308个realtionships类，3430个attributes类。<br>sentence encoder 使用[6] 来得到 parse scene graph，但实际上，[6]又是使用[7]中的方法，所以读者最好看[7]<br>这里介绍 一下[6] SPICE 是用来评价image caption的一个性能指标，这里为什么使用它，它是用来做为一个评价指标的吗？首先回答第二个问题，不是用来作为评价指标的，而是利用了它的原理：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1dwj56im1j30iq0nmk00.jpg"></p>
<p>parse scene graph 的过程：sentence-&gt; syntax dependency tree-&gt; scene graph<br>给定一个句子，首先分析句法依赖树，再根据给定句法依赖树的情况下，输出scene graph，而scene graph 的输出是对sentence中的每一个次元，输出其是object，还是 relation，还是attribute（即，对每个word 输出一个one hot vector （我的猜测））。如下图所示：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1gbldqsamj30q50kntkm.jpg"></p>
<p>经过parse scene graph得到的是object <strong>label</strong>、relationship <strong>label</strong>、attributes <strong>label</strong>的one hot vector（注意one hot 的长度是 5346+1308+3430 = 10102，即 将三种node合在了一起）。得到label之后，再经过word embedding层即可得到对应的word embedding: <strong>e<sub>o</sub> , e<sub>r</sub> , e<sub>a</sub></strong>。<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14w6j9aouj31670aqdiw.jpg" style="zoom:50%"></p>
<h2 id="2-Decoder"><a href="#2-Decoder" class="headerlink" title="2.  Decoder"></a><strong>2.</strong>  <strong>Decoder</strong></h2><p>由两层LSTM组成（该部分与论文[1][4] 的decoder部分是完全一致的，只是输入的encoder output不一样而已），下图给出了我自己画的decoder 结构[1]给出的结构[4]中给出的decoder结构</p>
<ul>
<li>在[4]中encoder output是GCN输出的object features（两个graph生成的encoder output分别送入decoder）。</li>
<li>但是在本文中encoder output是 <strong>u<sub>o</sub> , u<sub>r</sub> , u<sub>a</sub></strong> 组合成的d×M 矩阵，或者是 <strong>e<sub>o</sub> , e<sub>r</sub> , e<sub>a</sub></strong> 组合成的d×M 矩阵 。M = num_objects + num_relationships + num_attributes  注意：在sentence-encoder中的输出，这里的M是该句子的parse scene graph实际生成的object、relation、attribute的数量（有可能baseline 中不使用 sentence-encoder）；在image-encoder中的输出，这里也是实际的object detector、relationship classifier、attribute classifier 输出的实际数量总和</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14xg3jwvdj30mo0h2wfi.jpg" style="zoom:60%"><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g19d1x7kiij30im0bvaat.jpg" style="zoom:60%"><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14v8kb8kmj30sr0gzwgz.jpg" style="zoom:60%"><br>具体地，这里也给出本文的表达方式如下表:<br>这里的10369是对MS COCO中的captions 进行预处理之后，得到的 len of vocabulary<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14wrwfzplj30ze0hcjwe.jpg" style="zoom:60%"></p>
<h1 id="在baseline-上加东西"><a href="#在baseline-上加东西" class="headerlink" title="在baseline 上加东西"></a>在baseline 上加东西</h1><ul>
<li>一般的encoder-decoder如下图中的top所示，本文提出加入MGCN for image和GCN for sentence，同时加入Dictionary（共享参数 betwen sentence and image）<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14yn2vbtej30k40jzac6.jpg" style="zoom:50%"><br>由以上可知，构建了image scene graph 和 sentence scene graph，下面将本文的主要创新点，加入GCN和Dictionary  </li>
</ul>
<h2 id="sentence-graph-gt-GCN-更新embedding"><a href="#sentence-graph-gt-GCN-更新embedding" class="headerlink" title="sentence graph -&gt; GCN (更新embedding )"></a>sentence graph -&gt; GCN (更新embedding )</h2><p>经上面的分析构建的sentence scene graph 在得到了object、relation、attribute label 对应的word embedding之后，将通过GCN来更新embedding。</p>
<ul>
<li>表中的（7）（8）（9）可以认为是三个relationship、attribute、object graph。<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14y1f5p02j31370e1jw1.jpg" style="zoom:60%"></li>
<li>解释这里的<strong>g<sub>r</sub> g<sub>a</sub> g<sub>o</sub> g<sub>s</sub></strong><br>以<strong>g<sub>r</sub></strong> 为例：g<sub>r</sub> (D<sub>in</sub>，D<sub>out</sub>）。输入维度为什么是3000？因为e<sub>oi</sub> , e<sub>rij</sub> , e<sub>oj</sub>的维度分别均是1000，论文中省略了将其concatenate的操作的说明，但是实际上是进行了concatenate操作，使得维度变为3000，并作为g<sub>r</sub>的输入。输出是1000维度。</li>
<li><strong>因此这里图卷积层，可以认为是 该graph中所有的节点v<sub>i</sub>，经过concatenate之后，再经过一个全连接层。<br>g(.) = fc( concatenate(v1, v2, … , vn) )</strong><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14y594pa8j30og0ksdi2.jpg" style="zoom:50%">  </li>
</ul>
<h2 id="image-graph-gt-Multi-modal-GCN-更新embedding"><a href="#image-graph-gt-Multi-modal-GCN-更新embedding" class="headerlink" title="image graph -&gt; Multi-modal GCN (更新embedding )"></a>image graph -&gt; Multi-modal GCN (更新embedding )</h2><p>与sentence graph 对应的GCN类似，这里的 multimodal 也没什么意思，就是特征融合时（9）（10）（11），既使用了label 对应的word embedding，又使用了feature。<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14yf14p1mj30sp0k0ten.jpg">  </p>
<ul>
<li>解释这里的<strong>f<sub>r</sub> f<sub>a</sub> f<sub>o</sub> f<sub>s</sub></strong><br>与sentence scene graph 对应的g一致，首先对输入进行了concatenate操作<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14yhc6gpzj314l0gktax.jpg"></li>
</ul>
<h2 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h2><ul>
<li><strong>该部分的作用</strong>是一个memory network。首先Dictionary在<strong>S-&gt;G-&gt;D-&gt;S</strong>上预训练，之后才被用于<strong>I-&gt;G-&gt;D-&gt;S</strong>  。即是参数共享的。而在<strong>S-&gt;G-&gt;D-&gt;S</strong>中，输入的sentence是由human generated。因此Dictionary中就preserve human’s inductive bias。进而与<strong>I-&gt;G-&gt;D-&gt;S</strong>  共享，使得由image 生成的predict caption也含有 human’s inductive bias</li>
<li>由上文分析可知，经过GCN/MGCN更新的embedding的维度均是1000，则Dictionary的输入维度均是1000，D是可学习参数矩阵1000*10000，输入的x经过Dictionary得到 x^<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14yrlt89sj310c07e40b.jpg">  </li>
</ul>
<h2 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h2><p>经过encoder 结合GCN/MGCN之后，输出发生了改变，这里再讲一下decoder的输入。</p>
<ul>
<li>在<strong>S-&gt;G-&gt;D-&gt;S</strong> 这个序列过程中由D-&gt;S 即输入decoder LSTM的过程，输入的是D的输出。</li>
<li>而在<strong>I-&gt;G-&gt;D-&gt;S</strong> 这个序列过程中，输入decoder LSTM的过程，输入的是D的输出v’和G的输出v^，即concate[v’, v^]<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1507wpmlij30zf0h8dku.jpg"></li>
</ul>
<h1 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h1><ul>
<li>首先使用交叉熵损失函数训练 <strong>S-&gt;G-&gt;S</strong>  20 epoch。注意D不参与训练</li>
<li>使用交叉熵损失函数训练 <strong>S-&gt;G-&gt;D-&gt;S</strong>  20 epoch。这里的D参与训练</li>
<li>使用交叉熵损失函数训练 <strong>I-&gt;G-&gt;D-&gt;S</strong>  20 epoch。这里的D使用在上一步骤中预训练的参数，并fine-tune</li>
<li>使用RL-based reward 训练 <strong>I-&gt;G-&gt;D-&gt;S</strong>  40 epoch。 D参与训练  </li>
</ul>
<h1 id="推理过程"><a href="#推理过程" class="headerlink" title="推理过程"></a>推理过程</h1><ul>
<li>文章中没有写，但是我认为是<strong>I-&gt;G-&gt;D-&gt;S</strong>  </li>
</ul>
<h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><ul>
<li>由下表可知，实验结果并不突出，尤其是与GCN-LSTM[7]对比可知，GCN-LSTM的结构更加简单的情况下，两个模型的结果却相差不多。</li>
<li>可以看到表中有三个GCN-LSTM， 最上边那个是本文作者的复现，由于GCN-LSTM的作者batch_size 太大，本文作者觉得对比不公平，因此重新复现了代码（没公开代码）并减小了bs进行实验得到的结果。第二个GCN-LSTM（sem graph）是原作者论文中的实验数据。第三个GCN-LSTM是融合了semantic graph 和saptial graph。</li>
<li>对于SGAE的融合应该是输入decoder的不仅是<strong>I-&gt;G-&gt;D-&gt;S</strong> 中D的输出v’，而且也输入G的输出 v^，即concate[v’,  v^]<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14zjng66yj30oc0f0djs.jpg">   </li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] Bottom-up and top-down attention for image captioning and visual question answering<br>[2] Show, Attend and Tell: Neural Image Caption  Generation with Visual Attention<br>[3] Image Captioning with Object Detection and Localization<br>[4] Exploring Visual Relationship  for Image Captioning<br><strong>[5] Neural motifs: Scene graph parsing with global context</strong><br><strong>[6] Spice:  Semantic propositional image caption evaluation</strong><br><strong>[7] Generating Semantically Precise Scene Graphs from Textual Descriptions for Improved Image Retrieval</strong></p>
]]></content>
      <categories>
        <category>图像描述</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
        <tag>图卷积网络</tag>
      </tags>
  </entry>
  <entry>
    <title>(SCST)Self-critical Sequence Training for Image Captioning</title>
    <url>/2019/04/08/SCST-Self-critical-Sequence-Training-for-Image-Captioning/</url>
    <content><![CDATA[<p>强化学习中的策略梯度法可以针对那些不可微分的度量进行优化，<br>本文中，使用强化学习的方法来优化图像描述任务，将这个新的优化方法称为self-critical sequence training (SCST)。</p>
<p><strong>sequence models for image captioning的理想训练过程， 应该是避免 exposure bias 并且可以直接优化任务中的度量</strong></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="图像描述方面的现状"><a href="#图像描述方面的现状" class="headerlink" title="图像描述方面的现状"></a><strong>图像描述方面的现状</strong></h3><p>[1] <strong>show attend and tell</strong> 证明在caption任务中，使用attention机制是有益处的。<br>[2] <strong>Teacher-Forcing</strong> 用于文本的deep generative models 的训练方法一般是：给定上一步word的ground truth 来最大化该步生成word的最大似然，来反向传播。这个方法称为“Teacher-Forcing”  。但是这种方法导致在训练和测试时很不匹配。因为在测试时，该步生成的单词是在给定上一步预测出的单词的前提下。  </p>
<ul>
<li><p>这个exposure  bias [2]导致在测试时产生误差累积，因为模型从未暴露于其自己的预测中。<br>This exposure  bias [2], results in error accumulation during generation at  test time,<br>since the model has never been exposed to its own  predictions</p>
<p>一些克服exposure bias的方法[3] [4]<br>[3] <strong>Scheduled sampling</strong> 他们表明，反馈模型自己的预测，并在训练过程中缓慢地增加反馈概率p，可以显着地提高测试时间的性能。<br>[4] <strong>Professor forcing</strong> a  technique that uses adversarial training to encourage the dynamics of the recurrent network to be the same when training conditioned on ground truth previous words and when  sampling freely from the network</p>
</li>
</ul>
<h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><h3 id="实验结果证明"><a href="#实验结果证明" class="headerlink" title="实验结果证明"></a>实验结果证明</h3><p>we find that directly optimizing the CIDEr metric with  SCST and greedy decoding at test-time is highly effective.</p>
<h2 id="Image-Features"><a href="#Image-Features" class="headerlink" title="Image Features"></a>Image Features</h2><ul>
<li>FC Models<br>由CNN+FC得到image 的 特征向量，并送入LSTM中，来生成caption<br>但是需要注意的是仅在first step 输入该特征向量，其余步输入上一步生成的word (embedding)   </li>
<li>Spatial CNN features for Attention models<br>在不缩放也不裁剪图片的基础上，使用resnet-101来提取最后一个卷积层的特征，并应用apply spatially adaptive max-pooling来得到一个固定的尺寸14 × 14 × 2048。在每一个time step，attention model在这14 × 14=196个位置上计算一个<font color="#0099ff" size="6" face="黑体"> attention mask</font>（注意力系数/权重）。由这个mask 计算所有位置的加权求和，以此得到image feature。  </li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] Show, attend and tell: Neural image caption generation with visual attention. In ICML,  2015.<br>[2] Sequence level training with recurrent neural networks. ICLR, 2015.<br>[3] Scheduled sampling for sequence prediction with recurrent neural networks. In NIPS, 2015.<br>[4] Professor forcing: A  new algorithm for training recurrent networks. Neural Information Processing Systems. (NIPS) 2016.  </p>
]]></content>
      <categories>
        <category>图像描述</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>Score_Videos</title>
    <url>/2020/06/21/Score-Videos/</url>
    <content><![CDATA[<p>Video: 8iPflOxQaao_000018_000028</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1Xf4y1y7AP&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: UArdunmwEdA_000049_000059</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1mt4y1X7fE&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: vTSO26j_g3E_000006_000016</p>
<iframe src="//player.bilibili.com/player.html?aid=286089586&bvid=BV1Rf4y1y7nN&cid=203899418&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: gf37sAjEfRc_000013_000023</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1Bz4y1Q7Ai&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: GXO1eYu4kr8_000000_000010</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1JT4y1J7R6&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: saXahlRV7s4_000022_000032</p>
<iframe src="//player.bilibili.com/player.html?aid=286068284&bvid=BV1df4y1y7oD&cid=203899246&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: Hgo7xkutPno_000059_000069</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1Ez411e7QD&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: NRC5oMoNHn0_000003_000013</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV12t4y1X7tM&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: IbDcOoO9m6g_000139_000149</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1ni4y1x7xP&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: tGiBJQ5RhZQ_000077_000087</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1cV411k7yR&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: _YWpv2_K8Pk_000054_000064</p>
<iframe src="//player.bilibili.com/player.html?aid=456121030&bvid=BV1D5411W7zB&cid=203800090&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: KvVRY61JS7A_000023_000033</p>
<iframe src="//player.bilibili.com/player.html?aid=841065180&bvid=BV1U54y1B7ga&cid=204027776&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: VNXpHy5Tb_U_000064_000074</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1if4y1y71S&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: dC2Ih_JFoOM_000000_000010</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1cD4y1Q7BX&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: lcUJjVgqXp4_000000_000010</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV19V411r7FF&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: uh50grtCQSA_000026_000036</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1ma4y1Y7HQ&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: cb3RvnukQVs_000159_000169</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1vk4y1z7GR&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: 5D4HjS92zSQ_000126_000136</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV17i4y1G7rb&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: kRdxCmOsY2Y_000003_000013</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV15A411i7Cg&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: _PdB7OGolCo_000191_000201</p>
<iframe src="//player.bilibili.com/player.html?aid=838500851&bvid=BV1Eg4y1q7fp&cid=203798508&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: 38Jn4r_pcpg_000167_000177</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1Xt4y1X7L1&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: 53Ia-BtpM5A_000002_000012</p>
<iframe src="//player.bilibili.com/player.html?aid=841116130&bvid=BV1X54y1B7pu&cid=203898322&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: 7QyQVBclhT4_000000_000010</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV18a4y1Y7Bn&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: QyMTEHd-VCc_000004_000014</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1v54y1B7X4&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: t-COcCPV-T4_000020_000030</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1ff4y1y7xc&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: oGpVHf4xooM_000160_000170</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1Bp4y1D7NJ&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: WU5KZsG_mQk_000483_000493</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1XC4y1a7Cf&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



]]></content>
  </entry>
  <entry>
    <title>Score_sentences</title>
    <url>/2020/06/21/Score-sentences/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>Seeing Out of tHe bOx End-to-End Pre-training for Vision-Language Representation Learning</title>
    <url>/2021/04/20/Seeing-Out-of-tHe-bOx-End-to-End-Pre-training-for-Vision-Language-Representation-Learning-1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Seeing Out of tHe bOx End-to-End Pre-training for Vision-Language Representation Learning</title>
    <url>/2021/04/19/Seeing-Out-of-tHe-bOx-End-to-End-Pre-training-for-Vision-Language-Representation-Learning/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Semantic Equivalent Adversarial Data Augmentation for Visual Question Answering</title>
    <url>/2021/03/12/Semantic-Equivalent-Adversarial-Data-Augmentation-for-Visual-Question-Answering/</url>
    <content><![CDATA[<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p>受到深度学习的快速发展，VQA 近年来取得了非常成功的进展。数据增强是深度学习中的一个有用的技巧，但是，目前很少有工作关注于VQA任务的数据增强。</p>
<p>对于image side: 一些简单的数据增强操作不能直接应用到VQA这一场景下，比如，rotation and flipping 等操作，都可能导致<image, question, answer> 这一结构的正确性遭到破坏。</image,></p>
<p>对于text side (eg: questions) , it is challenging to come up with <strong>generalized rules for language transformation.</strong> 另外，有一类任务是Visual Question Generation，根据image和 answer来生成问题，但是生成的问题常常是有语法错误的，而且，他们在同一个目标数据集上进行学习，生成的数据与原始数据的分布是一致的，因此，<strong>若使用这种方案来做数据扩充，难以解决过拟合问题</strong>(通常训练数据和测试数据不是同一个分布)。</p>
<p>在本文中，不直接对image或者是question进行操作，而是对images 和 questions生成对抗样本作为数据增强。增强的样本不会改变image的原始语义，也不会改变questions中的semantic meaning。对抗性示例是经过<strong>策略</strong>修改的样本，可以成功地欺骗深层模型以做出不正确的预测。这种修改是难以察觉的，<strong>它在使对抗性示例的基础分布远离原始数据的同时保持了数据的语义。</strong>本文是第一个同时对image 和 text进行数据扩充的方法（已有的方法只是单独对一方面进行数据扩充）。</p>
<p>进而，使用本文方法产生的<strong>数据增强样本</strong>和<strong>对抗训练</strong>来训练经典的VQA model (BUTD) 。</p>
<p>实验结果证明，不仅可以提高 VQAv2的整体性能，而且相比于baseline还可以有效抵抗对抗攻击。</p>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p><img src="https://i.loli.net/2021/03/12/rmyqUFXQewT2PBK.png" alt="image-20210312165449352" style="zoom:50%;"></p>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><h4 id="何时加入对抗样本"><a href="#何时加入对抗样本" class="headerlink" title="何时加入对抗样本"></a>何时加入对抗样本</h4><ul>
<li><p>本文发现，将干净样本和对抗样本进行混合，然后<strong>从头到尾</strong>的训练，这种方案不会在干净样本上收敛。因此本文只在特定的训练时期对样本进行混合，最后使用干净样本进行微调。</p>
<p>本文实验中max-epoch=25.</p>
<p><img src="https://i.loli.net/2021/03/12/YOblV6WT4rtMkSf.png" alt="image-20210312171853940" style="zoom: 50%;"></p>
<p>本文的解释：与干净样本相比，对抗样本与其有不同的分布。如果把提升模型在VQA任务上的性能作为我们的主要目标，那么模型在干净样本上的拟合能力需要<strong>在结束</strong>的时候to be retrieved。而<strong>在开始</strong>时，模型需要warm up，此时不适合加入对抗样本。因此在中间阶段加入融合对抗样本的训练。</p>
</li>
<li><p>实验证明本文提出的方法不仅可以提高在干净样本上的VQA任务的性能，还能提高<strong>在对抗样本上的鲁棒性</strong>。</p>
</li>
</ul>
<h4 id="相比于baseline还可以有效抵抗对抗攻击"><a href="#相比于baseline还可以有效抵抗对抗攻击" class="headerlink" title="相比于baseline还可以有效抵抗对抗攻击"></a>相比于baseline还可以有效抵抗对抗攻击</h4><p><img src="https://i.loli.net/2021/03/12/np4eUgXwkz2rK5M.png" alt="image-20210312172242341" style="zoom:50%;"></p>
<h3 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h3><ul>
<li><strong>何时加入对抗样本</strong> 这个实验告诉我们：一般情况，我们提出一种数据增强方案，通常会从头到尾的使用，但是未必是好的。</li>
</ul>
]]></content>
      <categories>
        <category>cross-modal</category>
        <category>VQA</category>
      </categories>
      <tags>
        <tag>cross-modal,VQA</tag>
      </tags>
  </entry>
  <entry>
    <title>Sentence-BERT: Sentence Embeddings using Siamese BERT-Networks</title>
    <url>/2020/05/31/Sentence-BERT-Sentence-Embeddings-using-Siamese-BERT-Networks/</url>
    <content><![CDATA[<h4 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h4><p>BERT 和 RoBERTa 在 sentence-pair regression tasks (eg: semantic textual similarity ) 上取得了非常不错的成绩，但是由于需要将两个句子都送入到网络中，这将造成计算量过载。举个例子，若在10000个句子中要找到最相似的对，则需要50 million的推理计算（需要计算一个上三角阵：（10000+1）*10000/2）, 使用BERT，则需要 65 hours。</p>
<p><strong>这可以看到the construction of BERT，不适于semantic similarity search、 像聚类这种无监督任务、information retrieval via semantic search等等。</strong></p>
<p><strong>因此本文：</strong> 本文提出了 sentence-BERT, 是建立在 预训练的BERT上的一种修改，使用siamese 和 triplet 网络结构来得到语义上有意义的sentence embeddings, 从而方便的计算cosine similarity.</p>
<h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h4><p>三种训练策略，现在只说到了一种，分类损失，，另外两种，是在哪些数据集上使用的？</p>
<h4 id="yaya-启发"><a href="#yaya-启发" class="headerlink" title="yaya 启发"></a>yaya 启发</h4><p>一、本文中提出的当前 BERT存在的缺陷，也正是 video-text retrieval ，这种多模态任务存在的缺陷。</p>
<p>二、We showed in (Reimers et al., 2016)[1] that Pearson correlation is badly suited for  STS. Instead, we compute the Spearman’s rank correlation between the cosine-similarity of the sentence embeddings and the gold labels  </p>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>[1] Nils Reimers, Philip Beyer, and Iryna Gurevych. 2016.<br><strong>Task-Oriented Intrinsic Evaluation of Semantic Textual Similarity.</strong><br>In Proceedings of the 26th International Conference on Computational Linguistics (COLING), pages 87–96.      </p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Seq2Seq中Exposure Bias现象的浅析与对策</title>
    <url>/2021/07/05/Seq2Seq%E4%B8%ADExposure-Bias%E7%8E%B0%E8%B1%A1%E7%9A%84%E6%B5%85%E6%9E%90%E4%B8%8E%E5%AF%B9%E7%AD%96/</url>
    <content><![CDATA[<h2 id="Seq2Seq中Exposure-Bias现象的浅析与对策"><a href="#Seq2Seq中Exposure-Bias现象的浅析与对策" class="headerlink" title="Seq2Seq中Exposure Bias现象的浅析与对策"></a>Seq2Seq中Exposure Bias现象的浅析与对策</h2><p>前些天笔者写了<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&amp;mid=2247503481&amp;idx=1&amp;sn=f998484d31148762630e2fdc16af01aa&amp;chksm=96ea11f9a19d98ef4a4c29e7fd86c01a278888374bc5a5ae9bd208de41cdfe6e53b67a09e967&amp;token=748748465&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">CRF用过了，不妨再了解下更快的MEMM？</a>，里边提到了 MEMM 的局部归一化和 CRF 的全局归一化的优劣。</p>
<p>同时，笔者联想到了 Seq2Seq 模型，因为 Seq2Seq 模型的典型训练方案 Teacher Forcing 就是一个局部归一化模型，所以它也存在着局部归一化所带来的毛病——也就是我们经常说的“Exposure Bias”。</p>
<p>带着这个想法，笔者继续思考了一翻，将最后的思考结果记录在此文。</p>
<p><img src="https://i.loli.net/2021/07/05/3zdSt9gLwn41GZa.png" alt="image-20210705121610582" style="zoom:50%;"></p>
<p>▲ 经典的 Seq2Seq 模型图示</p>
<p>本文算是一篇进阶文章，适合对Seq2Seq模型已经有一定的了解、希望进一步提升模型的理解或表现的读者。关于Seq2Seq的入门文章，可以阅读旧作<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&amp;mid=2247491314&amp;idx=1&amp;sn=3e22d4a6d732b0877fdc567d2bce1076&amp;chksm=96e9c172a19e48646005da05e143751aa9012c141dd1cf9846a2b418cbf854c7d343013105a1&amp;token=748748465&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">玩转Keras之seq2seq自动生成标题</a>和<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&amp;mid=2247499793&amp;idx=1&amp;sn=685c54d27186a89dcf32d91ce0927274&amp;chksm=96ea1f91a19d9687af5dbe751accc9c1ddd7392f6cf4294dc8a024751a64053cbcb8c60ef8f8&amp;token=748748465&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">从语言模型到Seq2Seq：Transformer如戏，全靠Mask。</a></p>
<p>本文的内容大致为：</p>
<ol>
<li>Exposure Bias 的成因分析及例子；</li>
<li>简单可行的缓解 Exposure Bias 问题的策略。</li>
</ol>
<h2 id="1-Softmax"><a href="#1-Softmax" class="headerlink" title="1. Softmax"></a>1. Softmax</h2><p>首先，我们来回顾 Softmax 相关内容。大家都知道，对于向量 $\left(x_{1}, x_{2}, \ldots, x_{n}\right)$, 它的 Softmax 为:<br>$<br>\left(p_{1}, p_{2}, \ldots, p_{n}\right)=\frac{1}{\sum_{i=1}^{n} e^{x_{i}}}\left(e^{x_{1}}, e^{x_{2}}, \ldots, e^{x_{n}}\right)<br>$<br>由于 $e^{t}$ 是关于 $t$ 的严格单调递增函数，所以如果 $x_{k}$ 是 $x_{1}, x_{2}, \ldots, x_{n}$ 中的最大者， 那么 $p_{k}$也是 $p_{1}, p_{2}, \ldots, p_{n}$ 中的最大者。<br>对于分类问题，我们所用的 Ioss 一般是交叉嫡，也就是：<br>$<br>-\log p_{t}=\log \left(\sum_{i=1}^{n} e^{x_{i}}\right)-x_{t}(2)<br>$<br>其中 $t$ 是目标类。如文章 《寻求一个光滑的最大值函数》[1] 所述，上式第一项实际上是$\max \left(x_{1}, x_{2}, \ldots, x_{n}\right)$ 的光滑近似，所以为了形象理解交叉嫡, 我们可以写出:<br>$<br>-\log p_{t} \approx \max \left(x_{1}, x_{2}, \ldots, x_{n}\right)-x_{t}<br>$<br>也就是说，交叉商实际上在缩小目标类得分 $x_{t}$ 与全局最大值的差距，显然这个差距最小只能为 0 ，并且此时目标类得分就是最大值者。所以， Softmax 加交叉嫡的效果就是“希望目标类的得分成为最大值”。</p>
<h2 id="2-Teacher-Forcing"><a href="#2-Teacher-Forcing" class="headerlink" title="2. Teacher Forcing"></a>2. Teacher Forcing</h2><p>现在，我们来看 Seq2Seq，它通过条件分解来建模联合概率分布：</p>
<p>$\begin{aligned} p(\boldsymbol{y} \mid \boldsymbol{x}) &amp;=p\left(y_{1}, y_{2}, \ldots, y_{n} \mid \boldsymbol{x}\right) \\ &amp;=p\left(y_{1} \mid \boldsymbol{x}\right) p\left(y_{2} \mid \boldsymbol{x}, y_{1}\right) \ldots p\left(y_{n} \mid \boldsymbol{x}, y_{1}, \ldots, y_{n-1}\right) \end{aligned}$</p>
<p>每一项自然也就用 Softmax 来建模的，即：</p>
<p>$p\left(y_{1} \mid \boldsymbol{x}\right)=\frac{e^{f\left(y_{1} ; \boldsymbol{x}\right)}}{\sum_{y_{1}} e^{f\left(y_{1} ; \boldsymbol{x}\right)}}$,<br>$p\left(y_{2} \mid \boldsymbol{x}, y_{1}\right)=\frac{e^{f\left(y_{1}, y_{2} ; \boldsymbol{x}\right)}}{\sum_{y_{2}} e^{f\left(y_{1}, y_{2} ; \boldsymbol{x}\right)}}$,<br>$\ldots$,<br>$p\left(y_{n} \mid \boldsymbol{x}, y_{1}, \ldots, y_{n-1}\right)=\frac{e^{f\left(y_{1}, y_{2}, \ldots, y_{n} ; \boldsymbol{x}\right)}}{\sum_{y_{n}} e^{f\left(y_{1}, y_{2}, \ldots, y_{n} ; \boldsymbol{x}\right)}}$</p>
<p>乘起来就是：<br>$<br>p(\boldsymbol{y} \mid \boldsymbol{x})=\frac{e^{f\left(y_{1} ; \boldsymbol{x}\right)}}{\left(\sum_{y_{1}} e^{f\left(y_{1} ; \boldsymbol{x}\right)}\right)\left(\sum_{y} e^{f\left(y_{1}, y_{2} ; \boldsymbol{x}\right)}\right) \ldots\left(\sum_{y_{n}} e^{f\left(y_{1}, y_{2}, \ldots, y_{n} ; \boldsymbol{x}\right)}\right)}<br>$<br>而训练目标就是：<br>$-\log p(\boldsymbol{y} \mid \boldsymbol{x})=-\log p\left(y_{1} \mid \boldsymbol{x}\right)-\log p\left(y_{2} \mid \boldsymbol{x}, y_{1}\right)-\cdots-\log p\left(y_{n} \mid \boldsymbol{x}, y_{1}, \ldots, y_{n-1}\right)$这个直接的训练目标就叫做 Teacher Forcing, 因为在算 $-\log p\left(y_{2} \mid \boldsymbol{x}, y_{1}\right)$ 的时候我们要知道真实的 $y_{1}$, 在算 $-\log p\left(y_{3} \mid \boldsymbol{x}, y_{1}, y_{2}\right)$ 我们需要知道真实的 $y_{1}, y_{2}$, 依此类推， 这就好像有一个经验丰富的老师预先给我们铺好了大部分的路，让我们只需要求下一步即可。</p>
<p>这个直接的训练目标就叫做 Teacher Forcing，因为在算 的时候我们要知道真实的 ，在算 我们需要知道真实的 ，依此类推，这就好像有一个经验丰富的老师预先给我们铺好了大部分的路，让我们只需要求下一步即可。</p>
<p>这种方法训练起来简单，而且结合 CNN 或 Transformer 那样的模型就可以实现并行的训练，但它可能会带来 Exposure Bias 问题。</p>
<h2 id="3-Exposure-Bias"><a href="#3-Exposure-Bias" class="headerlink" title="3. Exposure Bias"></a>3. Exposure Bias</h2><p>其实 Teacher Forcing 这个名称本身就意味着它本身会存在 Exposure Bias 问题。回想一下老师教学生解题的过程，一般的步骤为：</p>
<ul>
<li>第一步应该怎么思考；</li>
<li>第一步想出来后，第二步我们有哪些选择；</li>
<li>确定了第二步后，第三步我们可以怎么做；</li>
<li>…</li>
<li>有了这 n-1 步后，最后一步就不难想到了。</li>
</ul>
<p>这个过程其实跟 Seq2Seq 的 Teacher Forcing 方案的假设是一样的。有过教学经验的读者就知道，通常来说学生们都能听得频频点头，感觉全都懂了，然后让学生课后自己做题，多数还是一脸懵比。</p>
<p>为什么会这样呢？其中一个原因就是 Exposure Bias。说白了，问题就在于，老师总是假设学生能想到前面若干步后，然后教学生下一步，但如果前面有一步想错了或者想不出来呢？这时候这个过程就无法进行下去了，也就是没法得到正确答案了，这就是 Exposure Bias 问题。</p>
<h2 id="4-Beam-Search"><a href="#4-Beam-Search" class="headerlink" title="4. Beam Search"></a>4. Beam Search</h2><p>事实上，我们真正做题的时候并不总是这样子，假如我们卡在某步无法确定时，我们就遍历几种选择，然后继续推下去，看后面的结果反过来辅助我们确定前面无法确定的那步。对应到 Seq2Seq 来说，这其实就相当于基于 Beam Search 的解码过程。</p>
<p>对于 Beam Search，我们应该能发现，beam size 并不是越大越好，有些情况甚至是 beam size 等于 1 时最好，这看起来有点不合理，因为 beam size 越大，理论上找到的序列就越接近最优序列，所以应该越有可能正确才对。事实上这也算是 Exposure Bias 的现象之一。</p>
<p>从式（6）我们可以看出，Seq2Seq 对目标序列 的打分函数为：</p>
<p>$f\left(y_{1} ; \boldsymbol{x}\right)+f\left(y_{1}, y_{2} ; \boldsymbol{x}\right)+\cdots+f\left(y_{1}, y_{2}, \ldots, y_{n} ; \boldsymbol{x}\right)$</p>
<p>正常来说，我们希望目标序列是所有候选序列之中分数最高的，根据本文开头介绍的 Softmax 方法，我们建立的概率分布应该是：</p>
<p>$p(\boldsymbol{y} \mid \boldsymbol{x})=\frac{e^{f\left(y_{1} ; \boldsymbol{x}\right)+f\left(y_{1}, y_{2} ; \boldsymbol{x}\right)+\cdots+f\left(y_{1}, y_{2}, \ldots, y_{n} ; \boldsymbol{x}\right)}}{\sum_{y_{1}, y_{2}, \ldots, y_{n}} e^{f\left(y_{1} ; \boldsymbol{x}\right)+f\left(y_{1}, y_{2} ; \boldsymbol{x}\right)+\cdots+f\left(y_{1}, y_{2}, \ldots, y_{n} ; \boldsymbol{x}\right)}}$</p>
<p>但上式的分母需要遍历所有路径求和，难以实现，而式（6）就作为一种折衷的选择得到了广泛应用。但式（6）跟式（9）并不等价，因此哪怕模型已经成功优化，也可能出现“最优序列并不是目标序列”的现象。</p>
<h2 id="5-简单例子"><a href="#5-简单例子" class="headerlink" title="5. 简单例子"></a>5. 简单例子</h2><p>我们来举一个简单例子。设序列长度只有 2，候选序列是 $(a, b)$ 和 $(c, d)$, 而目标序列是<br>$(a, b)$, 训练完成后，模型的概率分布情况为：</p>
<p><img src="https://i.loli.net/2021/07/05/l5dg34prCf8vzbB.png" alt="image-20210705122243485" style="zoom:50%;"></p>
<p>如果 beam size 为 1, 那么因为 $p(a)&gt;p(c)$, 所以第一步只能输出 $a$, 接着因为$p(b \mid a)&gt;p(d \mid a)$, 所以第二步只能输出 $b$, 成功输出了正确序列 $(a, b)$ 。但如果 beam size 为 2，那么第一步输出 $(a, 0.6),(c, 0.4)$, 而第二步遍历所有组合，我们得到：</p>
<p><img src="https://i.loli.net/2021/07/05/9SyY3m6nARxGofN.png" alt="image-20210705122317192" style="zoom:50%;"></p>
<p>所以输出了错误的序列 $(c,d)$。</p>
<p>那是因为模型没训练好吗？并不是，前面说过 Softmax 加交叉商的目的就是让目标的得分最大，对于第一步我们有 $p(a)&gt;p(c)$, 所以第一步的训练目标已经达到了，而第二步在 $a$ 已经预先知道的前提下我们有 $p(b \mid a)&gt;p(d \mid a)$ ，这说明第二步的训练目标也达到了。</p>
<p>因此，模型已经算是训练好了，只不过可能因为模型表达能力限制等原因，得分并没有特别高，但“让目标的得分最大”这个目标已经完成了。</p>
<h2 id="6-思考对策"><a href="#6-思考对策" class="headerlink" title="6. 思考对策"></a>6. 思考对策</h2><p>从上述例子中读者或许可以看出问题所在了：主要是 $p(d \mid c)$ 太高了，而 $p(d \mid c)$ 是没有经过训练的，没有任何显式的机制去抑制 $p(d \mid c)$ 变大，因此就出现了“最优序列并不是目标序列”的现象。</p>
<p>看到这里，读者可能就能想到一个朴素的对策了：添加额外的优化目标，降低那些Beam Search出来的非目标序列不就行了？</p>
<p>事实上，这的确是一个有效的解决方法，相关结果发表在 2016 年的论文 <strong><em>Sequence-to-Sequence Learning as Beam-Search Optimization</em></strong> [2]。但这样一来几乎要求每步训练前的每个样本都要进行一次 Beam Search，计算成本太大。</p>
<p>还有一些更新的结果，比如 ACL 2019 的最佳长论文 <strong><em>Bridging the Gap between Training and Inference for Neural Machine Translation\</em></strong> [3] 就是聚焦于解决 Exposure Bias 问题。此外，通过强化学习直接优化 BLEU 等方法，也能一定程度上缓解 Exposure Bias。</p>
<p>然而，据笔者所了解，这些致力于解决 Exposure Bias 的方法，大部分都是大刀阔斧地改动了训练过程，甚至会牺牲原来模型的训练并行性（需要递归地采样负样本，如果模型本身是 RNN 那倒无妨，但如果本身是 CNN 或 Transformer，那伤害就很大了），成本的提升幅度比效果的提升幅度大得多。</p>
<h2 id="7-构建负样本"><a href="#7-构建负样本" class="headerlink" title="7. 构建负样本"></a>7. 构建负样本</h2><p>纵观大部分解决 Exposure Bias 的论文，以及结合我们前面的例子和体会，不难想到，其主要思想就是构造有代表性的负样本，然后在训练过程中降低这些负样本的概率，所以问题就是如何构造“有代表性”的负样本了。</p>
<p>这里给出笔者构思的一种简单策略，实验证明它能一定程度上缓解 Exposure Bias，提升文本生成的表现，重要的是，这种策略比较简单，基本能做到即插即用，几乎不损失训练性能。</p>
<p>方法很简单，就是随机替换一下 Decoder 的输入词（Decoder 的输入词有个专门的名字，叫做 oracle words），如下图所示：</p>
<p><img src="https://i.loli.net/2021/07/05/KblSQv4UzCkoVW5.png" alt="image-20210705121402164" style="zoom:50%;"></p>
<p>▲ 一种缓解Exposure Bias的简单策略：直接将Decoder的部分输入词随机替换为别的词</p>
<p>其中紫色的 [R] 代表被随机替换的词。其实不少 Exposure Bias 的论文也是这个思路，只不过随机选词的方案不一样。笔者提出的方案很简单：</p>
<ol>
<li><p>50% 的概率不做改变；</p>
</li>
<li><p>50% 的概率把输入序列中 30% 的词替换掉，替换对象为原目标序列的任意一个词。</p>
</li>
</ol>
<p>也就是说，随机替换发生概率是 50%&gt;&gt;随机替换的比例是 30%，随机抽取空间就是目标序列的词集。</p>
<p>这个策略的灵感在于：尽管 Seq2Seq 不一定能完全生成目标序列，但它通常能生成大部分目标序列的词（但顺序可能不对，或者重复出现同一些词），因此这样替换后的输入序列通常可以作为有代表性的负样本。对了，说明一下，50% 和 30% 这两个比例纯粹是拍脑袋的，没仔细调参，因为生成模型调一次实在是太累了。</p>
<p>效果如何呢？笔者做了两个标题（摘要）生成的实验（就是 CLGE [4] 的前两个），其中 baseline 是 task_seq2seq_autotitle_csl.py [5]，代码开源于：</p>
<p><a href="https://github.com/bojone/exposure_bias" target="_blank" rel="noopener">https://github.com/bojone/exposure_bias</a></p>
<p>结果如下表：</p>
<p><img src="https://i.loli.net/2021/07/05/ae1MA82g9zBV6Lr.png" alt="image-20210705121333189" style="zoom:50%;"></p>
<p><img src="https://i.loli.net/2021/07/05/WlX9DUvHn1iYA62.png" alt="image-20210705121322078" style="zoom:50%;"></p>
<p>可以发现，在 CSL 任务中，基于随机替换的策略稳定提升了文本生成的所有指标，而 LCSTS 任务的各个指标则各有优劣，考虑到 LCSTS 本身比较难，各项指标本来就低，所以应该说 CSL 的结果更有说服力一些。</p>
<p>这表明，笔者提出的上述策略确实是一种值得尝试的方案（注：所有实验都重复了两次然后取平均，所以实验结果应该是比较可靠的了）。</p>
<h2 id="8-对抗训练"><a href="#8-对抗训练" class="headerlink" title="8. 对抗训练"></a>8. 对抗训练</h2><p>思考到这里，我们不妨再“天马行空”一下：既然解决 Exposure Bias 的思路之一就是要构造有代表性的负样本输入，说白了就是让模型在扰动下依然能预测正确，而前些天我们不是才讨论了一种生成扰动样本的方法吗？</p>
<p>不错，那就是<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&amp;mid=2247504686&amp;idx=2&amp;sn=087dc7e98ede7960b3baacb20d55ce40&amp;chksm=96ea0caea19d85b8dccc52f07763b82f4aaffda6dd4cbdd784e682f13de6a11c6ced5b8df96f&amp;token=748748465&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">对抗训练</a>。如果直接往 baseline 模型里边加入对抗训练，能不能提升模型的性能呢？简单起见，笔者做了往 baseline 模型里边梯度惩罚（也算是对抗训练的一种）的实验，结果对比如下：</p>
<p><img src="https://i.loli.net/2021/07/05/ZOhswW8mGaSxIYc.png" alt="image-20210705121226535" style="zoom:50%;"></p>
<p><img src="https://i.loli.net/2021/07/05/J1pAQX28GScMPIB.png" alt="image-20210705121209230" style="zoom:50%;"></p>
<p>可以看到，对抗训练（梯度惩罚）进一步提升了 CSL 生成的所有指标，而 LCSTS 上则同样比较“随缘”。因此，对抗训练也可以列入“提升文本生成模型的潜力技巧”名单之中。</p>
<h2 id="9-本文小结"><a href="#9-本文小结" class="headerlink" title="9. 本文小结"></a>9. 本文小结</h2><p>本文讨论了 Seq2Seq 中的 Exposure Bias 现象，尝试从直观上和理论上分析 Exposure Bias 的原因，并给出了简单可行的缓解 Exposure Bias 问题的对策。</p>
<p>其中包括笔者构思的一种随机替换策略，以及基于对抗训练的策略，这两种策略的好处是它们几乎是即插即用的，并且实验表明它们能一定程度上提升文本生成的各个指标。</p>
<p><strong>相关链接</strong></p>
<p>[1] <a href="https://kexue.fm/archives/3290" target="_blank" rel="noopener">https://kexue.fm/archives/3290</a></p>
<p>[2] <a href="https://arxiv.org/abs/1606.02960" target="_blank" rel="noopener">https://arxiv.org/abs/1606.02960</a></p>
<p>[3] <a href="https://arxiv.org/abs/1906.02448" target="_blank" rel="noopener">https://arxiv.org/abs/1906.02448</a></p>
<p>[4] <a href="https://github.com/CLUEbenchmark/CLGE" target="_blank" rel="noopener">https://github.com/CLUEbenchmark/CLGE</a></p>
<p>[5] <a href="https://github.com/bojone/bert4keras/blob/master/examples/task_seq2seq_autotitle_csl.py" target="_blank" rel="noopener">https://github.com/bojone/bert4keras/blob/master/examples/task_seq2seq_autotitle_csl.py</a></p>
]]></content>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Show, Attend and Tell: Neural Image Caption Generation with Visual Attention</title>
    <url>/2019/05/06/Show-Attend-and-Tell-Neural-Image-Caption-Generation-with-Visual-Attention/</url>
    <content><![CDATA[<ul>
<li>encoder  attention<br>本文的出发点是利用低层次的特征，并结合了attention 机制<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2re7nfbn3j30q70430sx.jpg"></li>
</ul>
<p>参考链接：<a href="https://blog.csdn.net/shenxiaolu1984/article/details/51493673" target="_blank" rel="noopener">https://blog.csdn.net/shenxiaolu1984/article/details/51493673</a></p>
]]></content>
      <categories>
        <category>图像描述</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>Show, Control and Tell: A Framework for Generating Controllable and Grounded Captions</title>
    <url>/2021/07/16/Show-Control-and-Tell-A-Framework-for-Generating-Controllable-and-Grounded-Captions/</url>
    <content><![CDATA[<p>来源：<a href="https://zhuanlan.zhihu.com/p/150667499" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/150667499</a></p>
<p>这是一篇收录于CVPR2019的图像描述生成文章，该文章提出了一种可以通过外部信号（图像区域）进行控制的图像描述生成模型，并且在可控描述质量与多样性两方面达到了Flickr30k Entities与COCO Entities数据集上的SOTA。作者声称，这是他们所知道的第一个可以基于图像区域进行控制的图像描述生成模型。</p>
<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>在对一张图像进行描述时，<strong>由于描述者的目标不同、关注的区域不同，进行描述的方式与角度也不尽相同</strong>。在对复杂的场景进行描述时，常常需要对模型进行控制，使模型更加关注于使用者感兴趣的区域，而现有的模型在生成图像描述时通常处于黑箱的状态，缺乏可控性与可解释性。</p>
<p>这篇文章提出了一种可控的图片描述生成模型，可以通过外界的控制信号操控模型生成多样化的描述。具体地，<strong>模型将图像中的一组区域作为控制信号</strong>，并生成基于这些区域的图像描述。如下图所示：</p>
<p><img src="https://i.loli.net/2021/07/16/aJeySqRXlhZCBNr.png" alt="image-20210716101209297" style="zoom:80%;"></p>
<p>上图中的（a）表示原始的图像描述生成模型，该模型将整张图像的特征作为输入，并得到基于图像整体的描述；（b）表示Up-Down模型生成描述的过程，该模型通过Faster R-CNN检测出一些目标区域，并综合这些目标区域的特征生成描述；（c）表示本文模型生成描述的过程，<strong>给定一个区域序列（或集合），模型会基于这些<font color="red">区域的特征</font>与<font color="red">顺序</font>生成描述，而忽略其他区域的特征，从而实现可控的图像描述</strong>。</p>
<p><img src="https://i.loli.net/2021/07/16/ANkfqLd3vpGQTRX.png" alt="image-20210716101331736" style="zoom: 67%;"></p>
<p>上图是将无序的区域集合作为控制信号时，模型的描述效果，图中的方框表示作为控制信号的区域。可以看到，控制信号中的物体都准确地出现在了描述中，而不在控制信号中的物体则没有出现。</p>
<p><img src="https://i.loli.net/2021/07/16/63CENAQTO5w9vhg.png" alt="image-20210716101547116"></p>
<p>上图是将有序的集合序列作为控制信号时模型的效果，可以看到描述中的名词块顺序与控制信号中的顺序一致。</p>
<h2 id="二、方法"><a href="#二、方法" class="headerlink" title="二、方法"></a>二、方法</h2><p><img src="https://i.loli.net/2021/07/16/4a6jA7cxRDlqo8k.png" alt="image-20210716101714728" style="zoom:67%;"></p>
<p>我们可以将图像描述中的单词分为两种：第一种是视觉词（visual words），表示对应于图中某个视觉实体的单词，如图中的boy、cap、shirt等；第二种是文本词（textual words），表示在图中没有对应实体的单词，如图中的a、with、on等。</p>
<p>进一步地，句中的每个名词可以与它的修饰语组成一个“名词块”（noun chunk），比如上文中的“a young boy”、“gray sweat jacket”等。这些名词块类似视觉词，通常与图像中的特定区域相对应，某些情况下，一个名词块也可能会与多个图像区域相对应。</p>
<p>每条描述由一系列的名词块连接而成，因此也对应着图像中的一组区域。只要改变生成描述时所考虑的图像区域或描述区域的顺序，便可以生成不同的图像描述。</p>
<p>基于上述假设，本文将图像中的一组区域作为控制信号输入模型中，使模型根据控制信号逐个生成名词块，并将名词块拼接成完整的句子，从而生成可控的、多样的图像描述。</p>
<p><img src="https://i.loli.net/2021/07/16/fCqmM3vZonAdbOu.png" alt="image-20210716101935615"></p>
<p>具体模型如上图所示，该模型的主要结构有：</p>
<p>1.Language model，由两层LSTM组成的语言模型，在每个时间点基于当前区域的特征与当前状态生成下一时刻的单词；</p>
<p>2.Chunk shifting gate，用于决定何时切换到下一个图像区域；</p>
<p>3.Adaptive attention，用于决定将要生成的单词是视觉词（基于视觉信息生成）还是文本词（基于当前的语句信息生成）；</p>
<p>4.Sorting network，在输入的控制信号为区域集合（无序）时，使用sorting network对控制信号进行排序。</p>
<p><strong>Language Model</strong></p>
<p><img src="https://i.loli.net/2021/07/16/vGzUDmCHS4qZt2f.png" alt="image-20210716102126047" style="zoom:50%;"></p>
<p>本文使用了双层LSTM结合attention作为语言模型。</p>
<p>第一层LSTM主要用于计算attention，给定上一时刻输出的单词向量 $y_{t-1}$ 、图像的总体特 征 $I$ 、上一时刻第二层LSTM的隐藏状态 $h_{t-1}^{2}$ 作为输入，第一层LSTM的输出结果用于计 算Adaptive Attention以及Chunk Shifting Gate, 决定下一步生成视觉词还是文本词, 以 及决定是否切换到下一个图像区域;<br>第二层LSTM主要作为language model，接受第一层的隐藏状态 $h_{t}^{1}$ 以及经过Adaptive Attention的上下文特征 $c_{t}$ 作为输入，预测下一个单词。<br>注意，本文通过对控制信号中所有区域的特征向量进行mean-pooling，将得到的结果作为 图像的总体特征 $I$ 。</p>
<p><strong>Chunk Shifting Gate</strong></p>
<p>Chunk Shifting Gate是一个布尔类型的门控变量，使用它更新当前区域的规则如下：</p>
<p>$\boldsymbol{r}_{t+1} \leftarrow \boldsymbol{R}[i], \quad$ where $i=\min \left(\sum_{k=1}^{t} g_{k}, N\right), g_{k} \in\{0,1\}$</p>
<p>上式中R表示由图像区域组成的有序序列，需要注意的是，由于每个名词块可能是基于多个 图像区域产生的，因此R中的每个元素都是一个区域集合，集合中通常只有一个区域，在集 合中包含多个区域的情况下，名词块便会综合这些区域的信息而产生。<br>上式中的 $r_{t+1}$ 表示在t+1时刻所考虑的区域集合, $\mathrm{N}$ 表示R中的区域集合数量。对于每个区 域, 作者使用Resnet-101提取区域中的特征, 并使用特征向量表示这个区域，因此控制信号 也可以视作由一组区域的特征向量组成。<br>可以看到，在每个时刻，如果该时刻的门控变量 $g_{t}$ 为 1, 则将 $r_{t+1}$ 更新为R中的下一个区 域集合，否则不更新。<br>门控变量 $g_{t}$ 的具体计算方法如下。在每个时间点，基于第一层LSTM的状态设立一个chunk sentinel, 记作 $s_{c}^{t}$, chunk sentinel可以表示在每个chunk结尾处LSTM的状态。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&l_{t}^{c}=\sigma\left(\boldsymbol{W}_{i g} \boldsymbol{x}_{t}+\boldsymbol{W}_{h g} \boldsymbol{h}_{t-1}\right) \\
&\boldsymbol{s}_{t}^{c}=l_{t}^{c} \odot \tanh \left(\boldsymbol{m}_{t}\right)
\end{aligned}</script><p>其中 $m_{t}$ 表示LSTM的cel|状态, $h_{t-1}$ 表示上一时刻 $\mathrm{STM}$ 的隐藏状态。随后, 模型基于 $s_{c}^{t}$ 与区域特征 $r_{t} ，$ 计算 $g_{t}$ 的概率分布:</p>
<script type="math/tex; mode=display">
\begin{gathered}
z_{t}^{c}=\boldsymbol{w}_{h}^{T} \tanh \left(\boldsymbol{W}_{s g} \boldsymbol{s}_{t}^{c}+\boldsymbol{W}_{g} \boldsymbol{h}_{t}\right) \\
\boldsymbol{z}_{t}^{r}=\boldsymbol{w}_{h}^{T} \tanh \left(\boldsymbol{W}_{s r} \boldsymbol{r}_{t}+\left(\boldsymbol{W}_{g} \boldsymbol{h}_{t}\right) \mathbb{1}^{T}\right)
\end{gathered}</script><script type="math/tex; mode=display">
p\left(g_{t}=1 \mid \boldsymbol{R}\right)=\frac{\exp z_{t}^{c}}{\exp z_{t}^{c}+\sum_{i=1}^{n} \exp z_{t i}^{r}}</script><p>计算过程类似于计算 $h_{t}$ 与 [ $\left.s_{t}^{c} ; r_{t}\right]$ 的attention，当模型更加注意 $s_{t}^{c}$ 时, $g_{t}=1$ 的概率 更大， 因此模型有更大的概率切换到下一个区域; 当模型更加注意 $r_{t}$ 时，模型则更有可能 停留在当前的区域。借助Chunk Shifting Gate，模型便可以决定何时切换关注的区域, 并 按照顺序生成这些区域对应的名词块。</p>
<p><strong>Adaptive Attention</strong></p>
<p>在生成单词时，为了判断当前单词究竟是基于视觉信息的视觉词还是基于当前语句信息的文本词，本文引入了Adaptive Attention机制。Adaptive Attention的计算方式如下，首先设立一个visual sentinel（类似上文的chunk sentinel）：</p>
<script type="math/tex; mode=display">
\begin{aligned}
l_{t}^{v} &=\sigma\left(\boldsymbol{W}_{i s} \boldsymbol{x}_{t}+\boldsymbol{W}_{h s} \boldsymbol{h}_{t-1}\right) \\
\boldsymbol{s}_{t}^{v} &=\boldsymbol{l}_{t}^{v} \odot \tanh \left(\boldsymbol{m}_{t}\right)
\end{aligned}</script><p>随后, 计算 $h_{t}$ 对 $\left[r_{t} ; s_{t}^{v}\right.$ ]的attention:</p>
<script type="math/tex; mode=display">
\begin{gathered}
\boldsymbol{z}_{t}^{r}=\boldsymbol{w}_{h}^{T} \tanh \left(\boldsymbol{W}_{s r} \boldsymbol{r}_{t}+\left(\boldsymbol{W}_{g} \boldsymbol{h}_{t}\right) \mathbb{1}^{T}\right) \\
\boldsymbol{\alpha}_{t}=\operatorname{softmax}\left(\left[\boldsymbol{z}_{t}^{r} ; \boldsymbol{w}_{h}^{T} \tanh \left(\boldsymbol{W}_{s s} \boldsymbol{s}_{t}^{v}+\boldsymbol{W}_{g} \boldsymbol{h}_{t}\right)\right]\right)
\end{gathered}</script><p>基于attention的结果, 可以计算出当前时刻模型正在关注的上下文特征 $c_{t}:$</p>
<script type="math/tex; mode=display">
\boldsymbol{c}_{t}=\sum_{i=1}^{n+1} \boldsymbol{\alpha}_{t i}\left[\boldsymbol{r}_{t} ; \boldsymbol{s}_{t}^{v}\right]</script><p>在大多数时候, 模型只会关注 $s_{t}^{v}$ 或 $r_{t}$ 所包含的区域中的一个，如果模型更加关注visual sentinel, 便会生成textual word; 反之, 便会生成基于 $r_{t}$ 中某个区域的的visual word.</p>
<p><strong>Sorting Network</strong></p>
<p>上述讨论的前提是控制信号R是一组有序的图像区域序列，模型可以按照区域在R中的顺序生成相应的文本。如果给定的控制信号是无序的，如何使模型按照合适的顺序生成文本？本文使用了一种sorting network对无序的控制信号进行排序，实现方法如下。</p>
<p>假设无序的集合R中包含N个区域集，首先使用全连接层将每个区域集的特征映射为N维向量，随后将所有特征向量拼接，得到N*N的特征矩阵；随后使用Sinkhorn算子迭代地处理特征矩阵，经过该算子可以得到一个类似置换矩阵的“软”置换矩阵，它与置换矩阵的主要区别在于置换矩阵是离散的，而它是连续的。</p>
<p>在训练时，作者通过最小化该置换与真实结果之间的均方误差来训练网络；在测试时，则使用匈牙利算法进行匹配，将“软”置换矩阵转化为最终的置换，以此来对R进行排序。</p>
<h2 id="三、训练"><a href="#三、训练" class="headerlink" title="三、训练"></a>三、训练</h2><p>由于模型需要同时预测两个分布, $-$ 个是 $p\left(y_{t} \mid R\right) ，$ 表示寺刻生成单词的概率分布; 另一 个是 $p\left(g_{t} \mid R\right) ，$ 表示t时刻chunk shifting gate的概率分布。为了同时训练两个分布, 模型 训练时的loss function如下:</p>
<script type="math/tex; mode=display">
\begin{aligned}
L(\theta) &=-\sum_{t=1}^{T}(\log \overbrace{p\left(y_{t}^{*} \mid \boldsymbol{r}_{1: t}^{*}, \boldsymbol{y}_{1: t-1}^{*}\right)}^{\text {Word-level probability }}+\\
&+g_{t}^{*} \log p\left(g_{t}=1 \mid \boldsymbol{r}_{1: t}^{*}, \boldsymbol{y}_{1: t-1}^{*}\right)+\\
&+\left(1-g_{t}^{*}\right)(1-\log \underbrace{p\left(g_{t}=1 \mid \boldsymbol{r}_{1: t}^{*}, \boldsymbol{y}_{1: t-1}^{*}\right)}_{\text {Chunk-level probability }})
\end{aligned}</script><p>其中 $y_{1: t}^{<em>}, g_{1: t}^{</em>} \quad r_{1: t}^{*}$ 为ground truth。除了使用cross entropy作为损失函数，本文 还使用了强化学习对模型进行优化，并使用如下表达式计算损失函数的梯度：</p>
<script type="math/tex; mode=display">
\nabla_{\theta} L(\theta)=-\left(r\left(\boldsymbol{w}^{s}\right)-b\right)\left(\nabla_{\theta} \log p\left(\boldsymbol{w}^{s}\right)+\nabla_{\theta} \log p\left(\boldsymbol{g}^{s}\right)\right)</script><p>其中 $w^{s}$ 与 $g^{s}$ 表示模型预测得到的句子与chunk shifting gate序列, $r\left(w^{s}\right)$ 表示对于 $w^{s}$ 的奖励, 而b表示奖励的baseline, 只有超过baseline才能获得奖励。此处b $=r\left(w^{\prime}\right)$, $w^{\prime}$ 表示模型使用贪心策略生成的句子。<br>除了提高描述的质量，本文模型还需要保证描述的可控性，因此除了衡量描述质量的指标 CIDEr, 本文还提出了另一种指标NW，用于衡量模型生成的语句与控制信号的对齐程度，并 将CIDEr与NW同时作为强化学习时的奖励。NW的计算方式如下。<br>对于模型生成的句子y与数据集中与之对应的句子 $\mathrm{y}^{\star}$, 首先将所有名词从两个句子中提取出 来，随后将这些名词对齐。 对于相匹配的两个名词，将它们的embedding向量夹角的cos值 作为匹配分数; 如果存在未匹配的名词，则将匹配分数记作-1。将所有匹配分数加和后，使 用两个句子中较多的名次数对分数做归一化, 公式如下:</p>
<script type="math/tex; mode=display">
\mathrm{NW}\left(\boldsymbol{y}, \boldsymbol{y}^{*}\right)=\frac{a l\left(\boldsymbol{y}, \boldsymbol{y}^{*}\right)}{\max \left(\# \boldsymbol{y}, \# \boldsymbol{y}^{*}\right)}</script><p>在所有的名词对齐中，挑选最高的NW分数作为最终的NW分数。</p>
<h2 id="四、评估"><a href="#四、评估" class="headerlink" title="四、评估"></a>四、评估</h2><h3 id="4-1-数据集"><a href="#4-1-数据集" class="headerlink" title="4.1 数据集"></a>4.1 <strong>数据集</strong></h3><p>本文在两个数据集上进行评估，分别是Flickr30k Entities与COCO Entities。其中，Flickr30k是图像描述生成工作中常用的数据集，Flickr30k Entities是它的扩展数据集。对于每条描述，Flickr30k Entities挑选出其中的所有名词块，并使用bounding box标注出图像中的对应物体。如下图所示：</p>
<p><img src="https://i.loli.net/2021/07/16/6KAp8l9vDuWnMba.jpg" alt="img"></p>
<p>MSCOCO是图像描述生成工作的常用数据集，COCO Entities是MSCOCO数据集的扩展，由本文作者提出。对于MSCOCO中的每条描述，作者将其中的每个名词与5个相似度最高的物体类别关联到一起（使用词向量的相似度）；随后使用目标检测器检测图片中的目标，如果检测到的目标类别与名词类别匹配，便将名词与目标区域相关联；最后，人工检查每个关联是否正确。下图是COCO Entities数据集中的一个例子：</p>
<p><img src="https://i.loli.net/2021/07/16/HukQ4vXIm291sWS.jpg" alt="img"></p>
<h3 id="4-2-评估指标"><a href="#4-2-评估指标" class="headerlink" title="4.2 评估指标"></a>4.2 <strong>评估指标</strong></h3><p>文章的评估方法与常规的image captioning评估有所区别。在评估时，除了将图像作为输入外，作者还将图像中的一系列区域作为控制信号输入；相应地，在评估生成描述的质量时，在数据集中只有控制信号与其相同的句子会作为衡量标准。</p>
<p>关于评估指标的选取，除了常用的BLUE-4、METEOR、ROUGE、CIDEr、SPICE外，在使用区域序列作为控制信号时，作者还使用了上文提到的NW分数来评估生成描述中的名词块与控制信号的对齐效果；而在使用区域集合作为控制信号时，为了评估生成的描述对控制信号的覆盖效果，作者还提出了一种类似交并比(IoU)的评测指标：</p>
<script type="math/tex; mode=display">
\operatorname{IoU}\left(\boldsymbol{y}, \boldsymbol{y}^{*}\right)=\frac{\mathrm{I}\left(\boldsymbol{y}, \boldsymbol{y}^{*}\right)}{\# \boldsymbol{y}+\# \boldsymbol{y}^{*}-\mathrm{I}\left(\boldsymbol{y}, \boldsymbol{y}^{*}\right)}</script><p>其中, $I\left(y, y^{*}\right)$ 表示将两个句子中的名词对齐后，相应名词的词向量cos相似度之和。 $10 \mathrm{U}$ 越高, 两个句子中名词的重合率便越高。</p>
<h3 id="4-3-Baselines"><a href="#4-3-Baselines" class="headerlink" title="4.3 Baselines"></a>4.3 <strong>Baselines</strong></h3><p><strong>1.Controllable LSTM</strong></p>
<p>在Controllable LSTM中，作者使用一个没有attention的、单层的LSTM作为语言模型。随后，作者将控制信号序列R中的特征输入到另一个LSTM中，并提取这个LSTM最终的隐藏状态，将该隐藏状态与图像特征进行拼接，输入到LSTM语言模型中，以此实现控制效果。</p>
<p><strong>2.Controllable Up-Down</strong></p>
<p>Up-Down模型是一种比较具有代表性的图像描述生成模型，它通过目标检测器检测出图像中的物体，并基于这些物体所在的图像区域生成描述。作者实现Controllable Up-Down的方式比较简单，将控制信号R中的区域输入到Up-Down模型中，并忽略图像中的其他区域即可。当然，由于Up-Down模型中对于不同区域的关注是无序的，因此Controllable Up-Down并不能按照给定的区域顺序生成描述。</p>
<p><strong>3.Ours without visual sentinel</strong></p>
<p>为了验证visual sentinel的重要性，作者提出了没有visual sentinel的模型，此时模型缺乏识别visual word与textual word的能力。</p>
<p><strong>4.Ours with single sentinel</strong></p>
<p>本文中visual sentinel与chunk sentinel的计算方式比较相似，为了验证它们的重要性，作者提出了将visual sentinel与chunk sentinel融合的模型，此时将有一个单独的sentinel同时充当二者的功能。</p>
<p><strong>5.Others</strong></p>
<p>本文还使用了几种不可控的模型作为对比，分别是FC-2K、Up-Down、Neural Baby Talk。需要注意的是，由于这几种模型无法接收控制信号所带来的额外信息，因此将本文模型与它们直接做对比是不公平的。</p>
<h3 id="4-4-定量评估"><a href="#4-4-定量评估" class="headerlink" title="4.4 定量评估"></a>4.4 <strong>定量评估</strong></h3><p>作者从三个角度评估模型的效果，分别是在有序控制信号下的效果、无序控制信号下的效果以及描述生成的多样性。</p>
<p><img src="https://i.loli.net/2021/07/16/FWhJRBAcynQiafC.png" alt="image-20210716105025286"></p>
<center>在COCO Entities上的评估结果（有序控制信号）</center>

<p><img src="https://i.loli.net/2021/07/16/kONCgj7Z9iMpwJE.png" alt="image-20210716105151176" style="zoom:50%;"></p>
<center>在Flickr30k Entities上的评测结果（有序控制信号）</center>

<p>作者首先使用COCO Entities与Flickr30k Entities评估模型在有序控制信号下的效果。可以看到，本文的模型在所有指标上都达到了最好的效果，不过由于FC-2K、Up-Down、Neural Baby Talk模型本身是不可控的，而Controllable Up-Down模型虽然可控，但无法按照控制信号的顺序生成描述，因此<font color="red">本文模型与它们的比较并不公平</font>&gt;</p>
<p><img src="https://i.loli.net/2021/07/16/TgZWAOdFJzwexGc.png" alt="image-20210716105307222" style="zoom:50%;"></p>
<center>在COCO Entities上的评估结果（无序控制信号）</center>

<p><img src="https://i.loli.net/2021/07/16/tajQBzJMN1GViLW.png" alt="image-20210716105318174" style="zoom:50%;"></p>
<center>Flickr30k Entities上的评测结果（无序控制信号）</center>

<p>随后，作者又在两个数据集上评估了模型在无序控制信号下的效果，此时本文模型与Controllable Up-Down模型的对比是有意义的。可以发现，本文模型在绝大多数指标上都优于Controllable Up-Down。</p>
<p><img src="https://i.loli.net/2021/07/16/x5qd7ConpzR6haJ.png" alt="image-20210716105441980" style="zoom: 50%;"></p>
<center>在COCO Entities数据集上的多样性评估结果</center>



<p>作者在COCO Entities数据集上评测了模型生成描述的多样性，并与另外两个专注于提高描述多样性的模型作对比。在评估多样性时，作者将所有可行的区域都作为控制信号输入到模型中，以此保证生成多样的描述；在计算评估指标时，作者首先使用每个模型各自生成20条描述，对于数据集中的每条描述，将选择模型生成的描述中得分最高的一条进行评估，并对每个评估指标都进行如上操作。</p>
<p>经过上述操作，可以得到每个模型的20条描述对于每个指标的最高分，并将其作为最终的评估分数。模型能得到的最高分越高，说明模型有能力生成效果更好的描述，这也意味着模型的多样性更好。从评估结果中可以看到，在大多数指标中，本文的模型要明显好于其他两种模型。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>这篇文章提出了一种可控的图像描述生成模型。这种可控性体现在两方面：第一，给定图像中的一些区域，模型会基于这些区域生成描述，忽视其他的区域；第二，给定这些区域的顺序，模型会按照顺序生成描述。</p>
<p>在COCO Entities与Flickr30k Entities数据集上，作者评估了模型的可控描述生成质量，并在与其他模型的对比中得到了最佳效果（<font color="red"><strong>个人认为只有在无序控制信号时，与Controllable Up-Down模型的对比比较有意义</strong></font>）；此外，作者还评估了模型的多样性，并在与其他模型的对比中得到了较好的效果，说明该模型有能力生成更高质量的描述。</p>
]]></content>
      <categories>
        <category>图像描述</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>Spatio-Temporal Dynamics and Semantic Attribute Enriched Visual Encoding for Video Captioning（CVPR2019）</title>
    <url>/2019/05/10/Spatio-Temporal-Dynamics-and-Semantic-Attribute-Enriched-Visual-Encoding-for-Video-Captioning-1/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/09/02/T5AzpW8DHkVL2Oy.png" alt="搜狗截图20190902152617.png"></p>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul>
<li>我们的方法丰富视觉特征的<strong>时域动态temporal dynamics</strong>，通过在整个video上分层对CNN特征应用短的fourier 变换</li>
<li>从object detector 中提取高层语义，来丰富被检测object 的<strong>空间动态 spatial dynamics</strong></li>
<li>最终的表达映射到一个压缩的空间</li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul>
<li>object detector YOLO[1]</li>
<li>目标检测和C3D的输出层被用来得到高层语义属性，</li>
<li>提出的视觉特征包含检测的目标属性、目标发生的频率</li>
</ul>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>现有的video captioning model 一种使用平均池化得到特征，一种使用attention得到high level特征，但是这些视觉特征都是直接的被使用，则，这些方法没有充分利用CNN在视频字幕框架中的最新特性。我们的模型丰富了视觉特征，实验结果证明，该视觉特征与任意一个简单的语言模型相结合，可以提高其性能。</p>
<h2 id="Visual-Representation"><a href="#Visual-Representation" class="headerlink" title="Visual Representation"></a>Visual Representation</h2><ul>
<li>the visual representation of a  video V as v = [α; β; γ; η]</li>
<li>α; β; γ; η 是四个列向量，下面具体介绍如何得到这四个列向量<h3 id="Encoding-temporal-dynamics"><a href="#Encoding-temporal-dynamics" class="headerlink" title="Encoding temporal dynamics"></a>Encoding temporal dynamics</h3></li>
<li>首先已经有 f 帧 对应的CNN[2]特征向量，和c个clip对应的C3D[3]得到的特征向量</li>
<li>对某个video而言，其所有帧再某一个维度的神经元，组成了一个特征向量a，利用<strong>傅里叶变换</strong>得到一个p维度的特征向量，将a分成两半，分别进行傅里叶变换，得到一个p维度的特征向量，再次进行分半，等等一系列操作，可以得到 p×7的矩阵。则对于所有的神经元m 则得到m×p×7的张量。至此得到<strong>α</strong></li>
<li><strong>β</strong>同理，只是对clips对应的C3D特征进行处理</li>
<li>目前已经有将傅里叶变换应用在行为识别上的文章吗，但是本文是第一篇将傅里叶变换应用在视频描述上的文章。</li>
<li><font color="#0099ff" size="4" face="黑体">但是需要注意的是，该文并没有说明使用傅里叶变换的动机（rich temporal dynamics?），但是为什么使用傅里叶变换可以丰富？？</font>

</li>
</ul>
<h3 id="Encoding-Semantics-and-Spatial-Evolution"><a href="#Encoding-Semantics-and-Spatial-Evolution" class="headerlink" title="Encoding Semantics and Spatial Evolution"></a>Encoding Semantics and Spatial Evolution</h3><ul>
<li>比较复杂，利用object detector YOLO 来提取Object 以及C3D来加强语义信息，具体看论文吧</li>
</ul>
<h2 id="Experimental-Results-on-MSVD"><a href="#Experimental-Results-on-MSVD" class="headerlink" title="Experimental Results on MSVD"></a>Experimental Results on MSVD</h2><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2wd8q6kegj30dh0ig0wc.jpg">    </p>
<ul>
<li>GRU-MP - (C3D) 与 使用了傅里叶变换的GRU-EVEhft - (C3D)  相比，可知，使用傅里叶变换是有小鬼的</li>
<li>GRU-EVEhft - (CI) 与GRU-EVEhft+sem - (CI)相比，可得增加的senmatic 效果是不显著的。</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] Yolo9000: better, faster, stronger.  In IEEE CVPR, 2017<br>[2] Inception-v4, inception-resnet and the impact of residual  connections on learning. In AAAI, volume 4, page 12, 2017.<br>[3] Learning spatiotemporal features with 3d convolutional networks. In Proceedings of the IEEE international conference  on computer vision, pages 4489–4497, 2015.</p>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>SimCSE: Simple Contrastive Learning of Sentence Embeddings</title>
    <url>/2021/06/11/SimCSE-Simple-Contrastive-Learning-of-Sentence-Embeddings/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Slot Filling</title>
    <url>/2021/03/15/Slot-Filling/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Spacy工具包</title>
    <url>/2019/07/16/Spacy%E5%B7%A5%E5%85%B7%E5%8C%85/</url>
    <content><![CDATA[<h2 id="spacy的主要操作："><a href="#spacy的主要操作：" class="headerlink" title="spacy的主要操作："></a>spacy的主要操作：</h2><h3 id="1、分词断句"><a href="#1、分词断句" class="headerlink" title="1、分词断句"></a>1、分词断句</h3><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">import spacy</span><br><span class="line">nlp = spacy.<span class="built_in">load</span>(<span class="string">'en'</span>)</span><br><span class="line">doc = nlp(<span class="string">'Hello World! My name is HanXiaoyang'</span>)</span><br><span class="line"><span class="comment"># 分词</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">token</span> <span class="keyword">in</span> doc:</span><br><span class="line">    print(<span class="string">'"'</span> + <span class="keyword">token</span>.<span class="keyword">text</span> + <span class="string">'"'</span>)</span><br><span class="line"><span class="comment"># 断句</span></span><br><span class="line"><span class="keyword">for</span> sent <span class="keyword">in</span> doc.sents:</span><br><span class="line">    print(sent)</span><br></pre></td></tr></table></figure>
<p>每个token对象有着非常丰富的属性，如下的方式可以取出其中的部分属性。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">doc</span> <span class="string">=</span> <span class="string">nlp("Next</span> <span class="string">week</span> <span class="string">I'll</span>   <span class="string">be</span> <span class="string">in</span> <span class="string">Shanghai.")</span></span><br><span class="line"><span class="string">for</span> <span class="string">token</span> <span class="string">in</span> <span class="attr">doc:</span></span><br><span class="line">    <span class="string">print("&#123;0&#125;\t&#123;1&#125;\t&#123;2&#125;\t&#123;3&#125;\t&#123;4&#125;\t&#123;5&#125;\t&#123;6&#125;\t&#123;7&#125;".format(</span></span><br><span class="line">        <span class="string">token.text,</span></span><br><span class="line">        <span class="string">token.idx,</span></span><br><span class="line">        <span class="string">token.lemma_,</span></span><br><span class="line">        <span class="string">token.is_punct,</span></span><br><span class="line">        <span class="string">token.is_space,</span></span><br><span class="line">        <span class="string">token.shape_,</span></span><br><span class="line">        <span class="string">token.pos_,</span></span><br><span class="line">        <span class="string">token.tag_</span></span><br><span class="line">    <span class="string">))</span></span><br><span class="line"><span class="string">输出结果如下：</span></span><br><span class="line"><span class="string">Next</span>    <span class="number">0</span>   <span class="string">next</span>    <span class="literal">False</span>   <span class="literal">False</span>   <span class="string">Xxxx</span>    <span class="string">ADJ</span> <span class="string">JJ</span></span><br><span class="line"><span class="string">week</span>    <span class="number">5</span>   <span class="string">week</span>    <span class="literal">False</span>   <span class="literal">False</span>   <span class="string">xxxx</span>    <span class="string">NOUN</span>    <span class="string">NN</span></span><br><span class="line"><span class="string">I</span>   <span class="number">10</span>  <span class="bullet">-PRON-</span>  <span class="literal">False</span>   <span class="literal">False</span>   <span class="string">X</span>   <span class="string">PRON</span>    <span class="string">PRP</span></span><br><span class="line"><span class="string">'ll 11  will    False   False   '</span><span class="string">xx</span> <span class="string">VERB</span>    <span class="string">MD</span></span><br><span class="line">    <span class="number">15</span>      <span class="literal">False</span>   <span class="literal">True</span>        <span class="string">SPACE</span>   <span class="string">_SP</span></span><br><span class="line"><span class="string">be</span>  <span class="number">17</span>  <span class="string">be</span>  <span class="literal">False</span>   <span class="literal">False</span>   <span class="string">xx</span>  <span class="string">VERB</span>    <span class="string">VB</span></span><br><span class="line"><span class="string">in</span>  <span class="number">20</span>  <span class="string">in</span>  <span class="literal">False</span>   <span class="literal">False</span>   <span class="string">xx</span>  <span class="string">ADP</span> <span class="string">IN</span></span><br><span class="line"><span class="string">Shanghai</span>    <span class="number">23</span>  <span class="string">shanghai</span>    <span class="literal">False</span>   <span class="literal">False</span>   <span class="string">Xxxxx</span>   <span class="string">PROPN</span>   <span class="string">NNP</span></span><br><span class="line"><span class="string">.</span>   <span class="number">31</span>  <span class="string">.</span>   <span class="literal">True</span>    <span class="literal">False</span>   <span class="string">.</span>   <span class="string">PUNCT</span>   <span class="string">.</span></span><br></pre></td></tr></table></figure>
<h3 id="2、词性标注"><a href="#2、词性标注" class="headerlink" title="2、词性标注"></a>2、词性标注</h3><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 词性标注</span></span><br><span class="line">doc = nlp(<span class="string">"Next week I'll be in Shanghai."</span>)</span><br><span class="line">print([(<span class="keyword">token</span>.<span class="keyword">text</span>, <span class="keyword">token</span>.tag_) <span class="keyword">for</span> <span class="keyword">token</span> <span class="keyword">in</span> doc])</span><br></pre></td></tr></table></figure>
<p>[(‘Next’, ‘JJ’), (‘week’, ‘NN’), (‘I’, ‘PRP’), (“‘ll”, ‘MD’), (‘be’, ‘VB’), (‘in’, ‘IN’), (‘Shanghai’, ‘NNP’), (‘.’, ‘.’)]</p>
<h3 id="3、组块分析"><a href="#3、组块分析" class="headerlink" title="3、组块分析"></a>3、组块分析</h3><p>spaCy可以自动检测名词短语，并输出根(root)词，比如下面的”Journal”,”piece”,”currencies”</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">doc = nlp(<span class="string">"Wall Street Journal just published an interesting piece on crypto currencies"</span>)</span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> doc<span class="selector-class">.noun_chunks</span>:</span><br><span class="line">    print(chunk<span class="selector-class">.text</span>, chunk<span class="selector-class">.label_</span>, chunk<span class="selector-class">.root</span><span class="selector-class">.text</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果：<br>Wall Street Journal NP Journal<br>an interesting piece NP piece<br>crypto currencies NP currencies</p>
<h3 id="4、命名实体识别"><a href="#4、命名实体识别" class="headerlink" title="4、命名实体识别"></a>4、命名实体识别</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">doc = nlp(<span class="string">"Two years ago, I lived in my Beijing."</span>)</span><br><span class="line"><span class="keyword">for</span> ent <span class="keyword">in</span> doc<span class="selector-class">.ents</span>:</span><br><span class="line">    print(ent<span class="selector-class">.text</span>, ent.label_)</span><br></pre></td></tr></table></figure>
<p>输出结果：<br>Two years ago DATE<br>BeijingGPE</p>
<p>还可以用非常漂亮的可视化做显示：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> spacy import displacy</span><br><span class="line">displacy.render(doc, <span class="attribute">style</span>=<span class="string">'ent'</span>, <span class="attribute">jupyter</span>=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p><img src="//upload-images.jianshu.io/upload_images/11681023-77f9837fa7e661dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/454/format/webp" alt></p>
<p>输出结果.png</p>
<h3 id="5、句法依存解析"><a href="#5、句法依存解析" class="headerlink" title="5、句法依存解析"></a>5、句法依存解析</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">doc = nlp(<span class="string">'Wall Street Journal just published an interesting piece on crypto currencies'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> doc:</span><br><span class="line">    print(<span class="string">"&#123;0&#125;/&#123;1&#125; &lt;--&#123;2&#125;-- &#123;3&#125;/&#123;4&#125;"</span>.format(</span><br><span class="line">        token<span class="selector-class">.text</span>, token<span class="selector-class">.tag_</span>, token<span class="selector-class">.dep_</span>, token<span class="selector-class">.head</span><span class="selector-class">.text</span>, token<span class="selector-class">.head</span><span class="selector-class">.tag_</span>))</span><br></pre></td></tr></table></figure>
<p>输出结果：<br>Wall/NNP &lt;—compound— Street/NNP<br>Street/NNP &lt;—compound— Journal/NNP<br>Journal/NNP &lt;—nsubj— published/VBD<br>just/RB &lt;—advmod— published/VBD<br>published/VBD &lt;—ROOT— published/VBD<br>an/DT &lt;—det— piece/NN<br>interesting/JJ &lt;—amod— piece/NN<br>piece/NN &lt;—dobj— published/VBD<br>on/IN &lt;—prep— piece/NN<br>crypto/JJ &lt;—compound— currencies/NNS<br>currencies/NNS &lt;—pobj— on/IN</p>
<h3 id="6、-词向量"><a href="#6、-词向量" class="headerlink" title="6、==词向量=="></a>6、==词向量==</h3><p>NLP中有一个非常强大的文本表示学习方法叫做==word2vec==，通过词的上下文学习到词语的稠密向量化表示，同时在这个表示形态下，语义相关的词在向量空间中会比较接近。也有类似v(爷爷)-v(奶奶) ≈ v(男人)-v(女人)的关系。<br>在spaCy中，要使用英文的词向量，需先下载预先训练好的结果。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">python3</span> -m spacy download en_core_web_lg</span><br></pre></td></tr></table></figure>
<p>词向量的应用：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">nlp = spacy.<span class="built_in">load</span>(<span class="string">'en_core_web_lg'</span>)</span><br><span class="line"><span class="built_in">from</span> scipy import spatial</span><br><span class="line"></span><br><span class="line"><span class="comment"># 余弦相似度计算</span></span><br><span class="line">cosine_similarity = lambda x, y: <span class="number">1</span> - spatial.distance.cosine(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 男人、女人、国王、女王 的词向量</span></span><br><span class="line">man = nlp.vocab[<span class="string">'man'</span>].vector</span><br><span class="line">woman = nlp.vocab[<span class="string">'woman'</span>].vector</span><br><span class="line">queen = nlp.vocab[<span class="string">'queen'</span>].vector</span><br><span class="line">king = nlp.vocab[<span class="string">'king'</span>].vector</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 我们对向量做一个简单的计算，"man" - "woman" + "queen"</span></span><br><span class="line">maybe_king = man - woman + queen</span><br><span class="line">computed_similarities = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 扫描整个词库的词向量做比对，召回最接近的词向量</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">word</span> <span class="keyword">in</span> nlp.vocab:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">word</span>.has_vector:</span><br><span class="line">        continue</span><br><span class="line"> </span><br><span class="line">    similarity = cosine_similarity(maybe_king, <span class="built_in">word</span>.vector)</span><br><span class="line">    computed_similarities.append((<span class="built_in">word</span>, similarity))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序与最接近结果展示</span></span><br><span class="line">computed_similarities = sorted(computed_similarities, key=lambda <span class="keyword">item</span>: -<span class="keyword">item</span>[<span class="number">1</span>])</span><br><span class="line">print([w[<span class="number">0</span>].<span class="keyword">text</span> <span class="keyword">for</span> w <span class="keyword">in</span> computed_similarities[:<span class="number">10</span>]])</span><br></pre></td></tr></table></figure>
<p>输出结果：<br>[‘Queen’, ‘QUEEN’, ‘queen’, ‘King’, ‘KING’, ‘king’, ‘KIng’, ‘Kings’, ‘KINGS’, ‘kings’]</p>
<h3 id="6、词汇与文本相似度"><a href="#6、词汇与文本相似度" class="headerlink" title="6、词汇与文本相似度"></a>6、词汇与文本相似度</h3><p>在词向量的基础上，spaCy提供了从词到文档的相似度计算的方法，下面的例子是它的使用方法。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 词汇语义相似度(关联性)</span></span><br><span class="line">banana = nlp.vocab['banana']</span><br><span class="line">dog = nlp.vocab['dog']</span><br><span class="line">fruit = nlp.vocab['fruit']</span><br><span class="line">animal = nlp.vocab['animal']</span><br><span class="line"> </span><br><span class="line">print(dog.similarity(animal), dog.similarity(fruit)) <span class="comment"># 0.6618534 0.23552845</span></span><br><span class="line">print(banana.similarity(fruit), banana.similarity(animal)) <span class="comment"># 0.67148364 0.2427285</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文本语义相似度(关联性)</span></span><br><span class="line">target = nlp(<span class="string">"Cats are beautiful animals."</span>)</span><br><span class="line"> </span><br><span class="line">doc1 = nlp(<span class="string">"Dogs are awesome."</span>)</span><br><span class="line">doc2 = nlp(<span class="string">"Some gorgeous creatures are felines."</span>)</span><br><span class="line">doc3 = nlp(<span class="string">"Dolphins are swimming mammals."</span>)</span><br><span class="line"> </span><br><span class="line">print(target.similarity(doc1))  <span class="comment"># 0.8901765218466683</span></span><br><span class="line">print(target.similarity(doc2))  <span class="comment"># 0.9115828449161616</span></span><br><span class="line">print(target.similarity(doc3))  <span class="comment"># 0.7822956752876101</span></span><br></pre></td></tr></table></figure>
<p>作者：还是那个没头脑<br>链接：<a href="https://www.jianshu.com/p/74e6c5376bc0" target="_blank" rel="noopener">https://www.jianshu.com/p/74e6c5376bc0</a><br>来源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Spatio-Temporal Dynamics and Semantic Attribute Enriched Visual Encoding for Video Captioning</title>
    <url>/2019/03/01/Spatio-Temporal-Dynamics-and-Semantic-Attribute-Enriched-Visual-Encoding-for-Video-Captioning/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Spectral Networks and Deep Locally Connected Networks on Graphs</title>
    <url>/2019/04/08/Spectral-Networks-and-Deep-Locally-Connected-Networks-on-Graphs/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Stanford Scene Graph Parser</title>
    <url>/2019/03/26/Stanford-Scene-Graph-Parser/</url>
    <content><![CDATA[<ul>
<li>官网：<a href="https://nlp.stanford.edu/software/scenegraph-parser.shtml#Usage" target="_blank" rel="noopener">https://nlp.stanford.edu/software/scenegraph-parser.shtml#Usage</a></li>
</ul>
<h2 id="下载相应的文件（官网有）"><a href="#下载相应的文件（官网有）" class="headerlink" title="下载相应的文件（官网有）"></a>下载相应的文件（官网有）</h2><ul>
<li>stanford-corenlp-full-2015-12-09.zip</li>
<li>scenegraph-1.0.jar<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2></li>
</ul>
<ol>
<li>将stanford-corenlp-full-2015-12-09.zip解压，然后按照博客<a href="https://shiyaya.github.io/2019/03/26/ubuntu-%E5%AE%89%E8%A3%85-Stanford-CoreNLP/" target="_blank" rel="noopener">ubuntu 安装 Stanford CoreNLP</a>来安装corenlp</li>
<li>需要将 scenegraph-1.0.jar 放入解压之后的文件夹stanford-corenlp-full-2015-12-09中，</li>
</ol>
<ul>
<li>需要注意版本</li>
<li>java  idk 1.8+ 按照博客来就可以</li>
<li><p>corenlp 使用人家给定的2015的，不要升级</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>法1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -mx2g -cp <span class="string">"*"</span> edu.stanford.nlp.scenegraph.RuleBasedParser</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意该命令是在stanford-corenlp-full-2015-12-09文件夹下执行的<br>该方法是交互式的，提示你输入句子，他给出相对应的解析出的scene graph</p>
</li>
</ul>
<p>法2：</p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>[T5] Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer</title>
    <url>/2021/04/28/T5-Exploring-the-Limits-of-Transfer-Learning-with-a-Unified-Text-to-Text-Transformer/</url>
    <content><![CDATA[<p>转载：<a href="https://zhuanlan.zhihu.com/p/88438851" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/88438851</a></p>
<p>对于 T5 这篇论文，<em>Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer</em>，无疑也是类似的论文。它的意义不在烧了多少钱，也不在屠了多少榜（砸钱就能砸出来），其中 idea 创新也不大，它最重要作用是给<strong style="color:red;"><strong>整个 NLP 预训练模型领域提供了一个通用框架</strong></strong>，把所有任务都转化成一种形式，正如论文里所说的</p>
<blockquote>
<p>introducing a unified framework that converts every language problem into a text-to-text format.</p>
</blockquote>
<p>之后未来做 NLP 实验时，可能就不再是自己怎么调一些模型了，而是无论什么任务，直接拿来一个超大预训练模型，然后<strong style="color:red;"><strong>主要工作就变成了怎么把任务转换成合适的文本输入输出</strong></strong>，于是我们就成了带引号的”数据科学家“。而且可以用于多种任务，而模型对这些任务的区分只是根据你构建的输入输出形式，其实这让我想起 Jeff Dean 在某次谈话中谈到的谷歌未来方向，想做一个超级模型，什么任务都能直接处理，而它内部可以是稀疏的，或者可以局部 Distill，来对单独任务进行处理。</p>
<p>关于论文，作者们做了很多实验。将近七十个实验，这也是大家吐槽财大气粗的原因，太有冲击力了，小家小业的话估计跑里面个小实验就够呛了。</p>
<p>正因为如此多实验，所以才对预训练模型中的大量技巧获得了一个较公平的比对和分析，但这也使得整篇论文长度巨长，读起来头晕。不是 idea 的冲击，而都是些琐碎细节，看了几大段后发现，还是看图表一目了然。</p>
<p>这里就简单介绍一下里面做了哪些实验，之后各取所需回看论文。</p>
<h2 id="Why-Text-to-Text？"><a href="#Why-Text-to-Text？" class="headerlink" title="Why Text-to-Text？"></a>Why Text-to-Text？</h2><p>首先为什么叫 T5 模型，因为是 <strong>Transfer Text-to-Text Transformer</strong> 的简写，和 XLNet 一样也不在芝麻街玩了，也有说法是吐槽谷歌 <strong>T5 Level</strong>（高级软件工程师）。</p>
<p>Transfer 来自 Transfer Learning，预训练模型大体在这范畴，Transformer 也不必多说，那么 Text-to-Text 是什么呢。那就是作者在这提出的一个统一框架，靠着大力出奇迹，<strong>将所有 NLP 任务都转化成 Text-to-Text （文本到文本）任务</strong>。</p>
<p><img src="https://i.loli.net/2021/04/28/zSwycrjd2qkPGas.png" alt="image-20210428195223812"></p>
<p>举几个例子就明白了，比如英德翻译，只需将训练数据集的输入部分前加上“translate English to German（给我从英语翻译成德语）” 就行。假设需要翻译”That is good”，那么先转换成 “translate English to German：That is good.” 输入模型，之后就可以直接输出德语翻译 “Das ist gut.”</p>
<p>再比如情感分类任务，输入”sentiment：This movie is terrible!”，前面直接加上 “sentiment：”，然后就能输出结果“negative（负面）”。</p>
<p>最神奇的是，对于需要输出连续值的 STS-B（文本语义相似度任务），居然也是直接输出文本，而不是加个连续值输出头。以每 0.2 为间隔，从 1 到 5 分之间分成 21 个值作为输出分类任务。比如上图中，输出 3.8 其实不是数值，而是一串文本，之所以能进行这样的操作，应该完全赖于 T5 模型强大的容量。</p>
<p>通过这样的方式就能将 NLP 任务都转换成 Text-to-Text 形式，也就可以<strong>用同样的模型，同样的损失函数，同样的训练过程，同样的解码过程来完成所有 NLP 任务</strong>。其实这个思想之前 GPT2 论文里有提，上斯坦福 cs224n 时 Socher 讲的 The Natural Language Decathlon 也有提。</p>
<h2 id="Data：C4-（Bomb-）"><a href="#Data：C4-（Bomb-）" class="headerlink" title="Data：C4 （Bomb!）"></a>Data：C4 （Bomb!）</h2><p>作者从 Common Crawl（一个公开的网页存档数据集，每个月大概抓取 20TB 文本数据） 里清出了 750 GB 的训练数据，然后取名为 ” Colossal Clean Crawled Corpus （超大型干净爬取数据）“，简称 C4，论作者取名之恶趣味。</p>
<p>大概清理过程如下：</p>
<ul>
<li>只保留结尾是正常符号的行；</li>
<li>删除任何包含不好的词的页面，具体词表参考<strong><a href="https://link.zhihu.com/?target=https%3A//github.com/LDNOOBW/List-of-Dirty-Naughty-Obscene-and-Otherwise-Bad-Words" target="_blank" rel="noopener">List-of-Dirty-Naughty-Obscene-and-Otherwise-Bad-Words</a></strong>库（笔者按：宝藏库，到里面转了一圈，看了看熟悉的几门语言，瞬间涨了不少新姿势 ）；</li>
<li>包含 Javascript 词的行全去掉；</li>
<li>包含编程语言中常用大括号的页面；</li>
<li>任何包含”lorem ipsum（用于排版测试）“的页面；</li>
<li>连续三句话重复出现情况，保留一个。</li>
</ul>
<h2 id="Architecture：The-Best-One"><a href="#Architecture：The-Best-One" class="headerlink" title="Architecture：The Best One"></a><strong>Architecture：The Best One</strong></h2><p>首先作者们先对预训练模型中的多种模型架构（Transformer）进行了比对，最主要的模型架构可以分成下面三种。</p>
<p><img src="C:\Users\shiyaya\AppData\Roaming\Typora\typora-user-images\image-20210428195326843.png" alt="image-20210428195326843"></p>
<p>第一种，<strong>Encoder-Decoder 型</strong>，即 Seq2Seq 常用模型，分成 Encoder 和 Decoder 两部分，对于 Encoder 部分，输入可以看到全体，之后结果输给 Decoder，而 Decoder 因为输出方式只能看到之前的。此架构代表是 MASS（今年WMT的胜者），而 BERT 可以看作是其中 Encoder 部分。</p>
<p>第二种， 相当于上面的 <strong>Decoder 部分</strong>，当前时间步只能看到之前时间步信息。典型代表是 GPT2 还有最近 CTRL 这样的。</p>
<p>第三种，<strong>Prefix LM（Language Model） 型</strong>，可看作是上面 Encoder 和 Decoder 的融合体，一部分如 Encoder 一样能看到全体信息，一部分如 Decoder 一样只能看到过去信息。最近开源的 UniLM 便是此结构。</p>
<p>上面这些模型架构都是 Transformer 构成，之所以有这些变换，主要是<strong>对其中注意力机制的 Mask 操作</strong>。</p>
<p><img src="C:\Users\shiyaya\AppData\Roaming\Typora\typora-user-images\image-20210428195656637.png" alt="image-20210428195656637"></p>
<p>通过实验作者们发现，在提出的这个 Text-to-Text 架构中，Encoder-Decoder 模型效果最好。于是乎，就把它定为 T5 模型，因此<strong>所谓的 T5 模型其实就是个 Transformer 的 Encoder-Decoder 模型</strong>。</p>
<p>之后是对预训练目标的大范围探索，具体做了哪些实验，下面这张图就能一目了然。</p>
<p><img src="https://i.loli.net/2021/04/28/HGA86geR3s5JoOl.png" alt="image-20210428200712939"></p>
<p>总共从四方面来进行比较。</p>
<p>第一个方面，<strong>高层次方法（自监督的预训练方法）对比</strong>，总共三种方式。</p>
<ol>
<li><strong>语言模型式</strong>，就是 GPT-2 那种方式，从左到右预测；</li>
<li><strong>BERT-style 式</strong>，就是像 BERT 一样将一部分给破坏掉，然后还原出来；</li>
<li><strong>Deshuffling （顺序还原）式</strong>，就是将文本打乱，然后还原出来。</li>
</ol>
<p><img src="https://i.loli.net/2021/04/28/La7uURigVxpHzdG.png" alt="image-20210428200943309"></p>
<p>其中发现 Bert-style 最好，进入下一轮。</p>
<p>第二方面，对文本一部分进行<strong>破坏时的策略</strong>，也分三种方法。</p>
<ol>
<li><strong>Mask 法</strong>，如现在大多模型的做法，将被破坏 token 换成特殊符如 [M]；</li>
<li><strong style="color:red;"><strong>replace span（小段替换）法</strong>，可以把它当作是把上面 Mask 法中相邻 [M] 都合成了一个特殊符，每一小段替换一个特殊符，提高计算效率；</strong></li>
<li><strong>Drop 法</strong>，没有替换操作，直接随机丢弃一些字符。</li>
</ol>
<p><img src="https://i.loli.net/2021/04/28/swF3Ab4uBetv1Nf.png" alt="image-20210428201451717"></p>
<p>此轮获胜的是 <strong>Replace Span 法</strong>（如下图），类似做法如 SpanBERT 也证明了有效性。</p>
<p><img src="https://i.loli.net/2021/04/28/9gAnaOWSlmMbxCF.png" alt="image-20210428195311177"></p>
<p>当当当，进入下一轮。</p>
<p>第三方面，到底该<strong>对文本百分之多少进行破坏</strong>呢，挑了 4 个值，10%，15%，25%，50%，最后发现 BERT 的 <strong>15%</strong> 就很 ok了。这时不得不感叹 BERT 作者 Devlin 这个技术老司机直觉的厉害。</p>
<p>接着进入更细节，第四方面，因为 Replace Span 需要决定<strong>对大概多长的小段进行破坏</strong>，于是对不同长度进行探索，2，3，5，10 这四个值，最后发现 <strong>3</strong> 结果最好。</p>
<p>终于获得了完整的 T5 模型，还有它的训练方法。</p>
<p><img src="C:\Users\shiyaya\AppData\Roaming\Typora\typora-user-images\image-20210428201927674.png" alt="image-20210428201927674"></p>
<ul>
<li>Transformer Encoder-Decoder 模型；</li>
<li>BERT-style 式的破坏方法；</li>
<li>Replace Span 的破坏策略；</li>
<li>15 %的破坏比；</li>
<li>3 的破坏时小段长度。</li>
</ul>
<p>到此基本上 T5 预训练就大致说完了，之后是些细碎探索。</p>
<h2 id="Datasets"><a href="#Datasets" class="headerlink" title="Datasets"></a>Datasets</h2><p>接着作者们拿着 C4 数据集做了各种实验，比如说从里面分出各种类型的数据集，单独训练 T5 模型，之后看在下游任务的表现，发现一些情况<strong>领域内的预训练数据可以增强下游任务</strong>（想当然的）。而 C4 完整数据集因为数据太多太杂，可能反而不如这种领域内较少数据集。</p>
<p>还有从 C4 中抽出不同量数据做实验，发现<strong>数据少时，模型会记住数据所以之后表现会比较差</strong>（这个也是想当然）。</p>
<p><img src="https://i.loli.net/2021/04/28/8bgrwBkAYaWQTJp.png" alt="image-20210428202002738" style="zoom:67%;"></p>
<h2 id="Training：Multi-Task-Learning"><a href="#Training：Multi-Task-Learning" class="headerlink" title="Training：Multi-Task Learning"></a><strong>Training：Multi-Task Learning</strong></h2><p>作者们之后又针对 MTDNN 给 T5 做了一系列类似训练，在一堆监督和非监督数据上进行预训练。</p>
<p>结果发现，只要<strong>混合训练比例调得OK，和前面说的非监督预训练性能差不多</strong>。</p>
<h2 id="Scaling：bigger-is-better"><a href="#Scaling：bigger-is-better" class="headerlink" title="Scaling：bigger is better?"></a><strong>Scaling：bigger is better?</strong></h2><p>接着又做了当放大模型某方面规模的相关实验，分别是增大模型，增大数据，还有在一定资源限制下的集成。</p>
<p>结论是，当<strong>这些因素放大时对性能都有提高，但其中大模型是最必要的</strong>。</p>
<h2 id="Models"><a href="#Models" class="headerlink" title="Models"></a><strong>Models</strong></h2><p>最后就是结合上面所有实验结果，训练了不同规模几个模型，由小到大：</p>
<ul>
<li>Small，Encoder 和 Decoder 都只有 6 层，隐维度 512，8 头；</li>
<li>Base，相当于 Encoder 和 Decoder 都用 BERT-base；</li>
<li>Large，Encoder 和 Decoder 都用 BERT-large 设置，除了层数只用 12 层；</li>
<li>3B（Billion）和11B，层数都用 24 层，不同的是其中头数量和前向层的维度。</li>
</ul>
<p>11B 的模型最后在 GLUE，SuperGLUE，SQuAD，还有 CNN/DM 上取得了 SOTA，而 WMT 则没有。看了性能表之后，我猜想之所以会有 3B 和 11B 模型出现，主要是为了刷榜。看表就能发现。</p>
<p><img src="https://i.loli.net/2021/04/28/JF4X6LzSgpxho93.jpg" alt="img"></p>
<p>比如说 GLUE，到 3B 时效果还并不是 SOTA，大概和 RoBERTa 评分差不多都是 88.5，而把模型加到 11B 才打破 ALBERT 的记录。然后其他实验结果也都差不多，3B 时还都不是 SOTA，而是靠 11B 硬拉上去的。除了 WMT 翻译任务，可能感觉差距太大，要拿 SOTA 代价过大，所以就没有再往上提。根据这几个模型的对比，可以发现<strong>即使是容量提到 11B，性能提升的间隔还是没有变缓</strong>，<strong>因此我认为再往上加容量还是有提升空间</strong>。</p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>TIGEr: Text-to-Image Grounding for Image Caption Evaluation</title>
    <url>/2020/01/15/TIGEr-Text-to-Image-Grounding-for-Image-Caption-Evaluation/</url>
    <content><![CDATA[<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><ul>
<li>当前在图像描述领域使用的 automatic metric 仅仅考虑了 gt 与 pred sentence 之间的匹配度。这就存在问题：（1）给出的 references 可能不能  fully cover the image content。（2）自然语言本质上就是有歧义的（模棱两可的）</li>
<li><p>因此提出了 TIGEr，该指标，（1）不仅可以评估 pred caption 与  image content 之间的匹配度，（2）也能评估 pred caption 与 gt caption 之间的匹配度</p>
</li>
<li><p>（1） 对于  pred caption 与 gt caption， 使用预训练的 image-text grounding model 来 grounds the content of texts。然后分别比较 relevance ranking 和 distribution of grounding weights。</p>
</li>
<li>（2）计算 pred 与 gt caption 之间的匹配度时，不采用 n-gram matching，而是将他们映射到一个共同的语义空间，再对得到的映射向量进行比较。</li>
</ul>
<h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><ul>
<li>现在方法的缺点<ul>
<li>Popular metrics, such as BLEU and CIDEr, are based solely on text matching between reference captions and machinegenerated captions, potentially leading to biased evaluations because references may not fully cover the image content and natural language is inherently ambiguous. </li>
</ul>
</li>
</ul>
<h4 id="本文提出的方法：TIGEr"><a href="#本文提出的方法：TIGEr" class="headerlink" title="本文提出的方法：TIGEr"></a>本文提出的方法：TIGEr</h4><ul>
<li>yaya:本文提出了一个learned-based 和 ruled-based 相结合的方法。（1）learned-based: 首先预训练一个 grounding model , 利用这个grounding model可以分别得到reference caption 和 candidate caption 对regions in image的关注度。（2）再对这两个关注度进行两个方面的比较：==<strong>a:</strong>==  The first one measures how similarly these image regions are ordered (by their grounding scores) in the two vectors. ==<strong>b:</strong>== The second one measures how similarly the<br>attention (indicated by grounding scores) is distributed among different regions of the image in the two vectors.(KL 散度) ==<strong>c:</strong>==The TIGEr score is the average score of the resulting two similarity scores.</li>
</ul>
<h4 id="关于实验部分，可以给人思考的点"><a href="#关于实验部分，可以给人思考的点" class="headerlink" title="关于实验部分，可以给人思考的点"></a>关于实验部分，可以给人思考的点</h4><ul>
<li>Changing Reference Number</li>
<li>Text Component Sensitivity</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gcmt5o6s5ij30do0b60vf.jpg" alt="搜狗截图20200308204541.png"><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gcmt5o7hyyj30b80eftc7.jpg" alt="搜狗截图20200308204629.png">    </p>
<h4 id="yaya-不赞同文中提到的观点"><a href="#yaya-不赞同文中提到的观点" class="headerlink" title="yaya 不赞同文中提到的观点"></a>yaya 不赞同文中提到的观点</h4><ul>
<li>For example, if a human judge wrote a caption solely based on a particular region of an image (e.g., a human face or a bottle as shown in Figure 1) while ignoring the rest of the image, then a good machine-generated caption would be expected to describe only the objects in the same region</li>
<li>yaya分析：<strong>不同的人</strong>当看到一张图片的时候，关注的点是不尽相同的，在这种情况下，由reference 对 region 的attention，当成machine generated caption <strong>target</strong> 本身就不是正确的！</li>
<li>yaya: 本文提出的方法，是希望 learning-based 和 ruled-based method 结合，但是显然，ruled-based metric 就会存在一些缺陷，比如，只能评价caption system performence 的某一方面，换句话说，评价的不够全面！</li>
<li>yaya认为该metric的一个缺点：该metric 同时依赖 reference caption 和 image content, 缺一不可。==对于那些没有reference captions的描述任务，就不可以适用。==</li>
</ul>
]]></content>
      <categories>
        <category>图像描述</category>
        <category>评价指标</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>TVR: A Large-Scale Dataset for Video-Subtitle Moment Retrieval</title>
    <url>/2021/04/20/TVR-A-Large-Scale-Dataset-for-Video-Subtitle-Moment-Retrieval/</url>
    <content><![CDATA[<p>本文新提出了一个数据集 Video Corpus Moment Retrieval (VCMR)。</p>
<p>该数据集与以前数据集不同的点有：</p>
<ul>
<li>人类标注的query，不仅依据视频(视觉信息)，还根据subtitles(文本信息)</li>
<li>选取的moment不是对video进行均匀采样得到的(DiDeMo dataset)，而是自由选取的，这样可以更加关注于重要的moment</li>
<li>人类标注的query不依赖上下文信息，不会出现first, then这种描述（ActivityNet Captions），使得标注的数据更加适合检索任务。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Temporal Deformable Convolutional Encoder-Decoder Networks for Video Captioning</title>
    <url>/2019/07/28/Temporal-Deformable-Convolutional-Encoder-Decoder-Networks-for-Video-Captioning/</url>
    <content><![CDATA[<h3 id="当前存在的问题"><a href="#当前存在的问题" class="headerlink" title="当前存在的问题"></a>当前存在的问题</h3><ul>
<li>RNN 存在梯度消失和梯度下降的问题</li>
<li>RNN 的本质的循环依赖，限制了其并行计算</li>
<li>因此本文提出了 ==Temporal Deformable Convolutional Encoder-Decoder Networks (dubbed as TDConvED) ==that fully employ convolutions in both encoder and decoder networks for video captioning. </li>
</ul>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>[The GEM Benchmark] Natural Language Generation, its Evaluation and Metrics</title>
    <url>/2021/03/01/The-GEM-Benchmark-Natural-Language-Generation-its-Evaluation-and-Metrics/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Task-Oriented Intrinsic Evaluation of Semantic Textual Similarity</title>
    <url>/2020/06/29/Task-Oriented-Intrinsic-Evaluation-of-Semantic-Textual-Similarity/</url>
    <content><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>语义文本相似性（STS），为了评价设计的 STS system 的性能，通常使用 Pearson 相关性进行比较。</p>
<p>在本文中，证明了依靠具有Pearson相关性的内在评估可能会产生误导。在三个基于STS的常见任务中，我们可以观察到Pearson相关性特别不适用于为该任务检测最佳STS系统，而其他评估措施则更适合。</p>
<p>In this work we define how <strong>the validity of an intrinsic evaluation can be assessed</strong> and compare different intrinsic evaluation methods.</p>
<font color="red"> 即本文来分析metric 的有效性</font>

<h3 id="key-words"><a href="#key-words" class="headerlink" title="key words"></a>key words</h3><p>intrinsic evaluations == metric</p>
<p>an STS based task  == a task that heavily depends on the output of an STS system </p>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>下面的图中，四种不同的图，计算得到的pearson 系数都是0.86. </p>
<p>即通过仅比较皮尔逊相关性，所有系统都将被视为同样良好。</p>
<p>同时也可以看到，<strong>Pearson</strong>相关对局外点敏感，只能测量线性关系以及两个变量需要近似正态分布的局限性。</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gg89uax2zvj31fs0sl41x.jpg"></p>
<p><strong>Spearman</strong>的排名相关性不使用实际值来计算相关性，而是使用值的排名。因此，它对异常值，非线性关系或非正态分布的数据不敏感。 但是，大多数STS系统的内在评估仅报告了Pearson相关性。</p>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p>本文还提出了一个 <strong>predictiveness</strong> 的概念。由于，STS system 不会单独使用，常常会将其应用于下游任务。对于那些STS system 上得分高的，且在下游任务上得分也高的，称其为 high predictiveness。</p>
<p>为了探索各种metric 哪种更加适合 STS system 的评价（适合==high predictiveness）。本文用各种  metric 来评估14个 STS system。并使用spearman’rank 来计算，这些metric  得到的STS system <strong>得分</strong> 与 STS based task本身任务的<strong>得分</strong>，这两个得分之间的相关性。相关性越高，则有 high predictiveness, 即，该metric 更加适合用来做STS system 的评价。</p>
<p>通过下图，可以看到，Pearson 作为metric 并不是很好。</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gg8a5wby91j30wb0qmte1.jpg"></p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Thinking Fast and Slow: Efficient Text-to-Visual Retrieval with Transformers</title>
    <url>/2021/04/01/Thinking-Fast-and-Slow-Efficient-Text-to-Visual-Retrieval-with-Transformers/</url>
    <content><![CDATA[<p>发表在CVPR 2021</p>
<p>这篇论文与(ICLR 2021) Support-set bottlenecks for video-text representation learning都结合了 captioning task</p>
<h2 id="研究任务"><a href="#研究任务" class="headerlink" title="研究任务"></a>研究任务</h2><p>提高跨模态检索的推理速度</p>
<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>目前做 cross-modal retrieval task 的主流模型可以分为两类：（1）dual encoding，速度快，但是准确率低；（2）cross-attention model, 准确率高，但是速度慢。</p>
<h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><p>保证模型准确率的同时，提高推理速度</p>
<ul>
<li><p>提高模型准确率，采取了两个点：（1）使用CNN特征上采样来获取细粒度视觉特征；（2）使用captioning loss来代替 对比学习损失来做检索任务。如下图</p>
<p><img src="https://i.loli.net/2021/04/01/VtX5mQn8T2LcwMs.png" alt="image-20210401205905230"></p>
</li>
<li><p>在提高模型推理速度上，采取了两个点：(1) 使用 teacher-student 方法，以 slow cross-attention model 作为教师，以 fast dual-encoding model 作为学生；（2）先使用 fast model检索，选取top-k，然后使用slow model 进行 re-rank。如下图</p>
<p><img src="https://i.loli.net/2021/04/01/bh9IRmOBQWlZKCg.png" alt="image-20210401205835827" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>VirTex: Learning Visual Representations from Textual Annotations</p>
]]></content>
      <categories>
        <category>cross-modal</category>
        <category>real-time</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
        <tag>real-time</tag>
      </tags>
  </entry>
  <entry>
    <title>The Style-Content Duality of Attractiveness: Learning to Write Eye-Catching Headlines via Disentanglement</title>
    <url>/2021/02/26/The-Style-Content-Duality-of-Attractiveness-Learning-to-Write-Eye-Catching-Headlines-via-Disentanglement/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/02/26/9xToFaqiXjyKLOU.png" alt="image-20210226094912200" style="zoom: 50%;"></p>
<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>抢眼的头条新闻是触发更多点击的第一个设备，在制作人和观众之间产生了相互影响。生产者可以获得更多的流量和利润，而读者可以访问优秀的文章。生成吸引人的头条新闻时，不仅要捕捉吸引人的<strong>内容</strong>，而且要遵循醒目的书面<strong>风格</strong>。</p>
<p>本文中，提出了一个a Disentanglement-based Attractive Headline Generator (DAHG)。该标题生成器根据有吸引力的样式来捕获有吸引力的内容的标题。具体而言，【1】我们首先设计一个解纠缠模块，将引人注目的原型标题的样式和内容划分为潜在空间，并带有两个辅助约束以确保两个空间确实被纠缠。【2】然后，潜在内容信息将用于进一步polish the document representation 并帮助捕获重要部分。【3】最后，生成器将 polished document 作为输入，以在引人注目的样式的指导下生成标题。</p>
<p>本文在Kuaibao dataset 上实现了最好的性能。人工评估还表明，与现有模型相比，DAHG触发的点击次数增加了22％。</p>
<h3 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h3><h4 id="Headline-Generation"><a href="#Headline-Generation" class="headerlink" title="Headline Generation"></a>Headline Generation</h4><p>头条生成目前是NLP中的一个研究热点，目前大部分存在的头条生成工作仅仅关注于 summarizing the document。目前在Attractive headline generation上的研究还相对较少，目前有以下几篇。据我们所知，目前没有工作considers the style-content duality of attractiveness（考虑  吸引力的 内容-风格 二重性）。</p>
<blockquote>
<p>【1】Clickbait? Sensational Headline Generation with Auto-tuned Reinforcement Learning</p>
<p>【2】Improving Latent Alignment in Text Summarization by Generalizing the Pointer Generator. EMNLP 2019</p>
<p>【3】Structure Learning for Headline Generation.</p>
<p>【4-（not）】Hooks in the Headline: Learning to Generate Headlines with Controlled Styles</p>
</blockquote>
<h4 id="Disentanglement"><a href="#Disentanglement" class="headerlink" title="Disentanglement."></a>Disentanglement.</h4><p>现有作品集中于学习learning the disentangled representation，并且我们进一步采取了这种方法来利用这种representation来生成attractive headlines。</p>
]]></content>
      <categories>
        <category>title</category>
        <category>style</category>
      </categories>
      <tags>
        <tag>title,style</tag>
      </tags>
  </entry>
  <entry>
    <title>The multimodality problem in NAT</title>
    <url>/2021/06/07/The-multimodality-problem-in-NAT/</url>
    <content><![CDATA[<h2 id="multimodality-problem"><a href="#multimodality-problem" class="headerlink" title="multimodality problem"></a>multimodality problem</h2><p>非自回归神经机器翻译系统(NAT)通过打破自回归性，并行地生成所有目标词，大幅度地提高了推断速度。然而，现有的NAT模型由于<strong>多峰问题</strong>，与自回归神经网络机器翻译模型相比，翻译质量仍有很大差距。</p>
<p><strong><strong style="color:red;">什么是多峰问题</strong></strong>，举个简单的例子将汉语句子“干/得/好/！”翻译成英文，可以翻译成“Good job !”或者“Well done !”。由于<strong style="color:blue;">非自回归模型</strong>的条件独立性假设，推断时第一个词“Good”和“Well”的概率是差不多大的，如果第二个词“job”和“done”的概率也差不多大，会使得模型生成出“Good done !”或者“Well job !”这样错误的翻译。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>Learning to Recover from Multi-Modality Errors for Non-Autoregressive Neural Machine Translation</p>
<p>Syntactically Supervised Transformers for Faster Neural Machine Translation</p>
<p>ICML 2021 (Oral)：Order-Agnostic Cross Entropy for Non-Autoregressive Machine Translation</p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIMO Towards Unified-Modal Understanding and Generation via Cross-Modal Contrastive Learning</title>
    <url>/2021/02/23/UNIMO-Towards-Unified-Modal-Understanding-and-Generation-via-Cross-Modal-Contrastive-Learning/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>cross-modal</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
      </tags>
  </entry>
  <entry>
    <title>Transformer</title>
    <url>/2021/03/19/Transformer/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/03/19/DrhRUENTcwXPo89.png" alt="image-20210319185913348" style="zoom:50%;"></p>
<p>Transformer模型中采用了 encoer-decoder 架构。论文中encoder层由6个encoder堆叠在一起，decoder层也一样。</p>
<h2 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h2><p>对于encoder，包含两层，一个self-attention层和一个前馈神经网络，self-attention能帮助当前节点不仅仅只关注当前的词，从而能获取到上下文的语义。</p>
<h2 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h2><p>decoder也包含encoder提到的两层网络，但是在这两层中间还有一层attention层，帮助当前节点获取到当前需要关注的重点内容。</p>
<p>Decoder 和 Encoder的结构差不多，但是多了一个attention的sub-layer，这里先明确一下decoder的输入输出和解码过程：</p>
<ul>
<li>输出：对应 $i$ 位置的输出词的概率分布</li>
<li>输入：encoder的输出 与 对应  $i-1$ 位置decoder的输出。所以中间的attention不是self-attention，它的<strong style="color:blue;">K，V来自encoder</strong>，<strong style="color:blue;">Q来自上一位置decoder的输出</strong></li>
<li><p>解码：这里要注意一下，训练和预测是不一样的。在训练时，解码是一次全部decode出来，用上一步的ground truth来预测（mask矩阵也会改动，让解码时看不到未来的token）；而预测时，因为没有ground truth了，需要一个个预测。</p>
<p>为了确保按照生成顺序：从左到右，使用sequence mask。</p>
<p>sequence mask 是为了使得 decoder 不能看见未来的信息。也就是对于一个序列，在 time_step 为 t 的时刻，我们的解码输出应该只能依赖于 t 时刻之前的输出，而不能依赖 t 之后的输出。因此我们需要想一个办法，把 t 之后的信息给隐藏起来。</p>
<p>那么具体怎么做呢？也很简单：产生一个上三角矩阵，上三角的值全为0。把这个矩阵作用在每一个序列上，就可以达到我们的目的。</p>
</li>
</ul>
<p><img src="https://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase64156846899939997439.gif" alt="img"></p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>USR An Unsupervised and Reference Free Evaluation Metric for Dialog Generation</title>
    <url>/2020/07/01/USR-An-Unsupervised-and-Reference-Free-Evaluation-Metric-for-Dialog-Generation/</url>
    <content><![CDATA[<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p>缺乏有意义的自动评估指标是开放域对话框生成研究的重要障碍。标准语言生成指标已被证明对对话评估无效。</p>
<blockquote>
<p><strong>Survey on Evaluation Methods for Dialogue Systems</strong></p>
</blockquote>
<p>在没有公认的有意义的自动度量标准的情况下，开放域对话框研究人员开始依赖人工评估。由于其时间和成本密集的性质，人工评估通常仅用于最终的对话模型。因此，在开发过程中，对话系统通常针对不相关的自动指标（例如F-1，BLEU，PPL）进行了优化，这可能会导致不佳的人类评估分数。</p>
<p>为了促进开放域下对话模型在有意义的自动评价指标下发展，本文提出了无监督、无reference的评价指标。</p>
<h3 id="当前-automatic-metric-的缺陷"><a href="#当前-automatic-metric-的缺陷" class="headerlink" title="当前 automatic metric 的缺陷"></a>当前 automatic metric 的缺陷</h3><p>从dialog 的特性出发来分析 当前 automatic metric 的缺陷</p>
<ul>
<li><p>dialog 的一对多性质会使那些基于计算words overlap 的 metric无效，无法对偏离groun-truth response 的有效系统输出进行评分。</p>
<p>一对多：</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ggbir2x8l4j30ir0okmy9.jpg" style="zoom:33%;"></p>
</li>
<li><p>人类往往会对dialog 评估多个属性（例如，适当，有趣，一致）。而 automatic metric 将对话质量的多面性浓缩为一个无法解释的得分。</p>
</li>
<li><p>关于什么是<em>好的对话</em>，有很多定义，因此，构建<em>“一刀切”</em>是不可行的。根据任务和数据，对话系统的期望质量可能会有所不同</p>
</li>
</ul>
<h3 id="本文提出的指标"><a href="#本文提出的指标" class="headerlink" title="本文提出的指标"></a>本文提出的指标</h3><p>USR是一种reference-free metric ，由几个可解释的子指标组成，这些子指标以可配置的方式组合在一起。无需依赖于ground-truth reference response，而是可以训练无监督模型来测量所需的对话质量（例如，有趣，自然）。<br>因此，USR：<br>（1）减轻了标准度量标准的一对多问题，<br>（2）为dialog的所需属性提供了可解释的度量标准，<br>（3）提供了一种可配置的机制，用于将多个子度量标准合并为总体质量得分。</p>
<h3 id="本文的贡献"><a href="#本文的贡献" class="headerlink" title="本文的贡献"></a>本文的贡献</h3><ul>
<li><strong style="color:blue;">【提出了一个评价指标】</strong>提出了a strongly-correlated, unsupervised and reference free metric，用于评估开放域对话系统。</li>
<li><strong style="color:blue;">【提出了一个带有人类质量注释的数据集】</strong>进行了全面的human quality annotation 并发布了该数据集，以方便将来使用对话评估指标的 <strong>benchmarking</strong>。</li>
</ul>
<h3 id="Human-Quality-Annotation"><a href="#Human-Quality-Annotation" class="headerlink" title="Human Quality Annotation"></a>Human Quality Annotation</h3><ul>
<li><p>数据集构成<br>为了评估自动度量与人类判断的相关性，在两个开放域对话语料库之间进行了人类质量注释。</p>
<p>每个上下文包含的相应有：（1）模型生成的response，（2）人工再编写一个response，（3）原始的真实响应。<strong>Topic-Chat</strong> 的 每个上下文进行了六个响应（四个系统输出，一个新注释的人类输出，一个原始的真实响应）。<strong>PersonaChat</strong>  的 每个上下文进行了五个响应（少一个系统的输出）。</p>
<p>其中，每个数据集包含60个dialog context.</p>
</li>
<li><p>人类打分</p>
<p>human worker 在 这两个数据集上进行 human quality annotation。</p>
<p>每个相应均得到6个不同的分数：可理解（0-1），自然（1-3），保持情境（1-3），有趣（1-3），使用知识（0-1），总体质量（1- 5）。三个human为每个响应进行打分。</p>
</li>
<li><p>人类打分的Instructions</p>
<p><strong style="color:red;">任务说明非常详细，以最大程度地减少human quality annotation 中的主观性。</strong> 例如，个人对<code>有趣</code>的定义可能有所不同（例如，有些人发现足球很有趣，而另一些人则没有）。因此，这些说明中包含了一个对 <code>有趣</code>清晰的定义，尽管有些僵化。但是，“ <em>总体质量”</em>注释的说明不太严格，因此这些注释包含一些特定于注释器的主观性。</p>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ggbi8h871nj31ed0r5ae2.jpg" style="zoom:33%;"></p>
<h3 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h3><ul>
<li><p>看一下，他引用的参考文献，说 automatic metric 不好，文章中是怎么说的</p>
<blockquote>
<p>arxiv: 1603.08023</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Unexpected key(s) in state_dict: “**module**.features.conv1.0.weight”</title>
    <url>/2019/03/20/Unexpected-key-s-in-state-dict-%E2%80%9C-module-features-conv1-0-weight%E2%80%9D/</url>
    <content><![CDATA[<ul>
<li><p>参考此处<a href="https://discuss.pytorch.org/t/when-loading-a-model-unexpected-key-s-in-state-dict-module-features-conv1-0-weight/20505" target="_blank" rel="noopener">[link]</a></p>
</li>
<li><p>问题描述：在使用pytorch 加载预训练的模型时:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">decoder.load_state_dict(checkpoint[<span class="string">'dec'</span>])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>出现错误：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Missing</span> <span class="selector-tag">key</span>(<span class="selector-tag">s</span>) <span class="selector-tag">in</span> <span class="selector-tag">state_dict</span>: “<span class="selector-tag">features</span><span class="selector-class">.conv1</span><span class="selector-class">.0</span><span class="selector-class">.weight</span>”,</span><br><span class="line"><span class="selector-tag">Unexpected</span> <span class="selector-tag">key</span>(<span class="selector-tag">s</span>) <span class="selector-tag">in</span> <span class="selector-tag">state_dict</span>: “**<span class="selector-tag">module</span>**<span class="selector-class">.features</span><span class="selector-class">.conv1</span><span class="selector-class">.0</span><span class="selector-class">.weight</span>”,</span><br></pre></td></tr></table></figure></p>
<ul>
<li>原因：<br>在训练阶段，使用的是多GPU，采用了nn.DataParallel，因此在测试阶段，对应的模型也需要是多GPU的。</li>
</ul>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Understanding Chinese Video and Language via Contrastive Multimodal Pre-Training</title>
    <url>/2021/04/20/Understanding-Chinese-Video-and-Language-via-Contrastive-Multimodal-Pre-Training/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>UniT: Multimodal Multitask Learning with a Unified Transformer</title>
    <url>/2021/06/15/UniT-Multimodal-Multitask-Learning-with-a-Unified-Transformer/</url>
    <content><![CDATA[<p>曾几何时，多模态预训练已经不是一个新的话题，各大顶会诸多论文仿佛搭上Visual和BERT，就能成功paper+=1，VisualBERT、ViLBERT层出不穷，傻傻分不清楚……这些年NLPer在跨界上忙活的不亦乐乎，提取视觉特征后和文本词向量一同输入到万能的Transformer中，加大力度预训练，总有意想不到的SOTA。</p>
<p>如何在多模态的语境中更细致准确地利用Transformer强大的表达能力呢？Facebook最新的 <strong><em>Transformer is All You Need</em></strong> 也许可以给你答案。</p>
<p><img src="https://i.loli.net/2021/06/15/7HAQCbFuxkGpOgt.png" alt="image-20210615125803091" style="zoom:67%;"></p>
<p>这篇貌似标题党的文章开宗明义，针对文本+视觉的多模态任务，用好Transformer就够了，与许多前作不同，这次提出的模型一个模型可以解决多个任务：目标检测、自然语言理解、视觉问答，各个模型板块各司其职、条理清晰：<strong>视觉编码器</strong>、<strong>文本编码器</strong>、<strong>特征融合解码器</strong>，都是建立在多层Transformer之上，最后添加为每个任务设计的<strong>处理器</strong>，通过多任务训练，一举刷新了多个任务的榜单。</p>
<p><strong>论文题目</strong>:<br><strong><em>Transformer is All You Need: Multimodal Multitask Learning with a Unified Transformer</em></strong></p>
<p><strong>论文链接</strong>:<br><em><a href="https://arxiv.org/pdf/2102.10772.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/2102.10772.pdf</a></em></p>
<p><img src="https://i.loli.net/2021/06/15/EXpkQu8UT67eYrn.png" alt="image-20210615125848323" style="zoom: 67%;"></p>
<h2 id="文本编码器"><a href="#文本编码器" class="headerlink" title="文本编码器"></a>文本编码器</h2><p>用Transformer提取文本特征是个老生常谈的问题，从BERT石破天惊开始，纯文本领域近乎已被Transformer蚕食殆尽，所以该文也不能免俗，直接借用BERT的结构提取文本内容，区别在于，为了解决多个任务，在文本序列前添加了一个针对不同任务的参数向量，在最后输出隐藏状态到解码器时再去掉。</p>
<p><img src="https://i.loli.net/2021/06/15/l5z9uxCfsK3iEkD.png" alt="image-20210615125939485" style="zoom:50%;"></p>
<h2 id="视觉编码器"><a href="#视觉编码器" class="headerlink" title="视觉编码器"></a>视觉编码器</h2><p>本文将Transformer强大的表达能力运用到视觉特征的提取中，由于图片像素点数量巨大，首先通过基于卷积神经网络的ResNet-50提取卷积特征，极大程度上地降低了特征数量，最终得到的feature map大小为，然后用全联接层调整单个特征的维度到，再利用多层Transformer中的注意力机制提取各个feature之间的关系，由于Transformer的输入是序列，文章将拉成一条长为的序列，另外和文本编码器类似，同样添加了与下游任务相关的。</p>
<p><img src="https://i.loli.net/2021/06/15/8s9PnX7Zgz3piNS.png" alt="image-20210615130014598" style="zoom:67%;"></p>
<p>其中是调整维度的全联接层，是多层Transformer编码器。</p>
<h2 id="模态融合解码器"><a href="#模态融合解码器" class="headerlink" title="模态融合解码器"></a>模态融合解码器</h2><p>多模态的关键之一就在于怎么同时利用多个模态，在本文中是通过Transformer的解码器实现的，这个解码器首先将任务相关的query做self-attention，再将结果与文本编码器和视觉编码器的结果做cross-attention，针对单一模态的任务，选取对应编码器的输出即可，针对多模态的任务，取两个编码器输出的拼接。</p>
<p><img src="https://i.loli.net/2021/06/15/TJHRK84Ppv9jzYU.png" alt="image-20210615130046055" style="zoom:50%;"></p>
<h2 id="任务处理器-task-specific-output-head"><a href="#任务处理器-task-specific-output-head" class="headerlink" title="任务处理器(task-specific output head)"></a>任务处理器(task-specific output head)</h2><p>之前多模态预训练模型往往只针对某一项任务，而本文提出的一个模型可以解决多个文本+视觉任务，与BERT可以解决多个文本任务类似，本文的模型在模态融合解码器的结果上添加为每个任务设计的处理器，这个处理器相对简单，用于从隐藏状态中提取出与特定任务相匹配的特征。</p>
<ul>
<li><strong>目标检测</strong>：添加box_head和class_head两个前馈神经网络从最后一层隐藏状态中提取特征用来确定目标位置和预测目标类型。</li>
</ul>
<p><img src="https://i.loli.net/2021/06/15/jZhuaekyDWdP46w.png" alt="image-20210615130137970"></p>
<ul>
<li><strong>自然语言理解、视觉问答</strong>：通过基于全联接层的分类模型实现，将模态融合解码器结果的第一位隐藏状态输入到两层全联接层并以GeLU作为激活函数，最后计算交叉熵损失。</li>
</ul>
<p><img src="https://i.loli.net/2021/06/15/kCJYopFwB7MKRE4.png" alt="image-20210615130146288"></p>
<h2 id="实验与总结"><a href="#实验与总结" class="headerlink" title="实验与总结"></a>实验与总结</h2><p>本文提出的多模态预训练模型各个板块划分明确，通过多层Transformer分别提取特征，再利用解码器机制融合特征并完成下游任务，同时借助最后一层任务相关的处理器，可以通过一个模型解决多个任务，同时也让多任务预训练成为可能，并在实验中的各个数据集上得到了论文主要进行了两部分实验：</p>
<h3 id="多任务学习："><a href="#多任务学习：" class="headerlink" title="多任务学习："></a>多任务学习：</h3><p>这里的多任务涉及目标检测和视觉问答两个任务，在目标检测上运用COCO和VG两个数据集，在视觉问答上运用VQAv2数据集。对比了单一任务和多任务同时训练的结果，同时对比了不同任务共用解码器的结果。</p>
<p><img src="C:\Users\shiyaya\AppData\Roaming\Typora\typora-user-images\image-20210615130353457.png" alt="image-20210615130353457"></p>
<p>从结果中我们可以看出，单纯的使用多任务训练并不一定可以提高结果，不同任务间虽然相关但是却不完全相同，这可能是任务本身差异或者数据集的特性所导致，第二行和第五行可以很明显地看出COCO上的目标检测和VQAv2的视觉问答相结合后，结果有显著的下降，然而VG上的目标检测却能够和视觉问答很好地结合，通过三个数据集上的共同训练，可以得到最高的结果。</p>
<h3 id="多模态学习："><a href="#多模态学习：" class="headerlink" title="多模态学习："></a>多模态学习：</h3><p>这一实验中，为了体现所提出模型能够有效解决多个多种模态的不同任务，论文作者在之前COCO、VG、VQAv2的基础上，增加了单一文本任务GLUE的几个数据集（QNLI、QQP、MNLI、SST-2）和视觉推断数据集SNLI-VE，从数据集的数量上可以看出本文模型的全能性。与本文对比的有纯文本的BERT、基于Transformer的视觉模型DETR、多模态预训练模型VisualBERT。</p>
<p><img src="https://i.loli.net/2021/06/15/hSUibrVRlXz8KF2.png" alt="image-20210615130226872"></p>
<p>仔细看各个数据集上的结果，不难看出本文提出的模型其实并不能在所有数据集多上刷出SOTA，比如COCO上逊色于DETR，SNLI-VE逊色于VisualBERT，SST-2逊色于BERT，其他数据集上都有一定的提高，但是模型却胜在一个“全”字，模型的结构十分清晰明了，各个板块的作用十分明确，同时针对不同任务的处理器也对后续多模态任务富有启发性。</p>
]]></content>
      <categories>
        <category>cross-modal</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
      </tags>
  </entry>
  <entry>
    <title>Unifying Vision-and-Language Tasks via Text Generation</title>
    <url>/2021/07/03/Unifying-Vision-and-Language-Tasks-via-Text-Generation/</url>
    <content><![CDATA[<p><a href="https://github.com/j-min/VL-T5" target="_blank" rel="noopener">code</a></p>
<h2 id="当前跨模态预训练模型存在的问题"><a href="#当前跨模态预训练模型存在的问题" class="headerlink" title="当前跨模态预训练模型存在的问题"></a>当前跨模态预训练模型存在的问题</h2><ul>
<li>当前跨模态预训练模型在做下游任务时，通常都是根据特定任务设计相应的 head 和 objective。例如，a multi-label answer classifier for visual question answering, a region scorer for referring expression comprehension, and a language decoder for image captioning.</li>
</ul>
<h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><p>为了避免复杂的设计，本文提出了一个联合框架，可以在同一个结构中学习不同的任务。<strong style="color:red;">具体地，本文将判别式任务和生成式任务都转化为 Text  Generation task。</strong>本文的这种方法达到了近似SOTA的效果。</p>
<p>同时本文提出的框架可以在<strong>同一个参数</strong>下进行多任务训练，这种设置下，可以实现与单独训练特定任务达到相似的性能。(yaya解释，意思是说，这个模型在多任务的设置下训练之后，可以直接拿来去做各种任务，与单独训练特定任务的效果近似)</p>
<p>这种范式的好处：</p>
<ul>
<li>不需要为特定任务设计特定的head</li>
<li>对于一个新的任务，通过对input and output 进行 text rewrite即可，而不需要增加额外的参数或者是设计新的结构和训练目标。</li>
<li>由于预训练任务是生成式任务，因此相比于MLM这种理解型任务，文本生成能力更强。比如，当我们回答需要非简单答案的开放式问题时，这一点尤其有帮助，在这种情况下，判别性方法只能从<strong>预定义的频繁候选者集合中</strong>回答，而我们的模型可以生成开放式的自然语言答案。</li>
</ul>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>整体上，模型基于NLP的 T5 和 BART的 backbone 来设计。下图中以T5为例。</p>
<p>类似于T5，针对特定的任务，在输入文本的前面追加了关于任务的描述（task description）, 如下图中的 visual grounding.</p>
<p>模型设计上的一个比较特殊的点：we use the text embeddings of visual sentinel tokens as region id embeddings in Sec. 3.1. The embedding sharing enables our model to build the correspondence among query text, label text, and objects, which are useful in the grounding tasks。</p>
<p><img src="https://i.loli.net/2021/07/08/Yr5dLpGUzo6Rtl2.png" alt="image-20210708203404311"></p>
<h2 id="推理"><a href="#推理" class="headerlink" title="推理"></a>推理</h2><p>与T5类似，无论是判别式任务或是生成式任务，都会以自回归的生成式方式来解决。</p>
<p>如下图(a) 和 图(b) 以前的跨模态预训练模型需要为特定的任务设计特定的head, 但是，本文的方法，图(c) 和 图(d)  都以language modeling 生成式的方式来做。</p>
<p>we <font color="red"> <strong>formulate the task labels to corresponding text</strong></font>, and we learn these dif- ferent tasks by predicting label text with the same language modeling objective</p>
<p><img src="https://i.loli.net/2021/07/08/xFwyLG16aPCNMir.png" alt="image-20210708204113897"></p>
<h2 id="预训练任务"><a href="#预训练任务" class="headerlink" title="预训练任务"></a>预训练任务</h2><p>下图给出了预训练任务和下游任务的输入数据的格式</p>
<p>预训练任务中图文匹配任务也转化为生成 true/false。</p>
<p>预训练任务中 caption region 这个倒是挺新颖的</p>
<p>下游任务中，对于VQA and GQA 这两个任务，以前的方式都是多项选择的方式，但是本文中采用的是生成的方式。</p>
<p><img src="https://i.loli.net/2021/07/08/6z5B19PCcUJQbxT.png" alt="image-20210708204838585"></p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>实验一，预训练后的模型在各个下游任务上分别微调</p>
<p><img src="https://i.loli.net/2021/07/08/oKvQEH2TeXAz8LO.png" alt="image-20210708212303877"></p>
<p>实验二，微调下游任务时，采取多任务一起微调的方式</p>
<p>多任务一起微调效果也很不错，实现了一个模型参数可以处理多个任务，且不需要特定的head!!!</p>
<p><img src="C:\Users\shiyaya\AppData\Roaming\Typora\typora-user-images\image-20210708212215025.png" alt="image-20210708212215025"></p>
<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><ul>
<li>存在的缺陷：不是端到端的，需要预先使用 faster r-cnn 提取 proposals; 虽然 ViLT是端到端的，但是ViLT 不方便做 visual grounding task。</li>
<li><font color="green">预训练任务中，有一个visual grounding task, 但是，region description 是如何得到的？？论文中有讲，但是没有看懂</font>

</li>
</ul>
]]></content>
      <categories>
        <category>croos-moal</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
      </tags>
  </entry>
  <entry>
    <title>VATEX: a video caption dataset</title>
    <url>/2019/07/23/VATEX-a-video-caption-dataset/</url>
    <content><![CDATA[<h2 id="VATEX数据集"><a href="#VATEX数据集" class="headerlink" title="VATEX数据集"></a>VATEX数据集</h2><ul>
<li>一个新的数据集，41269个video， 时长大约10s, 每个video有10个中文，10个英文，同时这10个之中，中英文之间有5个是两两配对的</li>
<li>提出了两个新的任务：（1）一个encoder-decoder模型，在两种语言之间共享参数，即希望一个模型，可以得到两种语言的描述。（2）提出了一种新的机器翻译任务，即当进行中英文的机器翻译任务时，可以添加视频的视觉特征作为辅助信息</li>
<li>数据集的来源：来自于kinetics的validation dataset, 然后它们找人进行了caption的标注。它们将这41269个video 分成了4部分，train, validation, public test, secret test(不公开，用于比赛)</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g8e7blhuobj30js0lfwkf.jpg" alt="搜狗截图20191028204431.png"></p>
<h3 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h3><ul>
<li>encoder-decoder 就是 TopDown的形式</li>
<li>视觉特征：通过I3D（在kinetics train上预训练且不再fine-tune）来提取视觉特征，应该是把video分成了很多segments，对每个segment都提取I3D的特征，每个特征作为vi。</li>
</ul>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>VIFIDEL: Evaluating the Visual Fidelity of Image Descriptions</title>
    <url>/2020/01/16/VIFIDEL-Evaluating-the-Visual-Fidelity-of-Image-Descriptions/</url>
    <content><![CDATA[<h3 id="当前指标存在的问题"><a href="#当前指标存在的问题" class="headerlink" title="当前指标存在的问题"></a>当前指标存在的问题</h3><ul>
<li>BLEU, ROUGE, Meteor, CIDEr 这些指标， 他们依靠精确的字符串匹配来测量 condidate 文本和reference文献之间的surface-level 、 n-gram 重叠。当 references 有限的情况下，这会导致样本稀疏问题 （reference数量对 metric 得分有很大影响，因为reference 数量越多，多样性更好）。Meteor 通过匹配字典和释义表中的同义词来部分解决此问题，但受限于此类字典的可用性，也不能很好地适用于其他的 language。SPICE and BAST 通过计算语义级别的相似性来解决 exact string matching。但是这个方法严重的依赖于语言资源，例如 parsers, semantic role labellers, tailored rules, 使其很难适应到不同的语言和领域。</li>
</ul>
<h3 id="仅仅使用-reference-description-来-评估-image-description-的缺点"><a href="#仅仅使用-reference-description-来-评估-image-description-的缺点" class="headerlink" title="仅仅使用 reference description 来 评估 image description 的缺点"></a>仅仅使用 reference description 来 评估 image description 的缺点</h3><ul>
<li>受限于 reference 的数量，可能会造成<strong>样本稀缺</strong>的问题。</li>
<li>reference description 是<strong>主观的，有歧义的</strong>，可能不能涵盖 image 中所有的关键信息，可能只包含 image content 的一个子集。<strong>使用 object labels 可以解决这个问题</strong> </li>
<li>references 可能含有错误的信息。</li>
</ul>
<h3 id="基于-object-information-来-作为评价指标的优点"><a href="#基于-object-information-来-作为评价指标的优点" class="headerlink" title="基于 object information 来 作为评价指标的优点"></a>基于 object information 来 作为评价指标的优点</h3><ul>
<li><strong>少的标注时间消耗</strong>： 若仅使用 multiple descriptions 来作为参考，则必然需要人类为 每个 image 来标注 多个 descriptions，在标注数据上需要花费很多时间。且为每个 image 标注的description 数量越多，评估的越准确，则也需要更多的标注时间。</li>
<li>但是若使用基于 object imformation ， 则可以使用 predicted objects 或者 object annotations</li>
</ul>
<h3 id="本文的方法简述"><a href="#本文的方法简述" class="headerlink" title="本文的方法简述"></a>本文的方法简述</h3><p>我们认为，衡量特定标准的细粒度度量标准对于理解IDG系统如何比另一个系统更有用。 </p>
<p>我们专注于这样一种标准，即视觉保真度。 </p>
<p>该标准旨在衡量<strong>description相对于图像中所描述内容的真实性</strong>，对description中多余的信息进行惩罚，对正确的信息进行奖励</p>
<p>This criterion aims to measure how faithful a description is with respect to what is depicted in the image (i.e.<strong style="color:red;"> <strong>systems should be rewarded for describing elements depicted in the image and penalised for describing things that are not depicted</strong></strong>). </p>
<blockquote>
<p>Introduction</p>
</blockquote>
<h3 id="Modelling-object-importance-with-reference-descriptions"><a href="#Modelling-object-importance-with-reference-descriptions" class="headerlink" title="Modelling object importance with reference descriptions"></a>Modelling object importance with reference descriptions</h3><ul>
<li><p>human reference 可以作为一种guidance 提供信息 — 人类对该张图片关注的重点在哪里。</p>
</li>
<li><p>与 CIDEr 很相似，都是考虑与 human reference 之间的consensus 信息，但是有以下两点不同：  </p>
<p>（1）使用reference 来建模object的重要性，而不是直接将 候选与 参考进行比较。<br>（2）在语义空间使用word embedding来执行 word matching，而不是直接在计算表面的匹配度（eg: n-gram）   </p>
</li>
</ul>
]]></content>
      <categories>
        <category>图像描述</category>
        <category>评价指标</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>[VATEX Captioning Challenge 2019] Multi-modal Information Fusion and Multi-stage Training Strategy for Video Captioning</title>
    <url>/2021/03/13/VATEX-Captioning-Challenge-2019-Multi-modal-Information-Fusion-and-Multi-stage-Training-Strategy-for-Video-Captioning/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>cross-modal</category>
        <category>video captioning</category>
      </categories>
      <tags>
        <tag>cross-modal,video captioning</tag>
      </tags>
  </entry>
  <entry>
    <title>VIOLIN: A Large-Scale Dataset for Video-and-Language Inference</title>
    <url>/2020/03/28/VIOLIN-A-Large-Scale-Dataset-for-Video-and-Language-Inference/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>VMSMO Learning to Generate Multimodal Summary for Video-based News Articles</title>
    <url>/2021/02/21/VMSMO-Learning-to-Generate-Multimodal-Summary-for-Video-based-News-Articles/</url>
    <content><![CDATA[<h2 id="VMSMO-Learning-to-Generate-Multimodal-Summary-for-Video-based-News-Articles"><a href="#VMSMO-Learning-to-Generate-Multimodal-Summary-for-Video-based-News-Articles" class="headerlink" title="VMSMO: Learning to Generate Multimodal Summary for Video-based News Articles"></a>VMSMO: Learning to Generate Multimodal Summary for Video-based News Articles</h2><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul>
<li>当前受欢迎的多媒体新闻格式是提供<strong>一个视频和相对应的文章</strong>。 这种格式广泛应用于 new media (CNN and BBC)，social media (Twitter and Weibo)。<br>在这种情况下，自动选择<strong>合适的视频封面</strong>并生成相应的<strong>文章摘要</strong>可帮助编辑人员节省时间，并使读者更有效地做出决定。</li>
<li>因此，在本文中，we propose the task of <strong>Video-based Multimodal Summarization with Multimodal Output</strong> (VMSMO) to tackle such a problem. </li>
<li>此任务中的主要挑战是使用文章的语义共同对视频的时间依赖性进行建模。</li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>视频的封面应该是整个视频最显著的要素，而文本摘要应该是从原文章中提取出来的重要信息。因为视频和文章都关注于同一个报告内容中的相同事件，因此这两种信息形式在 summarizing 过程中应该是<strong>互为补充的</strong>。但是由于视频和文章是不同的模态（空间），如何充分的探索视频中的时域依赖与文章中的语义内容<strong>之间的关系</strong>仍然是一个问题。</p>
<p>因此，在本文中，我们提出了一个模型（DIMS）。该模型通过在过程中实施一个 dual interaction strategy 来同时summarize video and article。（1）使用 RNN 来编码 text and video. （2）设计了一个对偶交互模块（a dual interaction module）来让视频和文章相互交互。具体地，包括一个conditional self-attention mechanism 该模块可以在文章的指导下学习 local video representation。还包括一个global-attention mechanism 来学习 high level representation of video-aware article and article-aware video。（3）最后，based on fusion repersentation multimodal generator generates textual summary and cover image。</p>
<p>为了证明本文提出模型的有效性，本文从社会媒体网站上收集了 a large-scale news article-summary dataset associated with video-cover。实验证明，在当前广泛使用的评价标准上，DIMS可以显著的超过当前最好的baseline methods.</p>
<h2 id="本文的贡献"><a href="#本文的贡献" class="headerlink" title="本文的贡献"></a>本文的贡献</h2><ul>
<li>提出了一个任务，需要同时生成一个视频封面和一个文本摘要。</li>
<li>针对该任务，提出了一个模型，该模型可以同时建模视频中对的时域依赖和文章中的语义信息。</li>
<li>本文提出了一个大规模的数据集。在该数据集上，本文提出的方法在 automatic and human evaluation上都显著好于 baseline methods。</li>
</ul>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><ul>
<li><p>Text Summarization: (1) Extractive models：从原文中提取一句话来表征整个文章的内容。（2）abstractive models：generate a summary from scratch</p>
</li>
<li><p>Multimodal Summarization：（1）结合多模态的输入，生成更高的texual summaries。（2）Multimodal<br>summarization with multimodal output 这一方向，研究的相对较少。[zhu 2018] 提出同时输出一个 textual summary 和 从6个候选中挑选出来的most relevent image。[zhu 2020] 增加了一个多模态的目标函数。</p>
<p>但是，在实际应用中，我们通常需要为包含数百帧的视频选择封面图。 因此，视频中帧之间的时间相关性不能通过几种静态编码方法简单地建模。</p>
<blockquote>
<p>[zhu 2018] Msmo: multimodal summarization with multimodal output. EMNLP/IJCNLP. </p>
<p>[zhu 2020] Multimodal summarization with guidance of multimodal reference.</p>
</blockquote>
</li>
</ul>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p><img src="https://i.loli.net/2021/02/21/KqO2uQEkZj1fyPB.png" alt="image-20210221114344434"></p>
<h2 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h2><p>本文从 <strong>微博</strong> 上收集了做 VMSMO task 的数据集。视频的平均时长是1分钟，帧率是25fps。对于文本，文章的平均长度是96个字，文章summary的长度是12个字。整体上，有184k 个样本被收集，180k作为训练集，2.4k作为验证集，2.4k作为测试集。</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><ul>
<li><p>compare baseline：本文提出的方法与summarization baseline 和 VQA baseline 进行比较。</p>
</li>
<li><p>evaluation metrics：<br>（1）评估生成的summary：standard full-length <strong>Rouge F1</strong>. R-1, R-2, and R-L refer to unigram, bigrams, and the longest common2 subsequence respectively.</p>
<p>（2）评估chosen cover frame: mean average precision （MAP）and recall at precision（$R_n@k$）。$R_n@k$用来评估是否positive sample 被排在n candidatas的前k个位置。</p>
</li>
<li><p>实验结果证明，（1）本文提出的方法相比于 baseline methods 都要好。（2）本文提出了一个联合损失，同时训练两个任务，可以看做是一个 Multi-task。在本文的实验中，探索了，如果分别训练这两个任务，是怎样的结果。从倒数第二列中可以发现，我们采用的多任务方式训练，效果会好。（3）在本文实验中探索了conditional self-attention 和 global-attention对效果的影响。从最后一列的实验结果可以发现，self-attention 模块对挑选 封面图有很大的贡献，global attention对生成文本摘要有很大的贡献。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/02/21/PcFyBkTZNQlHY8m.png" alt="image-20210221154509463"></p>
<h2 id="Future-work"><a href="#Future-work" class="headerlink" title="Future work"></a>Future work</h2><ul>
<li>本文最后说到，可以结合video  script (subtitles) 来做该任务。</li>
</ul>
]]></content>
      <categories>
        <category>cross-modal</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
      </tags>
  </entry>
  <entry>
    <title>VX2TEXT End-to-End Learning of Video-Based Text Generation From Multimodal Inputs</title>
    <url>/2021/02/23/VX2TEXT-End-to-End-Learning-of-Video-Based-Text-Generation-From-Multimodal-Inputs/</url>
    <content><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><ul>
<li>本文提出了一个框架 for text generation from multimodal inputs consisting of video plus text, speech, or audio。</li>
<li><p>为了利用 transformer networks，每个模态通过一个 learnable tokenzier 首先转换为 a set of language embeddinngs。这将使得我们的方法可以在语言空间执行多模态融合，从而消除了对ad-hoc cross-modal fusion modules 的需要。</p>
</li>
<li><p>为了解决在连续输入（例如视频或音频）上tokenization 的不可微性，我们利用了一种放松方案，该方案可进行端到端训练。</p>
</li>
<li><p>进一步地，不像先前的 encoder-only models。本文提出的网络包括一个 autoregressive decoder来生成 open-ended text。同时在语言空间执行多模态融合，这使我们的方法完全具有生成性，并使其<strong>直接适用于不同的“video + $x $ to text” 问题，而无需为每个任务设计专门的网络.</strong></p>
</li>
<li><p>本文提出的框架不仅概念简单，而且效果显着。实验结果证明，our approach based on a single architecture 在三个video basedd text-generation task （captioning, question answering and audio-visual scene-aware dialog）上实现了最好的性能，而且本文提出的方法不需要任何的预训练任务。</p>
</li>
</ul>
<h3 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h3><p>While this and a few other recent works [55] have leveraged decoders for text-generation from multimodal inputs, we believe <strong>we are the first</strong> to empirically demonstrate via systematic ablation the performance improvements achieved with generative learning with decoding, compared to discriminative learning applied to the same encoder model.</p>
<p>当前的multimodal transformer-based models inspired by the success of pretext tasks in the language domain（预训练任务）。这些工作，依赖消耗大的预训练任务。但是本文提出的VX2TEXT 可以在 unified language space 执行 跨模态融合，这不需要multimodal pretext pretraining.</p>
<blockquote>
<p>Hero: Hierarchical encoder for video language omni-representation pre-training</p>
<p>Vilbert: Pretraining task-agnostic visiolinguistic representations for vision-and-language tasks.</p>
<p>Videobert: A joint model for video and language representation learning, 2019.</p>
<p>Lxmert: Learning crossmodality encoder representations from transformers.</p>
<p>Unified vision-language pre-training for image captioning and vqa</p>
</blockquote>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p>本文提出的方法可以概括为三步: (1) 利用一个 预训练的 modality-specific classifiers来为每个模态获得最可能的类别预测。(2) 将预测类别的textual names 经由本文提出的可微分tokenization scheme 嵌入到一个语义语言空间，这将使得整个系统可以端到端的训练（including the modality-specific classifiers)。（3）最终，使用一个generative encoder-decoder language model 将 多个模态的，embedding vector 映射到 free-form text，这将使得 不同形式的 ”video+$x$ to text” 问题变形为一个 sequence-to-sequence task。</p>
<h4 id="Differentiable-Tokenization"><a href="#Differentiable-Tokenization" class="headerlink" title="Differentiable Tokenization"></a>Differentiable Tokenization</h4><ul>
<li>We first leverage modality-specific classifiers trained  to predict a large set of categories over <strong>predefined language vocabularies</strong>.</li>
<li>虽然概念上是简单的，但是这个方法有一些缺点。第一，预训练的 modality-specific classifiers 可能不能泛化到目标数据。第二，每个分类器中选择top categories，这一操作是不可微分的，这阻止我们针对 target task 来微调modality-specific classifiers。</li>
<li>为了解决这些限制，本文提出了一个 differentiable tokenization scheme，这个方案可以在整个系统（modality specific classifer + sequence-to-sequence model）上进行端到端的训练。</li>
<li><strong>将预测类别的textual names 嵌入到一个语义语言空间</strong>：（1）对于每个模态的类别概率输出，采样top $K_m$个类别。（2）将采样的类别名称嵌入到语言空间：$\mathbf{e}_{m}^{k}=\mathbf{W}_{m}^{T} \mathbf{c}_{m}^{k}$，the embedding transformation  $\mathbf{W}_{m}$ can be initialized using a pretrained language embedding space </li>
</ul>
<h3 id="Generative-Encoder-Decoder"><a href="#Generative-Encoder-Decoder" class="headerlink" title="Generative Encoder-Decoder"></a>Generative Encoder-Decoder</h3><p>上一阶段，将不同的模态嵌入到了一个相同的语言空间，因此，现在可以使用一个<strong>text encoder</strong>来融合多模态信息。将多个模态得到的embedding vectors 组成一个长为L的序列，并结合<strong>task token</strong> 输入到 <strong>text encoder</strong>，并生成一个长为L的序列，该序列从多个模态中捕捉到了task  specific information。</p>
<p>将得到的新序列送入 decoder 中来做text generation。本文提出的decoder使用auto-regressive的方式。</p>
<h3 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h3><ul>
<li>使用 teacher-forcing 和 cross-entropy 来训练模型</li>
</ul>
<h3 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h3><ul>
<li>大部分先前的 multimodal transformer 依赖 task-specific heads 来处理不同的任务。具体而言，为生成式任务设计的heads 通常与 判别式任务是不同的。但是，本文提出的VX2TEXT 可以同时处理这两种任务，而不需要改变结构</li>
<li>对于生成式任务，captioning and video dialog，使用 beam search and greedy decoding 来生成句子。</li>
<li>对于判别式任务，QA on TVQA，模型需要从候选答案中挑选出一个最可能的答案。在这种情况下，本文include the entire set of candidate answers as additional input to the model (using separator tokens to mark them)。然后评估每个候选答案，根据autoregressive decoder对它们输出的概率分布。</li>
</ul>
<h3 id="Implementation-Details"><a href="#Implementation-Details" class="headerlink" title="Implementation Details"></a>Implementation Details</h3><p>We use T5-base [39] as our text transformer including the text token embedding layer, the encoder and the decoder. We use pretrained weights provided in HuggingFace [50]</p>
<h3 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h3><ul>
<li>简要总结本文有效的点</li>
<li>（1）提出将不同的模态，通过一个modality-specific classifier 映射到语言空间。（2）提出了一个端到端训练的模式，同时可以将 classifier 一起训练，这样解决了 迁移，泛化性不好的问题。（3）为了可以进行端到端的训练，采取了一些技术方案。we leverage the Gumbel-Softmax trick [18] and a differentiable approximation of tokenization [8].</li>
</ul>
<blockquote>
<p>Eric Jang, Shixiang Gu, and Ben Poole. <strong>Categorical reparameterization with gumbel-softmax.</strong>  arXiv preprint arXiv:1611.01144, 2016. <strong>ICLR 2017</strong></p>
<p>Yoshua Bengio, Nicholas L´eonard, and Aaron Courville. <strong>Estimating or propagating gradients through stochastic neurons for conditional computation.</strong> arXiv preprint arXiv:1308.3432, 2013.</p>
</blockquote>
]]></content>
      <categories>
        <category>cross-modal</category>
        <category>end-to-end</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
        <tag>end-to-end</tag>
      </tags>
  </entry>
  <entry>
    <title>[VIVO] Surpassing Human Performance in Novel Object Captioning with Visual Vocabulary Pre-Training</title>
    <url>/2020/10/18/VIVO-Surpassing-Human-Performance-in-Novel-Object-Captioning-with-Visual-Vocabulary-Pre-Training/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>VIVO可以在没有文本标签的数据上进行文本和图像的多模态预训练，摆脱了对配对图文数据的依赖，可以直接利用ImageNet等数据集的类别标签。借助VIVO，模型可以学习到物体的视觉外表和语义之间的关系，建立视觉词表。</p>
<p>这个视觉词表是啥呢？其实就是一个图像和文本的联合特征空间，在这个特征空间中，语义相近的词会聚类到一起，如金毛和牧羊犬，手风琴和乐器等。</p>
<p>预训练建好词表后，模型只需在有少量共同物体的配对图文的数据上进行微调，模型就能自动生成通用的模板语句，使用时，即使出现没见过的词，也能从容应对，相当于把图片和描述的各部分解耦了。</p>
<p>所以VIVO既能利用预训练强大的物体识别能力，也能够利用模板的通用性，从而应对新出现的物体。</p>
<p><img src="https://i.loli.net/2020/10/17/gakiQWDp3YAITCd.png" alt="image-20201017185401941" style="zoom:50%;"></p>
<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>本文要针对describe novel objects which are unseen in caption-labeled training data。This paper presents VIsual VOcabulary pretraining (VIVO) that performs pre-training in the absence of caption annotations。</p>
<p>By breaking the dependency of paired image-caption training data in VLP, VIVO can leverage large amounts of <strong>paired image-tag data</strong> to learn <strong>a visual vocabulary</strong>.<br>This is done by pre-training a <strong>multi-layer Transformer model</strong> that learns to align image-level tags with their corresponding image region features. Given that tags are not ordered, we employ <strong>the Hungarian matching loss</strong> for tag prediction optimization. </p>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p><img src="https://i.loli.net/2020/10/17/JuOMYRtzW7LEgfo.png" alt="image-20201017193144259"></p>
<h4 id="VIVO-Pre-training"><a href="#VIVO-Pre-training" class="headerlink" title="VIVO Pre-training"></a>VIVO Pre-training</h4><p>We pre-train the Transformer model on a large-scale dataset with abundant tags, e.g., the Open Images training set with <strong>6.4K classes of image-level tags.</strong></p>
<p><strong>The training objective</strong> is to predict the missing (masked) tags given a bag of image-level tags and image regions. </p>
<p>We denote the training set: N images $I_i$ and their corresponding tags $G_i$. 一个image有多个tags.</p>
<p>use <strong>bi-directional attention mask</strong> in VIVO pre-training.</p>
<h4 id="Fine-tuning-and-Inference"><a href="#Fine-tuning-and-Inference" class="headerlink" title="Fine-tuning and Inference"></a>Fine-tuning and Inference</h4><p>After pre-training, the Transformer model is fine-tuned on a dataset where both captions and tags are available, e.g., the COCO set annotated with tags from 80 object classes and captions.</p>
<p>the input to the model during <strong>fine-tuning is a triplet of image region features $V$, a set of tags $T$ and a  caption $C$</strong>, where $V$ and $T$ are constructedin the same way as described in pre-training, and $C$ is a sequence of tokens. During fine-tuning, we <strong>randomly mask outsome of the tokens in a caption sentence</strong> for  prediction, and optimize the model parameters using the cross-entropy loss.</p>
<p>during fine-tuning we apply <strong>the uni-directional attention mask</strong> on a caption sequence to prevent the positions from attending to subsequent positions.</p>
<p>During inference, we first extract image region features and detect tags from a given image. Then the model is applied to <strong>generate a sequence, one token at a time,</strong> until it outputs the end of sentence token or reaches the maximum length.</p>
<p><strong>detect tags</strong> ：We use an object detector trained on the Open Images dataset （500 classes bboxes）to detect object tags for all datasets.</p>
<p><strong style="color:red;"><strong>yaya：</strong> tags detector的限制，仅能输出 500个类别tags, 因此，novel objects 的生成也是受到限制的</strong></p>
<p>以下这个表就可以说明问题，当不预训练时，是第一行的数据；当仅使用tags detector 的500个类时，是第二行的数据；当使用open-image 所有的 6.4k 个类时，是第三行的数据。因此，在inference阶段，使用 tag detector 来提供tags 是存在问题的。至少限制了模型的性能。</p>
<p><strong>改进</strong>：本文的model，pre-training, fine-tune，都是在一个fix model上。但是pre-training 的目的，仅仅是为了构建 image-tag vocabulary, 可以先构建，然后再离线使用！！！</p>
<p><img src="https://i.loli.net/2020/10/18/eyKJkcQPibhX3nS.png" alt="image-20201018115538016" style="zoom:33%;"></p>
]]></content>
      <categories>
        <category>图像描述</category>
        <category>region-word-embedding</category>
      </categories>
      <tags>
        <tag>region-word-embedding</tag>
      </tags>
  </entry>
  <entry>
    <title>Video as Space-Time Region Graphs</title>
    <url>/2019/03/15/Video-as-Space-Time-Region-Graphs/</url>
    <content><![CDATA[<p>本篇文章主要是讲图卷积网络应用在行为识别任务中。<br>使用的两个数据集是：charades和something-something数据集</p>
<ul>
<li>从数据集中video丰富性方面：其中charades数据集含有丰富的室内场景，video中的object较为复杂，也不居中。而，something-something 数据集中的video只含有1~2个object，且位于画面中的中心位置。</li>
<li>从数据集中video时长：charades的一整个video近30s长，但是annotation是对clips of video进行的标注，clips的分割也不具备规律性，几秒到几十秒不等。something-something数据集的video 时长为3s-6s。均为较短的视频。  </li>
</ul>
<p>由以上对数据集的分析，与作者的实验结果，结合，由于something-something的video时长短，objects of video 也较小，因此gcn+i3d 相比于对i3d的提升不大，而相反，charades数据集的提升较大。</p>
<ul>
<li>这里给出自己的看法：由于在charades上的提升较为明显，因此使用该网络应用到其他的网络中时，最好可以使用charades数据集进行pre-train，而不要使用something-something数据集。</li>
</ul>
<h2 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h2><p>在训练阶段，首先对video以6 fps的帧率进行截取帧，输入网络时，每个video选取30帧，这样相当于video中的5s。即在训练阶段，每个5s长的clips作为一个sample，赋给它相对应的label，进行训练。</p>
<h2 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h2><p>在测试阶段，charades对每个video 提取10个clips ，对每个clips的输出结果，以最大池化的方式进行聚合，对于something-something数据集，每个video提取2个clips，其他同理。</p>
<h2 id="Construct-Graph"><a href="#Construct-Graph" class="headerlink" title="Construct Graph"></a>Construct Graph</h2><p>对于charades dataset，每帧中提取50个object，对于something-something dataset ，每帧中提取10个object。</p>
<ul>
<li>Similarity Graph<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g13qsziabzj30fk0ahjrw.jpg" style="zoom:65%"><br>Similarity graph 含有可学习参数</li>
<li>Spatial Graph</li>
<li>无可学习参数</li>
<li>We denote the IoU between object i in frame t and object  j in frame t + 1 as σ<sub>ij</sub><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g13qv0z3bxj30fq0b30t3.jpg" style="zoom:65%"></li>
</ul>
]]></content>
      <categories>
        <category>行为识别</category>
      </categories>
      <tags>
        <tag>行为识别</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>Video Description: A Survey of Methods, Datasets and Evaluation Metrics</title>
    <url>/2019/07/29/Video-Description-A-Survey-of-Methods-Datasets-and-Evaluation-Metrics/</url>
    <content><![CDATA[<h3 id="视频描述仍然处于起步阶段的原因"><a href="#视频描述仍然处于起步阶段的原因" class="headerlink" title="视频描述仍然处于起步阶段的原因"></a>视频描述仍然处于起步阶段的原因</h3><ul>
<li>对视频描述模型的分析是困难的，很难去判别是visual feature 亦或是 language model 哪个做的贡献大</li>
<li>当前的数据集，既没有包含足够的视觉多样性，也没有复杂的语言结构</li>
<li>当前的凭据指标并不能非常正确的去评估生成的句子与人类生成的句子之间的一致程度</li>
</ul>
<h3 id="the-difficulty-of-video-caption"><a href="#the-difficulty-of-video-caption" class="headerlink" title="the difficulty of video caption"></a>the difficulty of video caption</h3><ul>
<li>并不是在video中的所有object 都是与description相关的，可能其只是背景中的一个元素。    </li>
<li>此外，还需要objects的运动信息，以及 事件，动作，对象之间的因果关系。   </li>
<li>视频中的action可能有不同的长度，不同的action之间，可能有重叠。    </li>
</ul>
<h3 id="Sequence-Learning-based-Video-Captioning-Methods"><a href="#Sequence-Learning-based-Video-Captioning-Methods" class="headerlink" title="Sequence Learning based Video Captioning Methods"></a>Sequence Learning based Video Captioning Methods</h3><h4 id="CNN-RNN-based"><a href="#CNN-RNN-based" class="headerlink" title="CNN-RNN-based"></a>CNN-RNN-based</h4><ul>
<li><p>第一个 end-to-end：</p>
<p>S. Venugopalan, H. Xu, J. Donahue, M. Rohrbach, R. Mooney, and K. Saenko. 2014. Translating videos to natural language using deep recurrent neural networks. arXiv preprint arXiv:1412.4729, (2014).<br><img src="https://i.loli.net/2019/07/29/5d3ea016090c918345.png" alt="图片1.png" title="图片1.png"></p>
</li>
<li><p>S2VT （变长输入，变长输出）</p>
<p>I. Sutskever, O. Vinyals, and Q. V. Le. 2014. Sequence to sequence learning with neural networks. In Advances in Neural Information Processing Systems. 3104-3112.<br><img src="https://i.loli.net/2019/07/29/5d3ea01536b3144846.png" alt="图片2.png" title="图片2.png">   </p>
</li>
<li><p>TA ( 加入C3D[1] )</p>
<p>L. Yao, A. Torabi, K. Cho, N. Ballas, C. Pal, H. Larochelle, and A.Courville. 2015. Describing videos by exploiting temporal structure. In IEEE ICCV<br><img src="https://i.loli.net/2019/07/29/5d3ea016a248c95582.png" alt="图片3.png" title="图片3.png">  </p>
</li>
<li><p>LSTM-E （making a common visual-semantic-embedding ）</p>
<p>Y. Pan, T. Mei, T. Yao, H. Li, and Y. Rui. 2016. Jointly modeling embedding and translation to bridge video and language. In IEEE CVPR.<br><img src="https://i.loli.net/2019/07/29/5d3ea421aaf9013065.png" alt="图片4.png" title="图片4.png"></p>
</li>
</ul>
<ul>
<li><p>GRU-EVE  ( short fourier transform)</p>
<p>N. Aafaq, N. Akhtar, W. Liu, S. Z. Gilani and A. Mian. 2019. Spatio-Temporal Dynamics and Semantic Attribute Enriched Visual Encoding for Video Captioning. In IEEE CVPR.<br><img src="https://i.loli.net/2019/07/29/5d3ea0163113561600.png" alt="搜狗截图20190729152752.png" title="搜狗截图20190729152752.png">   </p>
</li>
<li><p>h-RNN<br>H. Yu, J. Wang, Z. Huang, Y. Yang, and W. Xu. 2016. Video paragraph captioning using hierarchical recurrent neural networks. In IEEE CVPR.<br><img src="https://i.loli.net/2019/07/29/5d3ea63af2e0354548.png" alt="图片5.png" title="图片5.png"></p>
</li>
</ul>
<h4 id="RL-based"><a href="#RL-based" class="headerlink" title="RL-based"></a>RL-based</h4><ul>
<li><p>Z. Ren, X. Wang, N. Zhang, X. Lv, and L. Li. 2017. Deep reinforcement learning-based image captioning with embedding reward. arXiv preprint arXiv:1704.03899, (2017).</p>
</li>
<li><p>Y. Chen, S. Wang, W. Zhang, and Q. Huang. 2018.  ==Less Is More: Picking Informative Frames for Video Captioning.==  arXiv preprint arXiv:1803.01457, (2018).</p>
<p>提出了一个基于强化学习的方法，来选择 key informative frames 来表达一个 complete video ，希望这样的操作可以忽略掉噪声和不必要的计算。</p>
</li>
<li><p>L. Li and B. Gong. 2018. End-to-End Video Captioning with Multitask Reinforcement Learning. arXiv preprint arXiv:1803.07950,<br>(2018).</p>
</li>
<li><p>R. Pasunuru and M. Bansal. 2017. Reinforced video captioning with entailment rewards. arXiv preprint arXiv:1708.02300, (2017).</p>
</li>
<li><p>S. Phan, G. E. Henter, Y. Miyao, and S. Satoh. 2017. Consensusbased Sequence Training for Video Captioning. arXiv preprint arXiv:1712.09532, (2017).</p>
</li>
<li><p>X. Wang, W. Chen, J. Wu, Y. Wang, and W. Y. Wang. 2017.  ==Video Captioning via Hierarchical Reinforcement Learning.==  arXiv preprint arXiv:1711.11135, (2017).</p>
<p>在 decoder阶段，使用 深度强化学习，这个方法证明可以捕捉到视频内容中的细节，并生成细粒度的description，但是！这个方法相对于当前的baseline 没有多大的提高。（我自己还需要再看看， 使用DRL的motivation）</p>
</li>
</ul>
<h3 id="Evaluation-Metrics"><a href="#Evaluation-Metrics" class="headerlink" title="Evaluation Metrics"></a>Evaluation Metrics</h3><ul>
<li><p><a href="https://blog.csdn.net/joshuaxx316/article/details/58696552" target="_blank" rel="noopener">参考链接</a></p>
</li>
<li><p>BLEU、ROUGE、METEOR  来源于 机器翻译</p>
</li>
<li><p>CIDEr、SPICE 来源于图像描述   </p>
</li>
</ul>
<h4 id="BLEU"><a href="#BLEU" class="headerlink" title="BLEU"></a>BLEU</h4><ul>
<li><a href="https://blog.csdn.net/allocator/article/details/79657792" target="_blank" rel="noopener">BLEU参考链接</a></li>
<li>==BLEU实质是对两个句子的共现词频率计算==，但计算过程中使用好些技巧，追求计算的数值可以衡量这两句话的一致程度。 </li>
<li>BLEU容易陷入常用词和短译句的陷阱中，而给出较高的评分值。本文主要是对解决BLEU的这两个弊端的优化方法介绍。</li>
<li>缺点</li>
</ul>
<ol>
<li>　不考虑语言表达（语法）上的准确性；<br>2.　 测评精度会受常用词的干扰；<br>3.　 短译句的测评精度有时会较高； </li>
<li>　没有考虑同义词或相似表达的情况，可能会导致合理翻译被否定；</li>
</ol>
<h4 id="ROUGE"><a href="#ROUGE" class="headerlink" title="ROUGE"></a>ROUGE</h4><p><img src="https://i.loli.net/2019/07/29/5d3ed71f2086769963.png" alt="20170228224903951.png" title="20170228224903951.png"></p>
<h4 id="METEOR"><a href="#METEOR" class="headerlink" title="METEOR"></a>METEOR</h4><p><img src="https://i.loli.net/2019/07/29/5d3edcce1761442736.png" alt="20170228225011405.png" title="20170228225011405.png">   </p>
<h4 id="CIDEr"><a href="#CIDEr" class="headerlink" title="CIDEr"></a>CIDEr</h4><p><img src="https://i.loli.net/2019/07/29/5d3edcce646d089162.png" alt="20170228225056046.png" title="20170228225056046.png"></p>
<h4 id="SPICE"><a href="#SPICE" class="headerlink" title="SPICE"></a>SPICE</h4><ul>
<li>基于 gt 和 pred 的场景图解析，来对预测结果进行评价，</li>
<li>不被广泛使用的原因是，当前sentence scene graph 的能力还比较若，很容易解析错误(eg:dog swimming through river”, the failure case could be the word “swimming” being parsed as “object” and the word “dog” parsed as “attribute” )</li>
<li>对句子解析错误了，那么给出的评价指标也不会很好！！！</li>
</ul>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p><img src="https://i.loli.net/2019/07/29/5d3edd503479c20027.png" alt="搜狗截图20190729194921.png" title="搜狗截图20190729194921.png">    </p>
<h3 id="当前的瓶颈："><a href="#当前的瓶颈：" class="headerlink" title="当前的瓶颈："></a>当前的瓶颈：</h3><h4 id="缺乏有效的评价指标"><a href="#缺乏有效的评价指标" class="headerlink" title="缺乏有效的评价指标"></a>缺乏有效的评价指标</h4><ul>
<li>我们的调查显示，阻碍这一研究进展的一个主要瓶颈是缺乏有效和有目的设计的视频描述评价指标。目前，无论是从机器翻译还是从图像字幕中，都采用了现有的度量标准，无法衡量机器生成的视频字幕的质量及其与人类判断的一致性。改进这些指标的一种方法是增加引用语句的数量。我们认为，从数据本身学习的目的构建的度量标准是推进视频描述研究的关键。    </li>
<li><p>王鑫也曾说：human evaluation在video captioning任务中是有必要的       </p>
<h4 id="视觉特征部分的瓶颈"><a href="#视觉特征部分的瓶颈" class="headerlink" title="视觉特征部分的瓶颈"></a>视觉特征部分的瓶颈</h4></li>
<li>在一个video中，可能出现多个activity，但是caption model只能检测出部分几个，导致性能下降。   </li>
<li>可能这个video中 action 的持续时间较长，但是，当前的video representation方法只能捕捉时域较短的运动信息（eg:C3D），因此不能很好地提取视频特征。   </li>
<li>大多数特征提取器只适用于静态或平稳变化的图像，因此难以处理突然的场景变化。目前的方法通过表示整体视频或帧来简化视觉编码部分。可能需要进一步探索注意力模型，以关注视频中具有重要意义的空间和时间部分。   </li>
<li>当前的encoder 与 decoder 部分，并 ==不是端到端的==，需要先提取 video representation再进行decoder，这样分布进行，而不是端到端的训练是不好的！    </li>
</ul>
<h3 id="captioning-model-的可解释性不足"><a href="#captioning-model-的可解释性不足" class="headerlink" title="captioning model 的可解释性不足"></a>captioning model 的可解释性不足</h3><ul>
<li>举个例子：当我们从包含“白色消防栓”的帧中看到视频描述模型生成的标题“红色消防栓”时，很难确定颜色特征是视觉特征提取器编码错误还是由于使用的语言模型bias( 由于有过多的训练数据是“红色消防栓)。<br><img src="https://i.loli.net/2019/07/29/5d3ee4996cf7480633.png" alt="搜狗截图20190729202028.png" title="搜狗截图20190729202028.png"></li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li>[1] D. Tran, L. D. Bourdev, R. Fergus, L. Torresani, and M. Paluri. 2014. C3D: Generic Features for Video Analysis. CoRR abs/1412.0767, (2014). </li>
</ul>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>VideoGraph: Recognizing Minutes-Long Human Activities in Videos</title>
    <url>/2019/07/30/VideoGraph-Recognizing-Minutes-Long-Human-Activities-in-Videos/</url>
    <content><![CDATA[<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><ul>
<li>当前基于CNN或者non-lcoal的方法，可以建模 temporal concepts，但是却不能建模分钟级长的时域依赖。</li>
<li>学习一个无向图，节点和边都是直接从video中得到，而不需要进行单独的节点标注。</li>
<li>这里的节点是：组成activity的一个unit-action，比如 “煎鸡蛋” 这个activity里的 “打破鸡蛋” 。</li>
<li>边，表示 (units-action) 运动单元之间的时域关系</li>
</ul>
<h3 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h3><ul>
<li>建模长范围的activity</li>
<li>捕捉到细节信息</li>
</ul>
<h3 id="Vs-Video-as-space-time-region-graph"><a href="#Vs-Video-as-space-time-region-graph" class="headerlink" title="Vs  Video as space-time region graph"></a>Vs  <code>Video as space-time region graph</code></h3><ul>
<li>Video as space-time region graph： 需要提取 key objects</li>
<li>Video graph：自动的从video中学到 nodes</li>
</ul>
]]></content>
      <categories>
        <category>行为识别</category>
      </categories>
      <tags>
        <tag>行为识别</tag>
      </tags>
  </entry>
  <entry>
    <title>Video captioning summary</title>
    <url>/2019/02/23/Video-captioning-summary/</url>
    <content><![CDATA[<ul>
<li>总结一下各论文使用的encoder的model分别是什么，是否采用了C3D，若采用了C3D,每16帧输出一个特征向量，这样的话，n_frames/16 个特征向量，那么论文中又是如何聚合特征来得到video 特征的？<h2 id><a href="#" class="headerlink" title=" "></a> </h2></li>
</ul>
<h2 id="训练和测试的一般过程"><a href="#训练和测试的一般过程" class="headerlink" title="训练和测试的一般过程"></a>训练和测试的一般过程</h2><p>The training process predicts the next word given the previous words from groundtruth, while the generation process conditions the prediction on the ones previously generated by itself.  </p>
<h2 id="训练损失"><a href="#训练损失" class="headerlink" title="训练损失"></a>训练损失</h2><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0iyn2xsz9j30r00higpg.jpg" style="zoom:70%"></p>
<h2 id="Code-总结"><a href="#Code-总结" class="headerlink" title="Code 总结"></a>Code 总结</h2><div class="table-container">
<table>
<thead>
<tr>
<th>model</th>
<th>batch_size</th>
<th>epoch</th>
<th>learning_rate</th>
<th>MSVD&lt;/br&gt;train-dataset</th>
<th>MSR-train-dataset</th>
</tr>
</thead>
<tbody>
<tr>
<td>video-caption.pytorch</td>
<td>128</td>
<td>6001（MSR）</td>
<td>0.0004 (每200epoch下降0.8)</td>
<td>✘</td>
<td>6513 pairs&lt;/br&gt;(每一次随机的从captions中选择一个作为label)</td>
</tr>
<tr>
<td>SA-tensorflow</td>
<td>100</td>
<td>200</td>
<td>0.0001（不变）</td>
<td>1200×41个pairs</td>
<td>✘</td>
</tr>
<tr>
<td>reconstruction-network</td>
<td>100</td>
<td>iter=100000  （epoch=100000×100/(1200*41）=203</td>
<td>0.00001（不变）</td>
<td>1200×41个pairs</td>
<td>✘</td>
</tr>
<tr>
<td>saliency-based</td>
<td>100</td>
<td>100</td>
<td>0.0003（不变）</td>
<td>略</td>
<td>✘</td>
</tr>
<tr>
<td>HRNE</td>
<td>200</td>
<td>128</td>
<td>0.0002</td>
<td>略</td>
<td>✘</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>model</th>
<th>construct vocab use which dataset</th>
</tr>
</thead>
<tbody>
<tr>
<td>video-caption.pytorch</td>
<td>MSR: all</td>
</tr>
<tr>
<td>SA-tensorflow</td>
<td>MSVD: train</td>
</tr>
<tr>
<td>reconstruction-network</td>
<td>MSVD: all</td>
</tr>
<tr>
<td>saliency-based</td>
<td></td>
</tr>
<tr>
<td>HRNE</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>model</th>
<th>loss function</th>
<th>input of decoder</th>
</tr>
</thead>
<tbody>
<tr>
<td>video-caption.pytorch</td>
<td>output of decoder（bs, hidden size）,经过一个全连接层得到one-hot形式(bs, n_vocab），在经过F.log_softmax。则损失函数 nn.NLLLoss（）</td>
<td>rnn1的输入是video feature;&lt;/br&gt;rnn2的输入是rnn1的输出cancatenate 上一步ground truth的word embedding&lt;/br&gt; output1, state1 = self.rnn1(vid_feats, state1)&lt;/br&gt; input2 = torch.cat((output1, padding_words), dim=2)&lt;/br&gt;          output2, state2 = self.rnn2(input2, state2)</td>
</tr>
<tr>
<td>SA-tensorflow</td>
<td><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0izmumz8sj30ry01l74i.jpg">LSTM的output/hidden state、经过attention加权求和得到的videofeature、上一步step的groundtruth word embedding进行concatenate，在经过全连接层、非线性层、全连接层、输入交叉熵损失函数：tf.nn.softmax_cross_entropy_with_logits</td>
<td>LSTM的输入是concatenate(video_feature, 上一步ground truth的word embdedding）</td>
</tr>
<tr>
<td>reconstruction-network</td>
<td>output of decoder（bs, hidden size）,经过一个全连接层得到one-hot形式(bs, n_vocab），在经过dropout。  则损失函数 nn.CrossEntropyLoss()</td>
<td>LSTM的输入是concatenate(video_feature, 上一步ground truth的word embdedding）</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h2 id="Paper-总结"><a href="#Paper-总结" class="headerlink" title="Paper 总结"></a>Paper 总结</h2><div class="table-container">
<table>
<thead>
<tr>
<th>model</th>
<th>dataset</th>
<th>n_frames</th>
</tr>
</thead>
<tbody>
<tr>
<td>S2VT</td>
<td>MSVD</td>
<td>每10帧取1帧</td>
</tr>
<tr>
<td>SA</td>
<td>MSVD</td>
<td>前240帧等间隔取26帧</td>
</tr>
<tr>
<td>h-RNN</td>
<td>MSVD</td>
<td>没讲( ˇˍˇ )</td>
</tr>
<tr>
<td>HRNE</td>
<td>MSVD</td>
<td>fixed 160帧</td>
</tr>
<tr>
<td>LSTM-TSA</td>
<td>MSVD</td>
<td>等间隔采取25帧</td>
</tr>
<tr>
<td>LSTM-E</td>
<td>MSVD</td>
<td>all frames</td>
</tr>
<tr>
<td>Reconstruction</td>
<td>MSVD  MSR-VTT</td>
<td>等间隔28帧</td>
</tr>
<tr>
<td>M3</td>
<td>MSVD  MSR-VTT</td>
<td>28帧for MSVD; 40帧for MSR-VTT</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>model</th>
<th>词频</th>
<th>MSVD  vocabulary</th>
<th>MSR-VTT  vocabulary</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hierarchical Boundary-Aware Neural Encoder for Video Captioning</td>
<td>大于等于5</td>
<td>4215</td>
<td></td>
</tr>
<tr>
<td>Multimodal Memory Modelling for Video Captioning</td>
<td></td>
<td>13,000</td>
<td>29,000</td>
</tr>
<tr>
<td>Spatio-Temporal Dynamics and Semantic Attribute Enriched Visual Encoding for Video Captioning</td>
<td></td>
<td>9450</td>
<td>23500</td>
</tr>
<tr>
<td>Describing Videos by Exploiting Temporal Structure</td>
<td></td>
<td>16,000</td>
<td></td>
</tr>
<tr>
<td>Video Paragraph Captioning Using Hierarchical Recurrent Neural Networks</td>
<td></td>
<td>12, 766（1, 297 and 670 videos ）</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>model</th>
<th>feature</th>
<th>METER</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mean Pool + LSTM</td>
<td>在COCO上预训练的Alex net</td>
<td>29.1</td>
</tr>
<tr>
<td>S2VT</td>
<td>RGB frames on VGG Net&lt;/br&gt;optical flows on AlexNet</td>
<td>29.8</td>
</tr>
<tr>
<td>SA</td>
<td>GoogLeNet and 3D-CNN</td>
<td>29.6</td>
</tr>
<tr>
<td>LSTM-E</td>
<td>VGGNet and C3D</td>
<td>31.0</td>
</tr>
<tr>
<td>h-RNN</td>
<td>VGGNet and C3D</td>
<td>32.6</td>
</tr>
<tr>
<td>HRNE</td>
<td>GooLeNet</td>
<td>33.1</td>
</tr>
<tr>
<td>Reconstruction</td>
<td>Inception-V4&lt;/br&gt; last pooling layer</td>
<td>34.1</td>
</tr>
</tbody>
</table>
</div>
<h2 id="提取frames-features-之后，获取video-feature的几种方法："><a href="#提取frames-features-之后，获取video-feature的几种方法：" class="headerlink" title="提取frames features 之后，获取video feature的几种方法："></a>提取frames features 之后，获取video feature的几种方法：</h2><p><strong>1. Mean pooling</strong></p>
<ul>
<li>Translating videos to natural language using deep recurrent neural networks. NACACL, 2015</li>
<li>Jointly modeling embedding and translation to bridge video and language. CoRR,  2015  </li>
</ul>
<p><strong>2. Weighted mean Pooling with an attention model</strong>    </p>
<ul>
<li>Describing videos by exploiting temporal structure. ICCV, 2015  </li>
<li>Exploring Visual Relationship for Image Captioning</li>
<li>2层LSTM，第一层LSTM的输入是对object/frames features进行平均池化，第二层LSTM的输入是给定第一层的hidden state 来得到attention 系数，从而对object/frames features进行加权求和。 即第一层用平均池化的特征来表征 global feture，第二层用加权求和的特征来表征 global feature</li>
</ul>
<p><strong>3. Taking the last output from an RNN encoder which summarizes the feature sequence</strong>    </p>
<ul>
<li>Long-term recurrent convolutional networks for visual recognition and description. CVPR, 2015</li>
<li>Sequence to sequence - video to tex. ICCV, 2015</li>
<li>A multi-scale multiple instance video description network. CoRR, 2015  </li>
</ul>
<h2 id="video-captioning-的模型中，含有extract-object-proposal的论文"><a href="#video-captioning-的模型中，含有extract-object-proposal的论文" class="headerlink" title="video captioning 的模型中，含有extract object proposal的论文"></a>video captioning 的模型中，含有extract object proposal的论文</h2><ul>
<li>Video paragraph captioning using hierarchical recurrent neural networks.  CVPR, 2016.  </li>
<li>object-aware aggregation with bidirectional temporal graph for video capioning. CVPR, 2019</li>
</ul>
<h2 id="loss"><a href="#loss" class="headerlink" title="loss"></a>loss</h2><ul>
<li>一般的情况下是对decoder的部分计算loss, 并反向传播，encoder采用预训练好的model，并不在进行finetune。</li>
</ul>
<h2 id="使用objects-feature-的文章"><a href="#使用objects-feature-的文章" class="headerlink" title="使用objects feature 的文章"></a>使用objects feature 的文章</h2><ul>
<li></li>
<li>video as graph : charades 每帧提取50个objects(当objects 的数量将为25的时候，score只降了0.2), something2 :每帧提取10个objects</li>
<li>我的msr-vtt: 提取5个效果比较好，不会包含太多的噪声</li>
<li>==尽量让一个video中的objects 不同，去聚类帧之间的objects==  </li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>论文</th>
<th>charades( 30s)</th>
<th></th>
<th>something-something( 3-6s )</th>
<th>activity</th>
<th>MSVD（10-25s）</th>
</tr>
</thead>
<tbody>
<tr>
<td>video as graph</td>
<td>16帧 *50</td>
<td></td>
<td>16帧* 10</td>
<td>10帧*100</td>
<td></td>
</tr>
<tr>
<td>HTM （video captioning)</td>
<td>80帧 *30</td>
<td></td>
<td></td>
<td></td>
<td>28帧*30</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>论文</th>
<th>object detector</th>
<th>return</th>
</tr>
</thead>
<tbody>
<tr>
<td>(ACM 2019)Hierarchical Global-Local Temporal Modeling for VideoCaptioning</td>
<td>Faster rcnn 去掉rcnn的分类层，</td>
<td>提取_head_to_tail之后的特征 2048维</td>
</tr>
<tr>
<td>(CVPR 2019)Spatio-Temporal Dynamics and Semantic Attribute Enriched Visual Encoding for Video Captioning</td>
<td>YoLo</td>
<td>没说</td>
</tr>
<tr>
<td>(CVPR 2019)Grounded Video Description</td>
<td>a Faster RCNN model [24] with a ResNeXt-101 FPN backbone (在VG上预训练，类别会比coco 多，同时训练目标检测和属性分类)</td>
<td>返回的是fc6,我认为是_head_to_tail</td>
</tr>
<tr>
<td>( ECCV 2018)Videos as Space-Time Region Graph</td>
<td>the RPN with ResNet-50 backbone and FPN ==(需要注意，这里具体的：先由I3D得到THWd的特征，然后对32帧，每2帧取1帧，去得到这16帧的bbox，得到了bbox不是直接去得到pooled_feats，而是通过I3D的空间特征，bbox, Roi Align来得到bbox 的 region feat) ==</td>
<td>返回的是roi_pooling的7*7的，然后再进行平均池化</td>
</tr>
<tr>
<td>(CVPR 2019)Object-aware Aggregation with Bidirectional Temporal Graph for Video Captioning</td>
<td>MASK RCNN，在COCO上预训练，</td>
<td>将得到的regions 裁剪成图像，再送入ResNet-200中，得到res-layer5c的局部特征</td>
</tr>
<tr>
<td>（CVPR 2019）Auto-Encoding Scene Graphs for Image Captioning</td>
<td>faster rcnn , 使用 r-cnn 输出的 rois， 然后作用到 base feat上，使用 roi pooling 的到 pooled feats</td>
<td>返回 7*7的pooled feats</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>根据faster r-cnn 的网络结构，rpn部分输出bbox的预测，rcnn部分也输出bbox的预测，在目标检测任务中，采用rcnn的输出作为最后的结果。</li>
<li>但是在视频帧提取 object 的任务中，一般采用的是rpn部分输出的bbox,  why？ 这是因为，想要得到的不是bbox的坐标，而是bbox feats， 因此，直接取pooled_feats更加简洁方便。</li>
<li>所以在利用mmdetection时，设置 在rpn部分的max_region_per</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>VinVL: Revisiting Visual Representations in Vision-Language Models</title>
    <url>/2021/06/16/VinVL-Revisiting-Visual-Representations-in-Vision-Language-Models/</url>
    <content><![CDATA[<h2 id="本文的任务"><a href="#本文的任务" class="headerlink" title="本文的任务"></a>本文的任务</h2><p>研究如何改善 V+L 跨模态预训练模型</p>
<h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><p>通过改善目标检测器模型，来改善以物体 (object) 为中心的图像表示 (image representation)</p>
]]></content>
      <categories>
        <category>cross-modal</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
      </tags>
  </entry>
  <entry>
    <title>Visual Genome 数据集</title>
    <url>/2019/07/21/Visual-Genome-%E6%95%B0%E6%8D%AE%E9%9B%86/</url>
    <content><![CDATA[<ul>
<li>数据集介绍<br><a href="https://cloud.tencent.com/developer/article/1391855" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1391855</a></li>
</ul>
<p><a href="https://visualgenome.org/" target="_blank" rel="noopener">Visual Genome 主页</a></p>
<p><a href="https://visualgenome.org/api/v0/api_home.html" target="_blank" rel="noopener">Visual Genome Data</a></p>
<p><a href="https://visualgenome.org/api/v0/api_readme" target="_blank" rel="noopener">Visual Genome Readme</a></p>
<p>Visual Genome 数据集总览：</p>
<ul>
<li>108077 张图片</li>
<li>5.4 Million Region Descriptions</li>
<li>1.7 Million Visual Question Answers</li>
<li>3.8 Million Object Instances</li>
<li>2.8 Million Attributes</li>
<li>2.3 Million Relationships</li>
<li>Everything Mapped to Wordnet Synsets  </li>
<li>标注数据：  objects，attributes，图片内的 relationships</li>
<li>共 108K 张图片，每张图片平均有， 35 个 objects，26 个 attributes，21对 objects 见的成对 relationships.</li>
</ul>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/rex8eso6p5.png?imageView2/2/w/1620" alt="img"></p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/vtmiv1yyr6.png?imageView2/2/w/1620" alt="img"></p>
<h2 id="1-Visual-Genome-数据标注"><a href="#1-Visual-Genome-数据标注" class="headerlink" title="1. Visual Genome 数据标注"></a>1. Visual Genome 数据标注</h2><p>数据集主要包括七个主要部分：</p>
<ul>
<li>region descriptions</li>
<li>objects</li>
<li>attributes</li>
<li>relationships</li>
<li>region graphs</li>
<li>scene graphs</li>
<li>question answer pairs</li>
</ul>
<h3 id="1-1-Region-Descriptions"><a href="#1-1-Region-Descriptions" class="headerlink" title="1.1. Region Descriptions"></a>1.1. Region Descriptions</h3><p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/8kgo0p0qim.png?imageView2/2/w/1620" alt="img"></p>
<p>数据集标注了图片的 regions descriptions，每个 region 有一个 bounding box. </p>
<p>如上图中，图片有三个 regions descriptions： “man jumping over a fire hydrant,”，“yellow fire hydrant,” 和   “woman in shorts is standing behind the man.”.</p>
<h3 id="1-2-Objects"><a href="#1-2-Objects" class="headerlink" title="1.2. Objects"></a>1.2. Objects</h3><p>数据集中每张图片平均有 35 个 objects，每个 object 采用 bounding box 标注.</p>
<p>如图：   </p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/ih1qpz1p3s.png?imageView2/2/w/1620" alt="img"></p>
<p><a href="http://blog.csdn.net/zziahgf/article/details/72819043" target="_blank" rel="noopener">MS-COCO 数据集</a> 只标注了 80 个 object categories，没有描述图片中的所有 objects. 实际场景中，可能有更多的 objects 类别.</p>
<p>Visual Genome 数据集旨在对图片里出现的所有视觉 objects 进行标注，objects categories 类别达到 33877 种.</p>
<h3 id="1-3-Attributes"><a href="#1-3-Attributes" class="headerlink" title="1.3. Attributes"></a>1.3. Attributes</h3><p>数据集中每张图片平均有 26 个 attributes. Objects 可能没有或者有更多的相关 attributes. </p>
<p>Attributes 可以是 color(如 yellow)，states(如 standing) 等，如图：   </p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/k1n26a1mdt.png?imageView2/2/w/1620" alt="img"></p>
<p>Attributes 能够对 objects 进行更容易的描述、对比与分类. 即使以前未见到某 object，根据 attributes 仍能推断出与 object 相关的东西. 如，“yellow and brown spotted with long neck(长脖子上有黄色和棕色的斑点)”，很可能推断出 object 是 giraffe(长颈鹿).</p>
<p>关于 attributes 的研究：</p>
<ul>
<li>采用examplar SVMs，利用相似特征来寻找 objects；</li>
<li>采用纹理(textures) 研究 objects，或者预测颜色.</li>
<li>采用 attributes 来提高目标分类结果. 如 fine-grained 识别.</li>
</ul>
<p>Attributes 一般被定义为 parts(如 has legs)、shapes(如，spherical球形的)、materials(如 furry毛皮的)；用于对新的 objects 类别进行分类.</p>
<p>Visual Genome 数据集对于 attributes 进行扩展，其 attributes 不是 image-specific 的，而是真实场景中 object-specific 的. attributes 类型包括：size(如 small), pose(如bent), state (如 transparent), emotion (如 happy)等等.</p>
<ul>
<li>基于 VGG16 的 attributes 预测结果：   </li>
</ul>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/373ih7qquc.png?imageView2/2/w/1620" alt="img"></p>
<h3 id="1-4-Relationships"><a href="#1-4-Relationships" class="headerlink" title="1.4. Relationships"></a>1.4. Relationships</h3><p>Relationships 是两个 objects 的连接关系.</p>
<p>Relationships 可以是 actions(如 jumping over)，spatial(如 is build)，comparative(如 taller than)，prepositional phrases (如 drive on). 如图：   </p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/5ljbd3m2av.png?imageView2/2/w/1620" alt="img"></p>
<ul>
<li>Relationship 预测结果：   </li>
</ul>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/pgbhzj5ui4.png?imageView2/2/w/1620" alt="img"></p>
<h3 id="1-5-Region-Graphs"><a href="#1-5-Region-Graphs" class="headerlink" title="1.5. Region Graphs"></a>1.5. Region Graphs</h3><p>结合 objects、attributes 以及  region descriptions 提取的 relationships，创建每个 regions 的 graph representation. </p>
<h3 id="1-6-Scene-Graphs"><a href="#1-6-Scene-Graphs" class="headerlink" title="1.6. Scene Graphs"></a>1.6. Scene Graphs</h3><p>Region graphs 是图片的局部区域表示，将 region graphs 结合，生成单个 scene graph来表示整张图片.</p>
<p>Scene graph 是全部 region graphs 的统一，包含了全部的 objects、attributes以及每个 region description 的 relationships.</p>
<p>Scene Graph 将多种不同层次的 scene 信息以更加一致的方式结合在一起.</p>
<h3 id="1-7-Question-Answer-QA-Pairs"><a href="#1-7-Question-Answer-QA-Pairs" class="headerlink" title="1.7. Question Answer(QA) Pairs"></a>1.7. Question Answer(QA) Pairs</h3><p>数据集中每张图片有两种类型的 QA pairs：</p>
<ul>
<li>freeform QAs - 基于整张图片；</li>
<li>region-based QAs - 基于图片的选择区域. </li>
</ul>
<p>每张图片标注了 6 中不同类型的问题：what, where, how, when, who, why.</p>
<p>如图：   </p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/vbxbgpfi92.png?imageView2/2/w/1620" alt="img"></p>
<p>Figure . Visual Genome 数据集. 每张图片包括：region descriptions - 描述了图像的局部信息；两种类型的 question answer pairs(QAs) - free form QAs 和 region-based QAs. 每个 region 转化为 objects、attributes 和 pairwise relationships region 构成的 region graph 表示. 最终， 结合 region graphs 以形成图片内全部 objects 的 scene graph.</p>
<h2 id="2-Visual-Genome-数据集应用"><a href="#2-Visual-Genome-数据集应用" class="headerlink" title="2. Visual Genome 数据集应用"></a>2. Visual Genome 数据集应用</h2><p>基本应用：</p>
<ul>
<li>attribute classification 属性分类</li>
<li>relationship classification 关系分类</li>
<li>description generation 描述生成</li>
<li>question answering QA</li>
</ul>
<p>更多应用：</p>
<ul>
<li>Dense image captioning</li>
<li>Visual question answering</li>
<li>Image understanding</li>
<li>Relationship extraction</li>
<li>Semantic image retrieval</li>
<li>Completing the Set of Annotations</li>
</ul>
<p>注 - 与其它数据集对比：   </p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/cjqe5v7i44.png?imageView2/2/w/1620" alt="img"></p>
<h2 id="3-Reference"><a href="#3-Reference" class="headerlink" title="3. Reference"></a>3. Reference</h2><p>[1] - <a href="https://visualgenome.org/" target="_blank" rel="noopener">Visual Genome Home</a></p>
<p>[1] - <a href="https://visualgenome.org/static/paper/Visual_Genome.pdf" target="_blank" rel="noopener">Visual Genome Doc</a></p>
<p>[2] - <a href="https://arxiv.org/pdf/1701.02426.pdf" target="_blank" rel="noopener">Scene Graph Generation by Iterative Message Passing</a></p>
<p>本文参与<a href="https://cloud.tencent.com/developer/support-plan" target="_blank" rel="noopener">腾讯云自媒体分享计划</a>，欢迎正在阅读的你也加入，一起分享。</p>
]]></content>
      <categories>
        <category>目标检测</category>
      </categories>
      <tags>
        <tag>目标检测</tag>
      </tags>
  </entry>
  <entry>
    <title>WMT Shared Tasks -- Human Evaluation </title>
    <url>/2020/05/14/WMT-Shared-Tasks-Human-Evaluation/</url>
    <content><![CDATA[<h3 id="WMT-Shared-Tasks-—-Human-Evaluation"><a href="#WMT-Shared-Tasks-—-Human-Evaluation" class="headerlink" title="WMT Shared Tasks — Human Evaluation"></a>WMT Shared Tasks — Human Evaluation</h3><h4 id="Human-Evaluation"><a href="#Human-Evaluation" class="headerlink" title="Human Evaluation"></a>Human Evaluation</h4><p>两种评估的方式：direct assessments (DA); language pairs evaluated with relative ranking (RR)</p>
<p>但是DA相比于RR更具有优势，namely，对翻译质量的评估采取 absolute score 的方式。可以<strong>实施quality control</strong> 。</p>
<h4 id="Human-judgement-quality-control"><a href="#Human-judgement-quality-control" class="headerlink" title="Human judgement quality control"></a>Human judgement quality control</h4><ul>
<li><p>每个标注者，每次任务：给定100个 （reference+ candidate）pair, 针对给定的reference, 评估生成的candidate的好坏。</p>
</li>
<li><p>100个pair中有60个用于quality control，40个由participating systems 生成的翻译组成。</p>
<p>（1）这60个pair，是官方设计出来的，包括三类，repeat pairs (expecting a similar judgment), damage MT outputs/ bad reference (expecting significantly worse scores) and use references instead of MT outputs (expecting high scores). 因此仅仅会有20%的资源消耗：bad reference; good reference</p>
<p>Specifically，先从正常的MT system 中 得到30个 （reference, MT output）pair，如 table 5 中的 original system output， 然后1)对1-10对，进行重复，得到10对。2）对11-20对，将MT output搞破坏。得到10对。3）对21-30对，取corresponding reference—&gt; (reference_1, reference_2)，得到10对。</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gepxhtqcpgj311h052abz.jpg"></p>
<p>（2）within each 100-translation HIT， 每个articipating system<strong>等比例的贡献</strong>a（within each 100-translation HIT, the same proportion of translations are included from each participating system for that language pair.  ）这是为了确保每个参与的 系统含有近似的相同数量的评估。同时，这也从三个方面得到了公平性的评估：1）每有一个workers做一个HIT, 则就会为所有参与的系统增加human judgement。2）不会轻易受到worker个性差异的影响，因为每个worker都会给所有参与的系统进行评估。3）尽管DA判断是绝对的，但众所周知，判断者会根据观察到的总体翻译质量来“校准”他们使用量表的方式。 对于每个HIT（包括所有参与的系统），这种影响都是平均的。</p>
</li>
</ul>
<h4 id="Annotator-Agreement"><a href="#Annotator-Agreement" class="headerlink" title="Annotator Agreement"></a>Annotator Agreement</h4><ul>
<li><p><strong>【bad reference pairs】</strong> 由于 bad reference pairs 的质量应该是显著偏低的，通过查看人类在这类pairs 上的评分是否也是显著偏低。来过滤掉可信赖度低的human assessors。</p>
<p>set（A, bad reference） 与  set（A, translatin_B）这两个集合上的人类评估，计算一个p-value， 若p-value&gt;0.05 则说明该human assessor的可信度低。</p>
</li>
<li><p><strong>【repeat pairs】</strong> 对于 repeat pairs, 查看得到 repeat assessments的程度。</p>
</li>
</ul>
<h4 id="Producing-the-Human-Ranking"><a href="#Producing-the-Human-Ranking" class="headerlink" title="Producing the Human Ranking"></a>Producing the Human Ranking</h4><ul>
<li><p>Standardized </p>
<p>为了消除不同的人类评估者的评分策略的差异，首先根据每个人类评估者的总体平均得分和标准差得分对翻译的人类评估得分进行<strong>标准化</strong>。</p>
</li>
<li><p>system  score ……</p>
</li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Vokenization Improving Language Understanding with Contextualized, Visual-Grounded Supervision</title>
    <url>/2020/10/18/Vokenization-Improving-Language-Understanding-with-Contextualized-Visual-Grounded-Supervision/</url>
    <content><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><h4 id="现存问题"><a href="#现存问题" class="headerlink" title="现存问题"></a>现存问题</h4><p>人类学习语言都是结合多模态信息，但是当前的 language pre-training frameworks 仅通过自监督的方式，学习语言这一种模态。</p>
<p>虽然这种自监督的方式取得了很大的成功，但是它们没有利用grounding information from external visual word.</p>
<blockquote>
<p>Emily M Bender and Alexander Koller. 2020. <strong>Climbing towards nlu: On meaning, form, and understanding in the age of data.</strong> In ACL.</p>
<p>Yonatan Bisk, Ari Holtzman, Jesse Thomason, Jacob Andreas, Yoshua Bengio, Joyce Chai, Mirella Lapata,<br>Angeliki Lazaridou, Jonathan May, Aleksandr Nisnevich, Nicolas Pinto, and Joseph Turian. 2020. <strong>Experience grounds language.</strong> In EMNLP</p>
</blockquote>
<h4 id="本文的解决"><a href="#本文的解决" class="headerlink" title="本文的解决"></a>本文的解决</h4><p><img src="https://i.loli.net/2020/10/17/1cz3MHUdNXA9o5J.png" alt="image-20201017095623630" style="zoom:33%;"></p>
<p>本文：介绍了一个 <strong>视觉</strong>监督语言模型，如图1，该模型使用 language tokens 作为输入，使用token-related images 作为视觉监督。本文将这些images称作 vokens，which act as visualizations of the corresponding tokens.</p>
<p>假若a large aligned token-voken dataset 存在，那么模型可以通过voken-prediction task 从这些vokens中进行学习。但是不幸的是，不存在这种大型数据集，主要是有两个挑战：(1) 视觉性单词与 其他非视觉性单词之间，数量上存在很大的差异。如，在visually-grounded language datasets中仅有120M tokens, 但是在BERT的训练数据中有3300M tokens。grounded language 一般会更短，偏向于instructive descriptions, 因此在句子长度和有效词的数量上与其他语言类型的分布不同。(2) 自然语言中的大部分单词是 not visually grounded，因此对是否建立一个 visual supervision的数据集提出了质疑。粗略估计，英语维基百科中 grounded tokens 的比例仅为大约28％。 这种 low grounded ratio 导致以前方法中的视觉监控覆盖率低。</p>
<p><img src="https://i.loli.net/2020/10/17/27sWCBNOiqp13Vz.png" alt="image-20201017111702738"></p>
<p>为解决以上的两个挑战，本文提出了一个 <strong>vokenization method, that contextually maps the tokens to the visualized tokens (i.e., vokens) by retrieval.</strong>  而不是直接使用具有visually grounded的语言数据集来监督语言模型。</p>
<p>解决第一个挑战：(1) relative small datasets to train the <strong>vokenization processor</strong> (2) generate vokens for large language corpora.<br>our visually-supervised language model will take the input supervision from these large datasets, thus <strong>bridging the gap between different data sources,</strong> which solves the first challenge.</p>
<p>解决第一个挑战：low grounded ratio 的第二个挑战似乎是语言的固有特征。 但是，我们发现，考虑到它的上下文，可以将一些非可视化的tokens 有效地映射到相关图像。by our contextual token-image matching model (defined in Sec. 3.2) inside our vokenization processor, where we map tokens to images by viewing the sentence as the context.</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Using our proposed vokenizer with a <strong>contextualized</strong> token-image matching model, we generate vokens for English Wikipedia. </p>
<p>Supervised by these generated vokens, we show consistent improvements upon a BERT model on several diverse NLP tasks such as GLUE (Wang et al., 2019), SQuAD (Rajpurkar et al., 2016), and SWAG (Zellers et al., 2018).  We also show the transferability of our vokens to other frameworks (i.e., RoBERTa).</p>
<h3 id="Vokenization"><a href="#Vokenization" class="headerlink" title="Vokenization"></a>Vokenization</h3><p><img src="https://i.loli.net/2020/10/17/fUWtQpIO8kZjAcY.png" alt="image-20201017120304025" style="zoom:50%;"></p>
<p>we <strong>retrieve an image for a token</strong> from a set of images $X$ = {$x_1; x_2; … ; x_n$} regarding a token-image-relevance scoring function $r_\theta(w_i; x; s)$. This scoring function $r_\theta(w_i; x; s)$, parameterized by $\theta$</p>
<h4 id="Contextual-Token-Image-Matching-Model"><a href="#Contextual-Token-Image-Matching-Model" class="headerlink" title="Contextual Token-Image Matching Model"></a>Contextual Token-Image Matching Model</h4><p>输入：The model takes a sentence $s$ and an image $x$ as input.</p>
<p>输出：The output $r_\theta(w_i; x; s)$ is the relevance score between the token $w_i \in s$ and the image $x$ while considering the whole sentence $s$ as a context.</p>
<p>Model: an inner product of the language feature representation $f_\theta(w_i; s)$ and the visual feature representation $g_\theta(x)$: $r_\theta(w_i; x; s)$ = $f_\theta(w_i; s)^T$ $g_\theta(x)$</p>
<p>token-image paris: 使用MS-COCO image caption pairs， 将caption中的所有tokens的vokens 都指定为该 image.</p>
<p>Training: 训练模型，maximizing the relevance score of these aligned token-image pairs over unaligned pairs. 使用 hinge loss.</p>
<h3 id="Visually-Supervised-Language-Models"><a href="#Visually-Supervised-Language-Models" class="headerlink" title="Visually-Supervised Language Models"></a>Visually-Supervised Language Models</h3><p>Based on these vokens, we propose a new pre-training task for language: voken classification.</p>
<h4 id="The-Voken-Classification-Task"><a href="#The-Voken-Classification-Task" class="headerlink" title="The Voken-Classification Task"></a>The Voken-Classification Task</h4><p><img src="https://i.loli.net/2020/11/04/j32ZMfNUpHWwez4.png" alt="image-20201104160728232"></p>
<p>BERT 的结果，会在每个token $w_i$的位置输出一个localized feature representation ${h_i}$，因此这将会很容易增加一个 token-level classification task, 而不需要修改模型的结构。Suppose the vokens come<br>from a finite set $X$, we convert the hidden output to ${h_i}$ a probability distribution ${p_i}$ with a linear layer and a softmax layer. </p>
<h3 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h3><ul>
<li>受到这篇文章对的影响，是否可以结合视频，设计一个这种模型，比如有一些动词，仅能在视频中体现出来。</li>
</ul>
]]></content>
      <tags>
        <tag>region-word-embedding</tag>
      </tags>
  </entry>
  <entry>
    <title>Visual Grounding in Video for Unsupervised Word Translation</title>
    <url>/2020/10/18/Visual-Grounding-in-Video-for-Unsupervised-Word-Translation/</url>
    <content><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>我们的目标是使用视觉基础来改进语言之间的非监督词映射。其核心思想是通过学习母语教学视频中未配对的嵌入语，在两种语言之间建立一种共同的视觉表达。</p>
<p>本文的工作就是<strong>向机器提供不同的教学视频</strong>，这些视频的内容是人们用本国语言的教学视频。比如说，说中文和英文教别人榨橙汁的教学视频。这类视频有两个特点：视频网站上<strong>大量存在</strong>和<strong>内容相似度高</strong>，非常适合用于训练。但是这些视频也有一些弊端，会有很多无关废话（如“观众老爷们记得素质三连哦~”）。</p>
<p>即使如此，这种基于视觉的翻译提高了翻译的精度。</p>
<h3 id="Unsupervised-Multilingual-Learning"><a href="#Unsupervised-Multilingual-Learning" class="headerlink" title="Unsupervised Multilingual Learning"></a>Unsupervised Multilingual Learning</h3><p><img src="https://i.loli.net/2020/10/18/qzv2QN3bd8oInSx.png" alt="image-20201018172741937"></p>
<p>一个无监督的系统，该系统通过将语言嵌入视频中翻译单词。其中，不需要任何配对数据来学习翻译。</p>
<p><strong>Our method</strong> is unsupervised in that it learns the correspondences between two languages $X$ and $Y$ (e.g. English and French) without any parallel (paired) corpora.</p>
<p>given two distinct collections of instructional videos, i.e. n videos narrated with language $X$and another m different videos with language $Y$.</p>
<p><strong>Our goal</strong> is to learn to map languages $X$ and $Y$ by leveraging the shared visual modality $Z$ – the videos.</p>
<p><strong>Loss function</strong></p>
<p><img src="https://i.loli.net/2020/10/18/uYrymIKnJwvL2G6.png" alt="image-20201018173014409" style="zoom: 25%;"></p>
<h4 id="Multilingual-Visual-Embedding-Architecture"><a href="#Multilingual-Visual-Embedding-Architecture" class="headerlink" title="Multilingual Visual Embedding: Architecture"></a>Multilingual Visual Embedding: Architecture</h4><p><img src="https://i.loli.net/2020/10/18/XU2slICkuhyLBRT.png" alt="image-20201018172904212" style="zoom:33%;"></p>
<p><strong>yaya:</strong>  通过 视觉将两种语言做一种映射是存在困难的。文中列出了三点：<br>（1）learning video-text embeddings from instructional videos is difficult as the speech in these videos is only loosely related to the scene.</p>
<p>（2）in multilingual setting, such errors compound since both languages have this low video-text relevance;<br>（3）visually similar videos may not be semantically similar.</p>
<p>因此本文不同video 作为桥梁直接学习两种语言的映射，而是采取了间接的方式：we learn a joint (monolingual) video-text embedding space from instructional videos.</p>
<p>对于一种语言X, 学习视频及其字幕的映射，对于另一种语言，也学习一种映射，同时，在这种语言上加一个Adaptlayer, 使得 X和Y 能够映射到一个共同的空间。</p>
<p><strong>模型细节：</strong></p>
<p>其中X编码器 = WordEmbed + （Liner + ReLU MaxPool) + Linear</p>
<p>（WordEmbed层，度向量的转换；Linear层，建立与 Joint Embedding Space的映射）</p>
<p>而Y编码器则多了一个调整层（AdaptLayer），进行的是跨语言共享模型的权重分配，尽量让Y语言的词和X语言的词有相似的嵌入。</p>
<h4 id="MUVE-Improving-Unsupervised-Translation"><a href="#MUVE-Improving-Unsupervised-Translation" class="headerlink" title="MUVE: Improving Unsupervised Translation"></a>MUVE: Improving Unsupervised Translation</h4><p>略</p>
]]></content>
  </entry>
  <entry>
    <title>[VisualSparta] Sparse Transformer Fragment-level Matching for Large-scale Text-to-Image Search</title>
    <url>/2021/03/16/VisualSparta-Sparse-Transformer-Fragment-level-Matching-for-Large-scale-Text-to-Image-Search/</url>
    <content><![CDATA[<h2 id="1-任务"><a href="#1-任务" class="headerlink" title="1. 任务"></a>1. 任务</h2><p>本文是做跨模态检索问题。文本到图像的检索是多模态信息检索中的一项基本任务，即在给定文本查询的情况下从大型且未标记的图像数据集中检索相关图像。</p>
<h2 id="2-存在的问题"><a href="#2-存在的问题" class="headerlink" title="2. 存在的问题"></a>2. 存在的问题</h2><p>图文检索问题上存在两个核心挑战：<strong style="color:red;">准确率以及速度</strong>。</p>
<h2 id="3-本文提出的点"><a href="#3-本文提出的点" class="headerlink" title="3. 本文提出的点"></a>3. 本文提出的点</h2><p>在本文中，提出了基于transformer 的 VisualSparta 模型，这是一种新颖的文本到图像检索模型，该模型在准确性和效率上都比现有模型显著提高。</p>
<p>本文提出的模型关注点在于两点：</p>
<p>（1）准确率，学习query tokens 与 image regions之间的细粒度关系，以丰富跨模态理解。</p>
<p>（2）有效性，独立的学习query 和 answer（image）的特征表示，从而使得模型可以<strong><strong style="color:red;">离线的</strong>索引所有的candidate images</strong>。整个VisualSparta 模型可以作为一个经典的反向索引（Inverted index）搜索引擎，以实现高效搜索。</p>
<h2 id="4-本文的贡献"><a href="#4-本文的贡献" class="headerlink" title="4. 本文的贡献"></a>4. 本文的贡献</h2><p>1) 性能优势：提出了一个新的基于片段交互（fragment-level interaction）的图文检索模型，并取得了SOTA的性能；</p>
<p>2) 速度优势：相比于标准的向量搜索，VisualSparta 有391x 速度提升。且实验证明，由于VisualSparta 可以有效的进行<strong>反向索引</strong> ，因此对于更大的数据集，速度优势会更加的明显，</p>
<p>3) 第一：VisualSparta 是<strong>第一个</strong>可以在大规模数据集上实现<strong>实时搜索</strong>的，基于transformer的 text-to-image retrieval model，并且实现了显著的性能提升。本文的方法证明了large pretrained model 也可以占用<strong>较少的内存和较少的计算时间</strong>。</p>
<p>4) 对当前存在的 text-to-image retrieval models 进行了 accuracy-latency comparisons。</p>
<h2 id="5-Method"><a href="#5-Method" class="headerlink" title="5. Method"></a>5. Method</h2><p>本文提出了 <strong>VisualSparta retriever</strong>, a fragment-level transformer-based model for efficient text-image matching.</p>
<p><img src="https://i.loli.net/2021/03/16/ZTKckhILpCEBv19.png" alt="image-20210316192344412"></p>
<h3 id="5-1-Query-representation"><a href="#5-1-Query-representation" class="headerlink" title="5.1 Query representation"></a>5.1 Query representation</h3><p>在检索中，<strong style="color:red;">query 的处理是一个在线操作</strong>。需要很好的考虑query 编码的效率。以前的方法，使用bi-RNN来处理 query sentence，为每个token获得上下文特征表示。</p>
<p>本文中，不采用序列处理的方式。丢掉query中的顺序信息，仅仅使用预训练的word embedding 来表征每个token。<strong>这种方法可以使得每个token的特征表达损失独立的，与上下文无关的</strong>。同时这种方式对于高效的indexing and inference 是必要的。</p>
<p>a query is represented as $\hat{w}=\left\{\hat{w}_{1}, \ldots, \hat{w}_{m}\right\}$</p>
<h3 id="5-2-Visual-Representation"><a href="#5-2-Visual-Representation" class="headerlink" title="5.2 Visual Representation"></a>5.2 Visual Representation</h3><p>相比于 query 需要实时在线处理，answer candidates 可以在 query 到来之前离线编制索引 (indexed offline)。因此，answer candidates 的处理可以更加丰富和复杂。因此，本文 follow OSCAR的工作，对于answer candidates 本文提取其上下文特征。</p>
<p>具体的看上图.</p>
<p>$H_{\text {image }} \in \mathbb{R}^{(n+k) \times d_{H}}$ is the final contextualized representation for one answer.</p>
<h3 id="5-3-Scoring-Function"><a href="#5-3-Scoring-Function" class="headerlink" title="5.3 Scoring Function"></a>5.3 Scoring Function</h3><p>第一个等式：学习 image element 和 每个query token 之间的fragment-level 交互。</p>
<p>$y_{i} =\max _{j \in[1, n+k]}\left(\hat{w}_{i}^{T} h_{j}\right) $              <strong>（equation 10）</strong></p>
<p>第二个等式：经过一个 ReLu 和 可训练的bias来得到sparse embedding。</p>
<p>$ \phi\left(y_{i}\right) =\operatorname{ReLU}\left(y_{i}+b\right) $              <strong>（equation 11）</strong></p>
<p>第三个等式：对于所有的分数求和，并为了抑制过大的分数，使用log operation</p>
<p>$ f(q, v) =\sum_{i=0}^{m} \log \left(\phi\left(y_{i}\right)+1\right) $             <strong>（equation 12）</strong></p>
<h3 id="5-4-Retriever-Training"><a href="#5-4-Retriever-Training" class="headerlink" title="5.4 Retriever Training"></a>5.4 Retriever Training</h3><p>最小化如下目标：</p>
<p>$J=f\left(q, v^{+}\right)-\log \sum_{k \in K^{-}} e^{\left.f\left(q, v_{k}\right)\right)}$</p>
<p><strong style="color:blue;"><strong>yaya: 这个损失函数其实与正常的NCE损失不同</strong></strong></p>
<p>负样本的选择：从相同batch 中的其他image samples作为负样本。</p>
<p><strong>而且本文发现，相比于一些复杂的负样本选择策略（比如，使用有相近标签的相似图像作为负样本），这种负样本的选择策略是简单有效地，效果相当。</strong></p>
<p><strong style="color:blue;">yaya: 为什么这种选择策略比复杂的策略是有效的？？是不是在不同的场合，应该使用不同的策略呢？？</strong></p>
<h3 id="5-5-Efficient-Indexing-and-Inference"><a href="#5-5-Efficient-Indexing-and-Inference" class="headerlink" title="5.5 Efficient Indexing and Inference"></a>5.5 Efficient Indexing and Inference</h3><p><strong style="color:red;">real-time inference</strong></p>
<p>定义 testing query 为 $q=\left[w_{0}, \ldots w_{m}\right]$</p>
<p>the <strong>ranking score</strong> between $q$ and an image is （利用5.3 中第二个等式得到的 sparse embedding）:</p>
<p>​    $\operatorname{CACHE}(w, v)=\log ($ sparse embedding $) \quad w \in W $             <strong>（equation 14）</strong></p>
<p>​    $f(q, v)=\sum_{i=1}^{m} \operatorname{CACHE}\left(w_{i}, v\right)$             <strong>（equation 15）</strong></p>
<p>由于query term embedding 不是基于上下文得到。因此，可以预先计算 vocabulary $W$ 中每个<strong>term</strong> $w$  与 每个 image candidates 之间的 ranking feature $\phi(w, v)$，<strong style="color:red;">生成的分数 is cached during indexing</strong>，如等式14 所示。得到了一个一个  <strong style="color:red;">$N_{vocab}*M_{images} $的矩阵</strong></p>
<p><strong>during inference time，最终的分数可以经过 O(1)的查询和一个简单的求和运算得到，如 公式15所示。</strong></p>
<p><strong style="color:red;">Inverted Index</strong></p>
<p>更加重要的是，以上的计算可以经由一个 Inverted Index 来高效的实施。 Inverted Index 是现代搜索引擎的基础数据结构，如图1所示。</p>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95</a></p>
</blockquote>
<h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><h3 id="Datasets"><a href="#Datasets" class="headerlink" title="Datasets"></a>Datasets</h3><ul>
<li><p>使用图像描述数据集作为本文text-to-image model 的数据来源。<strong>benchmark: MSCOCO; Flickr 30K</strong></p>
</li>
<li><p>for large-scale efficiency experiments: 由于目前不存在大规模的图像描述数据集。</p>
<p>因此，we <strong>manually design 113K and 1M datasets</strong> for testing the inference speed of different models in the large-scale setting.   对于这两个数据集，我们只关注于speed comparison。在数据上的模型性能忽略不比较。</p>
<p>The 113K dataset refers to the MSCOCO training set。</p>
<p>The 1M dataset we design consists of 1 million images randomly sampled from the MSCOCO training set.</p>
<p>所有的 <strong>efficiency test  experiments</strong> 都是在MSCOCO 1K and 5k test splits 再加上这113k 和 1M 数据上进行的。</p>
</li>
</ul>
<h3 id="Recall-Performance"><a href="#Recall-Performance" class="headerlink" title="Recall Performance"></a>Recall Performance</h3><p><img src="https://i.loli.net/2021/03/17/8dVeNz7bngQEwKl.png" alt="image-20210317120703074" style="zoom:50%;"></p>
<h3 id="Speed-Performance"><a href="#Speed-Performance" class="headerlink" title="Speed Performance"></a>Speed Performance</h3><p>三个模型使用相同的Faster-rcnn image region features。下表中没有考虑这部分时间。</p>
<p><img src="https://i.loli.net/2021/03/17/GfApECsXomRWHPq.png" alt="image-20210317120800787" style="zoom:50%;"></p>
<p>（1）在不同size的数据集下，本文提出的模型的速度远高于另外两个模型（一个使用dual encoding, 另一个使用transformer model）</p>
<p>（2）Table 2 also reveals that as the number of images increases, <strong>the performance drop is much slower</strong> when comparing VisualSparta with other two methods.</p>
<h3 id="Speed-Accuracy-Flexibility"><a href="#Speed-Accuracy-Flexibility" class="headerlink" title="Speed-Accuracy Flexibility"></a>Speed-Accuracy Flexibility</h3><p>在 Efficient Indexing and Inference 这一节，得到了一个  <strong style="color:red;">$N_{vocab}*M_{images} $的矩阵</strong>， 对于每个image, 与 N个words 计算出了weights, 可以挑选出 top-K， 这样更新为一个  <strong style="color:red;">$K_{words}*M_{images} $的矩阵</strong>，K 越小，检索效率越高。</p>
<p><img src="https://i.loli.net/2021/03/17/nkhj8yC6dPxugfw.png" alt="image-20210317132243925" style="zoom: 67%;"></p>
<p><img src="https://i.loli.net/2021/03/17/FmkRlfDp4WqTzOV.png" alt="image-20210317132318637" style="zoom: 50%;"></p>
<h3 id="Implementation-details"><a href="#Implementation-details" class="headerlink" title="Implementation details"></a>Implementation details</h3><ul>
<li>image encoder 的初始权重 从 Oscar-base model （12 layers and 768 hidden dimensions）中获得。</li>
<li>the query embedding， 使用Oscar-base word embedding的参数作为初始权重</li>
</ul>
<h2 id="可以查看的其他文献"><a href="#可以查看的其他文献" class="headerlink" title="可以查看的其他文献"></a>可以查看的其他文献</h2><p>本文受到此篇论文的启发: <strong>Sparta: Efficient open-domain question answering via sparse transformer matching retrieval.</strong></p>
<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a><strong>yaya</strong></h2><ul>
<li><p>对于输入的消融实现，如果不提供 object label ？</p>
<p><strong>本文没有做这个实验。</strong></p>
</li>
<li><p>实验结果与 transformer-based retrieval model 的对比， eg: Oscar, Unicoder-VL 等</p>
<p><strong>本文没有做对比，只是与不基于pre-trained models 进行了对比。</strong></p>
<p><strong>但是实际上，本文的实验效果在准确率上，是不如那些基于预训练模型的。</strong></p>
</li>
<li><p>使用了 transformer 结构，那么本文的学习率是如何设计的？先warm up吗？？</p>
<p><strong>本文学习率为 1e-5， bs=20, 没有对学习率的变化进行说明。</strong></p>
</li>
<li><p>本文发现，相比于一些复杂的负样本选择策略（比如，使用有相近标签的相似图像作为负样本），这种负样本的选择策略是简单有效地，效果相当。</p>
<p><strong>对于这部分，论文中并没有相关的解释与实验数据说明</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>cross-modal</category>
        <category>real time</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
        <tag>real time</tag>
      </tags>
  </entry>
  <entry>
    <title>Weakly-Supervised Spatio-Temporally Grounding Natural Sentence in Video</title>
    <url>/2019/12/02/Weakly-Supervised-Spatio-Temporally-Grounding-Natural-Sentence-in-Video/</url>
    <content><![CDATA[<ul>
<li><strong>ACL 2019</strong></li>
</ul>
<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><ul>
<li><p>image grounding取得了很大的进步，但是将该任务迁移到视频上，需要对视频中的每帧都标注region，这个工程量是巨大的。</p>
</li>
<li><p>为了避免这种标注工作的工程量，一些<strong>weakly-supervised</strong> video grouding工作【1】【2】被提出来，他们只提供了video-sentence pairs，没有提供 fine-grained regional annotations。在他们的 video grounding任务中，他们仅仅对名词和代词在 视频的静态帧进行grounding。</p>
</li>
<li><p>但是这种 grounding存在问题，比如sentence: A brown and white dog is lying on the grass and then it stands up. 但是帧中出现了多个狗，而我们给出的要搜索的对象仅仅是一个名词： ‘dog’，没有其他更多的信息，来进行更加具体地定位，那么就有可能定位错误。另外只对一张静态帧进行定位，也无法捕捉到object在时域上的动态变化。</p>
</li>
<li><p>基于上述的分析，本文提出了一个在video grounding上 weakly-supervised 的新任务：<strong>weakly-supervised spatio-temporally grounding sentence in video (WSSTG).</strong>    </p>
</li>
</ul>
<h3 id="Weakly-supervised-spatio-temporally-grounding-sentence-in-video"><a href="#Weakly-supervised-spatio-temporally-grounding-sentence-in-video" class="headerlink" title="Weakly-supervised spatio-temporally grounding sentence in video"></a>Weakly-supervised spatio-temporally grounding sentence in video</h3><ul>
<li>Specifically, given a natural sentence and a video, we aim to localize a spatio-temporal tube (i.e., a sequence of bounding boxes) ,（本文中作者将tube 称作 instance）</li>
<li>yaya: 相比于之前的video-grounding任务，同是 weakly-supervised，但是有两点不同：（1）是句子级别的描述，对要定位的对象的描述更加具体，而不是仅仅是个noun。（2）是要定位出一个 spatial-temporal tube，而不是仅在一张静态帧中定位出一个bbox。</li>
<li>这两点不同同时带来了优势和挑战</li>
<li>（1）细节性的描述可以消除歧义，但是如何捕捉句子中的语义并在video中定位出来是一个难题；（2）相比于在静态帧中定位一个bbox, 而是在video中定位一个tube,更能呈现出一个object在时域上的动态。但是，如何利用和建模tube的时空特性以及它们与句子的复杂关系提出了另一个挑战。</li>
<li>compared with 【2】: different from 【2】，whose text input consists of nouns/pronouns and output is a bounding box in a specific frame, we aim  to ground a natural sentence and output a spatio-temporal tube in the video. </li>
</ul>
<h3 id="Contributions"><a href="#Contributions" class="headerlink" title="Contributions"></a>Contributions</h3><ul>
<li>提出了一个新任务：weakly-supervised spatio-temporally grounding sentence in video</li>
<li>针对该任务提出了一个method：提出了一个Attentive interactor利用 tube(instance) 与 sentence之间的细粒度的关系来计算 匹配度；提出了一个diversity loss来加强 reliable instance-sentence pairs 并惩罚 unreliable ones。</li>
<li>在VID object detection dataset 数据集的基础上，对tube(instance) 增加了description</li>
</ul>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><h4 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h4><ul>
<li>该任务是 给出一个 a natural sentence query <strong>q</strong> and a video <strong>v</strong> 来定位一个spatial-temporal tube，作者也将这个tube 称作 instance。</li>
<li>由于是弱监督，因此仅仅只给出 video-sentence pair，细粒度的regional annotations不给出！</li>
<li>将该任务转为一个 Multiple instance learning problem。给定一个video，首先由instance generator【3】来生成一组instance proposals，然后再根据语义相似性来匹配 natural sentence query 和 instance。  </li>
</ul>
<h4 id="Instance-Extraction"><a href="#Instance-Extraction" class="headerlink" title="Instance Extraction"></a>Instance Extraction</h4><ul>
<li><strong>Instance Generation</strong> ：  先由faster rcnn提取object proposals，假设每帧提取N个proposal ， 然后根据【3】得到N个spatial-temporal tube</li>
<li><strong>Feature Representation</strong> ：I3D-RGB， I3D-Flow， frame-level RoI pooled feature   </li>
</ul>
<h4 id="Attentive-Interactor"><a href="#Attentive-Interactor" class="headerlink" title="Attentive Interactor"></a>Attentive Interactor</h4><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g9io2sodynj30i40hk0v9.jpg" alt="搜狗截图20191202204720.png"></p>
<ul>
<li>（1）分别对 sequential visual features 和 sequential textual features 经过LSTM进行编码，LSTM每个step输出的隐层状态作为新的representation，得到新的visual feature 和 sentence representation</li>
<li>（2）依次以visual feature中的每个隐状态作为查询，以 sentence 所有隐状态作为key 和 value，输入Attention中，则得到了<strong>visual guided sentence feature</strong>。（直观的理解：在给定某一个视觉特征，用attention去分析要关注哪一个word）  </li>
</ul>
<h4 id="Matching-Behavior-Characterization"><a href="#Matching-Behavior-Characterization" class="headerlink" title="Matching Behavior Characterization"></a>Matching Behavior Characterization</h4><ul>
<li>用余弦函数计算 <code>i-th</code> visual feature 和 visual guided sentence features 之间的 匹配度</li>
<li>对所有的step 加和，则得到instance proposal 与 sentence 之间的匹配度</li>
</ul>
<h3 id="Training-Loss"><a href="#Training-Loss" class="headerlink" title="Training Loss"></a>Training Loss</h3><ul>
<li><p>论文对这里介绍的比较详细，参见论文。</p>
</li>
<li><p><strong>ranking loss</strong>： aiming at distinguishing aligned video-sentence pairs from the unaligned ones.  这个损失是希望不匹配的video-sentence之间计算出来的匹配度差一些，比如给网络输入不与该视频对应的句子。</p>
</li>
<li><strong>novel diversity loss</strong> ：to strengthen the matching behaviors between reliable instance-sentence pairs and penalize the unreliable ones from the aligned video-sentence pair.  这个损失主要是希望对一个video，在计算tube 与 sentence之间的匹配度时，希望不同的 tube之间的差异性（diversity）大一些！</li>
</ul>
<h3 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h3><ul>
<li>一个video 给出了N个 tube proposal，当计算完匹配度之后，选取匹配度最大的那个proposal，然后计算与GT之间的 overlap【4】，若overlap 大于一个阈值，则任务预测正确。</li>
</ul>
<h3 id="Yaya-Analysis："><a href="#Yaya-Analysis：" class="headerlink" title="Yaya Analysis："></a>Yaya Analysis：</h3><ul>
<li><p><strong>此类任务可提升的point</strong></p>
</li>
<li><p>更好的 detector来获取 object proposal</p>
</li>
<li><p>更好的算法来获取 tube proposal</p>
</li>
<li><p>设计算法更好滴计算 sentence 与 tube proposal 匹配度！</p>
</li>
<li><p>对 rank loss 给予更多的约束，像此文：提出了一个novel  diversity loss</p>
</li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li>【1】De-An Huang, Shyamal Buch, Lucio Dery, Animesh Garg, Li Fei-Fei, and Juan Carlos Niebles. 2018. <strong>Finding “it”: Weakly-supervised reference-aware visual grounding in instructional videos</strong>. In CVPR. </li>
<li>【2】Luowei Zhou, Nathan Louis, and Jason J Corso. 2018. <strong>Weakly-supervised video object grounding from text by loss weighting and object interaction</strong>. BMVC. </li>
<li>【3】Georgia Gkioxari and Jitendra Malik. 2015. <strong>Finding action tubes</strong>. In CVPR, pages 759–768. </li>
<li>【4】Masataka Yamaguchi, Kuniaki Saito, Yoshitaka Ushiku, and Tatsuya Harada. 2017. <strong>Spatio-temporal person retrieval via natural language queries</strong>. In ICCV. </li>
</ul>
]]></content>
      <categories>
        <category>Visual Grounding</category>
      </categories>
      <tags>
        <tag>Viusal Grounding</tag>
      </tags>
  </entry>
  <entry>
    <title>Zero-Shot Detection via Vision and Language Knowledge Distillation</title>
    <url>/2021/06/25/Zero-Shot-Detection-via-Vision-and-Language-Knowledge-Distillation/</url>
    <content><![CDATA[<p>来源：<a href="https://zhuanlan.zhihu.com/p/369153230" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/369153230</a></p>
<p>今年年初刚出的CLIP可以说是震惊了NLP和CV界，它让大白话搜图不再是梦想，就像这样：</p>
<p><img src="https://i.loli.net/2021/07/19/sXp4lcNJHfdTg6a.png" alt="image-20210719102532427" style="zoom:67%;"></p>
<p>以上是一个老哥用CLIP在unsplash数据集上做的大白话搜图引擎，有兴趣的同学们可以去感受一下：</p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/haltakov/natural-language-image-search" target="_blank" rel="noopener">natural-language-image-searchgithub.com</a></p>
<p>其实CLIP做的事情很简单，简单说来就是<strong>学习出了一个图像和文本的共同空间</strong>，给定任意图像和文本都可以映射到这个空间中，然后这些图像和文本就可以<strong>直接计算相似度</strong>，于是就可以做到用大白话来搜图。换句话说，CLIP找到了一个方式<strong>填平了文本和视觉的gap</strong>。</p>
<p>那既然如此，可不可以进一步拓展，利用CLIP来做检测，比如我随便说一句话就可以检测出图像里面对应的物体，不管我这句话里面的物体属于任意类别呢？当然可以！而且谷歌已经做出来了，就在前天挂上了arXiv，不得不感叹他们真的太快了（CLIP才出了3个月啊）</p>
<p>这篇文章的名字就叫<strong>Zero-Shot Detection via Vision and Language Knowledge Distillation。</strong>zero-shot顾名思义，就是对于一个新类别，一张训练图像都不给的情况下训练出能检测这个类别物体的检测器；而knowledge distillation呢，指的就是从CLIP中蒸馏出知识来训练检测器（毕竟CLIP用了4亿个文本-图像对训练，肯定得好好利用啊）。</p>
<p>这个方法的名字叫做ViLD（Vision and Language knowledge Distillation），首先感受一下它的效果：</p>
<p><img src="https://i.loli.net/2021/07/19/QcueiMgxDAGhk2H.png" alt="image-20210719102620483"></p>
<p>这些玩具都是训练集里没有出现过的类别哦。</p>
<p>那么ViLD是怎么做的呢？框架图先贴出来：</p>
<p><img src="https://i.loli.net/2021/07/19/5g479jOJ2PB6ikQ.png" alt="image-20210719102700196"></p>
<p>定位网络用的是Mask R-CNN，BackBone提特征图，RPN提proposal，然后RoiAlign提proposal的特征就不用多说了。</p>
<p>训练时，重点在图像会用proposal进行裁剪，裁剪下来的图像会送入预训练好的CLIP中得到在其<strong>共同空间</strong>中的特征，训练的目标就是<strong>拉近proposal特征和CLIP得到的裁剪图像特征的距离</strong>，这个训练可以认为是一种蒸馏，把CLIP中的知识传递给了训练的模型。这样训练好的模型提取出的proposal特征也可以认为已经在CLIP的共同空间中了。这一部分对应于图中上半部分的Training<strong>。</strong></p>
<p>测试时，先把需要分类的文本标签通过其在CLIP共同空间的特征。然后图像中的proposal特征就可以<strong>直接与这些文本标签特征进行相似度计算</strong>（因为它们可以假设都位于CLIP的共同空间中），完成分类。</p>
<p>具体来看训练时候是怎么做的：</p>
<p><img src="https://i.loli.net/2021/07/19/WnESNvxVQCYmKRg.png" alt="image-20210719102730131"></p>
<p>直接看（b）部分，其中的ViLD-text部分就是在文本模态进行训练，比如当前的proposal对应的类别为“猫”，那么相应的，这个proposal特征应该和CLIP对“猫”这个文本生成的在共同空间中的特征相近。</p>
<p>ViLD-image则是在视觉模态进行训练，即proposal特征应该和根据这个proposal裁剪下来的图像在CLIP的共同空间的特征相近。</p>
<p>总结一下，就是在两个模态上对CLIP进行知识蒸馏，目的是将proposal特征映射到CLIP的共同空间中，其中文本模态由类别标签得到，视觉模态由裁剪的图像得到。</p>
<p>说下自己的感受吧，这个idea本来我刚刚想到，结果现在看到这篇文章，心里还是暗喜还好没开始做hhhhh。更多还是感叹大厂的速度是真的快，仅仅三个月就整出来了完成度和创新度都很不错的一篇文章。另外利用CLIP做跨模态肯定是以后的趋势了，毕竟用了4亿图像-文本对训练出来的模型填平了视觉和文本的gap，绝对大有搞头。</p>
<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><p>本文使用了两个损失，一个是L1 loss,用于知识蒸馏，而cross entropy loss 则是为了使用CLIP预测的范式（使用匹配的方式来做分类预测）。</p>
<p>这两个损失是缺一不可的，仅使用L1 loss 来知识蒸馏是没有任何用的，因为这里并不是想获取更好的视觉特征，而是使用clip的预测范式。</p>
]]></content>
      <categories>
        <category>目标检测</category>
      </categories>
      <tags>
        <tag>目标检测</tag>
      </tags>
  </entry>
  <entry>
    <title>coco-detection</title>
    <url>/2019/03/02/coco-detection/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>automatic metric 总结</title>
    <url>/2020/07/23/automatic-metric-%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="automatic-metric-总结"><a href="#automatic-metric-总结" class="headerlink" title="automatic metric 总结"></a>automatic metric 总结</h1><p>转载：<code>肝了1W字！文本生成评价指标的进化与推翻</code></p>
<h2 id="基于词重叠率的方法"><a href="#基于词重叠率的方法" class="headerlink" title="基于词重叠率的方法"></a>基于词重叠率的方法</h2><h2 id="机器翻译-amp-摘要-常用指标"><a href="#机器翻译-amp-摘要-常用指标" class="headerlink" title="机器翻译 &amp; 摘要 常用指标"></a><strong>机器翻译 &amp; 摘要 常用指标</strong></h2><p>基于词重叠率的方法是指基于词汇的级别计算模型的生成文本和人工的参考文本之间的相似性，比较经典的代表有BLEU、METEOR和ROUGE，其中BLEU和METEOR常用于机器翻译任务，ROUGE常用于自动文本摘要。</p>
<h3 id="BLEU"><a href="#BLEU" class="headerlink" title="BLEU"></a><strong>BLEU</strong></h3><p>BLEU （Bilingual Evaluation Understudy，双语评估辅助工具）可以说是所有评价指标的鼻祖，它的核心思想是比较候选译文和参考译文里的 n-gram 的重合程度，重合程度越高就认为译文质量越高。unigram用于衡量单词翻译的准确性，高阶n-gram用于衡量句子翻译的流畅性。实践中，通常是取N=1~4，然后对进行加权平均。<img src="https://mmbiz.qpic.cn/mmbiz_jpg/5fknb41ib9qFEWM9OIZ9BADhs7bP0lrAg4GOn0EZAicLNZY3lw97TdibGCPyA09s0Ms9KZT1CpypiaZ0EwLuG5ZGrA/640?wx_fmt=jpeg" alt="img" style="zoom: 50%;"></p>
<ul>
<li>BLEU 需要计算译文 1-gram，2-gram，…，N-gram 的精确率，一般 N 设置为 4 即可，公式中的 <em>Pn 指 n-gram 的精确率</em>。</li>
<li>Wn 指 n-gram 的权重，一般设为均匀权重，即对于任意 n 都有 Wn = 1/N。</li>
<li>BP 是惩罚因子，如果译文的长度小于最短的参考译文，则 BP 小于 1。</li>
<li>BLEU 的 1-gram 精确率表示译文忠于原文的程度，而其他 n-gram 表示翻译的流畅程度。</li>
</ul>
<p>不过BLEU对词重复和短句有着非常不好的表现，所以改进的BLEU分别使用 <strong>改进的多元精度（n-gram precision）</strong> 和<strong>短句惩罚因子</strong>进行了优化。</p>
<h4 id="1-改进的多元精度（n-gram-precision）"><a href="#1-改进的多元精度（n-gram-precision）" class="headerlink" title="1. 改进的多元精度（n-gram precision）"></a>1. 改进的多元精度（n-gram precision）</h4><p>假设机器翻译的译文C和一个参考翻译S1如下：</p>
<blockquote>
<p>C: a cat is on the table<br>S1: there is a cat on the table</p>
</blockquote>
<p>则可以计算出 1-gram，2-gram，… 的精确率（参考文献里写的是准确率(accuracy),我理解是写错了，此处应该是精确率(precision)）</p>
<p>p1 计算 a cat is on the table 分别都在参考翻译S1中 所以 p1 = 1</p>
<p>p2  (a, cat)在, (cat is) 没在, (is on) 没在, (on the) 在, (the table)在 所以p2 = 3/5</p>
<p>p3  (a cat is)不在, (cat is on)不在, (is on the)不在, (on the table)在 所以 p3 = 1/4</p>
<p>依次类推(上面的在或者不在, 说的都是当前词组有没有在参考翻译中)。直接这样算, 会存在很大的问题. 例如:</p>
<blockquote>
<p>C: there there there there there S1: there is a cat on the table</p>
</blockquote>
<p>这时候机器翻译的结果明显是不正确的，但是其 1-gram 的 Precision 为1，因此 BLEU 一般会使用修正的方法。给定参考译文S1,S2, …,S<em>m</em>，可以计算C里面 n 元组的 Precision，计算公式如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5fknb41ib9qFEWM9OIZ9BADhs7bP0lrAgXmshfK57WrgarjibbBcy4ZdtxHS9Y3EtyDfTzjTNNl2GMxwJAIPmfbA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>针对上面的例子  p1 = 1/5  (因为there在C和S1中都出现了 我们按最少的次数来)</p>
<p><strong style="color:red;">yaya: 从公式中，可以看到，对于m个reference，取max 的方式，进行聚合</strong></p>
<h4 id="2-惩罚因子"><a href="#2-惩罚因子" class="headerlink" title="2. 惩罚因子"></a>2. 惩罚因子</h4><p>上面介绍了 BLEU 计算 n-gram 精确率的方法， 但是仍然存在一些问题，当机器翻译的长度比较短时，BLEU 得分也会比较高，但是这个翻译是会损失很多信息的，例如：</p>
<blockquote>
<p>C: a cat<br>S1: there is a cat on the table</p>
</blockquote>
<p>因此需要在 BLEU 分数乘上惩罚因子</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5fknb41ib9qFEWM9OIZ9BADhs7bP0lrAgaghJVhQZHwspVre1F1yyaAkZj4UnUwUDIurNHI8aPb8vlNP3GWg0Lw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h4 id="3-优点"><a href="#3-优点" class="headerlink" title="3. 优点"></a>3. 优点</h4><ul>
<li>它的易于计算且速度快，特别是与人工翻译模型的输出对比；</li>
<li>它应用范围广泛，这可以让你很轻松将模型与相同任务的基准作对比。</li>
</ul>
<h4 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4. 缺点"></a>4. 缺点</h4><ul>
<li>它不考虑语义，句子结构</li>
<li>不能很好地处理形态丰富的语句（BLEU原文建议大家配备4条翻译参考译文）</li>
<li>BLEU 指标偏向于较短的翻译结果（brevity penalty 没有想象中那么强）</li>
</ul>
<h3 id="ROUGE"><a href="#ROUGE" class="headerlink" title="ROUGE"></a><strong>ROUGE</strong></h3><p>英文全称Recall-Oriented Understudy for Gisting Evaluation，可以看做是BLEU 的改进版，专注于<strong>召回率而非精度</strong>。换句话说，它会查看有多少个参考译句中的 n 元词组出现在了输出之中。</p>
<p>ROUGE大致分为四种（常用的是前两种）：</p>
<ul>
<li>ROUGE-N （将BLEU的精确率优化为召回率）</li>
<li>ROUGE-L （将BLEU的n-gram优化为公共子序列）</li>
<li>ROUGE-W （将ROUGE-L的连续匹配给予更高的奖励）</li>
<li>ROUGE-S  （允许n-gram出现跳词(skip)）</li>
</ul>
<p>ROUGE 用作机器翻译评价指标的初衷是这样的：在 SMT（统计机器翻译）时代，机器翻译效果稀烂，需要同时评价翻译的准确度和流畅度；等到 NMT （神经网络机器翻译）出来以后，神经网络脑补能力极强，翻译出的结果都是通顺的，但是有时候容易瞎翻译。</p>
<p>ROUGE的出现很大程度上是为了解决NMT的漏翻问题（低召回率）。所以 ROUGE 只适合评价 NMT，而不适用于 SMT，因为它不管候选译文流不流畅</p>
<p>这里只介绍 ROUGE_L</p>
<h4 id="ROUGE-L"><a href="#ROUGE-L" class="headerlink" title="ROUGE-L"></a>ROUGE-L</h4><p>ROUGE-L 中的 L 指最长公共子序列 (longest common subsequence, LCS)，ROUGE-L 计算的时候使用了机器译文C和参考译文S的最长公共子序列，计算公式如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5fknb41ib9qFEWM9OIZ9BADhs7bP0lrAgfXBibHaKdNJDXNPgWhZ0L9FKG1b8LuabowzXZiaMhGXB3WQSepe0gYiaw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" style="zoom:33%;"></p>
<p>公式中的 RLCS 表示召回率，而 PLCS 表示精确率，FLCS 就是 ROUGE-L。一般 beta 会设置为很大的数，因此 FLCS 几乎只考虑了 RLCS (即召回率)。注意这里 beta 大，则 F 会更加关注 R，而不是 P，可以看下面的公式。如果 beta 很大，则 PLCS 那一项可以忽略不计。</p>
<p><strong style="color:red;">yaya: 对于含有多个reference的情况，先分别计算 R<sub>LCS</sub> 和 P<sub>LCS</sub>， 再分别取max，得到 max_R, max_P之后，再带入 F<sub>LCS</sub> 中。</strong></p>
<h3 id><a href="#" class="headerlink" title=" "></a> </h3><h3 id="METEOR"><a href="#METEOR" class="headerlink" title="METEOR"></a><strong>METEOR</strong></h3><p>和BLEU不同，METEOR同时考虑了基于整个语料库上的准确率和召回率，而最终得出测度。</p>
<p>METEOR也包括其他指标没有发现一些其他功能，如<strong>同义词匹配</strong>等。METEOR用 WordNet 等知识源扩充了一下同义词集，同时考虑了单词的词形（词干相同的词也认为是部分匹配的，也应该给予一定的奖励，比如说把 likes 翻译成了 like 总比翻译成别的乱七八糟的词要好吧？）</p>
<p><strong>在评价句子流畅性的时候，用了 chunk 的概念</strong>（候选译文和参考译文能够对齐的、空间排列上连续的单词形成一个 chunk，这个对齐算法是一个有点复杂的启发式 beam serach），chunk 的数目越少意味着每个 chunk 的平均长度越长，也就是说候选译文和参考译文的语序越一致。</p>
<p>最后，METEOR计算为对应最佳候选译文和参考译文之间的准确率和召回率的调和平均：</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ggzxernqjrj30pe0hut9u.jpg" style="zoom:33%;"></p>
<h4 id="1-理解"><a href="#1-理解" class="headerlink" title="1. 理解"></a>1. 理解</h4><p>看公式总是挺抽象的，下面我们还是看看来自维基百科的例子吧。计算的最基本单元是句子。算法首先从待评价字符串和参考字符串之间创建一个平面图如下：<img src="https://mmbiz.qpic.cn/mmbiz_jpg/5fknb41ib9qFEWM9OIZ9BADhs7bP0lrAgruCbgRHd3tQITE2N2mQsfJUficbIQav7TBGZA7wvUpnyiaoMlwfYYxrg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>所谓<strong>平面图</strong>，就是1元组之间的映射集。平面图有如下的一些限制：在待评价翻译中的每个1元组必须映射到参考翻译中的1个或0个一元组，然后根据这个定义创建平面图。<strong>如果有两个平面图的映射数量相同，那么选择映射交叉数目较少的那个。</strong> 也就是说，上面左侧平面图会被选择。状态会持续运行，在每个状态下只会向平面图加入那些在前一个状态中尚未匹配的1元组。<em>一旦最终的平面图计算完毕，就开始计算METEOR得分</em>：</p>
<p>1元组精度：</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ggzxernte4j307d04fmx0.jpg" style="zoom:33%;"></p>
<p>其中m是<em>在参考句子中同样存在的，**待评价句子中的一元组的数量</em>。wt是<em>待评价翻译中一元组的数量</em>。</p>
<p>1元组召回率：</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ggzxersvbuj307s04h745.jpg" style="zoom:33%;"></p>
<p>m同上，是参考翻译中一元组的数量。</p>
<p>然后使用调和平均来计算F-mean，且召回的权重是精度的9（上面说的超参数α）倍。</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ggzxerunotj30eo054jre.jpg" style="zoom:33%;"></p>
<p>到目前为止，这个方法只对单个单词的一致性进行了衡量，还没有用到为了评价流畅性的 <strong>chunk</strong> 。chunk 块的定义是在待评价语句和参考语句中毗邻的一元组集合。</p>
<p>在参考和待评价句子中的没有毗连的映射越多，惩罚就越高。为了计算惩罚，1元组被分组成最少可能的块（chunks）。<em>在待评价语句和参考语句之间的毗邻映射越长，块的数量就越少</em>。一个待评价翻译如果和参考翻译相同，那么就只有一个块。惩罚p的计算如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ggzxeruhhij30dj05pwei.jpg" style="zoom:33%;"></p>
<p>（假设参数都已经设置好了）其中c就是块的数量，Um是被映射的一元组的数量。p可以减少F-mean的值。最后：</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ggzxertdasj30fn02xjrb.jpg" style="zoom:33%;"></p>
<h4 id="2-优点"><a href="#2-优点" class="headerlink" title="2. 优点"></a>2. 优点</h4><ul>
<li>该方法基于一元组的精度和召回的调和平均，召回的权重比精度要高一点 ， 与人类判断相关性高</li>
<li><em>引入了外部知识，评价更加友好了。</em></li>
</ul>
<h4 id="3-缺点"><a href="#3-缺点" class="headerlink" title="3. 缺点"></a>3. 缺点</h4><ul>
<li>实现非常复杂，目前只有java版本</li>
<li>α、γ和θ 均为用于评价的默认参数。这些都是对着某个数据集调出来的（让算法的结果和人的主观评价尽可能一致，方法我记得是 grid search）。参数一多听起来就不靠谱（给个眼神体会一下）</li>
<li>需要有外部知识。如果很多词不在wordnet，那其实就没什么意义了</li>
</ul>
<h2 id="image-caption-常用指标"><a href="#image-caption-常用指标" class="headerlink" title="image caption 常用指标"></a><strong>image caption 常用指标</strong></h2><h3 id="CIDEr"><a href="#CIDEr" class="headerlink" title="CIDEr"></a><strong>CIDEr</strong></h3><p>CIDEr 是专门设计出来用于图像标注问题的。这个指标将每个句子都看作“文档”，将其表示成 Term Frequency Inverse Document Frequency（tf-idf）向量的形式，通过对每个n元组进行(TF-IDF) 权重计算，计算参考 caption 与模型生成的 caption 的余弦相似度，来衡量图像标注的一致性的。</p>
<ul>
<li>公式<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5fknb41ib9qFEWM9OIZ9BADhs7bP0lrAgicMuoIiabcIRSiaXj1tLEmgWU5ysVK6ZO4FlTJmfc5S3j3vS7tyzuibkEg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></li>
<li>举例<img src="https://mmbiz.qpic.cn/mmbiz_jpg/5fknb41ib9qFEWM9OIZ9BADhs7bP0lrAg6qxl9VK30SIG0T4LBfVOkbrqRlx4DyBcDK9tRk9vMrwCKfvZYC1ZBw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></li>
</ul>
<h4 id="1-好处"><a href="#1-好处" class="headerlink" title="1. 好处"></a>1. 好处</h4><p>是一种加权的评价指标，他更关注你是否说到了重点，而常见的词权重则没有那么高。在 Kaustav_slides image caption的综述里，也提到这个评价指标和人类的评价相关性更高一些</p>
<h3 id="SPICE"><a href="#SPICE" class="headerlink" title="SPICE"></a><strong>SPICE</strong></h3><p>SPICE 也是专门设计出来用于 image caption 问题的。全称是 Semantic Propositional Image Caption Evaluation。</p>
<p>我们考虑如下图片：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5fknb41ib9qFEWM9OIZ9BADhs7bP0lrAgl3KCxN5scYCpo7RnLCVOWpTmaG8scssC1iaibPwzaNCQNATuOsU7Dq3g/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>你很快会发现尽管生成的句子与参考句极为相似（只有basketball一词不一样），但我们仍认为这是一个糟糕的生成。原因在于考虑了语义的情况下，模型把网球场错误的识别成了篮球场。这个时候BLEU或者其他指标就不能很好的评价生成效果了。</p>
<p>SPICE 使用基于图的语义表示来编码 caption 中的 objects, attributes 和 relationships。它先将待评价 caption 和参考 captions 用 Probabilistic Context-Free Grammar (PCFG) dependency parser parse 成 syntactic dependencies trees，然后用基于规则的方法把 dependency tree 映射成 scene graphs。最后计算待评价的 caption 中 objects, attributes 和 relationships 的 F-score 值。</p>
<p>还是已上图为例，a young girl standing on top of a tennis court (参考句) 可以被SPICE做如下处理：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5fknb41ib9qFEWM9OIZ9BADhs7bP0lrAgRYbeW3NVtIAQDicktJATMl9o5KkyImngjsiaIdnX8SdvwFEibsxA59UyQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img">得到了若干个三元组之后，我们通过下面的公式来计算候选句c和参考句（或集合）S的得分：</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gh01gh6umpj313d0fx408.jpg" style="zoom:33%;"></p>
<p>这里有一个例子：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5fknb41ib9qFEWM9OIZ9BADhs7bP0lrAgwIdbmLATA8Zk5uKHZDAAGkyJlf0J0ZDHPicGUibNgAlUCdrPlT82javA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h4 id="1-好处-1"><a href="#1-好处-1" class="headerlink" title="1. 好处"></a>1. 好处</h4><ul>
<li>对目标，属性，关系有更多的考虑；</li>
<li>和基于n-gram的评价模式相比，有更高的和人类评价的相关性</li>
</ul>
<h4 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h4><ul>
<li>不考虑语法问题</li>
<li>依赖于semantic parsers ， 但是他不总是对的</li>
<li>每个目标，属性，关系的权重都是一样的（一幅画的物体显然有主次之分）</li>
</ul>
]]></content>
      <categories>
        <category>图像描述</category>
        <category>评价指标</category>
      </categories>
      <tags>
        <tag>评价指标</tag>
      </tags>
  </entry>
  <entry>
    <title>correlation coefficient</title>
    <url>/2020/08/26/correlation-coefficient/</url>
    <content><![CDATA[<h1 id="correlation-coefficient"><a href="#correlation-coefficient" class="headerlink" title="correlation coefficient"></a>correlation coefficient</h1><ul>
<li>spearman 和 kendall 计算的都是对排序 之间的计算</li>
<li>pearson 计算的是直接的数值，协方差，标准差之间的计算</li>
</ul>
<h3 id="pearson"><a href="#pearson" class="headerlink" title="pearson"></a>pearson</h3><ul>
<li><p>代码实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以下两种方式都可以</span></span><br><span class="line">scipy.stats.pearsonr(array_1, array_2)</span><br><span class="line">np.corrcoef(array_1, array_2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算公式</p>
<p><img src="https://i.loli.net/2020/08/26/lXA4uMz9UkG2vFx.png" alt="image-20200826144001717" style="zoom: 33%;"></p>
</li>
<li><p>适用范围</p>
<p>当两个变量的标准差都不为零时，相关系数才有定义，皮尔逊相关系数适用于：</p>
<p>(1)、两个变量之间是线性关系，都是连续数据。</p>
<p>(2)、两个变量的总体是正态分布，或接近正态的单峰分布。</p>
<p>(3)、两个变量的观测值是成对的，每对观测值之间相互独立。</p>
</li>
<li><p>注意</p>
<p>公式的分母是变量的标准差，这就意味着计算pearson时，变量的标准差不能为0（分母不能为0），也就是说你的两个变量中任何一个的值不能都是相同的。如果没有变化，用pearson是没办法算出这个变量与另一个变量之间是不是有相关性的。</p>
<p>就好比我们想研究人跑步的速度与心脏跳动的相关性，如果你无论跑多快，心跳都不变（即心跳这个变量的标准差为0），或者你心跳忽快忽慢的，却一直保持一个速度在跑（即跑步速度这个变量的标准差为0），那我们都无法通过pearson的计算来判断心跳与跑步速度到底相不相关。</p>
</li>
<li><p>使用Pearson线性相关系数有2个局限：</p>
<ol>
<li>必须假设数据是成对地从正态分布中取得的。</li>
<li>数据至少在逻辑范围内是等距的。</li>
</ol>
</li>
</ul>
<h3 id="spearman"><a href="#spearman" class="headerlink" title="spearman"></a>spearman</h3><p><a href="https://statistics.laerd.com/statistical-guides/spearmans-rank-order-correlation-statistical-guide.php" target="_blank" rel="noopener">https://statistics.laerd.com/statistical-guides/spearmans-rank-order-correlation-statistical-guide.php</a></p>
<ul>
<li><p>代码实现</p>
<ul>
<li><p>对于一般情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result, _ = scipy.stats.spearmanr(array_1, array_2)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>对于离散整数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spearmanr</span><span class="params">(set_1, set_2)</span>:</span></span><br><span class="line"></span><br><span class="line">    ar = np.apply_along_axis(scipy.stats.rankdata, <span class="number">0</span>, set_1)</span><br><span class="line">    br = np.apply_along_axis(scipy.stats.rankdata, <span class="number">0</span>, set_2)</span><br><span class="line">    d = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ar)):</span><br><span class="line">        d.append(ar[i] - br[i])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    d_sq = [i ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> d]</span><br><span class="line">    sum_d_sq = sum(d_sq)</span><br><span class="line">    n_cu_min_n = len(set_1) ** <span class="number">3</span> - len(set_1)</span><br><span class="line">    r = <span class="number">1</span> - ((<span class="number">6.0</span> * sum_d_sq) / n_cu_min_n)</span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>计算公式</p>
<ul>
<li><p>存在 并列排序时：</p>
<p>先排序，对排序值 pair 计算 pearson 系数</p>
</li>
<li><p>不存在并列排序时，</p>
<p>先排序，计算d<sub>i</sub> 再按照下面第一个公式进行计算</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2020/08/26/ON5iLc2kl6EAM1p.png" alt="微信截图_20200826151113"></p>
<ul>
<li><p>另外一种说法</p>
<ul>
<li><p>一般情况：</p>
<p>先排序，对排序值 pair 计算 pearson 系数</p>
</li>
<li><p>对于数值为离散的整数时，</p>
<p>先排序，计算d<sub>i</sub> 再按照吐下的公式进行计算</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/08/26/z3iJWqUxRcBSegV.png" alt="微信截图_20200826151324"></p>
</li>
<li><p>适用范围</p>
<p>spearman 对数据条件的要求没有皮尔逊相关系数严格，只要两个变量的观测值是成对的等级评定资料，或者是由连续变量观测资料转化得到的等级资料，不论两个变量的总体分布形态、样本容量的大小如何，都可以用spearman 来进行研究</p>
</li>
</ul>
<h3 id="kendall"><a href="#kendall" class="headerlink" title="kendall"></a>kendall</h3><ul>
<li><p>代码实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scipy.stats.kendalltau(array_1, array_2)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Kendallta</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    Lens = len(a)</span><br><span class="line"></span><br><span class="line">    ties_onlyin_x = <span class="number">0</span></span><br><span class="line">    ties_onlyin_y = <span class="number">0</span></span><br><span class="line">    con_pair = <span class="number">0</span></span><br><span class="line">    dis_pair = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(Lens - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, Lens):</span><br><span class="line">            test_tying_x = np.sign(a[i] - a[j])</span><br><span class="line">            test_tying_y = np.sign(b[i] - b[j])</span><br><span class="line">            panduan = test_tying_x * test_tying_y</span><br><span class="line">            <span class="keyword">if</span> panduan == <span class="number">1</span>:</span><br><span class="line">                con_pair += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> panduan == <span class="number">-1</span>:</span><br><span class="line">                dis_pair += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> test_tying_y == <span class="number">0</span> <span class="keyword">and</span> test_tying_x != <span class="number">0</span>:</span><br><span class="line">                ties_onlyin_y += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> test_tying_x == <span class="number">0</span> <span class="keyword">and</span> test_tying_y != <span class="number">0</span>:</span><br><span class="line">                ties_onlyin_x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    result = (con_pair - dis_pair) / np.sqrt(</span><br><span class="line">        (con_pair + dis_pair + ties_onlyin_x) * (dis_pair + con_pair + ties_onlyin_y))</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算公式</p>
<p><a href="https://en.wikipedia.org/wiki/Kendall_rank_correlation_coefficient" target="_blank" rel="noopener">Kendall_rank_correlation_coefficient</a></p>
<p>有好几个计算公式</p>
</li>
<li><p>适用范围</p>
<p>kendall与spearman 对数据条件的要求相同，可参见<a href="http://blog.csdn.net/wsywl/archive/2010/09/02/5859751.aspx" target="_blank" rel="noopener">统计相关系数(2)—Spearman Rank(斯皮尔曼等级)相关系数及MATLAB实现</a>中介绍的spearman 对数据条件的要求。</p>
</li>
</ul>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul>
<li>这三种 相关系数，计算 array_1 与 array_2 之间的相关性，若array_1 或者 array_2 中的元素都相同（eg: array_1 = np.array([5,5,5,5,5])） 则会使得输出为NaN.</li>
</ul>
<p>三种方法的适用场合</p>
<h4 id="主要参数methods介绍"><a href="#主要参数methods介绍" class="headerlink" title="主要参数methods介绍:"></a>主要参数methods介绍:</h4><ol>
<li>pearson correlation coefficient（皮尔逊相关性系数）。<br> 常用的相关系数求法，采用协方差cov(X,Y)/标准差的乘积(σX, σY)。<br> 数据要求： 线性数据、连续且符合正态分布；数据间差异不能太大；变量准差不能为0，即两变量中任何一个值不能都是相同。</li>
<li>spearman correlation coefficient（斯皮尔曼秩相关性系数）。<br> 根据原始数据的排序位置进行计算。<br> 数据要求：用于解决称名数据和顺序数据相关的问题，适用于两列变量，而且具有等级变量性质具有线性关系的数据，能够很好处理序列中相同值和异常值。</li>
<li>kendall correlation coefficient（肯德尔相关性系数）。<br> 等级相关系数，适用于两个变量均为有序分类的情况<br> 数据要求：肯德尔相关性系数，它也是一种秩相关系数，不过它所计算的对象是分类变量。</li>
</ol>
<p>所以针对【连续、正态分布、线性】数据，采用pearson相关系数；针对【非线性的、非正态】数据，采用spearman相关系数；针对【分类变量、无序】数据，采用Kendall相关系数。一般来讲，线性数据采用pearson，否则选择spearman，如果是分类的则用kendall。</p>
<p>作者：王叽叽的小心情<br>链接：<a href="https://www.jianshu.com/p/f9304da68d98" target="_blank" rel="noopener">https://www.jianshu.com/p/f9304da68d98</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="相关系数和P-value-值"><a href="#相关系数和P-value-值" class="headerlink" title="相关系数和P-value 值"></a>相关系数和P-value 值</h3><p>看两者是否算相关要看两方面</p>
<p>显著水平以及相关系数</p>
<p>（1）显著水平,就是P值,这是首要的,因为如果不显著,相关系数再高也没用,可能只是因为偶然因素引起的,那么多少才算显著,一般p值小于0.05就是显著了；如果小于0.01就更显著；例如p值=0.001,就是很高的显著水平了,只要显著,就可以下结论说：拒绝原假设无关,两组数据显著相关也说两者间确实有明显关系.通常需要p值小于0.1,最好小于0.05甚至0.01,才可得出结论：两组数据有明显关系,如果p=0.5,远大于0.1,只能说明相关程度不明显甚至不相关.起码不是线性相关.</p>
<p>（2）相关系数,也就是pearson spearman等,通常也称为R值,在确认上面指标显著情况下,再来看这个指标,一般相关系数越高表明两者间关系越密切.R&gt;0 代表连个变量正相关,即一个变大另一个随之变大</p>
<h3 id="需要的数据量"><a href="#需要的数据量" class="headerlink" title="需要的数据量"></a>需要的数据量</h3><p><a href="https://bbs.pinggu.org/thread-3240378-1-1.html" target="_blank" rel="noopener">https://bbs.pinggu.org/thread-3240378-1-1.html</a></p>
]]></content>
      <tags>
        <tag>评价指标</tag>
      </tags>
  </entry>
  <entry>
    <title>faster r-cnn 解读</title>
    <url>/2019/03/24/faster-r-cnn-%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>来自<a href="https://mp.weixin.qq.com/s/M_i38L2brq69BYzmaPeJ9w" target="_blank" rel="noopener">机器之心</a><br>可能机器之心的那个链接无法转到，<a href="http://tech.ifeng.com/a/20180223/44884976_0.shtml" target="_blank" rel="noopener">看这个</a><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e0ltm2y7j30u0083wev.jpg"><br>by yaya:<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e10a6tguj31fj0mw0vw.jpg"></p>
<h2 id="RPN"><a href="#RPN" class="headerlink" title="RPN"></a>RPN</h2><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e0p68j95j30t80gaaar.jpg" style="zoom:60%"></p>
<p>anchor: 定义anchor的长: scale=[4,8,16], 长宽比: ratio=[0.5, 1, 1.5, 2]，则在each position of conv feature 将会有k=len(scale)×len(ratio)=12个anchor</p>
<p>(1)对于分类层，我们对每个锚点输出两个预测值：它是背景（不是目标）的分数，和它是前景（实际的目标）的分数.&lt;/br&gt;<br>则经过该1×1的卷积层，输出的shape=N×2k×H×W  &lt;/br&gt;</p>
<p>(2)对于回归或边框调整层，我们输出四个预测值(偏移值)：<font color="#0099ff" size="5" face="黑体">Δxcenter、Δycenter、Δwidth、Δheight</font>，我们将会把这些值用到锚点中来得到最终的建议：(x1, y1, x2, y2)分别为左下角和右上角的坐标，即area=(x2-x1)*(y2-y1).&lt;/br&gt;<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e0p66yxyj312w066t91.jpg"></p>
<p>(3) 补充，<font color="#0099ff" size="5" face="黑体">RoI Pooling</font>  得到 pooled feats，输入的是base feats, 得到的pred proposals 以及 <font color="#0099ff" size="5" face="黑体">1/scale</font><br>因为pred proposals得到的坐标是在<del>原始的image上的</del> 输入到网络中的image，而当前的base feats 是相对于原图有尺度变化的，为了对应.</p>
<h2 id="R-CNN"><a href="#R-CNN" class="headerlink" title="R-CNN"></a>R-CNN</h2><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e0p6ekybj30u00c175l.jpg"></p>
<p>有两个不同的目标：&lt;/br&gt;<br>(1) 将建议分到一个类中，加上一个背景类（用于删除不好的建议）。&lt;/br&gt;<br>(2) 根据预测的类别更好地调整建议的边框。&lt;/br&gt;<br>在最初的 Faster R-CNN 论文中，R-CNN 对每个建议采用特征图，将它平坦化并使用两个大小为 4096 的有 ReLU 激活函数的全连接层。然后，它对每个不同的目标使用两种不同的全连接层：&lt;/br&gt;<br>一个有 N+1 个单元的全连接层，其中 N 是类的总数，另外一个是背景类。&lt;/br&gt;<br>一个有 4N 个单元的全连接层。我们希望有一个回归预测，因此对 N 个类别中的每一个可能的类别，我们都需要 <font color="#0099ff" size="5" face="黑体">Δxcenter、Δycenter、Δwidth、Δheight</font>。&lt;/br&gt;<br>训练和目标&lt;/br&gt;<br>R-CNN 的目标与 RPN 的目标的计算方法几乎相同，但是考虑的是不同的可能类别。我们采用建议和真实边框，并计算它们之间的 IoU。&lt;/br&gt;</p>
<p>那些有任何真实边框的建议，只要其 IoU 大于 0.5，都被分配给那个真实数据。那些 IoU 在 0.1 和 0.5 之间的被标记为背景。与我们在为 RPN 分配目标时相反的是，我们忽略了没有任何交集的建议。这是因为在这个阶段，我们假设已经有好的建议并且我们对解决更困难的情况更有兴趣。当然，这些所有的值都是可以为了更好的拟合你想找的目标类型而做调整的超参数。&lt;/br&gt;</p>
<p>边框回归的目标是计算建议和与其对应的真实框之间的偏移量，仅针对那些基于 IoU 阈值分配了类别的建议。&lt;/br&gt;</p>
<p>我们随机抽样了一个尺寸为 64 的 balanced mini batch，其中我们有高达 25% 的前景建议（有类别）和 75% 的背景。&lt;/br&gt;</p>
<p>按照我们对 RPN 损失所做的相同处理方式，现在的分类损失是一个多类别的交叉熵损失，使用所有选定的建议和用于与真实框匹配的 25% 建议的 Smooth L1 loss。由于 R-CNN 边框回归的全连接网络的输出对于每个类都有一个预测，所以当我们得到这种损失时必须小心。在计算损失时，我们只需要考虑正确的类。&lt;/br&gt;<br>这里若假定类别可知，则每个类都有预测，若类别不可知，则仅有一个预测即可，代码如下：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e0p66uafj30nq03vt8o.jpg"></p>
]]></content>
      <categories>
        <category>目标检测</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>目标检测</tag>
      </tags>
  </entry>
  <entry>
    <title>glob.glob vs os.listdir</title>
    <url>/2019/04/05/glob-glob-vs-os-listdir/</url>
    <content><![CDATA[<ul>
<li>现在想要得到某个文件夹下的一些图片，并按照顺序排列，如下图所示：  </li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1rl9d9xq9j30ia0cbjri.jpg">  </p>
<ul>
<li>第一种方法：（得到的frames_list是不包含路径的）<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frames_list = sorted(os.listdir(video_path))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1rlb8uq8aj309h0a8q2z.jpg"></p>
<ul>
<li>第二种方法：（得到的frames_list包含路径的）<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frames_list = sorted(glob.glob(os.path.join(video_path, <span class="string">'*.jpg'</span>)))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1rlbroiqmj30nt0b40u9.jpg"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>os.listdir 仅可以得到对当前路径下文件名称，但是不包含路径信息<br>glob.glob 可以得到对当前路径下文件名称，并包含路径信息</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>glob 之 **</title>
    <url>/2019/08/13/glob-%E4%B9%8B/</url>
    <content><![CDATA[<ul>
<li>该篇主要介绍glob的一些使用小技巧</li>
</ul>
<h3 id="想要获得某个文件目录下所有-指定文件格式-的所有文件"><a href="#想要获得某个文件目录下所有-指定文件格式-的所有文件" class="headerlink" title="想要获得某个文件目录下所有 指定文件格式 的所有文件"></a>想要获得某个文件目录下所有 <strong><em>指定文件格式</em></strong> 的所有文件</h3><ul>
<li><p>假设有一个文件环境如下图所示</p>
<p><img src="https://i.loli.net/2019/08/14/sjTANPfDuV6cord.png" alt="搜狗截图20190814100532.png"></p>
</li>
</ul>
<ul>
<li><p>比如想要获得<code>/userhome/dataset/MSVD/YouTubeClips/YouTubeClips</code> 下 <code>.avi</code>格式的所有文件</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">path</span> = <span class="string">'/userhome/dataset/MSVD/YouTubeClips/YouTubeClips/'</span></span><br><span class="line">glob.glob(<span class="built_in">path</span> + <span class="string">'*.avi'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>想要获得某目录下的所有子目录中的所有指定文件格式的所有文件</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">path</span> = <span class="string">'/userhome/dataset/MSVD/YouTubeClips/'</span></span><br><span class="line">glob.glob(<span class="built_in">path</span> + <span class="string">'**/'</span> + <span class="string">'*.avi'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">path</span> = <span class="string">'/userhome/dataset/MSVD/'</span></span><br><span class="line">glob.glob(<span class="built_in">path</span> + <span class="string">'**/'</span> + <span class="string">'**/'</span> + <span class="string">'*.avi'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>GCN_LSTM  vs  SGAE</title>
    <url>/2019/07/30/gcn-on-captioning/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>faster_rcnn various box head</title>
    <url>/2019/07/22/faster-rcnn-various-box-head/</url>
    <content><![CDATA[<h4 id="Ground-video-description"><a href="#Ground-video-description" class="headerlink" title="Ground video description"></a>Ground video description</h4><ul>
<li>在阅读这篇论文的时候，由于作者提取了objects，说是提取的fc6的特征，但是不太懂是哪里，在issue中，他说是借鉴这里的代码，于是乎，我就来看了看<a href="https://github.com/facebookresearch/Detectron/blob/8170b25b425967f8f1c7d715bea3c5b8d9536cd8/detectron/modeling/fast_rcnn_heads.py" target="_blank" rel="noopener">box_head</a>，哈哈哈哈哈哈 </li>
<li>fc6 是 box_head里边的，box_head就是 类似于faster_rcnn中的_head_to_tail</li>
</ul>
<h4 id="那么box-head-是干嘛的？"><a href="#那么box-head-是干嘛的？" class="headerlink" title="那么box_head 是干嘛的？"></a>那么box_head 是干嘛的？</h4><ul>
<li>由于经过roi_pooling 之后得到的是 7*7的一个pooled_feats，还要 ==再进行池化或者拍平，或者再进行全连接层等== ，以便于后边的预测，分类任务。</li>
</ul>
<ul>
<li><p>faster_rcnn 中的box_head就是 resnet layer4</p>
</li>
<li><p>mmdetection 中的 faster_rcnn 现将7*7  排成49 ，再送入两个全连接层，可以将这两个全连接层命名为fc6, fc7.   完美!！!！</p>
</li>
<li><p>这里展示了各种各样的 box_head</p>
</li>
</ul>
]]></content>
      <categories>
        <category>目标检测</category>
      </categories>
      <tags>
        <tag>目标检测</tag>
      </tags>
  </entry>
  <entry>
    <title>(h-RNN)Video Paragraph Captioning Using Hierarchical Recurrent Neural Networks</title>
    <url>/2019/02/23/h-RNN-Video-Paragraph-Captioning-Using-Hierarchical-Recurrent-Neural-Networks/</url>
    <content><![CDATA[<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><ul>
<li>这篇文章主要针对于一个video 划分为多个interval，并分别对其进行caption这样的数据集。其中段落生成器的作用：可以捕捉句子之间的相互依赖关系，同时段落生成器的输出作为句子生成器的输入，可以使得<strong>下一个句子的生成是建立在当前句子的语境下生成的</strong>。</li>
<li>另外对于MSVD这种一个video直接由一个sentence来描述的数据集，段落生成器不起作用，只是在<strong>decoder的结构相较于其他的model有不同之处</strong>：video feature 不输入decoder 的 RNN，而是与RNN的hidden state 级联后输入Multimodal层，Multimodal( concatenate( hidden state，video feature ) )。</li>
</ul>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>提出了一个方法：<strong>利用分层RNN开解决视频描述</strong>。我们的分层框架包含一个句子生成器和一个段落生成器。<strong><em>句子生成器</em></strong>产生一个简短的句子，这个句子可以描述一个特定的短视频间隔。它利用时间和空间的注意力机制，有选择地将注意力集中在视觉元素上。<strong><em>段落生成器</em></strong>通过将句子生成器产生的句子嵌入与段落历史结合起来作为输入来捕获句子间的依赖关系，并段落生成器的parahraph state 将作为输出语句生成器的新初始状态，然后句子生成器再生成下一个句子，~ 循环</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul>
<li><strong>对当前方法的总结：</strong><br>当给出了从视频帧中提取的深度卷积特征序列(例如vggnet 和c3d)，则视频的特征可以用以下几种方法获取：<br>（1）平均池化[1, 2]<br>（2）加权平均池化（attention 机制）[3]<br>（3）RNN encoder 的最后一个输出[4, 5, 6]<br>当前基于序列学习的视频描述方法，只专注于为一个简短的视频剪辑生成一个句子。到目前为止，深层次学习方法还没有尝试为长视频生成多个句子或段落的问题。使用平均池化得到 video feature 的方法，只适用于 short video clips where there is only one major event，随后有了 recurrent encoder 和 attention model。<br>我们的方法也采用了attention 机制。但是我们的框架和他们的框架之间存在两个不同之处，1. 解释<strong>空间注意力</strong>：即对每个frames 提取object proposals 然后基于注意力机制对proposal features of one frames 进行加权求和来得到frames features。这对于数据集中 object 非常小且难定位的情况有很大的帮助。另外，也解释一下<strong>时域注意力</strong>：是指对features of frames 进行加权求和，从而得到 video feature。 <strong>本文的注意力机制</strong>：提取M帧，每帧K个object, 则对这M*K个 object 进行基于attention 系数的加权求和。2. 在加权视频特征和注意权重之后，我们不会在加权特征的基础上限制递归层的隐藏状态。 </li>
<li><strong>Motivation</strong><br>大多数视频描述的不仅仅是一个事件。只用一个简短的句子来描述一个语义丰富的视频通常会产生信息不多甚至无聊的结果。例如，一个video 应该描述成<strong>那个人把土豆切成片，把洋葱切成块，把洋葱和土豆放进锅里</strong>，但是只产生one sentence的方法可能会说<strong>这个人在做饭</strong>。</li>
<li><strong>Idea</strong><br>我们想要利用句子之间的时域依赖性，这样，在生成段落时，句子就不会独立地生成。相反，一个句子的生成可能会受到前几句所提供的语义上下文的影响。<br>我们的分层RNN结构包括两个生成器，一个句子生成器和一个段落生成器，这两个生成器都使用RNN layers<br>据我们所知，这是分层RNN在视频字幕任务中的首次应用。  </li>
</ul>
<h2 id="Hierarchical-RNN-for-Video-Captioning"><a href="#Hierarchical-RNN-for-Video-Captioning" class="headerlink" title="Hierarchical RNN for Video Captioning"></a>Hierarchical RNN for Video Captioning</h2><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0gmi1zayjj314o0h2n1f.jpg"><br><strong><em>designed by yaya:</em></strong><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0k7r1p5ygj316f0jyq47.jpg"><br>我们的方法：在句子生成器之上堆叠了一个段落生成器<br><strong>句子生成器</strong>：1) RNN 用来语言建模 2) 多模态层对多源信息进行聚合 3) 注意力模型</p>
<ul>
<li>RNN1：word embedding 作为RNN的输入，并更新 hidden state </li>
<li>Attention layer: RNN 的hidden state 作为attention layer 的输入，来计算weight:<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0gohii8woj30xx02saab.jpg" style="zoom:30%"><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0gom9zybsj30kg04mwes.jpg" style="zoom:45%"><br>假设视频中有M帧，每帧有K个objects，则features：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0go2kemkqj30bq01pt8m.jpg" style="zoom:50%"><br>若计算出了一组权重:<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0go382u2qj309m0250so.jpg" style="zoom:50%"><br>则 video feature：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0go5n8g7dj30if036mx8.jpg" style="zoom:30%"><br>得到的video feature是一个特征通道，完整的模型是两个特征通道，一个由 object appearance 生成，另一个由action 生成</li>
<li>Multimodal<br>输入：RNN 的hidden state <strong>concate</strong> 2个Attention 的输出（两个特征通道Ua  C3D，action feature；Uo aggregate object appearance）。既有语言，又有视觉，因此成为多模态。<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0gpaasqgmj30sb022dg0.jpg" style="zoom:50%"></li>
<li>Hidden layer<br>-输出维度512 与 word embdeding 的维度一致</li>
<li>Softmax layer<br>输出维度与vocabulary size 一致</li>
<li>Maxid layer<br>Maxid layer 在softmax layer 的输出中挑选了最大值所在的索引，该索引将会被作为predicted word 的id(对应到vocabulary 的 索引)</li>
<li>预测的单词将会作为句子生成器的下一个输入（test）；下一个输入单词总是由带注释的句子（ground truth/ reference）提供。</li>
</ul>
<p><strong>段落生成器</strong> : 另外一个RNN，来建模句子之间的相互依赖。输入：1.句子生成器的输出， 2. paragraph history  输出：该输出作为句子生成器的初始状态<br>使用的RNN为GRU</p>
<ul>
<li>Word Embedding<br>1) 对sentences中的所有单词的embedding 取平均，得到一个压缩embedding vector<br>2) 同时也接受RNN1 的最后一个hidden state 作为 压缩表达<br>将上面两个压缩表达concatenated </li>
<li>Sentences Embedding<br>将上面concatenated 的特征输入该层，得到512维度的输出</li>
<li>RNN2</li>
<li>Paragraph State layer<br>输入：结合RNN2的hidden state 和 sentence embedding<br>输出：作为RNN1下一个句子的初始状态，为句子生成器提供了段落历史是有必要的，以便在上下文语境中中生成下一句。<br>它实质上为句子生成器提供了段落历史，以便在上下文中生成下一句。</li>
</ul>
<h2 id="Training-and-Generation"><a href="#Training-and-Generation" class="headerlink" title="Training and Generation"></a>Training and Generation</h2><p><strong>整个网络的循环过程</strong></p>
<ul>
<li>当RNN1在每一时间步骤中不断更新其hidden state，RNN2只在处理完整句子时才更新其hidden state。</li>
<li>RNN1 由beam search 得到 J 个sequence cost 最低的句子，挑选出1个最低的，然后送入RNN2。RNN2又输出隐层状态，最为RNN1下一个句子的初始隐层状态。如此循环，直至， when the sentence received by the paragraph generator is the EOP (end-of-paragraph) which consists of only the BOS and the EOS。</li>
</ul>
<h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p><strong>数据集</strong><br>two benchmark datasets: YouTubeClips and TACoS-MultiLevel<br>YouTubeClips： 虽然每个video 有多个sentences进行描述，但是sentences是对这个video的整体描述，而不是分别对video进行分段描述。因此这个数据集作为我们方法的特例，paragraph length N=1.<br><strong>Encoder</strong></p>
<ul>
<li>由于YouTubeClips数据集中的object 十分显著，因此不进行提取object的操作，只对frame 提取特征，这样attention 只包括temporal attention ，而不包括 spatial attention。</li>
<li>对于TACoS-MultiLevel 数据集，首先使用光流大体的提取boundinig box，然后沿着bounding box 的边，提取220*220的image patches，保证相邻两个box 重合度为50%。使用VGG模型对每个patch提取特征，并使用attention的权重，对这些patches进行加权求和。此时，attention同时包括temporal 和 spatial。</li>
<li>C3D 提取 action/motion feature of video<br>C3D 模型：输入frames of video ，每16帧输出一个固定长度的特征向量。然后采用attention机制对C3D特征进行polling（加权求和）<br><strong>实验结果对比分析</strong></li>
<li>YouTubeClips<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0hdv8rde9j30i7099jtg.jpg"><br>相比于<strong>LSTM-E[2]</strong>（同样同时利用了VGG和C3D特征），我们的模型效果更好。<br>相比于<strong>SA[3]</strong>（同样利用了temporal attention）我们的方法更好，原因：RNN的输入不包括视频特征，换句话说， hidden state的更新不建立在video feature的基础上。video feature直接的输入到multimodal layer。</li>
<li>TACoS-MultiLevel<br>这里不做分析（可以自行参考论文）</li>
</ul>
<h2 id="Discussions-and-Limitations"><a href="#Discussions-and-Limitations" class="headerlink" title="Discussions and Limitations"></a>Discussions and Limitations</h2><ol>
<li>目前我们使用的目标检测方法很难处理small object，造成在生成句子时，极容易混淆，比如应该是orange ，却生成了mango</li>
<li>句子信息通过段落循环层单向流动，从段落开始到结尾，但也不是以相反的方式。如果第一个句子中含有错误信息，则会导致错误信息依次传递，目前使用双向RNN来生成句子，仍然是一个开放性的问题（yaya: sorry , i don’t kow what’s mean，可能是目前还不知道使用BiRNN来生成句子的效果是否好于单向RNN）。</li>
<li>与其他大多数图像/视频字幕方法一样，我们的方法存在一个已知的问题，即训练所使用的目标函数与生成方法所使用的目标函数之间存在差异。训练过程给定来自groundtruth的先前单词来预测下一个单词，而生成过程则对先前由其自身生成的单词进行预测。这个问题在我们的分层框架中更加放大，因为在训练时，段落生成器输入的是groundtruth，但是在测试阶段，输入的是句子生成器生成的句子。潜在的解决办法：</li>
</ol>
<ul>
<li>Scheduled Sampling<br>在训练过程中增加Scheduled Sampling，即随机的选择words of groundtruth或者由model生成的单词。</li>
<li>在训练的过程中直接优化metric(BLEU， CIDER, etc)</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <strong><em>Translating videos to natural language using deep recurrent neural networks</em></strong>. NACACL, 2015<br>[2] <strong><em>Jointly modeling embedding and translation to bridge video and language</em></strong>. CoRR,  2015<br>[3] <strong><em>Describing videos by exploiting temporal structure</em></strong>. ICCV, 2015<br>[4] <strong><em>Long-term recurrent convolutional networks for visual recognition and description</em></strong>. CVPR, 2015<br>[5] <strong><em>Sequence to sequence - video to text</em></strong>. ICCV, 2015<br>[6]  <strong><em>A multi-scale multiple instance video description network</em></strong>. CoRR, 2015</p>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/07/11/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>java 的编译与执行</title>
    <url>/2019/03/26/java/</url>
    <content><![CDATA[<h2 id="java-的编译与执行"><a href="#java-的编译与执行" class="headerlink" title="java 的编译与执行"></a>java 的编译与执行</h2><ol>
<li><p>用文本编辑器新建一个yumhtest.java文件，在其中输入以下代码并保存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">yumhtest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译：在shell终端执行命令 <strong>javac yumhtest.java</strong></p>
</li>
<li><p>运行：在shell终端执行命令 <strong>java yumhtest</strong><br>当shell下出现“hello world !”字样</p>
</li>
</ol>
<p>注意事项：类名应和文件名相同。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java</title>
    <url>/2019/03/26/java%20%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<h2 id="java-的编译与执行"><a href="#java-的编译与执行" class="headerlink" title="java 的编译与执行"></a>java 的编译与执行</h2><ol>
<li><p>用文本编辑器新建一个yumhtest.java文件，在其中输入以下代码并保存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">yumhtest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译：在shell终端执行命令 <strong>javac yumhtest.java</strong></p>
</li>
<li><p>运行：在shell终端执行命令 <strong>java yumhtest</strong><br>当shell下出现“hello world !”字样</p>
</li>
</ol>
<p>注意事项：类名应和文件名相同。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 文件名中有空格、括号 时如何操作</title>
    <url>/2019/08/14/linux-%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%AD%E6%9C%89%E7%A9%BA%E6%A0%BC%E3%80%81%E6%8B%AC%E5%8F%B7-%E6%97%B6%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="如何处理-cd-cp"><a href="#如何处理-cd-cp" class="headerlink" title="如何处理 cd cp"></a>如何处理 <code>cd</code> <code>cp</code></h3><ul>
<li><p>将文件名用<strong>双引号</strong> 包起来</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">cmd = 'cp -r <span class="string">"&#123;&#125;"</span> <span class="string">"&#123;&#125;"</span>'.format(source_path, target_path)</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-查看cpu状态</title>
    <url>/2019/03/13/linux-%E6%9F%A5%E7%9C%8Bcpu%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<ul>
<li>转载 “<a href="https://www.tianmaying.com/tutorial/cpu-top" target="_blank" rel="noopener">https://www.tianmaying.com/tutorial/cpu-top</a>“<br><code>top</code>命令是<code>Linux</code>下常用的性能分析工具，但本质上它提供了实时的对系统处理器的状态监视</li>
</ul>
<p>在命令行中输入<code>top</code>将输出一下信息：</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">top - 23:16:12 up  7:40, <span class="number"> 1 </span>user,  load average: 0.97, 0.98, 1.01</span><br><span class="line">Tasks:<span class="number"> 440 </span>total,  <span class="number"> 2 </span>running,<span class="number"> 438 </span>sleeping,  <span class="number"> 0 </span>stopped,  <span class="number"> 0 </span>zombie</span><br><span class="line">%Cpu(s):  1.3 us,  1.4 sy,  0.0 ni, 96.9 id,  0.0 wa,  0.0 hi,  0.4 si,  0.0 st</span><br><span class="line">KiB Mem : 13183891+total, 12378241+free, <span class="number"> 3884532 </span>used, <span class="number"> 4171956 </span>buff/cache</span><br><span class="line">KiB Swap:       <span class="number"> 0 </span>total,       <span class="number"> 0 </span>free,       <span class="number"> 0 </span>used. 12719112+avail Mem </span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                                               </span><br><span class="line">11746 jenkins  <span class="number"> 20 </span> <span class="number"> 0 </span><span class="number"> 159972 </span> <span class="number"> 4760 </span> <span class="number"> 1600 </span>R  99.7  0.0 362:41.65 root/2                                                                                                                </span><br><span class="line">  <span class="number"> 42 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   4.3  0.0  14:46.50 rcu_sched                                                                                                             </span><br><span class="line">  <span class="number"> 68 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   2.6  0.0   0:55.10 rcuos/25                                                                                                              </span><br><span class="line">11414 jenkins  <span class="number"> 20 </span> <span class="number"> 0 </span>42.134g 1.652g <span class="number"> 24516 </span>S   0.7  1.3   2:37.54 java                                                                                                                  </span><br><span class="line">  <span class="number"> 49 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.3  0.0   0:32.35 rcuos/6                                                                                                               </span><br><span class="line"><span class="number"> 6818 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.3  0.0   0:34.33 kworker/0:1                                                                                                           </span><br><span class="line">14702 root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.3  0.0   0:00.26 kworker/2:0                                                                                                           </span><br><span class="line">15491 txq      <span class="number"> 20 </span> <span class="number"> 0 </span><span class="number"> 158044 </span> <span class="number"> 2616 </span> <span class="number"> 1552 </span>R   0.3  0.0   0:00.13 top                                                                                                                   </span><br><span class="line">   <span class="number"> 1 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span> <span class="number"> 45892 </span> <span class="number"> 8580 </span> <span class="number"> 3908 </span>S   0.0  0.0   0:13.06 systemd                                                                                                               </span><br><span class="line">   <span class="number"> 2 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.06 kthreadd</span><br></pre></td></tr></table></figure>
<p>前五行是当前整个系统资源的统计信息。</p>
<p>第一行是任务队列，包括当前时间，系统运行的总时间，系统用户登陆的数量，以及1分钟，5分钟，15分钟系统的负载情况。</p>
<p>第二行是<code>Tasks</code>信息，显示当前系统总共的进程数为440，运行状态的进程有两个，438个处于休眠状态，0个停止，0个僵尸进程。</p>
<p>第三行是<code>CPU</code>信息，很多人可能会忽略这些信息，我之前就是，所以详细说一下。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">%<span class="selector-tag">Cpu</span>(<span class="selector-tag">s</span>):  1<span class="selector-class">.3</span> <span class="selector-tag">us</span>,  1<span class="selector-class">.4</span> <span class="selector-tag">sy</span>,  0<span class="selector-class">.0</span> <span class="selector-tag">ni</span>, 96<span class="selector-class">.9</span> <span class="selector-tag">id</span>,  0<span class="selector-class">.0</span> <span class="selector-tag">wa</span>,  0<span class="selector-class">.0</span> <span class="selector-tag">hi</span>,  0<span class="selector-class">.4</span> <span class="selector-tag">si</span>,  0<span class="selector-class">.0</span> <span class="selector-tag">st</span></span><br></pre></td></tr></table></figure>
<p><code>us</code> user CPU time ——用户空间占用<code>CPU</code>百分比</p>
<p><code>sy</code> system CPU time——内核空间占用<code>CPU</code>百分比</p>
<p><code>ni</code> nice CPU time——用户进程空间内改变过优先级的进程占用<code>CPU</code>百分比</p>
<p><code>id</code> idle——空闲<code>CPU</code>百分比</p>
<p><code>wa</code> iowait—— 等待输入输出的<code>CPU</code>时间百分比</p>
<p><code>hi</code> hardware irq——硬件中断</p>
<p><code>si</code> software irq——软件中断</p>
<p><code>st</code> steal time——实时</p>
<p>具体对应到第三行的详细信息，大家自己对照一下就行，或者在你命令行中试一下。</p>
<p>第四行<code>Memory</code>的状态信息，总共13183891+内存，空闲12378241+，使用3884532，缓存为4171956</p>
<p>第五行<code>Swap</code>交换分区信息，总共0，空闲0，使用0，缓存交换区总量12719112+</p>
<p>第六行是各个进程监视的项目列</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">PID   <span class="built_in"> USER </span>     PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+   COMMAND</span><br><span class="line">PID` — 进程`id</span><br></pre></td></tr></table></figure>
<p><code>USER</code> — 进程所有者</p>
<p><code>PR</code> — 进程优先级</p>
<p><code>NI</code> — nice值。负值表示高优先级，正值表示低优先级</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">VIRT` — 进程使用的虚拟内存总量。`VIRT=SWAP+RES</span><br><span class="line">RES` — 进程使用的、未被换出的物理内存大小。`RES=CODE+DATA</span><br></pre></td></tr></table></figure>
<p><code>SHR</code> — 共享内存大小</p>
<p><code>S</code>— 进程状态。<code>D</code>=不可中断的睡眠状态 <code>R</code>=运行 <code>S</code>=睡眠 <code>T</code>=跟踪/停止 <code>Z</code>=僵尸进程</p>
<p><code>%CPU</code> — 上次更新到现在的<code>CPU</code>时间占用百分比</p>
<p><code>%MEM</code> — 进程使用的物理内存百分比</p>
<p><code>TIME+</code> — 进程使用的<code>CPU</code>时间总计</p>
<p><code>COMMAND</code> — 进程名称（命令名/命令行）</p>
<p>对应的每个进程的信息，大家可以自己看一下。</p>
<p>如果你在命令行下再输入<code>1</code>，输出如下：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">top - <span class="number">23</span>:<span class="number">16</span>:<span class="number">12</span> <span class="keyword">up</span>  <span class="number">7</span>:<span class="number">40</span>,  <span class="number">1</span> user,  load average: <span class="number">0.97</span>, <span class="number">0.98</span>, <span class="number">1.01</span></span><br><span class="line">Task<span class="variable">s:</span> <span class="number">440</span> total,   <span class="number">2</span> running, <span class="number">438</span> sleeping,   <span class="number">0</span> stopped,   <span class="number">0</span> zombie</span><br><span class="line">%Cpu0  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu1  :  <span class="number">0.0</span> us,  <span class="number">0.3</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni, <span class="number">99.7</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu2  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu3  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu4  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu5  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu6  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu7  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu8  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu9  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu10 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu11 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu12 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu13 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu14 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu15 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu16 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu17 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu18 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu19 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu20 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu21 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu22 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu23 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu24 : <span class="number">44.2</span> us, <span class="number">43.9</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,  <span class="number">0.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>, <span class="number">12.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu25 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu26 :  <span class="number">0.3</span> us,  <span class="number">0.3</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni, <span class="number">99.3</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu27 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu28 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu29 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu30 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu31 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">KiB Mem : <span class="number">13183891</span>+total, <span class="number">12377862</span>+free,  <span class="number">3887628</span> used,  <span class="number">4172660</span> buff/cache</span><br><span class="line">KiB Swap:        <span class="number">0</span> total,        <span class="number">0</span> free,        <span class="number">0</span> used. <span class="number">12718814</span>+avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                                               </span><br><span class="line"><span class="number">11746</span> jenkins   <span class="number">20</span>   <span class="number">0</span>  <span class="number">159972</span>   <span class="number">4760</span>   <span class="number">1600</span> R <span class="number">100.0</span>  <span class="number">0.0</span> <span class="number">393</span>:<span class="number">16.94</span> root/<span class="number">2</span>                                                                                                                </span><br><span class="line">   <span class="number">42</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">2.7</span>  <span class="number">0.0</span>  <span class="number">15</span>:<span class="number">59.27</span> rcu_sched                                                                                                             </span><br><span class="line">   <span class="number">67</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">1.3</span>  <span class="number">0.0</span>   <span class="number">1</span>:<span class="number">03.60</span> rcuos/<span class="number">24</span></span><br></pre></td></tr></table></figure>
<p>输入<code>1</code>可以查看每个逻辑<code>CPU</code>的情况，如上总共有32个逻辑<code>CPU</code>；</p>
<p>其他命令：</p>
<p>输入<code>b</code>，显示高亮，<code>shift+&gt;</code>和<code>shift+&lt;</code>可以左右切换</p>
<p>输入<code>x</code>也是显示高亮，但没有<code>b</code>那么明显，同理<code>shift+&gt;</code>和<code>shift+&lt;</code>可以左右切换</p>
<p>直接输入<code>top -c</code>，会显示完整命令，输出如下：</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">top - 23:56:31 up  8:20, <span class="number"> 1 </span>user,  load average: 0.95, 0.97, 1.00</span><br><span class="line">Tasks:<span class="number"> 439 </span>total,  <span class="number"> 2 </span>running,<span class="number"> 437 </span>sleeping,  <span class="number"> 0 </span>stopped,  <span class="number"> 0 </span>zombie</span><br><span class="line">%Cpu(s):  1.4 us,  1.5 sy,  0.0 ni, 96.8 id,  0.0 wa,  0.0 hi,  0.4 si,  0.0 st</span><br><span class="line">KiB Mem : 13183891+total, 12377344+free, <span class="number"> 3892304 </span>used, <span class="number"> 4173168 </span>buff/cache</span><br><span class="line">KiB Swap:       <span class="number"> 0 </span>total,       <span class="number"> 0 </span>free,       <span class="number"> 0 </span>used. 12718340+avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                                               </span><br><span class="line">11746 jenkins  <span class="number"> 20 </span> <span class="number"> 0 </span><span class="number"> 159972 </span> <span class="number"> 4760 </span> <span class="number"> 1600 </span>R 100.0  0.0 402:57.42 root/2                                                                                                                </span><br><span class="line">  <span class="number"> 42 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   3.3  0.0  16:21.24 [rcu_sched]                                                                                                           </span><br><span class="line">  <span class="number"> 57 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.7  0.0   1:03.01 [rcuos/14]                                                                                                            </span><br><span class="line">  <span class="number"> 63 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.3  0.0   0:29.22 [rcuos/20]                                                                                                            </span><br><span class="line"><span class="number"> 7933 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.3  0.0   0:05.50 [kworker/20:0]                                                                                                        </span><br><span class="line">11414 jenkins  <span class="number"> 20 </span> <span class="number"> 0 </span>42.134g 1.661g <span class="number"> 24516 </span>S   0.3  1.3   2:47.29 /etc/alternatives/java -Dcom.sun.akuma.Daemon=daemonized -Djava.awt.headless=true -DJENKINS_HOME=/var/lib/jenkins -j+ </span><br><span class="line">14702 root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.3  0.0   0:01.48 [kworker/2:0]                                                                                                         </span><br><span class="line">15098 root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.3  0.0   0:01.37 [kworker/6:2]                                                                                                         </span><br><span class="line">18465 txq      <span class="number"> 20 </span> <span class="number"> 0 </span><span class="number"> 158088 </span> <span class="number"> 2720 </span> <span class="number"> 1640 </span>R   0.3  0.0   0:00.18 top -c                                                                                                                </span><br><span class="line">   <span class="number"> 1 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span> <span class="number"> 45892 </span> <span class="number"> 8580 </span> <span class="number"> 3908 </span>S   0.0  0.0   0:13.78 /usr/lib/systemd/systemd --switched-root --system --deserialize<span class="number"> 21 </span>                                                   </span><br><span class="line">   <span class="number"> 2 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.06 [kthreadd]                                                                                                            </span><br><span class="line">   <span class="number"> 3 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.34 [ksoftirqd/0]                                                                                                         </span><br><span class="line">   <span class="number"> 5 </span>root      <span class="number"> 0 </span>-20      <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.00 [kworker/0:0H]                                                                                                        </span><br><span class="line">   <span class="number"> 8 </span>root      rt  <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.35 [migration/0]                                                                                                         </span><br><span class="line">   <span class="number"> 9 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.00 [rcu_bh]                                                                                                              </span><br><span class="line">  <span class="number"> 10 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.00 [rcuob/0]                                                                                                             </span><br><span class="line">  <span class="number"> 11 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.00 [rcuob/1]</span><br></pre></td></tr></table></figure>
<p>输入<code>q</code>是退出，还有其他命令参数，用到的时候再说，今天先统计这几个。</p>
<p>版权声明</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>cpu</tag>
      </tags>
  </entry>
  <entry>
    <title>mmdetection的安装</title>
    <url>/2019/07/20/mmdetection%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul>
<li>选择镜像：py36-pytorch0.4.0-cu90-ctc （即，准备一个cuda9.0的环境）</li>
<li>note: 需要一个pytorch1.1.0（pytorch1.2测试不可以用，推荐使用1.1.0），后文有讲如何在anaconda下安装pytorch</li>
<li>进入容器，安装anaconda</li>
</ul>
<h3 id="按着Github-install的步骤进行安装如下："><a href="#按着Github-install的步骤进行安装如下：" class="headerlink" title="按着Github install的步骤进行安装如下："></a>按着<a href="https://github.com/open-mmlab/mmdetection/blob/master/INSTALL.md" target="_blank" rel="noopener">Github install</a>的步骤进行安装如下：</h3><ul>
<li>Create a conda virtual environment and activate it. Then install Cython.<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conda create -n open-mmlab python=<span class="number">3.7</span> -y</span><br><span class="line">source activate open-mmlab</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong> 以下的操作都是在进入open-mmlab环境之后进行的</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">conda <span class="keyword">install</span> cython</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 numpy</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> numpy</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>安装<a href="https://github.com/open-mmlab/mmcv" target="_blank" rel="noopener">mmcv</a> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install mmcv</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装pytorch<br>最好是离线下载，然后再安装，因为conda install 或者 pip install 可能连接不上（细节：pip install torch  就会出现下载链接，然后自己复制链接去网页下载即可），下载之后：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">pip</span> <span class="selector-tag">install</span> <span class="selector-tag">torch-1</span><span class="selector-class">.1</span><span class="selector-class">.0-cp37-cp37m-manylinux1_x86_64</span><span class="selector-class">.whl</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装opencv</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">conda <span class="keyword">install</span> -c menpo opencv</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>安装matplotlib<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> matplotlib</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>安装 terminaltables<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> terminaltables</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>安装 pip install pycocotools</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> pycocotools</span><br></pre></td></tr></table></figure>
</li>
<li><p>选择一个看的顺眼的位置：Clone the mmdetection repository.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/open-mmlab/mmdetection.git</span><br><span class="line">cd mmdetection</span><br></pre></td></tr></table></figure>
</li>
<li><p>Install mmdetection</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python setup.py develop</span><br></pre></td></tr></table></figure>
</li>
<li><p>大功告成</p>
</li>
</ul>
]]></content>
      <categories>
        <category>目标检测</category>
      </categories>
      <tags>
        <tag>目标检测</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-物理CPU和逻辑CPU</title>
    <url>/2019/03/13/linux-%E7%89%A9%E7%90%86CPU%E5%92%8C%E9%80%BB%E8%BE%91CPU/</url>
    <content><![CDATA[<p>通过cat /proc/cpuinfo 来查看CPU的信息</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/5262207-4e29a8e7da45169c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/837/format/webp" alt="img"></p>
<p>cpu.png</p>
<p>physical id 表示物理CPU的编号<br> CPU cores 表示每个物理CPU上的内核数<br> core id 表示每个内核的编号<br> processor 表示每个逻辑CPU的编号</p>
<p>逻辑CPU的总数=物理CPU的数量 <em> 每个物理CPU上的核数 </em> 超线程数<br> 如果 逻辑CPU的总数=物理CPU的数量 * 每个物理CPU上的核数 则表示超线程没开，否则表示超线程以开</p>
<p>作者：君子亮剑</p>
<p>链接：<a href="https://www.jianshu.com/p/ff8e8be262ac" target="_blank" rel="noopener">https://www.jianshu.com/p/ff8e8be262ac</a></p>
<p>来源：简书</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>nltk-tokenize</title>
    <url>/2019/02/28/nltk-tokenize/</url>
    <content><![CDATA[<p>转载：<a href="https://pythonprogramming.net/tokenizing-words-sentences-nltk-tutorial/" target="_blank" rel="noopener">https://pythonprogramming.net/tokenizing-words-sentences-nltk-tutorial/</a></p>
<p>Next, you’re going to need NLTK 3. The easiest method to installing the NLTK module is going to be with pip.</p>
<p>For all users, that is done by opening up cmd.exe, bash, or whatever shell you use and typing:<br><code>pip install nltk</code></p>
<p>These are the words you will most commonly hear upon entering the Natural Language Processing (NLP) space, but there are many more that we will be covering in time. With that, let’s show an example of how one might actually tokenize something into tokens with the NLTK module.</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">from nltk<span class="selector-class">.tokenize</span> import sent_tokenize, word_tokenize</span><br><span class="line"></span><br><span class="line">EXAMPLE_TEXT = <span class="string">"Hello Mr. Smith, how are you doing today? The weather is great, and Python is awesome. The sky is pinkish-blue. You shouldn't eat cardboard."</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(sent_tokenize(EXAMPLE_TEXT)</span></span>)</span><br></pre></td></tr></table></figure>
<p>At first, you may think tokenizing by things like words or sentences is a rather trivial enterprise. For many sentences it can be. The first step would be likely doing a simple .split(‘. ‘), or splitting by period followed by a space. Then maybe you would bring in some <a href="https://pythonprogramming.net/regular-expressions-regex-tutorial-python-3/" target="_blank" rel="noopener"><strong>regular expressions</strong></a> to split by period, space, and then a capital letter. The problem is that things like Mr. Smith would cause you trouble, and many other things. Splitting by word is also a challenge, especially when considering things like concatenations like we and are to we’re. NLTK is going to go ahead and just save you a ton of time with this seemingly simple, yet very complex, operation.</p>
<p>The above code will output the sentences, split up into a list of sentences, which you can do things like iterate through with a <a href="https://pythonprogramming.net/loop-python-3-basics-tutorial/" target="_blank" rel="noopener"><strong>for loop</strong></a>.<br><code>[&#39;Hello Mr. Smith, how are you doing today?&#39;, &#39;The weather is great, and Python is awesome.&#39;, &#39;The sky is pinkish-blue.&#39;, &quot;You shouldn&#39;t eat cardboard.&quot;]</code></p>
<p>So there, we have created tokens, which are sentences. Let’s tokenize by word instead this time:</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">print(<span class="name">word_tokenize</span>(<span class="name">EXAMPLE_TEXT</span>))</span><br></pre></td></tr></table></figure>
<p>Now our output is: <code>[&#39;Hello&#39;, &#39;Mr.&#39;, &#39;Smith&#39;, &#39;,&#39;, &#39;how&#39;, &#39;are&#39;, &#39;you&#39;, &#39;doing&#39;, &#39;today&#39;, &#39;?&#39;, &#39;The&#39;, &#39;weather&#39;, &#39;is&#39;, &#39;great&#39;, &#39;,&#39;, &#39;and&#39;, &#39;Python&#39;, &#39;is&#39;, &#39;awesome&#39;, &#39;.&#39;, &#39;The&#39;, &#39;sky&#39;, &#39;is&#39;, &#39;pinkish-blue&#39;, &#39;.&#39;, &#39;You&#39;, &#39;should&#39;, &quot;n&#39;t&quot;, &#39;eat&#39;, &#39;cardboard&#39;, &#39;.&#39;]</code></p>
<p>There are a few things to note here. First, notice that punctuation is treated as a separate token. Also, notice the separation of the word “shouldn’t” into “should” and “n’t.” Finally, notice that “pinkish-blue” is indeed treated like the “one word” it was meant to be turned into. Pretty cool!</p>
]]></content>
  </entry>
  <entry>
    <title>mmdetection的configs中的各项参数具体解释</title>
    <url>/2019/07/21/mmdetection%E7%9A%84configs%E4%B8%AD%E7%9A%84%E5%90%84%E9%A1%B9%E5%8F%82%E6%95%B0%E5%85%B7%E4%BD%93%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<p>一、简介<br>在使用mmdetection对模型进行调优的过程中总会遇到很多参数的问题，不知道参数在代码中是什么作用，会对训练产生怎样的影响，这里我以faster_rcnn_r50_fpn_1x.py和cascade_rcnn_r50_fpn_1x.py为例，简单介绍一下mmdetection中的各项参数含义</p>
<p>二、faster_rcnn_r50_fpn_1x.py配置文件<br>首先介绍一下这个配置文件所描述的框架，它是基于resnet50的backbone，有着5个fpn特征层的faster-RCNN目标检测网络，训练迭代次数为标准的12次epoch，下面逐条解释其含义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># model settings</span></span><br><span class="line">model = dict(</span><br><span class="line">	type=<span class="string">'FasterRCNN'</span>,                         <span class="comment"># model类型</span></span><br><span class="line">    pretrained=<span class="string">'modelzoo://resnet50'</span>,          <span class="comment"># 预训练模型：imagenet-resnet50</span></span><br><span class="line">    backbone=dict(</span><br><span class="line">        type=<span class="string">'ResNet'</span>,                         <span class="comment"># backbone类型</span></span><br><span class="line">        depth=<span class="number">50</span>,                              <span class="comment"># 网络层数</span></span><br><span class="line">        num_stages=<span class="number">4</span>,                          <span class="comment"># resnet的stage数量</span></span><br><span class="line">        out_indices=(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),              <span class="comment"># 输出的stage的序号</span></span><br><span class="line">        frozen_stages=<span class="number">1</span>,                       <span class="comment"># 冻结的stage数量，即该stage不更新参数，-1表示所有的stage都更新参数</span></span><br><span class="line">        style=<span class="string">'pytorch'</span>),                      <span class="comment"># 网络风格：如果设置pytorch，则stride为2的层是conv3x3的卷积层；如果设置caffe，则stride为2的层是第一个conv1x1的卷积层</span></span><br><span class="line">    neck=dict(</span><br><span class="line">        type=<span class="string">'FPN'</span>,                            <span class="comment"># neck类型</span></span><br><span class="line">        in_channels=[<span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>, <span class="number">2048</span>],    <span class="comment"># 输入的各个stage的通道数</span></span><br><span class="line">        out_channels=<span class="number">256</span>,                      <span class="comment"># 输出的特征层的通道数</span></span><br><span class="line">        num_outs=<span class="number">5</span>),                           <span class="comment"># 输出的特征层的数量</span></span><br><span class="line">    rpn_head=dict(</span><br><span class="line">        type=<span class="string">'RPNHead'</span>,                        <span class="comment"># RPN网络类型</span></span><br><span class="line">        in_channels=<span class="number">256</span>,                       <span class="comment"># RPN网络的输入通道数</span></span><br><span class="line">        feat_channels=<span class="number">256</span>,                     <span class="comment"># 特征层的通道数</span></span><br><span class="line">        anchor_scales=[<span class="number">8</span>],                     <span class="comment"># 生成的anchor的baselen，baselen = sqrt(w*h)，w和h为anchor的宽和高</span></span><br><span class="line">        anchor_ratios=[<span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">2.0</span>],         <span class="comment"># anchor的宽高比</span></span><br><span class="line">        anchor_strides=[<span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>],     <span class="comment"># 在每个特征层上的anchor的步长（对应于原图）</span></span><br><span class="line">        target_means=[<span class="number">.0</span>, <span class="number">.0</span>, <span class="number">.0</span>, <span class="number">.0</span>],         <span class="comment"># 均值</span></span><br><span class="line">        target_stds=[<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>],      <span class="comment"># 方差</span></span><br><span class="line">        use_sigmoid_cls=<span class="literal">True</span>),                 <span class="comment"># 是否使用sigmoid来进行分类，如果False则使用softmax来分类</span></span><br><span class="line">    bbox_roi_extractor=dict(</span><br><span class="line">        type=<span class="string">'SingleRoIExtractor'</span>,                                   <span class="comment"># RoIExtractor类型</span></span><br><span class="line">        roi_layer=dict(type=<span class="string">'RoIAlign'</span>, out_size=<span class="number">7</span>, sample_num=<span class="number">2</span>),   <span class="comment"># ROI具体参数：ROI类型为ROIalign，输出尺寸为7，sample数为2</span></span><br><span class="line">        out_channels=<span class="number">256</span>,                                            <span class="comment"># 输出通道数</span></span><br><span class="line">        featmap_strides=[<span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>]),                             <span class="comment"># 特征图的步长</span></span><br><span class="line">    bbox_head=dict(</span><br><span class="line">        type=<span class="string">'SharedFCBBoxHead'</span>,                     <span class="comment"># 全连接层类型</span></span><br><span class="line">        num_fcs=<span class="number">2</span>,                                   <span class="comment"># 全连接层数量</span></span><br><span class="line">        in_channels=<span class="number">256</span>,                             <span class="comment"># 输入通道数</span></span><br><span class="line">        fc_out_channels=<span class="number">1024</span>,                        <span class="comment"># 输出通道数</span></span><br><span class="line">        roi_feat_size=<span class="number">7</span>,                             <span class="comment"># ROI特征层尺寸</span></span><br><span class="line">        num_classes=<span class="number">81</span>,                              <span class="comment"># 分类器的类别数量+1，+1是因为多了一个背景的类别</span></span><br><span class="line">        target_means=[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],               <span class="comment"># 均值</span></span><br><span class="line">        target_stds=[<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.2</span>],            <span class="comment"># 方差</span></span><br><span class="line">        reg_class_agnostic=<span class="literal">False</span>))                   <span class="comment"># 是否采用class_agnostic的方式来预测，class_agnostic表示输出bbox时只考虑其是否为前景，后续分类的时候再根据该bbox在网络中的类别得分来分类，也就是说一个框可以对应多个类别</span></span><br><span class="line"><span class="comment"># model training and testing settings</span></span><br><span class="line">train_cfg = dict(</span><br><span class="line">    rpn=dict(</span><br><span class="line">        assigner=dict(</span><br><span class="line">            type=<span class="string">'MaxIoUAssigner'</span>,            <span class="comment"># RPN网络的正负样本划分</span></span><br><span class="line">            pos_iou_thr=<span class="number">0.7</span>,                  <span class="comment"># 正样本的iou阈值</span></span><br><span class="line">            neg_iou_thr=<span class="number">0.3</span>,                  <span class="comment"># 负样本的iou阈值</span></span><br><span class="line">            min_pos_iou=<span class="number">0.3</span>,                  <span class="comment"># 正样本的iou最小值。如果assign给ground truth的anchors中最大的IOU低于0.3，则忽略所有的anchors，否则保留最大IOU的anchor</span></span><br><span class="line">            ignore_iof_thr=<span class="number">-1</span>),               <span class="comment"># 忽略bbox的阈值，当ground truth中包含需要忽略的bbox时使用，-1表示不忽略</span></span><br><span class="line">        sampler=dict(</span><br><span class="line">            type=<span class="string">'RandomSampler'</span>,             <span class="comment"># 正负样本提取器类型</span></span><br><span class="line">            num=<span class="number">256</span>,                          <span class="comment"># 需提取的正负样本数量</span></span><br><span class="line">            pos_fraction=<span class="number">0.5</span>,                 <span class="comment"># 正样本比例</span></span><br><span class="line">            neg_pos_ub=<span class="number">-1</span>,                    <span class="comment"># 最大负样本比例，大于该比例的负样本忽略，-1表示不忽略</span></span><br><span class="line">            add_gt_as_proposals=<span class="literal">False</span>),       <span class="comment"># 把ground truth加入proposal作为正样本</span></span><br><span class="line">        allowed_border=<span class="number">0</span>,                     <span class="comment"># 允许在bbox周围外扩一定的像素</span></span><br><span class="line">        pos_weight=<span class="number">-1</span>,                        <span class="comment"># 正样本权重，-1表示不改变原始的权重</span></span><br><span class="line">        smoothl1_beta=<span class="number">1</span> / <span class="number">9.0</span>,                <span class="comment"># 平滑L1系数</span></span><br><span class="line">        debug=<span class="literal">False</span>),                         <span class="comment"># debug模式</span></span><br><span class="line">    rcnn=dict(</span><br><span class="line">        assigner=dict(</span><br><span class="line">            type=<span class="string">'MaxIoUAssigner'</span>,            <span class="comment"># RCNN网络正负样本划分</span></span><br><span class="line">            pos_iou_thr=<span class="number">0.5</span>,                  <span class="comment"># 正样本的iou阈值</span></span><br><span class="line">            neg_iou_thr=<span class="number">0.5</span>,                  <span class="comment"># 负样本的iou阈值</span></span><br><span class="line">            min_pos_iou=<span class="number">0.5</span>,                  <span class="comment"># 正样本的iou最小值。如果assign给ground truth的anchors中最大的IOU低于0.3，则忽略所有的anchors，否则保留最大IOU的anchor</span></span><br><span class="line">            ignore_iof_thr=<span class="number">-1</span>),               <span class="comment"># 忽略bbox的阈值，当ground truth中包含需要忽略的bbox时使用，-1表示不忽略</span></span><br><span class="line">        sampler=dict(</span><br><span class="line">            type=<span class="string">'RandomSampler'</span>,             <span class="comment"># 正负样本提取器类型</span></span><br><span class="line">            num=<span class="number">512</span>,                          <span class="comment"># 需提取的正负样本数量</span></span><br><span class="line">            pos_fraction=<span class="number">0.25</span>,                <span class="comment"># 正样本比例</span></span><br><span class="line">            neg_pos_ub=<span class="number">-1</span>,                    <span class="comment"># 最大负样本比例，大于该比例的负样本忽略，-1表示不忽略</span></span><br><span class="line">            add_gt_as_proposals=<span class="literal">True</span>),        <span class="comment"># 把ground truth加入proposal作为正样本</span></span><br><span class="line">        pos_weight=<span class="number">-1</span>,                        <span class="comment"># 正样本权重，-1表示不改变原始的权重</span></span><br><span class="line">        debug=<span class="literal">False</span>))                         <span class="comment"># debug模式</span></span><br><span class="line">test_cfg = dict(</span><br><span class="line">    rpn=dict(                                 <span class="comment"># 推断时的RPN参数</span></span><br><span class="line">        nms_across_levels=<span class="literal">False</span>,              <span class="comment"># 在所有的fpn层内做nms</span></span><br><span class="line">        nms_pre=<span class="number">2000</span>,                         <span class="comment"># 在nms之前保留的的得分最高的proposal数量</span></span><br><span class="line">        nms_post=<span class="number">2000</span>,                        <span class="comment"># 在nms之后保留的的得分最高的proposal数量</span></span><br><span class="line">        max_num=<span class="number">2000</span>,                         <span class="comment"># 在后处理完成之后保留的proposal数量</span></span><br><span class="line">        nms_thr=<span class="number">0.7</span>,                          <span class="comment"># nms阈值</span></span><br><span class="line">        min_bbox_size=<span class="number">0</span>),                     <span class="comment"># 最小bbox尺寸</span></span><br><span class="line">    rcnn=dict(</span><br><span class="line">        score_thr=<span class="number">0.05</span>, nms=dict(type=<span class="string">'nms'</span>, iou_thr=<span class="number">0.5</span>), max_per_img=<span class="number">100</span>)   <span class="comment"># max_per_img表示最终输出的det bbox数量</span></span><br><span class="line">    <span class="comment"># soft-nms is also supported for rcnn testing</span></span><br><span class="line">    <span class="comment"># e.g., nms=dict(type='soft_nms', iou_thr=0.5, min_score=0.05)            # soft_nms参数</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># dataset settings</span></span><br><span class="line">dataset_type = <span class="string">'CocoDataset'</span>                <span class="comment"># 数据集类型</span></span><br><span class="line">data_root = <span class="string">'data/coco/'</span>                    <span class="comment"># 数据集根目录</span></span><br><span class="line">img_norm_cfg = dict(</span><br><span class="line">    mean=[<span class="number">123.675</span>, <span class="number">116.28</span>, <span class="number">103.53</span>], std=[<span class="number">58.395</span>, <span class="number">57.12</span>, <span class="number">57.375</span>], to_rgb=<span class="literal">True</span>)   <span class="comment"># 输入图像初始化，减去均值mean并处以方差std，to_rgb表示将bgr转为rgb</span></span><br><span class="line">data = dict(</span><br><span class="line">    imgs_per_gpu=<span class="number">2</span>,                <span class="comment"># 每个gpu计算的图像数量</span></span><br><span class="line">    workers_per_gpu=<span class="number">2</span>,             <span class="comment"># 每个gpu分配的线程数</span></span><br><span class="line">    train=dict(</span><br><span class="line">        type=dataset_type,                                                 <span class="comment"># 数据集类型</span></span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/instances_train2017.json'</span>,       <span class="comment"># 数据集annotation路径</span></span><br><span class="line">        img_prefix=data_root + <span class="string">'train2017/'</span>,                               <span class="comment"># 数据集的图片路径</span></span><br><span class="line">        img_scale=(<span class="number">1333</span>, <span class="number">800</span>),                                             <span class="comment"># 输入图像尺寸，最大边1333，最小边800</span></span><br><span class="line">        img_norm_cfg=img_norm_cfg,                                         <span class="comment"># 图像初始化参数</span></span><br><span class="line">        size_divisor=<span class="number">32</span>,                                                   <span class="comment"># 对图像进行resize时的最小单位，32表示所有的图像都会被resize成32的倍数</span></span><br><span class="line">        flip_ratio=<span class="number">0.5</span>,                                                    <span class="comment"># 图像的随机左右翻转的概率</span></span><br><span class="line">        with_mask=<span class="literal">False</span>,                                                   <span class="comment"># 训练时附带mask</span></span><br><span class="line">        with_crowd=<span class="literal">True</span>,                                                   <span class="comment"># 训练时附带difficult的样本</span></span><br><span class="line">        with_label=<span class="literal">True</span>),                                                  <span class="comment"># 训练时附带label</span></span><br><span class="line">    val=dict(</span><br><span class="line">        type=dataset_type,                                                 <span class="comment"># 同上</span></span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/instances_val2017.json'</span>,         <span class="comment"># 同上</span></span><br><span class="line">        img_prefix=data_root + <span class="string">'val2017/'</span>,                                 <span class="comment"># 同上</span></span><br><span class="line">        img_scale=(<span class="number">1333</span>, <span class="number">800</span>),                                             <span class="comment"># 同上</span></span><br><span class="line">        img_norm_cfg=img_norm_cfg,                                         <span class="comment"># 同上</span></span><br><span class="line">        size_divisor=<span class="number">32</span>,                                                   <span class="comment"># 同上</span></span><br><span class="line">        flip_ratio=<span class="number">0</span>,                                                      <span class="comment"># 同上</span></span><br><span class="line">        with_mask=<span class="literal">False</span>,                                                   <span class="comment"># 同上</span></span><br><span class="line">        with_crowd=<span class="literal">True</span>,                                                   <span class="comment"># 同上</span></span><br><span class="line">        with_label=<span class="literal">True</span>),                                                  <span class="comment"># 同上</span></span><br><span class="line">    test=dict(</span><br><span class="line">        type=dataset_type,                                                 <span class="comment"># 同上</span></span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/instances_val2017.json'</span>,         <span class="comment"># 同上</span></span><br><span class="line">        img_prefix=data_root + <span class="string">'val2017/'</span>,                                 <span class="comment"># 同上</span></span><br><span class="line">        img_scale=(<span class="number">1333</span>, <span class="number">800</span>),                                             <span class="comment"># 同上</span></span><br><span class="line">        img_norm_cfg=img_norm_cfg,                                         <span class="comment"># 同上</span></span><br><span class="line">        size_divisor=<span class="number">32</span>,                                                   <span class="comment"># 同上</span></span><br><span class="line">        flip_ratio=<span class="number">0</span>,                                                      <span class="comment"># 同上</span></span><br><span class="line">        with_mask=<span class="literal">False</span>,                                                   <span class="comment"># 同上</span></span><br><span class="line">        with_label=<span class="literal">False</span>,                                                  <span class="comment"># 同上</span></span><br><span class="line">        test_mode=<span class="literal">True</span>))                                                   <span class="comment"># 同上</span></span><br><span class="line"><span class="comment"># optimizer</span></span><br><span class="line">optimizer = dict(type=<span class="string">'SGD'</span>, lr=<span class="number">0.02</span>, momentum=<span class="number">0.9</span>, weight_decay=<span class="number">0.0001</span>)   <span class="comment"># 优化参数，lr为学习率，momentum为动量因子，weight_decay为权重衰减因子</span></span><br><span class="line">optimizer_config = dict(grad_clip=dict(max_norm=<span class="number">35</span>, norm_type=<span class="number">2</span>))          <span class="comment"># 梯度均衡参数</span></span><br><span class="line"><span class="comment"># learning policy</span></span><br><span class="line">lr_config = dict(</span><br><span class="line">    policy=<span class="string">'step'</span>,                        <span class="comment"># 优化策略</span></span><br><span class="line">    warmup=<span class="string">'linear'</span>,                      <span class="comment"># 初始的学习率增加的策略，linear为线性增加</span></span><br><span class="line">    warmup_iters=<span class="number">500</span>,                     <span class="comment"># 在初始的500次迭代中学习率逐渐增加</span></span><br><span class="line">    warmup_ratio=<span class="number">1.0</span> / <span class="number">3</span>,                 <span class="comment"># 起始的学习率</span></span><br><span class="line">    step=[<span class="number">8</span>, <span class="number">11</span>])                         <span class="comment"># 在第8和11个epoch时降低学习率</span></span><br><span class="line">checkpoint_config = dict(interval=<span class="number">1</span>)      <span class="comment"># 每1个epoch存储一次模型</span></span><br><span class="line"><span class="comment"># yapf:disable</span></span><br><span class="line">log_config = dict(</span><br><span class="line">    interval=<span class="number">50</span>,                          <span class="comment"># 每50个batch输出一次信息</span></span><br><span class="line">    hooks=[</span><br><span class="line">        dict(type=<span class="string">'TextLoggerHook'</span>),      <span class="comment"># 控制台输出信息的风格</span></span><br><span class="line">        <span class="comment"># dict(type='TensorboardLoggerHook')</span></span><br><span class="line">    ])</span><br><span class="line"><span class="comment"># yapf:enable</span></span><br><span class="line"><span class="comment"># runtime settings</span></span><br><span class="line">total_epochs = <span class="number">12</span>                               <span class="comment"># 最大epoch数</span></span><br><span class="line">dist_params = dict(backend=<span class="string">'nccl'</span>)              <span class="comment"># 分布式参数</span></span><br><span class="line">log_level = <span class="string">'INFO'</span>                              <span class="comment"># 输出信息的完整度级别</span></span><br><span class="line">work_dir = <span class="string">'./work_dirs/faster_rcnn_r50_fpn_1x'</span> <span class="comment"># log文件和模型文件存储路径</span></span><br><span class="line">load_from = <span class="literal">None</span>                                <span class="comment"># 加载模型的路径，None表示从预训练模型加载</span></span><br><span class="line">resume_from = <span class="literal">None</span>                              <span class="comment"># 恢复训练模型的路径</span></span><br><span class="line">workflow = [(<span class="string">'train'</span>, <span class="number">1</span>)]                       <span class="comment"># 当前工作区名称</span></span><br></pre></td></tr></table></figure>
<p> 三、cascade_rcnn_r50_fpn_1x.py配置文件<br>cascade-RCNN是cvpr2018的文章，相比于faster-RCNN的改进主要在于其RCNN有三个stage，这三个stage逐级refine检测的结果，使得结果达到更高的精度。下面逐条解释其config的含义，与faster-RCNN相同的部分就不再赘述。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># model settings</span></span><br><span class="line">model = dict(</span><br><span class="line">    type=<span class="string">'CascadeRCNN'</span>,</span><br><span class="line">    num_stages=<span class="number">3</span>,                     <span class="comment"># RCNN网络的stage数量，在faster-RCNN中为1</span></span><br><span class="line">    pretrained=<span class="string">'modelzoo://resnet50'</span>,</span><br><span class="line">    backbone=dict(</span><br><span class="line">        type=<span class="string">'ResNet'</span>,</span><br><span class="line">        depth=<span class="number">50</span>,</span><br><span class="line">        num_stages=<span class="number">4</span>,</span><br><span class="line">        out_indices=(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">        frozen_stages=<span class="number">1</span>,</span><br><span class="line">        style=<span class="string">'pytorch'</span>),</span><br><span class="line">    neck=dict(</span><br><span class="line">        type=<span class="string">'FPN'</span>,</span><br><span class="line">        in_channels=[<span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>, <span class="number">2048</span>],</span><br><span class="line">        out_channels=<span class="number">256</span>,</span><br><span class="line">        num_outs=<span class="number">5</span>),</span><br><span class="line">    rpn_head=dict(</span><br><span class="line">        type=<span class="string">'RPNHead'</span>,</span><br><span class="line">        in_channels=<span class="number">256</span>,</span><br><span class="line">        feat_channels=<span class="number">256</span>,</span><br><span class="line">        anchor_scales=[<span class="number">8</span>],</span><br><span class="line">        anchor_ratios=[<span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">2.0</span>],</span><br><span class="line">        anchor_strides=[<span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>],</span><br><span class="line">        target_means=[<span class="number">.0</span>, <span class="number">.0</span>, <span class="number">.0</span>, <span class="number">.0</span>],</span><br><span class="line">        target_stds=[<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>],</span><br><span class="line">        use_sigmoid_cls=<span class="literal">True</span>),</span><br><span class="line">    bbox_roi_extractor=dict(</span><br><span class="line">        type=<span class="string">'SingleRoIExtractor'</span>,</span><br><span class="line">        roi_layer=dict(type=<span class="string">'RoIAlign'</span>, out_size=<span class="number">7</span>, sample_num=<span class="number">2</span>),</span><br><span class="line">        out_channels=<span class="number">256</span>,</span><br><span class="line">        featmap_strides=[<span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>]),</span><br><span class="line">    bbox_head=[</span><br><span class="line">        dict(</span><br><span class="line">            type=<span class="string">'SharedFCBBoxHead'</span>,</span><br><span class="line">            num_fcs=<span class="number">2</span>,</span><br><span class="line">            in_channels=<span class="number">256</span>,</span><br><span class="line">            fc_out_channels=<span class="number">1024</span>,</span><br><span class="line">            roi_feat_size=<span class="number">7</span>,</span><br><span class="line">            num_classes=<span class="number">81</span>,</span><br><span class="line">            target_means=[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">            target_stds=[<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.2</span>],</span><br><span class="line">            reg_class_agnostic=<span class="literal">True</span>),</span><br><span class="line">        dict(</span><br><span class="line">            type=<span class="string">'SharedFCBBoxHead'</span>,</span><br><span class="line">            num_fcs=<span class="number">2</span>,</span><br><span class="line">            in_channels=<span class="number">256</span>,</span><br><span class="line">            fc_out_channels=<span class="number">1024</span>,</span><br><span class="line">            roi_feat_size=<span class="number">7</span>,</span><br><span class="line">            num_classes=<span class="number">81</span>,</span><br><span class="line">            target_means=[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">            target_stds=[<span class="number">0.05</span>, <span class="number">0.05</span>, <span class="number">0.1</span>, <span class="number">0.1</span>],</span><br><span class="line">            reg_class_agnostic=<span class="literal">True</span>),</span><br><span class="line">        dict(</span><br><span class="line">            type=<span class="string">'SharedFCBBoxHead'</span>,</span><br><span class="line">            num_fcs=<span class="number">2</span>,</span><br><span class="line">            in_channels=<span class="number">256</span>,</span><br><span class="line">            fc_out_channels=<span class="number">1024</span>,</span><br><span class="line">            roi_feat_size=<span class="number">7</span>,</span><br><span class="line">            num_classes=<span class="number">81</span>,</span><br><span class="line">            target_means=[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">            target_stds=[<span class="number">0.033</span>, <span class="number">0.033</span>, <span class="number">0.067</span>, <span class="number">0.067</span>],</span><br><span class="line">            reg_class_agnostic=<span class="literal">True</span>)</span><br><span class="line">    ])</span><br><span class="line"><span class="comment"># model training and testing settings</span></span><br><span class="line">train_cfg = dict(</span><br><span class="line">    rpn=dict(</span><br><span class="line">        assigner=dict(</span><br><span class="line">            type=<span class="string">'MaxIoUAssigner'</span>,</span><br><span class="line">            pos_iou_thr=<span class="number">0.7</span>,</span><br><span class="line">            neg_iou_thr=<span class="number">0.3</span>,</span><br><span class="line">            min_pos_iou=<span class="number">0.3</span>,</span><br><span class="line">            ignore_iof_thr=<span class="number">-1</span>),</span><br><span class="line">        sampler=dict(</span><br><span class="line">            type=<span class="string">'RandomSampler'</span>,</span><br><span class="line">            num=<span class="number">256</span>,</span><br><span class="line">            pos_fraction=<span class="number">0.5</span>,</span><br><span class="line">            neg_pos_ub=<span class="number">-1</span>,</span><br><span class="line">            add_gt_as_proposals=<span class="literal">False</span>),</span><br><span class="line">        allowed_border=<span class="number">0</span>,</span><br><span class="line">        pos_weight=<span class="number">-1</span>,</span><br><span class="line">        smoothl1_beta=<span class="number">1</span> / <span class="number">9.0</span>,</span><br><span class="line">        debug=<span class="literal">False</span>),</span><br><span class="line">    rcnn=[                    <span class="comment"># 注意，这里有3个RCNN的模块，对应开头的那个RCNN的stage数量</span></span><br><span class="line">        dict(</span><br><span class="line">            assigner=dict(</span><br><span class="line">                type=<span class="string">'MaxIoUAssigner'</span>,</span><br><span class="line">                pos_iou_thr=<span class="number">0.5</span>,</span><br><span class="line">                neg_iou_thr=<span class="number">0.5</span>,</span><br><span class="line">                min_pos_iou=<span class="number">0.5</span>,</span><br><span class="line">                ignore_iof_thr=<span class="number">-1</span>),</span><br><span class="line">            sampler=dict(</span><br><span class="line">                type=<span class="string">'RandomSampler'</span>,</span><br><span class="line">                num=<span class="number">512</span>,</span><br><span class="line">                pos_fraction=<span class="number">0.25</span>,</span><br><span class="line">                neg_pos_ub=<span class="number">-1</span>,</span><br><span class="line">                add_gt_as_proposals=<span class="literal">True</span>),</span><br><span class="line">            pos_weight=<span class="number">-1</span>,</span><br><span class="line">            debug=<span class="literal">False</span>),</span><br><span class="line">        dict(</span><br><span class="line">            assigner=dict(</span><br><span class="line">                type=<span class="string">'MaxIoUAssigner'</span>,</span><br><span class="line">                pos_iou_thr=<span class="number">0.6</span>,</span><br><span class="line">                neg_iou_thr=<span class="number">0.6</span>,</span><br><span class="line">                min_pos_iou=<span class="number">0.6</span>,</span><br><span class="line">                ignore_iof_thr=<span class="number">-1</span>),</span><br><span class="line">            sampler=dict(</span><br><span class="line">                type=<span class="string">'RandomSampler'</span>,</span><br><span class="line">                num=<span class="number">512</span>,</span><br><span class="line">                pos_fraction=<span class="number">0.25</span>,</span><br><span class="line">                neg_pos_ub=<span class="number">-1</span>,</span><br><span class="line">                add_gt_as_proposals=<span class="literal">True</span>),</span><br><span class="line">            pos_weight=<span class="number">-1</span>,</span><br><span class="line">            debug=<span class="literal">False</span>),</span><br><span class="line">        dict(</span><br><span class="line">            assigner=dict(</span><br><span class="line">                type=<span class="string">'MaxIoUAssigner'</span>,</span><br><span class="line">                pos_iou_thr=<span class="number">0.7</span>,</span><br><span class="line">                neg_iou_thr=<span class="number">0.7</span>,</span><br><span class="line">                min_pos_iou=<span class="number">0.7</span>,</span><br><span class="line">                ignore_iof_thr=<span class="number">-1</span>),</span><br><span class="line">            sampler=dict(</span><br><span class="line">                type=<span class="string">'RandomSampler'</span>,</span><br><span class="line">                num=<span class="number">512</span>,</span><br><span class="line">                pos_fraction=<span class="number">0.25</span>,</span><br><span class="line">                neg_pos_ub=<span class="number">-1</span>,</span><br><span class="line">                add_gt_as_proposals=<span class="literal">True</span>),</span><br><span class="line">            pos_weight=<span class="number">-1</span>,</span><br><span class="line">            debug=<span class="literal">False</span>)</span><br><span class="line">    ],</span><br><span class="line">    stage_loss_weights=[<span class="number">1</span>, <span class="number">0.5</span>, <span class="number">0.25</span>])     <span class="comment"># 3个RCNN的stage的loss权重</span></span><br><span class="line">test_cfg = dict(</span><br><span class="line">    rpn=dict(</span><br><span class="line">        nms_across_levels=<span class="literal">False</span>,</span><br><span class="line">        nms_pre=<span class="number">2000</span>,</span><br><span class="line">        nms_post=<span class="number">2000</span>,</span><br><span class="line">        max_num=<span class="number">2000</span>,</span><br><span class="line">        nms_thr=<span class="number">0.7</span>,</span><br><span class="line">        min_bbox_size=<span class="number">0</span>),</span><br><span class="line">    rcnn=dict(</span><br><span class="line">        score_thr=<span class="number">0.05</span>, nms=dict(type=<span class="string">'nms'</span>, iou_thr=<span class="number">0.5</span>), max_per_img=<span class="number">100</span>),</span><br><span class="line">    keep_all_stages=<span class="literal">False</span>)         <span class="comment"># 是否保留所有stage的结果</span></span><br><span class="line"><span class="comment"># dataset settings</span></span><br><span class="line">dataset_type = <span class="string">'CocoDataset'</span></span><br><span class="line">data_root = <span class="string">'data/coco/'</span></span><br><span class="line">img_norm_cfg = dict(</span><br><span class="line">    mean=[<span class="number">123.675</span>, <span class="number">116.28</span>, <span class="number">103.53</span>], std=[<span class="number">58.395</span>, <span class="number">57.12</span>, <span class="number">57.375</span>], to_rgb=<span class="literal">True</span>)</span><br><span class="line">data = dict(</span><br><span class="line">    imgs_per_gpu=<span class="number">2</span>,</span><br><span class="line">    workers_per_gpu=<span class="number">2</span>,</span><br><span class="line">    train=dict(</span><br><span class="line">        type=dataset_type,</span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/instances_train2017.json'</span>,</span><br><span class="line">        img_prefix=data_root + <span class="string">'train2017/'</span>,</span><br><span class="line">        img_scale=(<span class="number">1333</span>, <span class="number">800</span>),</span><br><span class="line">        img_norm_cfg=img_norm_cfg,</span><br><span class="line">        size_divisor=<span class="number">32</span>,</span><br><span class="line">        flip_ratio=<span class="number">0.5</span>,</span><br><span class="line">        with_mask=<span class="literal">False</span>,</span><br><span class="line">        with_crowd=<span class="literal">True</span>,</span><br><span class="line">        with_label=<span class="literal">True</span>),</span><br><span class="line">    val=dict(</span><br><span class="line">        type=dataset_type,</span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/instances_val2017.json'</span>,</span><br><span class="line">        img_prefix=data_root + <span class="string">'val2017/'</span>,</span><br><span class="line">        img_scale=(<span class="number">1333</span>, <span class="number">800</span>),</span><br><span class="line">        img_norm_cfg=img_norm_cfg,</span><br><span class="line">        size_divisor=<span class="number">32</span>,</span><br><span class="line">        flip_ratio=<span class="number">0</span>,</span><br><span class="line">        with_mask=<span class="literal">False</span>,</span><br><span class="line">        with_crowd=<span class="literal">True</span>,</span><br><span class="line">        with_label=<span class="literal">True</span>),</span><br><span class="line">    test=dict(</span><br><span class="line">        type=dataset_type,</span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/instances_val2017.json'</span>,</span><br><span class="line">        img_prefix=data_root + <span class="string">'val2017/'</span>,</span><br><span class="line">        img_scale=(<span class="number">1333</span>, <span class="number">800</span>),</span><br><span class="line">        img_norm_cfg=img_norm_cfg,</span><br><span class="line">        size_divisor=<span class="number">32</span>,</span><br><span class="line">        flip_ratio=<span class="number">0</span>,</span><br><span class="line">        with_mask=<span class="literal">False</span>,</span><br><span class="line">        with_label=<span class="literal">False</span>,</span><br><span class="line">        test_mode=<span class="literal">True</span>))</span><br><span class="line"><span class="comment"># optimizer</span></span><br><span class="line">optimizer = dict(type=<span class="string">'SGD'</span>, lr=<span class="number">0.02</span>, momentum=<span class="number">0.9</span>, weight_decay=<span class="number">0.0001</span>)</span><br><span class="line">optimizer_config = dict(grad_clip=dict(max_norm=<span class="number">35</span>, norm_type=<span class="number">2</span>))</span><br><span class="line"><span class="comment"># learning policy</span></span><br><span class="line">lr_config = dict(</span><br><span class="line">    policy=<span class="string">'step'</span>,</span><br><span class="line">    warmup=<span class="string">'linear'</span>,</span><br><span class="line">    warmup_iters=<span class="number">500</span>,</span><br><span class="line">    warmup_ratio=<span class="number">1.0</span> / <span class="number">3</span>,</span><br><span class="line">    step=[<span class="number">8</span>, <span class="number">11</span>])</span><br><span class="line">checkpoint_config = dict(interval=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># yapf:disable</span></span><br><span class="line">log_config = dict(</span><br><span class="line">    interval=<span class="number">50</span>,</span><br><span class="line">    hooks=[</span><br><span class="line">        dict(type=<span class="string">'TextLoggerHook'</span>),</span><br><span class="line">        <span class="comment"># dict(type='TensorboardLoggerHook')</span></span><br><span class="line">    ])</span><br><span class="line"><span class="comment"># yapf:enable</span></span><br><span class="line"><span class="comment"># runtime settings</span></span><br><span class="line">total_epochs = <span class="number">12</span></span><br><span class="line">dist_params = dict(backend=<span class="string">'nccl'</span>)</span><br><span class="line">log_level = <span class="string">'INFO'</span></span><br><span class="line">work_dir = <span class="string">'./work_dirs/cascade_rcnn_r50_fpn_1x'</span></span><br><span class="line">load_from = <span class="literal">None</span></span><br><span class="line">resume_from = <span class="literal">None</span></span><br><span class="line">workflow = [(<span class="string">'train'</span>, <span class="number">1</span>)]</span><br></pre></td></tr></table></figure>
<p>参考链接：</p>
<p><a href="https://www.jiqizhixin.com/articles/2018-10-17-10" target="_blank" rel="noopener">https://www.jiqizhixin.com/articles/2018-10-17-10</a></p>
]]></content>
      <categories>
        <category>目标检测</category>
      </categories>
      <tags>
        <tag>目标检测</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy 函数</title>
    <url>/2019/06/16/numpy-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="np-round"><a href="#np-round" class="headerlink" title="np.round "></a><font color="#0099ff" size="7" face="黑体">np.round </font></h2><h3 id="round函数概念："><a href="#round函数概念：" class="headerlink" title="round函数概念："></a>round函数概念：</h3><p>英文：圆，四舍五入<br>是python内置函数，它在哪都能用，对数字取四舍五入。<br>round(number[, ndigits])<br>round 对传入的数据进行四舍五入，如果ngigits不传，默认是0（就是说保留整数部分）.ngigits&lt;0 的时候是来对整数部分进行四舍五入，返回的结果是浮点数.</p>
<h3 id="round-负数"><a href="#round-负数" class="headerlink" title="round 负数"></a>round 负数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 四舍五入是围绕着0来计算的，  </span></span><br><span class="line">round(<span class="number">0.5</span>) <span class="comment"># 1.0  </span></span><br><span class="line">round(<span class="number">-0.5</span>) <span class="comment">#-1.0</span></span><br></pre></td></tr></table></figure>
<h3 id="round-的陷阱"><a href="#round-的陷阱" class="headerlink" title="round 的陷阱"></a>round 的陷阱</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">round(<span class="number">1.675</span>, <span class="number">2</span>) <span class="comment">#1.68  </span></span><br><span class="line">round(<span class="number">2.675</span>, <span class="number">2</span>) <span class="comment">#2.67</span></span><br></pre></td></tr></table></figure>
<h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">round(<span class="number">3.4</span>) <span class="comment"># 3.0  </span></span><br><span class="line">round(<span class="number">3.5</span>) <span class="comment"># 4.0  </span></span><br><span class="line">round(<span class="number">3.6</span>) <span class="comment"># 4.0  </span></span><br><span class="line">round(<span class="number">3.6</span>, <span class="number">0</span>) <span class="comment"># 4.0  </span></span><br><span class="line">round(<span class="number">1.95583</span>, <span class="number">2</span>) <span class="comment"># 1.96  </span></span><br><span class="line">round(<span class="number">1241757</span>, <span class="number">-3</span>) <span class="comment"># 1242000.0  </span></span><br><span class="line">round(<span class="number">5.045</span>, <span class="number">2</span>) <span class="comment"># 5.05  </span></span><br><span class="line">round(<span class="number">5.055</span>, <span class="number">2</span>) <span class="comment"># 5.06</span></span><br></pre></td></tr></table></figure>
<h2 id="np-clip"><a href="#np-clip" class="headerlink" title="np.clip"></a><font color="#0099ff" size="7" face="黑体">np.clip</font></h2><p>numpy.clip(a, a_min, a_max, out=None)[source]<br>其中a是一个数组，后面两个参数分别表示最小和最大值，怎么用呢，老规矩，我们看代码：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x=np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>])</span><br><span class="line">np.clip(x,<span class="number">3</span>,<span class="number">8</span>)</span><br><span class="line">Out[<span class="number">88</span>]:</span><br><span class="line">array([<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>])</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>optical flow(光流)</title>
    <url>/2019/03/23/optical-flow-%E5%85%89%E6%B5%81/</url>
    <content><![CDATA[<p>参考：<a href="https://blog.csdn.net/zouxy09/article/details/8683859" target="_blank" rel="noopener">https://blog.csdn.net/zouxy09/article/details/8683859</a></p>
<h2 id="光流的定义"><a href="#光流的定义" class="headerlink" title="光流的定义"></a>光流的定义</h2><p>在人的眼睛在观察物体时，物体的景象在人的视网膜上形成一系列连续变化的图像，这一系列连续变化的信息不断“流过”视网膜，好像一种光的流，故称之为光流。<br>一般，光流是由于场景中前景目标本身的移动、相机的移动，或者两者的共同运动所产生的。<br>定义：它是空间运动物体在观察成像平面上的像素运动的瞬时速度，是利用图像序列中<strong>像素在时间域上的变化以及相邻帧之间的相关性</strong>来找到上一帧跟当前帧之间存在的<strong>对应关系</strong>，从而计算出<strong>相邻帧</strong>之间物体的运动信息的一种方法。</p>
<h2 id="如何计算光流"><a href="#如何计算光流" class="headerlink" title="如何计算光流"></a>如何计算光流</h2><ul>
<li>那通俗的讲就是通过一个图片序列，把每张图像中每个像素的运动速度和运动方向找出来就是光流场。那怎么找呢？咱们直观理解肯定是：第t帧的时候A点的位置是(x1, y1)，那么我们在第t+1帧的时候再找到A点，假如它的位置是(x2,y2)，那么我们就可以确定A点的运动了：(ux, vy) = (x2, y2) - (x1,y1)。</li>
<li>那怎么知道第t+1帧的时候A点的位置呢？ 这就存在很多的光流计算方法了。</li>
<li>1981年，Horn和Schunck创造性地将二维速度场与灰度相联系，引入光流约束方程，得到光流计算的基本算法。人们基于不同的理论基础提出各种光流计算方法，算法性能各有不同。Barron等人对多种光流计算技术进行了总结，按照理论基础与数学方法的区别把它们分成四种：<strong>基于梯度的方法、基于匹配的方法、基于能量的方法、基于相位的方法</strong>。近年来神经动力学方法也颇受学者重视。</li>
<li><p>yaya: 即光流法计算的是：相邻两帧之间的对应像素点之间的<strong>速度矢量</strong>，但是如何得到相邻帧对应的像素点是一个问题。<br>光流法主要依赖于三个假设：</p>
<p>  [亮度恒定] 图像中目标的像素强度在连续帧之间不会发生变化。<br>  [时间规律] 相邻帧之间的时间足够短，以至于在考虑运行变化时可以忽略它们之间的差异。该假设用于导出下面的核心方程。<br>  [空间一致性] 相邻像素具有相似的运动。  </p>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1cgxrjz19j30hi0h90uo.jpg">  </p>
<p>上式中，I<sub>x</sub>,  I<sub>y</sub>可以通过图像沿x方向和y方向的导数计算，I<sub>t</sub>可以通过I(x,y,t)−I(x,y,t−1)计算。未知数是(u,v)， 正是我们想要求解的每个像素在前后相邻两帧的位移。</p>
<p>这里只有一个方程，却有两个未知数（实际是NN个方程，2N2N个未知数，NN是图像中待估计的像素点的个数，但是我们通过矩阵表示，将它们写成了如上式所述的紧凑形式），所以是一个不定方程。我们需要找出其它的约束求解方程。</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1cgxrjo7dj30g00e6ta4.jpg"><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1cgxrhmkgj30gh05swej.jpg">  </p>
<p>如上图所示，H中的像素点(x,y)在I中的移动到了(x+u,y+v)的位置，偏移量为(u,v)。速度=位移在极短时间你内的位移量。  </p>
<p>参看：<a href="https://xmfbit.github.io/2017/05/03/cs131-opticalflow/" target="_blank" rel="noopener">https://xmfbit.github.io/2017/05/03/cs131-opticalflow/</a><br>参看：<a href="https://blog.csdn.net/carson2005/article/details/7581642" target="_blank" rel="noopener">https://blog.csdn.net/carson2005/article/details/7581642</a></p>
]]></content>
      <categories>
        <category>行为识别</category>
      </categories>
      <tags>
        <tag>行为识别</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>pth: save in py2, but load in py3</title>
    <url>/2019/12/11/pth-save-in-py2-but-load-in-py3/</url>
    <content><![CDATA[<h3 id="在torch-load-pth-时出现的问题：UnicodeDecodeError-39-utf-8-39-codec-can-39-t-decode-byte-0xba-in-position-0-invalid-start-byte"><a href="#在torch-load-pth-时出现的问题：UnicodeDecodeError-39-utf-8-39-codec-can-39-t-decode-byte-0xba-in-position-0-invalid-start-byte" class="headerlink" title="在torch.load(*.pth) 时出现的问题：UnicodeDecodeError: &#39;utf-8&#39; codec can&#39;t decode byte 0xba in position 0: invalid start byte"></a>在torch.load(*.pth) 时出现的问题：<code>UnicodeDecodeError: &#39;utf-8&#39; codec can&#39;t decode byte 0xba in position 0: invalid start byte</code></h3><ul>
<li><p>经过网络查询，发现是由于该文件是在 python2 下保存的，但是现在却是在python3下读取，而导致的错误</p>
</li>
<li><p>有的人给出了下面的解决方案(但是对于我是无效的)：    </p>
<p>来自：<a href="https://github.com/CSAILVision/places365/issues/25" target="_blank" rel="noopener">https://github.com/CSAILVision/places365/issues/25</a></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools import partial</span><br><span class="line">import pickle</span><br><span class="line">pickle.load = partial(pickle.load, <span class="attribute">encoding</span>=<span class="string">"latin1"</span>)</span><br><span class="line">pickle.Unpickler = partial(pickle.Unpickler, <span class="attribute">encoding</span>=<span class="string">"latin1"</span>)</span><br><span class="line">model = torch.load(model_file, <span class="attribute">map_location</span>=lambda storage, loc: storage, <span class="attribute">pickle_module</span>=pickle)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>这里给出我的解决办法</strong>   </p>
<p>（1） 在python2 环境下读取该文件，然后用 pickle来保存   </p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">tmp_data = torch.<span class="built_in">load</span>(model_file)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'tmp.pickle'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> <span class="built_in">file</span>:</span><br><span class="line">    pickle.dump(tmp_data, <span class="built_in">file</span>, protocol=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>（2）换到python3环境下，再读取pickle文件，再用torch.load来保存（这一点或可以省略）</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'tmp.pickle'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> <span class="built_in">file</span>:</span><br><span class="line">    tmp_data = pickle.<span class="built_in">load</span>(<span class="built_in">file</span>, encoding=<span class="string">'latin1'</span>)</span><br><span class="line">    </span><br><span class="line">torch.save(tmp_data, tmp_model.pth)</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy广播</title>
    <url>/2019/04/09/numpy%E5%B9%BF%E6%92%AD/</url>
    <content><![CDATA[<ul>
<li>末尾有彩蛋</li>
</ul>
<h1 id="NumPy-广播-Broadcast"><a href="#NumPy-广播-Broadcast" class="headerlink" title="NumPy 广播(Broadcast)"></a>NumPy 广播(Broadcast)</h1><p>广播(Broadcast)是 numpy 对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。</p>
<p>如果两个数组 a 和 b 形状相同，即满足 <strong>a.shape == b.shape</strong>，那么 a*b 的结果就是 a 与 b 数组对应位相乘。这要求维数相同，且各维度的长度相同。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>import numpy as np    a = np.array([1,2,3,4])  b = np.array([10,20,30,40])  c = a * b  print (c)</p>
<p>输出结果为：<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">[ <span class="number">10</span>  <span class="number">40</span>  <span class="number">90</span> <span class="number">160</span>]</span><br></pre></td></tr></table></figure></p>
<p>当运算中的 2 个数组的形状不同时，numpy 将自动触发广播机制。如：</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np    </span><br><span class="line">a = np.array([[ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],            [<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>],            [<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>],            [<span class="number">30</span>,<span class="number">30</span>,<span class="number">30</span>]]) </span><br><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) print(a + b)</span><br></pre></td></tr></table></figure>
<p>输出结果为：<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">[[ <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [<span class="number">11</span> <span class="number">12</span> <span class="number">13</span>]</span><br><span class="line"> [<span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]</span><br><span class="line"> [<span class="number">31</span> <span class="number">32</span> <span class="number">33</span>]]</span><br></pre></td></tr></table></figure></p>
<p>下面的图片展示了数组 b 如何通过广播来与数组 a 兼容。</p>
<p><img src="http://www.runoob.com/wp-content/uploads/2018/10/image0020619.gif" alt="img"></p>
<p>4x3 的二维数组与长为 3 的一维数组相加，等效于把数组 b 在二维上重复 4 次再运算。</p>
<h2 id="yayay实例"><a href="#yayay实例" class="headerlink" title="yayay实例"></a>yayay实例</h2><p>在few-shot gnn任务中，想要计算邻接矩阵A，其公式为：<strong>a<sub>ij</sub> = fc(v<sub>i</sub>-v<sub>j</sub>)</strong><br>那么问题来了得到的邻接矩阵是N×N的，则计算的差值矩阵也应该是N×N的。那么该如何高效的计算出来这个差值矩阵。<br>```python<br>import numpy as np<br>N = 10<br>D = 7<br>X = np.ones((N,D))<br>X1 = np.expand_dims(X, axis=0)<br>X2 = np.expand_dims(X, axis=1)<br>X_abs = np.abs(X1-X2)<br>X_abs = np.reshape(X_abs, (N,N,D))<br>X_T = X_abs </p>
<p>?????????????????需要考虑一下这个转置问题</p>
]]></content>
      <categories>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>python 3.3.3 字面量,正则,反斜杠和原始字符串</title>
    <url>/2019/08/14/python-3-3-3-%E5%AD%97%E9%9D%A2%E9%87%8F-%E6%AD%A3%E5%88%99-%E5%8F%8D%E6%96%9C%E6%9D%A0%E5%92%8C%E5%8E%9F%E5%A7%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<ul>
<li>注明：转载 from <a href="https://www.cnblogs.com/xiangnan/p/3446904.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiangnan/p/3446904.html</a></li>
</ul>
<h1 id="两个不起眼但是比较重要的设定"><a href="#两个不起眼但是比较重要的设定" class="headerlink" title="两个不起眼但是比较重要的设定"></a>两个不起眼但是比较重要的设定</h1><ul>
<li>Python str类型的字面量解释器</li>
</ul>
<p>当反斜杠及其紧接字符无法构成一个具有特殊含义的序列(‘recognized escape sequences’)时,Python选择保留全部字符.直接看例子:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\c'</span></span><br><span class="line"><span class="string">'\\c'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\d'</span></span><br><span class="line"><span class="string">'\\d'</span></span><br></pre></td></tr></table></figure>
<p>官方管’\c’这种序列叫’unrecognized escape sequences’.官方文档相应部分:</p>
<p>Unlike Standard C, all unrecognized escape sequences are left in the string unchanged, i.e., <em>the backslash is left in the string</em>. (This behavior is useful when debugging: if an escape sequence is mistyped, the resulting output is more easily recognized as broken.) </p>
<p>按这段英文的意思,估计C语言里面,’c’和’\c’是等同的.Python是’\\c’和’\c’等同.这个等以后学C语言再确定.</p>
<p>与上面对应的是,如果紧接字符能够和反斜杠构成’recognized escape sequences’的<strong>全部</strong>或者<strong>起始部分</strong>,中文就叫’被承认的转义序列’吧.比如:</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\b'</span></span><br><span class="line"><span class="string">'\x08'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\n'</span></span><br><span class="line"><span class="string">'\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\x'</span></span><br><span class="line"><span class="symbol">SyntaxError:</span> (unicode error) <span class="string">'unicodeescape'</span> codec can<span class="string">'t decode bytes in position 0-1: truncated \xXX escape</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; '</span>\N<span class="string">'</span></span><br><span class="line"><span class="string">SyntaxError: (unicode error) '</span>unicodeescape<span class="string">' codec can'</span>t decode bytes <span class="keyword">in</span> position <span class="number">0</span>-<span class="number">1</span>: malformed \N character escape</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\U'</span></span><br><span class="line"><span class="symbol">SyntaxError:</span> (unicode error) <span class="string">'unicodeescape'</span> codec can<span class="string">'t decode bytes in position 0-1: truncated \UXXXXXXXX escape</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; '</span>\u<span class="string">'</span></span><br><span class="line"><span class="string">SyntaxError: (unicode error) '</span>unicodeescape<span class="string">' codec can'</span>t decode bytes <span class="keyword">in</span> position <span class="number">0</span>-<span class="number">1</span>: truncated \uXXXX escape</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<ul>
<li>Python re模块正则表达式解释器</li>
</ul>
<p>当反斜杠及其紧接字符无法构成一个具有特殊含义的序列(special sequences)时,re选择忽略反斜杠,例如:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\e'</span>,<span class="string">'eee'</span>)</span><br><span class="line">[<span class="string">'e'</span>, <span class="string">'e'</span>, <span class="string">'e'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'e'</span>,<span class="string">'eee'</span>)</span><br><span class="line">[<span class="string">'e'</span>, <span class="string">'e'</span>, <span class="string">'e'</span>]</span><br></pre></td></tr></table></figure>
<p>可见,’\e’和’e’起到了完全一样的效果.Python相关文档描述是:</p>
<p>If the ordinary character is not on the list, then the resulting RE will match the second character. For example, <code>\$</code> matches the character <code>&#39;$&#39;</code>.</p>
<p>与上面对应的是,如果能够构成special sequences,那么re会解释为相应含义.例如:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\w'</span>,<span class="string">'abcdefghijklmnopqrstuvwxyz'</span>)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span>, <span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'o'</span>, <span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>, <span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>, <span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]</span><br></pre></td></tr></table></figure>
<h1 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h1><p>字面量(Literals),是用于表示一些Python内建类型的常量的符号.最常见的字面量类型是str literals 和 bytes literals.</p>
<p>比如:</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'abc'</span></span><br><span class="line"><span class="string">'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"abc"</span></span><br><span class="line"><span class="string">'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'啊哦额'</span></span><br><span class="line"><span class="string">'啊哦额'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'abc'</span></span><br><span class="line"><span class="string">b'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">r'\n'</span></span><br><span class="line"><span class="string">'\\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'啊哦额'</span></span><br><span class="line">SyntaxError: bytes can only contain ASCII literal characters.</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p>反斜杠\的用途按紧接其后的字符种类可划分为3类:</p>
<p>1.将特殊字符转换为字面量.这特殊字符包括(单引号,双引号,反斜杠):’”\</p>
<p>2.将普通字符转换为特殊序列.包括:abfNnrtuUvx0123456789.</p>
<p>(注意,bytes字面量中,NuU这三个普通字符无法被转义成特殊序列)</p>
<p>3.将”新行”和自身忽略掉.这个比较抽象,举例说明:py文件中,某个字符串太长了,以至于需要分两行写,那么你可以插个反斜杠,紧接着换行,然后写剩余字符串.</p>
<p>下面是官方文档归纳的表:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Escape Sequence</th>
<th>Meaning</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\newline</code></td>
<td>Backslash and newline ignored</td>
<td></td>
</tr>
<tr>
<td><code>\\</code></td>
<td>Backslash (<code>\</code>)</td>
<td></td>
</tr>
<tr>
<td><code>\&#39;</code></td>
<td>Single quote (<code>&#39;</code>)</td>
<td></td>
</tr>
<tr>
<td><code>\&quot;</code></td>
<td>Double quote (<code>&quot;</code>)</td>
<td></td>
</tr>
<tr>
<td><code>\a</code></td>
<td>ASCII Bell (BEL)</td>
<td></td>
</tr>
<tr>
<td><code>\b</code></td>
<td>ASCII Backspace (BS)</td>
<td></td>
</tr>
<tr>
<td><code>\f</code></td>
<td>ASCII Formfeed (FF)</td>
<td></td>
</tr>
<tr>
<td><code>\n</code></td>
<td>ASCII Linefeed (LF)</td>
<td></td>
</tr>
<tr>
<td><code>\r</code></td>
<td>ASCII Carriage Return (CR)</td>
<td></td>
</tr>
<tr>
<td><code>\t</code></td>
<td>ASCII Horizontal Tab (TAB)</td>
<td></td>
</tr>
<tr>
<td><code>\v</code></td>
<td>ASCII Vertical Tab (VT)</td>
<td></td>
</tr>
<tr>
<td><code>\ooo</code></td>
<td>Character with octal value <em>ooo</em></td>
<td>(1,3)</td>
</tr>
<tr>
<td><code>\xhh</code></td>
<td>Character with hex value <em>hh</em></td>
<td>(2,3)</td>
</tr>
</tbody>
</table>
</div>
<p>Escape sequences only recognized in string literals are:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Escape Sequence</th>
<th>Meaning</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\N{name}</code></td>
<td>Character named <em>name</em> in the Unicode database</td>
<td>(4)</td>
</tr>
<tr>
<td><code>\uxxxx</code></td>
<td>Character with 16-bit hex value <em>xxxx</em></td>
<td>(5)</td>
</tr>
<tr>
<td><code>\Uxxxxxxxx</code></td>
<td>Character with 32-bit hex value <em>xxxxxxxx</em></td>
<td>(6)</td>
</tr>
</tbody>
</table>
</div>
<p>举例:</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\N&#123;END OF LINE&#125;'</span></span><br><span class="line"><span class="string">'\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\N&#123;HORIZONTAL TABULATION&#125;'</span></span><br><span class="line"><span class="string">'\t'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\u9f6a'</span>==<span class="string">'齪'</span></span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\1'</span>==<span class="string">'\01'</span></span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\1'</span>==<span class="string">'\001'</span></span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\1'</span>==<span class="string">'\0000001'</span></span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<h1 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h1><ul>
<li>正则表达式的反斜杠的作用</li>
</ul>
<p>一种是使紧跟在后面的元字符(special characters或metacharacters)失去特殊含义,变为字面量.这些元字符有14个:</p>
<p>.^$*+?{}<a href></a>|</p>
<p>另一种是使紧跟在后面的普通字符变得具有特殊含义.这些普通字符是:</p>
<p>AbBdDsSwWZ0123456789</p>
<p>以及在str字面量中能被反斜杠转义的字符:</p>
<p>\’”abfnrtuUvx0123456789</p>
<p>例如:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\"'</span>,<span class="string">'"'</span>)</span><br><span class="line">[<span class="string">'"'</span>]</span><br></pre></td></tr></table></figure>
<p>正则pattern的反斜杠的作用和Python字面量的反斜杠类似,这据说是带来”反斜杠灾难”的根源.最典型的莫过于你需要用正则’\\\\’才能匹配字面量反斜杠’\\’.</p>
<p>为方便说明,我们假设re.search(pattern,string)中,pattern表示正则表达式字符串,string表示待匹配的字符串.</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; re.search(<span class="string">'\\\\'</span>,<span class="string">'\\'</span>)</span><br><span class="line">&lt;_sre<span class="selector-class">.SRE_Match</span> <span class="selector-tag">object</span> at <span class="number">0</span>x02858528&gt;</span><br></pre></td></tr></table></figure>
<p>详细来说就是一个文本层级的反斜杠’\’(比如你在txt文件中看到的反斜杠),对应Python str 字面量的’\\’,对应正则pattern的’\\\\’.这个确实比较难以理解,实在不行就住这点就好:<strong>如果不是最简单的正则类型(比如’ab’),强烈推荐对pattern使用r前缀符</strong>.这样容易理解:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(<span class="string">r'\\'</span>,<span class="string">'\\'</span>)</span><br><span class="line">&lt;_sre.SRE_Match object at <span class="number">0x02858448</span>&gt;</span><br></pre></td></tr></table></figure>
<p>注意:</p>
<ul>
<li>1.多重含义的特殊序列处理机制</li>
</ul>
<p>b0123456789比较特殊,它们在Python字面量和re正则中都能和反斜杠构成作用不同的特殊序列.例如\b,在python 字面量中解释为”退格键”.re正则中解释为’单词边界’.<strong>python 字面量有优先解释权</strong>,如下可证:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\b'</span>,<span class="string">'\b'</span>)  <span class="comment">#'\b'被优先解释为退格键,而不是单词边界</span></span><br><span class="line">[<span class="string">'\x08'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\b'</span>,<span class="string">'\b'</span>)</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\b'</span>,<span class="string">'b'</span>) </span><br><span class="line">[<span class="string">''</span>, <span class="string">''</span>]</span><br></pre></td></tr></table></figure>
<p>再比如:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'(a)\1\1'</span>,<span class="string">'aaa'</span>) <span class="comment">#\1按字面量优先解释为八进制字符串,因此无匹配结果</span></span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'(a)\\1\\1'</span>,<span class="string">'aaa'</span>)  <span class="comment">#\\1按正则引擎层级的反斜杠解释为第一个匹配组提取到的字符,相当于'(a)aa'</span></span><br><span class="line">[<span class="string">'a'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'a\1\1'</span>,<span class="string">'a\1\1'</span>) <span class="comment">#\1按字面量优先解释为八进制字符串,所以有匹配结果</span></span><br><span class="line">[<span class="string">'a\x01\x01'</span>]</span><br></pre></td></tr></table></figure>
<p>了解这个设置有什么用?</p>
<p>1.当你想使用正则层级的特殊序列\1时,如果你没有使用r作为前缀,那么你必须使用\\1才能如愿.</p>
<p>2.当你想使用字面量层级的特殊序列\1时,则不能使用r作为pattern前缀.</p>
<p>想想,你有可能在一个r前缀的字符串中写出能够匹配值为1的八进制字符串的pattern吗?</p>
<p>也许我太较真了,因为实践中好像从没遇到过需要匹配值为1的八进制字符串的情况,但理论上就是这样的.</p>
<ul>
<li><strong>2.正则表达式中特殊序列的准确定义的猜想</strong></li>
</ul>
<p>官方文档下面的一句话值得推敲:</p>
<p>Note that <code>\b</code> is used to represent word boundaries, and means “backspace” only inside character classes</p>
<p>意思是说\b只有在[…]里面时才表示退格键,这显然是错的.比如下面这个例子,\b没有在[]之内,但它是按”退格键”解释的,并非”单词边界”:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\b'</span>,<span class="string">'\b'</span>)</span><br><span class="line">[<span class="string">'\x08'</span>]</span><br></pre></td></tr></table></figure>
<p>除非官方文档描述的\b是指文本层面的数据(比如你在txt文档里看到的\b).</p>
<p>由此引出了一个猜想,re的正则pattern中”反斜杠+普通字符”构成特殊序列或”反斜杠+特殊字符”构成字面量—这种描述中的反斜杠准确来说是指两个反斜杠!</p>
<p>仍然是举例说明:</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\b\w+\\b'</span>,<span class="string">'one two three'</span>)  <span class="comment">#必须用\\b才能表示单词边界</span></span><br><span class="line">[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\b\\w+\\b'</span>,<span class="string">'one two three'</span>)  <span class="comment">#想想,为什么\w和\\w都一样</span></span><br><span class="line">[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\d'</span>,<span class="string">'123'</span>)</span><br><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\d'</span>,<span class="string">'123'</span>)</span><br><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<ul>
<li>3.u和U只在str字面量中才能被转义,bytes字面量中是普通字符.</li>
</ul>
<p>以下是我猜测的正则表达式分析器和Python字面量分析器的传递规则表格:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Python string literal</th>
<th>values passed to regular expression</th>
<th>number of characters</th>
<th>what regular expression engine does</th>
<th>real meaning for regular expression</th>
</tr>
</thead>
<tbody>
<tr>
<td>\e</td>
<td>\e</td>
<td>2</td>
<td>ignore the backslash</td>
<td>e</td>
</tr>
<tr>
<td>\\e</td>
<td>\e</td>
<td>2</td>
<td>ignore the backslash</td>
<td>e</td>
</tr>
<tr>
<td>e</td>
<td>e</td>
<td>1</td>
<td>nothing spacial</td>
<td>e</td>
</tr>
<tr>
<td>\n</td>
<td>\n</td>
<td>1</td>
<td>nothing spacial</td>
<td>换行符</td>
</tr>
<tr>
<td>\\n</td>
<td>\n</td>
<td>2</td>
<td>\n is special</td>
<td>换行符</td>
</tr>
<tr>
<td>\b</td>
<td>\b</td>
<td>1</td>
<td>nothing spacial</td>
<td>退格键</td>
</tr>
<tr>
<td>\\b</td>
<td>\b</td>
<td>2</td>
<td>\b is special</td>
<td>word boundary</td>
</tr>
<tr>
<td>\s</td>
<td>\s</td>
<td>2</td>
<td>\s is special</td>
<td>Unicode whitespace characters</td>
</tr>
<tr>
<td>\\</td>
<td>\</td>
<td>1</td>
<td>must followed by a charcter</td>
<td>Can’t form any meaning</td>
</tr>
<tr>
<td>\\\\</td>
<td>\\</td>
<td>2</td>
<td>remove all special meanning of \</td>
<td>\</td>
</tr>
<tr>
<td>*</td>
<td>*</td>
<td>1</td>
<td>* is special</td>
<td>repeat the left characters 0 or more times</td>
</tr>
<tr>
<td>*</td>
<td>*</td>
<td>2</td>
<td>remove all special meanning of *</td>
<td>*</td>
</tr>
</tbody>
</table>
</div>
<p>最后是待探究的例子:</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\n'</span>,<span class="string">'\n\n'</span>)</span><br><span class="line">[<span class="string">'\n'</span>, <span class="string">'\n'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\n'</span>,<span class="string">'\n\n'</span>)</span><br><span class="line">[<span class="string">'\n'</span>, <span class="string">'\n'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\\n'</span>,<span class="string">'\n\n'</span>)</span><br><span class="line">[<span class="string">'\n'</span>, <span class="string">'\n'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\\\n'</span>,<span class="string">'\n\n'</span>)</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\b'</span>,<span class="string">'\b\b'</span>)</span><br><span class="line">[<span class="string">'\x08'</span>, <span class="string">'\x08'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\b'</span>,<span class="string">'\b\b'</span>)</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\\b'</span>,<span class="string">'\b\b'</span>)</span><br><span class="line">[<span class="string">'\x08'</span>, <span class="string">'\x08'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\\\b'</span>,<span class="string">'\b\b'</span>)</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\c'</span>,<span class="string">'\c\c'</span>)</span><br><span class="line">[<span class="string">'c'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\c'</span>,<span class="string">'\c\c'</span>)</span><br><span class="line">[<span class="string">'c'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\\c'</span>,<span class="string">'\c\c'</span>)</span><br><span class="line">[<span class="string">'\\c'</span>, <span class="string">'\\c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\\\c'</span>,<span class="string">'\c\c'</span>)</span><br><span class="line">[<span class="string">'\\c'</span>, <span class="string">'\\c'</span>]</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p>参考:</p>
<p>Python 3.3.3 官方文档</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python-dict</title>
    <url>/2019/05/08/python-dict/</url>
    <content><![CDATA[<h1 id="dict-的get-函数"><a href="#dict-的get-函数" class="headerlink" title="dict 的get 函数"></a>dict 的get 函数</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Python 字典(Dictionary) get() 函数返回指定键的值，如果值不在字典中返回默认值。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>get()方法语法：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">dict.<span class="builtin-name">get</span>(key, <span class="attribute">default</span>=None)</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li>key — 字典中要查找的键。</li>
<li>default — 如果指定键的值不存在时，返回该默认值值。</li>
</ul>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>返回指定键的值，如果值不在字典中返回默认值None。</p>
<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><p>get函数的作用是返回指定key的值，若key不存在，则返回default值，default值，默认为None，也可以自己指定</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python: list vs tuple</title>
    <url>/2019/03/20/python-list-vs-tuple/</url>
    <content><![CDATA[<ul>
<li><p><a href="https://shiyaya.github.io/2019/03/12/python%E5%9F%BA%E7%A1%80%EF%BC%9A-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-python-%E4%B8%AD%E7%9A%84%E8%B5%8B%E5%80%BC%E3%80%81%E5%BC%95%E7%94%A8%E3%80%81%E6%8B%B7%E8%B4%9D%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/" target="_blank" rel="noopener">shiyaya.github.io-python基础： 深入理解 python 中的赋值、引用、拷贝、作用域</a></p>
</li>
<li><p><a href="https://data-flair.training/blogs/python-tuples-vs-lists/" target="_blank" rel="noopener">https://data-flair.training/blogs/python-tuples-vs-lists/</a>  </p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>list</th>
<th>tuple</th>
</tr>
</thead>
<tbody>
<tr>
<td>可变对象</td>
<td>不可变对象</td>
</tr>
<tr>
<td>参数传递是传递的是引用</td>
<td>参数传递是传递的是值</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>可以修改某个元素的值</td>
<td>不可以修改某个元素的值，即不可以按索引来修改元素值</td>
</tr>
<tr>
<td>a= [1,2,3]&lt;/br&gt;b=a&lt;/br&gt;b[0]=8&lt;/br&gt;print(a) #a=[8,2,3]</td>
<td>略</td>
</tr>
<tr>
<td>可以修改slice&lt;/br&gt;del a[0:2]</td>
<td>不可以修改slice&lt;/br&gt;del a[0:2]#会提示错误</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python list sort方法</title>
    <url>/2019/04/04/python-list-sort%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><strong>sort()</strong> 函数用于对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>sort()方法语法：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">list.sort(<span class="attribute">cmp</span>=None, <span class="attribute">key</span>=None, <span class="attribute">reverse</span>=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li>cmp — 可选参数, 如果指定了该参数会使用该参数的方法进行排序。</li>
<li>key — 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</li>
<li>reverse — 排序规则，<strong>reverse = True</strong> 降序， <strong>reverse = False</strong> 升序（默认）。</li>
</ul>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>该方法没有返回值，但是会对列表的对象进行排序。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">video_sort_lambda = <span class="keyword">lambda</span> x: int(x[<span class="number">3</span>:<span class="number">-4</span>]) <span class="comment"># 定义一个函数对元素x进行操作，并得到一个整数Int</span></span><br><span class="line">video_root = <span class="string">"/userhome/dataset/MSVD/Video-Description-with-Spatial-Temporal-Attention/youtube"</span></span><br><span class="line">videos = sorted(os.listdir(video_root), key=video_sort_lambda) <span class="comment"># 按得到的整数，对list进行排序</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python 关于list的操作</title>
    <url>/2019/04/18/python-%E5%85%B3%E4%BA%8Elist%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="list-的置换"><a href="#list-的置换" class="headerlink" title="list 的置换"></a>list 的置换</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">nums[<span class="number">0</span>],nums[<span class="number">1</span>] = nums[<span class="number">1</span>],nums[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># nums = [2,1,3]</span></span><br></pre></td></tr></table></figure>
<h3 id="判断是否为空列表"><a href="#判断是否为空列表" class="headerlink" title="判断是否为空列表"></a>判断是否为空列表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = []</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> a:</span><br><span class="line">    print(<span class="string">"a is a null list"</span>)</span><br><span class="line"><span class="comment"># 输出：a is a null list</span></span><br></pre></td></tr></table></figure>
<h3 id="列表的连接"><a href="#列表的连接" class="headerlink" title="列表的连接"></a>列表的连接</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">c = a + b</span><br><span class="line">print(c)  <span class="comment"># [1, 2, 3, 6, 7, 8]</span></span><br><span class="line">d = a.extend(b)  <span class="comment"># extend()传入的参数需要是一个迭代对象 ：列表、元组、集合</span></span><br><span class="line">print(d) </span><br><span class="line"><span class="comment"># d 输出为None ,因为extend 无返回值，但是此时 a更改为[1, 2, 3, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>
<h3 id="列表的排序函数"><a href="#列表的排序函数" class="headerlink" title="列表的排序函数"></a>列表的排序函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = [2,4,6,5]</span><br><span class="line">b = a.sort()  # a = [2,4,5,6] , b = None</span><br><span class="line">a= [2,4,6,5]  </span><br><span class="line">b = sorted(a)  # a = [2, 4, 6, 5] , b = [2, 4, 5, 6]</span><br><span class="line"></span><br><span class="line">## sorted() 输出的是排序的结果，但是不更改传入的列表</span><br><span class="line">## sort() 直接对列表进行排序操作，并更改列表值</span><br></pre></td></tr></table></figure>
<h3 id="列表的置换顺序函数"><a href="#列表的置换顺序函数" class="headerlink" title="列表的置换顺序函数"></a>列表的置换顺序函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">b = a.reverse() <span class="comment"># a=[4,3,2,1] b = None</span></span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于列表 nums<br>凡是可以进行 nums.function()，这样的函数，一般是无返回值的，直接对列表本身进行操作。<br>比如<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">nums.extend([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])     <span class="comment"># [1, 2, 3, 4, 1, 2, 3]</span></span><br><span class="line">nums.append(<span class="number">2</span>)           <span class="comment"># [1, 2, 3, 4, 1, 2, 3, 2]</span></span><br><span class="line">nums.sort()              <span class="comment"># [1, 1, 2, 2, 2, 3, 3, 4]</span></span><br><span class="line">nums.reverse()           <span class="comment"># [4, 3, 3, 2, 2, 2, 1, 1]</span></span><br><span class="line">nums.insert(<span class="number">5</span>,<span class="number">100</span>)       <span class="comment"># [4, 3, 3, 2, 2, 100, 2, 1, 1]    在索引为5的位置插入元素100</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>注意<br>nums.index(100)          # <strong>有返回值5</strong>, 查找对应元素<strong>首次出现</strong>所在位置的索引</li>
</ul>
<h3 id="数字转为列表-123-gt-“1”-“2”-“3”"><a href="#数字转为列表-123-gt-“1”-“2”-“3”" class="headerlink" title="数字转为列表  123 -&gt; [“1”, “2”, “3”]"></a>数字转为列表  123 -&gt; [“1”, “2”, “3”]</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">123</span></span><br><span class="line">A = list(str(num))  <span class="comment"># A = ['1', '2', '3']</span></span><br><span class="line">B = int(<span class="string">""</span>.join(A))  <span class="comment"># B = 123</span></span><br></pre></td></tr></table></figure>
<h3 id="中括号-for循环生成列表，，并使用判断"><a href="#中括号-for循环生成列表，，并使用判断" class="headerlink" title="中括号 for循环生成列表，，并使用判断"></a>中括号 for循环生成列表，，并使用判断</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">-7</span>,<span class="number">0</span>,]</span><br><span class="line">a = [<span class="number">1</span> <span class="keyword">if</span> num &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> num <span class="keyword">in</span> nums]</span><br><span class="line">print(a)   <span class="comment"># [1, 1, 0, 0]</span></span><br></pre></td></tr></table></figure>
<h2 id="python内置函数的复杂度"><a href="#python内置函数的复杂度" class="headerlink" title="python内置函数的复杂度"></a>python内置函数的复杂度</h2><p><a href="https://wiki.python.org/moin/TimeComplexity" target="_blank" rel="noopener">https://wiki.python.org/moin/TimeComplexity</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python 函数</title>
    <url>/2019/04/10/python-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>python基础： 深入理解 python 中的赋值、引用、拷贝、作用域</title>
    <url>/2019/03/12/python%E5%9F%BA%E7%A1%80%EF%BC%9A-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-python-%E4%B8%AD%E7%9A%84%E8%B5%8B%E5%80%BC%E3%80%81%E5%BC%95%E7%94%A8%E3%80%81%E6%8B%B7%E8%B4%9D%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h3 id="浅复制："><a href="#浅复制：" class="headerlink" title="浅复制："></a>浅复制：</h3><ul>
<li>仅复制对象的引用，而不开辟内存，即，改变复制后的对象时，其实是在改变原对象内存中的内容。</li>
<li>b = a[ : ]<h3 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a>深复制</h3>将开辟新的内存，把原对象内存中的内容复制到新的内存中来，如果改变复制后的对象，将改变原对象的内容。即，这两个对象在完成复制之后，已经是两个独立的对象了</li>
</ul>
<p><strong>- 转载： <a href="https://draapho.github.io/2016/11/21/1618-python-variable/" target="_blank" rel="noopener">https://draapho.github.io/2016/11/21/1618-python-variable/</a></strong></p>
<h3 id="可变对象：list-dict-set-（引用传递）"><a href="#可变对象：list-dict-set-（引用传递）" class="headerlink" title="可变对象：list dict set  （引用传递）"></a>可变对象：list dict set  （引用传递）</h3><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">   <span class="meta"># list</span></span><br><span class="line">a= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">9</span></span><br><span class="line"><span class="keyword">print</span>(b) <span class="meta"># [9, 2, 3]</span></span><br><span class="line"><span class="keyword">print</span>(a) <span class="meta"># [9, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># dict</span></span><br><span class="line">a = &#123;&#125;</span><br><span class="line">a['key1'] = <span class="number">1</span></span><br><span class="line">b = a</span><br><span class="line">b['key1'] = <span class="number">9</span></span><br><span class="line"><span class="keyword">print</span>(b) <span class="meta"># &#123;'key1': 9&#125;</span></span><br><span class="line"><span class="keyword">print</span>(a) <span class="meta"># &#123;'key1': 9&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]  </span><br><span class="line">values[<span class="number">1</span>] = values  </span><br><span class="line">values  </span><br><span class="line">[<span class="number">0</span>, [...], <span class="number">2</span>] # 实际结果, 为何要赋值无限次?  </span><br><span class="line">[<span class="number">0</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="number">2</span>] # 预想结果</span><br></pre></td></tr></table></figure>
<p>   Python 没有赋值，只有引用。你这样相当于创建了一个引用自身的结构，所以导致了无限循环</p>
<h3 id="不可变对象：tuple-string-int-float-bool-（值传递）"><a href="#不可变对象：tuple-string-int-float-bool-（值传递）" class="headerlink" title="不可变对象：tuple string int float bool （值传递）"></a>不可变对象：<strong><em>tuple</em></strong> string int float bool （值传递）</h3><p>对于可变对象，对象的操作不会重建对象，而对于不可变对象，每一次操作就重建新的对象。</p>
<pre><code>def func_int(a):
    a += 4

def func_list(a_list):
    a_list[0] = 4

t = 0
func_int(t)
print t
# output: 0

t_list = [1, 2, 3]
func_list(t_list)
print t_list
# output: [4, 2, 3]
</code></pre><h3 id="Dictionary-与-List-与-Tuple的区别"><a href="#Dictionary-与-List-与-Tuple的区别" class="headerlink" title="Dictionary 与 List 与 Tuple的区别"></a>Dictionary 与 List 与 Tuple的区别</h3><p>元组和列表在结构上没有什么区别，唯一的差异在于元组是只读的，不能修改。</p>
<p><strong>Dictionary</strong> </p>
<ol>
<li>Dictionary 是 Python 的内置数据类型之一, 它定义了键和值之间一对一的关系。</li>
<li>每一个元素都是一个 key-value 对, 整个元素集合用大括号括起来</li>
<li>您可以通过 key 来引用其值, 但是不能通过值获取 key</li>
<li>在一个 dictionary 中不能有重复的 key。给一个存在的 key 赋值会覆盖原有的值。 <a href="file:///home/echo/.chmsee/bookshelf/4791a2294b7b1d4cf68b0e1df606181d/native_data_types/index.html#odbchelper.dict.2.2" target="_blank" rel="noopener"><img src="file:///home/echo/.chmsee/bookshelf/4791a2294b7b1d4cf68b0e1df606181d/images/callouts/2.png" alt="2"></a> 在任何时候都可以加入新的 key-value 对。这种语法同修改存在的值是一样的。</li>
<li>当使用 dictionary 时, 您需要知道: dictionary 的 key 是大小写敏感的</li>
<li>Dictionary 不只是用于存储字符串。Dictionary 的值可以是任意数据类型, 包括字符串, 整数, 对象, 甚至其它的 dictionary。在单个 dictionary 里, dictionary 的值并不需要全都是同一数据类型, 可以根据需要混用和匹配。 Dictionary 的 key 要严格多了, 但是它们可以是字符串, 整数和几种其它的类型 (后面还会谈到这一点) 。也可以在一个 dictionary 中混用和配匹 key 的数据类型</li>
<li><code>del</code> 允许您使用 key 从一个 dictionary 中删除独立的元素。</li>
<li><code>clear</code> 从一个 dictionary 中清除所有元素。注意空的大括号集合表示一个没有元素的 dictionary。</li>
</ol>
<hr>
<p><strong>List</strong> </p>
<ol>
<li>list是一个使用方括号括起来的有序元素集合。</li>
<li>List 可以作为以 0 下标开始的数组。任何一个非空 list 的第一个元素总是 <code>li[0]</code></li>
<li><code>负数索引从 list 的尾部开始向前计数来存取元素。任何一个非空的 list 最后一个元素总是</code> li[-1]。 <a href="file:///home/echo/.chmsee/bookshelf/4791a2294b7b1d4cf68b0e1df606181d/native_data_types/lists.html#odbchelper.list.2.2" target="_blank" rel="noopener"><img src="file:///home/echo/.chmsee/bookshelf/4791a2294b7b1d4cf68b0e1df606181d/images/callouts/2.png" alt="2"></a>如果负数索引使您感到糊涂, 可以这样理解: <code>li[-n] == li[len(li) - n]</code>。 所以在这个 list 里, <code>li[-3] == li[5 - 3] == li[2]</code>。</li>
<li><code>您可以通过指定 2 个索引得到 list 的子集, 叫做一个 “slice” 。返回值是一个新的 list, 它包含了 list 中按顺序从第一个 slice 索引 (这里为</code> li[1]) 开始, 直到但是不包括第二个 slice 索引 (这里为<code>li[3]</code>) 的所有元素。</li>
<li><code>如果将两个分片索引全部省略, 这将包括 list 的所有元素。但是与原始的名为</code> li 的 list 不同, 它是一个新 list, 恰好拥有与 <code>li</code> 一样的全部元素。<code>li[:]</code> 是生成一个 list 完全拷贝的一个简写。</li>
<li><code>``append</code> 向 list 的末尾追加单个元素。</li>
<li><code>insert</code> 将单个元素插入到 list 中。数值参数是插入点的索引。请注意, list 中的元素不必唯一, 有有两个独立的元素具有 <code>&#39;new&#39;</code> 这个相同的值<code>。</code></li>
<li><code>extend</code> 用来连接 list。请注意不要使用多个参数来调用 <code>extend</code>, 要使用一个 list 参数进行调用。</li>
<li>Lists 的两个方法 <code>extend</code> 和 <code>append</code> 看起来类似, 但实际上完全不同。 <code>extend</code> 接受一个参数, 这个参数总是一个 list, 并且添加这个 list 中的每个元素到原 list 中</li>
<li>另一方面, <code>append</code> 接受一个参数, 这个参数可以是任何数据类型, 并且简单地追加到 list 的尾部。 在这里使用一个含有 3 个元素的 list 参数调用 <code>append</code> 方法。</li>
<li><code>index</code> 在 list 中查找一个值的首次出现并返回索引值。</li>
<li>要测试一个值是否在 list 内, 使用 <code>in</code>, 如果值存在, 它返回 <code>True</code>, 否则返为 <code>False</code> 。</li>
<li><code>remove</code> 从 list 中删除一个值的首次出现。</li>
<li><code>pop</code> 是一个有趣的东西。它会做两件事: 删除 list 的最后一个元素, 然后返回删除元素的值。请注意, 这与 <code>li[-1]</code> 不同, 后者返回一个值但不改变 list 本身。也不同于 <code>li.remove(*value*)</code>, 后者改变 list 但并不返回值。</li>
<li>Lists 也可以用 <code>+</code> 运算符连接起来。 <code>*list* = *list* + *otherlist*</code> 相当于 <code>*list*.extend(*otherlist*)</code>。 但 <code>+</code>运算符把一个新 (连接后) 的 list 作为值返回, 而 <code>extend</code> 只修改存在的 list。 也就是说, 对于大型 list 来说, <code>extend</code> 的执行速度要快一些。</li>
<li>Python 支持 <code>+=</code> 运算符。 <code>li += [&#39;two&#39;]</code> 等同于 <code>li.extend([&#39;two&#39;])</code>。 <code>+=</code> 运算符可用于 list, 字符串和整数, 并且它也可以被重载用于用户自定义的类中。</li>
<li><code>*</code> 运算符可以作为一个重复器作用于 list。 <code>li = [1, 2] * 3</code> 等同于 <code>li = [1, 2] + [1, 2] + [1, 2]</code>, 即将三个 list 连接成一个。</li>
</ol>
<hr>
<p><strong>Tuple</strong></p>
<ol>
<li>​    Tuple是不可变的list.一是创建了一个tuple就不能以任何方式改变它.</li>
<li>​    定义tuple与定义list的方式相同,除了整个元素集是用小括号包围的而不是方括号.</li>
<li>　 Tuple的元素与list一样按定义的次序进行排序.Tuples的索引与list一样从0开始,所以一个非空的tuple的第一个元素总是t[0].</li>
<li>​    负数索引与 list 一样从 tuple 的尾部开始计数。</li>
<li>​    与 list 一样分片 (slice) 也可以使用。注意当分割一个 list 时, 会得到一个新的 list ；当分割一个 tuple 时, 会得到一个新的 tuple。</li>
<li>​    Tuple 没有方法：没有 <code>append</code> 或 <code>extend</code> 方法、没有 <code>remove</code> 或 <code>pop</code> 方法、没有 <code>index</code> 方法、可以使用 <code>in</code> 来查看一个元素是否存在于 tuple 中。</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python类的继承</title>
    <url>/2019/04/08/python%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<ul>
<li>参考：<a href="https://www.cnblogs.com/bigberg/p/7182741.html" target="_blank" rel="noopener">https://www.cnblogs.com/bigberg/p/7182741.html</a>  </li>
</ul>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><h3 id="1-继承的定义"><a href="#1-继承的定义" class="headerlink" title="1. 继承的定义"></a>1. 继承的定义</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span>   <span class="comment"># 定义一个父类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span>    <span class="comment"># 父类中的方法</span></span><br><span class="line">        print(<span class="string">"person is talking...."</span>)  </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span><span class="params">(Person)</span>:</span>    <span class="comment"># 定义一个子类， 继承Person类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">walk</span><span class="params">(self)</span>:</span>      <span class="comment"># 在子类中定义其自身的方法</span></span><br><span class="line">        print(<span class="string">'is walking...'</span>)</span><br><span class="line"> </span><br><span class="line">c = Chinese()</span><br><span class="line">c.talk()      <span class="comment"># 调用继承的Person类的方法</span></span><br><span class="line">c.walk()     <span class="comment"># 调用本身的方法</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<blockquote>
<p>person is talking….<br>is walking…</p>
<h2 id="2-构造函数的继承"><a href="#2-构造函数的继承" class="headerlink" title="2. 构造函数的继承"></a>2. 构造函数的继承</h2><p>如果我们要给实例 c 传参，我们就要使用到构造函数，那么构造函数该如何继承，同时子类中又如何定义自己的属性？</p>
</blockquote>
<p>继承类的构造方法：<br>1.经典类的写法： 父类名称.<strong>init</strong>(self,参数1，参数2，…)  </p>
<ol>
<li><font color="#0059ff" size="5" face="黑体"> 新式类的写法：super(子类，self).__init__(参数1，参数2，....)</font>

</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span>  </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span>  </span><br><span class="line">        self.name = name  </span><br><span class="line">        self.age = age  </span><br><span class="line">        self.weight = <span class="string">'weight'</span>  </span><br><span class="line">  </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        print(<span class="string">"person is talking...."</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span><span class="params">(Person)</span>:</span>  </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, language)</span>:</span>  <span class="comment"># 先继承，在重构  </span></span><br><span class="line">		Person.__init__(self, name, age)  </span><br><span class="line">		<span class="comment"># 继承父类的构造方法，也可以写成：</span></span><br><span class="line">		<span class="comment"># super(Chinese,self).__init__(name,age)  </span></span><br><span class="line">        self.language = language  <span class="comment"># 定义类的本身属性  </span></span><br><span class="line">  </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">walk</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        print(<span class="string">'is walking...'</span>)  </span><br><span class="line">        </span><br><span class="line">c = Chinese(<span class="string">'bigberg'</span>, <span class="number">22</span>, <span class="string">'Chinese'</span>)  </span><br><span class="line">print(c.name)  </span><br><span class="line">print(c.language)</span><br><span class="line">c.talk()</span><br></pre></td></tr></table></figure>
<p>输出</p>
<blockquote>
<p>bigberg<br>Chinese<br>person is talking….</p>
</blockquote>
<h3 id="3-子类对父类方法的重写"><a href="#3-子类对父类方法的重写" class="headerlink" title="3.子类对父类方法的重写"></a>3.子类对父类方法的重写</h3><p>如果我们对基类/父类的方法需要修改，可以在子类中重构该方法。如下的talk()方法<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span>  </span><br><span class="line">        self.name = name  </span><br><span class="line">        self.age = age  </span><br><span class="line">        self.weight = <span class="string">'weight'</span>  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        print(<span class="string">"person is talking...."</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span><span class="params">(Person)</span>:</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, language)</span>:</span>  </span><br><span class="line">        Person.__init__(self, name, age)  </span><br><span class="line">        self.language = language  </span><br><span class="line">        print(self.name, self.age, self.weight, self.language)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span>  <span class="comment"># 子类 重构方法  </span></span><br><span class="line">  print(<span class="string">'%s is speaking chinese'</span> % self.name)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">walk</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        print(<span class="string">'is walking...'</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">c = Chinese(<span class="string">'bigberg'</span>, <span class="number">22</span>, <span class="string">'Chinese'</span>)  </span><br><span class="line">c.talk()</span><br></pre></td></tr></table></figure></p>
<p>输出</p>
<blockquote>
<p>bigberg 22 weight Chinese<br>bigberg is speaking chinese</p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python  面试</title>
    <url>/2019/03/12/python-%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p><a href="https://juejin.im/post/5b6bc1d16fb9a04f9c43edc3" target="_blank" rel="noopener">https://juejin.im/post/5b6bc1d16fb9a04f9c43edc3</a></p>
<p><a href="https://juejin.im/post/5b8505b6e51d4538884d22bf" target="_blank" rel="noopener">https://juejin.im/post/5b8505b6e51d4538884d22bf</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础知识-try与except处理异常语句</title>
    <url>/2019/03/19/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-try%E4%B8%8Eexcept%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h2 id="try-except介绍"><a href="#try-except介绍" class="headerlink" title="try/except介绍"></a>try/except介绍</h2><blockquote>
<p>与其他语言相同，在python中，try/except语句主要是用于处理程序正常执行过程中出现的一些异常情况，如语法错（python作为脚本语言没有编译的环节，在执行过程中对语法进行检测，出错后发出异常消息）、数据除零错误、从未定义的变量上取值等；而try/finally语句则主要用于在无论是否发生异常情况，都需要执行一些清理工作的场合，如在通信过程中，无论通信是否发生错误，都需要在通信完成或者发生错误时关闭网络连接。尽管<strong>try/except和**</strong>try/finally**的作用不同，但是在编程实践中通常可以把它们组合在一起使用try/except/else/finally的形式来实现稳定性和灵活性更好的设计。</p>
<p>默认情况下，在程序段的执行过程中，如果没有提供try/except的处理，脚本文件执行过程中所产生的异常消息会自动发送给程序调用端，如python shell，而python shell对异常消息的默认处理则是终止程序的执行并打印具体的出错信息。这也是在python shell中执行程序错误后所出现的出错打印信息的由来。</p>
</blockquote>
<h2 id="try-except格式"><a href="#try-except格式" class="headerlink" title="try/except格式"></a>try/except格式</h2><blockquote>
<p>python中try/except/else/finally语句的完整格式如下所示：</p>
<p>try:</p>
<p>​     Normal execution block</p>
<p>except A:</p>
<p>​     Exception A handle</p>
<p>except B:</p>
<p>​     Exception B handle</p>
<p>except:</p>
<p>​     Other exception handle</p>
<p>else:</p>
<p>​     if no exception,get here</p>
<p>finally:</p>
<p>​     print(“finally”)   </p>
<p>说明：</p>
<p>正常执行的程序在try下面的Normal execution block执行块中执行，在执行过程中如果发生了异常，则<strong>中断当前在Normal execution block中的执行</strong>，跳转到对应的异常处理块中开始执行；</p>
<p>python<strong>从第一个except X处开始查找</strong>，如果找到了对应的exception类型则进入其提供的exception handle中进行处理，如果没有找到则直接进入except块处进行处理。except块是可选项，如果没有提供，该exception将会被提交给python进行默认处理，处理方式则是<strong>终止应用程序并打印提示信息</strong>；</p>
<p>如果在Normal execution block执行块中执行过程中没有发生任何异常，则在执行完Normal execution block后会进入else执行块中（如果存在的话）执行。</p>
<p>无论是否发生了异常，只要提供了finally语句，以上try/except/else/finally代码块执行的最后一步总是执行finally所对应的代码块。</p>
<p>需要注意的是：</p>
<p>1.在上面所示的完整语句中try/except/else/finally所出现的顺序必须是try—&gt;except X—&gt;except—&gt;else—&gt;finally，即所有的<strong>except必须在else和finally之前</strong>，<strong>else（如果有的话）必须在finally之前</strong>，而<strong>except X必须在except之前</strong>。否则会出现语法错误。</p>
<p>2.对于上面所展示的try/except完整格式而言，else和finally都是可选的，而不是必须的，但是如果存在的话e<strong>lse必须在finally之前</strong>，<strong>finally</strong>（如果存在的话）<strong>必须在整个语句的最后位置</strong>。</p>
<p>3.在上面的完整语句中，else语句的存在必须以except X或者except语句为前提，<strong>如果在没有except语句的try block中使用else语句会引发语法错误</strong>。也就是说<strong>else不能与try/finally配合使用</strong>。</p>
</blockquote>
<p>4.except的使用要非常小心，慎用。</p>
<p>class AError(Exception):<br>     “””AError—-exception”””<br>     print(‘AError’)</p>
<blockquote>
<p>try:</p>
<p>​     #raise AError</p>
<p>​     asdas(‘123’)</p>
<p>except AError:</p>
<p>​     print(“Get AError”)</p>
<p>except:</p>
<p>​     print(“exception”)     </p>
<p>else:</p>
<p>​     print(“else”)</p>
<p>finally:</p>
<p>​     print(“finally”)     </p>
<p>print(“hello wolrd”)</p>
<p>在上面的代码中，Normal execution block中出现了语法错误，但是由于使用了except语句，该语法错误就被掩盖掉了。因此在使用try/except是最好还是要非常清楚的知道Normal execution block中有可能出现的异常类型以进行针对性的处理。</p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch-Multi-Gpus</title>
    <url>/2019/03/02/pytorch-Multi-Gpus/</url>
    <content><![CDATA[<ul>
<li>源为pytorch的官方文档</li>
<li><a href="https://pytorch.org/tutorials/beginner/blitz/data_parallel_tutorial.html" target="_blank" rel="noopener">website</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset, DataLoader</span><br><span class="line"></span><br><span class="line"><span class="comment"># Parameters and DataLoaders</span></span><br><span class="line">input_size = <span class="number">5</span></span><br><span class="line">output_size = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">30</span></span><br><span class="line">data_size = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="comment"># Our model</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_size, output_size)</span>:</span></span><br><span class="line">        super(Model, self).__init__()</span><br><span class="line">        self.fc = nn.Linear(input_size, output_size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, input)</span>:</span></span><br><span class="line">        output = self.fc(input)</span><br><span class="line">        print(<span class="string">"\tIn Model: input size"</span>, input.size(),</span><br><span class="line">              <span class="string">"output size"</span>, output.size())</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomDataset</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, size, length)</span>:</span></span><br><span class="line">        self.len = length</span><br><span class="line">        self.data = torch.randn(length, size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.data[index]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.len</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rand_loader = DataLoader(dataset=RandomDataset(input_size, data_size), batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">model = Model(input_size, output_size)</span><br><span class="line"><span class="keyword">if</span> torch.cuda.device_count() &gt; <span class="number">1</span>:</span><br><span class="line">    print(<span class="string">"Let's use"</span>, torch.cuda.device_count(), <span class="string">"GPUs!"</span>)</span><br><span class="line">    <span class="comment"># dim = 0 [30, xxx] -&gt; [10, ...], [10, ...], [10, ...] on 3 GPUs</span></span><br><span class="line">    model = nn.DataParallel(model)</span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">"cuda:0"</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line">model.to(device)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> rand_loader:</span><br><span class="line">    input = data.to(device)</span><br><span class="line">    output = model(input)</span><br><span class="line">    print(<span class="string">"Outside: input size"</span>, input.size(),</span><br><span class="line">          <span class="string">"output_size"</span>, output.size())</span><br></pre></td></tr></table></figure>
<h2 id="转载：-PyTorch-论文pytorch复现中遇到的BUG"><a href="#转载：-PyTorch-论文pytorch复现中遇到的BUG" class="headerlink" title="转载：[PyTorch]论文pytorch复现中遇到的BUG]"></a>转载：<a href="https://www.cnblogs.com/kk17/p/10139884.html" target="_blank" rel="noopener">[PyTorch]论文pytorch复现中遇到的BUG]</a></h2><ul>
<li>我在Multi-GPUs时，也遇到了第一个问题</li>
</ul>
<p>目录</p>
<ul>
<li><a href="https://www.cnblogs.com/kk17/p/10139884.html#zip-argument-1-must-support-iteration" target="_blank" rel="noopener">1. zip argument #1 must support iteration</a></li>
<li><a href="https://www.cnblogs.com/kk17/p/10139884.html#torch.nn.dataparallel" target="_blank" rel="noopener">2. torch.nn.DataParallel</a></li>
<li><a href="https://www.cnblogs.com/kk17/p/10139884.html#model.state_dict" target="_blank" rel="noopener">3. model.state_dict()</a></li>
</ul>
<h1 id="1-zip-argument-1-must-support-iteration"><a href="#1-zip-argument-1-must-support-iteration" class="headerlink" title="1. zip argument #1 must support iteration"></a>1. zip argument #1 must support iteration</h1><p>在多gpu训练的时候，自动把你的batch_size分成n_gpu份，每个gpu跑一些数据， 最后再合起来。我之所以出现这个bug是因为返回的时候 返回了一个常量。。</p>
<h1 id="2-torch-nn-DataParallel"><a href="#2-torch-nn-DataParallel" class="headerlink" title="2. torch.nn.DataParallel"></a>2. torch.nn.DataParallel</h1><p>在使用torch.nn.DataParallel时候，要先把模型放在gpu上，再进行parallel。</p>
<h1 id="3-model-state-dict"><a href="#3-model-state-dict" class="headerlink" title="3. model.state_dict()"></a>3. model.state_dict()</h1><p>一般在现有的网络加载预训练模型通常是找到预训练模型在现有的model里面的参数，然后model进行更新，遇到一个bug， 发现加载预训练模型的时候， 效果很差，跟参数没有更新一样，找了一大顿bug，最后才发现，之前是单gpu进行的预训练，现在的模型使用的是多gpu， 打印现在模型的参数你会发现他所有的参数前面都加了一个module. 所以向以前一样更新，没有一个参数会被更新，因此写了一个万能模型参数加载函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pretrained_dict = checkpoint[<span class="string">'state_dict'</span>]</span><br><span class="line">model_dict = self.model.state_dict()</span><br><span class="line"><span class="keyword">if</span> checkpoint[<span class="string">'config'</span>][<span class="string">'n_gpu'</span>] &gt; <span class="number">1</span> <span class="keyword">and</span> self.config[<span class="string">'n_gpu'</span>] == <span class="number">1</span>:</span><br><span class="line">    new_dict = OrderedDict()</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> pretrained_dict.items():</span><br><span class="line">        name = k[<span class="number">7</span>:]</span><br><span class="line">        new_dict[name] = v</span><br><span class="line">    pretrained_dict = new_dict</span><br><span class="line"><span class="keyword">elif</span> checkpoint[<span class="string">'config'</span>][<span class="string">'n_gpu'</span>] == <span class="number">1</span> <span class="keyword">and</span> self.config[<span class="string">'n_gpu'</span>] &gt; <span class="number">1</span>:</span><br><span class="line">    new_dict = OrderedDict()</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> pretrained_dict.items():</span><br><span class="line">        name = <span class="string">"module."</span>+k</span><br><span class="line">        new_dict[name] = v</span><br><span class="line">    pretrained_dict = new_dict</span><br><span class="line">print(<span class="string">"The pretrained model's para is following"</span>)</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> pretrained_dict.items():</span><br><span class="line">    print(k)</span><br><span class="line">pretrained_dict = &#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> pretrained_dict.items() <span class="keyword">if</span> k <span class="keyword">in</span> model_dict&#125;</span><br><span class="line">model_dict.update(pretrained_dict)</span><br><span class="line">self.model.load_state_dict(model_dict)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title> pytorch clone() vs copy_()</title>
    <url>/2019/08/06/pytorch-clone-vs-copy/</url>
    <content><![CDATA[<p><code>clone</code>() → Tensor</p>
<ul>
<li>反向传播时，将会返回到原来的变量上<br>Returns a copy of the <code>self</code> tensor. The copy has the same size and data type as <code>self</code>.</li>
<li>NOTE</li>
<li>Unlike copy_(), this function is recorded in the computation graph. Gradients propagating to the cloned tensor will propagate to the original tensor.</li>
</ul>
<hr>
<p><code>copy_</code>(<em>src</em>, <em>non_blocking=False</em>) → Tensor</p>
<ul>
<li><p>只是值得复制<br>Copies the elements from <code>src</code> into <code>self</code> tensor and returns <code>self</code>.</p>
</li>
<li><p>The <code>src</code> tensor must be <a href="https://pytorch.org/docs/stable/notes/broadcasting.html#broadcasting-semantics" target="_blank" rel="noopener">broadcastable</a> with the <code>self</code> tensor. It may be of a different data type or reside on a different device.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch 减小显存消耗，优化显存使用，避免out of memory</title>
    <url>/2019/04/03/pytorch-%E5%87%8F%E5%B0%8F%E6%98%BE%E5%AD%98%E6%B6%88%E8%80%97%EF%BC%8C%E4%BC%98%E5%8C%96%E6%98%BE%E5%AD%98%E4%BD%BF%E7%94%A8%EF%BC%8C%E9%81%BF%E5%85%8Dout-of-memory/</url>
    <content><![CDATA[<h3 id="本文是整理了大神的两篇博客："><a href="#本文是整理了大神的两篇博客：" class="headerlink" title="本文是整理了大神的两篇博客："></a>本文是整理了大神的两篇博客：</h3><ul>
<li><p>如何计算模型以及中间变量的显存占用大小：<br><a href="https://oldpan.me/archives/how-to-calculate-gpu-memory" target="_blank" rel="noopener">https://oldpan.me/archives/how-to-calculate-gpu-memory</a></p>
</li>
<li><p>如何在Pytorch中精细化利用显存：<br><a href="https://oldpan.me/archives/how-to-use-memory-pytorch" target="_blank" rel="noopener">https://oldpan.me/archives/how-to-use-memory-pytorch</a></p>
</li>
<li><p>还有知乎中大神的解答：<br><a href="https://zhuanlan.zhihu.com/p/31558973" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31558973</a></p>
</li>
<li><p>ppt<br><a href="https://www.zhihu.com/question/67209417" target="_blank" rel="noopener">https://www.zhihu.com/question/67209417</a></p>
</li>
<li><p>在说之前先推荐一个实时监控内存显存使用的小工具：</p>
</li>
</ul>
<blockquote>
<p>sudo apt-get install htop</p>
</blockquote>
<ul>
<li>监控内存（-d为更新频率，下为每0.1s更新一次）：</li>
</ul>
<blockquote>
<p>htop -d=0.1</p>
</blockquote>
<ul>
<li>监控显存（-n为更新频率，下为每0.1s更新一次）：</li>
</ul>
<blockquote>
<p>watch -n 0.1 nvidia-smi</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>pytorch-gather</title>
    <url>/2019/07/12/pytorch-gather/</url>
    <content><![CDATA[<p>函数<code>torch.gather(input, dim, index, out=None) → Tensor</code><br> 沿给定轴 dim ,将输入索引张量 index 指定位置的值进行聚合.<br> 对一个 3 维张量,输出可以定义为:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">out[<span class="string">i</span>][<span class="symbol">j</span>][<span class="string">k</span>] = input[<span class="string">index[i</span>][<span class="symbol">j</span>][<span class="string">k</span>]][<span class="string">j</span>][<span class="symbol">k</span>]  # if dim == 0</span><br><span class="line">out[<span class="string">i</span>][<span class="symbol">j</span>][<span class="string">k</span>] = input[<span class="string">i</span>][<span class="symbol">index[i</span>][<span class="string">j</span>][<span class="symbol">k</span>]][<span class="symbol">k</span>]  # if dim == 1</span><br><span class="line">out[<span class="string">i</span>][<span class="symbol">j</span>][<span class="string">k</span>] = input[<span class="string">i</span>][<span class="symbol">j</span>][<span class="string">index[i</span>][<span class="symbol">j</span>][<span class="string">k</span>]]  # if dim == 2</span><br></pre></td></tr></table></figure>
<p>Parameters:</p>
<ul>
<li>input (Tensor) – 源张量</li>
<li>dim (int) – 索引的轴</li>
<li>index (LongTensor) – 聚合元素的下标(index需要是torch.longTensor类型)</li>
<li>out (Tensor, optional) – 目标张量</li>
</ul>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch 索引 切片</title>
    <url>/2019/10/10/pytorch-%E7%B4%A2%E5%BC%95-%E5%88%87%E7%89%87/</url>
    <content><![CDATA[<h2 id="给出：四维张量，三维的索引。根据索引得到张量中对应的数据"><a href="#给出：四维张量，三维的索引。根据索引得到张量中对应的数据" class="headerlink" title="给出：四维张量，三维的索引。根据索引得到张量中对应的数据"></a>给出：四维张量，三维的索引。根据索引得到张量中对应的数据</h2><ul>
<li><p>四维张量，object_feats.shape = [bs, 28, 5, 1024]。一个video中截取 28帧，每帧提取5个object, 其特征向量维度为1024</p>
</li>
<li><p>三维索引，traj_idx.shape = [bs, 28, 5]。以第一帧 frame上的 5个object 作为anchor，找到以该anchor 作为开头的轨迹（即，在其余帧上的对应的objects的索引），</p>
</li>
<li><p>目标：由索引，提取对应的 object feature</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">traj_feats = object_feats.gather(<span class="number">2</span>, traj_idx.unsqueeze(<span class="number">3</span>).expand_as(object_feats))</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch0.4.0学习</title>
    <url>/2019/04/18/pytorch0-4-0%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="不会的"><a href="#不会的" class="headerlink" title="不会的"></a>不会的</h2><ol>
<li>SGD 、 Adam中 的weight_decay 是干嘛的</li>
<li>SGD 中的 momentum是干嘛的，一般设置为多大</li>
<li>pytorch 中的初始化函数 </li>
<li>y = y.permute(0, 2, 1).contiguous()<br>这是干嘛的</li>
</ol>
<h3 id="学会的"><a href="#学会的" class="headerlink" title="学会的"></a>学会的</h3><ul>
<li>累加loss<br>以前（0.3.0）了累加loss(为了看loss的大小)一般是用total_loss+=loss.data[0] , 比较诡异的是, 为啥是.data[0]? 这是因为, 这是因为loss是一个Variable,<br>所以以后累加loss, 用loss.item().这个是必须的, 如果直接加, 那么随着训练的进行, 会导致后来的loss具有非常大的graph, 可能会超内存.<br>然而total_loss只是用来看的, 所以没必要进行维持这个graph!</li>
</ul>
<h3 id="pytorch-中-对tensor的一些函数"><a href="#pytorch-中-对tensor的一些函数" class="headerlink" title="pytorch 中 对tensor的一些函数"></a>pytorch 中 对tensor的一些函数</h3><ul>
<li><p>生成正态分布的随机张量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.randn(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)  <span class="comment"># 正态分布的随机张量</span></span><br><span class="line">a.sum()                 <span class="comment"># 对a中的元素求和</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对tensor 求最大值</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="keyword">a</span> = torch.randn(<span class="number">10</span>,<span class="number">8</span>)</span><br><span class="line">max_value, max_index = <span class="keyword">a</span>.<span class="built_in">max</span>(<span class="number">1</span>)   </span><br><span class="line"><span class="comment"># 按照维度对a求最大值 ，此处为1，即得到（10,1）的张量，</span></span><br><span class="line"><span class="comment"># 有两个返回值，第一个返回值为具体的最大值为多少，第二个返回值为该最大值所在的索引</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>判断两数有多少个元素相等</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">a = torch.tensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">b = torch.tensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>])</span><br><span class="line">a.eq(b)   # 输出 tensor([ <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">0</span>], dtype=torch.uint8)</span><br></pre></td></tr></table></figure>
</li>
<li><p>批矩阵相乘</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"># 批矩阵相乘 pytorch <span class="number">0.3</span><span class="number">.0</span></span><br><span class="line">output = torch.bmm(W, x)</span><br><span class="line"></span><br><span class="line"># 批矩阵相乘 pytorch <span class="number">0.4</span><span class="number">.0</span></span><br><span class="line">a = torch.randn(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">b = torch.rand(<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">c = torch.matmul(a, b)</span><br><span class="line">print(c.shape)  # torch.Size([<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line"># 在pytorch <span class="number">0.4</span><span class="number">.0</span>中使用torch.matmul 输入的参数是两个<span class="number">3</span>d的tensor ,tensor的首个维度是batch_size</span><br></pre></td></tr></table></figure>
</li>
<li><p>tensor 两个维度转置</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"># tensor 两个维度转置</span><br><span class="line">x = torch.randn(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">x = x.permute(<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">print(x.shape)  # torch.Size([<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>chunk  cat </p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">torch.cat(inputs, <span class="attribute">dimension</span>=0) → Tensor</span><br><span class="line"><span class="comment"># cat 是将多个tensor按照指定的维度拼接起来</span></span><br><span class="line">torch.chunk(tensor, chunks, <span class="attribute">dim</span>=0)</span><br><span class="line"><span class="comment"># chunk是将某个tensor按照指定的维度进行拆分成指定的块数</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="初始化函数"><a href="#初始化函数" class="headerlink" title="初始化函数"></a>初始化函数</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">import torch.nn as nn</span><br><span class="line">self.W = nn.Conv2d(in_channels=<span class="number">512</span>, out_channels=<span class="number">1024</span>, kernel_size=(<span class="number">3</span>,<span class="number">3</span>), \</span><br><span class="line">                   padding=(<span class="number">1</span>,<span class="number">1</span>), stride=(<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">nn.init.kaiming.normal(self.W.weight)</span><br><span class="line">nn.init.kaiming.uniform(self.W.weight)</span><br><span class="line">nn.init.constant(self.W.bias, <span class="number">0</span>)</span><br><span class="line"># 输出 tensor([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>self.training in pytorch</title>
    <url>/2019/04/07/self-training-in-pytorch/</url>
    <content><![CDATA[<ul>
<li>代码来源于：<a href="https://zhuanlan.zhihu.com/p/26893755" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26893755</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable, Function</span><br><span class="line"></span><br><span class="line">x_train = np.array([[<span class="number">3.3</span>], [<span class="number">4.4</span>], [<span class="number">5.5</span>], [<span class="number">6.71</span>], [<span class="number">6.93</span>], [<span class="number">4.168</span>],</span><br><span class="line">                    [<span class="number">9.779</span>], [<span class="number">6.182</span>], [<span class="number">7.59</span>], [<span class="number">2.167</span>], [<span class="number">7.042</span>],</span><br><span class="line">                    [<span class="number">10.791</span>], [<span class="number">5.313</span>], [<span class="number">7.997</span>], [<span class="number">3.1</span>]], dtype=np.float32)</span><br><span class="line"></span><br><span class="line">y_train = np.array([[<span class="number">1.7</span>], [<span class="number">2.76</span>], [<span class="number">2.09</span>], [<span class="number">3.19</span>], [<span class="number">1.694</span>], [<span class="number">1.573</span>],</span><br><span class="line">                    [<span class="number">3.366</span>], [<span class="number">2.596</span>], [<span class="number">2.53</span>], [<span class="number">1.221</span>], [<span class="number">2.827</span>],</span><br><span class="line">                    [<span class="number">3.465</span>], [<span class="number">1.65</span>], [<span class="number">2.904</span>], [<span class="number">1.3</span>]], dtype=np.float32)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x_train = torch.from_numpy(x_train)</span><br><span class="line">y_train = torch.from_numpy(y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"---------------------------------------"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearRegression</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(LinearRegression, self).__init__()</span><br><span class="line">        self.linear = nn.Linear(<span class="number">1</span>, <span class="number">1</span>)  <span class="comment"># input and output is 1 dimension</span></span><br><span class="line">        print(<span class="string">"self.training: "</span> + str(self.training))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        out = self.linear(x)</span><br><span class="line">        print(<span class="string">"self.training；"</span> + str(self.training))</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">print(<span class="string">"initialize"</span>)</span><br><span class="line">model = LinearRegression()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"---------------------------------------"</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"model.eval()"</span>)</span><br><span class="line">model.eval()</span><br><span class="line">inputs = Variable(x_train)</span><br><span class="line">target = Variable(y_train)</span><br><span class="line"><span class="comment"># forward</span></span><br><span class="line">out = model(inputs) <span class="comment"># 前向传播</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"---------------------------------------"</span>)</span><br><span class="line">print(<span class="string">"model.train()"</span>)</span><br><span class="line">model.train()</span><br><span class="line">inputs = Variable(x_train)</span><br><span class="line">target = Variable(y_train)</span><br><span class="line"><span class="comment"># forward</span></span><br><span class="line">out = model(inputs) <span class="comment"># 前向传播</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>shiyaya-Instruction-Final-bilibili</title>
    <url>/2020/09/17/shiyaya-Instruction-Final-bilibili/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>self-attention</title>
    <url>/2019/06/16/self-attention/</url>
    <content><![CDATA[<ul>
<li>一篇解读：<a href="https://kexue.fm/archives/4765" target="_blank" rel="noopener">https://kexue.fm/archives/4765</a></li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>range xrange np.arange np.linspace</title>
    <url>/2019/04/05/range-xrange-np-arange-np-linspace/</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1rmpadk75j309a07saa2.jpg"></p>
<p>python</p>
<ul>
<li>xrange 得到一个迭代器，（仅可以在python2中使用）</li>
<li>range 得到一个列表，（python2/python3均可）</li>
</ul>
<p>numpy</p>
<ul>
<li>numpy.arange 得到一份数组</li>
<li>numpy.linspace <strong>得到固定数量的等间隔数组，注意包含指定的尾部</strong></li>
</ul>
]]></content>
      <categories>
        <category>python</category>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorboard_logger</title>
    <url>/2019/04/06/tensorboard-logger/</url>
    <content><![CDATA[<p>使用tensorboard_logger记录训练过程中的数据<br>（1）首先需要安装tensorflow</p>
<ul>
<li>可参考<a href="https://blog.csdn.net/love666666shen/article/details/77099843" target="_blank" rel="noopener">https://blog.csdn.net/love666666shen/article/details/77099843</a></li>
<li>不需要单独设置一个tensorflow的环境，直接pip install 一个CPU 版本的即可</li>
<li>pip install —ignore-installed —upgrade <a href="https://storage.googleapis.com/tensorflow/windows/cpu/tensorflow-1.1.0-cp35-cp35m-win_amd64.whl" target="_blank" rel="noopener">https://storage.googleapis.com/tensorflow/windows/cpu/tensorflow-1.1.0-cp35-cp35m-win_amd64.whl</a></li>
</ul>
<p>（2）安装tensorboard</p>
<ul>
<li>pip install tensorboard</li>
</ul>
<p>（3）No scalar data was found的解决<br>只需将cmd目录cd进入日志文件存放的目录，再加载日志文件便可解决：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">e:</span><br><span class="line">cd logdir</span><br><span class="line">tensorboard <span class="attribute">--logdir</span>=E:\logdir <span class="attribute">--host</span>=127.0.0.1</span><br></pre></td></tr></table></figure></p>
<p><img src="https://i.loli.net/2019/09/05/7YODLiJAZ6aUTG4.png" alt="搜狗截图20190905112015.png"></p>
]]></content>
      <tags>
        <tag>tensorboard</tag>
      </tags>
  </entry>
  <entry>
    <title>torch.backends.cudnn.benchmark = true 使用情形</title>
    <url>/2019/04/03/torch-backends-cudnn-benchmark-true-%E4%BD%BF%E7%94%A8%E6%83%85%E5%BD%A2/</url>
    <content><![CDATA[<p><a href="https://www.pytorchtutorial.com/when-should-we-set-cudnn-benchmark-to-true/" target="_blank" rel="noopener">pytorch-torch.backends.cudnn.benchmark文档</a></p>
<ul>
<li>torch.backends.cudnn.benchmark<br>设置这个 flag 可以让内置的 cuDNN 的 auto-tuner 自动寻找最适合当前配置的高效算法，来达到优化运行效率的问题。</li>
</ul>
<p>应该遵循以下准则：</p>
<ul>
<li>如果网络的输入数据维度或类型上变化不大，设置  torch.backends.cudnn.benchmark = true  可以增加运行效率；</li>
<li>如果网络的输入数据在每次 iteration 都变化的话，会导致 cnDNN 每次都会去寻找一遍最优配置，这样反而会降低运行效率。</li>
<li>在程序刚开始加这条语句可以提升一点训练速度，没什么额外开销。</li>
<li>有时候可能是因为每次迭代都会引入点临时变量，会导致训练速度越来越慢，基本呈线性增长。<br>开发人员还不清楚原因，但如果周期性的使用torch.cuda.empty_cache()的话就可以解决这个问题。这个命令是清除没用的临时变量的。</li>
</ul>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu 安装 Stanford CoreNLP</title>
    <url>/2019/03/26/ubuntu-%E5%AE%89%E8%A3%85-Stanford-CoreNLP/</url>
    <content><![CDATA[<h3 id="安装java-jdk"><a href="#安装java-jdk" class="headerlink" title="安装java jdk"></a>安装java jdk</h3><ul>
<li><p>更新软件包列表：</p>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line">apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装openjdk-8-jdk：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">apt-<span class="builtin-name">get</span> install openjdk-8-jdk</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看java版本：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">java -<span class="built_in">version</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="下载并解压Stanford-coreNLP-包："><a href="#下载并解压Stanford-coreNLP-包：" class="headerlink" title="下载并解压Stanford coreNLP 包："></a>下载并解压Stanford coreNLP 包：</h3><ul>
<li>从这里下载<br><a href="https://stanfordnlp.github.io/CoreNLP/download.html" target="_blank" rel="noopener">https://stanfordnlp.github.io/CoreNLP/download.html</a><br>或者以命令行方式下载<blockquote>
<p>wget <a href="http://nlp.stanford.edu/software/stanford-corenlp-full-2018-02-27.zip" target="_blank" rel="noopener">http://nlp.stanford.edu/software/stanford-corenlp-full-2018-02-27.zip</a>  </p>
</blockquote>
</li>
</ul>
<ul>
<li><p>解压</p>
<blockquote>
<p>unzip stanford-corenlp-full-2018-02-27.zip</p>
</blockquote>
</li>
<li><p>转到文件目录</p>
</li>
</ul>
<blockquote>
<p>cd stanford-corenlp-full-2018-02-27/</p>
</blockquote>
<h3 id="配置环境变量："><a href="#配置环境变量：" class="headerlink" title="配置环境变量："></a>配置环境变量：</h3><p>把下列这行代码加到你的.bashrc里面(vim .bashrc)</p>
<blockquote>
<p> cd ~<br>vim .bashrc<br>export CLASSPATH=/path/to/stanford-corenlp-full-2018-02-27/stanford-corenlp-3.9.1.jar<br>source ~/.bashrc  ## 使之生效<br>把/path/to/替换为你保存stanford-corenlp-full-2016-10-31的地方的路径</p>
</blockquote>
<h3 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h3><blockquote>
<p>pip install stanfordcorenlp</p>
</blockquote>
<p>处理中文还需要下载中文的模型jar文件，然后放到stanford-corenlp-full-2018-02-27根目录下即可</p>
<p>wget <a href="http://nlp.stanford.edu/software/stanford-chinese-corenlp-2018-02-27-models.jar" target="_blank" rel="noopener">http://nlp.stanford.edu/software/stanford-chinese-corenlp-2018-02-27-models.jar</a></p>
<h3 id="检查自己是否装好了stanfordcorenlp"><a href="#检查自己是否装好了stanfordcorenlp" class="headerlink" title="检查自己是否装好了stanfordcorenlp"></a>检查自己是否装好了stanfordcorenlp</h3><p>进入python2或者python3</p>
<p>命令行下输入：</p>
<blockquote>
<p>python<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> stanfordcorenlp <span class="keyword">import</span> StanfordCoreNLP</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>能成功导入不报错，就是安装成功了。</p>
]]></content>
  </entry>
  <entry>
    <title>torch.no_grad</title>
    <url>/2019/07/17/torch-no-grad/</url>
    <content><![CDATA[<ul>
<li><a href="https://discuss.pytorch.org/t/model-eval-vs-with-torch-no-grad/19615/21" target="_blank" rel="noopener">https://discuss.pytorch.org/t/model-eval-vs-with-torch-no-grad/19615/21</a></li>
<li>with torch.no_grad()</li>
<li>可以减少内存，加快运行速度，同时可以使得batch_size 增大</li>
<li>但不是说非得必要</li>
</ul>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>video-caption-dataset</title>
    <url>/2019/02/22/video-caption-dataset/</url>
    <content><![CDATA[<h2 id="Youtube2Text-（MSVD）-1"><a href="#Youtube2Text-（MSVD）-1" class="headerlink" title="Youtube2Text （MSVD）[1]"></a>Youtube2Text （MSVD）[1]</h2><ul>
<li>这个数据集包含 1967个短视频，10-25s，平均时长为9s，视频包含不同的人，动物，动作，场景等。</li>
<li>每个视频由不同的人标注了多个句子，大约41 annotated sentences per clip，共有 80839 个sentences，平均每个句子有8个words，这些所有的句子中共包含近16000个 unique words。</li>
<li>caption中包括多国的语言进行描述，部分论文中采取只选用laguage = english 的caption 进行训练和测试[3][4]</li>
<li>采用的split根据 [2] ： 1,200 videos for training, 100 for validation and 670 for testing.<br><a href="https://github.com/ShiYaya/video_captioning/tree/master/MSVD" target="_blank" rel="noopener">我的整理</a></li>
</ul>
<ul>
<li>数据的下载：</li>
<li><a href="https://www.microsoft.com/en-us/download/details.aspx?spm=a2c4e.11153940.blogcont209612.6.42ba7e9eAA1K2o&amp;id=52422&amp;from=http%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fdownloads%2F38cf15fd-b8df-477e-a4e4-a4680caa75af%2Fdefault.aspx" target="_blank" rel="noopener">[website]</a></li>
<li>原数据：只给出了video_id,以及strart and end time , 若需要video数据，则需要自己通过url下载</li>
<li>某篇对于视频分析的总结，给出了<a href="https://github.com/sinyeratlantis/sinyeratlantis.github.io/blob/master/content/dl/%E8%A7%86%E9%A2%91%E5%88%86%E6%9E%90%E6%96%87%E7%8C%AE%E8%B0%83%E7%A0%94.md" target="_blank" rel="noopener">MSVD的下载链接</a>，可用，推荐(下载速度快，且video命名相对较好)☀☀&lt;/br&gt;<br><a href="http://www.cs.utexas.edu/users/ml/clamp/videoDescription/YouTubeClips.tar" target="_blank" rel="noopener">直接的下载链接</a><strong>[推荐]</strong></li>
<li>某篇github 含有MSVD(Youtube2Text)的<a href="https://github.com/yaoli/arctic-capgen-vid" target="_blank" rel="noopener">[preproceed dataset]</a>&lt;/br&gt;<br><a href="http://lisaweb.iro.umontreal.ca/transfert/lisa/users/yaoli/youtube2text_iccv15.zip" target="_blank" rel="noopener">直接的下载链接</a>(下载速度慢)</li>
<li>该篇github上含有<a href="https://github.com/ShiYaya/Video-Description-with-Spatial-Temporal-Attention#video-datas-and-pre-extracted-features-on-msvd-dataset" target="_blank" rel="noopener">MSVD数据集下载链接</a>&lt;/br&gt;<br><a href="https://www.multcloud.com/share/050e69cd-cab9-4ba3-a671-ed459341ab41" target="_blank" rel="noopener">直接的下载链接</a></li>
<li>对caption 常用的预处理: 1) verting all text to lower case, 2) tokenizing the sentences, 3) removing punctuation.</li>
</ul>
<h2 id="MSR-VTT-dataset"><a href="#MSR-VTT-dataset" class="headerlink" title="MSR-VTT dataset"></a>MSR-VTT dataset</h2><p>下载链接：<a href="https://www.mediafire.com/folder/h14iarbs62e7p/shared" target="_blank" rel="noopener">https://www.mediafire.com/folder/h14iarbs62e7p/shared</a></p>
<p>以下的链接可能不能用了 </p>
<p>共10000个video, 每个video有20个sentences, 共20万 video/sentence pair，10-30s居多</p>
<ul>
<li>split:  train:6513, val:497, test：2990</li>
<li>MSR-VTT dataset v2 , just video url: <a href="http://ms-multimedia-challenge.com/2017/dataset" target="_blank" rel="noopener">http://ms-multimedia-challenge.com/2017/dataset</a></li>
<li>author split train test val by himself and provied video data :<a href="https://github.com/xiadingZ/video-caption.pytorch" target="_blank" rel="noopener">https://github.com/xiadingZ/video-caption.pytorch</a>  &lt;/br&gt;<br><strong>下载这个数据集即可使用，但是还需要再找split!</strong>&lt;/br&gt;</li>
<li>MSR VTT 采用的split 是2016年提供的，<strong>目前科研广泛使用的都是2016年的</strong>。</li>
<li><a href="https://github.com/adi-dhal/In_Depth_Video_Analysis/tree/master/msr-vtt/2016" target="_blank" rel="noopener">[split]</a><br>MSR-VTT. Test video doesn’t have captions, so I spilit train-viedo to train/val/test. Extract and put them in <code>./data/</code> directory</li>
</ul>
<p>train-video: <a href="https://drive.google.com/file/d/1Qi6Gn_l93SzrvmKQQu-drI90L-x8B0ly/view?usp=sharing" target="_blank" rel="noopener">download link</a> &lt;/br&gt;<br>test-video: <a href="https://drive.google.com/file/d/10fPbEhD-ENVQihrRvKFvxcMzkDlhvf4Q/view?usp=sharing" target="_blank" rel="noopener">download link</a> &lt;/br&gt;<br>json info of train-video: <a href="https://drive.google.com/file/d/1LcTtsAvfnHhUfHMiI4YkDgN7lF1-_-m7/view?usp=sharing" target="_blank" rel="noopener">download link</a> &lt;/br&gt;<br>json info of test-video: <a href="https://drive.google.com/file/d/1Kgra0uMKDQssclNZXRLfbj9UQgBv-1YE/view?usp=sharing" target="_blank" rel="noopener">download link</a> &lt;/br&gt;</p>
<ul>
<li><p>download.py 可以下载MSR-VTT数据集(step by video)：<a href="https://github.com/OSUPCVLab/VideoToTextDNN" target="_blank" rel="noopener">[链接]</a></p>
</li>
<li><p>msr-vtt 2017 vs 2016<br>In the 2nd MSR Video to Language Challenge, we have combined the training set, validation set, and testing data in the 1st MSR Video to Language Challenge as the new training data. An additional test set of around 3K video clips will be released on June 1st as the final evaluation set. As such, we have 10K video clips for training and 3K video clips for testing this year. Each video is annotated with 20 natural sentences.&lt;/br&gt;<br>总结：就仅仅是将2016的train val and test 综合到一起，组成了2017： 一个大的含10000个video的train 数据集，并另外提供了2000个test video。&lt;/br&gt;<br>科研上普遍使用2016的分割方案，</p>
</li>
</ul>
<ul>
<li>In MSR-VTT dataset, we provide the category information for each video clip and the video clip contains audio information as well.</li>
</ul>
<h2 id="VATEX数据集"><a href="#VATEX数据集" class="headerlink" title="VATEX数据集"></a>VATEX数据集</h2><ul>
<li>一个新的数据集，41269个video， 时长大约10s, 每个video有10个中文，10个英文，同时这10个之中，中英文之间有5个是两两配对的</li>
<li>提出了两个新的任务：（1）一个encoder-decoder模型，在两种语言之间共享参数，即希望一个模型，可以得到两种语言的描述。（2）提出了一种新的机器翻译任务，即当进行中英文的机器翻译任务时，可以添加视频的视觉特征作为辅助信息</li>
<li><p>数据集的来源：来自于kinetics的validation dataset, 然后它们找人进行了caption的标注。它们将这41269个video 分成了4部分，train, validation, public test, secret test(不公开，用于比赛)</p>
</li>
<li><p>具体我的介绍见这篇博文</p>
</li>
</ul>
<h2 id="三个数据集的caption-length-的长度的统计情况"><a href="#三个数据集的caption-length-的长度的统计情况" class="headerlink" title="三个数据集的caption length 的长度的统计情况"></a>三个数据集的caption length 的长度的统计情况</h2><ul>
<li>eg, 句长为10 的captions 在当前这个数据集中所占比例   </li>
<li>msvd : 主要是len=6 为中心的居多<br><img src="https://i.loli.net/2019/09/07/jJ7ztsQb9MUR15X.png" alt="msvd_cap_length_.png"></li>
<li>msr-vtt：以len=9 为中心的居多<br><img src="https://i.loli.net/2019/09/07/SNYoIqHxPLWmU9D.png" alt="msr-vtt_cap_length_.png"></li>
<li>vatex：以len=15为中心的居多<br><img src="https://i.loli.net/2019/09/07/he7KYqMt8xj5pUs.png" alt="vatex_cap_length_.png"></li>
</ul>
<p>[1] Youtube2text: Recognizing and describing arbitrary activities using semantic hierarchies and zero-shot recognition. In ICCV 2013</p>
<p>[2] Translating videos to natural language using deep recurrent neural networks. NAACL, 2015.<br>[3] (ICCV 2015)Sequence to Sequence – Video to Text<br>[4] Jointly Modeling Embedding and Translation to Bridge Video and Language</p>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>video captioning 任务的难点？</title>
    <url>/2019/09/07/video-captioning-%E4%BB%BB%E5%8A%A1%E7%9A%84%E9%9A%BE%E7%82%B9%EF%BC%9F/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>vatex_challenge_solutions</title>
    <url>/2019/10/20/vatex-challenge-solutions/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>word2vec</title>
    <url>/2019/08/02/word2vec-1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>vision to language 大牛</title>
    <url>/2019/07/26/vision-to-language-%E5%A4%A7%E7%89%9B/</url>
    <content><![CDATA[<h3 id="王鑫"><a href="#王鑫" class="headerlink" title="王鑫"></a>王鑫</h3><p>Papers can be found at <a href="https://sites.cs.ucsb.edu/~xwang" target="_blank" rel="noopener">https://sites.cs.ucsb.edu/~xwang</a><br>Email: xwang@cs.ucsb.edu</p>
<h4 id="video-captioning-via-hierarchical-reinforcement-learning"><a href="#video-captioning-via-hierarchical-reinforcement-learning" class="headerlink" title="video captioning via hierarchical  reinforcement learning"></a>video captioning via hierarchical  reinforcement learning</h4><ol>
<li>强化学习</li>
<li>加入音频信号</li>
</ol>
<h4 id="zero-shot-video-captioning"><a href="#zero-shot-video-captioning" class="headerlink" title="zero-shot video captioning"></a>zero-shot video captioning</h4><ul>
<li>Topic-Aware Mixture of Experts (TAMoE)  <h4 id="evaluation"><a href="#evaluation" class="headerlink" title="evaluation"></a>evaluation</h4></li>
</ul>
<ol>
<li><p>如何去评判，本身就是一个问题，当前的评价指标并不是那么合理</p>
</li>
<li><p>human evaluation是一个必要的评测方法，尤其是对于生成story的</p>
</li>
</ol>
<h4 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h4><ul>
<li>利用强化学习直接对指标进行优化，很可能会造成，指标上去了，但是生成的句子语义并不好。所以提出了下篇论文</li>
</ul>
<ol>
<li>Adversarial REward Learning (AREL)</li>
</ol>
<h4 id="Connecting-Language-and-Vision-to-Actions"><a href="#Connecting-Language-and-Vision-to-Actions" class="headerlink" title="Connecting Language and Vision to Actions"></a>Connecting Language and Vision to Actions</h4><ul>
<li>Look Before You Leap: Model-based RL</li>
<li>Reinforced Cross-Modal Matching (RCM)</li>
</ul>
<h3 id="吴琦"><a href="#吴琦" class="headerlink" title="吴琦"></a>吴琦</h3><h4 id="从-Vision-到-Language-再到-Action，万字漫谈三年跨域信息融合研究"><a href="#从-Vision-到-Language-再到-Action，万字漫谈三年跨域信息融合研究" class="headerlink" title="从 Vision 到 Language 再到 Action，万字漫谈三年跨域信息融合研究"></a><a href="https://mp.weixin.qq.com/s/lnoL1TpKY8HQqCMaBqWA5Q" target="_blank" rel="noopener">从 Vision 到 Language 再到 Action，万字漫谈三年跨域信息融合研究</a></h4><h4 id="一文纵览-Vision-and-Language-领域最新研究与进展"><a href="#一文纵览-Vision-and-Language-领域最新研究与进展" class="headerlink" title="一文纵览 Vision-and-Language 领域最新研究与进展"></a><a href="https://mp.weixin.qq.com/s/dyY64QrvPWbjGvJw5H51OA" target="_blank" rel="noopener">一文纵览 Vision-and-Language 领域最新研究与进展</a></h4>]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>word2vec</title>
    <url>/2019/08/01/word2vec/</url>
    <content><![CDATA[<h3 id="使用one-hot-来作为词向量"><a href="#使用one-hot-来作为词向量" class="headerlink" title="使用one-hot 来作为词向量"></a>使用one-hot 来作为词向量</h3><ul>
<li>存在一个缺点，即，两个单词之间的余弦相似度为0，因为one-hot是两两正交的形式。</li>
<li>但是相似度为0，显然是不对的</li>
</ul>
<h3 id="word2vet"><a href="#word2vet" class="headerlink" title="word2vet"></a>word2vet</h3><ul>
<li>跳字模型：中心词生成背景词</li>
<li>连续词袋模型：背景词生成中心词</li>
<li><p>这两个模型存在的问题：在softmax中，由于分母是对整个vocab进行求和，导致反向传播的计算量非常大</p>
</li>
<li><p><a href="https://www.bilibili.com/video/av18512944/" target="_blank" rel="noopener">相关教程</a></p>
</li>
</ul>
<p>预训练模型</p>
<ul>
<li>glove</li>
<li>fasttext</li>
<li><a href="https://www.bilibili.com/video/av18795160/?spm_id_from=333.788.videocard.0" target="_blank" rel="noopener">相关教程</a></li>
<li>spacy</li>
<li><a href="https://shiyaya.github.io/2019/07/16/Spacy工具包/" target="_blank" rel="noopener">https://shiyaya.github.io/2019/07/16/Spacy%E5%B7%A5%E5%85%B7%E5%8C%85/</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>优先级队列式分支限界法---最小重量机器设计问题--python实现</title>
    <url>/2019/05/22/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%BC%8F%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95-%E6%9C%80%E5%B0%8F%E9%87%8D%E9%87%8F%E6%9C%BA%E5%99%A8%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98-python%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>这里给出两个解决方案：</p>
<p>1）不使用优先级，简单使用队列式分支限界法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 普通的FIFO 队列式分支限界法</span></span><br><span class="line"><span class="comment">## 当 不满足总价格不超过d的要求时，则剪枝</span></span><br><span class="line"><span class="comment">## 当搜索到深度n时，即搜索到了叶节点，不再进行扩展节点的操作，而是针对于叶节点所对应的最小值，</span></span><br><span class="line"><span class="comment"># 反向求得该节点所对应的的路径</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># coding : utf-8</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = <span class="number">3</span></span><br><span class="line">m = <span class="number">3</span></span><br><span class="line">d = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">price = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line">weight = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到当前扩展节点所在的Level</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getlevel</span><span class="params">(m, currrent)</span>:</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    level = <span class="number">0</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> currrent == <span class="number">0</span>:</span><br><span class="line">        level = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> level</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">        level = level+<span class="number">1</span></span><br><span class="line">        sum = m**level + sum  <span class="comment"># sum=m</span></span><br><span class="line">        <span class="keyword">if</span> sum-m**level &lt; currrent &lt;= sum:  <span class="comment"># m-m^0 = m-1</span></span><br><span class="line">            <span class="keyword">return</span> level</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到当前扩展节点，所对应的首个子节点所在的索引</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_idx</span><span class="params">(m, current)</span>:</span></span><br><span class="line">    level = getlevel(m, current)</span><br><span class="line">    <span class="comment"># 求current 在该level中的相对索引，即 相对于该level第一个元素的位置</span></span><br><span class="line">    current_level_idx = current - sum([m**i <span class="keyword">for</span> i <span class="keyword">in</span> range(level)])</span><br><span class="line">    <span class="comment"># 子节点所在层的开始绝对索引</span></span><br><span class="line">    start_idx  = sum([m**i <span class="keyword">for</span> i <span class="keyword">in</span> range(level+<span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> start_idx + current_level_idx*m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到最优解之后，反向查找其路径</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_path</span><span class="params">(m, current)</span>:</span></span><br><span class="line">    path = []</span><br><span class="line">    path.append(current%m)  <span class="comment"># from 1, not from 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        level = getlevel(m, current)</span><br><span class="line">        <span class="keyword">if</span> level == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> path[::<span class="number">-1</span>]</span><br><span class="line">        current_level_idx = current - sum([m ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(level)])  <span class="comment"># # 求current 在该level中的相对索引，即 相对于该level第一个元素的位置</span></span><br><span class="line">        path.append(current_level_idx // m + <span class="number">1</span>)  <span class="comment"># 得到上一级的索引位置</span></span><br><span class="line">        current = sum([m ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(level<span class="number">-1</span>)]) + current_level_idx // m  <span class="comment">#得到上一级的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MinWighet</span><span class="params">(n,m,d,price,weight)</span>:</span></span><br><span class="line">    minweight = float(<span class="string">"inf"</span>)</span><br><span class="line">    <span class="comment"># 子集树中的节点数</span></span><br><span class="line">    vec_len = sum([m ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>)]) + <span class="number">1</span></span><br><span class="line">    que = queue.Queue()</span><br><span class="line">    que.put(<span class="number">0</span>)</span><br><span class="line">    vec_price = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(vec_len)]</span><br><span class="line">    vec_weight = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(vec_len)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">not</span> que.empty()):</span><br><span class="line">        current = que.get()  <span class="comment"># 得到当前扩展节点（索引号）</span></span><br><span class="line">        level = getlevel(m, current)  <span class="comment"># 当前 扩展节点所在的level</span></span><br><span class="line"></span><br><span class="line">        idx = get_idx(m, current)   <span class="comment"># 得到当前扩展节点，所对应的首个子节点所在的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 若搜索完了整棵树</span></span><br><span class="line">        <span class="keyword">if</span> getlevel(m, current) == getlevel(m, vec_len)<span class="number">-1</span>:</span><br><span class="line">            minweight = vec_price[current]</span><br><span class="line">            min_at_idx = current</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">not</span> que.empty()):</span><br><span class="line">                <span class="comment"># minweight = min(minweight, vec_price[que.get()])</span></span><br><span class="line">                tmp = que.get()</span><br><span class="line">                <span class="keyword">if</span> minweight &gt; vec_price[tmp]:</span><br><span class="line">                    minweight = vec_price[tmp]</span><br><span class="line">                    min_at_idx = tmp</span><br><span class="line">            path = get_path(m, min_at_idx)</span><br><span class="line">            <span class="keyword">return</span> minweight, path</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断当前的扩展结点下的所有子节点是否可以加入活结点队列中</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            vec_price[idx] = int(vec_price[current] + price[level][i])</span><br><span class="line">            <span class="keyword">if</span> vec_price[idx] &lt;= d:</span><br><span class="line">                vec_weight[idx] = int(vec_weight[current] + weight[level][i])</span><br><span class="line">                que.put(idx)</span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(MinWighet(n,m,d,price,weight))</span><br></pre></td></tr></table></figure>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>2） 优先级队列式分支限界法</p>
<p>解空间：子集树，每个分支节点的分支数为m<br>解向量：x[1:n]  n为部件数量， x[i] 表示第i个部件使用哪个供应商。</p>
<p>算法：采用优先队列式分支限界法。<br>类似于单源最短路径，使用当前节点所确定下的采购方案对应的机器重量和最为优先级。<br>由于wij不是负值，当前节点所对应的当前机器重量和是解空间中以该节点为根的子树的中所有节点所对应的重量和的下界。</p>
<p>算法代码实现：</p>
<p>1）使用列表来代表队列，通过对列表中的活结点按照其当前重量和进行从小到大排序（实现了最小堆的维护）<br>2）定义一个节点类，属性有：节点所在的索引，以及节点当前的重量和<br>3）取出一个扩展节点：由于对活结点表进行了某种规则的排序，则直接取出列表的第一个元素即可<br>4）加入活结点表：将满足条件的子节点加入到活结点表中</p>
<p>失活当前扩展节点：删掉列表中的第一个元素即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 普通的FIFO 队列式分支限界法</span></span><br><span class="line"><span class="comment">## 当 不满足总价格不超过d的要求时，则剪枝</span></span><br><span class="line"><span class="comment">## 当搜索到深度n时，即搜索到了叶节点，不再进行扩展节点的操作，而是针对于叶节点所对应的最小值，</span></span><br><span class="line"><span class="comment"># 反向求得该节点所对应的的路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入优先级--使用当前节点的重量作为优先级，重量小优先级高</span></span><br><span class="line"><span class="comment"># 将队列改成列表，以append的方式加入到列表中，再以排序的方式维护当前列表的首个元素为最小权值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># coding : utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到当前扩展节点所在的Level</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getlevel</span><span class="params">(m, currrent)</span>:</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    level = <span class="number">0</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> currrent == <span class="number">0</span>:</span><br><span class="line">        level = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> level</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">        level = level+<span class="number">1</span></span><br><span class="line">        sum = m**level + sum  <span class="comment"># sum=m</span></span><br><span class="line">        <span class="keyword">if</span> sum-m**level &lt; currrent &lt;= sum:  <span class="comment"># m-m^0 = m-1</span></span><br><span class="line">            <span class="keyword">return</span> level</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到当前扩展节点，所对应的首个子节点所在的索引</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_idx</span><span class="params">(m, current)</span>:</span></span><br><span class="line">    level = getlevel(m, current)</span><br><span class="line">    <span class="comment"># 求current 在该level中的相对索引，即 相对于该level第一个元素的位置</span></span><br><span class="line">    current_level_idx = current - sum([m**i <span class="keyword">for</span> i <span class="keyword">in</span> range(level)])</span><br><span class="line">    <span class="comment"># 子节点所在层的开始绝对索引</span></span><br><span class="line">    start_idx  = sum([m**i <span class="keyword">for</span> i <span class="keyword">in</span> range(level+<span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> start_idx + current_level_idx*m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到最优解之后，反向查找其路径</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_path</span><span class="params">(m, current)</span>:</span></span><br><span class="line">    path = []</span><br><span class="line">    path.append(current%m)  <span class="comment"># from 1, not from 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        level = getlevel(m, current)</span><br><span class="line">        <span class="keyword">if</span> level == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> path[::<span class="number">-1</span>]</span><br><span class="line">        current_level_idx = current - sum([m ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(level)])  <span class="comment"># # 求current 在该level中的相对索引，即 相对于该level第一个元素的位置</span></span><br><span class="line">        path.append(current_level_idx // m + <span class="number">1</span>)  <span class="comment"># 得到上一级的索引位置</span></span><br><span class="line">        current = sum([m ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(level<span class="number">-1</span>)]) + current_level_idx // m  <span class="comment">#得到上一级的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为活结点表中的节点 定义了一个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, idx, weight)</span>:</span></span><br><span class="line">        self.idx = idx</span><br><span class="line">        self.weight = weight</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MinWighet</span><span class="params">(n,m,d,price,weight)</span>:</span></span><br><span class="line">    <span class="comment"># 子集树中的节点数</span></span><br><span class="line">    vec_len = sum([m ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>)]) + <span class="number">1</span></span><br><span class="line">    que = []</span><br><span class="line">    que.append(Node(<span class="number">0</span>,<span class="number">0</span>))  <span class="comment"># 在活结点表中加入根节点</span></span><br><span class="line">    <span class="comment"># vec_price = [0 for _ in range(vec_len)]</span></span><br><span class="line">    <span class="comment"># vec_weight = [0 for _ in range(vec_len)]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(que):  <span class="comment"># 当活结点表非空时</span></span><br><span class="line">        que = sorted(que, key=<span class="keyword">lambda</span> node: node.weight)  <span class="comment"># 类似于最小堆的维护</span></span><br><span class="line">        current = que[<span class="number">0</span>]  <span class="comment"># 得到当前扩展节点（索引号）</span></span><br><span class="line">        level = getlevel(m, current.idx)  <span class="comment"># 当前 扩展节点所在的level</span></span><br><span class="line"></span><br><span class="line">        new_node_idx = get_idx(m, current.idx)   <span class="comment"># 得到当前扩展节点，所对应的首个子节点所在的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 若搜索完了整棵树</span></span><br><span class="line">        <span class="keyword">if</span> getlevel(m, current.idx) == getlevel(m, vec_len)<span class="number">-1</span>:</span><br><span class="line">            minweight = current.weight</span><br><span class="line">            min_at_idx = current.idx</span><br><span class="line"></span><br><span class="line">            path = get_path(m, min_at_idx)</span><br><span class="line">            <span class="keyword">return</span> minweight, path</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断当前的扩展结点下的所有子节点是否可以加入活结点队列中</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> int(current.weight + price[level][i]) &lt;= d:</span><br><span class="line">                new_node = Node(new_node_idx, int(current.weight + weight[level][i]))</span><br><span class="line">                que.append(new_node)</span><br><span class="line">            new_node_idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将当前的扩展节点失活</span></span><br><span class="line">        <span class="keyword">del</span> que[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    n = <span class="number">3</span></span><br><span class="line">    m = <span class="number">3</span></span><br><span class="line">    d = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    price = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]]</span><br><span class="line">    weight = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]]</span><br><span class="line">    result = MinWighet(n,m,d,price,weight)</span><br><span class="line">    print(MinWighet(n,m,d,price,weight))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>到底ResNet在解决一个什么问题呢</title>
    <url>/2019/08/17/%E5%88%B0%E5%BA%95ResNet%E5%9C%A8%E8%A7%A3%E5%86%B3%E4%B8%80%E4%B8%AA%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%91%A2/</url>
    <content><![CDATA[<p>对知乎上回答的简单总结</p>
<hr>
<p><strong>一、引言：为什么会有ResNet？Why ResNet？</strong></p>
<ul>
<li>过拟合？<br>  不是！因为深层网络表现为训练误差和测试误差都比较高，所以不是过拟合</li>
<li><p>梯度消失？梯度爆炸？<br>  不是！因为已经使用了 batch normalization ，在很大程度上解决了梯度消失、爆炸的问题，（yaya：我个人认为对梯度消失问题有一定的帮助，毕竟梯度值为1）</p>
</li>
<li><p>深层网络退化的原因？</p>
<p>  由于非线性激活函数的存在，使得信息被丢失，而不能完整保留，所以，应该在网络中加入恒等映射</p>
</li>
</ul>
<p><strong>二、关于resnet网络结构 【没看懂为什么要有两层】  </strong></p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g62hrnrs6nj30h9048aax.jpg" alt></p>
<ul>
<li>yaya 分析：<br>一层：  relu(x +  w1 x)<br>两层：  relu(x +w2 relu(w1 x))</li>
</ul>
<p>​       既然非线性激活函数会把信息丢失，为什么不这样：relu(wx) + x ，因为这样是错误的，本身relu是需要放在输出后面，起到非线性的作用，但是这样，就不算作对输出的非线</p>
<p><strong>三、更多的理解    </strong></p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g62hpvudvxj30iu0cc3zi.jpg" alt></p>
<hr>
<p>yaya 的总结/理解</p>
<ol>
<li>resnet 解决的不是过拟合的问题，因为过拟合的现象是，train loss 小，但是val loss大，但是当前深层网络的问题是train loss大，val loss也大</li>
<li>resnet 提供了一个梯度为1的反向传播，在一定程度上解决了梯度消失的问题</li>
<li>FPN中指出，不同深度的网络的结合可以结合不同的分辨率，但是当前resnet 只跨越了一种分辨率，因此，没能很好地利用这一特点，因此desnet便被提出来</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>使用 objects position 作为特征的论文</title>
    <url>/2019/10/10/%E4%BD%BF%E7%94%A8-objects-position-%E4%BD%9C%E4%B8%BA%E7%89%B9%E5%BE%81%E7%9A%84%E8%AE%BA%E6%96%87/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>从bagging到dropout</title>
    <url>/2019/03/22/%E4%BB%8Ebagging%E5%88%B0dropout/</url>
    <content><![CDATA[<ul>
<li>转载 from: <a href="https://blog.csdn.net/m0_37477175/article/details/77145459" target="_blank" rel="noopener">https://blog.csdn.net/m0_37477175/article/details/77145459</a></li>
</ul>
<p>dropout的思想继承自bagging方法，学习dropout先了解一下bagging方法。</p>
<h2 id="bagging"><a href="#bagging" class="headerlink" title="bagging"></a>bagging</h2><ul>
<li>bagging是一种集成方法（ensemble methods）,可以通过集成来减小泛化误差（generalization error）。 </li>
<li>bagging的<strong>最基本的思想</strong>是通过分别训练几个不同分类器，最后对测试的样本，每个分类器对其进行投票。在机器学习上这种策略叫model averaging。 </li>
<li>model averaging 之所以有效，是因为并非所有的分类器都会产生相同的误差，只要有不同的分类器产生的误差不同就会对减小泛化误差非常有效。 </li>
<li>对于bagging方法，允许采用相同的分类器，相同的训练算法，相同的目标函数。但是在<strong>数据集方面</strong>，<a href="https://www.baidu.com/s?wd=%E6%96%B0%E6%95%B0%E6%8D%AE&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">新数据</a>集与原始数据集的大小是相等的。每个数据集都是通过在原始数据集中随机选择一个样本进行替换而得到的。意味着，每个新数据集中会<strong>存在重复</strong>的样本。 </li>
<li>在数据集建好之后，用<strong>相同的学习算法</strong>分别作用于每个数据集就得到了几个分类器。 </li>
<li>下面这幅图片很好的解释了bagging的工作方式：我们想实现一个对数字8进行分类的分类器。此时构造了两个数据集，使用相同的学习算法，第一个分类器学习到的是8的上面那部分而第二个分类器学习的是8的下面那个部分。当我们把两个分类器集合起来的时候，此时的分类才是比较好的。 </li>
<li>Each of these individual classification ruls is brittle, but if we average there output then the detector is robust.<br><img src="https://img-blog.csdn.net/20170813153102572?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbTBfMzc0NzcxNzU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></li>
</ul>
<h2 id="dropout"><a href="#dropout" class="headerlink" title="dropout"></a>dropout</h2><ul>
<li>我们可以把dropout类比成将许多大的神经网络进行集成的一种bagging方法。 </li>
<li>但是每一个神经网络的训练是非常耗时和占用很多内存的，训练很多的神经网络进行集合分类就显得太不实际了。 </li>
<li>但是，dropout可以训练所有子网络的集合，这些子网络通过去除整个网络中的一些<a href="https://www.baidu.com/s?wd=%E7%A5%9E%E7%BB%8F%E5%85%83&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">神经元</a>来获得。 </li>
<li><p>如下图所示：<br><img src="https://img-blog.csdn.net/20170813154717429?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbTBfMzc0NzcxNzU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
</li>
<li><p>可能有些人会问上图的有些子网络，从输入到不了最终的输出，怎么办？其实对于比较宽的层（wider layers）从输入到输出都切断的概率是非常小的，多以影响不是很大。</p>
</li>
<li><p>如何移除一个神经元呢，我们通过仿射和非线性变换，试神经元的输出乘以0。</p>
</li>
<li><p>每次我们加载一个样本到minibatch，然后随机的采样一个不同的二进制掩膜作用在所有的输出，输入，隐藏节点上。每个节点的掩膜都是独立采样的。采样一个掩膜值为1的概率是固定的超参数。</p>
</li>
</ul>
<h2 id="bagging与dropout训练的对比"><a href="#bagging与dropout训练的对比" class="headerlink" title="bagging与dropout训练的对比"></a>bagging与dropout训练的对比</h2><ul>
<li>在bagging中，所有的分类器都是独立的，而在dropout中，所有的模型都是共享参数的。</li>
<li>在bagging中，所有的分类器都是在特定的数据集下训练至收敛，而在dropout中没有明确的模型训练过程。网络都是在一步中训练一次（输入一个样本，随机训练一个子网络）</li>
<li>（相同点）对于训练集来说，每一个子网络的训练数据是通过原始数据的替代采样得到的子集。<strong>？？？</strong>（自己的理解：每一个输入一个样本初始化某一个子网络）</li>
</ul>
<h2 id="dropout的优势"><a href="#dropout的优势" class="headerlink" title="dropout的优势"></a>dropout的优势</h2><ul>
<li>very computationally cheap在dropout训练阶段，每一个样本每一次更新只需要O(n)<br>，同时要生成n个二进制数字与每个状态相乘。除此之外，还需要O(n)的额外空间存储这些二进制数字，直到反向传播阶段。</li>
<li>没有很显著的限制模型的大小和训练的过程。</li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划(dynamic programming)</title>
    <url>/2019/04/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dynamic-programming/</url>
    <content><![CDATA[<h3 id="从起始点，走到终点"><a href="#从起始点，走到终点" class="headerlink" title="从起始点，走到终点"></a>从起始点，走到终点</h3><p>（1）共有多少路径<br>（2）哪条路径最短<br>对于grid 走路，只有两种走走法，这类问题，需要：   </p>
<ul>
<li>分析最后终点的结果，是怎么得来的：是由左邻和上邻的结果，进行某种运算得来的   </li>
<li>先将第一行、第一列进行初始化（结合具体问题）   </li>
<li>分析，递推公式，并采用自底向上的方式，因此，需要先高度的想，最后终点的递推公式，在结合这个公式，分析，在初始化之后，接下来的点，如何根据初始化的值，以及递推公式来计算得到。   </li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>分治递归： 一步一步的化解为小问题，最终由小问题再反向计算各大问题。自上而下   </li>
<li>动态规划：也需要得到递推公式，但是需要先将小问题的值写出来（初始化阶段），再根据递推公式，写for循环   </li>
</ul>
<h3 id="对于求解任意两个节点之间的值，并求全局最优解的问题，还需要再总结"><a href="#对于求解任意两个节点之间的值，并求全局最优解的问题，还需要再总结" class="headerlink" title="对于求解任意两个节点之间的值，并求全局最优解的问题，还需要再总结"></a>对于求解任意两个节点之间的值，并求全局最优解的问题，还需要再总结</h3><ul>
<li><a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-subarray/</a>  </li>
<li><a href="https://leetcode.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-product-subarray/</a>  </li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针(two pointers)</title>
    <url>/2019/04/18/%E5%8F%8C%E6%8C%87%E9%92%88-two-pointers/</url>
    <content><![CDATA[<ul>
<li>荷兰分区问题<br>可参考 <a href="https://blog.csdn.net/sylar_d/article/details/52742598" target="_blank" rel="noopener">https://blog.csdn.net/sylar_d/article/details/52742598</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>图像描述-评价指标-中用到的数据集汇总</title>
    <url>/2020/06/04/%E5%9B%BE%E5%83%8F%E6%8F%8F%E8%BF%B0-%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87-%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>为了评估 提出的metric 与 human judgement的相关性，提出了一些数据集。这些数据集，包含image-text-human_score, 通过利用统计学分析 metric_evaluation 与 human_score 的相关性，来验证提出评价指标的合理性。</p>
<h1 id="Caption-level-Correlation"><a href="#Caption-level-Correlation" class="headerlink" title="Caption-level Correlation"></a>Caption-level Correlation</h1><h2 id="Flickr-8k-Dataset"><a href="#Flickr-8k-Dataset" class="headerlink" title="Flickr 8k Dataset"></a>Flickr 8k Dataset</h2><ul>
<li>website: <a href="http://academictorrents.com/details/9dea07ba660a722ae1008c4c8afdd303b6f6e53b" target="_blank" rel="noopener">http://academictorrents.com/details/9dea07ba660a722ae1008c4c8afdd303b6f6e53b</a></li>
<li>论文: Framing Image Description as a Ranking Task: Data, Models and Evaluation Metrics   </li>
</ul>
<font size="2"> **数据集介绍** </font>

<ul>
<li><p>Cite: Framing image description as a ranking task: Data, models and evaluation metrics.  </p>
</li>
<li><p>对于图像描述任务：该数据集包含8092张image。训练集6000张，验证集1000张，测试集1000张，，很奇怪。。数据加起来对不上。。每张image 都对应有人类标注的5个句子。</p>
</li>
<li><p>对于图像描述评价指标任务： </p>
<p><strong>测试集1000张</strong>，<font color="blue"><strong>通过image-text retrieval 算法</strong></font> 检索candidate caption，为每张图片从整个测试集的语料库上进行检索（检索的数量没有固定，像是根据检索结果阈值截取的）。由于是在整个测试集的预料库上进行检索，则，也有可能检索到自身image对应的groundtruth。This dataset also includes 5822 testing captions for 1000 images。  </p>
<p>得到这些新的image-text pair，对于每个pair，再由<strong>三个人工</strong>去标注image与text的匹配程度( give a score from 1 (not related to the image content) to 4 (very related))。</p>
<p>则，构建了一个可以衡量metric 与 human judgement 相关性的一个数据集。</p>
</li>
</ul>
<font size="2"> **使用 Note** </font>

<ul>
<li>在TIGER [1] : <strong>Because 158 candidates are actual references of target images, we excluded these for further analysis。</strong> <font color="red">在TIGER 的实验设置中：若Flickr 8k数据集中检索到了本image对应的reference，则去掉该条检索。</font>去掉了 158条，则剩余 5822-158=5664条</li>
</ul>
<font size="2"> **评估方式**</font>

<p><code>Kendall</code> and <code>Spearman</code> rank correlations reflect the similarity of the pairwise rankings whereas <code>Pearson’s</code> p captures the linear association between data points.</p>
<h2 id="Composite-Dataset"><a href="#Composite-Dataset" class="headerlink" title="Composite Dataset"></a>Composite Dataset</h2><p>论文：From Images to Sentences through Scene Description Graphs using Commonsense Reasoning and Knowledge  </p>
<font size="2"> **数据集介绍** </font>

<p>这个数据集是由三个数据集组成的。包括：testing captions for 2007 MS-COCO images, 997 Flickr 8k pictures, and 991 Flickr 30k images.  </p>
<p>每张图片对应3个candidate captions，包括1个human written reference和 2个machine generated。</p>
<p>这里总计有11,985 candidates, 标注与image 之间的相关性，from 1 (not relevant) to 5 (very relevant)。</p>
<font size="2"> **评估方式**</font>

<p><code>Kendall</code> and <code>Spearman</code> rank correlations reflect the similarity of the pairwise rankings whereas <code>Pearson’s</code> p captures the linear association between data points.</p>
<h2 id="Pascal-50s-Dataset"><a href="#Pascal-50s-Dataset" class="headerlink" title="Pascal 50s Dataset"></a>Pascal 50s Dataset</h2><ul>
<li>website: <a href="http://vrama91.github.io/cider/" target="_blank" rel="noopener">http://vrama91.github.io/cider/</a></li>
</ul>
<font size="2"> **数据集介绍** </font>

<p>Cite: <code>CIDEr: Consensus-based Image Description Evaluation</code></p>
<p>从 UIUC PASCAL Sentence Dataset中提取1000张image，原数据集中，每个image配有5个human written sentence。</p>
<p>对于图像描述评价指标任务： </p>
<p>在以上基础上每个image 又由 AMT workers标注了50个captions。以此构成了pascal 50s 数据集。</p>
<p>不同于以上的两个数据集评估image-text 之间的匹配，该数据集考量candidate 与 reference之间的匹配。具体地：对于一个image，（1）使用48 of 50 human written caption as <strong>reference</strong>。（2）剩下的两个human written caption as <strong>candidate</strong>，同时也使用 machine generated caption as <strong>candidate</strong>，另外other image 的 human written caption通过检索的方式也可以当 这样candidate可以当做<strong>candidate</strong>。</p>
<p>基于此，构建三元组：（A, (B, C)）—(reference, (candidate_1, candidate_2)) 根据(B, C) 组合方式的不同，分为四类：HC，HI，HM，MM。（1）human–human correct pairs (HC), where we pick two human sentences describing the same image. （2） human–human incorrect pairs (HI), where one of the sentences is a human description for the image and the other is also a human sentence but describing some other image from the dataset picked at random. （3）human–machine (HM) pairs formed by pairing a human sentence describing an image with a machine generated sentence describing the same image. （4）machine–machine (MM) pairs, where we compare two machine generated sentences describing the same image</p>
<p>则，可以得到 1000image × 48reference(A) × 4(B,C) = 192000个三元组</p>
<p><strong>human judgement 的标注</strong> 对于任意给出的一个三元组(A, B, C)。A 是一个reference sentence, (B, C) 是两个candidate captions pair. 标注者被要求从B和C中选择一个与A最相似的句子。这样就可以收集到一个human judgements for each triplet. 如果B的投票对于C则认为B is winner.</p>
<font size="2"> **使用 Note** </font>

<ul>
<li>解读如下的表格的acuracy是如何计算的吧！首先在PASCAL-50s数据集里含有4种模式：HC、HI、HM、MM， 即对于（A,(B, C)）中的pair（B, C）含有四种模式。当前AMT workers对pair(B, C)已经有了排序，当proposed metric也对这些B，C sentences进行评分的时候，自然也会有一个对B，C的排序，即score高的sentence, 排序就在前。基于人类已经给了人工的标注排序，即获得了GT，那么就可以去评判 proposed metric 对该pair的评分是否正确。进而可以得到对该类HC/HI/HM/MM的准确率。其实也可以在整个数据集上进行测试得到一个准确率。</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gcdc0x4s91j30ex04uaas.jpg" alt="搜狗截图20200229160306.png"></p>
<font size="2"> **评估方式**</font>

<p>Pairwise Classification Accuracy</p>
<h1 id="System-Level-Correlation"><a href="#System-Level-Correlation" class="headerlink" title="System-Level Correlation"></a>System-Level Correlation</h1><h2 id="the-2015-COCO-Captioning-Challenge-for-12-teams"><a href="#the-2015-COCO-Captioning-Challenge-for-12-teams" class="headerlink" title="the 2015 COCO Captioning Challenge for 12 teams"></a>the 2015 COCO Captioning Challenge for 12 teams</h2><font size="2"> **数据集介绍** </font>

<ul>
<li><p>Cite: The coco 2015 captioning challenge. <a href="http://mscoco.org/dataset/#captions-challenge2015" target="_blank" rel="noopener">http://mscoco.org/dataset/#captions-challenge2015</a>.  </p>
</li>
<li><p><a href="https://panderson.me/spice/" target="_blank" rel="noopener">spice website</a> 提供的链接：<a href="https://cocodataset.org/#captions-leaderboard" target="_blank" rel="noopener">https://cocodataset.org/#captions-leaderboard</a></p>
</li>
<li><p>use human judgements collected in the 2015 COCO Captioning Challenge for 12 teams who participated in this captioning challenge.</p>
</li>
<li><p>We report</p>
<ul>
<li><p>M1: Percentage of captions that are evaluated as better or equal to human caption,</p>
</li>
<li><p>M2: Percentage of captions that pass the Turing Test,</p>
</li>
<li><p>M3: Average correctness of the captions on a scale of 1-5 (incorrect - correct),</p>
</li>
<li><p>M4: Average amount of detail of the captions on a scale of 1-5 (lack of details - very detailed) and</p>
</li>
<li><p>M5: Percentage of captions that are similar to human description.</p>
</li>
<li><p>While M1 and M2 were used to rank the captioning models in the COCO challenge.   </p>
<p>M3, M4 and M5  are not used to rank image captioning models , but are intended for an ablation study to understand the various aspects of caption quality.  </p>
</li>
</ul>
</li>
</ul>
<font size="2">**yaya** </font>

<p>由(CVPR 2018) Learning to Evaluate Image Captioning中的描述：“we don’t have access to the COCO test set annotations, where the human judgments are collected on, we perform our experiments on the COCO validation set. There are 15 teams participated in the 2015 COCO captioning challenge and we use 12 of them that submitted results on the validation set. We assume the human judgment on the validation set is sufficiently similar to the judgment on the test set. “</p>
<p>大致是说，<strong>我们无法访问到coco test set annotations，因此，假设system 在测试集和验证集上的human judgements是一致的，所以使用val set prediction caption 和 test test human judgements.</strong></p>
<p>IJCV LCEval 采用的是和他们一致的思路</p>
<p>SPICE 是将他们的code 发送给COCO官方（因为spice authors也无法访问 test captions）</p>
<font size="2">**使用 Note** </font>

<p>计算system-level correlation, （1）需要为每个 caption model 来计算一个metric score, 这个分数聚合了由该model 生成的所有的caption 的 metric socre。（2） 然后，该captio model 的aggregate metric score 与 system-level human assessments之间的相关性被计算。</p>
<font size="2"> **评估方式**</font>

<ul>
<li>Compare proposed metric with others on the <strong>Pearson’s ρ correlation</strong> between all common metrics and human judgments collected in the 2015 COCO Captioning Challenge. </li>
</ul>
<h1 id="论文引用情况"><a href="#论文引用情况" class="headerlink" title="论文引用情况"></a>论文引用情况</h1><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Caption-level Correlation</th>
<th></th>
<th></th>
<th>System-Level Correlation</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>Flickr 8k</td>
<td>Composite</td>
<td>pascal-50s</td>
<td>2015 COCO Captioning Challenge</td>
</tr>
<tr>
<td>CIDEr</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>SPICE</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>(CVPR 2018) Learning to Evaluate Image Captioning</td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>(EMNLP-IJCNLP 2019) REO-Relevance, Extraness, Omission A Fine-grained Evaluation for Image Captioning</td>
<td></td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>(ACL 2019) VIFIDEL Evaluating the visual fidelity of image descriptions</td>
<td></td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>(EMNLP2019) TIGEr Text-to-Image Grounding for Image Caption Evaluation</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>(IJCV)Learning-based Composite Metrics for Improved Caption Evaluation</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>图像描述</category>
        <category>评价指标</category>
      </categories>
      <tags>
        <tag>评价指标</tag>
      </tags>
  </entry>
  <entry>
    <title>史雅雅的收藏夹</title>
    <url>/2019/04/04/%E5%8F%B2%E9%9B%85%E9%9B%85%E7%9A%84%E6%94%B6%E8%97%8F%E5%A4%B9/</url>
    <content><![CDATA[<p><a href="http://pygments.org/" target="_blank" rel="noopener">http://pygments.org/</a></p>
<p><a href="https://202.38.95.226:7443/view.html" target="_blank" rel="noopener">https://202.38.95.226:7443/view.html</a></p>
<p><a href="https://aideadlin.es/?sub=ML,RO,CV,SP,NLP,DM" target="_blank" rel="noopener">https://aideadlin.es/?sub=ML,RO,CV,SP,NLP,DM</a></p>
<p><a href="https://yjs.ustc.edu.cn/" target="_blank" rel="noopener">https://yjs.ustc.edu.cn/</a></p>
<p><a href="https://www.json.cn/" target="_blank" rel="noopener">https://www.json.cn/</a></p>
<p><a href="https://kevinj-huang.github.io/" target="_blank" rel="noopener">https://kevinj-huang.github.io/</a></p>
<p><a href="https://shiyaya.github.io/" target="_blank" rel="noopener">https://shiyaya.github.io/</a></p>
<p><a href="https://stackedit.io/app#" target="_blank" rel="noopener">https://stackedit.io/app#</a></p>
<p><a href="http://jsonviewer.stack.hu/" target="_blank" rel="noopener">http://jsonviewer.stack.hu/</a></p>
<p><a href="http://www.nlpjob.com/" target="_blank" rel="noopener">http://www.nlpjob.com/</a></p>
<p><a href="https://nlp.stanford.edu/software/scenegraph-parser.shtml#Usage" target="_blank" rel="noopener">https://nlp.stanford.edu/software/scenegraph-parser.shtml#Usage</a></p>
<p><a href="https://paperswithcode.com/sota" target="_blank" rel="noopener">https://paperswithcode.com/sota</a></p>
<p><a href="https://sm.ms/" target="_blank" rel="noopener">https://sm.ms/</a></p>
<p><a href="http://www.arxiv-sanity.com/" target="_blank" rel="noopener">http://www.arxiv-sanity.com/</a></p>
<p><a href="http://www.cvpapers.com/" target="_blank" rel="noopener">http://www.cvpapers.com/</a></p>
<h3 id="论文搜索"><a href="#论文搜索" class="headerlink" title="论文搜索"></a>论文搜索</h3><ul>
<li><p><a href="https://dblp.uni-trier.de/db/" target="_blank" rel="noopener">https://dblp.uni-trier.de/db/</a></p>
<ul>
<li>（可以进行筛选，eg:nips, iccv, cvpr）; (也可以对某些作者进行查询)</li>
</ul>
</li>
<li><p><a href="http://openaccess.thecvf.com/menu.py" target="_blank" rel="noopener">http://openaccess.thecvf.com/menu.py</a></p>
</li>
<li><a href="http://actionrecognition.net/files/paper.php" target="_blank" rel="noopener">http://actionrecognition.net/files/paper.php</a></li>
<li><a href="http://www.aaai.org/Library/AAAI/aaai19contents.php" target="_blank" rel="noopener">http://www.aaai.org/Library/AAAI/aaai19contents.php</a></li>
<li><a href="https://dl.acm.org/results.cfm?within=owners.owner%3DHOSTED&amp;srt=_score&amp;query=&amp;Go.x=26&amp;Go.y=1" target="_blank" rel="noopener">https://dl.acm.org/results.cfm?within=owners.owner%3DHOSTED&amp;srt=_score&amp;query=&amp;Go.x=26&amp;Go.y=1</a></li>
</ul>
<h3 id="翻墙"><a href="#翻墙" class="headerlink" title="翻墙"></a>翻墙</h3><ul>
<li><p><a href="https://github.com/vpncn/vpncn.github.io" target="_blank" rel="noopener">https://github.com/vpncn/vpncn.github.io</a></p>
</li>
<li><p><a href="https://flyzyblog.com/install-ss-ssr-bbr-in-one-command/#ss" target="_blank" rel="noopener">https://flyzyblog.com/install-ss-ssr-bbr-in-one-command/#ss</a></p>
</li>
<li><p><a href="https://www.banpie.info/shadowsocks-pac-gfw/" target="_blank" rel="noopener">https://www.banpie.info/shadowsocks-pac-gfw/</a></p>
</li>
<li><p>Vultr搭建SS</p>
</li>
<li><p><a href="https://github.com/sirzdy/shadowsocks/wiki/Vultr搭建SS（VPS搭建SS）" target="_blank" rel="noopener">http://wuzhangyang.com/2019/03/06/vultr-ss/</a></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">wget https:<span class="comment">//raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</span></span><br><span class="line"></span><br><span class="line">chmod +x shadowsocks.sh</span><br><span class="line"></span><br><span class="line">./shadowsocks<span class="selector-class">.sh</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>搬瓦工</p>
</li>
<li><p>推荐：<a href="https://www.bandwagonhost.net/1967.html" target="_blank" rel="noopener">https://www.bandwagonhost.net/1967.html</a></p>
</li>
</ul>
<h2 id="会议搜索"><a href="#会议搜索" class="headerlink" title="会议搜索"></a>会议搜索</h2><ul>
<li><a href="http://www.searchconf.net/conf/searchresule/" target="_blank" rel="noopener">http://www.searchconf.net/conf/searchresule/</a></li>
</ul>
<h3 id="iccv-2019-challenge"><a href="#iccv-2019-challenge" class="headerlink" title="iccv 2019 challenge"></a>iccv 2019 challenge</h3><ul>
<li><a href="https://sites.google.com/site/iccv19clvllsmdc/home" target="_blank" rel="noopener">https://sites.google.com/site/iccv19clvllsmdc/home</a></li>
</ul>
<h3 id="GCN"><a href="#GCN" class="headerlink" title="GCN"></a>GCN</h3><ul>
<li><a href="https://github.com/rusty1s/pytorch_geometric" target="_blank" rel="noopener">https://github.com/rusty1s/pytorch_geometric</a></li>
</ul>
<p>深度学习课程</p>
<ul>
<li><a href="https://discuss.gluon.ai/c/5-category" target="_blank" rel="noopener">https://discuss.gluon.ai/c/5-category</a></li>
<li><a href="http://zh.d2l.ai/chapter_preface/preface.html" target="_blank" rel="noopener">http://zh.d2l.ai/chapter_preface/preface.html</a></li>
</ul>
<h3 id="tensorboard-可视化"><a href="#tensorboard-可视化" class="headerlink" title="tensorboard 可视化"></a>tensorboard 可视化</h3><ul>
<li><a href="https://www.aiuai.cn/aifarm646.html" target="_blank" rel="noopener">https://www.aiuai.cn/aifarm646.html</a></li>
</ul>
]]></content>
      <categories>
        <category>杂类</category>
      </categories>
      <tags>
        <tag>杂类</tag>
      </tags>
  </entry>
  <entry>
    <title>图像描述任务的实际应用</title>
    <url>/2020/12/24/%E5%9B%BE%E5%83%8F%E6%8F%8F%E8%BF%B0%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h3 id="CaptionBot"><a href="#CaptionBot" class="headerlink" title="CaptionBot"></a>CaptionBot</h3><p>from: <a href="https://www.theguardian.com/technology/2016/apr/14/captionbot-microsoft-latest-ai-experiment-it-isnt-racist" target="_blank" rel="noopener">https://www.theguardian.com/technology/2016/apr/14/captionbot-microsoft-latest-ai-experiment-it-isnt-racist</a></p>
<p>简介：用户上传一张图片到CaptionBot Service，该系统针对该图片自动的生成一个caption。用户可以评分生成的caption 是否准确。</p>
<blockquote>
<p>The idea is that you upload a photo to the service, and it tries to automatically generate a caption that describes what the algorithm sees. You are then able to rate how accurately it has detected what was on display. It learns from the rating, and in theory, the captions get better.</p>
</blockquote>
<p>The bot, from <a href="http://go.theguardian.com/?id=114047X1572903&amp;url=https%3A%2F%2Fwww.microsoft.com%2Fcognitive-services&amp;sref=https://www.theguardian.com/technology/2016/apr/14/captionbot-microsoft-latest-ai-experiment-it-isnt-racist" target="_blank" rel="noopener">Microsoft’s Cognitive Services team</a>, is the result of <a href="http://go.theguardian.com/?id=114047X1572903&amp;url=http%3A%2F%2Fresearch.microsoft.com%2Fpubs%2F264408%2FImageCaptionInWild.pdf&amp;sref=https://www.theguardian.com/technology/2016/apr/14/captionbot-microsoft-latest-ai-experiment-it-isnt-racist" target="_blank" rel="noopener">some hefty research</a> into how to model objects in photographs so that a computer can understand them. They claim that their system can recognise “a broad range of visual concepts” and also performs entity extraction so that it can recognise celebrities. </p>
<p><img src="https://i.loli.net/2020/12/24/kJ31yRYX5dKH64g.jpg" alt="Taylor Swift and Kanye West both identified in Microsoft’s CaptionBot app"></p>
<h3 id="Seeing-AI-项目"><a href="#Seeing-AI-项目" class="headerlink" title="Seeing AI 项目"></a><strong>Seeing AI</strong> 项目</h3><p>微软研究院的研究员们不仅在寻找识别图像的方法，还在为图像进行描述。这项研究结合了图像识别技术与自然语言处理技术，能帮助视障人士获得对图像的准确描述，还可能帮助那些需要图像信息却无法直接看到图像的人——比如正在开车的司机。</p>
<p>Seeing AI项目组中的Margaret Mitchell是一名专攻自然语言处理的研究员，也是图像描述领域顶尖的研究者之一。她说，她和同事们正在寻找方法，让计算机可以用更加人性化的方式来描述图像。例如，计算机可以将一个场景准确地描述为“一群人坐在一起”，但真人可能会将这一场景描述为“一群人坐在一起享受美好时光。”<strong>目前的挑战就是让这项技术懂得一张图像中哪些是对人们最重要、最值得描述的内容。</strong>“<strong>一张图像中有什么，和我们如何谈论一张图像可是完全不同的两回事</strong>，”Mitchell说。</p>
<p>微软的另一些研究员们正在努力让最新的图像识别工具提供更深入的图片解释。例如，与单纯地将图片描述为“一个男人和一个女人坐在一起”相比，对人们更有帮助的描述可能是：“奥巴马和希拉里·克林顿正在摆pose拍照”。今天人们在网上搜索图片时，绝大多数情况下搜索引擎会根据与图片相关的文字内容，从而得到美国名媛金·卡戴珊或“霉霉”泰勒·斯威夫特的照片，这些搜索结果主要依据文本内容。而微软的资深研究员张磊及郭彦东等研究员正在开发一套借助机器学习识别名人、政治家和公众人物的系统，这套系统会根据图像本身的元素，而非与图像相关的文字内容来进行图像识别。</p>
]]></content>
      <categories>
        <category>图像描述</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>图像描述评价指标的论文总结</title>
    <url>/2020/07/02/%E5%9B%BE%E5%83%8F%E6%8F%8F%E8%BF%B0%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87%E7%9A%84%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h3><p><strong style="color:blue;">(AAAI 2020) Going Beneath the Surface Evaluating Image Captioning for Grammaticality</strong></p>
<ul>
<li><p>语法正确性</p>
</li>
<li><p>准确性</p>
<blockquote>
<p>we investigate is truthfulness, that is, whether a candidate caption is compatible with the content of the image it is supposed to describe.  </p>
</blockquote>
</li>
<li><p>多样性</p>
</li>
</ul>
<p><strong style="color:blue;">(ACL 2019) VIFIDEL Evaluating the visual fidelity of image descriptions</strong></p>
<ul>
<li><p>准确性</p>
<blockquote>
<p> We focus on one such criterion, visual fidelity. </p>
<p>This criterion aims to measure how faithful a description is with respect to what is depicted in the image (i.e. systems should be rewarded for describing elements depicted in the image and penalised for describing things that are not depicted). </p>
</blockquote>
</li>
</ul>
<p><strong style="color:blue;">(EMNLP2019) TIGEr Text-to-Image Grounding for Image Caption Evaluation</strong></p>
<ul>
<li>没有针对，就是使用 image conten 作为 GT，设计了一个评价指标</li>
</ul>
<p><strong style="color:blue;">(EMNLP-IJCNLP 2019) REO-Relevance, Extraness, Omission A Fine-grained Evaluation for Image Captioning</strong></p>
<ul>
<li><p>相关度  Relevance</p>
<blockquote>
<p>relevant information of a candidate caption with respect to the ground truth  </p>
</blockquote>
</li>
<li><p>多余  Extraness</p>
<blockquote>
<p>extra information of a  candidate caption beyond ground truth data  </p>
</blockquote>
</li>
<li><p>缺少  Omission</p>
<blockquote>
<p>missing information that a candidate fails to describe from an image and humangenerated reference captions.  </p>
</blockquote>
</li>
</ul>
<p><strong style="color:blue;">(ICLR 2020 workshop)Egoshots, an ego-vision life-logging dataset and semantic fidelity metric to evaluate diversity in image captioning models</strong></p>
<ul>
<li>多样性？？</li>
</ul>
]]></content>
      <categories>
        <category>图像描述</category>
        <category>评价指标</category>
      </categories>
  </entry>
  <entry>
    <title>安装pytorch_geometricc</title>
    <url>/2019/07/30/%E5%AE%89%E8%A3%85pytorch-geometricc/</url>
    <content><![CDATA[<ul>
<li><p><a href="https://pytorch-geometric.readthedocs.io/en/latest/notes/installation.html#frequently-asked-questions" target="_blank" rel="noopener">官方链接</a></p>
</li>
<li><p>下面是截取自官方</p>
</li>
</ul>
<h2 id="Directly-Installation"><a href="#Directly-Installation" class="headerlink" title="Directly Installation"></a>Directly Installation</h2><p>We have outsourced a lot of functionality of PyTorch Geometric to other packages, which needs to be installed in advance. These packages come with their own CPU and GPU kernel implementations based on the newly introduced <a href="https://github.com/pytorch/extension-cpp/" target="_blank" rel="noopener">C++/CUDA extensions</a> in PyTorch 0.4.0.</p>
<p>Note</p>
<p>We do not recommend installation as root user on your system python. Please setup an <a href="https://conda.io/docs/user-guide/install/index.html/" target="_blank" rel="noopener">Anaconda/Miniconda</a> environment or create a <a href="https://www.docker.com/" target="_blank" rel="noopener">Docker image</a>.</p>
<p>Please follow the steps below for a successful installation:</p>
<ol>
<li><p>Added  by yaya:</p>
<ul>
<li><p>may be you can select a conda environments, will be more fine</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">bash Anaconda3<span class="number">-5.0</span><span class="number">.0</span>-Linux-x86_64.sh</span><br><span class="line">conda create -n pytorch_geometric python=<span class="number">3.7</span> -y</span><br><span class="line">source activate pytorch_geometric</span><br></pre></td></tr></table></figure>
</li>
<li><p>after into env: pytorch_geometric</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">pip</span> <span class="selector-tag">install</span> <span class="selector-tag">torch-1</span><span class="selector-class">.1</span><span class="selector-class">.0-cp37-cp37m-manylinux1_x86_64</span><span class="selector-class">.whl</span>  # <span class="selector-tag">download</span> <span class="selector-tag">at</span> <span class="selector-tag">first</span></span><br><span class="line"><span class="selector-tag">pip</span> <span class="selector-tag">installl</span> <span class="selector-tag">numpy-1</span><span class="selector-class">.17</span><span class="selector-class">.0-cp37-cp37m-manylinux1_x86_64</span><span class="selector-class">.whl</span>  # <span class="selector-tag">download</span> <span class="selector-tag">at</span> <span class="selector-tag">first</span></span><br><span class="line"><span class="selector-tag">pip</span> <span class="selector-tag">install</span> <span class="selector-tag">scipy-1</span><span class="selector-class">.3</span><span class="selector-class">.0-cp37-cp37m-manylinux1_x86_64</span><span class="selector-class">.whl</span>  # <span class="selector-tag">download</span> <span class="selector-tag">at</span> <span class="selector-tag">first</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ol>
<li><p>Ensure that at least PyTorch 1.1.0 is installed:</p>
<blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt; $ python -c <span class="string">"import torch; print(torch.__version__)"</span></span><br><span class="line">&gt; <span class="meta">&gt;&gt;&gt; </span><span class="number">1.1</span>.<span class="number">0</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>Ensure CUDA is setup correctly (optional):</p>
<blockquote>
<ol>
<li><p>Check if PyTorch is installed with CUDA support:</p>
<blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;    &gt; $ python -c <span class="string">"import torch; print(torch.cuda.is_available())"</span></span><br><span class="line">&gt;    &gt; <span class="meta">&gt;&gt;&gt; </span>True</span><br><span class="line">&gt;    &gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>Add CUDA to <code>$PATH</code> and <code>$CPATH</code> (note that your actual CUDA path may vary from <code>/usr/local/cuda</code>):</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; $ <span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/cuda/bin:<span class="variable">$PATH</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; $ <span class="built_in">echo</span> <span class="variable">$PATH</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; &gt;&gt;&gt; /usr/<span class="built_in">local</span>/cuda/bin:...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; $ <span class="built_in">export</span> CPATH=/usr/<span class="built_in">local</span>/cuda/include:<span class="variable">$CPATH</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; $ <span class="built_in">echo</span> <span class="variable">$CPATH</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; &gt;&gt;&gt; /usr/<span class="built_in">local</span>/cuda/include:...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>Add CUDA to <code>$LD_LIBRARY_PATH</code> on Linux and to <code>$DYLD_LIBRARY_PATH</code> on macOS (note that your actual CUDA path may vary from <code>/usr/local/cuda</code>):</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; $ <span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/cuda/lib64:<span class="variable">$LD_LIBRARY_PATH</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; $ <span class="built_in">echo</span> <span class="variable">$LD_LIBRARY_PATH</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; &gt;&gt;&gt; /usr/<span class="built_in">local</span>/cuda/lib64:...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; $ <span class="built_in">export</span> DYLD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/cuda/lib:<span class="variable">$DYLD_LIBRARY_PATH</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; $ <span class="built_in">echo</span> <span class="variable">$DYLD_LIBRARY_PATH</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; &gt;&gt;&gt; /usr/<span class="built_in">local</span>/cuda/lib:...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>Verify that <code>nvcc</code> is accessible from terminal:</p>
<blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt;    &gt; $ nvcc --version</span></span><br><span class="line"><span class="quote">&gt;    &gt; &gt;&gt;&gt; 10.0</span></span><br><span class="line"><span class="quote">&gt;    &gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>Ensure that PyTorch and system CUDA versions match:</p>
<blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;    &gt; $ python -c <span class="string">"import torch; print(torch.version.cuda)"</span></span><br><span class="line">&gt;    &gt; <span class="meta">&gt;&gt;&gt; </span><span class="number">10.0</span></span><br><span class="line">&gt;    &gt; </span><br><span class="line">&gt;    &gt; $ nvcc --version</span><br><span class="line">&gt;    &gt; <span class="meta">&gt;&gt;&gt; </span><span class="number">10.0</span></span><br><span class="line">&gt;    &gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
</blockquote>
</li>
<li><p>Install all needed packages:</p>
<blockquote>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">&gt; <span class="symbol">$</span> you can see <span class="number">4.</span> first (optional)</span><br><span class="line">&gt; <span class="symbol">$</span> pip install --verbose --<span class="keyword">no</span>-cache-dir torch-scatter</span><br><span class="line">&gt; <span class="symbol">$</span> pip install --verbose --<span class="keyword">no</span>-cache-dir torch-sparse</span><br><span class="line">&gt; <span class="symbol">$</span> pip install --verbose --<span class="keyword">no</span>-cache-dir torch-cluster</span><br><span class="line">&gt; <span class="symbol">$</span> pip install --verbose --<span class="keyword">no</span>-cache-dir torch-spline-conv (optional)</span><br><span class="line">&gt; <span class="symbol">$</span> pip install torch-geometric</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>added by yaya:<br>may be you can pip install scipy at first ,because above need it.</p>
</li>
</ol>
<h2 id="Docker-install"><a href="#Docker-install" class="headerlink" title="Docker install"></a>Docker install</h2><ul>
<li><a href="https://github.com/rusty1s/pytorch_geometric/tree/master/docker" target="_blank" rel="noopener">https://github.com/rusty1s/pytorch_geometric/tree/master/docker</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>多模态人工智能</title>
    <url>/2021/03/12/%E5%A4%9A%E6%A8%A1%E6%80%81%E4%BA%A4%E4%BA%92%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</url>
    <content><![CDATA[<p>多模态：视觉，语音，自然语言</p>
<p><img src="https://i.loli.net/2021/03/12/8ObjKzRVd4UXgS3.png" alt="image-20210312202150477"></p>
<p><img src="https://i.loli.net/2021/03/12/IqFHGuL6ZYOKwXb.png" alt="image-20210312202209438"></p>
<p><img src="https://i.loli.net/2021/03/12/CsF8TR3m9UlS54N.png" alt="image-20210312202229192"></p>
<p><img src="https://i.loli.net/2021/03/12/HbPD8yaB3GU7IAk.png" alt="image-20210312202108780"></p>
]]></content>
      <categories>
        <category>cross-modal</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
      </tags>
  </entry>
  <entry>
    <title>完整性-pair</title>
    <url>/2020/07/11/%E5%AE%8C%E6%95%B4%E6%80%A7-pair/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>多标签图像分类任务的评价方法-mAP</title>
    <url>/2019/08/31/%E5%A4%9A%E6%A0%87%E7%AD%BE%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%AF%84%E4%BB%B7%E6%96%B9%E6%B3%95-mAP/</url>
    <content><![CDATA[<p>转载 from: <a href="http://blog.sina.com.cn/s/blog_9db078090102whzw.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_9db078090102whzw.html</a></p>
<p>多标签图像分类（Multi-label   Image  Classification）任务中图片的标签不止一个，因此评价不能用普通单标签图像分类的标准，即mean  accuracy，该任务采用的是和信息检索中类似的方法—mAP（mean  Average  Precision）。mAP虽然字面意思和mean  accuracy看起来差不多，但是计算方法要繁琐得多，以下是mAP的计算方法：</p>
<p>首先用训练好的模型得到所有测试样本的confidence  score，每一类（如car）的confidence   score保存到一个文件中（如comp1_cls_test_car.txt）。假设共有20个测试样本，每个的id，confidence  score和ground  truth  label如下：</p>
<p><a href="http://blog.photo.sina.com.cn/showpic.html#url=http://album.sina.com.cn/pic/002T2ChPgy6XQd58yJ15f" target="_blank" rel="noopener"><img src="http://s16.sinaimg.cn/mw690/002T2ChPgy6XQd58yJ15f" alt="img"></a> </p>
<p>接下来对confidence  score排序，得到：</p>
<p><a href="http://blog.photo.sina.com.cn/showpic.html#url=http://album.sina.com.cn/pic/002T2ChPgy6XQd86isc4c" target="_blank" rel="noopener"><img src="http://s13.sinaimg.cn/mw690/002T2ChPgy6XQd86isc4c" alt="img"></a><em>这张表很重要，接下来的precision和recall都是依照这个表计算的</em>﻿</p>
<p>然后计算precision和recall，这两个标准的定义如下：</p>
<p><a href="http://blog.photo.sina.com.cn/showpic.html#url=http://album.sina.com.cn/pic/002T2ChPgy6XQdjij4Ae8" target="_blank" rel="noopener"><img src="http://s9.sinaimg.cn/mw690/002T2ChPgy6XQdjij4Ae8" alt="img"></a></p>
<p>上图比较直观，圆圈内（true   positives + false  positives）是我们选出的元素,它对应于分类任务中我们取出的结果，比如对测试样本在训练好的car模型上分类，我们想得到top-5的结果，即：</p>
<p><a href="http://blog.photo.sina.com.cn/showpic.html#url=http://album.sina.com.cn/pic/002T2ChPgy6XQdbTpla5c" target="_blank" rel="noopener"><img src="http://s13.sinaimg.cn/mw690/002T2ChPgy6XQdbTpla5c" alt="img"></a></p>
<p>在这个例子中，true   positives就是指第4和第2张图片，false   positives就是指第13，19，6张图片。方框内圆圈外的元素（false   negatives和true  negatives）是相对于方框内的元素而言，在这个例子中，是指confidence   score排在top-5之外的元素，即：</p>
<p><a href="http://blog.photo.sina.com.cn/showpic.html#url=http://album.sina.com.cn/pic/002T2ChPgy6XQdcMwKCea" target="_blank" rel="noopener"><img src="http://s11.sinaimg.cn/mw690/002T2ChPgy6XQdcMwKCea" alt="img"></a> </p>
<p>其中，false   negatives是指第9，16，7，20张图片，true   negatives是指第1,18,5,15,10,17,12,14,8,11,3张图片。</p>
<p>那么，这个例子中Precision=2/5=40%，意思是对于car这一类别，我们选定了5个样本，其中正确的有2个，即准确率为40%；Recall=2/6=30%，意思是在所有测试样本中，共有6个car，但是因为我们只召回了2个，所以召回率为30%。</p>
<p>实际多类别分类任务中，我们通常不满足只通过top-5来衡量一个模型的好坏，而是需要知道从top-1到top-N（N是所有测试样本个数，本文中为20）对应的precision和recall。显然随着我们选定的样本越来也多，recall一定会越来越高，而precision整体上会呈下降趋势。把recall当成横坐标，precision当成纵坐标，即可得到常用的precision-recall曲线。这个例子的precision-recall曲线如下：</p>
<p><a href="http://blog.photo.sina.com.cn/showpic.html#url=http://album.sina.com.cn/pic/002T2ChPgy6XQddBz7ze9" target="_blank" rel="noopener"><img src="http://s10.sinaimg.cn/mw690/002T2ChPgy6XQddBz7ze9" alt="img"></a></p>
<p>接下来说说AP的计算，此处参考的是PASCAL  VOC  CHALLENGE的计算方法。首先设定一组阈值，[0, 0.1, 0.2, …, 1]。然后对于recall大于每一个阈值（比如recall&gt;0.3），我们都会得到一个对应的最大precision。这样，我们就计算出了11个precision。AP即为这11个precision的平均值。这种方法英文叫做11-point interpolated average precision。</p>
<p>当然PASCAL VOC CHALLENGE自2010年后就换了另一种计算方法。新的计算方法假设这N个样本中有M个正例，那么我们会得到M个recall值（1/M, 2/M, …, M/M）,对于每个recall值r，我们可以计算出对应（r’ &gt; r）的最大precision，然后对这M个precision值取平均即得到最后的AP值。计算方法如下：</p>
<p><a href="http://blog.photo.sina.com.cn/showpic.html#url=http://album.sina.com.cn/pic/002T2ChPzy76AuWjHOp29" target="_blank" rel="noopener"><img src="http://s10.sinaimg.cn/mw690/002T2ChPzy76AuWjHOp29" alt="img"></a></p>
<p>相应的Precision-Recall曲线（这条曲线是单调递减的）如下：</p>
<p><a href="http://blog.photo.sina.com.cn/showpic.html#url=http://album.sina.com.cn/pic/002T2ChPzy76AuH9Z6010" target="_blank" rel="noopener"><img src="http://s1.sinaimg.cn/mw690/002T2ChPzy76AuH9Z6010" alt="img"></a></p>
<p>AP衡量的是学出来的模型在每个类别上的好坏，mAP衡量的是学出的模型在所有类别上的好坏，得到AP后mAP的计算就变得很简单了，就是取所有AP的平均值。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>完整性分析</title>
    <url>/2020/07/03/%E5%AE%8C%E6%95%B4%E6%80%A7%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>Class: flying kite Video: 8iPflOxQaao_000018_000028</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1Xf4y1y7AP&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] An announcer is talking while a kid is showing how to wind a power flyer and let it go into the air.<br>[2] A boy winds a powered kite engine then launches the kite, which flies then is displayed on a table.<br>[3] A boy is outside winding up a toy plane,then throws it in the air to fly.<br>[4] An announcer is talking while a kid is showing how to wind a power flyer and let it go into the air.<br>[5] A boy winds a powered kite engine then launches the kite, which flies then is displayed on a table.<br><strong>Prediction:</strong><br>[baseline]: a young boy in a red shirt is holding a baseball bat .<br>[graph_kl]: a little girl is standing in a field and is holding a kite .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A boy is jumping on a trampoline and doing some flips.<br>A boy is jumping on a trampoline, doing various jumps and flips.<br>A boy is jumping on a trampoline and does a flip.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A little boy is flying a kite and some person is helping him to fly<br>A woman is trying to help a young boy fly a kite.<br>A little boy is flying a kite and his mother helps him.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>Someone is flying a kite up in the sky and trying to reel it in.<br>A sky with clouds and a break of sun fades to black, before a woman riding a kite sail is on the water.</p>
<hr>
<p>Class: carving ice Video: UArdunmwEdA_000049_000059</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1mt4y1X7fE&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A man chiseling and picking at a large block of ice.<br>[2] A man shaves ice off a large block and talks to a worker.<br>[3] A man shaves ice off a large block and talks to a worker.<br>[4] one person carving an ice block with a tool and another person holding a ice carving machine<br>[5] An ice sculptor shows how he begins a typical project.<br><strong>Prediction:</strong><br>[baseline]: a man is using a chainsaw to carve a block of ice .<br>[graph_kl]: a man is using a tool to carve a block of ice .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A man makes an ice sculpture using a carving saw.<br>A man uses a tool to carve an ice sculpture while a class of people watch him.<br>A man showing his skills in an outdoor ice carving competition.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A person is carving an ice sculpture from a block of ice with a chainsaw.<br>A man makes an ice sculpture using a carving saw.<br>A man uses a tool to carve an ice sculpture while a class of people watch him.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A person is creating an ice sculpture as viewers take it all in.<br>A person is making an ice sculpture and it appears to be a seahorse.</p>
<hr>
<p>Class: tobogganing Video: vTSO26j_g3E_000006_000016</p>
<iframe src="//player.bilibili.com/player.html?aid=286089586&bvid=BV1Rf4y1y7nN&cid=203899418&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A man and a baby sled down a snow covered hill in the winter.<br>[2] A man and a small child ride a sled down a snowy hill.<br>[3] A man and a small child ride a sled down a snowy hill.<br>[4] An adult is sliding down a snowy hill on a sunny day.<br>[5] A man and a child are sledding down a hill.<br><strong>Prediction:</strong><br>[baseline]: a person is sledding down a snowy hill on a sled .<br>[graph_kl]: a person is riding a sled down a snowy hill .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A little boy gets a on a sled and goes down a snowy hill.<br>An adult and a child share a sled ride down a snowy hill.<br>A man and a child are sliding down a mountain on a sled with other people around them.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A woman and child are sledding down a snowy hill together.<br>An adult and child are together sledding down a snowy slope.<br>An adult and a child share a sled ride down a snowy hill.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A woman and a young child are sliding on a sled in the snow.<br>A little boy gets a on a sled and goes down a snowy hill.</p>
<hr>
<p>Class: jogging Video: gf37sAjEfRc_000013_000023</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1Bz4y1Q7Ai&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] Two boys are running in slow motion towards playground equipment.<br>[2] a group of people running together in a park as they pass by each other having fun<br>[3] Two young men are racing a course outside and going in slow motion as they pass a woman<br>[4] Two young men are racing a course outside and going in slow motion as they pass a woman<br>[5] A woman high fiving people who are  running past her in the park.<br><strong>Prediction:</strong><br>[baseline]: a group of people are standing in a field and one of them is holding a ball .<br>[graph_kl]: a man is teaching a young boy how to do a karate kick .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>Two young boys are chasing each other playfully around a park<br>A young boy runs down the street in order to catch a ball.<br>Two boys playing around in a park and running around.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A group of people are playing basketball on an outdoor court.<br>A group of boys are playing a game of soccer outside.<br>Two young girls are dancing to music at a restaurant.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A group of adults and children a grouped together outside as a small group is lowering a object into the ground.<br>A bunch of kids outside playing a game of socceer together on the field</p>
<hr>
<p>Class: throwing ball (not baseball or American football) Video: GXO1eYu4kr8_000000_000010</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1JT4y1J7R6&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] a man sitting on a gym floor throwing a black ball<br>[2] A man seated is throwing a ball to a man standing indoors.<br>[3] A man sitting on a gym floor with legs spread passes a ball to another man who is standing.<br>[4] A man sitting on a gymnasium floor throws a large ball to a standing man.<br>[5] A man, seated on the floor with his back against the wall and legs spread apart, throws a ball to a standing man in a gymnasium.<br><strong>Prediction:</strong><br>[baseline]: a young boy is practicing his basketball skills in a gym .<br>[graph_kl]: a man is standing in the middle of a gym and throws a ball .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>Grown men in the gymnasium play dodgeball, one blocks a ball with another ball that his friend catches and then two men get hit with balls.<br>Men are in a gymnasium playing dodge ball with their hands<br>A group of men throwing several balls to children indoors.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A man throws a football to someone in an indoor gym<br>A young man is kicking a soccer ball to somebody else on the gymnasium floor.<br>A man in a gym steps back and throws a football.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>a person in a gym by themselves throwing a football to the other side of the gym<br>A man in a gym kicks a white ball back and forth.</p>
<hr>
<p>Class: sipping cup Video: saXahlRV7s4_000022_000032</p>
<iframe src="//player.bilibili.com/player.html?aid=286068284&bvid=BV1df4y1y7oD&cid=203899246&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A little boy holding a sippy cup of juice smiling and giggling.<br>[2] A little boy is sucking juice out of a cup while a man is talking to him.<br>[3] A baby drinks juice from a sippy cup and smiles while a person hold the bottom of the cup them pokes his belly.<br>[4] A baby is sipping a juice in a bottle and a man speaks to him<br>[5] A little boy holding a sippy cup of juice smiling and giggling.<br><strong>Prediction:</strong><br>[baseline]: a baby is drinking from a sippy cup while a woman talks to him .<br>[graph_kl]: a baby is sitting on a couch and drinking from a sippy cup .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A baby sips liquid out of a sippy cup with great gusto.<br>A little boy holding a sippy-cup begins to mumble and then takes a sip from the cup.<br>A young child drinks out of straw in a sippy type cup.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A toddler drinks from a sippy cup while talking to a woman.<br>A man holds a baby while she drinks from a sippy cup.<br>A man holds a young child while they drink from a sippy cup.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A baby is holding onto a pink sippy cup with two hands and drinking from it.<br>A toddler drinks from a sippy cup while talking to a woman.</p>
<hr>
<p>Class: welding Video: Hgo7xkutPno_000059_000069</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1Ez411e7QD&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] The man used a welding tool while covering his face with a protective mask.<br>[2] A man is welding metal together while wearing protective gear.<br>[3] Someone is welding while there is rock music playing in the background.<br>[4] A person with a mask works welding under an overhead light.<br>[5] A person wearing a welders helmet, using a welding torch on an object.<br><strong>Prediction:</strong><br>[baseline]: a group of people are welding a piece of metal .<br>[graph_kl]: a person is using a torch to blow a piece of wood .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>a person using a tool to do some welding wearing protective gear<br>A man in proper protective gear is welding metal together.<br>A man in a mask welding pieces of metal together.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A man with a welding mask on is speaking while welding an object.<br>The man is wearing a face mask while welding pipes together.<br>A man in proper protective gear is welding metal together.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A person welds metal creating sparks and bright flashes of light.<br>Someone uses a welding tool to weld something together, it creates a very bright light.</p>
<hr>
<p>Class: cutting pineapple Video: NRC5oMoNHn0_000003_000013</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV12t4y1X7tM&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A man is teaching how to cut a pineapple by cutting off top and bottom.<br>[2] In a kitchen, a chef instructs and demonstrates how to cut a pineapple.<br>[3] A chef chops a pineapple on the counter; removing the top first and then the rest.<br>[4] A man is teaching how to cut a pineapple by cutting off top and bottom.<br>[5] In a kitchen, a chef instructs and demonstrates how to cut a pineapple.<br><strong>Prediction:</strong><br>[baseline]: a man is demonstrating how to cut a pineapple with a knife .<br>[graph_kl]: a man is demonstrating how to cut a pineapple with a knife .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A person is demonstrating how to cut up a pineapple in a kitchen.<br>A person shows how to cut a pineapple in order to get to the core of the fruit.<br>A man is cutting a pineapple with a small knife.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A person is demonstrating how to cut up a pineapple in a kitchen.<br>A woman is demonstrating how to cut an orange with a knife.<br>A man demonstrates how to cut into an orange using a knife.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A man is cutting a pineapple with a small knife.<br>A person uses a knife to demonstrate how to cut the ends and skin off of a pineapple.</p>
<hr>
<p>Class: making paper aeroplanes Video: IbDcOoO9m6g_000139_000149</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1ni4y1x7xP&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A kid is demonstrating some origami and is folding the paper into a triangle.<br>[2] A person folds a piece of paper over a decorative dark board.<br>[3] A person shows how to fold the napkin to decorate the hotel tables<br>[4] A person shows how to fold the napkin to decorate the hotel tables<br>[5] A person shows how to fold the napkin to decorate the hotel tables<br><strong>Prediction:</strong><br>[baseline]: a person is folding a piece of paper into a triangle .<br>[graph_kl]: a person is demonstrating how to fold a piece of paper .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A person shows how to fold a piece of paper folding in the different corners and then the top.<br>A young boy is showing a technique to fold a piece of paper into a paper airplane.<br>A little boy demonstrates how to fold a paper plane using paper.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A man demonstrates folding a piece of green paper into origami.<br>A young boy is showing a technique to fold a piece of paper into a paper airplane.<br>Someone is demonstrating how to fold a piece of paper to make an airplane.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A woman folds a napkin in half to form a triangle, then folds the points towards the center.<br>a woman is showing how to fold a napkin in order to create something</p>
<hr>
<p>Class: trimming shrubs Video: tGiBJQ5RhZQ_000077_000087</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1cV411k7yR&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A man is standing and using clippers to trim a bush.<br>[2] A man is standing and using clippers to trim a bush.<br>[3] A man uses a gardening tool to cut shrubbery as he details the process.<br>[4] A man cutting plants it lengthy branches and give instruction to other.<br>[5] a gardener is showing how to trim parts of a hedge<br><strong>Prediction:</strong><br>[baseline]: a man is using a chainsaw to trim a tree .<br>[graph_kl]: a man is using a chainsaw to cut a piece of wood .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A man with garden shears describing how to trim bushes<br>A man using pruning shears is explaining and demonstrating how to trim an evergreen tree.<br>A guy stands outside as he snips away at the branches in a bush.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A man using pruning shears is explaining and demonstrating how to trim an evergreen tree.<br>A man with garden shears describing how to trim bushes<br>A guy stands outside as he snips away at the branches in a bush.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A guy stands outside as he snips away at the branches in a bush.<br>A man in an orange shirt trims trees while standing high up in the branches.</p>
<hr>
<p>Class: using circular saw Video: _YWpv2_K8Pk_000054_000064</p>
<iframe src="//player.bilibili.com/player.html?aid=456121030&bvid=BV1D5411W7zB&cid=203800090&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] Someone is cutting down wood on a saw carefully with another piece pushing it.<br>[2] A man is cutting a block of wood with a table saw and pushing it along with another piece of wood.<br>[3] A person is feeding a piece of wood into a table or bench saw to cut it.<br>[4] A person cutting a wooden board on a flat table saw<br>[5] A guy is running a wood board through a saw a few times.<br><strong>Prediction:</strong><br>[baseline]: a man is using a tool to cut a piece of wood .<br>[graph_kl]: a man is using a tool to cut a piece of wood .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>a man is cutting construction wood using a table saw<br>A man had a wood on his lap while carving it with a knife<br>A person is using a skill saw to cut through a piece of wood.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>The man uses a circular saw to cut a piece of lumber.<br>A person with a circular saw is cutting a piece of wood.<br>A person uses an electric saw to cut through a piece of wood.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A person is rolling dough on a table with a roller.<br>a man measures a long piece of wood next to a machine</p>
<hr>
<p>Class: walking the dog Video: KvVRY61JS7A_000023_000033</p>
<iframe src="//player.bilibili.com/player.html?aid=841065180&bvid=BV1U54y1B7ga&cid=204027776&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] Two people are walking two dogs down their street together.<br>[2] A man and a boy walking their 2 dogs on the street but the boy fell down and cried.<br>[3] A man and a toddler are walking two dogs down the street.<br>[4] Two people are walking two dogs down their street together.<br>[5] A baby bumps into a dog and cries while walking down road.<br><strong>Prediction:</strong><br>[baseline]: a woman is walking on a sidewalk with a dog on her back .<br>[graph_kl]: a person is walking down the street and a man is walking .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A boy is walking a dog on a leash on a street.<br>A little boy is walking his tiny dog on the streets.<br>A boy is skateboarding and walking his dog at the same time.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A woman and a child are walking down the sidewalk.<br>A woman and her young child are walking down the sidewalk.<br>A little boy is walking his tiny dog on the streets.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A person uses a power washer to remove paint from an asphalt surface.<br>A kid in a white shirt hits his head against a wall and falls to the ground.</p>
<hr>
<p>Class: blowing leaves Video: VNXpHy5Tb_U_000064_000074</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1if4y1y71S&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A little boy runs a leaf blower for a short minute then cuts it off.<br>[2] A small boy is blowing the leaves with a leaf blower and the blower stops.<br>[3] A boy using an electric leaf blower on debris outdoors suddenly stops working and walks away.<br>[4] a person in front of different leaves trying to blow them away with a  machine<br>[5] A young boy using a leaf blower moves leaves in a yard then shuts off the leaf blower and talks to someone else.<br><strong>Prediction:</strong><br>[baseline]: a man is using a chainsaw to cut a pile of wood .<br>[graph_kl]: a man is using a leaf blower to blow leaves in a yard .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A man is blowing off leaves using a leaf blower off of the pavement<br>Man rides lawn mower with leaf-blower attachment over cleared grass and blows fallen leaves under trees.<br>An individual uses a leaf blower to get rid of several leaves.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A man is blowing off leaves using a leaf blower off of the pavement<br>An individual uses a leaf blower to get rid of several leaves.<br>A person uses a leaf blower to blow leaves from a house gutter.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A man picked up a stick with a mound of mud at the base<br>A boy is stick in a muddy ditch trying to get out of it.</p>
<hr>
<p>Class: ice swimming Video: dC2Ih_JFoOM_000000_000010</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1cD4y1Q7BX&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] Two men in underwear step into a pond and one of the men dips under the water very quickly and immediately heads to get out of the pond.<br>[2] Two men wade into the water and one dunks under the water.<br>[3] Two men wade into the water and one dunks under the water.<br>[4] Two men wade into the water and one dunks under the water.<br>[5] two men are walking into the water in a cold day<br><strong>Prediction:</strong><br>[baseline]: a group of people are in a pool and one of them jumps into the water .<br>[graph_kl]: a group of people are in a pool and one of them jumps into the water .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A man wearing swimming trunks goes for a swim in freezing cold water.<br>A man in orange swim trunks and a white beanie walked into a pool of cold winter water.<br>A man was swimming in icy water and then came out<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A man walked into a cold pool of water and walked back out while talking to another person.<br>A man is walking into a wide body of water.<br>A man is wading into a body of lake water.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>Two men are wading in water and one tries to catch something with a strange tool.<br>A man is wading into a body of lake water.</p>
<hr>
<p>Class: opening door Video: lcUJjVgqXp4_000000_000010</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV19V411r7FF&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A person is showing how to unlock a locked door using a folded playing card.<br>[2] A person dhowing to take a playing card and unlock a door to get it.<br>[3] A man used a folded card to open the lock of a door<br>[4] A person dhowing to take a playing card and unlock a door to get it.<br>[5] A man is showing how to open a door using a folded playing card.<br><strong>Prediction:</strong><br>[baseline]: a person is using a machine to open a door .<br>[graph_kl]: a person opens a door and opens the door and opens the door .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A man is demonstrating how to pick a lock on a door.<br>A very close up angle shows a guy picking the lock to a door.<br>A person demonstrates using lockpicks to open a standard lock.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A man is demonstrating how to pick a lock on a door.<br>A boy is opening a door lock using a pin.<br>A man attempts to unlock a door using some simple tools.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A man in a mask power cleans a portable machine.<br>A man is withdrawing some money and a receipt out of an ATM machine</p>
<hr>
<p>Class: scrapbooking Video: uh50grtCQSA_000026_000036</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1ma4y1Y7HQ&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] a person writes something on a colorful canvass that they have in front of them<br>[2] A little girl is explaining her notebook and how she likes it as she flips the pages.<br>[3] A young girl writes a note on her scrapbook, then flips through it.<br>[4] A girl is showing the only thing she has done in her scrapbook.<br>[5] A child is showing and describing what she did with her scrapbook.<br><strong>Prediction:</strong><br>[baseline]: a person is folding a piece of paper on a table .<br>[graph_kl]: a person is showing how to fold a piece of paper .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A girl colors in a hand-drawn map of the countries of the world.<br>A woman quietly looks through the pages of a homemade scrapbook.<br>A person is showing designs on different pages in a scrapbook.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A woman quietly looks through the pages of a homemade scrapbook.<br>A person is showing designs on different pages in a scrapbook.<br>A person is showing how they draw in a sketch book.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A person folds a cloth into a triangle then folds the corner in again.<br>A person is using cardboard to properly fold a shirt.</p>
<hr>
<p>Class: waxing chest Video: cb3RvnukQVs_000159_000169</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1vk4y1z7GR&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A guy laying flat on his back as a woman attempts to wax his chest and stomach.<br>[2] A woman looks at a man’s bare chest and removes excess wax with a paper towel.<br>[3] A man is laying down on his back shirtless while a woman uses wax strips to help remove the hair.<br>[4] A woman cleans up hair of a man’s belly after he was waxed.<br>[5] A woman cleans up hair of a man’s belly after he was waxed.<br><strong>Prediction:</strong><br>[baseline]: a man is getting his chest waxed by a woman .<br>[graph_kl]: a man is laying on his stomach while another person is waxing his chest .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A man lays face down as a woman waxes his back.<br>A woman is waxing a man’s chest hair.<br>A woman applying hair removal wax strips to a man’s chest<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A woman is waxing a man’s chest hair.<br>A man is laying on the table getting his chest hair waxed.<br>A man is having his back waxed by a woman<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A person is removing strips of wax from another persons back to remove the hair.<br>A man covered in wax and a person pulling the wax off of his back.</p>
<hr>
<p>Class: diving cliff Video: 5D4HjS92zSQ_000126_000136</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV17i4y1G7rb&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A boy does a backflip off a precipice into a body of water<br>[2] A person does a backflip off a cliff into water while others are already in the water.<br>[3] On a high cliff boys jump into a water quarry.<br>[4] A man does a back-flip off of a cliff, while his friend watches from the water below.<br>[5] A person is doing a flip off of a cliff into a lake.<br><strong>Prediction:</strong><br>[baseline]: a man jumps off of a cliff into a body of water .<br>[graph_kl]: a man jumps off a cliff into a body of water .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A man does various flips while jumping off of a cliff into the water.<br>A man does a front flip off of a cliff into a body of water, then a backflip.<br>One of the men from the top of the cliff jumped off and landed in the water<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A man does various flips while jumping off of a cliff into the water.<br>A man does a front flip off of a cliff into a body of water, then a backflip.<br>A boy jumps off a cliff into a pool of water.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A person jumps off a cliff into a large body of water.<br>A boy jumps from a cliff into some water and another boy is climbing out of the water</p>
<hr>
<p>Class: giving or receiving award Video: kRdxCmOsY2Y_000003_000013</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV15A411i7Cg&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A man stands on a stage in front of an audience as he hands an award to another man walking on the stage.<br>[2] Four people are called up onto a stage, and one accepts an award.<br>[3] A man is presenting a prize to a group of four.<br>[4] A man stands on a stage in front of an audience as he hands an award to another man walking on the stage.<br>[5] A man presents a group of young adults with an award.<br><strong>Prediction:</strong><br>[baseline]: a man is standing in front of a crowd and singing a song .<br>[graph_kl]: a group of people are on a stage in front of an audience .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>An older gentleman is standing at a podium accepting an award when another gentleman walks across the stage and shakes his hand.<br>People are cheering as a man is welcomed on stage.<br>A man is on a stage introducing himself to an audience.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>An older gentleman is standing at a podium accepting an award when another gentleman walks across the stage and shakes his hand.<br>A man is standing on a stage and speaking to a crowd.<br>A man is on a stage introducing himself to an audience.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>Three people are on stage performing a play and one of them is singing.<br>Two men and a woman are performing a play on a stage.</p>
<hr>
<p>Class: fly tying Video: _PdB7OGolCo_000191_000201</p>
<iframe src="//player.bilibili.com/player.html?aid=838500851&bvid=BV1Eg4y1q7fp&cid=203798508&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A spool of thread is wrapped around a small hook several times.<br>[2] A man uses an object to wrap string around another object.<br>[3] A person ties very fine string around a small hook.<br>[4] A spool of thread is wrapped around a small hook several times.<br>[5] Someone shows how to wrap a fish hook with thread using a tool to hold it.<br><strong>Prediction:</strong><br>[baseline]: a man is demonstrating how to make a fly fishing lure .<br>[graph_kl]: a man is demonstrating how to make a fishing lure .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>a person using their fingers to wrap string around a hook<br>A person holds a piece of string with a loop at the end, they place the loop over a hook and tighten the loop.<br>A man is carefully wrapping the hook with some thread.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A man is demonstrating how to wrap a hook with string.<br>A person is demonstrating how to tie a fishing string to a hook.<br>A man is demonstrating how to secure wire to a hook.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A man describes how to create snags using a line and a hook.<br>A person holds a hook and connects material to create a fly hook.</p>
<hr>
<p>Class: bottling Video: 38Jn4r_pcpg_000167_000177</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1Xt4y1X7L1&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A man is making beer and pours some of his beer into another container to even them out.<br>[2] A man is in a kitchen and pulls out bottles from a pot that is sitting on the counter.<br>[3] A man is in a kitchen and pulls out bottles from a pot that is sitting on the counter.<br>[4] A guy has two bottles in his hands and is pouring liquid from one bottle to the other.<br>[5] A man picks up to amber beer type bottles and pours fluid from one into the other.<br><strong>Prediction:</strong><br>[baseline]: a man is demonstrating how to make a recipe in a kitchen .<br>[graph_kl]: a man is demonstrating how to use a machine to make a meal .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>a man is pouring a bottle of beer into a large glass.<br>A man pours a bottle of beer into a large beer glass.<br>A man standing in a kitchen holds a bottle and a cup then pours whats in the bottle into the cup.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>a man is pouring a bottle of beer into a large glass.<br>A man pours a bottle of beer into a large beer glass.<br>A man picks up a brewing pot and pours water into a cup.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A man picks up a brewing pot and pours water into a cup.<br>A male is in the kitchen showing how he pours water out quickly out the pot.</p>
<hr>
<p>Class: dancing gangnam style Video: 53Ia-BtpM5A_000002_000012</p>
<iframe src="//player.bilibili.com/player.html?aid=841116130&bvid=BV1X54y1B7pu&cid=203898322&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A toddler girl dances across the floor while listening to music.<br>[2] A little girls is dancing to music next to her toy scooter.<br>[3] A toddler dressed in pink is dancing while music is playing.<br>[4] A toddler girl dances across the floor while listening to music.<br>[5] A little girl is dancing to the popular Korean song ‘Gangnam Style.’<br><strong>Prediction:</strong><br>[baseline]: a little girl is sitting on the floor and is dancing to music .<br>[graph_kl]: a little girl is sitting on the floor and dancing to music .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A little girl on a small table dances along to a video playing on tv.<br>A young girl is giving a tap dancing performance while music plays in the background.<br>A group of young people are shown while a girl is shown dancing to music.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>Two young girls are dancing to music at a restaurant.<br>a young boy is in his room listening to music and dancing<br>A young man dances on a kitchen floor as music plays.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>a small girl riding her small pink bike while a bell clinks<br>This little girl is dancing on her toes like a ballerina.</p>
<hr>
<p>Class: falling off bike Video: 7QyQVBclhT4_000000_000010</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV18a4y1Y7Bn&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A kid rides a bike down a hill going too fast and has a wipe out.<br>[2] A young kid riding a bike across sand and crashing it<br>[3] Uncontrolled bicycle, careening down a desert hill, leaves boy with multiple sand abrasions.<br>[4] A kid rides a bike down a hill going too fast and has a wipe out.<br>[5] A boy is speeding down a sand hill on a bicycle which wobbles and throws him off.<br><strong>Prediction:</strong><br>[baseline]: a man is riding a bike on a beach and then falls over .<br>[graph_kl]: a man is riding a bike on a dirt road .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A guy on a bike goes down a steep hill and wrecks, tumbling down the hill.<br>A boy tips forward and falls on his face while trying to do a bicycle trick.<br>Slow motion action of young man jumping with bicycle doen a hillside and tumbling to the bottom.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A man rides his bike in the snow and wipes out.<br>A man on a bike goes down a hill then falls off from his bike.<br>A person rides a dirtbike up a steep hill then falls.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A person rides a bicycle down a hill and over a dirt berm<br>A man rode a dirt bike over a very steep dirt hill</p>
<hr>
<p>Class: long jump Video: QyMTEHd-VCc_000004_000014</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1v54y1B7X4&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A person is running and then performs a long jump into a sand box.<br>[2] A woman is practicing her long jumps while her friend records.<br>[3] A woman runs then does a high jump to create distance.<br>[4] A woman runs then does a high jump to create distance.<br>[5] A person is running and then performs a long jump into a sand box.<br><strong>Prediction:</strong><br>[baseline]: a man is running down a track and jumps into a pit of sand .<br>[graph_kl]: a man runs down a track and jumps into a sand pit .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A person running and then leaping to perform a long jump<br>An athlete runs down the track and performs a long jump.<br>People watch as a woman runs down a track, then jumps into the air for a long jump.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>An athlete runs down the track and performs a long jump.<br>A man is running and doing a long jump, while people are watching.<br>A young woman runs down an asphalt track then performs a long jump.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A competitor is taking a running start and then successfully performs a high jump.<br>A person is outside and they are jumping over a vault for some type of track event.</p>
<hr>
<p>Class: knitting Video: t-COcCPV-T4_000020_000030</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1ff4y1y7xc&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] Someone is showing how to crochet through some sort of material.<br>[2] A gir lis trying to stitching up the black and white knitting kit with a knitting needle<br>[3] A young girl shows how to crochet and encourages her own type of technique.<br>[4] A gir lis trying to stitching up the black and white knitting kit with a knitting needle<br>[5] Someone is showing how to crochet through some sort of material.<br><strong>Prediction:</strong><br>[baseline]: a person is demonstrating how to fix a bicycle .<br>[graph_kl]: a person is using a needle to sew a piece of fabric .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A woman holds needle and yarn and she demonstrates how to knit.<br>A woman demonstrates how to knit using needles and yarn.<br>A tutorial with a women demonstrating knitting techniques using yarn.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A woman is demonstrating how to work with a piece of fabric.<br>A woman demonstrates how to knit using needles and yarn.<br>A person is demonstrating how to weave a small basket.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A person is using cloth to design an image of a frog.<br>A person with glasses works on the tubing of a bicycle tire.</p>
<hr>
<p>Class: historical reenactment Video: oGpVHf4xooM_000160_000170</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1Bp4y1D7NJ&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] People are watching as men in uniforms are shooting each other.<br>[2] People are watching as men in uniforms are shooting each other.<br>[3] A group of people in uniforms fire guns while a crowd watches.<br>[4] A group of people watch a reenact-ion of a fight from the American revolution from behind a fence.<br>[5] People are moving across a green field and firing rifles, while spectators look on.<br><strong>Prediction:</strong><br>[baseline]: a large group of people are gathered around a large group of people .<br>[graph_kl]: a group of people are standing in a field and a man is talking .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A group of people are watching a war reenactment and walking around.<br>Civil war reenactors are shooting at each other as someone is recording them.<br>A group of people are in a field re-enacting a battle scene with guns.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A group of people are watching a war reenactment and walking around.<br>A group of men in a field are doing an reenactment of a battle and firing guns.<br>Several people are in a field doing a war re-enactment.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A group of people are outside, they are dressed up and recreating the civil war.<br>People are sitting outside talking as some other people are standing up.</p>
<hr>
<p>Class: home roasting coffee Video: WU5KZsG_mQk_000483_000493</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1XC4y1a7Cf&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A man is pouring hot coffee beans from a roaster onto a flat surface.<br>[2] A person illustrates and demonstrates how to brew several types of cocoa beans for coffee making.<br>[3] A man is pouring hot coffee beans from a roaster onto a flat surface.<br>[4] A person is removing a set of beans on a table that  are being prepped for dinner.<br>[5] A person illustrates and demonstrates how to brew several types of cocoa beans for coffee making.<br><strong>Prediction:</strong><br>[baseline]: a man is using a power tool to cut a piece of metal .<br>[graph_kl]: a person is using a machine to heat a piece of metal .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A man using a roasting machine to roast coffee beans.<br>A person lifts up a switch which drops coffee beans into a machine that stirs them.<br>A man is stiring some coffee beans in a strainer with a wooden spoon<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A man using a roasting machine to roast coffee beans.<br>The lady is doing a demonstration on the equipment to roast coffee beans.<br>A person is roasting coffee beans in a wok and then puts them in a cup.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A man wearing protective headwear uses a soldering  iron to solder two piece of metal together.<br>A man has put coffee beans into a metal strainer and using a wooden spoon is grinding the beans so they will be ready to be used to make a special coffee.</p>
<hr>
]]></content>
  </entry>
  <entry>
    <title>少样本学习(few-shot learning)</title>
    <url>/2019/04/09/%E5%B0%91%E6%A0%B7%E6%9C%AC%E5%AD%A6%E4%B9%A0-few-shot-learning/</url>
    <content><![CDATA[<h2 id="小样本学习的概念"><a href="#小样本学习的概念" class="headerlink" title="小样本学习的概念"></a>小样本学习的概念</h2><ul>
<li>少样本学习(few-shot learning)的目标是在<strong>已知类别(Seen Class)训练一个分类模型，使它能够在只有少量数据的未知类别(Unseen Class)上面具有很好的泛化性能</strong>。</li>
<li>少样本学习面临两个重要的问题：<br>（1）已知类别和未知类别之间没有交集，导致它们的数据分布差别很大，不能直接通过训练分类器和微调(finetune)的方式得到很好的性能；<br>（2）未知类别只有极少量数据(每个类别1或者5个训练样本)，导致分类器学习不可靠。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>实验中遇到的问题及解决</title>
    <url>/2019/08/05/%E5%AE%9E%E9%AA%8C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题 1"></a>问题 1</h3><ul>
<li>问题描述：首先表现为：在pycharm debug下和在running模式下的实验结果不一致，&lt;/br&gt;<br>后来，在训练阶段将预训练的模型保存下来，载入evaluate.py 文件中再次进行评估，得到的分数与在训练阶段评估的分数不一致</li>
<li>解决思路：由于第二个现象，更加容易解决，因此先解决他，师兄提出一个办法，将保存的模型再次载入，这样就可以有两个网络，然后比较两个网络的数据是在哪里出现差异的，这样可以找到问题。</li>
<li>解决办法：</li>
</ul>
<ol>
<li>在训练一个epoch 后，将模型保存了下来，然后用两个网络，一个时train.py中重新加载这个网络，一个是在evaluate.py中加载这个网络，将得到的结果，进行比较，（看输出的结果是否一致），然后发现，在一些video 输出的结果是一样的，在一些video是不一样的。&lt;/br&gt;</li>
<li>找到那些video对应的结果不一样的所对应的iteration，在该iteration打印出了网络中的部分变量的数据，发现，在dataloader的数据就是不一样的.&lt;/br&gt;</li>
<li>那么问题就是出现在数据加载上。通过对数据加载部分的代码进行调试，发现，仅在num_workers=0时，两个dataloader的数据才一样，而采用多线程的话，两个dataloader的数据不完全一样。而又在其他的代码上测试，多线程不会影响数据加载，那么问题就是出现在，自己设计的dataset上，&lt;/br&gt;</li>
<li>又发现在加载h5py文件时，没有取切片，而self.critical pytorch代码时加上了的，通过加上切片 <code>[:]</code> 发现在多线程时，是正常的。</li>
</ol>
]]></content>
      <categories>
        <category>问题总结</category>
      </categories>
      <tags>
        <tag>问题总结</tag>
      </tags>
  </entry>
  <entry>
    <title>对分类损失的优化</title>
    <url>/2019/09/23/%E5%AF%B9%E5%88%86%E7%B1%BB%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>指数加权平均</title>
    <url>/2019/04/09/%E6%8C%87%E6%95%B0%E5%8A%A0%E6%9D%83%E5%B9%B3%E5%9D%87/</url>
    <content><![CDATA[<p>参考：<a href="https://zhuanlan.zhihu.com/p/29895933" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29895933</a><br><a href="https://www.jianshu.com/p/41218cb5e099" target="_blank" rel="noopener">https://www.jianshu.com/p/41218cb5e099</a></p>
<h2 id="指数加权平均"><a href="#指数加权平均" class="headerlink" title="指数加权平均"></a>指数加权平均</h2><p><strong>v<sub>t</sub></strong> 是要代替  θ_t  的估计值，代表第t天的指数平均温度值<br><strong>θ<sub>t</sub></strong> 代表第t天的实际温度值<br><strong>β</strong> 代表可调节的超参数值  </p>
<p>则第t天的指数平均温度，可用如下公式表示<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1wnugwmkrj30ne0ggjsp.jpg" width="50%" height="50%">    </p>
<p>将<strong>v<sub>100</sub></strong> 展开可得:<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1wonisescj30j201o0sr.jpg"><br>v<sub>t</sub> 是对每天温度的加权平均，之所以称之为指数加权，是因为加权系数是随着时间以指数形式递减的，<strong>时间越靠近，权重越大</strong>，越靠前，权重越小。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1667471-485da343fbd96353.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/665/format/webp" alt><br>再来看下面三种情况：</p>
<p>当 β = 0.9 时，指数加权平均最后的结果如图<strong>红色线</strong>所示，代表的是最近 10 天的平均温度值；<br>当 β = 0.98 时，指结果如图<strong>绿色线</strong>所示，代表的是最近 50 天的平均温度值；<br>当 β = 0.5 时，结果如下图<strong>黄色线</strong>所示，代表的是最近 2 天的平均温度值；</p>
<p><img src="//upload-images.jianshu.io/upload_images/1667471-7d82e7b89e860299.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/473/format/webp" alt></p>
<p><img src="//upload-images.jianshu.io/upload_images/1667471-6fd989467bcb6121.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/475/format/webp" alt></p>
<p><strong>β 越小，噪音越多</strong>，虽然能够很快的适应温度的变化，但是更容易出现奇异值。</p>
<p><strong>β 越大，得到的曲线越平坦</strong>，因为多平均了几天的温度，这个曲线的波动更小。<br>但有个缺点是，因为只有 0.02 的权重给了当天的值，而之前的数值权重占了 0.98 ，<br>曲线进一步右移，在温度变化时就会适应地更缓慢一些，会出现一定延迟。</p>
<p>通过上面的内容可知，β 也是一个很重要的超参数，不同的值有不同的效果，需要调节来达到最佳效果，<strong>一般 0.9 的效果就很好</strong>。</p>
<p>作者：不会停的蜗牛<br>链接：<a href="https://www.jianshu.com/p/41218cb5e099" target="_blank" rel="noopener">https://www.jianshu.com/p/41218cb5e099</a><br>来源：简书  </p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>我们可以看到指数加权平均的求解过程实际上是一个递推的过程，那么这样就会有一个非常大的好处，每当我要求从0到某一时刻（n）的平均值的时候，我并不需要像普通求解平均值的作为，保留所有的时刻值，类和然后除以n。</p>
<p>而是只需要保留0-(n-1)时刻的平均值和n时刻的温度值即可。也就是每次只需要保留常数值，然后进行运算即可，这对于深度学习中的海量数据来说，是一个很好的减少内存和空间的做法。</p>
<h2 id="为什么在优化算法中使用指数加权平均"><a href="#为什么在优化算法中使用指数加权平均" class="headerlink" title="为什么在优化算法中使用指数加权平均"></a>为什么在优化算法中使用指数加权平均</h2><p>上面提到了一些 指数加权平均 的应用，这里我们着重看一下在优化算法中的作用。</p>
<p>以 Momentum 梯度下降法为例，</p>
<p><strong>Momentum 梯度下降法</strong>，就是计算了梯度的指数加权平均数，并以此来更新权重，它的运行<strong>速度几乎总是快于标准的梯度下降算法</strong>。</p>
<p><strong>这是为什么呢？</strong></p>
<p>让我们来看一下这个图，</p>
<p><img src="//upload-images.jianshu.io/upload_images/1667471-07d825d3e2624537.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/745/format/webp" alt></p>
<p>例如这就是我们要优化的成本函数的形状，图中红点就代表我们要达到的最小值的位置，<br>假设我们<strong>从左下角这里出发开始用梯度下降法</strong>，那么蓝色曲线就是一步一步迭代，一步一步向最小值靠近的轨迹。</p>
<p>可以看出<strong>这种上下波动，减慢了梯度下降法的速度</strong>，而且无法使用更大的学习率，因为如果用较大的学习率，可能会偏离函数的范围。</p>
<p>如果有一种方法，可以使得在纵轴上，学习得慢一点，减少这些摆动，但是在横轴上，学习得快一些，快速地从左向右移移向红点最小值，那么训练的速度就可以加快很多。</p>
<p>这个方法就是动量 Momentum 梯度下降法，它<strong>在每次计算梯度的迭代中，对 dw 和 db 使用了指数加权平均法的思想</strong>，</p>
<p><img src="//upload-images.jianshu.io/upload_images/1667471-eedf9342a4bce813.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/272/format/webp" alt></p>
<p>这样我们就可以得到如图红色线的轨迹：</p>
<p><img src="//upload-images.jianshu.io/upload_images/1667471-f9e70b57daae0359.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/718/format/webp" alt></p>
<p>可以看到：<br><strong>纵轴方向</strong>，平均过程中正负摆动相互抵消，平均值接近于零，摆动变小，学习放慢。<br><strong>横轴方向</strong>，因为所有的微分都指向横轴方向，因此平均值仍然较大，向最小值运动更快了。<br>在抵达最小值的路上减少了摆动，加快了训练速度。</p>
<p>作者：不会停的蜗牛<br>链接：<a href="https://www.jianshu.com/p/41218cb5e099" target="_blank" rel="noopener">https://www.jianshu.com/p/41218cb5e099</a><br>来源：简书  </p>
]]></content>
  </entry>
  <entry>
    <title>排序(sort)</title>
    <url>/2019/04/18/%E6%8E%92%E5%BA%8F-sort/</url>
    <content><![CDATA[<ul>
<li>快速排序与冒泡排序均是进行交换操作，使用的空间复杂度为O(1)，而插入排序的空间复杂度为O(n)</li>
<li>快速排序的平均时间复杂度为O(nlogn)，最坏情况复杂度为O(n^2)</li>
<li>冒泡排序的时间复杂度为O(n^2)</li>
<li>插入排序的时间复杂度为O(n^2)</li>
</ul>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><blockquote>
<p>待补充</p>
</blockquote>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(nums, left, right)</span>:</span></span><br><span class="line">    tmp = left</span><br><span class="line">    reference = nums[left]  <span class="comment"># 以最左端的nums[left] 作为中位数</span></span><br><span class="line">    left = left</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] &lt;= reference:</span><br><span class="line">            left = left + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] &gt; reference:</span><br><span class="line">            right = right - <span class="number">1</span></span><br><span class="line">        nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">    <span class="keyword">if</span> nums[left] &lt; reference:</span><br><span class="line">        nums[left], nums[tmp] = nums[tmp], nums[left]</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        nums[left<span class="number">-1</span>], nums[tmp] = nums[tmp], nums[left<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> left<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">QuickSort</span><span class="params">(nums , left, right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; right:</span><br><span class="line">        index = partition(nums, left, right)</span><br><span class="line">        QuickSort(nums, left, index<span class="number">-1</span>)</span><br><span class="line">        QuickSort(nums, index+<span class="number">1</span>, right)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment"># nums = [1,2,3,4]</span></span><br><span class="line"><span class="comment"># nums = [3,2,5,6,4,4,4,5,6]</span></span><br><span class="line">left = <span class="number">0</span></span><br><span class="line">right = len(nums)<span class="number">-1</span></span><br><span class="line">QuickSort(nums, left, right)</span><br><span class="line">print(nums)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最新机器翻译进展</title>
    <url>/2021/06/07/%E6%9C%80%E6%96%B0%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91%E8%BF%9B%E5%B1%95/</url>
    <content><![CDATA[<h2 id="AAAI-2021"><a href="#AAAI-2021" class="headerlink" title="AAAI  2021"></a>AAAI  2021</h2><p>在 AAAI2021 上同样涌现了许多关于机器翻译任务的研究工作，几乎所有的工作都是基于Transformer模型展开讨论。这里对机器翻译在AAAI2021上的最新研究进展进行总结：</p>
<h2 id="1-引入语法信息"><a href="#1-引入语法信息" class="headerlink" title="1. 引入语法信息"></a><strong>1. 引入语法信息</strong></h2><p>尽管依托于模型本身本文就能从海量数据中捕获到语言之间的映射关系，但研究人员一直在探索如何将句法、语义等先验知识有效地融入到模型中，并指导模型取得进一步的性能突破。传统的做法通常使用外部工具从训练样本中构造句法树等先验知识，之后在编码端、解码端分别融入先验知识。SyntAligner[1]采取一种自监督双语句法对齐方法，让模型在高维空间中对源语-目标语的句法结构进行精确对齐，从而最大限度地利用对齐后的句法结构之间的互信息提高翻译的性能。</p>
<blockquote>
<p>Self-supervised Bilingual Syntactic Alignment for Neural Machine Translation</p>
</blockquote>
<h2 id="2-无监督机器翻译"><a href="#2-无监督机器翻译" class="headerlink" title="2. 无监督机器翻译"></a><strong>2. 无监督机器翻译</strong></h2><p>无监督机器翻译同样是机器翻译中备受关注的研究热点。在现实世界中，除了部分富资源语言（如英语，汉语，德语，俄语，印地语等），更多的语言本身受众较小，缺乏海量的双语平行语料进行监督学习。因此，如何在这种资源匮乏，甚至零资源的条件下，学习语言之间的映射是极具挑战的。目前无监督机器翻译通常采用迭代式的back-translation。此外，利用预训练的技术手段能够有效地加快模型的收敛，提高翻译的正确性。[2]通过在构造伪数据的过程中对合成的句子进行正则化约束能够有效地改善翻译的性能。</p>
<blockquote>
<p>Empirical Regularization for Synthetic Sentence Pairs in Unsupervised Neural Machine Translation</p>
</blockquote>
<h2 id="3-多语言翻译"><a href="#3-多语言翻译" class="headerlink" title="3. 多语言翻译"></a><strong>3. 多语言翻译</strong></h2><p>伴随着机器翻译的发展，研究人员逐渐开始探索不局限于双语句对之间的翻译。多语言模型通过一个模型实现多个语种之间的翻译能够有效降低多语言翻译部署成本。同时将一种源语言翻译成多种不同的目标语言是多语言翻译最常见的场景之一。SimNMT[3]提出了一种同步交叉交互解码器，即在每个目标语生成时，可以依赖未来的信息，以及其他目标语言的历史和未来的上下文信息，充分利用语言内与语言间的信息。</p>
<h2 id="4-语音翻译"><a href="#4-语音翻译" class="headerlink" title="4. 语音翻译"></a><strong>4. 语音翻译</strong></h2><p>语音翻译直接将源语的语音翻译成目标语言的文本。传统的方法中，采用语音识别和机器翻译级联的方法来解决这一问题。但是具有延迟高，占用存储大，以及容易产生错误累积的问题，很多工作开始关注直接使用端到端的语音到文本的模型来解决这一问题。对于跨模态之间的语言映射，为了让单一的模型充分学习模态之间的关联信息，往往需要引入更多的跨模态和跨语言的特征，造成了沉重的负担，同时单纯的用于端到端模型的语音到文本数据较少，无法充分利用语言识别和机器翻译的数据。为了解决这些问题，COSTT[4]作为一种通用的框架同时结合了级联模型与端到端模型的优点，能够更好地利用大规模双语平行语料，在多个测试集上取得了最优的效果。</p>
<p>同声传译是一种实时的语言翻译场景，对翻译时延的要求更加严格。目前主流的手段是采用Wait-K策略，但仍然存在由于重复编码导致的训练慢，以及缺少对未来信息建模的问题。Future-guided Training[5]采取unidirectional Transformer方式来避免重复编码，并引入averaged embedding来满足当前词与过去词之间的信息交互。同时利用知识精炼的手段让网络充分利用未来的信息，从而达到更准确的预测。</p>
<h2 id="5-领域适应"><a href="#5-领域适应" class="headerlink" title="5. 领域适应"></a><strong>5. 领域适应</strong></h2><p>在神经机器翻译中，通过微调来做领域的迁移是一种常见的方法。但是，无约束的微调需要非常仔细的超参数调整，否则很容易在目标域上出现过拟合，导致在通用领域上的性能退化。PRUNE-TUNE[6]是一种基于渐变修剪的领域适应算法。它学习微小的特定于领域的子网以进行调优，通过调整它相应的子网来适应一个新的领域。有效缓解了在微调过中的过拟合和退化问题。</p>
<p>此外，领域适应与其他方法相结合也是研究的一个热点。元学习对于低资源神经机器翻译(NMT)的有效性已经得到了充分的验证。但是元训练的NMT系统在未见领域中的翻译性能仍然较差。Meta-Curriculum Learning[7]是一种新的面向领域适应的元课程学习方法。在元训练过程中，NMT首先从各个领域学习相似的知识，以避免早期陷入局部最优，最后学习针对不同领域学习个性化的知识，以提高模型对领域特定知识学习的鲁棒性。</p>
<h2 id="6-解码加速：轻量模型-非自回归解码"><a href="#6-解码加速：轻量模型-非自回归解码" class="headerlink" title="6. 解码加速：轻量模型/非自回归解码"></a><strong>6. 解码加速：轻量模型/非自回归解码</strong></h2><p>过参数化的（超大规模）模型能够有效提升神经机器翻译的性能，但是庞大的存储开销和高昂的计算复杂度使得这类模型无法直接部署到边缘设备(如手机，翻译笔，离线翻译机等)上。早期为了提高模型对未登录词的覆盖度往往使用更大的词表，同时增大了词嵌入矩阵的存储开销，以及构建词表上概率分布时对计算资源的消耗。针对该问题，Partial Vector Quantization[8]提出了一种部分矢量量化的方法，通过压缩词嵌入降低softmax层的计算复杂度，同时使用查找操作来替换softmax层中的大部分乘法运算，在保障翻译质量的同时大大减少了词嵌入矩阵的参数和softmax层的计算复杂度。</p>
<p>近期，深层模型在神经机器翻译中取得突破性进展，但伴随着层数的堆叠同样面临上述问题。GPKD[9]中提出一种基于群体置换的知识蒸馏方法将深层模型压缩为浅层模型，该方法可以分别应用与编码端与解码端达到模型压缩和解码加速的目的。文中探讨了一种深编码器-浅解码器的异构网络， 其既能保证翻译的准确度，同时满足工业生产的推断时延需求。此外采用子层跳跃的正则化训练方法缓解随着网络加深带来的过拟合问题。</p>
<p>此外，沿着减少解码端计算复杂度的研究方向，例如Averaged Attention Network（ACL2018）和Sharing Attention Network（IJCAI2019），Compressed Attention Network[10]采取压缩子层的方式，将解码器每一层中分离的多个子层压缩成一个子层，进而简化解码端的计算复杂度，达到解码加速的目的。这种方式在深编码器-浅解码器的结构上取得了进一步的加速增益。</p>
<p>上述的工作通过轻量化模型提高推断速度，本质上在解码过程中还是采用自回归的方式。相比之下非自回归解码同样是一种有效的解码加速手段。非自回归神经机器翻译系统(NAT)通过打破自回归性，并行地生成所有目标词，大幅度地提高了推断速度。然而，现有的NAT模型由于<strong>多峰问题</strong>，与自回归神经网络机器翻译模型相比，翻译质量仍有很大差距。<strong>什么是多峰问题</strong>，举个简单的例子将汉语句子“干/得/好/！”翻译成英文，可以翻译成“Good job !”或者“Well done !”。由于非自回归模型的条件独立性假设，推断时第一个词“Good”和“Well”的概率是差不多大的，如果第二个词“job”和“done”的概率也差不多大，会使得模型生成出“Good done !”或者“Well job !”这样错误的翻译。ReorderNAT[11]提出一个新颖的NAT框架，通过显式地建模重排序信息来指导非自回归解码。区别于传统方法，根据源语的繁衍率来构造解码端的输入，ReorderNAT在编码器和解码器中间引入了重排序机制。该机制将源语的表示按照目标语的语序进行重新组合，减少解码器对语序的再加工。</p>
<h2 id="7-评测方法及应用"><a href="#7-评测方法及应用" class="headerlink" title="7. 评测方法及应用"></a><strong>7. 评测方法及应用</strong></h2><p>除了针对机器翻译系统的研究外，如何有效的评估机器翻译系统的性能也是一个重要的研究方向。通常情况下我们使用BLEU作为译文质量评估的常用指标，但是在很多应用场景中，并没有可以对比的参考译文。机器翻译质量评估(QE)便是在不依赖任何参考译文的情况下预测机器翻译质量的一项任务。在QE任务中，通常使用预测器-估计器框架(Predictor-Estimator)。使用预训练的预测器作为特征提取器，再通过评估器对译文进行评估。但是预测器和估计器在训练数据和训练目标上都存在差距，这使得QE模型不能更直接地从大量平行语料库中受益。<strong>DirectQE</strong>[12]中提出了一个新框架，通过生成器在构造QE伪数据，使用额外的探测器在生成的数据上进行训练，并为QE任务设定了新的学习目标，将原本分离的过程进行整合。</p>
<p>同样机器翻译本身也可以作为工具应用于其他的任务。研究人员为了解决问答任务的数据稀缺问题，通过机器翻译方法来构造多语言问答数据[13]。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <strong>Self-supervised Bilingual Syntactic Alignment for Neural Machine Translation</strong></p>
<p>[2] Empirical Regularization for Synthetic Sentence Pairs in Unsupervised Neural Machine Translation</p>
<p>[3] Synchronous Interactive Decoding for Multilingual Neural Machine Translation</p>
<p>[4] Consecutive Decoding for Speech-to-text Translation</p>
<p>[5] Future-Guided Incremental Transformer for Simultaneous Translation</p>
<p>[6] Finding Sparse Structure for Domain Specific Neural Machine Translation</p>
<p>[7] Meta-Curriculum Learning for Domain Adaptation in Neural Machine Translation</p>
<p>[8] Accelerating Neural Machine Translation with Partial Word Embedding Compression</p>
<p>[9] Learning Light-Weight Translation Models from Deep Transformer</p>
<p>[10] An Efficient Transformer Decoder with Compressed Sub-layers</p>
<p>[11] <strong>Guiding Non-Autoregressive Neural Machine Translation Decoding with Reordering Information</strong></p>
<p>[12] <strong>DirectQE: Direct Pretraining for Machine Translation Quality Estimation</strong></p>
<p>[13] Multilingual Transfer Learning for QA Using Translation as Data Augmentation</p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>数据集收集过程--各论文汇总</title>
    <url>/2020/06/06/%E6%95%B0%E6%8D%AE%E9%9B%86%E6%94%B6%E9%9B%86%E8%BF%87%E7%A8%8B-%E5%90%84%E8%AE%BA%E6%96%87%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h3 id="Stanford-Natural-Language-Inference"><a href="#Stanford-Natural-Language-Inference" class="headerlink" title=" Stanford Natural Language Inference "></a><font color="red"> Stanford Natural Language Inference </font></h3><blockquote>
<p>A large annotated corpus for learning natural language inference</p>
</blockquote>
<h4 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a><strong>数据收集</strong></h4><p>从Flickr 上的human written captions 作为 <strong>premises</strong> 。</p>
<p>（1）AMT workers 手工写 与 premises 相对应label下的句子：（不提供图像的前提下）Asked AMT workers to supply hypotheses for each of our three labels entailment, neutral, and contradiction. 即得到<strong>hypotheses</strong> 。 (这种label, 称为 author label)</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gfhjx642jrj30k90pk441.jpg" style="zoom:50%"></p>
<p>（2）基于得到的premises-hypotheses pair，再由4个 AMT workers进行评估，从三种类别中【entailment, neutral, and contradiction  】中，选择一个label，基于此，则对于每个premises-hypotheses pair，有5个label，基于共识，为该pair选择一个最终的label（称为 gold label.）</p>
<blockquote>
<p>5个label: </p>
<p>(1) original author 算一个，因为他是首先在给定promise 和 label 的情况下，写出的hypotheses</p>
<p>(2) 根据 给出的 promise 和 hypotheses， 来给标签，【entailment, neutral, and contradiction】</p>
<p>共识：如果有&gt;=3个人给出同一个标签，则赋予为该标签</p>
<p>但是，若没有这种共识（2% of cases），则分配一个占位符。（但是，这种数据没有什么用，无法应用于NLI任务）</p>
</blockquote>
<h4 id="Data-validation"><a href="#Data-validation" class="headerlink" title="Data validation  "></a><strong>Data validation  </strong></h4><p><strong>为了评估，基于上述的数据标注，得到的数据是否可靠</strong>。又从整个标注的数据中取了5%，再次由AMT workers做如（2）中的标注工作。看看前后两次标注的结果是否相关。这次AMT workers 选择的label 称为 Individual label 。得到如下的统计结果。可以看出Individual label 与之前的 gold label/ author’s label 有较高的一致性，即，之前的标注工作是可靠的。</p>
<ul>
<li><font color="red"><strong>yaya</strong> </font>个人觉得，这是一种马后炮的行为，没什么用，因为之前的标注，已经完成了，钱也花了。这种验证，即便是验证结果不好，那也没有什么修正措施。</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gfhl3kdkdtj30gj0na42d.jpg" style="zoom:50%"></p>
<p>表格中还使用 Fleiss 来计算human annotator 之间的一致性</p>
<blockquote>
<p>Fleiss : <a href="https://www.jianshu.com/p/f9c383b39859" target="_blank" rel="noopener">简书</a><br><a href="shiyaya.github.io/2020/08/06/评价者之间的一致性-Kappas/">yaya blog</a></p>
</blockquote>
<h3 id="Visual-Entailment-Dataset"><a href="#Visual-Entailment-Dataset" class="headerlink" title=" Visual Entailment Dataset  "></a><font color="red"> Visual Entailment Dataset  </font></h3><h4 id="数据收集-1"><a href="#数据收集-1" class="headerlink" title="数据收集"></a>数据收集</h4><p>该数据集是在 Flickr 和 SNLI dataset 的一个简单集成。</p>
<p>任务是，给出一个image-text pair，希望model 预测该pair 的匹配程度[Entailment, Contradiction, Neutral]。</p>
<p>数据的收集：在 SNLI dataset 就是基于 Flickr30k image captions 构建的，</p>
<ul>
<li><strong>Entailment</strong> holds if there is enough evidence in image to conclude that text is true.</li>
<li><strong>Contradiction</strong> holds if there is enough evidence in image to conclude that text is false.</li>
<li><strong>Neutral</strong>, implying the evidence in image is insufficient to draw a conclusion about text.  </li>
</ul>
<h4 id="该文提出了几个构建数据集的准则"><a href="#该文提出了几个构建数据集的准则" class="headerlink" title="该文提出了几个构建数据集的准则"></a><strong>该文提出了几个构建数据集的准则</strong></h4><p>基于在SNLI, VQA-v1.0, VQA-v2.0, and CLEVR, 这个几个数据集上的经验， 这里提出了四个准则来开发一个新的数据集:</p>
<ul>
<li><strong>Structured set of real-world images.</strong> The dataset should be based on real-world images and the same image can be paired with different hypotheses to form different labels. </li>
<li><strong>Fine-grained.</strong> The dataset should enforce fine-grained reasoning about subtle changes in hypotheses that could lead to distinct labels. </li>
<li><strong>Sanitization.</strong> No instance overlapping across different dataset partitions. One image can only exist in a single partition.  </li>
<li><strong>Account for any bias.</strong> Measure the dataset bias and  provide baselines to serve as the performance lower bound for potential future evaluations.  该文中提出了一些单纯仅仅使用</li>
</ul>
<h3 id="WMT-Shared-Task"><a href="#WMT-Shared-Task" class="headerlink" title="WMT Shared Task  "></a><font color="red">WMT Shared Task  </font></h3><h4 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h4><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gfijyrn8qsj30zw0gvwl7.jpg" style="zoom:50%"></p>
<h4 id="Human-judgement-quality-control"><a href="#Human-judgement-quality-control" class="headerlink" title="Human judgement quality control"></a>Human judgement quality control</h4><ul>
<li><p>每个标注者，每次HIT任务：给定100个 （reference+ candidate）pair, 针对给定的reference, 评估生成的candidate的好坏。</p>
</li>
<li><p>100个pair中有60个用于quality control，40个由participating systems 生成的翻译组成。</p>
<p>（1）这60个pair，是官方设计出来的，包括三类，repeat pairs (expecting a similar judgment), damage MT outputs/ bad reference (expecting significantly worse scores) and use references instead of MT outputs (expecting high scores). 因此仅仅会有20%的资源消耗：bad reference; good reference</p>
<p>Specifically，先从正常的MT system 中 得到30个 （reference, MT output）pair，如 table 5 中的 original system output， 然后1)对1-10对，进行重复，得到10对。2）对11-20对，将MT output搞破坏。或者是对reference caption搞破坏，得到10对。3）对21-30对，取corresponding reference—&gt; (reference_1, reference_2)，得到10对。</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gepxhtqcpgj311h052abz.jpg"></p>
<p>（2）within each 100-translation HIT， 每个articipating system<strong>等比例的贡献</strong>a（within each 100-translation HIT, the same proportion of translations are included from each participating system for that language pair.  ）这是为了确保每个参与的 系统含有近似的相同数量的评估。同时，这也从三个方面得到了公平性的评估：1）每有一个workers做一个HIT, 则就会为所有参与的系统增加human judgement。2）不会轻易受到worker个性差异的影响，因为每个worker都会给所有参与的系统进行评估。3）尽管DA判断是绝对的，但众所周知，判断者会根据观察到的总体翻译质量来“校准”他们使用量表的方式。 对于每个HIT（包括所有参与的系统），这种影响都是平均的。</p>
</li>
</ul>
<h4 id="Annotator-Agreement"><a href="#Annotator-Agreement" class="headerlink" title="Annotator Agreement"></a>Annotator Agreement</h4><p>（1）由于 bad reference pairs 的质量应该是显著偏低的，通过查看人类在这类pairs 上的评分是否也是显著偏低。来过滤掉可信赖度低的human assessors。</p>
<p>set（A, bad reference） 与  set（A, translatin_B）这两个集合上的人类评估，计算一个p-value， 若p-value&gt;0.05 则说明该human assessor的可信度低。</p>
<p>（2）对于 repeat pairs, 查看得到 repeat assessments的程度。</p>
<h4 id="Producing-the-Human-Ranking"><a href="#Producing-the-Human-Ranking" class="headerlink" title="Producing the Human Ranking"></a>Producing the Human Ranking</h4><ul>
<li><p>Standardized </p>
<p>为了消除不同的人类评估者的评分策略的差异，首先根据每个人类评估者的总体平均得分和标准差得分对翻译的人类评估得分进行<strong>标准化</strong>。</p>
</li>
</ul>
<h3 id="VIOLIN-Video-and-Language-Inference"><a href="#VIOLIN-Video-and-Language-Inference" class="headerlink" title="[VIOLIN] Video-and-Language Inference "></a><font color="red">[VIOLIN] Video-and-Language Inference </font></h3><p>yaya blog: <a href="https://shiyaya.github.io/2020/03/28/VIOLIN-A-Large-Scale-Dataset-for-Video-and-Language-Inference/" target="_blank" rel="noopener">https://shiyaya.github.io/2020/03/28/VIOLIN-A-Large-Scale-Dataset-for-Video-and-Language-Inference/</a></p>
<h4 id="数据集收集简介"><a href="#数据集收集简介" class="headerlink" title="数据集收集简介"></a>数据集收集简介</h4><p> 该任务是在给定 Subtitles  和 video 的情况下，推断一个statement 是否与 video 相符合[entailed (label 1) ，contradicts (label 0) ]。</p>
<p><strong>positive statements 的收集</strong>：给出 subtitles + video，然后annotators 写出与其想对应的 statements。</p>
<p><strong>negative statements 的收集</strong>：（1）要求annotators通过只更改positive statements 的几个单词或短语来编写negative statements。（2）进行<strong>对抗匹配</strong>：对于每个视频，从其他视频的陈述库中选择具有挑战性和令人困惑的陈述作为否定陈述。具体地，对于video_i/j 已经分别有其相对应的 positive statement H_i/j , 则通过查找与H_i 最相近的H_j 作为 negative statements。 对抗匹配的方式可以消除 human bias的影响。</p>
<h4 id="数据收集-Instruction"><a href="#数据收集-Instruction" class="headerlink" title="数据收集 Instruction"></a>数据收集 Instruction</h4><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gfil6timz7j31c60van7q.jpg"><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gfil6tix9ij313e150na4.jpg"><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gfil6tj9shj30ts14mtl2.jpg"></p>
<h4 id="用户界面-1"><a href="#用户界面-1" class="headerlink" title="用户界面"></a>用户界面</h4><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gfilt0g35qj316o128n4z.jpg" style="zoom:50%"></p>
<h3 id="VCR"><a href="#VCR" class="headerlink" title="VCR"></a><font color="red">VCR</font></h3><p>yaya blog: <a href="https://shiyaya.github.io/2020/05/16/From-Recognition-to-Cognition-Visual-Commonsense-Reasoning/" target="_blank" rel="noopener">https://shiyaya.github.io/2020/05/16/From-Recognition-to-Cognition-Visual-Commonsense-Reasoning/</a></p>
<h4 id="用户界面-2"><a href="#用户界面-2" class="headerlink" title="用户界面"></a>用户界面</h4><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gfioadgc3qj30r20pbn3e.jpg"></p>
<h4 id="Crowdsourcing-quality-data"><a href="#Crowdsourcing-quality-data" class="headerlink" title="Crowdsourcing quality data"></a>Crowdsourcing quality data</h4><p><strong>Automated quality checks</strong></p>
<p>在众包UI中加入了一些<strong>自动</strong>的检测，比如，workers 在写 question、answer、rationale 时，有单词数量的限制且必须要指定一个detection</p>
<p><strong>Instructions  </strong></p>
<p>鼓励workers，编写的question，是比较high-level的（需要一定的推理步骤），同时不要编写一些general questions, 即不针对image 本身的那些问题。</p>
<p>同时为workers 提供了一些例子展示。</p>
<p><strong>Qualification exam  </strong></p>
<p>再进行正式的标注之前，先做一个测试，验证该worker 具有标注VCR数据的能努力。</p>
<p>The qualification test included a mix of multiple-choice graded answers as well as a short written section, which was to provide a single question, answer, and rationale for an image.  </p>
<p>在完成这个质量测试之后，由发布该任务的requester(即VCR论文作者)来手工看，这个worker是否具有资格。</p>
<p><strong>Work verification</strong>  </p>
<p>查看 workers 编写的 question、answer、rationales是否符合要求。由于这项检查工作，工作量也很大，因此，将这种检查工作也当做另外一种 HIT 当做任务进行发布，由那些outstanding workers in previous annotation work 来完成这项检查工作, 每为 一位another worker完成了检查工作，将得到 $0.4</p>
<h3 id="Composite-dataset"><a href="#Composite-dataset" class="headerlink" title="Composite dataset"></a><font color="red">Composite dataset</font></h3><p>From: <code>From Images to Sentences through Scene Description Graphs using Commonsense Reasoning and Knowledge</code></p>
<h4 id="数据集介绍"><a href="#数据集介绍" class="headerlink" title="数据集介绍"></a>数据集介绍</h4><p>该篇文章是做 image captioning 任务，为了更好的评估该captioning model 的性能，将模型生成的预测上传到AMT，让人类去评估。（为了对比，除了评估our_captioning_model 的预测，本文还评估了gold-standard description 和 the output from a state-of-the-art image captioning system.  ）</p>
<p>该文中从两个方面进行评估：相关性和全面性:  <strong>how much the description conveys the image content</strong> (relevance) and <strong>how much of the image content is conveyed by the description</strong> (thoroughness)。</p>
<h4 id="Instruction"><a href="#Instruction" class="headerlink" title="Instruction"></a>Instruction</h4><ul>
<li>很简单的 Instruction，也没有给范例。</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gfiysqscgfj316r0e943t.jpg"><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gfiysr0uf8j317i0g2an3.jpg"></p>
<ul>
<li>没有说在数据标注过程中，加入一些监督workers的操作。（这主要是本篇的目的不是为了进行数据收集，而只是简单的去评估 captioning model）</li>
</ul>
<h3 id="Reinforcement-Learning-in-Image-QE"><a href="#Reinforcement-Learning-in-Image-QE" class="headerlink" title="Reinforcement Learning in Image QE"></a>Reinforcement Learning in Image QE</h3><p>From: Reinforcing an Image Caption Generator Using Off-Line Human Feedback  </p>
<p>该文是引入强化学习，以及human judgement score, 来做 image captioning 任务</p>
<p>为了评估提出的captioning model 的性能，将其在数据集上的预测结果，提交到众包平台，让人类进行打分。提出了两种评估方式：Single-caption evaluation  和 Side-by-side caption evaluation  </p>
<p><strong>Single-caption evaluation</strong></p>
<p>给出image-captioning pair,然后，让6个不同的raters进行打分[good, bad], 然后对这6个评分取平均，或者是取majority voting，作为该pair 的最终得分</p>
<p><strong>Side-by-side caption evaluation</strong>  </p>
<p>给出 (image, our_model_prediction, baseline_model_prediction) 这个三元组，然后让raters, 选一个更贴合image的sentence。<strong>并且，从三个方面进行评估，信息性、正确性、流畅性</strong></p>
]]></content>
  </entry>
  <entry>
    <title>梯度消失与梯度爆炸的原因以及解决方案</title>
    <url>/2019/03/22/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E4%B8%8E%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>转载from: <a href="https://blog.csdn.net/raojunyang/article/details/79962665" target="_blank" rel="noopener">https://blog.csdn.net/raojunyang/article/details/79962665</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要深入介绍深度学习中的梯度消失和梯度爆炸的问题以及解决方案。本文分为三部分，第一部分主要直观的介绍深度学习中为什么使用梯度更新，第二部分主要介绍深度学习中梯度消失及爆炸的原因，第三部分对提出梯度消失及爆炸的解决方案。有基础的同鞋可以跳着阅读。<br>其中，梯度消失爆炸的解决方案主要包括以下几个部分。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>预训练加微调</span><br><span class="line"><span class="bullet">- </span>梯度剪切、权重正则（针对梯度爆炸）</span><br><span class="line"><span class="bullet">- </span>使用不同的激活函数</span><br><span class="line"><span class="bullet">- </span>使用batchnorm</span><br><span class="line"><span class="bullet">- </span>使用残差结构</span><br><span class="line"><span class="bullet">- </span>使用LSTM网络</span><br></pre></td></tr></table></figure>
<h1 id="第一部分：为什么要使用梯度更新规则"><a href="#第一部分：为什么要使用梯度更新规则" class="headerlink" title="第一部分：为什么要使用梯度更新规则"></a>第一部分：为什么要使用梯度更新规则</h1><hr>
<ul>
<li><p>在介绍梯度消失以及爆炸之前，先简单说一说梯度消失的根源—–深度神经网络和反向传播。目前深度学习方法中，深度神经网络的发展造就了我们可以构建更深层的网络完成更复杂的任务，深层网络比如深度卷积网络，LSTM等等，而且最终结果表明，在处理复杂任务上，深度网络比浅层的网络具有更好的效果。但是，目前优化神经网络的方法都是基于反向传播的思想，即根据损失函数计算的误差通过梯度反向传播的方式，指导深度网络权值的更新优化。这样做是有一定原因的，首先，深层网络由许多非线性层堆叠而来，每一层非线性层都可以视为是一个非线性函数 (非线性来自于非线性激活函数），因此整个深度网络可以视为是一个复合的非线性多元函数 </p>
</li>
<li><p>我们最终的目的是希望这个多元函数可以很好的完成输入到输出之间的映射，那么，优化深度网络就是为了寻找到合适的权值，满足取得极小值点，比如最简单的损失函数 </p>
</li>
<li>假设损失函数的数据空间是下图这样的，我们最优的权值就是为了寻找下图中的最小值点，对于这种数学寻找最小值问题，采用梯度下降的方法再适合不过了。 </li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1baz0q65tj30e809edj1.jpg"></p>
<h1 id="第二部分：梯度消失、爆炸"><a href="#第二部分：梯度消失、爆炸" class="headerlink" title="第二部分：梯度消失、爆炸"></a>第二部分：梯度消失、爆炸</h1><p>梯度消失与梯度爆炸其实是一种情况，看接下来的文章就知道了。两种情况下梯度消失经常出现，一是在<strong>深层网络</strong>中，二是采用了<strong>不合适的损失函数</strong>，比如sigmoid。梯度爆炸一般出现在深层网络和<strong>权值初始化值太大</strong>的情况下，下面分别从这两个角度分析梯度消失和爆炸的原因。</p>
<h3 id="1-深层网络角度"><a href="#1-深层网络角度" class="headerlink" title="1.深层网络角度"></a>1.深层网络角度</h3><p>比较简单的深层网络如下：<br><img src="https://img-blog.csdn.net/20171219215626301?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图中是一个四层的全连接网络，假设每一层网络激活后的输出为,其中为第层, 代表第层的输入，也就是第层的输出，是激活函数，那么，得出，简单记为。<br>BP算法基于梯度下降策略，以目标的负梯度方向对参数进行调整，参数的更新为，给定学习率，得出。如果要更新第二隐藏层的权值信息，根据链式求导法则，更新梯度信息：<br>，很容易看出来，即第二隐藏层的输入。<br>所以说，就是对激活函数进行求导，如果此部分大于1，那么层数增多的时候，最终的求出的梯度更新将以指数形式增加，即发生<strong>梯度爆炸</strong>，如果此部分小于1，那么随着层数增多，求出的梯度更新信息将会以指数形式衰减，即发生了<strong>梯度消失</strong>。如果说从数学上看不够直观的话，下面几个图可以很直观的说明深层网络的梯度问题（图片内容来自参考文献1）：</p>
<p>注：下图中的隐层标号和第一张全连接图隐层标号刚好相反。<br>图中的曲线表示权值更新的速度，对于下图两个隐层的网络来说，已经可以发现隐藏层2的权值更新速度要比隐藏层1更新的速度慢</p>
<p><img src="https://img-blog.csdn.net/20171220110058983?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">那么对于四个隐层的网络来说，就更明显了，第四隐藏层比第一隐藏层的更新速度慢了两个数量级：</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdn.net/20171220110732927?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><strong>总结：</strong>从深层网络角度来讲，不同的层学习的速度差异很大，表现为网络中靠近输出的层学习的情况很好，靠近输入的层学习的很慢，有时甚至训练了很久，前几层的权值和刚开始随机初始化的值差不多。因此，梯度消失、爆炸，其<strong>根本原因</strong>在于反向传播训练法则，属于<a href="https://www.baidu.com/s?wd=%E5%85%88%E5%A4%A9%E4%B8%8D%E8%B6%B3&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">先天不足</a>，另外多说一句，Hinton提出capsule的原因就是为了彻底抛弃反向传播，如果真能大范围普及，那真是一个革命。</p>
<h3 id="2-激活函数角度"><a href="#2-激活函数角度" class="headerlink" title="2.激活函数角度"></a>2.激活函数角度</h3><p>其实也注意到了，上文中提到计算权值更新信息的时候需要计算前层偏导信息，因此如果激活函数选择不合适，比如使用sigmoid，梯度消失就会很明显了，原因看下图，左图是sigmoid的损失函数图，右边是其倒数的图像，如果使用sigmoid作为损失函数，其梯度是不可能超过0.25的，这样经过链式求导之后，很容易发生梯度消失，sigmoid函数数学表达式为：<br><img src="https://img-blog.csdn.net/20171220113129230?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="sigmoid函数"><img src="https://img-blog.csdn.net/20171220113422675?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="sigmoid函数导数"></p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">同理，<span class="built-in">tanh</span>作为损失函数，它的导数图如下，可以看出，<span class="built-in">tanh</span>比<span class="built-in">sigmoid</span>要好一些，但是它的倒数仍然是小于<span class="number">1</span>的。<span class="built-in">tanh</span>数学表达为：</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdn.net/20171220114016270?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="第三部分：梯度消失、爆炸的解决方案"><a href="#第三部分：梯度消失、爆炸的解决方案" class="headerlink" title="第三部分：梯度消失、爆炸的解决方案"></a>第三部分：梯度消失、爆炸的解决方案</h1><hr>
<h3 id="2-1-方案1-预训练加微调"><a href="#2-1-方案1-预训练加微调" class="headerlink" title="2.1 方案1-预训练加微调"></a>2.1 方案1-预训练加微调</h3><p>此方法来自Hinton在2006年发表的一篇论文，Hinton为了解决梯度的问题，提出采取无监督逐层训练方法，其基本思想是每次训练一层隐节点，训练时将上一层隐节点的输出作为输入，而本层隐节点的输出作为下一层隐节点的输入，此过程就是逐层“预训练”（pre-training）；在预训练完成后，再对整个网络进行“微调”（fine-tunning）。Hinton在训练深度信念网络（Deep Belief Networks中，使用了这个方法，在各层预训练完成后，再利用BP算法对整个网络进行训练。此思想相当于是先寻找局部最优，然后整合起来寻找全局最优，此方法有一定的好处，但是目前应用的不是很多了。</p>
<h3 id="2-2-方案2-梯度剪切、正则"><a href="#2-2-方案2-梯度剪切、正则" class="headerlink" title="2.2 方案2-梯度剪切、正则"></a>2.2 方案2-梯度剪切、正则</h3><p><strong>梯度剪切</strong>这个方案主要是针对梯度爆炸提出的，其思想是设置一个梯度剪切阈值，然后更新梯度的时候，如果梯度超过这个阈值，那么就将其强制限制在这个范围之内。这可以防止梯度爆炸。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注：在WGAN中也有梯度剪切限制操作，但是和这个是不一样的，WGAN限制梯度更新信息是为了保证lipchitz条件。</span><br></pre></td></tr></table></figure>
<p>另外一种解决梯度爆炸的手段是采用<strong>权重正则化</strong>（weithts regularization）比较常见的是正则，和正则，在各个深度框架中都有相应的API可以使用正则化，比如在中，若搭建网络的时候已经设置了正则化参数，则调用以下代码可以直接计算出正则损失：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">regularization_loss = tf.add_n(tf<span class="selector-class">.losses</span><span class="selector-class">.get_regularization_losses</span>(scope=<span class="string">'my_resnet_50'</span>))</span><br></pre></td></tr></table></figure>
<p>如果没有设置初始化参数，也可以使用以下代码计算正则损失：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">l2_loss = tf.add_n([tf<span class="selector-class">.nn</span><span class="selector-class">.l2_loss</span>(var) <span class="keyword">for</span> <span class="selector-tag">var</span> <span class="keyword">in</span> tf.trainable_variables() <span class="keyword">if</span> <span class="string">'weights'</span> <span class="keyword">in</span> <span class="selector-tag">var</span>.name])</span><br></pre></td></tr></table></figure>
<p>正则化是通过对网络权重做正则限制过拟合，仔细看正则项在损失函数的形式： </p>
<p>其中，是指正则项系数，因此，如果发生梯度爆炸，权值的范数就会变的非常大，通过正则化项，可以部分限制梯度爆炸的发生。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注：事实上，在深度神经网络中，往往是梯度消失出现的更多一些。</span><br></pre></td></tr></table></figure>
<h3 id="2-3-方案3-relu、leakrelu、elu等激活函数"><a href="#2-3-方案3-relu、leakrelu、elu等激活函数" class="headerlink" title="2.3 方案3-relu、leakrelu、elu等激活函数"></a>2.3 方案3-relu、leakrelu、elu等激活函数</h3><p><strong>Relu:</strong>思想也很简单，如果激活函数的导数为1，那么就不存在梯度消失爆炸的问题了，每层的网络都可以得到相同的更新速度，relu就这样应运而生。先看一下relu的数学表达式：</p>
<p><img src="https://img-blog.csdn.net/20171220115642365?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>其函数图像：</p>
<p><img src="https://img-blog.csdn.net/20171220115719332?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>从上图中，我们可以很容易看出，relu函数的导数在正数部分是恒等于1的，因此在深层网络中使用relu激活函数就不会导致梯度消失和爆炸的问题。</p>
<p><strong>relu</strong>的主要贡献在于：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 解决了梯度消失、爆炸的问题</span></span><br><span class="line"><span class="comment">-- 计算方便，计算速度快</span></span><br><span class="line"><span class="comment">-- 加速了网络的训练</span></span><br></pre></td></tr></table></figure>
<p>同时也存在一些<strong>缺点</strong>：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 由于负数部分恒为0，会导致一些神经元无法激活（可通过设置小学习率部分解决）</span></span><br><span class="line"> <span class="comment">-- 输出不是以0为中心的</span></span><br></pre></td></tr></table></figure>
<p>尽管relu也有缺点，但是仍然是目前使用最多的激活函数</p>
<p><strong>leakrelu</strong><br>leakrelu就是为了解决relu的0区间带来的影响，其数学表达为：其中k是leak系数，一般选择0.01或者0.02，或者通过学习而来</p>
<p><img src="https://img-blog.csdn.net/20170702211001517?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FpY2FpYXRuYnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>leakrelu解决了0区间带来的影响，而且包含了relu的所有优点<br><strong>elu</strong><br>elu激活函数也是为了解决relu的0区间带来的影响，其数学表达为：<img src="https://img-blog.csdn.net/20171220134603079?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>其函数及其导数数学形式为：</p>
<p><img src="https://img-blog.csdn.net/20171220134614121?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>但是elu相对于leakrelu来说，计算要更耗时间一些</p>
<h3 id="2-4-解决方案4-batchnorm"><a href="#2-4-解决方案4-batchnorm" class="headerlink" title="2.4 解决方案4-batchnorm"></a>2.4 解决方案4-batchnorm</h3><p><strong>Batchnorm</strong>是深度学习发展以来提出的最重要的成果之一了，目前已经被广泛的应用到了各大网络中，具有加速网络收敛速度，提升训练稳定性的效果，Batchnorm本质上是解决反向传播过程中的梯度问题。batchnorm全名是batch normalization，简称BN，即批规范化，通过规范化操作将输出信号x规范化到均值为0，方差为1保证网络的稳定性。<br>具体的batchnorm原理非常复杂，在这里不做详细展开，此部分大概讲一下batchnorm解决梯度的问题上。具体来说就是反向传播中，经过每一层的梯度会乘以该层的权重，举个简单例子：<br>正向传播中，那么反向传播中，，反向传播式子中有的存在，所以的大小影响了梯度的消失和爆炸，batchnorm就是通过对每一层的输出规范为均值和方差一致的方法，消除了带来的放大缩小的影响，进而解决梯度消失和爆炸的问题。<br>有关batch norm详细的内容可以参考我的另一篇博客：<br><a href="http://blog.csdn.net/qq_25737169/article/details/79048516" target="_blank" rel="noopener">http://blog.csdn.net/qq_25737169/article/details/79048516</a></p>
<h3 id="2-5-解决方案5-残差结构"><a href="#2-5-解决方案5-残差结构" class="headerlink" title="2.5 解决方案5-残差结构"></a>2.5 解决方案5-残差结构</h3><p><strong>残差结构</strong>说起残差的话，不得不提这篇论文了：Deep Residual Learning for Image Recognition，关于这篇论文的解读，可以参考知乎链接：<a href="https://zhuanlan.zhihu.com/p/31852747" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31852747</a>这里只简单介绍残差如何解决梯度的问题。<br>事实上，就是残差网络的出现导致了image net比赛的终结，自从残差提出后，几乎所有的深度网络都离不开残差的身影，相比较之前的几层，几十层的深度网络，在残差网络面前都不值一提，残差可以很轻松的构建几百层，一千多层的网络而不用担心梯度消失过快的问题，原因就在于残差的捷径（shortcut）部分，其中残差单元如下图所示：<br><img src="https://img-blog.csdn.net/20171220144105760?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>相比较于以前网络的直来直去结构，残差中有很多这样的跨层连接结构，这样的结构在反向传播中具有很大的好处，见下式：<br><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial%20loss%7D%7B%5Cpartial%20%7B%7Bx%7D_%7Bl%7D%7D%7D=%5Cfrac%7B%5Cpartial%20loss%7D%7B%5Cpartial%20%7B%7Bx%7D_%7BL%7D%7D%7D%5Ccdot%20%5Cfrac%7B%5Cpartial%20%7B%7Bx%7D_%7BL%7D%7D%7D%7B%5Cpartial%20%7B%7Bx%7D_%7Bl%7D%7D%7D=%5Cfrac%7B%5Cpartial%20loss%7D%7B%5Cpartial%20%7B%7Bx%7D_%7BL%7D%7D%7D%5Ccdot%20%5Cleft%28%201%2B%5Cfrac%7B%5Cpartial%20%7D%7B%5Cpartial%20%7B%7Bx%7D_%7BL%7D%7D%7D%5Csum%5Climits_%7Bi=l%7D%5E%7BL-1%7D%7BF%28%7B%7Bx%7D_%7Bi%7D%7D,%7B%7BW%7D_%7Bi%7D%7D%29%7D%20%5Cright%29" alt="这里写图片描述"><br>式子的第一个因子  表示的损失函数到达 L 的梯度，小括号中的1表明短路机制可以无损地传播梯度，而另外一项残差梯度则需要经过带有weights的层，梯度不是直接传递过来的。残差梯度不会那么巧全为-1，而且就算其比较小，有1的存在也不会导致梯度消失。所以残差学习会更容易。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注：上面的推导并不是严格的证明。</span><br></pre></td></tr></table></figure>
<h3 id="2-6-解决方案6-LSTM"><a href="#2-6-解决方案6-LSTM" class="headerlink" title="2.6 解决方案6-LSTM"></a>2.6 解决方案6-LSTM</h3><p><strong>LSTM</strong>全称是长短期记忆网络（long-short term memory networks），是不那么容易发生梯度消失的，主要原因在于LSTM内部复杂的“门”(gates)，如下图，LSTM通过它内部的“门”可以接下来更新的时候“记住”前几次训练的”残留记忆“，因此，经常用于生成文本中。目前也有基于CNN的LSTM，感兴趣的可以尝试一下。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/42741-b9a16a53d58ca2b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="这里写图片描述"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h2><p>1.《Neural networks and deep learning》<br>2.<a href="https://www.baidu.com/s?wd=%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">《机器学习》</a>周志华 </p>
<ol>
<li><p><a href="https://www.cnblogs.com/willnote/p/6912798.html&gt;" target="_blank" rel="noopener">https://www.cnblogs.com/willnote/p/6912798.html&gt;</a> </p>
</li>
<li><p><a href="https://www.zhihu.com/question/38102762" target="_blank" rel="noopener">https://www.zhihu.com/question/38102762</a> </p>
<ol>
<li><a href="http://www.jianshu.com/p/9dc9f41f0b29" target="_blank" rel="noopener">http://www.jianshu.com/p/9dc9f41f0b29</a></li>
</ol>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>模型剪枝 Model Pruning</title>
    <url>/2019/04/09/%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D-Model-Pruning/</url>
    <content><![CDATA[<p>参考：<a href="https://xmfbit.github.io/2018/10/03/paper-summary-model-pruning/" target="_blank" rel="noopener">https://xmfbit.github.io/2018/10/03/paper-summary-model-pruning/</a><br>L1正则化项，加入损失函数中，可以对特征进行选择。<br>L1也可以应用到模型压缩任务中，选择某个filter是否有存在的必要，从而决定是否要剪掉。</p>
]]></content>
      <categories>
        <category>杂类</category>
      </categories>
      <tags>
        <tag>杂类</tag>
      </tags>
  </entry>
  <entry>
    <title>深度层次化图卷积神经网络</title>
    <url>/2019/07/25/%E6%B7%B1%E5%BA%A6%E5%B1%82%E6%AC%A1%E5%8C%96%E5%9B%BE%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h3 id="池化-可以扩大感受野"><a href="#池化-可以扩大感受野" class="headerlink" title="池化 可以扩大感受野"></a>池化 可以扩大感受野</h3><h3 id="GCN（两层）-node-classification"><a href="#GCN（两层）-node-classification" class="headerlink" title="GCN（两层）( node classification )"></a>GCN（两层）( node classification )</h3><ul>
<li>基于邻域聚合的</li>
<li><code>H= AXW</code><h3 id="deeper-insight-into-graph-convolutional-networks-for-semi-supervised-learning"><a href="#deeper-insight-into-graph-convolutional-networks-for-semi-supervised-learning" class="headerlink" title="deeper insight into graph convolutional networks for semi-supervised learning"></a>deeper insight into graph convolutional networks for semi-supervised learning</h3></li>
<li>GCN层数多效果不好：特征之间过于平滑<h3 id="GAT-（两层）-GraphSAGE"><a href="#GAT-（两层）-GraphSAGE" class="headerlink" title="GAT （两层）  GraphSAGE"></a>GAT （两层）  GraphSAGE</h3></li>
<li>两层，感受野小，2-hop</li>
</ul>
<h3 id="Hierarchical-Graph-Representation-Learning-with-Differentiable-Pooling-（graph-classification）"><a href="#Hierarchical-Graph-Representation-Learning-with-Differentiable-Pooling-（graph-classification）" class="headerlink" title="Hierarchical Graph Representation Learning with Differentiable Pooling （graph classification）"></a>Hierarchical Graph Representation Learning with Differentiable Pooling （graph classification）</h3><ol>
<li>优点</li>
</ol>
<ul>
<li>简单的两层GCN 的感受野只有2-hop</li>
<li>但是如果GCN- clusterpooling，把相同的节点聚类在一起，再进行GCN，那么感受野就会扩大，</li>
<li>捕捉到了graph 中的Hierarchical  structure</li>
</ul>
<ol>
<li>缺点</li>
</ol>
<ul>
<li>但是由于他自身网络设计的，一次池化，就需要一个全连接层，使得想要设计一个很深的网络，就需要很多的参数，容易过拟合</li>
<li>很难去训练pooling matrix，这是由于不能保证，经过这一个池化层，就可以把相似的objects聚类到一起。本文作者在每层都增加了两个正则项</li>
</ul>
<h3 id="Hierarchical-Graph-Convolutional-Networks-for-Semi-supervised-Node-Classification-9层-IJCAI-2019"><a href="#Hierarchical-Graph-Convolutional-Networks-for-Semi-supervised-Node-Classification-9层-IJCAI-2019" class="headerlink" title="Hierarchical Graph Convolutional Networks for Semi-supervised Node Classification ( 9层 ) ( IJCAI 2019)"></a>Hierarchical Graph Convolutional Networks for Semi-supervised Node Classification ( 9层 ) ( IJCAI 2019)</h3><ul>
<li>粗化 coarsening</li>
<li>结构一致粗化</li>
<li>结构相似粗化</li>
</ul>
]]></content>
      <categories>
        <category>图卷积网络</category>
      </categories>
      <tags>
        <tag>图卷积网络</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Batch Normalization批标准化</title>
    <url>/2019/08/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Batch-Normalization%E6%89%B9%E6%A0%87%E5%87%86%E5%8C%96/</url>
    <content><![CDATA[<ul>
<li>转载 from：<a href="https://www.cnblogs.com/guoyaohua/p/8724433.html" target="_blank" rel="noopener">https://www.cnblogs.com/guoyaohua/p/8724433.html</a></li>
</ul>
<blockquote>
<p>这几天面试经常被问到BN层的原理，虽然回答上来了，但还是感觉答得不是很好，今天仔细研究了一下Batch Normalization的原理，以下为参考网上几篇文章总结得出。</p>
</blockquote>
<p>　　Batch Normalization作为最近一年来DL的重要成果，已经广泛被证明其有效性和重要性。虽然有些细节处理还解释不清其理论原因，但是实践证明好用才是真的好，别忘了DL从Hinton对深层网络做Pre-Train开始就是一个<strong>经验领先于理论分析</strong>的偏经验的一门学问。本文是对论文《Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift》的导读。</p>
<p>　　机器学习领域有个很重要的假设：<strong>IID独立同分布假设</strong>，就是假设训练数据和测试数据是满足相同分布的，这是通过训练数据获得的模型能够在测试集获得好的效果的一个基本保障。那BatchNorm的作用是什么呢？<strong>BatchNorm就是在深度神经网络训练过程中使得每一层神经网络的输入保持相同分布的。</strong></p>
<p>　　接下来一步一步的理解什么是BN。</p>
<p>　　为什么深度神经网络<strong>随着网络深度加深，训练起来越困难，收敛越来越慢？</strong>这是个在DL领域很接近本质的好问题。很多论文都是解决这个问题的，比如ReLU激活函数，再比如Residual Network，BN本质上也是解释并从某个不同的角度来解决这个问题的。</p>
<h2 id="一、“Internal-Covariate-Shift”问题"><a href="#一、“Internal-Covariate-Shift”问题" class="headerlink" title="一、“Internal Covariate Shift”问题"></a>一、“Internal Covariate Shift”问题</h2><p>　　从论文名字可以看出，BN是用来解决“Internal Covariate Shift”问题的，那么首先得理解什么是“Internal Covariate Shift”？</p>
<p>　　论文首先说明Mini-Batch SGD相对于One Example SGD的两个优势：梯度更新方向更准确；并行计算速度快；（为什么要说这些？因为BatchNorm是基于Mini-Batch SGD的，所以先夸下Mini-Batch SGD，当然也是大实话）；然后吐槽下SGD训练的缺点：超参数调起来很麻烦。（作者隐含意思是用BN就能解决很多SGD的缺点）</p>
<p>　　接着引入<strong>covariate shift的概念</strong>：<strong>如果ML系统实例集合<x,y>中的输入值X的分布老是变，这不符合IID假设</x,y></strong>，网络模型很难<strong>稳定的学规律</strong>，这不得引入迁移学习才能搞定吗，我们的ML系统还得去学习怎么迎合这种分布变化啊。对于深度学习这种包含很多隐层的网络结构，在训练过程中，因为各层参数不停在变化，所以每个隐层都会面临covariate shift的问题，也就是<strong>在训练过程中，隐层的输入分布老是变来变去，这就是所谓的“Internal Covariate Shift”，Internal指的是深层网络的隐层，是发生在网络内部的事情，而不是covariate shift问题只发生在输入层。</strong></p>
<p>　　然后提出了BatchNorm的基本思想：能不能<strong>让每个隐层节点的激活输入分布固定下来呢</strong>？这样就避免了“Internal Covariate Shift”问题了。</p>
<p>　　BN不是凭空拍脑袋拍出来的好点子，它是有启发来源的：之前的研究表明如果在图像处理中对输入图像进行白化（Whiten）操作的话——所谓<strong>白化</strong>，<strong>就是对输入数据分布变换到0均值，单位方差的正态分布</strong>——那么神经网络会较快收敛，那么BN作者就开始推论了：图像是深度神经网络的输入层，做白化能加快收敛，那么其实对于深度网络来说，其中某个隐层的神经元是下一层的输入，意思是其实深度神经网络的每一个隐层都是输入层，不过是相对下一层来说而已，那么能不能对每个隐层都做白化呢？这就是启发BN产生的原初想法，而BN也确实就是这么做的，<strong>可以理解为对深层神经网络每个隐层神经元的激活值做简化版本的白化操作。</strong></p>
<h2 id="二、BatchNorm的本质思想"><a href="#二、BatchNorm的本质思想" class="headerlink" title="二、BatchNorm的本质思想"></a><strong>二、</strong>BatchNorm的本质思想</h2><p>　　BN的基本思想其实相当直观：因为深层神经网络在做非线性变换前的<strong>激活输入值</strong>（就是那个x=WU+B，U是输入）<strong>随着网络深度加深或者在训练过程中，其分布逐渐发生偏移或者变动，之所以训练收敛慢，一般是整体分布逐渐往非线性函数的取值区间的上下限两端靠近</strong>（对于Sigmoid函数来说，意味着激活输入值WU+B是大的负值或正值），所以这<strong>导致反向传播时低层神经网络的梯度消失</strong>，这是训练深层神经网络收敛越来越慢的<strong>本质原因</strong>，<strong>而BN就是通过一定的规范化手段，把每层神经网络任意神经元这个输入值的分布强行拉回到均值为0方差为1的标准正态分布</strong>，其实就是把越来越偏的分布强制拉回比较标准的分布，这样使得激活输入值落在非线性函数对输入比较敏感的区域，这样输入的小变化就会导致损失函数较大的变化，意思是<strong>这样让梯度变大，避免梯度消失问题产生，而且梯度变大意味着学习收敛速度快，能大大加快训练速度。</strong></p>
<p>　　THAT’S IT。其实一句话就是：<strong>对于每个隐层神经元，把逐渐向非线性函数映射后向取值区间极限饱和区靠拢的输入分布强制拉回到均值为0方差为1的比较标准的正态分布，使得非线性变换函数的输入值落入对输入比较敏感的区域，以此避免梯度消失问题。</strong>因为梯度一直都能保持比较大的状态，所以很明显对神经网络的参数调整效率比较高，就是变动大，就是说向损失函数最优值迈动的步子大，也就是说收敛地快。BN说到底就是这么个机制，方法很简单，道理很深刻。</p>
<p>　　上面说得还是显得抽象，下面更形象地表达下这种调整到底代表什么含义。</p>
<p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180405225246905-37854887.png" alt="img"></p>
<p>  图1  几个正态分布</p>
<p>　　假设某个隐层神经元原先的激活输入x取值符合正态分布，正态分布均值是-2，方差是0.5，对应上图中最左端的浅蓝色曲线，通过BN后转换为均值为0，方差是1的正态分布（对应上图中的深蓝色图形），意味着什么，意味着输入x的取值正态分布整体右移2（均值的变化），图形曲线更平缓了（方差增大的变化）。这个图的意思是，BN其实就是把每个隐层神经元的激活输入分布从偏离均值为0方差为1的正态分布通过平移均值压缩或者扩大曲线尖锐程度，调整为均值为0方差为1的正态分布。</p>
<p>　　那么把激活输入x调整到这个正态分布有什么用？首先我们看下均值为0，方差为1的标准正态分布代表什么含义：</p>
<p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180405225314624-527885612.png" alt="img"></p>
<p>图2  均值为0方差为1的标准正态分布图</p>
<p>　　这意味着在一个标准差范围内，也就是说64%的概率x其值落在[-1,1]的范围内，在两个标准差范围内，也就是说95%的概率x其值落在了[-2,2]的范围内。那么这又意味着什么？我们知道，激活值x=WU+B,U是真正的输入，x是某个神经元的激活值，假设非线性函数是sigmoid，那么看下sigmoid(x)其图形：</p>
<p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180407143109455-1460017374.png" alt="img"></p>
<p>图3. Sigmoid(x)</p>
<p>及sigmoid(x)的导数为：G’=f(x)*(1-f(x))，因为f(x)=sigmoid(x)在0到1之间，所以G’在0到0.25之间，其对应的图如下：</p>
<p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180407142351924-124461667.png" alt="img"></p>
<p>图4  Sigmoid(x)导数图</p>
<p>　　假设没有经过BN调整前x的原先正态分布均值是-6，方差是1，那么意味着95%的值落在了[-8,-4]之间，那么对应的Sigmoid（x）函数的值明显接近于0，这是典型的梯度饱和区，在这个区域里梯度变化很慢，为什么是梯度饱和区？请看下sigmoid(x)如果取值接近0或者接近于1的时候对应导数函数取值，接近于0，意味着梯度变化很小甚至消失。而假设经过BN后，均值是0，方差是1，那么意味着95%的x值落在了[-2,2]区间内，很明显这一段是sigmoid(x)函数接近于线性变换的区域，意味着x的小变化会导致非线性函数值较大的变化，也即是梯度变化较大，对应导数函数图中明显大于0的区域，就是梯度非饱和区。</p>
<p>　　从上面几个图应该看出来BN在干什么了吧？其实就是把隐层神经元激活输入x=WU+B从变化不拘一格的正态分布通过BN操作拉回到了均值为0，方差为1的正态分布，即原始正态分布中心左移或者右移到以0为均值，拉伸或者缩减形态形成以1为方差的图形。什么意思？就是说<strong>经过BN后，目前大部分Activation的值落入非线性函数的线性区内，其对应的导数远离导数饱和区，这样来加速训练收敛过程。</strong></p>
<p>　　但是很明显，看到这里，稍微了解神经网络的读者一般会提出一个疑问：如果都通过BN，那么不就跟把非线性函数替换成线性函数效果相同了？这意味着什么？我们知道，如果是多层的线性函数变换其实这个深层是没有意义的，因为多层线性网络跟一层线性网络是等价的。这意味着网络的<strong>表达能力</strong>下降了，这也意味着深度的意义就没有了。<strong>所以BN为了保证非线性的获得，对变换后的满足均值为0方差为1的x又进行了scale加上shift操作(y=scale*x+shift)</strong>，每个神经元增加了两个参数scale和shift参数，这两个参数是通过训练学习到的，意思是通过scale和shift把这个值从标准正态分布左移或者右移一点并长胖一点或者变瘦一点，每个实例挪动的程度不一样，这样等价于非线性函数的值从正中心周围的线性区往非线性区动了动。核心思想应该是想找到一个线性和非线性的较好平衡点，既能享受非线性的较强表达能力的好处，又避免太靠非线性区两头使得网络收敛速度太慢。当然，这是我的理解，论文作者并未明确这样说。但是很明显这里的scale和shift操作是会有争议的，因为按照论文作者论文里写的理想状态，就会又通过scale和shift操作把变换后的x调整回未变换的状态，那不是饶了一圈又绕回去原始的“Internal Covariate Shift”问题里去了吗，感觉论文作者并未能够清楚地解释scale和shift操作的理论原因。</p>
<h2 id="三、训练阶段如何做BatchNorm"><a href="#三、训练阶段如何做BatchNorm" class="headerlink" title="三、训练阶段如何做BatchNorm"></a>三、训练阶段如何做BatchNorm</h2><p>　　上面是对BN的抽象分析和解释，具体在Mini-Batch SGD下做BN怎么做？其实论文里面这块写得很清楚也容易理解。为了保证这篇文章完整性，这里简单说明下。</p>
<p>　　假设对于一个深层神经网络来说，其中两层结构如下：</p>
<p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180405213859690-1933561230.png" alt="img"></p>
<p>  图5  DNN其中两层</p>
<p>　　要对每个隐层神经元的激活值做BN，可以想象成每个隐层又加上了一层BN操作层，它位于X=WU+B激活值获得之后，非线性函数变换之前，其图示如下：</p>
<p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180405213955224-1791925244.png" alt="img"></p>
<p>  图6. BN操作</p>
<p>　　对于Mini-Batch SGD来说，一次训练过程里面包含m个训练实例，其具体BN操作就是对于隐层内每个神经元的激活值来说，进行如下变换：</p>
<p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180407142802238-1209499294.png" alt="img"></p>
<p>　　要注意，这里t层某个神经元的x(k)不是指原始输入，就是说不是t-1层每个神经元的输出，而是t层这个神经元的线性激活x=WU+B，这里的U才是t-1层神经元的输出。变换的意思是：某个神经元对应的原始的激活x通过减去mini-Batch内m个实例获得的m个激活x求得的均值E(x)并除以求得的方差Var(x)来进行转换。</p>
<p>　　上文说过经过这个<strong>变换后某个神经元的激活x形成了均值为0，方差为1的正态分布，目的是把值往后续要进行的非线性变换的线性区拉动，增大导数值，增强反向传播信息流动性，加快训练收敛速度。**</strong>但是这样会导致网络表达能力下降，为了防止这一点，每个神经元增加两个调节参数（scale和shift），这两个参数是通过训练来学习到的，用来对变换后的激活反变换，使得网络表达能力增强，即对变换后的激活进行如下的scale和shift操作，这其实是变换的反操作：**</p>
<p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180407142923190-79595046.png" alt="img"></p>
<p>　　BN其具体操作流程，如论文中描述的一样：</p>
<p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180407142956288-903484055.png" alt="img"></p>
<p>　　过程非常清楚，就是上述公式的流程化描述，这里不解释了，直接应该能看懂。</p>
<h2 id="四、BatchNorm的推理-Inference-过程"><a href="#四、BatchNorm的推理-Inference-过程" class="headerlink" title="四、BatchNorm的推理(Inference)过程"></a>四、BatchNorm的推理(Inference)过程</h2><p>　　BN在训练的时候可以根据Mini-Batch里的若干训练实例进行激活数值调整，但是在推理（inference）的过程中，很明显输入就只有一个实例，看不到Mini-Batch其它实例，那么这时候怎么对输入做BN呢？因为很明显一个实例是没法算实例集合求出的均值和方差的。这可如何是好？</p>
<p>　　既然没有从Mini-Batch数据里可以得到的统计量，那就想其它办法来获得这个统计量，就是均值和方差。可以用从所有训练实例中获得的统计量来代替Mini-Batch里面m个训练实例获得的均值和方差统计量，因为本来就打算用全局的统计量，只是因为计算量等太大所以才会用Mini-Batch这种简化方式的，那么在推理的时候直接用全局统计量即可。</p>
<p>　　决定了获得统计量的数据范围，那么接下来的问题是如何获得均值和方差的问题。很简单，因为每次做Mini-Batch训练时，都会有那个Mini-Batch里m个训练实例获得的均值和方差，现在要全局统计量，只要把每个Mini-Batch的均值和方差统计量记住，然后对这些均值和方差求其对应的数学期望即可得出全局统计量，即：</p>
<p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180407143405654-1995556833.png" alt="img"></p>
<p>　　有了均值和方差，每个隐层神经元也已经有对应训练好的Scaling参数和Shift参数，就可以在推导的时候对每个神经元的激活数据计算NB进行变换了，在推理过程中进行BN采取如下方式：</p>
<p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180407143658338-63450857.png" alt="img"></p>
<p>　　这个公式其实和训练时</p>
<p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180407143807788-1841864822.png" alt="img"></p>
<p>　　是等价的，通过简单的合并计算推导就可以得出这个结论。那么为啥要写成这个变换形式呢？我猜作者这么写的意思是：在实际运行的时候，按照这种变体形式可以减少计算量，为啥呢？因为对于每个隐层节点来说：</p>
<p>　　　　　　　　<img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180407144519480-1024698421.png" alt="img">　　<img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180407144549010-487189588.png" alt="img"></p>
<p>　　都是固定值，这样这两个值可以事先算好存起来，在推理的时候直接用就行了，这样比原始的公式每一步骤都现算少了除法的运算过程，乍一看也没少多少计算量，但是如果隐层节点个数多的话节省的计算量就比较多了。</p>
<h2 id="五、BatchNorm的好处"><a href="#五、BatchNorm的好处" class="headerlink" title="五、BatchNorm的好处"></a>五、BatchNorm的好处</h2><p>　　BatchNorm为什么NB呢，关键还是效果好。<strong>①**</strong>不仅仅极大提升了训练速度，收敛过程大大加快；②还能增加分类效果，一种解释是这是类似于Dropout的一种防止过拟合的正则化表达方式，所以不用Dropout也能达到相当的效果；③另外调参过程也简单多了，对于初始化要求没那么高，而且可以使用大的学习率等。**总而言之，经过这么简单的变换，带来的好处多得很，这也是为何现在BN这么快流行起来的原因。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>池化层的反向传播</title>
    <url>/2019/04/21/%E6%B1%A0%E5%8C%96%E5%B1%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/</url>
    <content><![CDATA[<ul>
<li>参考： <a href="https://blog.csdn.net/qq_21190081/article/details/72871704" target="_blank" rel="noopener">https://blog.csdn.net/qq_21190081/article/details/72871704</a></li>
<li>总结，<br>（1）对于平均池化层，比如2×2-&gt;1， 梯度的反向传递，是1-&gt;2×2，若梯度为x, 则，反向传播的梯度为4个 1/4<br>（1）对于最大池化层，比如2×2-&gt;1， 梯度的反向传递，是1-&gt;2×2，若梯度为x, 则，反向传播只赋值给最大值所在的元素，其余三个元素的梯度为0</li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习知识点</title>
    <url>/2019/03/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<ul>
<li><p>讲一下正则化，L1和L2正则化各自的特点和适用场景。<br>答：L1用来获得稀疏化特征；L2用来防止过拟合。L1让一部分特征的系数缩小到0，从而间接实现特征选择，用于特征间有关联的场合；L2让所有的特征系数都减小，但不会减为0，会使优化求解稳定快速。</p>
</li>
<li><p>防止过拟合的方法：<br>（1）早停，使用验证集，当验证集的损失下降，但是训练集的损失仍在上升时，则停止训练<br>（2）加入正则化项，L1、L2</p>
</li>
<li><p>分类问题有哪些评价指标？每种的适用场景<br>Precision  精确率，在所有预测为正样本的样本(TP+FP)中预测正确(TP)的比例，也就是：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1asfgshjuj307c01d3yb.jpg"><br>适用于：检索出的信息有多少是用户感兴趣的<br>Recall  召回率，在所有正样本(TP+FN)中，预测正确(TP)的比例，也就是：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1asfv7ikpj306d019t8i.jpg"><br>适用于：用户感兴趣的信息有多少被检索出来了<br>Accuracy  准确率，正确分类的样本占所有样本的比例，不适于数据极度不平衡的场景如广告点击率一般在千分之几。<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1asg2ggqgj30ab01eglg.jpg"><br>适用于多分类问题<br>F1-measure  F1分数，是综合考虑Precision和Recall得到的一个指标，一般在需要PR都要保证的场景使用，针对一个值的优化更加直观容易衡量<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1asgb0qo9j304701dwe9.jpg"></p>
</li>
<li><p>逻辑回归可以处理非线性问题吗<br>只用原始特征不能；对特征做非线性变换，比如kernel，当然可以。 但那就不是lr了 或者一个神经网络 最后一层看成是lr 前面看成是提特征<br>lr的应用场景主要是特征很多的情况下 比如特征是上亿维的一些场景</p>
</li>
<li><p>讲一下pooling的作用， 为什么max pooling要更常用？哪些情况下，average pooling比max pooling更合适？<br>（1）保证特征的位置与旋转不变性。对于图像处理这种特性是很好的，但是对于NLP来说特征出现的位置是很重要的。比如主语一般出现在句子头等等<br>maxpooling提供了一定position的invariance，当图像某些区域像素变化时，maxpooling得到的output并不会变<br>（2）减少模型参数数量，减少过拟合问题。2D或1D的数组转化为单一数值，对于后续的convolution层或者全连接隐层来说，减少了单个Filter参数或隐层神经元个数<br>（3）可以把变长的输入x整理成固定长度的输入。CNN往往最后连接全连接层，神经元个数需要固定好，但是cnn输入x长度不确定，通过pooling操作，每个filter固定取一个值。有多少个Filter，Pooling就有多少个神经元，这样就可以把全连接层神经元固定住<br>（4）yaya: pooling 一般是对缩小image size，从而可以减小后续步骤中的参数量<br>max-pooling还提供了非线性, 这是max-pooling效果更好的一个重要原因.<br><strong>average pooling比max pooling更合适：</strong>有的时候在模型接近分类器的末端使用全局平均池化还可以代替Flatten操作，使输入数据变成一位向量。</p>
</li>
<li><p>1x1的卷积核有什么作用？<br>1*1的卷积核在NIN、Googlenet中被广泛使用，作用：<br>（1）实现跨通道的交互和信息整合<br>（2）进行卷积核通道数的降维和升维<br>（3）对于单通道feature map 用单核卷积即为乘以一个参数，而一般情况都是多核卷积多通道，实现多个feature map的线性组合</p>
</li>
<li><p>梯度消失和梯度爆炸的原因是什么？ 有哪些解决方法？<br>转载：<a href="https://blog.csdn.net/raojunyang/article/details/79962665（解释的很清楚）" target="_blank" rel="noopener">https://blog.csdn.net/raojunyang/article/details/79962665（解释的很清楚）</a><br>梯度消失更容易发生，当网络较深或者使用了不合适的激活函数时，会发生梯度消失；当为深层网络且权值初始化值太大时，容易发生梯度爆炸<br>yaya: 由于深层网络，在底层的网络权重的更新，需要高层网络权重的连乘，因此，当高层网络权重较小时，使得发生梯度消失，相反，当权重较大时，则发生梯度爆炸。<br>那么什么时候高层网络权重小—-当使用sigmoid/tanh这样的激活函数时，因为sigmoid的导数最大为1/2；什么时候高层网络权重大—当初始化的权重较大时<br>如何解决梯度消失与爆炸：（1）使用正确的非线性激活函数（2）对于梯度爆炸问题使用梯度剪切（3）使用batch normalization（4）使用残差结构</p>
</li>
<li>CNN和RNN的梯度消失是一样的吗？  </li>
<li>有哪些防止过拟合的方法？<br>早停；添加正则化项：L1、L2；使用dropout</li>
<li>讲一下激活函数sigmoid，tanh，relu. Leaky ReLU各自的优点和适用场景？<br>sigmoid，tanh 有梯度消失的问题<br>relu 部分解决梯度消失问题（x&gt;0）<br>leaky relu </li>
<li>relu的负半轴导数都是0，这部分产生的梯度消失怎么办？  </li>
<li>batch size对收敛速度的影响。  </li>
<li>讲一下batch normalization<br>对输入的数据进行mini batch 的归一化</li>
<li>讲一下你怎么理解dropout，分别从bagging和正则化的角度<br><a href="https://blog.csdn.net/m0_37477175/article/details/77145459" target="_blank" rel="noopener">https://blog.csdn.net/m0_37477175/article/details/77145459</a><br>bagging 都是使用集成学习的思想，但是</li>
<li>data augmentation有哪些技巧？  </li>
<li>讲一下你了解的优化方法，sgd, momentum, rmsprop, adam的区别和联系  </li>
<li>如果训练的神经网络不收敛，可能有哪些原因？<br>可以参见此博文，具体来说，可以简述为以下几点：<br>（1）<strong>没有对数据进行归一化</strong>，即对数据减均值，并除以方差。而大部分神经网络的输入输出都是在0附近的分布。因此无法收敛。<br>（2）<strong>学习率不正确</strong><br>（3）<strong>在输出层使用错误的激活函数</strong>：在最后一层使用激活函数时，无法产生所需全部范围的值。假使你使用Relu这类限制范围的函数，神经网络便只会训练得到正值<br>（4）<strong>没有正确初始化权重</strong></li>
</ul>
<p>（1）代码题（leetcode类型），主要考察数据结构和基础算法，以及代码基本功<br>虽然这部分跟机器学习，深度学习关系不大，但也是面试的重中之重。基本每家公司的面试都问了大量的算法题和代码题，即使是商汤、face++这样的深度学习公司，考察这部分的时间也占到了我很多轮面试的60%甚至70%以上。我去face++面试的时候，面试官是residual net，shuffle net的作者；但他们的面试中，写代码题依旧是主要的部分。<br>大部分题目都不难，基本是leetcode medium的难度。但是要求在现场白板编程，思路要流畅，能做到一次性Bug-free. 并且，一般都是要给出时间复杂度和空间复杂度最优的做法。对于少数难度很大的题，也不要慌张。一般也不会一点思路也没有，尽力给面试官展现自己的思考过程。面试官也会引导你，给一点小提示，沿着提示把题目慢慢做出来也是可以通过面试的。<br>以下是我所遇到的一些需要当场写出完整代码的题目：  </p>
<p><1> 二分查找。分别实现C++中的lower_bound和upper_bound.  </1></p>
<p><2> 排序。 手写快速排序，归并排序，堆排序都被问到过。  </2></p>
<p><3> 给你一个数组，求这个数组的最大子段积<br>时间复杂度可以到O(n)  </3></p>
<p><4> 给你一个数组，在这个数组中找出不重合的两段，让这两段的字段和的差的绝对值最小。<br>时间复杂度可以到O(n)  </4></p>
<p><5> 给你一个数组，求一个k值，使得前k个数的方差 + 后面n-k个数的方差最小<br>时间复杂度可以到O(n)  </5></p>
<p><6> 给你一个只由0和1组成的字符串，找一个最长的子串，要求这个子串里面0和1的数目相等。<br>时间复杂度可以到O(n)  </6></p>
<p><7> 给你一个数组以及一个数K， 从这个数组里面选择三个数，使得三个数的和小于等于K， 问有多少种选择的方法？<br>时间复杂度可以到O(n^2)  </7></p>
<p><8> 给你一个只由0和1组成的矩阵，找出一个最大的子矩阵，要求这个子矩阵是方阵，并且这个子矩阵的所有元素为1<br>时间复杂度可以到O(n^2)  </8></p>
<p><9> 求一个字符串的最长回文子串<br>时间复杂度可以到O(n) (Manacher算法)  </9></p>
<p><10> 在一个数轴上移动，初始在0点，现在要到给定的某一个x点， 每一步有三种选择，坐标加1，坐标减1，坐标乘以2，请问最少需要多少步从0点到x点。  </10></p>
<p><11> 给你一个集合，输出这个集合的所有子集。  </11></p>
<p><12> 给你一个长度为n的数组，以及一个k值（k &lt; n) 求出这个数组中每k个相邻元素里面的最大值。其实也就是一个一维的max pooling<br>时间复杂度可以到O(n)  </12></p>
<p><13> 写一个程序，在单位球面上随机取点，也就是说保证随机取到的点是均匀的。  </13></p>
<p><14> 给你一个长度为n的字符串s，以及m个短串（每个短串的长度小于10）， 每个字符串都是基因序列，也就是说只含有A,T,C,G这四个字母。在字符串中找出所有可以和任何一个短串模糊匹配的子串。模糊匹配的定义，两个字符串长度相等，并且至多有两个字符不一样，那么我们就可以说这两个字符串是模糊匹配的。  </14></p>
<p><15> 其它一些描述很复杂的题这里就不列了。</15></p>
<p>（2）数学题或者”智力”题。<br>不会涉及特别高深的数学知识，一般就是工科数学（微积分，概率论，线性代数）和一些组合数学的问题。<br>下面是我在面试中被问到过的问题：  </p>
<p><1> 如果一个女生说她集齐了十二个星座的前男友，她前男友数量的期望是多少？<br>ps：这道题在知乎上有广泛的讨论，作为知乎重度用户我也看到过。如果一个女生说，她集齐了十二个星座的前男友，我们应该如何估计她前男友的数量？  </1></p>
<p><2> 两个人玩游戏。有n堆石头，每堆分别有a1, a2, a3…. an个石头，每次一个游戏者可以从任意一堆石头里拿走至少一个石头，也可以整堆拿走，但不能从多堆石头里面拿。无法拿石头的游戏者输，请问这个游戏是否有先手必胜或者后手必胜的策略？ 如果有，请说出这个策略，并证明这个策略能保证必胜。  </2></p>
<p><3> 一个一维数轴，起始点在原点。每次向左或者向右走一步，概率都是0.5. 请问回到原点的步数期望是多少？  </3></p>
<p><4> 一条长度为1的线段，随机剪两刀，求有一根大于0.5的概率。  </4></p>
<p><5> 讲一下你理解的矩阵的秩。低秩矩阵有什么特点？ 在图像处理领域，这些特点有什么应用？  </5></p>
<p><6> 讲一下你理解的特征值和特征向量。  </6></p>
<p><7> 为什么负梯度方向是使函数值下降最快的方向？简单数学推导一下</7></p>
<p>（3）机器学习基础<br>这部分建议参考周志华老师的《机器学习》。<br>下面是我在面试中被问到过的问题：  </p>
<p><1> 逻辑回归和线性回归对比有什么优点？  </1></p>
<p><2> 逻辑回归可以处理非线性问题吗？  </2></p>
<p><3> 分类问题有哪些评价指标？每种的适用场景。  </3></p>
<p><4> 讲一下正则化，L1和L2正则化各自的特点和适用场景。  </4></p>
<p><5> 讲一下常用的损失函数以及各自的适用场景。  </5></p>
<p><6> 讲一下决策树和随机森林  </6></p>
<p><7> 讲一下GBDT的细节，写出GBDT的目标函数。 GBDT和Adaboost的区别与联系  </7></p>
<p><8> 手推softmax loss公式  </8></p>
<p><9> 讲一下SVM, SVM与LR有什么联系。  </9></p>
<p><10>讲一下PCA的步骤。PCA和SVD的区别和联系  </10></p>
<p><11> 讲一下ensemble  </11></p>
<p><12> 偏差和方差的区别。ensemble的方法中哪些是降低偏差，哪些是降低方差？<br>…… 这部分问得太琐碎了，我能记起来的问题就这么多了。我的感觉，这部分问题大多数不是问得很深，所以不至于被问得哑口无言，总有得扯；但是要想给出一个特别深刻的回答，还是需要对机器学习的基础算法了解比较透彻。</12></p>
<p>（4）深度学习基础<br>这部分的准备，我推荐花书（Bengio的Deep learning）和 @魏秀参 学长的《解析卷积神经网络-深度学习实践手册》<br>下面是我在面试中被问到过的问题：  </p>
<p><1> 手推BP  </1></p>
<p><2> 手推RNN和LSTM结构  </2></p>
<p><3> LSTM中每个gate的作用是什么，为什么跟RNN比起来，LSTM可以防止梯度消失  </3></p>
<p><4> 讲一下pooling的作用， 为什么max pooling要更常用？哪些情况下，average pooling比max pooling更合适？  </4></p>
<p><5> 梯度消失和梯度爆炸的原因是什么？ 有哪些解决方法？  </5></p>
<p><6> CNN和RNN的梯度消失是一样的吗？  </6></p>
<p><6> 有哪些防止过拟合的方法？  </6></p>
<p><7> 讲一下激活函数sigmoid，tanh，relu. 各自的优点和适用场景？  </7></p>
<p><8> relu的负半轴导数都是0，这部分产生的梯度消失怎么办？  </8></p>
<p><9> batch size对收敛速度的影响。  </9></p>
<p><10> 讲一下batch normalization  </10></p>
<p><11> CNN做卷积运算的复杂度。如果一个CNN网络的输入channel数目和卷积核数目都减半，总的计算量变为原来的多少？  </11></p>
<p><12> 讲一下AlexNet的具体结构，每层的作用  </12></p>
<p><13> 讲一下你怎么理解dropout，分别从bagging和正则化的角度  </13></p>
<p><14> data augmentation有哪些技巧？  </14></p>
<p><15> 讲一下你了解的优化方法，sgd, momentum, rmsprop, adam的区别和联系  </15></p>
<p><16> 如果训练的神经网络不收敛，可能有哪些原因？  </16></p>
<p><17> 说一下你理解的卷积核， 1x1的卷积核有什么作用？<br>……..<br>同上，这部分的很多问题也是每个人都或多或少能回答一点，但要答得很好还是需要功底的。</17></p>
<p>（5）科研上的开放性问题<br>这部分的问题没有固定答案，也没法很好地针对性准备。功在平时，多读paper多思考，注意培养自己的insight和intuition<br>下面是我在面试中被问到过的问题：  </p>
<p><1> 选一个计算机视觉、深度学习、机器学习的子领域，讲一下这个领域的发展脉络，重点讲出各种新方法提出时的motivation，以及谈谈这个领域以后会怎么发展。  </1></p>
<p><2> 讲一下你最近看的印象比较深的paper  </2></p>
<p><3> 讲一下经典的几种网络结构， AlexNet， VGG，GoogleNet， Residual Net等等，它们各自最重要的contribution  </3></p>
<p><4> 你看过最近很火的XXX paper吗? 你对这个有什么看法？<br>……<br>（6） 编程语言、操作系统等方面的一些问题。<br>C++， Python， 操作系统，Linux命令等等。这部分问得比较少，但还是有的，不具体列了<br>（7）针对简历里项目/论文 / 实习的一些问题。<br>这部分因人而异，我个人的对大家也没参考价值，也不列了。</4></p>
<p>作者：wendy_要努力努力再努力<br>链接：<a href="https://www.jianshu.com/p/d40fc51874c8" target="_blank" rel="noopener">https://www.jianshu.com/p/d40fc51874c8</a><br>来源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>理解对比学习和 SimCSE</title>
    <url>/2021/06/22/%E7%90%86%E8%A7%A3%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0%E5%92%8C-SimCSE/</url>
    <content><![CDATA[<p>来源：<a href="https://mp.weixin.qq.com/s/12UvfXnaB4NTy54wWIFZdQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/12UvfXnaB4NTy54wWIFZdQ</a></p>
<p>2020 年的 Moco 和 SimCLR 等，掀起了对比学习在 CV 领域的热潮，2021 年的 SimCSE，则让 NLP 也乘上了对比学习的东风。下面就尝试用 QA 的形式挖掘其中一些细节知识点，去更好地理解对比学习和 SimCSE。</p>
<ul>
<li><p>如何去理解对比学习，它和度量学习的差别是什么？</p>
</li>
<li><p>对比学习中一般选择一个 batch 中的所有其他样本作为负例，那如果负例中有很相似的样本怎么办？</p>
</li>
<li><p>infoNCE loss 如何去理解，和 CE loss有什么区别？</p>
</li>
<li><p>对比学习的 infoNCE loss 中的温度常数的作用是什么？</p>
</li>
<li><p>SimCSE 中的 dropout mask 指的是什么，dropout rate 的大小影响的是什么？</p>
</li>
<li><p>SimCSE 无监督模式下的具体实现流程是怎样的，标签生成和 loss 计算如何实现？</p>
</li>
</ul>
<h2 id="1-如何去理解对比学习，它和度量学习的差别是什么？"><a href="#1-如何去理解对比学习，它和度量学习的差别是什么？" class="headerlink" title="1. 如何去理解对比学习，它和度量学习的差别是什么？"></a><strong>1. 如何去理解对比学习，它和度量学习的差别是什么？</strong></h2><p>对比学习的思想是去拉近相似的样本，推开不相似的样本，而目标是要从样本中学习到一个好的语义表示空间。</p>
<p>论文 [1] 给出的 “Alignment and Uniformity on the Hypersphere”，就是一个非常好的去理解对比学习的角度。</p>
<p>好的对比学习系统应该具备两个属性：Alignment和Uniformity（参考上图）。</p>
<p>所谓“Alignment”，指的是相似的例子，也就是正例，映射到单位超球面后，应该有接近的特征，也即是说，在超球面上距离比较近；</p>
<p>所谓“Uniformity”，指的是系统应该倾向在特征里保留尽可能多的信息，这等价于使得映射到单位超球面的特征，尽可能均匀地分布在球面上，分布得越均匀，意味着保留的信息越充分。分布均匀意味着两两有差异，也意味着各自保有独有信息，这代表信息保留充分（参考自 [2]）。</p>
<p>度量学习和对比学习的思想是一样的，都是去拉近相似的样本，推开不相似的样本。但是对比学习是无监督或者自监督学习方法，而度量学习一般为有监督学习方法。而且对比学习在 loss 设计时，为单正例多负例的形式，因为是无监督，数据是充足的，也就可以找到无穷的负例，但<font color="red">如何构造有效正例才是重点。</font></p>
<p>而度量学习多为二元组或三元组的形式，如常见的 Triplet 形式（anchor，positive，negative），Hard Negative 的挖掘对最终效果有较大的影响。</p>
<h2 id="2-对比学习中一般选择一个-batch-中的所有其他样本作为负例，那如果负例中有很相似的样本怎么办？"><a href="#2-对比学习中一般选择一个-batch-中的所有其他样本作为负例，那如果负例中有很相似的样本怎么办？" class="headerlink" title="2. 对比学习中一般选择一个 batch 中的所有其他样本作为负例，那如果负例中有很相似的样本怎么办？"></a>2. <strong>对比学习中一般选择一个 batch 中的所有其他样本作为负例，那如果负例中有很相似的样本怎么办？</strong></h2><p>在无监督无标注的情况下，这样的伪负例，其实是不可避免的，首先可以想到的方式是去扩大语料库，去加大 batch size，以降低 batch 训练中采样到伪负例的概率，减少它的影响。</p>
<p>另外，神经网络是有一定容错能力的，像伪标签方法就是一个很好的印证，但前提是错误标签数据或伪负例占较小的比例。</p>
<p>PS：也确有人考虑研究过这个问题，可以参考论文 [3] [4]</p>
<h2 id="3-infoNCE-loss-如何去理解，和-CE-loss-有什么区别？"><a href="#3-infoNCE-loss-如何去理解，和-CE-loss-有什么区别？" class="headerlink" title="3. infoNCE loss 如何去理解，和 CE loss 有什么区别？"></a>3. <strong>infoNCE loss 如何去理解，和 CE loss 有什么区别？</strong></h2><p><strong>infoNCE loss</strong> 全称 info Noise Contrastive Estimation loss，对于一个 batch 中的样本 i，它的 loss 为：</p>
<p><img src="https://i.loli.net/2021/06/22/Omj8YCPkqeWwyp4.png" alt="image-20210622211019708" style="zoom:50%;"></p>
<p>要注意的是，<font color="red">log 里面的分母叠加项是<strong>包括了分子项</strong>的。</font> 分子是正例对的相似度，分母是正例对+所有负例对的相似度，最小化 infoNCE loss，就是去最大化分子的同时最小化分母，也就是最大化正例对的相似度，最小化负例对的相似度。</p>
<p>上面公式直接看可能没那么清晰，可以把负号放进去，分子分母倒过来化简一下就会很明了了。</p>
<p><strong>CE loss</strong>，Cross Entropy loss，在输入 p 是 softmax 的输出时：</p>
<p><img src="https://i.loli.net/2021/06/22/YFIfqETp1S7Kg83.png" alt="image-20210622211041814" style="zoom:50%;"></p>
<p>在分类场景下，真实标签 y 一般为 one-hot 的形式，因此，CE loss 可以简化成（i 位置对应标签 1）：</p>
<p><img src="https://i.loli.net/2021/06/22/saTEDlBWg1uUNAp.png" alt="image-20210622211108963" style="zoom:50%;"></p>
<p>看的出来，info NCE loss 和在一定条件下简化后的 CE loss 是非常相似的，但有一个区别要注意的是：</p>
<p>infoNCE loss 中的 K 是 batch 的大小，是可变的，是第 i 个样本要和 batch 中的每个样本计算相似度，而 batch 里的每一个样本都会如此计算，因此上面公式只是样本 i 的 loss。</p>
<p>CE loss 中的 K 是分类类别数的大小，任务确定时是不变的，i 位置对应标签为 1 的位置。不过实际上，infoNCE loss 就是直接可以用 CE loss 去计算的。</p>
<p>注：1）info NCE loss 不同的实现方式下，它的计算方式和 K 的含义可能会有差异；2）info NCE loss 是基于 NCE loss 的，对公式推导感兴趣的可以参考 [5]。</p>
<h2 id="4-对比学习的-infoNCE-loss-中的温度常数-t-的作用是什么？"><a href="#4-对比学习的-infoNCE-loss-中的温度常数-t-的作用是什么？" class="headerlink" title="4. 对比学习的 infoNCE loss 中的温度常数 t 的作用是什么？"></a>4. <strong>对比学习的 infoNCE loss 中的温度常数 t 的作用是什么？</strong></h2><p>论文 [6] 给出了非常细致的分析，知乎博客 [7] 则对论文 [6] 做了细致的解读，这里摘录它的要点部分：</p>
<p>温度系数的作用是调节对困难样本的关注程度：<strong>越小的温度系数越关注于将本样本和最相似的困难样本分开</strong>，去得到更均匀的表示。然而困难样本往往是与本样本相似程度较高的，很多困难负样本其实是潜在的正样本，过分强迫与困难样本分开会破坏学到的潜在语义结构，因此，温度系数不能过小。</p>
<p>考虑两个极端情况，温度系数趋向于 0 时，对比损失退化为只关注最困难的负样本的损失函数；当温度系数趋向于无穷大时，对比损失对所有负样本都一视同仁，失去了困难样本关注的特性。</p>
<p>还有一个角度：</p>
<p>可以把不同的负样本想像成同极点电荷在不同距离处的受力情况，距离越近的点电荷受到的库伦斥力更大，而距离越远的点电荷受到的斥力越小。</p>
<p>对比损失中，越近的负例受到的斥力越大，具体的表现就是对应的负梯度值越大 [4]。这种性质更有利于形成在超球面均匀分布的特征。</p>
<p>对照着公式去理解：</p>
<p><img src="https://i.loli.net/2021/06/22/QTPnuCLMc6Ug1sb.png" alt="image-20210622211420543" style="zoom:33%;"></p>
<p>温度系数很小时，越相似也即越困难的负例，对应的 就会越大，在分母叠加项中所占的比重就会越大，对整体 loss 的影响就会越大，具体的表现就是对应的负梯度值越大 [7]。</p>
<p>当然，这仅仅是提供了一种定性的认识，定量的认识和推导可以参见博客 [7]。</p>
<h2 id="5-SimCSE-中的-dropout-mask-指的是什么，dropout-rate-的大小影响的是什么？"><a href="#5-SimCSE-中的-dropout-mask-指的是什么，dropout-rate-的大小影响的是什么？" class="headerlink" title="5. SimCSE 中的 dropout mask 指的是什么，dropout rate 的大小影响的是什么？"></a>5. <strong>SimCSE 中的 dropout mask 指的是什么，dropout rate 的大小影响的是什么？</strong></h2><p>一般而言的 mask 是对 token 级别的 mask，比如说 BERT MLM 中的 mask，batch 训练时对 padding 位的 mask 等。</p>
<p>SimCSE 中的 dropout mask，对于 BERT 模型本身，是一种网络模型的随机，是对网络参数 W 的 mask，起到防止过拟合的作用。</p>
<p>而 SimCSE 巧妙的把它作为了一种 noise，起到数据增强的作用，因为同一句话，经过带 dropout 的模型两次，得到的句向量是不一样的，但是因为是相同的句子输入，最后句向量的语义期望是相同的，因此作为正例对，让模型去拉近它们之间的距离。</p>
<p>在实现上，因为一个 batch 中的任意两个样本，经历的 dropout mask 都是不一样的，因此，一个句子过两次 dropout，SimCSE 源码中实际上是在一个 batch 中实现的，即 [a,a,b,b…] 作为一个 batch 去输入。</p>
<p>dropout rate 大小的影响，可以理解为，这个概率会对应有 dropout 的句向量相对无 dropout 句向量，在整个单位超球体中偏移的程度，因为 BERT 是多层的结构，每一层都会有 dropout，这些 noise 的累积，会让句向量在每个维度上都会有偏移的，只是 p 较小的情况下，两个向量在空间中仍较为接近，如论文所说，“keeps a steady alignment”，保证了一个稳定的对齐性。</p>
<h2 id="6-SimCSE-无监督模式下的具体实现流程是怎样的，标签生成和-loss-计算如何实现？"><a href="#6-SimCSE-无监督模式下的具体实现流程是怎样的，标签生成和-loss-计算如何实现？" class="headerlink" title="6. SimCSE 无监督模式下的具体实现流程是怎样的，标签生成和 loss 计算如何实现？"></a>6. <strong>SimCSE 无监督模式下的具体实现流程是怎样的，标签生成和 loss 计算如何实现？</strong></h2><p>这里用一个简单的例子和 Pytorch 代码来说明：</p>
<p><strong>前向句子 embedding 计算：</strong></p>
<p>假设初始输入一个句子集 sents = [a,b]，每一句要过两次 BERT，因此复制成 sents = [a,a,b,b]。</p>
<p>sents 以 batch 的形式过 BERT 等语言模型得到句向量：batch_emb = [a1,a2,b1,b2]。</p>
<p><strong>batch 标签生成：</strong>标签为 1 的地方是相同句子不同 embedding 对应的位置。</p>
<p><img src="https://i.loli.net/2021/06/22/bE15TPnoGCRvFZk.png" alt="image-20210622211637062" style="zoom: 33%;"></p>
<p>pytorch 中的 CE_loss，要使用一维的数字标签，上面的 one-hot 标签可转换成：[1,0,3,2]。</p>
<p>可以把 label 拆成两个部分：奇数部分 [1,3…] 和偶数部分 [0,2…]，交替的每个奇数在偶数前面。因此实际生成的时候，可以分别生成两个部分再 concat 并 reshape 成一维。</p>
<p>pytorch 中 label 的生成代码如下：</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构造标签</span></span><br><span class="line"><span class="keyword">batch</span>_size = <span class="keyword">batch</span>_emb.size<span class="params">(0)</span></span><br><span class="line">y_<span class="literal">true</span> = torch.cat<span class="params">([torch.arange(1,batch_size,<span class="attr">step</span>=2,<span class="attr">dtype</span>=torch.long)</span><span class="string">.unsqueeze</span><span class="params">(1)</span>,</span><br><span class="line">                    torch.arange<span class="params">(0,batch_size,<span class="attr">step</span>=2,<span class="attr">dtype</span>=torch.long)</span><span class="string">.unsqueeze</span><span class="params">(1)</span>],</span><br><span class="line">                    dim=1)<span class="string">.reshape</span><span class="params">([batch_size,])</span></span><br></pre></td></tr></table></figure>
<p><strong>score 和 loss计算：</strong></p>
<p>batch_emb 会先 norm，再计算任意两个向量之间的点积，得到向量间的余弦相似度，维度是：[batch_size, batch_size]。</p>
<p>但是对角线的位置，也就是自身的余弦相似度，需要 mask 掉，因为它肯定是 1，是不产生 loss 的。</p>
<p>然后，要除以温度系数，再进行 loss 的计算，loss_func 采用 CE loss，注意 CE loss 中是自带 softmax 计算的。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算score和loss</span></span><br><span class="line"><span class="attr">norm_emb</span> = F.normalize(batch_emb, dim=<span class="number">1</span>, p=<span class="number">2</span>)</span><br><span class="line"><span class="attr">sim_score</span> = torch.matmul(norm_emb, norm_emb.transpose(<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="attr">sim_score</span> = sim_score - torch.eye(batch_size) * <span class="number">1</span>e12</span><br><span class="line"><span class="attr">sim_score</span> = sim_score * <span class="number">20</span>        <span class="comment"># 温度系数为 0.05，也就是乘以20</span></span><br><span class="line"><span class="attr">loss</span> = loss_func(sim_score, y_<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p>完整代码：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="attr">loss_func</span> = nn.CrossEntropyLoss()</span><br><span class="line">def simcse_loss(batch_emb):</span><br><span class="line">    <span class="string">""</span><span class="string">"用于无监督SimCSE训练的loss</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    <span class="comment"># 构造标签</span></span><br><span class="line">    <span class="attr">batch_size</span> = batch_emb.size(<span class="number">0</span>)</span><br><span class="line">    <span class="attr">y_true</span> = torch.cat([torch.arange(<span class="number">1</span>, batch_size, <span class="attr">step=2,</span> <span class="attr">dtype=torch.long).unsqueeze(1),</span></span><br><span class="line">                        torch.arange(<span class="number">0</span>, batch_size, <span class="attr">step=2,</span> <span class="attr">dtype=torch.long).unsqueeze(1)],</span></span><br><span class="line">                       <span class="attr">dim=1).reshape([batch_size,])</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算score和loss</span></span><br><span class="line">    <span class="attr">norm_emb</span> = F.normalize(batch_emb, <span class="attr">dim=1,</span> <span class="attr">p=2)</span></span><br><span class="line">    <span class="attr">sim_score</span> = torch.matmul(norm_emb, norm_emb.transpose(<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">    <span class="attr">sim_score</span> = sim_score - torch.eye(batch_size) * <span class="number">1</span>e12</span><br><span class="line">    <span class="attr">sim_score</span> = sim_score * <span class="number">20</span></span><br><span class="line">    <span class="attr">loss</span> = loss_func(sim_score, y_true)</span><br><span class="line">    return loss</span><br></pre></td></tr></table></figure>
<p>注：看过论文源码 [8] 的同学可能会发现，这个和论文源码中的实现方式不一样，论文源码是为了兼容无监督 SimCSE 和有监督 SimCSE，并兼容有 hard negative 的三句输入设计的，因此实现上有差异。</p>
<p>看过苏神源码 [9] 的同学也会发现，构造标签的地方不一样，那是因为 keras 的 CE loss 用的是 one-hot 标签，pytorch 用的是数字标签，但本质一样。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] Understanding Contrastive Representation Learning through Alignment and Uniformity on the Hypersphere</p>
<p>[2] <a href="https://zhuanlan.zhihu.com/p/367290573" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/367290573</a></p>
<p>[3] Debiased Contrastive Learning</p>
<p>[4] ADACLR: Adaptive Contrastive Learning Of Representation By Nearest Positive Expansion</p>
<p>[5] <a href="https://zhuanlan.zhihu.com/p/334772391" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/334772391</a></p>
<p>[6] Understanding the Behaviour of Contrastive Loss</p>
<p>[7] <a href="https://zhuanlan.zhihu.com/p/357071960" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/357071960</a></p>
<p>[8] <a href="https://github.com/princeton-nlp/SimCSE" target="_blank" rel="noopener">https://github.com/princeton-nlp/SimCSE</a></p>
<p>[9] <a href="https://github.com/bojone/SimCSE" target="_blank" rel="noopener">https://github.com/bojone/SimCSE</a></p>
]]></content>
  </entry>
  <entry>
    <title>目标检测模型中的性能评估——MAP(Mean Average Precision))</title>
    <url>/2019/08/31/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E2%80%94%E2%80%94MAP-Mean-Average-Precision/</url>
    <content><![CDATA[<p>参考：<a href="https://blog.csdn.net/katherine_hsr/article/details/79266880" target="_blank" rel="noopener">https://blog.csdn.net/katherine_hsr/article/details/79266880</a></p>
]]></content>
      <categories>
        <category>目标检测</category>
      </categories>
      <tags>
        <tag>目标检测</tag>
      </tags>
  </entry>
  <entry>
    <title>算法</title>
    <url>/2019/04/18/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<ul>
<li><p><a href="https://blog.csdn.net/v_JULY_v/article/details/19131887" target="_blank" rel="noopener">别人的博客</a></p>
</li>
<li><p><a href="https://shiyaya.github.io/2019/04/18/%E5%8F%8C%E6%8C%87%E9%92%88-two-pointers/" target="_blank" rel="noopener">双指针</a></p>
</li>
<li><p><a href="https://shiyaya.github.io/2019/04/18/%E6%8E%92%E5%BA%8F-sort/" target="_blank" rel="noopener">排序</a></p>
</li>
<li><p><a href="https://shiyaya.github.io/2019/04/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dynamic-programming/" target="_blank" rel="noopener">动态规划</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>视频分类总结</title>
    <url>/2019/04/09/%E8%A7%86%E9%A2%91%E5%88%86%E7%B1%BB%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="Two-Stream"><a href="#Two-Stream" class="headerlink" title="Two-Stream"></a>Two-Stream</h3><ul>
<li>训练<br>（1）spatial net：每个video中随机提取1帧：224<em>224</em>3，进行训练，<br>（2）temporal net：每个video中选取L=10帧光流，224<em>224</em>2L，进行训练<br>由于含有x,y 方向，因此10帧光流，对应的5帧图像，该5帧是连续的</li>
<li>测试：每个video中平均采25帧，并通过crop and flip等操作扩增10倍，整个video的得分，是这250帧的平均得分。</li>
</ul>
<h3 id="TSN"><a href="#TSN" class="headerlink" title="TSN"></a>TSN</h3><ul>
<li>训练，将video分段，默认为3段<br>（1）spatial net：每个video分成N段，每段随机提取1帧，则得到N帧，这N帧共享参数，一起训练，N帧分别得到的score进行平均，作为video的分数，并反向传播，训练。<br>（2）temporal net ,同理，每个video分成N段，每段随机提取L=10帧，这N段共享参数，一起训练，N段分别得到的score进行平均，作为video的分数，并反向传播，训练。</li>
<li>测试，将video分段，默认为25段</li>
<li>同训练过程</li>
</ul>
<h3 id="C3D"><a href="#C3D" class="headerlink" title="C3D"></a>C3D</h3><ul>
<li>在Sports-1M上进行训练，训练完成之后便得到一个video feature extractor </li>
<li>训练：在每个video中随机剪切5个2s长的clip，对clip进行训练 </li>
<li>测试：对于一个video，含有N帧，则将这N帧分成16帧的clips，每相邻的两个clips重叠8帧，然后将这些clips得到的fc6 activations 进行<strong>平均得到video feature</strong>，进而送入分类层得到video class label</li>
</ul>
<h3 id="I3D"><a href="#I3D" class="headerlink" title="I3D"></a>I3D</h3><ul>
<li>video 以25帧/秒的帧率来提取关键帧</li>
<li>训练：以64帧组成的snippets进行训练。</li>
<li>测试：同样以64帧组成的snippets进行测试，但是对于该video上的所有的snippet的<strong>预测结果进行取平均</strong>作为该video的预测结果</li>
</ul>
]]></content>
      <categories>
        <category>行为识别</category>
      </categories>
      <tags>
        <tag>行为识别</tag>
      </tags>
  </entry>
  <entry>
    <title>视频描述任务中用到objects的论文总结</title>
    <url>/2019/09/01/%E8%A7%86%E9%A2%91%E6%8F%8F%E8%BF%B0%E4%BB%BB%E5%8A%A1%E4%B8%AD%E7%94%A8%E5%88%B0objects%E7%9A%84%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ul>
<li><p>CVPR 2018</p>
<ol>
<li>Fine-grained Video Captioning for Sports Narrative</li>
</ol>
</li>
<li><p>CVPR 2019</p>
<ol>
<li>Grounded Video Description</li>
<li>Object-aware Aggregation with Bidirectional Temporal Graph for Video Captioning</li>
<li>Spatio-Temporal Dynamics and Semantic Attribute Enriched Visual Encoding for Video Captioning 【再去读一遍】</li>
<li>Adversarial Inference for Multi-Sentence Video Description</li>
</ol>
</li>
<li><p>ACM 2019</p>
<ol>
<li>Hierarchical Global-Local Temporal Modeling for Video Captioning</li>
</ol>
</li>
</ul>
<h3 id="Grounded-Video-Description"><a href="#Grounded-Video-Description" class="headerlink" title="Grounded Video Description"></a>Grounded Video Description</h3><p><img src="https://i.loli.net/2019/09/02/Hvtk4BJVNQ2WwdM.png" alt="搜狗截图20190902104324.png"></p>
<ol>
<li><p>如何使用region feature？</p>
<p> 仅在language lstm 用到了 region featrue, attention 加权求和之后 与 cat[ fc, motion] features 对应元素相加（cat[fc, motion]也是在经过attention加权求和之后的）</p>
<p> 但我个人认为对应元素相加，并没有道理，相当于在 cat[ fc, motion] 的基础上增加了一个 bias，没有什么道理</p>
</li>
<li><p>region feature 的构成？</p>
<p>R：是 object detector  在 fc6 输出的 feature</p>
<p>Ms(R)：是 object detector 在 fc7 输出的feature (这里有一些细节的修改，具体见论文)</p>
<p>Ml： 是 position embedding</p>
</li>
</ol>
<p><img src="https://i.loli.net/2019/09/02/y4JkxlmLQpqaj5c.png" alt="搜狗截图20190902105022.png"></p>
<h3 id="Object-aware-Aggregation-with-Bidirectional-Temporal-Graph-for-Video-Captioning"><a href="#Object-aware-Aggregation-with-Bidirectional-Temporal-Graph-for-Video-Captioning" class="headerlink" title="Object-aware Aggregation with Bidirectional Temporal Graph for Video Captioning"></a>Object-aware Aggregation with Bidirectional Temporal Graph for Video Captioning</h3><p><img src="https://i.loli.net/2019/09/02/TIP7Ww3FnLNKzvu.png" alt="搜狗截图20190902144125.png"></p>
<ol>
<li><p>简要介绍本文的结构</p>
<p> 在encoder 部分，使用 object feature 和 frame feature，分别经过设计的VALD 得到更新的特征向量</p>
<p> 在 decoder 部分，对object feature 使用两层的attention, 先对 <strong>一个轨迹</strong>上的objects 进行attention 的加权求和，再对N different objects instances进行 attention 的加权求和，这样就可以得到对所有objects 的聚合表达</p>
<p> 轨迹：对于第一帧的ojects, 根据相似性分别去找其他帧与其对应的objects，而构成的时域轨迹。</p>
<p>  这里采用了前向轨迹，和后向轨迹两种，在decoder 输出预测的单词之后，进行融合。</p>
</li>
<li><p>如何使用region feature？<br> 仅有一个lstm ，在输入lstm前对objects features进行两层attention 加权求和后，与同样经过attention的frames feature进行加和（sum）。<br> 本文没有使用 motion feeture</p>
</li>
<li><p>region feature 的构成？<br> 非常简单，只有 appearance feature，但是经过了 obejct VLAD module！</p>
</li>
<li><font color="#0099ff" size="5" face="黑体">object feature 的 hierarchical attention 值得借鉴呢！<br>计算object 相似性的部分也不错</font>



</li>
</ol>
<h3 id="Spatio-Temporal-Dynamics-and-Semantic-Attribute-Enriched-Visual-Encoding-for-Video-Captioning"><a href="#Spatio-Temporal-Dynamics-and-Semantic-Attribute-Enriched-Visual-Encoding-for-Video-Captioning" class="headerlink" title="Spatio-Temporal Dynamics and Semantic Attribute Enriched Visual Encoding for Video Captioning"></a>Spatio-Temporal Dynamics and Semantic Attribute Enriched Visual Encoding for Video Captioning</h3><p><img src="https://i.loli.net/2019/09/02/T5AzpW8DHkVL2Oy.png" alt="搜狗截图20190902152617.png"></p>
<ul>
<li>此文没有太看懂</li>
</ul>
<ol>
<li><p>如何使用region feature？</p>
<p> 得到 obejcts sematics embeddding 一起其他三个信息，经过聚合之后得到特征向量v，再经过一个线性变换得到v，再送入decoder中</p>
</li>
<li><p>region feature 的构成？</p>
<p> 由 object detector 输出的特征，以及其他输出（objetcs 存现的频率、概率），来构建semantics</p>
</li>
</ol>
<h3 id="Hierarchical-Global-Local-Temporal-Modeling-for-Video-Captioning"><a href="#Hierarchical-Global-Local-Temporal-Modeling-for-Video-Captioning" class="headerlink" title="Hierarchical Global-Local Temporal Modeling for Video Captioning"></a>Hierarchical Global-Local Temporal Modeling for Video Captioning</h3><p><img src="https://i.loli.net/2019/09/02/m5xLQnzCJGsjWVc.png" alt="搜狗截图20190902161552.png"></p>
<ol>
<li><p>如何使用region features ?</p>
<p> encoder 部分由两层LSTM，第一层LSTM 构建 frames features 和 c3d features的 隐层状态，并送入第二层LSTM，</p>
<p>在第二层LSTM 的每一个step, 都对该step 对应帧上的 objetcs进行attention 加权求和，并送入LSTM中，得到该帧的objects 的聚合特征的隐层状态   </p>
<p> <img src="https://i.loli.net/2019/09/02/q6XNP8iSVzekyCE.png" alt="搜狗截图20190902165813.png"></p>
</li>
<li><p>region feature 的构成？</p>
<p>   每帧 objects features 的加权求和，再经过LSTM得到隐层状态</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>当前基于 objects feature 的论文，decoder 部分没有太大的新颖（一般都是Top-Down或者是 Soft-Attention），主要的新颖的地方是在 encoder 部分</li>
<li>encoder部分有的使用LSTM 以及attention 来更新 objects features；有的使用VLAD 来构建 行为特征，使用 objects 的时域轨迹和两层attention 来聚合特征；使用objetcs 的其他信息，比如 position 以及 label 等信息</li>
</ul>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉学术会议</title>
    <url>/2019/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE/</url>
    <content><![CDATA[<h3 id="A类"><a href="#A类" class="headerlink" title="A类"></a>A类</h3><ul>
<li>(AAAI)   Conference on Artificial Intelligence  </li>
</ul>
<p>截稿日期：2019-8-30</p>
<ul>
<li>CVPR 2019: IEEE Conference on Computer Vision and Pattern Recognition    </li>
</ul>
<p><a href="http://cvpr2019.thecvf.com/" target="_blank" rel="noopener">http://cvpr2019.thecvf.com/</a> </p>
<p>截稿日期：2018-11-16<br>通知日期：2019-03-02<br>会议日期：2019-06-15</p>
<ul>
<li>IJCAI 2019: International Joint Conference on Artificial Intelligence</li>
</ul>
<p><a href="http://www.ijcai19.org" target="_blank" rel="noopener">http://www.ijcai19.org</a></p>
<p>截稿日期：2019-02-05<br>会议日期：Aug 10 - Aug 16, 2019</p>
<ul>
<li>ICCV2019: International Conference on Computer Vision</li>
</ul>
<p><a href="http://iccv2019.thecvf.com" target="_blank" rel="noopener">http://iccv2019.thecvf.com</a></p>
<p>截稿日期：2019-05-01<br>会议日期：Oct 27 - Nov 3, 2019</p>
<ul>
<li>ECCV</li>
</ul>
<p>截稿时间：3 月 14 日<br>会议时间：9 月 8-14 日</p>
<ul>
<li>ACM International Conference on Multimedia (ACM MM) </li>
</ul>
<p><a href="https://www.acmmm.org/2019/" target="_blank" rel="noopener">https://www.acmmm.org/2019/</a></p>
<p>截稿日期：2019.4.1</p>
<h3 id="B类"><a href="#B类" class="headerlink" title="B类"></a>B类</h3><ul>
<li>ICME 2019: International Conference on Multimedia and Expo</li>
</ul>
<p><a href="http://www.icme2019.org" target="_blank" rel="noopener">http://www.icme2019.org</a> </p>
<p>截稿日期：2018-12-03<br>通知日期：2019-03-11<br>会议日期：2019-07-08</p>
<h3 id="C类"><a href="#C类" class="headerlink" title="C类"></a>C类</h3><ul>
<li>BMVC</li>
</ul>
<p><a href="http://bmvc2018.org" target="_blank" rel="noopener">http://bmvc2018.org</a></p>
<p>截稿时间：4 月 30 日</p>
<ul>
<li>ICIP</li>
</ul>
<p>截稿时间：3 月 2 日</p>
]]></content>
      <categories>
        <category>杂类</category>
      </categories>
      <tags>
        <tag>杂类</tag>
      </tags>
  </entry>
  <entry>
    <title>视频解码</title>
    <url>/2019/04/09/%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81/</url>
    <content><![CDATA[<ul>
<li>opencv提取关键帧（banet）</li>
<li><p>ffmpeg提取关键帧 （video to text）</p>
</li>
<li><p>i帧、P帧、B帧</p>
</li>
<li>参考：<a href="https://blog.csdn.net/huangblog/article/details/8739876" target="_blank" rel="noopener">https://blog.csdn.net/huangblog/article/details/8739876</a><br>I帧，Intra-coded frame：是一张完整的图片<br>P帧，predictive frame: 记录了与之前真的差别，在解码P帧之前需要参考之前的图片帧<br>B帧，Bi-Predictive frame: 不仅需要参考之前的图片帧，还需要参考之后的图片帧，才能完整解码。<br>因此解码P帧、B帧的速度相对较慢，直接解码I帧可以获得更快的速度。<br><strong>简单地讲，I帧是一个完整的画面，而P帧和B帧记录的是相对于I帧的变化。没有I帧，P帧和B帧就无法解码</strong>  </li>
</ul>
<h3 id="GOP"><a href="#GOP" class="headerlink" title="GOP"></a>GOP</h3><p>所谓GOP，意思是画面组，一个GOP就是一组连续的画面。从一个I帧到下一个I帧之间的所有帧的组合称为一个GOP。</p>
<ul>
<li><strong>I帧</strong><br>I帧是参考帧，一个GOP中必须含有I帧，它是一个全帧压缩编码帧。它将全帧图像信息进行JPEG压缩编码及传输。</li>
<li><strong>P帧的预测与重构:</strong><br>P帧是以I帧为参考帧,在I帧中找出P帧“某点”的预测值和运动矢量,取预测差值和运动矢量一起传送。在接收端根据运动矢量从I帧中找出P帧“某点”的预测值并与差值相加以得到P帧“某点”样值,从而可得到完整的P帧。</li>
<li><p><strong>B帧的预测与重构：</strong><br>B帧以前面的I或P帧和后面的P帧为参考帧,“找出”B帧“某点”的预测值和两个运动矢量,并取预测差值和运动矢量传送。接收端根据运动矢量在两个参考帧中“找出(算出)”预测值并与差值求和,得到B帧“某点”样值,从而可得到完整的B帧。</p>
</li>
<li><p><strong>用下图中的1234567帧来表达</strong><br>首先由1：I帧，<br>再由1、4帧得到第4帧所在位置处的图像信息<br>最后由1、4、2得到第2帧所在位置处的图像信息，由1、4、3得到第3帧所在位置处的图像信息</p>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1w7ki6x02j30ra0ge0st.jpg">  </p>
<ul>
<li>另外一张图  </li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1w7ki8pfvj30nm0fk77r.jpg"></p>
<hr>
<h3 id="视频压缩：I帧、P帧、B帧"><a href="#视频压缩：I帧、P帧、B帧" class="headerlink" title="视频压缩：I帧、P帧、B帧"></a>视频压缩：I帧、P帧、B帧</h3><ul>
<li>来源： <a href="https://blog.csdn.net/huangblog/article/details/8739876" target="_blank" rel="noopener">https://blog.csdn.net/huangblog/article/details/8739876</a></li>
</ul>
<p>视频压缩中，每帧代表一幅静止的图像。而在实际压缩时，会采取各种算法减少数据的容量，其中IPB就是最常见的。</p>
<pre><code>简单地说，I帧是关键帧，属于帧内压缩。就是和AVI的压缩是一样的。
P是向前搜索的意思。B是双向搜索。他们都是基于I帧来压缩数据。
</code></pre><p>   I帧表示关键帧，你可以理解为这一帧画面的完整保留；解码时只需要本帧数据就可以完成（因为包含完整画面）</p>
<p>   P帧表示的是这一帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是差别帧，P帧没有完整画面数据，只有与前一帧的画面差别的数据）</p>
<p>   B帧是双向差别帧，也就是B帧记录的是本帧与前后帧的差别（具体比较复杂，有4种情况），换言之，要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时CPU会比较累~。</p>
<pre><code>采用的压缩方法: 分组:把几帧图像分为一组(GOP),为防止运动变化,帧数不宜取多。

    1.定义帧:将每组内各帧图像定义为三种类型,即I帧、B帧和P帧;

    2.预测帧:以I帧做为基础帧,以I帧预测P帧,再由I帧和P帧预测B帧;

    3.数据传输:最后将I帧数据与预测的差值信息进行存储和传输。
</code></pre><p>一、I帧  </p>
<pre><code>I图像（帧）是靠尽可能去除图像空间冗余信息来压缩传输数据量的帧内编码图像。

I帧又称为内部画面 (intra picture)，I 帧通常是每个 GOP（MPEG 所使用的一种视频压缩技术）的第一个帧，经过适度地压缩（做为随机访问的参考点）可以当成图象。在MPEG编码的过程中部分视频帧序列压缩成为I帧，部分压缩成P帧，还有部分压缩成B帧。I帧法是帧内压缩法（P、B为帧间），也称为“关键帧”压缩法。I帧法是基于离散余弦变换DCT（Discrete Cosine Transform）的压缩技术，这种算法与JPEG压缩算法类似。采用I帧压缩可达到1/6的压缩比而无明显的压缩痕迹。

I帧特点：

    1.它是一个全帧压缩编码帧。它将全帧图像信息进行JPEG压缩编码及传输;

    2.解码时仅用I帧的数据就可重构完整图像;

    3.I帧描述了图像背景和运动主体的详情;

    4.I帧不需要参考其他画面而生成;

    5.I帧是P帧和B帧的参考帧(其质量直接影响到同组中以后各帧的质量);

    6.I帧是帧组GOP的基础帧(第一帧),在一组中只有一个I帧;

    7.I帧不需要考虑运动矢量;

    8.I帧所占数据的信息量比较大。

I帧编码流程：

    (1)进行帧内预测，决定所采用的帧内预测模式。

    (2)像素值减去预测值，得到残差。

    (3)对残差进行变换和量化。

    (4)变长编码和算术编码。

    (5)重构图像并滤波，得到的图像作为其它帧的参考帧。
</code></pre><p>二、P帧</p>
<pre><code> P图像（帧）是通过充分降低于图像序列中前面已编码帧的时间冗余信息来压缩传输数据量的编码图像，也叫预测帧。

在针对连续动态图像编码时，将连续若干幅图像分成P,B,I三种类型，P帧由在它前面的P帧或者I帧预测而来，它比较与它前面的P帧或者I帧之间的相同信息或数据，也即考虑运动的特性进行帧间压缩。P帧法是根据本帧与相邻的前一帧（I帧或P帧）的不同点来压缩本帧数据。采取P帧和I帧联合压缩的方法可达到更高的压缩且无明显的压缩痕迹。

P帧的预测与重构:

    P帧是以I帧为参考帧,在I帧中找出P帧“某点”的预测值和运动矢量,取预测差值和运动矢量一起传送。在接收端根据运动矢量从I帧中找出P帧“某点”的预测值并与差值相加以得到P帧“某点”样值,从而可得到完整的P帧。

P帧特点：

    ①P帧是I帧后面相隔1-2帧的编码帧。  

    ②P帧采用运动补偿的方法传送它与前面的I或P帧的差值及运动矢量（预测误差）。  

    ③解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧图像。  

    ④P帧属于前向预测的帧间编码。它只参考前面最靠近它的I帧或P帧。  

    ⑤P帧可以是其后面P帧的参考帧，也可以是其前后的B帧的参考帧。

    ⑥由于P帧是参考帧，它可能造成解码错误的扩散。 

    ⑦由于是差值传送，P帧的压缩比较高。
</code></pre><p>三、B帧</p>
<pre><code>B图像（帧）是既考虑与源图像序列前面已编码帧，也顾及源图像序列后面已编码帧之间的时间冗余信息来压缩传输数据量的编码图像，也叫双向预测帧。   

B帧法是双向预测的帧间压缩算法。当把一帧压缩成B帧时，它根据相邻的前一帧、本帧以及后一帧数据的不同点来压缩本帧，也即仅记录本帧与前后帧的差值。只有采用B帧压缩才能达到200：1的高压缩。一般地，I帧压缩效率最低，P帧较高，B帧最高。

B帧的预测与重构：

    B帧以前面的I或P帧和后面的P帧为参考帧,“找出”B帧“某点”的预测值和两个运动矢量,并取预测差值和运动矢量传送。接收端根据运动矢量在两个参考帧中“找出(算出)”预测值并与差值求和,得到B帧“某点”样值,从而可得到完整的B帧。

B帧特点：

    1.B帧是由前面的I或P帧和后面的P帧来进行预测的;

    2.B帧传送的是它与前面的I或P帧和后面的P帧之间的预测误差及运动矢量;

    3.B帧是双向预测编码帧;

    4.B帧压缩比最高,因为它只反映2参考帧间运动主体的变化情况,预测比较准确;

    5.B帧不是参考帧,不会造成解码错误的扩散。 

P 帧和 B 帧编码的基本流程为：

    (1)进行运动估计，计算采用帧间编码模式的率失真函数(节)值。P 帧 只参考前面的帧，B 帧可参考后面的帧。

    (2)进行帧内预测，选取率失真函数值最小的帧内模式与帧间模式比较，确定采用哪种编码模式。

    (3)计算实际值和预测值的差值。

    (4)对残差进行变换和量化。

    (5)若编码，如果是帧间编码模式，编码运动矢量。

注:I、B、P各帧是根据压缩算法的需要,是人为定义的,它们都是实实在在的物理帧,至于图像中的哪一帧是I帧,是随机的,一但确定了I帧,以后的各帧就严格按规定顺序排列。 
</code></pre><p>四、实际应用</p>
<pre><code>从上面的解释看，我们知道I和P的解码算法比较简单，资源占用也比较少，I只要自己完成就行了，P呢，也只需要解码器把前一个画面缓存一下，遇到P时就使用之前缓存的画面就好了，如果视频流只有I和P，解码器可以不管后面的数据，边读边解码，线性前进，大家很舒服。

但网络上的电影很多都采用了B帧，因为B帧记录的是前后帧的差别，比P帧能节约更多的空间，但这样一来，文件小了，解码器就麻烦了，因为在解码时，不仅要用之前缓存的画面，还要知道下一个I或者P的画面（也就是说要预读预解码），而且，B帧不能简单地丢掉，因为B帧其实也包含了画面信息，如果简单丢掉，并用之前的画面简单重复，就会造成画面卡（其实就是丢帧了），并且由于网络上的电影为了节约空间，往往使用相当多的B帧，B帧用的多，对不支持B帧的播放器就造成更大的困扰，画面也就越卡。

一般平均来说，I的压缩率是7（跟JPG差不多），P是20，B可以达到50，可见使用B帧能节省大量空间，节省出来的空间可以用来保存多一些I帧，这样在相同码率下，可以提供更好的画质。
</code></pre>]]></content>
  </entry>
  <entry>
    <title>视频描述评价指标的分析</title>
    <url>/2019/09/21/%E8%A7%86%E9%A2%91%E6%8F%8F%E8%BF%B0%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87%E7%9A%84%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>设置随机种子</title>
    <url>/2019/07/21/%E8%AE%BE%E7%BD%AE%E9%9A%8F%E6%9C%BA%E7%A7%8D%E5%AD%90/</url>
    <content><![CDATA[<p>def set_random_seed(seed):<br>    random.seed(seed)<br>    np.random.seed(seed)<br>    torch.manual_seed(seed)<br>    torch.cuda.manual_seed_all(seed)</p>
]]></content>
  </entry>
  <entry>
    <title>评价者之间的一致性-Kappas</title>
    <url>/2020/08/06/%E8%AF%84%E4%BB%B7%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7-Kappas/</url>
    <content><![CDATA[<h3 id="评价者之间的一致性—Kappas-Inter-rater-agreement-Kappas"><a href="#评价者之间的一致性—Kappas-Inter-rater-agreement-Kappas" class="headerlink" title="评价者之间的一致性—Kappas Inter-rater agreement Kappas"></a>评价者之间的一致性—Kappas Inter-rater agreement Kappas</h3><p>inter-rater reliability == inter-rater agreement == concordance</p>
<p>评价者之间的一致性的Kappa分数代表着在打分判断中，他们有多少共识，有多一致。</p>
<p>Kappa分数处于0-1之间，具体地：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">K</th>
<th style="text-align:center">Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&lt;0</td>
<td style="text-align:center">Poor agreement 不一致</td>
</tr>
<tr>
<td style="text-align:center">0.0-0.20</td>
<td style="text-align:center">Slight agreement</td>
</tr>
<tr>
<td style="text-align:center">0.21-0.40</td>
<td style="text-align:center">Fair agreement</td>
</tr>
<tr>
<td style="text-align:center">0.41-0.60</td>
<td style="text-align:center">Moderate agreement</td>
</tr>
<tr>
<td style="text-align:center">0.61-0.80</td>
<td style="text-align:center">Substantial agreement</td>
</tr>
<tr>
<td style="text-align:center">0.81-1.0</td>
<td style="text-align:center">Almost perfect agreement</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Cohen’s-Kappa"><a href="#Cohen’s-Kappa" class="headerlink" title="Cohen’s Kappa"></a>Cohen’s Kappa</h3><p>Cohen’s Kappa 计算了评分者之间的一致性。当评分者对同一项任务给出了相同的判断或分数，那么他们的一致性得到了体现。</p>
<p>Cohen’s Kappa 只能在以下的条件下使用：</p>
<ul>
<li>两个评价者分别对每个样本进行评分</li>
<li>一个评价者对每个样本进行两次评分</li>
</ul>
<p><strong>Cohen’s Kappa 计算</strong></p>
<p>要注意的是，一般情况下，Cohen’s Kappa 的计算背景是：有<strong>两个</strong>评分者对每个样本进行<strong>二分类</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">postive (rater A)</th>
<th style="text-align:center">negative (rater A)</th>
<th style="text-align:center">Total</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>postive (rater B)</strong></td>
<td style="text-align:center"><img src="https://math.jianshu.com/math?formula=n_%7B11%7D" alt="n_{11}"></td>
<td style="text-align:center"><img src="https://math.jianshu.com/math?formula=n_%7B12%7D" alt="n_{12}"></td>
<td style="text-align:center"><img src="https://math.jianshu.com/math?formula=n_%7B1.%7D" alt="n_{1.}"></td>
</tr>
<tr>
<td style="text-align:center"><strong>negative (rater B)</strong></td>
<td style="text-align:center"><img src="https://math.jianshu.com/math?formula=n_%7B21%7D" alt="n_{21}"></td>
<td style="text-align:center"><img src="https://math.jianshu.com/math?formula=n_%7B22%7D" alt="n_{22}"></td>
<td style="text-align:center"><img src="https://math.jianshu.com/math?formula=n_%7B2.%7D" alt="n_{2.}"></td>
</tr>
<tr>
<td style="text-align:center"><strong>Total</strong></td>
<td style="text-align:center"><img src="https://math.jianshu.com/math?formula=n_%7B.1%7D" alt="n_{.1}"></td>
<td style="text-align:center"><img src="https://math.jianshu.com/math?formula=n_%7B.2%7D" alt="n_{.2}"></td>
<td style="text-align:center"><img src="https://math.jianshu.com/math?formula=n_%7B11%7D%2Bn_%7B12%7D%2Bn_%7B21%7D%2Bn_%7B22%7D" alt="n_{11}+n_{12}+n_{21}+n_{22}"></td>
</tr>
</tbody>
</table>
</div>
<p>计算公式为：<br> <img src="https://math.jianshu.com/math?formula=k%20%3D%20%5Cfrac%7Bp_o-p_e%7D%7B1-p_e%7D%20%3D%201-%5Cfrac%7B1-p_o%7D%7B1-p_e%7D" alt="k = \frac{p_o-p_e}{1-p_e} = 1-\frac{1-p_o}{1-p_e}"><br> 其中，<img src="https://math.jianshu.com/math?formula=p_o" alt="p_o"> 代表评价者之间的相对观察一致性（the relative <strong>observed agreement</strong> among raters）<br> <img src="https://math.jianshu.com/math?formula=p_o%3D%5Cfrac%7Bn_%7B11%7D%2Bn_%7B22%7D%7D%7Bn_%7B11%7D%2Bn_%7B12%7D%2Bn_%7B21%7D%2Bn_%7B22%7D%7D" alt="p_o=\frac{n_{11}+n_{22}}{n_{11}+n_{12}+n_{21}+n_{22}}"><br> <img src="https://math.jianshu.com/math?formula=p_e" alt="p_e"> 代表偶然一致性的假设概率（the hypothetical probability of <strong>chance agreemnet</strong>）<br> <img src="https://math.jianshu.com/math?formula=p_e%3D%5Cfrac%7Bn_%7B.1%7D*n_%7B1.%7D%7D%7B(n_%7B11%7D%2Bn_%7B12%7D%2Bn_%7B21%7D%2Bn_%7B22%7D" alt="p_e=\frac{n_{.1}*n_{1.}}{(n_{11}+n_{12}+n_{21}+n_{22})^2}+\frac{n_{.2}*n_{2.}}{(n_{11}+n_{12}+n_{21}+n_{22})^2}=\frac{n_{.1}*n_{1.}+n_{.2}*n_{2.}}{(n_{11}+n_{12}+n_{21}+n_{22})^2}">%5E2%7D%2B%5Cfrac%7Bn_%7B.2%7D<em>n_%7B2.%7D%7D%7B(n_%7B11%7D%2Bn_%7B12%7D%2Bn_%7B21%7D%2Bn_%7B22%7D)%5E2%7D%3D%5Cfrac%7Bn_%7B.1%7D</em>n_%7B1.%7D%2Bn_%7B.2%7D<em>n_%7B2.%7D%7D%7B(n_%7B11%7D%2Bn_%7B12%7D%2Bn_%7B21%7D%2Bn_%7B22%7D)%5E2%7D)<br> <em>*例子</em></em></p>
<p>rater A和rater B对50张图片进行分类，正类和负类。结果为：</p>
<ul>
<li>20张图片两个评价者都认为是正类</li>
<li>15张图片两个评价者都认为是负类</li>
<li>rater A认为25张图片是正类，25张图片是负类</li>
<li>rater B 认为30张图片是正类，20张图片是负类</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">postive (rater A)</th>
<th style="text-align:center">negative (rater A)</th>
<th style="text-align:center">Total</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>postive (rater B)</strong></td>
<td style="text-align:center">20</td>
<td style="text-align:center">10</td>
<td style="text-align:center">30</td>
</tr>
<tr>
<td style="text-align:center"><strong>negative (rater B)</strong></td>
<td style="text-align:center">5</td>
<td style="text-align:center">15</td>
<td style="text-align:center">20</td>
</tr>
<tr>
<td style="text-align:center"><strong>Total</strong></td>
<td style="text-align:center">25</td>
<td style="text-align:center">25</td>
<td style="text-align:center">50</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Step1</strong> ：计算<img src="https://math.jianshu.com/math?formula=p_o" alt="p_o"><br> <img src="https://math.jianshu.com/math?formula=p_o%3Dnumber%5C%20in%5C%20agreement%2F%5C%20total%3D(20%2B15" alt="p_o=number\ in\ agreement/\ total=(20+15)/50=0.70">%2F50%3D0.70)</p>
<p><strong>Step2</strong> ：计算<img src="https://math.jianshu.com/math?formula=p_e" alt="p_e"><br> <img src="https://math.jianshu.com/math?formula=p_e%3DThe%5C%20total%5C%20probability%5C%20the%5C%20raters%5C%20both%5C%20saying%5C%20postive%20%5C%5Cand%5C%20negative%20%5C%20randomly%20%3D(25%2F50" alt="p_e=The\ total\ probability\ the\ raters\ both\ saying\ postive \\and\ negative \ randomly =(25/50)*(30/50)+(25/50)*(20/50)=0.50"><em>(30%2F50)%2B(25%2F50)</em>(20%2F50)%3D0.50)<br> <strong>Step3</strong> ：计算<img src="https://math.jianshu.com/math?formula=k" alt="k"><br> <img src="https://math.jianshu.com/math?formula=k%3D%5Cfrac%7Bp_o-p_e%7D%7B1-p_e%7D%3D%5Cfrac%7B0.70-0.50%7D%7B1-0.50%7D%3D0.40" alt="k=\frac{p_o-p_e}{1-p_e}=\frac{0.70-0.50}{1-0.50}=0.40"><br> <img src="https://math.jianshu.com/math?formula=k%3D0.40" alt="k=0.40"> 代表<strong>fair agreement</strong></p>
<h3 id="Fleiss’s-Kappa"><a href="#Fleiss’s-Kappa" class="headerlink" title="Fleiss’s Kappa"></a>Fleiss’s Kappa</h3><p>Fleiss’s Kappa 是对 Cohen‘s Kappa 的扩展：</p>
<ul>
<li>衡量<strong>三个或更多</strong>评分者的一致性</li>
<li>不同的评价者可以对不同的项目进行评分，而不用像Cohen’s 两个评价者需要对相同的项目进行评分</li>
<li>Cohen’s Kappa 的评价者是精心选择和固定的，而Fleiss’s Kappa 的评价者是从较大的人群中随机选择的</li>
</ul>
<p>举一个例子对 Fleiss’s Kappa 的计算进行说明：14个评价者对10个项目进行1-5的评分，<img src="https://math.jianshu.com/math?formula=N%3D10%2Cn%3D14%2Ck%3D5" alt="N=10,n=14,k=5"></p>
<blockquote>
<p>关于这  “10个项目” 的理解：比如在 NLI 数据标注中，需要为很多 promise-hypotheses pair 进行打分，这每一个pair就是一个pair.</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://math.jianshu.com/math?formula=n_%7Bij%7D" alt="n_{ij}"></th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center"><img src="https://math.jianshu.com/math?formula=P_i" alt="P_i"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">14</td>
<td style="text-align:center">1.000</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">6</td>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0.253</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">0.308</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">9</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0.440</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">8</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0.330</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
<td style="text-align:center">7</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0.462</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">6</td>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0.242</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">2</td>
<td style="text-align:center">5</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0.176</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">6</td>
<td style="text-align:center">5</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0.286</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">7</td>
<td style="text-align:center">0.286</td>
</tr>
<tr>
<td style="text-align:center">Total</td>
<td style="text-align:center">20</td>
<td style="text-align:center">28</td>
<td style="text-align:center">39</td>
<td style="text-align:center">21</td>
<td style="text-align:center">32</td>
<td style="text-align:center">140</td>
</tr>
<tr>
<td style="text-align:center"><img src="https://math.jianshu.com/math?formula=p_j" alt="p_j"></td>
<td style="text-align:center">0.143</td>
<td style="text-align:center">0.200</td>
<td style="text-align:center">0.279</td>
<td style="text-align:center">0.150</td>
<td style="text-align:center">0.229</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Step1</strong> ：计算<img src="https://math.jianshu.com/math?formula=p_j" alt="p_j"> ，以<img src="https://math.jianshu.com/math?formula=p_1" alt="p_1">为例，评价者随机打1分的概率<br> <img src="https://math.jianshu.com/math?formula=p_1%3Dthe%5C%20total%5C%20number%5C%20of%5C%20the%5C%20column%2F%5C%20the%5C%20total%5C%20number%5C%20of%20%5C%20tasks%20%3D%2020%2F14*10%3D0.143" alt="p_1=the\ total\ number\ of\ the\ column/\ the\ total\ number\ of \ tasks = 20/14*10=0.143"><br> <strong>Step2</strong> ：计算<img src="https://math.jianshu.com/math?formula=P_i" alt="P_i"> ，以<img src="https://math.jianshu.com/math?formula=P_2" alt="P_2">为例,14个评价者对第2个任务达成共识的程度<br> <img src="https://math.jianshu.com/math?formula=P_2%3D%5Cfrac%7Bthe%5C%20sum%5C%20of%5C%20suqare%20%5C%20of%5C%20the%5C%20row%7D%7Bn*(n-1" alt="P_2=\frac{the\ sum\ of\ suqare \ of\ the\ row}{n*(n-1)}=\frac{0^2+2^2+6^2+4^2-14}{14*(14-1)}=0.253">%7D%3D%5Cfrac%7B0%5E2%2B2%5E2%2B6%5E2%2B4%5E2-14%7D%7B14<em>(14-1)%7D%3D0.253)<br> <strong>Step3</strong> ：计算<img src="https://math.jianshu.com/math?formula=P_e%2CP_o" alt="P_e,P_o"><br> ![P_o=\frac{1}{N}\sum_{i=1}^{N}P_i=\frac{1}{10}</em>3.78=0.378](<a href="https://math.jianshu.com/math?formula=P_o%3D%5Cfrac%7B1%7D%7BN%7D%5Csum_%7Bi%3D1%7D%5E%7BN%7DP_i%3D%5Cfrac%7B1%7D%7B10%7D*3.78%3D0.378" target="_blank" rel="noopener">https://math.jianshu.com/math?formula=P_o%3D%5Cfrac%7B1%7D%7BN%7D%5Csum_%7Bi%3D1%7D%5E%7BN%7DP_i%3D%5Cfrac%7B1%7D%7B10%7D*3.78%3D0.378</a>)</p>
<p><img src="https://math.jianshu.com/math?formula=P_e%3D%5Csum_%7Bj%3D1%7D%5E%7Bk%7Dp_j%5E2%3D0.143%5E2%2B0.200%5E2%2B0.279%5E2%2B0.150%5E2%2B0.229%5E2%3D0.213" alt="P_e=\sum_{j=1}^{k}p_j^2=0.143^2+0.200^2+0.279^2+0.150^2+0.229^2=0.213"></p>
<p><img src="https://math.jianshu.com/math?formula=k%3D%5Cfrac%7BP_o-P_e%7D%7B1-P_e%7D%3D%5Cfrac%7B0.378-0.213%7D%7B1-0.213%7D%3D0.210" alt="k=\frac{P_o-P_e}{1-P_e}=\frac{0.378-0.213}{1-0.213}=0.210"></p>
<p><img src="https://math.jianshu.com/math?formula=k%3D0.210" alt="k=0.210"> 代表<strong>fair agreement</strong></p>
<blockquote>
<p>[1] Landis JR, Koch GG. The measurement of observer agreement for categorical data. Biometrics.     1977;33(1):159–74</p>
<p>[2] <a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.pmean.com%2Fdefinitions%2Fkappa.htm" target="_blank" rel="noopener">http://www.pmean.com/definitions/kappa.htm</a></p>
<p>[3] <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.statisticshowto.datasciencecentral.com%2Fcohens-kappa-statistic%2F" target="_blank" rel="noopener">https://www.statisticshowto.datasciencecentral.com/cohens-kappa-statistic/</a></p>
<p>[4] <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.statisticshowto.datasciencecentral.com%2Ffleiss-kappa%2F" target="_blank" rel="noopener">https://www.statisticshowto.datasciencecentral.com/fleiss-kappa/</a></p>
<p>[5]  <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Famirziai%2Flearning%2Fblob%2Fmaster%2Fstatistics%2FInter-rater%20agreement%20kappas.ipynb%5D(https%3A%2F%2Fgithub.com%2Famirziai%2Flearning%2Fblob%2Fmaster%2Fstatistics%2FInter-rater" target="_blank" rel="noopener">[https://github.com/amirziai/learning/blob/master/statistics/Inter-rater%20agreement%20kappas.ipynb](https://github.com/amirziai/learning/blob/master/statistics/Inter-rater</a> agreement kappas.ipynb)</p>
<p>[6] <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fqq_31113079%2Farticle%2Fdetails%2F76216611" target="_blank" rel="noopener">https://blog.csdn.net/qq_31113079/article/details/76216611</a></p>
</blockquote>
<p>作者：Luuuuuua<br>链接：<a href="https://www.jianshu.com/p/f9c383b39859" target="_blank" rel="noopener">https://www.jianshu.com/p/f9c383b39859</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
  </entry>
  <entry>
    <title>阅读论文 tips</title>
    <url>/2020/05/29/%E9%98%85%E8%AF%BB%E8%AE%BA%E6%96%87-tips/</url>
    <content><![CDATA[<p>[TOC]</p>
<h4 id="快速阅读：划分结构层次"><a href="#快速阅读：划分结构层次" class="headerlink" title="快速阅读：划分结构层次"></a>快速阅读：划分结构层次</h4><p>对于快速阅读，一个小的技巧是图文浏览。因为一些好的论文必然是图文并茂，所以只要弄清楚论文中表格和图片的标题和注释，就能够获得这篇论文八、九成的信息。</p>
<p>读者在读论文的时候也应该要有逻辑，首先要清楚论文中的表达是否是我想要学习到的；其次，我能从论文中学到多少呢；最后，这篇论文的背景是什么——是什么样的背景让这篇论文变得重要和有趣。</p>
<h4 id="仔细阅读：批判思维"><a href="#仔细阅读：批判思维" class="headerlink" title="仔细阅读：批判思维"></a>仔细阅读：批判思维</h4><p>以评判性阅读开始，带着质疑的心态问问题。如果作者论文中声称解决了一个问题，那么你就要在心里问自己：<strong>论文是否正确、真正地解决了问题？</strong> <strong>作者论文中所用方法是否有局限性</strong>？如果<strong>所读的论文没有解决问题，那么我能解决么</strong>？我能采用<strong>比论文中更简单的方法解决么</strong>？所以，一旦进入仔细阅读的状态，要在读论文之前对自己说：这篇论文可能有问题，我要找出来。</p>
<h4 id="创造性阅读：积极思考"><a href="#创造性阅读：积极思考" class="headerlink" title="创造性阅读：积极思考"></a>创造性阅读：积极思考</h4><p>问自己：在我所读的论文中，作者有<strong>哪些点还没有想到</strong>？如果我现在做这项研究，我<strong>能做的新事情是什么</strong>？创造性的阅读需要<strong>把你所读的论文和其他相关的论文建立联系，从而产生一些新的想法</strong>，这些想法可以支撑你进行三个月到五个月的研究。</p>
<p>如果你真正想理解你所读的论文，那么就写一个摘要吧，最好做一个口头展示，这样你会发现，只有把东西写下来或者说出来才能真正深刻理解。如果你能做一个报告，那就更好了，因为做报告的时候，别人可以问你问题，这会强迫你理解所读的论文。</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gf9in4p85tj30f8088t92.jpg"></p>
<p>在做这个演讲之前，我曾经向我的同事、学生询问了关于论文阅读有哪些问题可以“问自己”，上面这张图片是一个总结，图片的上半部分是比较客观的问题，包括论文的核心观点是什么？主要的局限性是什么？代码和数据是不是可得的？论文的贡献是否有意义？论文中的实验是否足够好？</p>
<p>图片的下半部分是比较主观的问题，包括我错过了什么相关论文么？这对我的工作有何帮助么？这是一篇值得关注的论文么？这个研究领域的领头人是谁呢？其他的人对这篇论文有何看法呢？如果有机会见到作者，我应该问作者什么问题？</p>
<p>当你在阅读论文的时候如果能回答出上面列出的问题，我相信你会对你所读论文有非常深刻的理解。</p>
]]></content>
      <categories>
        <category>杂类</category>
      </categories>
      <tags>
        <tag>杂类</tag>
      </tags>
  </entry>
  <entry>
    <title>[调研] non-autoregressive neural machine translation</title>
    <url>/2021/03/24/%E8%B0%83%E7%A0%94-non-autoregressive-neural-machine-translation/</url>
    <content><![CDATA[<p>本篇对基于非自回归的机器翻译任务进行调研</p>
<h2 id="First-paper"><a href="#First-paper" class="headerlink" title="First paper"></a><strong style="color:blue;">First paper</strong></h2><p>Gu, J.; Bradbury, J.; Xiong, C.; Li, V. O.; and Socher, R. 2018. <strong>Non-autoregressive neural machine translation.</strong> In ICLR.</p>
<h2 id="Enhancing-the-decoder-inputs"><a href="#Enhancing-the-decoder-inputs" class="headerlink" title="Enhancing the decoder inputs"></a><strong style="color:blue;">Enhancing the decoder inputs</strong></h2><p>Bingzhen Wei, Mingxuan Wang, Hao Zhou, Junyang Lin, and Xu Sun. 2019. <strong>Imitation learning for nonautoregressive neural machine translation.</strong> In ACL.</p>
<p>Wang, Y.; Tian, F.; He, D.; Qin, T.; Zhai, C.; and Liu, T.-Y. 2019b. <strong>Non-autoregressive machine translation with auxiliary regularization.</strong> In AAAI.</p>
<p>Guo, J.; Tan, X.; He, D.; Qin, T.; Xu, L.; and Liu, T.-Y. 2019. <strong>Non-autoregressive neural machine translation with enhanced decoder input.</strong> In AAAI.</p>
<p>Lee, J.; Mansimov, E.; and Cho, K. 2018. <strong>Deterministic nonautoregressive neural sequence modeling by iterative refinement.</strong> In EMNLP.</p>
<h2 id="Modeling-the-dependencies-among-target-outputs"><a href="#Modeling-the-dependencies-among-target-outputs" class="headerlink" title="Modeling the dependencies among target outputs"></a><strong style="color:blue;">Modeling the dependencies among target outputs</strong></h2><p>Ghazvininejad, M.; Levy, O.; Liu, Y.; and Zettlemoyer, L. 2019. <strong>Mask-predict: Parallel decoding of conditional masked language models.</strong> In EMNLP-IJCNLP.</p>
<p>Lihua Qian, Hao Zhou, Yu Bao, Mingxuan Wang, Lin Qiu, Weinan Zhang, Yong Yu, and Lei Li. 2020. <strong>Glancing transformer for non-autoregressive neural machine translation.</strong> arXiv preprint arXiv:2008.07905.</p>
<p>Gu, J.;Wang, C.; and Zhao, J. 2019. <strong>Levenshtein transformer.</strong> In Advances in NIPS.</p>
<p>Mansimov, E.; Wang, A.; and Cho, K. 2019. <strong>A generalized framework of sequence generation with application to undirected sequence models.</strong> arXiv preprint arXiv:1905.12790 .</p>
<ul>
<li><p><strong style="color:blue;">model the target-side dependencies in the latent space</strong></p>
<p>Non-Autoregressive Translation by Learning Target Categorical Codes. NAACL-2021</p>
<p><a href="https://mp.weixin.qq.com/s/qDN1ROXjkVI6wdTHa18YlA" target="_blank" rel="noopener">NAACL2021论文：基于隐式类别建模的非自回归式翻译</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>谱聚类</title>
    <url>/2019/04/08/%E8%B0%B1%E8%81%9A%E7%B1%BB/</url>
    <content><![CDATA[<ul>
<li>先占位置</li>
<li><a href="https://www.cnblogs.com/pinard/p/6221564.html" target="_blank" rel="noopener">参考某博客</a>  </li>
<li><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.SpectralClustering.html#sklearn.cluster.SpectralClustering" target="_blank" rel="noopener">sklearn.cluster.SpectralClustering</a></p>
<ul>
<li>References<br>Normalized cuts and image segmentation, 2000 Jianbo Shi, Jitendra Malik <a href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.160.2324" target="_blank" rel="noopener">http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.160.2324</a><br>A Tutorial on Spectral Clustering, 2007 Ulrike von Luxburg <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.165.9323" target="_blank" rel="noopener">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.165.9323</a><br>Multiclass spectral clustering, 2003 Stella X. Yu, Jianbo Shi <a href="http://www1.icsi.berkeley.edu/~stellayu/publication/doc/2003kwayICCV.pdf" target="_blank" rel="noopener">http://www1.icsi.berkeley.edu/~stellayu/publication/doc/2003kwayICCV.pdf</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>图卷积网络</category>
      </categories>
      <tags>
        <tag>图卷积网络</tag>
      </tags>
  </entry>
  <entry>
    <title>非极大值抑制(NMS)</title>
    <url>/2019/03/20/%E9%9D%9E%E6%9E%81%E5%A4%A7%E5%80%BC%E6%8A%91%E5%88%B6-NMS/</url>
    <content><![CDATA[<p>非极大值抑制（Non-maximum suppression，NMS）是一种去除非极大值的算法，常用于计算机视觉中的边缘检测、物体识别等。</p>
<h2 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h2><p>给出一张图片和上面许多物体检测的候选框（即每个框可能都代表某种物体），但是这些框很可能有互相重叠的部分，我们要做的就是只保留最优的框。假设有N个框，每个框被分类器计算得到的分数为Si, 1&lt;=i&lt;=N。</p>
<p>0、建造一个存放待处理候选框的集合H，初始化为包含全部N个框；</p>
<p>建造一个存放最优框的集合M，初始化为空集。</p>
<p>1、将所有集合 H 中的框进行排序，选出分数最高的框 m，从集合 H 移到集合 M；</p>
<p>2、遍历集合 H 中的框，分别与框 m 计算交并比（Interection-over-union，IoU），如果高于某个阈值（一般为0~0.5），则认为此框与 m 重叠，将此框从集合 H 中去除。</p>
<p>3、回到第1步进行迭代，直到集合 H 为空。集合 M 中的框为我们所需。</p>
<h2 id="需要优化的参数："><a href="#需要优化的参数：" class="headerlink" title="需要优化的参数："></a>需要优化的参数：</h2><p>IoU 的阈值是一个可优化的参数，一般范围为0~0.5，可以使用交叉验证来选择最优的参数。<br>比如人脸识别的一个例子：</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g19dbcocjfj30gw07kdmg.jpg"></p>
<p>已经识别出了 5 个候选框，但是我们只需要最后保留两个人脸。</p>
<p>首先选出分数最大的框（0.98），然后遍历剩余框，计算 IoU，会发现露丝脸上的两个绿框都和 0.98 的框重叠率很大，都要去除。</p>
<p>然后只剩下杰克脸上两个框，选出最大框（0.81），然后遍历剩余框（只剩下0.67这一个了），发现0.67这个框与 0.81 的 IoU 也很大，去除。</p>
<p>至此所有框处理完毕，算法结果：</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g19dbr3kk4j30gw07kdmi.jpg"></p>
<p>（图片来自<a href="https://blog.csdn.net/shuzfan/article/details/52711706）" target="_blank" rel="noopener">https://blog.csdn.net/shuzfan/article/details/52711706）</a></p>
<h2 id="添加-by-yaya"><a href="#添加-by-yaya" class="headerlink" title="添加 by yaya:"></a>添加 by yaya:</h2><ul>
<li>在faster r-cnn中，得到了pred_boxes以及cls_boxes 之后，分别对每个类的objects进行NMS。（这里多说一句：使用了class_agnostic=false，即对每个bbox都有N个类别的得分）</li>
<li>首先得到得分最高的一个object bbox，之后，进行IOU分析，若IoU大于阈值，则剔除，否则保留。</li>
<li>对这一个得分最高的bbox分析完之后，再分析下一个次高得分的，并剔除所有与它IoU值大于阈值的object。一直这样分析，直到剩下的object之间的IoU值两两之间均小于阈值。</li>
<li>即可得到该类对应的bbox，且不交叠。</li>
<li>下一循环分析下一个类<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, imdb.num_classes):</span><br><span class="line">    inds = torch.nonzero(scores[:,j]&gt;thresh).view(<span class="number">-1</span>) </span><br><span class="line">    <span class="comment"># thresh = 0   inds.shape = torch.Size([300])</span></span><br><span class="line">    <span class="comment"># if there is det</span></span><br><span class="line">    <span class="keyword">if</span> inds.numel() &gt; <span class="number">0</span>:</span><br><span class="line">      cls_scores = scores[:,j][inds] <span class="comment"># 某个类在300个object上的得分</span></span><br><span class="line">      _, order = torch.sort(cls_scores, <span class="number">0</span>, <span class="literal">True</span>) <span class="comment"># 某个类在这300个object上的得分的高低排序</span></span><br><span class="line">      <span class="keyword">if</span> args.class_agnostic:</span><br><span class="line">        cls_boxes = pred_boxes[inds, :]</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        cls_boxes = pred_boxes[inds][:, j * <span class="number">4</span>:(j + <span class="number">1</span>) * <span class="number">4</span>]  <span class="comment"># 某个类对应的predict bbox</span></span><br><span class="line">      </span><br><span class="line">      cls_dets = torch.cat((cls_boxes, cls_scores.unsqueeze(<span class="number">1</span>)), <span class="number">1</span>)  <span class="comment"># torch.Size([300, 5])</span></span><br><span class="line">      <span class="comment"># cls_dets = torch.cat((cls_boxes, cls_scores), 1)</span></span><br><span class="line">      cls_dets = cls_dets[order]  <span class="comment"># torch.Size([300, 5]) 排了序之后的cat</span></span><br><span class="line">      keep = nms(cls_dets, cfg.TEST.NMS)  <span class="comment"># torch.Size([91, 1])</span></span><br><span class="line">      cls_dets = cls_dets[keep.view(<span class="number">-1</span>).long()]  <span class="comment"># torch.Size([91, 5])</span></span><br><span class="line">      <span class="keyword">if</span> vis:</span><br><span class="line">        im2show = vis_detections(im2show, imdb.classes[j], cls_dets.cpu().numpy(), <span class="number">0.3</span>)</span><br><span class="line">      all_boxes[j][i] = cls_dets.cpu().numpy()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      all_boxes[j][i] = empty_array</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>作者：HappyRocking<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/HappyRocking/article/details/79970627" target="_blank" rel="noopener">https://blog.csdn.net/HappyRocking/article/details/79970627</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>
]]></content>
      <categories>
        <category>目标检测</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>目标检测</tag>
      </tags>
  </entry>
</search>
