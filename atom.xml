<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ShiYaya</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-25T10:09:29.973Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ShiYaya</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Memory-Attended Recurrent Network for Video Captioning</title>
    <link href="http://yoursite.com/2019/07/25/Memory-Attended-Recurrent-Network-for-Video-Captioning/"/>
    <id>http://yoursite.com/2019/07/25/Memory-Attended-Recurrent-Network-for-Video-Captioning/</id>
    <published>2019-07-25T08:28:58.000Z</published>
    <updated>2019-07-25T10:09:29.973Z</updated>
    
    <content type="html"><![CDATA[<h3 id="词频"><a href="#词频" class="headerlink" title="词频"></a>词频</h3><p>“&gt; =3”的保留</p><p>MSR-VTT :11K   MSVD:4K</p><h3 id="Attention-Decoder"><a href="#Attention-Decoder" class="headerlink" title="Attention Decoder"></a>Attention Decoder</h3><ul><li><p>采用SA-LSTM的结构</p></li><li><p>细节：</p><ul><li><p>由于需要对frames_feature ==(L帧)==  与 C3D_feature ==（L帧 -&gt; L/16个特征向量）== 都进行attention，这里进行了共享attention，好处：   <br>  （1）将2D 和 3D 特征映射到相似的特征空间  <br></p><p>（2）像是一种正则化，减少了参数，避免过拟合  <br>  </p></li><li><p>降维，将2D 和 3D 的2048维度的特征，降维到512</p></li></ul></li></ul><h3 id="Attended-Memory-Decoder"><a href="#Attended-Memory-Decoder" class="headerlink" title="Attended Memory Decoder"></a>Attended Memory Decoder</h3><ul><li><p>当前模型的不足：</p><ul><li>现有的模型在生成word的时候，只依赖于当前video的信息，而不能依赖于那些，出现过该单词的其他video的信息</li><li>生成下一个单词，仅依赖于video信息和当前单词，没有建模相邻两个单词之间的兼容性（没看懂）</li></ul></li><li><p>具体的memeory设计详见论文</p></li></ul><h3 id="Attention-Coherent-Loss-AC-Loss"><a href="#Attention-Coherent-Loss-AC-Loss" class="headerlink" title="Attention-Coherent Loss (AC Loss)"></a>Attention-Coherent Loss (AC Loss)</h3><ul><li>将C3D 输入的L帧作为1个time interval,希望对一个time interval 中的frames feature 的attention系数值相近</li><li>仅对frames_features 的attention 系数，计算这样的一个loss</li></ul><img src="https://i.loli.net/2019/07/25/5d397582d36f640160.png" alt="搜狗截图20190725172350.png" title="搜狗截图20190725172350.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;词频&quot;&gt;&lt;a href=&quot;#词频&quot; class=&quot;headerlink&quot; title=&quot;词频&quot;&gt;&lt;/a&gt;词频&lt;/h3&gt;&lt;p&gt;“&amp;gt; =3”的保留&lt;/p&gt;
&lt;p&gt;MSR-VTT :11K   MSVD:4K&lt;/p&gt;
&lt;h3 id=&quot;Attention-Decod
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深度层次化图卷积神经网络</title>
    <link href="http://yoursite.com/2019/07/25/%E6%B7%B1%E5%BA%A6%E5%B1%82%E6%AC%A1%E5%8C%96%E5%9B%BE%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2019/07/25/深度层次化图卷积神经网络/</id>
    <published>2019-07-25T03:53:40.000Z</published>
    <updated>2019-07-25T03:54:41.406Z</updated>
    
    <content type="html"><![CDATA[<h3 id="池化-可以扩大感受野"><a href="#池化-可以扩大感受野" class="headerlink" title="池化 可以扩大感受野"></a>池化 可以扩大感受野</h3><h3 id="GCN（两层）-node-classification"><a href="#GCN（两层）-node-classification" class="headerlink" title="GCN（两层）( node classification )"></a>GCN（两层）( node classification )</h3><ul><li>基于邻域聚合的</li><li><code>H= AXW</code><h3 id="deeper-insight-into-graph-convolutional-networks-for-semi-supervised-learning"><a href="#deeper-insight-into-graph-convolutional-networks-for-semi-supervised-learning" class="headerlink" title="deeper insight into graph convolutional networks for semi-supervised learning"></a>deeper insight into graph convolutional networks for semi-supervised learning</h3></li><li>GCN层数多效果不好：特征之间过于平滑<h3 id="GAT-（两层）-GraphSAGE"><a href="#GAT-（两层）-GraphSAGE" class="headerlink" title="GAT （两层）  GraphSAGE"></a>GAT （两层）  GraphSAGE</h3></li><li>两层，感受野小，2-hop</li></ul><h3 id="Hierarchical-Graph-Representation-Learning-with-Differentiable-Pooling-（graph-classification）"><a href="#Hierarchical-Graph-Representation-Learning-with-Differentiable-Pooling-（graph-classification）" class="headerlink" title="Hierarchical Graph Representation Learning with Differentiable Pooling （graph classification）"></a>Hierarchical Graph Representation Learning with Differentiable Pooling （graph classification）</h3><ol><li>优点</li></ol><ul><li>简单的两层GCN 的感受野只有2-hop</li><li>但是如果GCN- clusterpooling，把相同的节点聚类在一起，再进行GCN，那么感受野就会扩大，</li><li>捕捉到了graph 中的Hierarchical  structure</li></ul><ol start="2"><li>缺点</li></ol><ul><li>但是由于他自身网络设计的，一次池化，就需要一个全连接层，使得想要设计一个很深的网络，就需要很多的参数，容易过拟合</li><li>很难去训练pooling matrix，这是由于不能保证，经过这一个池化层，就可以把相似的objects聚类到一起。本文作者在每层都增加了两个正则项</li></ul><h3 id="Hierarchical-Graph-Convolutional-Networks-for-Semi-supervised-Node-Classification-9层-IJCAI-2019"><a href="#Hierarchical-Graph-Convolutional-Networks-for-Semi-supervised-Node-Classification-9层-IJCAI-2019" class="headerlink" title="Hierarchical Graph Convolutional Networks for Semi-supervised Node Classification ( 9层 ) ( IJCAI 2019)"></a>Hierarchical Graph Convolutional Networks for Semi-supervised Node Classification ( 9层 ) ( IJCAI 2019)</h3><ul><li>粗化 coarsening</li><li>结构一致粗化</li><li>结构相似粗化</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;池化-可以扩大感受野&quot;&gt;&lt;a href=&quot;#池化-可以扩大感受野&quot; class=&quot;headerlink&quot; title=&quot;池化 可以扩大感受野&quot;&gt;&lt;/a&gt;池化 可以扩大感受野&lt;/h3&gt;&lt;h3 id=&quot;GCN（两层）-node-classification&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="图卷积网络" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="图卷积网络" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Hierarchical Global-Local Temporal Modeling for Video Captioning</title>
    <link href="http://yoursite.com/2019/07/23/Hierarchical-Global-Local-Temporal-Modeling-for-Video-Captioning/"/>
    <id>http://yoursite.com/2019/07/23/Hierarchical-Global-Local-Temporal-Modeling-for-Video-Captioning/</id>
    <published>2019-07-23T06:44:42.000Z</published>
    <updated>2019-07-23T10:17:31.275Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><ul><li>使用object features能够更好地检测出action 和 关键的Object</li></ul><h3 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h3><ul><li><p>两个LSTM层</p></li><li><p>global : frame features and C3D features</p></li><li><p>local : objects </p></li></ul><h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><ul><li><p>Top Down decoder</p><ul><li>Bottom LSTM：mean of regions</li><li>Top LSTM : attention of  regions</li></ul></li><li><p>Grounded video description的decoder：</p><ul><li>Bottom LSTM：mean of  fc+motion</li><li>Top LSTM: attention of  regions and attention of  fc+motion</li></ul></li><li><p>==Hierarchical Global-Local Temporal Modeling（本文） ==</p><ul><li>Bottom LSTM：attention of fc+motion</li><li>Top LSTM: attention of regions</li><li>本文不一样的地方是在Bottom LSTM的输入也加入了attention</li></ul></li></ul><h3 id="提取特征"><a href="#提取特征" class="headerlink" title="提取特征"></a>提取特征</h3><ul><li>等间隔提取帧的特征</li><li>由于帧之间的间隔，会使得没有运动信息，所以再使用C3D来补充运动信息（以该该为中心，提取16帧，输入C3D中）</li><li>object features: faster rcnn 去掉rcnn部分的类别/分数预测，提取head_to_heal处的pooled_feats</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Motivation&quot;&gt;&lt;a href=&quot;#Motivation&quot; class=&quot;headerlink&quot; title=&quot;Motivation&quot;&gt;&lt;/a&gt;Motivation&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;使用object features能够更好地检测出action 
      
    
    </summary>
    
    
      <category term="视频描述" scheme="http://yoursite.com/tags/%E8%A7%86%E9%A2%91%E6%8F%8F%E8%BF%B0/"/>
    
      <category term="[object Object]" scheme="http://yoursite.com/tags/object-Object/"/>
    
  </entry>
  
  <entry>
    <title>VATEX: a video caption dataset</title>
    <link href="http://yoursite.com/2019/07/23/VATEX-a-video-caption-dataset/"/>
    <id>http://yoursite.com/2019/07/23/VATEX-a-video-caption-dataset/</id>
    <published>2019-07-23T01:20:22.000Z</published>
    <updated>2019-07-23T01:43:28.289Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VATEX数据集"><a href="#VATEX数据集" class="headerlink" title="VATEX数据集"></a>VATEX数据集</h2><ul><li>一个新的数据集，41269个video， 时长大约10s, 每个video有10个中文，10个英文，同时这10个之中，中英文之间有5个是两两配对的</li><li>提出了两个新的任务：（1）一个encoder-decoder模型，在两种语言之间共享参数，即希望一个模型，可以得到两种语言的描述。（2）提出了一种新的机器翻译任务，即当进行中英文的机器翻译任务时，可以添加视频的视觉特征作为辅助信息</li><li>数据集的来源：来自于kinetics的validation dataset, 然后它们找人进行了caption的标注。它们将这41269个video 分成了4部分，train, validation, public test, secret test(不公开，用于比赛)</li></ul><h3 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h3><ul><li>encoder-decoder 就是 TopDown的形式</li><li>视觉特征：通过I3D（在kinetics train上预训练且不再fine-tune）来提取视觉特征，应该是把video分成了很多segments，对每个segment都提取I3D的特征，每个特征作为vi。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;VATEX数据集&quot;&gt;&lt;a href=&quot;#VATEX数据集&quot; class=&quot;headerlink&quot; title=&quot;VATEX数据集&quot;&gt;&lt;/a&gt;VATEX数据集&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一个新的数据集，41269个video， 时长大约10s, 每个video有10
      
    
    </summary>
    
      <category term="视频描述" scheme="http://yoursite.com/categories/%E8%A7%86%E9%A2%91%E6%8F%8F%E8%BF%B0/"/>
    
    
      <category term="视频描述" scheme="http://yoursite.com/tags/%E8%A7%86%E9%A2%91%E6%8F%8F%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>faster_rcnn various box head</title>
    <link href="http://yoursite.com/2019/07/22/faster-rcnn-various-box-head/"/>
    <id>http://yoursite.com/2019/07/22/faster-rcnn-various-box-head/</id>
    <published>2019-07-22T02:26:23.000Z</published>
    <updated>2019-07-22T02:35:54.643Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Ground-video-description"><a href="#Ground-video-description" class="headerlink" title="Ground video description"></a>Ground video description</h4><ul><li>在阅读这篇论文的时候，由于作者提取了objects，说是提取的fc6的特征，但是不太懂是哪里，在issue中，他说是借鉴这里的代码，于是乎，我就来看了看<a href="https://github.com/facebookresearch/Detectron/blob/8170b25b425967f8f1c7d715bea3c5b8d9536cd8/detectron/modeling/fast_rcnn_heads.py" target="_blank" rel="noopener">box_head</a>，哈哈哈哈哈哈 </li><li>fc6 是 box_head里边的，box_head就是 类似于faster_rcnn中的_head_to_tail</li></ul><h4 id="那么box-head-是干嘛的？"><a href="#那么box-head-是干嘛的？" class="headerlink" title="那么box_head 是干嘛的？"></a>那么box_head 是干嘛的？</h4><ul><li>由于经过roi_pooling 之后得到的是 7*7的一个pooled_feats，还要 ==再进行池化或者拍平，或者再进行全连接层等== ，以便于后边的预测，分类任务。</li></ul><ul><li><p>faster_rcnn 中的box_head就是 resnet layer4</p></li><li><p>mmdetection 中的 faster_rcnn 现将7*7  排成49 ，再送入两个全连接层，可以将这两个全连接层命名为fc6, fc7.   完美!！!！</p></li><li><p>这里展示了各种各样的 box_head</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Ground-video-description&quot;&gt;&lt;a href=&quot;#Ground-video-description&quot; class=&quot;headerlink&quot; title=&quot;Ground video description&quot;&gt;&lt;/a&gt;Ground video d
      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
    
      <category term="目标检测" scheme="http://yoursite.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>mmdetection的configs中的各项参数具体解释</title>
    <link href="http://yoursite.com/2019/07/21/mmdetection%E7%9A%84configs%E4%B8%AD%E7%9A%84%E5%90%84%E9%A1%B9%E5%8F%82%E6%95%B0%E5%85%B7%E4%BD%93%E8%A7%A3%E9%87%8A/"/>
    <id>http://yoursite.com/2019/07/21/mmdetection的configs中的各项参数具体解释/</id>
    <published>2019-07-21T11:45:54.000Z</published>
    <updated>2019-07-21T11:48:45.207Z</updated>
    
    <content type="html"><![CDATA[<p>一、简介<br>在使用mmdetection对模型进行调优的过程中总会遇到很多参数的问题，不知道参数在代码中是什么作用，会对训练产生怎样的影响，这里我以faster_rcnn_r50_fpn_1x.py和cascade_rcnn_r50_fpn_1x.py为例，简单介绍一下mmdetection中的各项参数含义</p><p>二、faster_rcnn_r50_fpn_1x.py配置文件<br>首先介绍一下这个配置文件所描述的框架，它是基于resnet50的backbone，有着5个fpn特征层的faster-RCNN目标检测网络，训练迭代次数为标准的12次epoch，下面逐条解释其含义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># model settings</span></span><br><span class="line">model = dict(</span><br><span class="line">type=<span class="string">'FasterRCNN'</span>,                         <span class="comment"># model类型</span></span><br><span class="line">    pretrained=<span class="string">'modelzoo://resnet50'</span>,          <span class="comment"># 预训练模型：imagenet-resnet50</span></span><br><span class="line">    backbone=dict(</span><br><span class="line">        type=<span class="string">'ResNet'</span>,                         <span class="comment"># backbone类型</span></span><br><span class="line">        depth=<span class="number">50</span>,                              <span class="comment"># 网络层数</span></span><br><span class="line">        num_stages=<span class="number">4</span>,                          <span class="comment"># resnet的stage数量</span></span><br><span class="line">        out_indices=(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),              <span class="comment"># 输出的stage的序号</span></span><br><span class="line">        frozen_stages=<span class="number">1</span>,                       <span class="comment"># 冻结的stage数量，即该stage不更新参数，-1表示所有的stage都更新参数</span></span><br><span class="line">        style=<span class="string">'pytorch'</span>),                      <span class="comment"># 网络风格：如果设置pytorch，则stride为2的层是conv3x3的卷积层；如果设置caffe，则stride为2的层是第一个conv1x1的卷积层</span></span><br><span class="line">    neck=dict(</span><br><span class="line">        type=<span class="string">'FPN'</span>,                            <span class="comment"># neck类型</span></span><br><span class="line">        in_channels=[<span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>, <span class="number">2048</span>],    <span class="comment"># 输入的各个stage的通道数</span></span><br><span class="line">        out_channels=<span class="number">256</span>,                      <span class="comment"># 输出的特征层的通道数</span></span><br><span class="line">        num_outs=<span class="number">5</span>),                           <span class="comment"># 输出的特征层的数量</span></span><br><span class="line">    rpn_head=dict(</span><br><span class="line">        type=<span class="string">'RPNHead'</span>,                        <span class="comment"># RPN网络类型</span></span><br><span class="line">        in_channels=<span class="number">256</span>,                       <span class="comment"># RPN网络的输入通道数</span></span><br><span class="line">        feat_channels=<span class="number">256</span>,                     <span class="comment"># 特征层的通道数</span></span><br><span class="line">        anchor_scales=[<span class="number">8</span>],                     <span class="comment"># 生成的anchor的baselen，baselen = sqrt(w*h)，w和h为anchor的宽和高</span></span><br><span class="line">        anchor_ratios=[<span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">2.0</span>],         <span class="comment"># anchor的宽高比</span></span><br><span class="line">        anchor_strides=[<span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>],     <span class="comment"># 在每个特征层上的anchor的步长（对应于原图）</span></span><br><span class="line">        target_means=[<span class="number">.0</span>, <span class="number">.0</span>, <span class="number">.0</span>, <span class="number">.0</span>],         <span class="comment"># 均值</span></span><br><span class="line">        target_stds=[<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>],      <span class="comment"># 方差</span></span><br><span class="line">        use_sigmoid_cls=<span class="literal">True</span>),                 <span class="comment"># 是否使用sigmoid来进行分类，如果False则使用softmax来分类</span></span><br><span class="line">    bbox_roi_extractor=dict(</span><br><span class="line">        type=<span class="string">'SingleRoIExtractor'</span>,                                   <span class="comment"># RoIExtractor类型</span></span><br><span class="line">        roi_layer=dict(type=<span class="string">'RoIAlign'</span>, out_size=<span class="number">7</span>, sample_num=<span class="number">2</span>),   <span class="comment"># ROI具体参数：ROI类型为ROIalign，输出尺寸为7，sample数为2</span></span><br><span class="line">        out_channels=<span class="number">256</span>,                                            <span class="comment"># 输出通道数</span></span><br><span class="line">        featmap_strides=[<span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>]),                             <span class="comment"># 特征图的步长</span></span><br><span class="line">    bbox_head=dict(</span><br><span class="line">        type=<span class="string">'SharedFCBBoxHead'</span>,                     <span class="comment"># 全连接层类型</span></span><br><span class="line">        num_fcs=<span class="number">2</span>,                                   <span class="comment"># 全连接层数量</span></span><br><span class="line">        in_channels=<span class="number">256</span>,                             <span class="comment"># 输入通道数</span></span><br><span class="line">        fc_out_channels=<span class="number">1024</span>,                        <span class="comment"># 输出通道数</span></span><br><span class="line">        roi_feat_size=<span class="number">7</span>,                             <span class="comment"># ROI特征层尺寸</span></span><br><span class="line">        num_classes=<span class="number">81</span>,                              <span class="comment"># 分类器的类别数量+1，+1是因为多了一个背景的类别</span></span><br><span class="line">        target_means=[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],               <span class="comment"># 均值</span></span><br><span class="line">        target_stds=[<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.2</span>],            <span class="comment"># 方差</span></span><br><span class="line">        reg_class_agnostic=<span class="literal">False</span>))                   <span class="comment"># 是否采用class_agnostic的方式来预测，class_agnostic表示输出bbox时只考虑其是否为前景，后续分类的时候再根据该bbox在网络中的类别得分来分类，也就是说一个框可以对应多个类别</span></span><br><span class="line"><span class="comment"># model training and testing settings</span></span><br><span class="line">train_cfg = dict(</span><br><span class="line">    rpn=dict(</span><br><span class="line">        assigner=dict(</span><br><span class="line">            type=<span class="string">'MaxIoUAssigner'</span>,            <span class="comment"># RPN网络的正负样本划分</span></span><br><span class="line">            pos_iou_thr=<span class="number">0.7</span>,                  <span class="comment"># 正样本的iou阈值</span></span><br><span class="line">            neg_iou_thr=<span class="number">0.3</span>,                  <span class="comment"># 负样本的iou阈值</span></span><br><span class="line">            min_pos_iou=<span class="number">0.3</span>,                  <span class="comment"># 正样本的iou最小值。如果assign给ground truth的anchors中最大的IOU低于0.3，则忽略所有的anchors，否则保留最大IOU的anchor</span></span><br><span class="line">            ignore_iof_thr=<span class="number">-1</span>),               <span class="comment"># 忽略bbox的阈值，当ground truth中包含需要忽略的bbox时使用，-1表示不忽略</span></span><br><span class="line">        sampler=dict(</span><br><span class="line">            type=<span class="string">'RandomSampler'</span>,             <span class="comment"># 正负样本提取器类型</span></span><br><span class="line">            num=<span class="number">256</span>,                          <span class="comment"># 需提取的正负样本数量</span></span><br><span class="line">            pos_fraction=<span class="number">0.5</span>,                 <span class="comment"># 正样本比例</span></span><br><span class="line">            neg_pos_ub=<span class="number">-1</span>,                    <span class="comment"># 最大负样本比例，大于该比例的负样本忽略，-1表示不忽略</span></span><br><span class="line">            add_gt_as_proposals=<span class="literal">False</span>),       <span class="comment"># 把ground truth加入proposal作为正样本</span></span><br><span class="line">        allowed_border=<span class="number">0</span>,                     <span class="comment"># 允许在bbox周围外扩一定的像素</span></span><br><span class="line">        pos_weight=<span class="number">-1</span>,                        <span class="comment"># 正样本权重，-1表示不改变原始的权重</span></span><br><span class="line">        smoothl1_beta=<span class="number">1</span> / <span class="number">9.0</span>,                <span class="comment"># 平滑L1系数</span></span><br><span class="line">        debug=<span class="literal">False</span>),                         <span class="comment"># debug模式</span></span><br><span class="line">    rcnn=dict(</span><br><span class="line">        assigner=dict(</span><br><span class="line">            type=<span class="string">'MaxIoUAssigner'</span>,            <span class="comment"># RCNN网络正负样本划分</span></span><br><span class="line">            pos_iou_thr=<span class="number">0.5</span>,                  <span class="comment"># 正样本的iou阈值</span></span><br><span class="line">            neg_iou_thr=<span class="number">0.5</span>,                  <span class="comment"># 负样本的iou阈值</span></span><br><span class="line">            min_pos_iou=<span class="number">0.5</span>,                  <span class="comment"># 正样本的iou最小值。如果assign给ground truth的anchors中最大的IOU低于0.3，则忽略所有的anchors，否则保留最大IOU的anchor</span></span><br><span class="line">            ignore_iof_thr=<span class="number">-1</span>),               <span class="comment"># 忽略bbox的阈值，当ground truth中包含需要忽略的bbox时使用，-1表示不忽略</span></span><br><span class="line">        sampler=dict(</span><br><span class="line">            type=<span class="string">'RandomSampler'</span>,             <span class="comment"># 正负样本提取器类型</span></span><br><span class="line">            num=<span class="number">512</span>,                          <span class="comment"># 需提取的正负样本数量</span></span><br><span class="line">            pos_fraction=<span class="number">0.25</span>,                <span class="comment"># 正样本比例</span></span><br><span class="line">            neg_pos_ub=<span class="number">-1</span>,                    <span class="comment"># 最大负样本比例，大于该比例的负样本忽略，-1表示不忽略</span></span><br><span class="line">            add_gt_as_proposals=<span class="literal">True</span>),        <span class="comment"># 把ground truth加入proposal作为正样本</span></span><br><span class="line">        pos_weight=<span class="number">-1</span>,                        <span class="comment"># 正样本权重，-1表示不改变原始的权重</span></span><br><span class="line">        debug=<span class="literal">False</span>))                         <span class="comment"># debug模式</span></span><br><span class="line">test_cfg = dict(</span><br><span class="line">    rpn=dict(                                 <span class="comment"># 推断时的RPN参数</span></span><br><span class="line">        nms_across_levels=<span class="literal">False</span>,              <span class="comment"># 在所有的fpn层内做nms</span></span><br><span class="line">        nms_pre=<span class="number">2000</span>,                         <span class="comment"># 在nms之前保留的的得分最高的proposal数量</span></span><br><span class="line">        nms_post=<span class="number">2000</span>,                        <span class="comment"># 在nms之后保留的的得分最高的proposal数量</span></span><br><span class="line">        max_num=<span class="number">2000</span>,                         <span class="comment"># 在后处理完成之后保留的proposal数量</span></span><br><span class="line">        nms_thr=<span class="number">0.7</span>,                          <span class="comment"># nms阈值</span></span><br><span class="line">        min_bbox_size=<span class="number">0</span>),                     <span class="comment"># 最小bbox尺寸</span></span><br><span class="line">    rcnn=dict(</span><br><span class="line">        score_thr=<span class="number">0.05</span>, nms=dict(type=<span class="string">'nms'</span>, iou_thr=<span class="number">0.5</span>), max_per_img=<span class="number">100</span>)   <span class="comment"># max_per_img表示最终输出的det bbox数量</span></span><br><span class="line">    <span class="comment"># soft-nms is also supported for rcnn testing</span></span><br><span class="line">    <span class="comment"># e.g., nms=dict(type='soft_nms', iou_thr=0.5, min_score=0.05)            # soft_nms参数</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># dataset settings</span></span><br><span class="line">dataset_type = <span class="string">'CocoDataset'</span>                <span class="comment"># 数据集类型</span></span><br><span class="line">data_root = <span class="string">'data/coco/'</span>                    <span class="comment"># 数据集根目录</span></span><br><span class="line">img_norm_cfg = dict(</span><br><span class="line">    mean=[<span class="number">123.675</span>, <span class="number">116.28</span>, <span class="number">103.53</span>], std=[<span class="number">58.395</span>, <span class="number">57.12</span>, <span class="number">57.375</span>], to_rgb=<span class="literal">True</span>)   <span class="comment"># 输入图像初始化，减去均值mean并处以方差std，to_rgb表示将bgr转为rgb</span></span><br><span class="line">data = dict(</span><br><span class="line">    imgs_per_gpu=<span class="number">2</span>,                <span class="comment"># 每个gpu计算的图像数量</span></span><br><span class="line">    workers_per_gpu=<span class="number">2</span>,             <span class="comment"># 每个gpu分配的线程数</span></span><br><span class="line">    train=dict(</span><br><span class="line">        type=dataset_type,                                                 <span class="comment"># 数据集类型</span></span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/instances_train2017.json'</span>,       <span class="comment"># 数据集annotation路径</span></span><br><span class="line">        img_prefix=data_root + <span class="string">'train2017/'</span>,                               <span class="comment"># 数据集的图片路径</span></span><br><span class="line">        img_scale=(<span class="number">1333</span>, <span class="number">800</span>),                                             <span class="comment"># 输入图像尺寸，最大边1333，最小边800</span></span><br><span class="line">        img_norm_cfg=img_norm_cfg,                                         <span class="comment"># 图像初始化参数</span></span><br><span class="line">        size_divisor=<span class="number">32</span>,                                                   <span class="comment"># 对图像进行resize时的最小单位，32表示所有的图像都会被resize成32的倍数</span></span><br><span class="line">        flip_ratio=<span class="number">0.5</span>,                                                    <span class="comment"># 图像的随机左右翻转的概率</span></span><br><span class="line">        with_mask=<span class="literal">False</span>,                                                   <span class="comment"># 训练时附带mask</span></span><br><span class="line">        with_crowd=<span class="literal">True</span>,                                                   <span class="comment"># 训练时附带difficult的样本</span></span><br><span class="line">        with_label=<span class="literal">True</span>),                                                  <span class="comment"># 训练时附带label</span></span><br><span class="line">    val=dict(</span><br><span class="line">        type=dataset_type,                                                 <span class="comment"># 同上</span></span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/instances_val2017.json'</span>,         <span class="comment"># 同上</span></span><br><span class="line">        img_prefix=data_root + <span class="string">'val2017/'</span>,                                 <span class="comment"># 同上</span></span><br><span class="line">        img_scale=(<span class="number">1333</span>, <span class="number">800</span>),                                             <span class="comment"># 同上</span></span><br><span class="line">        img_norm_cfg=img_norm_cfg,                                         <span class="comment"># 同上</span></span><br><span class="line">        size_divisor=<span class="number">32</span>,                                                   <span class="comment"># 同上</span></span><br><span class="line">        flip_ratio=<span class="number">0</span>,                                                      <span class="comment"># 同上</span></span><br><span class="line">        with_mask=<span class="literal">False</span>,                                                   <span class="comment"># 同上</span></span><br><span class="line">        with_crowd=<span class="literal">True</span>,                                                   <span class="comment"># 同上</span></span><br><span class="line">        with_label=<span class="literal">True</span>),                                                  <span class="comment"># 同上</span></span><br><span class="line">    test=dict(</span><br><span class="line">        type=dataset_type,                                                 <span class="comment"># 同上</span></span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/instances_val2017.json'</span>,         <span class="comment"># 同上</span></span><br><span class="line">        img_prefix=data_root + <span class="string">'val2017/'</span>,                                 <span class="comment"># 同上</span></span><br><span class="line">        img_scale=(<span class="number">1333</span>, <span class="number">800</span>),                                             <span class="comment"># 同上</span></span><br><span class="line">        img_norm_cfg=img_norm_cfg,                                         <span class="comment"># 同上</span></span><br><span class="line">        size_divisor=<span class="number">32</span>,                                                   <span class="comment"># 同上</span></span><br><span class="line">        flip_ratio=<span class="number">0</span>,                                                      <span class="comment"># 同上</span></span><br><span class="line">        with_mask=<span class="literal">False</span>,                                                   <span class="comment"># 同上</span></span><br><span class="line">        with_label=<span class="literal">False</span>,                                                  <span class="comment"># 同上</span></span><br><span class="line">        test_mode=<span class="literal">True</span>))                                                   <span class="comment"># 同上</span></span><br><span class="line"><span class="comment"># optimizer</span></span><br><span class="line">optimizer = dict(type=<span class="string">'SGD'</span>, lr=<span class="number">0.02</span>, momentum=<span class="number">0.9</span>, weight_decay=<span class="number">0.0001</span>)   <span class="comment"># 优化参数，lr为学习率，momentum为动量因子，weight_decay为权重衰减因子</span></span><br><span class="line">optimizer_config = dict(grad_clip=dict(max_norm=<span class="number">35</span>, norm_type=<span class="number">2</span>))          <span class="comment"># 梯度均衡参数</span></span><br><span class="line"><span class="comment"># learning policy</span></span><br><span class="line">lr_config = dict(</span><br><span class="line">    policy=<span class="string">'step'</span>,                        <span class="comment"># 优化策略</span></span><br><span class="line">    warmup=<span class="string">'linear'</span>,                      <span class="comment"># 初始的学习率增加的策略，linear为线性增加</span></span><br><span class="line">    warmup_iters=<span class="number">500</span>,                     <span class="comment"># 在初始的500次迭代中学习率逐渐增加</span></span><br><span class="line">    warmup_ratio=<span class="number">1.0</span> / <span class="number">3</span>,                 <span class="comment"># 起始的学习率</span></span><br><span class="line">    step=[<span class="number">8</span>, <span class="number">11</span>])                         <span class="comment"># 在第8和11个epoch时降低学习率</span></span><br><span class="line">checkpoint_config = dict(interval=<span class="number">1</span>)      <span class="comment"># 每1个epoch存储一次模型</span></span><br><span class="line"><span class="comment"># yapf:disable</span></span><br><span class="line">log_config = dict(</span><br><span class="line">    interval=<span class="number">50</span>,                          <span class="comment"># 每50个batch输出一次信息</span></span><br><span class="line">    hooks=[</span><br><span class="line">        dict(type=<span class="string">'TextLoggerHook'</span>),      <span class="comment"># 控制台输出信息的风格</span></span><br><span class="line">        <span class="comment"># dict(type='TensorboardLoggerHook')</span></span><br><span class="line">    ])</span><br><span class="line"><span class="comment"># yapf:enable</span></span><br><span class="line"><span class="comment"># runtime settings</span></span><br><span class="line">total_epochs = <span class="number">12</span>                               <span class="comment"># 最大epoch数</span></span><br><span class="line">dist_params = dict(backend=<span class="string">'nccl'</span>)              <span class="comment"># 分布式参数</span></span><br><span class="line">log_level = <span class="string">'INFO'</span>                              <span class="comment"># 输出信息的完整度级别</span></span><br><span class="line">work_dir = <span class="string">'./work_dirs/faster_rcnn_r50_fpn_1x'</span> <span class="comment"># log文件和模型文件存储路径</span></span><br><span class="line">load_from = <span class="literal">None</span>                                <span class="comment"># 加载模型的路径，None表示从预训练模型加载</span></span><br><span class="line">resume_from = <span class="literal">None</span>                              <span class="comment"># 恢复训练模型的路径</span></span><br><span class="line">workflow = [(<span class="string">'train'</span>, <span class="number">1</span>)]                       <span class="comment"># 当前工作区名称</span></span><br></pre></td></tr></table></figure><p> 三、cascade_rcnn_r50_fpn_1x.py配置文件<br>cascade-RCNN是cvpr2018的文章，相比于faster-RCNN的改进主要在于其RCNN有三个stage，这三个stage逐级refine检测的结果，使得结果达到更高的精度。下面逐条解释其config的含义，与faster-RCNN相同的部分就不再赘述。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># model settings</span></span><br><span class="line">model = dict(</span><br><span class="line">    type=<span class="string">'CascadeRCNN'</span>,</span><br><span class="line">    num_stages=<span class="number">3</span>,                     <span class="comment"># RCNN网络的stage数量，在faster-RCNN中为1</span></span><br><span class="line">    pretrained=<span class="string">'modelzoo://resnet50'</span>,</span><br><span class="line">    backbone=dict(</span><br><span class="line">        type=<span class="string">'ResNet'</span>,</span><br><span class="line">        depth=<span class="number">50</span>,</span><br><span class="line">        num_stages=<span class="number">4</span>,</span><br><span class="line">        out_indices=(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">        frozen_stages=<span class="number">1</span>,</span><br><span class="line">        style=<span class="string">'pytorch'</span>),</span><br><span class="line">    neck=dict(</span><br><span class="line">        type=<span class="string">'FPN'</span>,</span><br><span class="line">        in_channels=[<span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>, <span class="number">2048</span>],</span><br><span class="line">        out_channels=<span class="number">256</span>,</span><br><span class="line">        num_outs=<span class="number">5</span>),</span><br><span class="line">    rpn_head=dict(</span><br><span class="line">        type=<span class="string">'RPNHead'</span>,</span><br><span class="line">        in_channels=<span class="number">256</span>,</span><br><span class="line">        feat_channels=<span class="number">256</span>,</span><br><span class="line">        anchor_scales=[<span class="number">8</span>],</span><br><span class="line">        anchor_ratios=[<span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">2.0</span>],</span><br><span class="line">        anchor_strides=[<span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>],</span><br><span class="line">        target_means=[<span class="number">.0</span>, <span class="number">.0</span>, <span class="number">.0</span>, <span class="number">.0</span>],</span><br><span class="line">        target_stds=[<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>],</span><br><span class="line">        use_sigmoid_cls=<span class="literal">True</span>),</span><br><span class="line">    bbox_roi_extractor=dict(</span><br><span class="line">        type=<span class="string">'SingleRoIExtractor'</span>,</span><br><span class="line">        roi_layer=dict(type=<span class="string">'RoIAlign'</span>, out_size=<span class="number">7</span>, sample_num=<span class="number">2</span>),</span><br><span class="line">        out_channels=<span class="number">256</span>,</span><br><span class="line">        featmap_strides=[<span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>]),</span><br><span class="line">    bbox_head=[</span><br><span class="line">        dict(</span><br><span class="line">            type=<span class="string">'SharedFCBBoxHead'</span>,</span><br><span class="line">            num_fcs=<span class="number">2</span>,</span><br><span class="line">            in_channels=<span class="number">256</span>,</span><br><span class="line">            fc_out_channels=<span class="number">1024</span>,</span><br><span class="line">            roi_feat_size=<span class="number">7</span>,</span><br><span class="line">            num_classes=<span class="number">81</span>,</span><br><span class="line">            target_means=[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">            target_stds=[<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.2</span>],</span><br><span class="line">            reg_class_agnostic=<span class="literal">True</span>),</span><br><span class="line">        dict(</span><br><span class="line">            type=<span class="string">'SharedFCBBoxHead'</span>,</span><br><span class="line">            num_fcs=<span class="number">2</span>,</span><br><span class="line">            in_channels=<span class="number">256</span>,</span><br><span class="line">            fc_out_channels=<span class="number">1024</span>,</span><br><span class="line">            roi_feat_size=<span class="number">7</span>,</span><br><span class="line">            num_classes=<span class="number">81</span>,</span><br><span class="line">            target_means=[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">            target_stds=[<span class="number">0.05</span>, <span class="number">0.05</span>, <span class="number">0.1</span>, <span class="number">0.1</span>],</span><br><span class="line">            reg_class_agnostic=<span class="literal">True</span>),</span><br><span class="line">        dict(</span><br><span class="line">            type=<span class="string">'SharedFCBBoxHead'</span>,</span><br><span class="line">            num_fcs=<span class="number">2</span>,</span><br><span class="line">            in_channels=<span class="number">256</span>,</span><br><span class="line">            fc_out_channels=<span class="number">1024</span>,</span><br><span class="line">            roi_feat_size=<span class="number">7</span>,</span><br><span class="line">            num_classes=<span class="number">81</span>,</span><br><span class="line">            target_means=[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">            target_stds=[<span class="number">0.033</span>, <span class="number">0.033</span>, <span class="number">0.067</span>, <span class="number">0.067</span>],</span><br><span class="line">            reg_class_agnostic=<span class="literal">True</span>)</span><br><span class="line">    ])</span><br><span class="line"><span class="comment"># model training and testing settings</span></span><br><span class="line">train_cfg = dict(</span><br><span class="line">    rpn=dict(</span><br><span class="line">        assigner=dict(</span><br><span class="line">            type=<span class="string">'MaxIoUAssigner'</span>,</span><br><span class="line">            pos_iou_thr=<span class="number">0.7</span>,</span><br><span class="line">            neg_iou_thr=<span class="number">0.3</span>,</span><br><span class="line">            min_pos_iou=<span class="number">0.3</span>,</span><br><span class="line">            ignore_iof_thr=<span class="number">-1</span>),</span><br><span class="line">        sampler=dict(</span><br><span class="line">            type=<span class="string">'RandomSampler'</span>,</span><br><span class="line">            num=<span class="number">256</span>,</span><br><span class="line">            pos_fraction=<span class="number">0.5</span>,</span><br><span class="line">            neg_pos_ub=<span class="number">-1</span>,</span><br><span class="line">            add_gt_as_proposals=<span class="literal">False</span>),</span><br><span class="line">        allowed_border=<span class="number">0</span>,</span><br><span class="line">        pos_weight=<span class="number">-1</span>,</span><br><span class="line">        smoothl1_beta=<span class="number">1</span> / <span class="number">9.0</span>,</span><br><span class="line">        debug=<span class="literal">False</span>),</span><br><span class="line">    rcnn=[                    <span class="comment"># 注意，这里有3个RCNN的模块，对应开头的那个RCNN的stage数量</span></span><br><span class="line">        dict(</span><br><span class="line">            assigner=dict(</span><br><span class="line">                type=<span class="string">'MaxIoUAssigner'</span>,</span><br><span class="line">                pos_iou_thr=<span class="number">0.5</span>,</span><br><span class="line">                neg_iou_thr=<span class="number">0.5</span>,</span><br><span class="line">                min_pos_iou=<span class="number">0.5</span>,</span><br><span class="line">                ignore_iof_thr=<span class="number">-1</span>),</span><br><span class="line">            sampler=dict(</span><br><span class="line">                type=<span class="string">'RandomSampler'</span>,</span><br><span class="line">                num=<span class="number">512</span>,</span><br><span class="line">                pos_fraction=<span class="number">0.25</span>,</span><br><span class="line">                neg_pos_ub=<span class="number">-1</span>,</span><br><span class="line">                add_gt_as_proposals=<span class="literal">True</span>),</span><br><span class="line">            pos_weight=<span class="number">-1</span>,</span><br><span class="line">            debug=<span class="literal">False</span>),</span><br><span class="line">        dict(</span><br><span class="line">            assigner=dict(</span><br><span class="line">                type=<span class="string">'MaxIoUAssigner'</span>,</span><br><span class="line">                pos_iou_thr=<span class="number">0.6</span>,</span><br><span class="line">                neg_iou_thr=<span class="number">0.6</span>,</span><br><span class="line">                min_pos_iou=<span class="number">0.6</span>,</span><br><span class="line">                ignore_iof_thr=<span class="number">-1</span>),</span><br><span class="line">            sampler=dict(</span><br><span class="line">                type=<span class="string">'RandomSampler'</span>,</span><br><span class="line">                num=<span class="number">512</span>,</span><br><span class="line">                pos_fraction=<span class="number">0.25</span>,</span><br><span class="line">                neg_pos_ub=<span class="number">-1</span>,</span><br><span class="line">                add_gt_as_proposals=<span class="literal">True</span>),</span><br><span class="line">            pos_weight=<span class="number">-1</span>,</span><br><span class="line">            debug=<span class="literal">False</span>),</span><br><span class="line">        dict(</span><br><span class="line">            assigner=dict(</span><br><span class="line">                type=<span class="string">'MaxIoUAssigner'</span>,</span><br><span class="line">                pos_iou_thr=<span class="number">0.7</span>,</span><br><span class="line">                neg_iou_thr=<span class="number">0.7</span>,</span><br><span class="line">                min_pos_iou=<span class="number">0.7</span>,</span><br><span class="line">                ignore_iof_thr=<span class="number">-1</span>),</span><br><span class="line">            sampler=dict(</span><br><span class="line">                type=<span class="string">'RandomSampler'</span>,</span><br><span class="line">                num=<span class="number">512</span>,</span><br><span class="line">                pos_fraction=<span class="number">0.25</span>,</span><br><span class="line">                neg_pos_ub=<span class="number">-1</span>,</span><br><span class="line">                add_gt_as_proposals=<span class="literal">True</span>),</span><br><span class="line">            pos_weight=<span class="number">-1</span>,</span><br><span class="line">            debug=<span class="literal">False</span>)</span><br><span class="line">    ],</span><br><span class="line">    stage_loss_weights=[<span class="number">1</span>, <span class="number">0.5</span>, <span class="number">0.25</span>])     <span class="comment"># 3个RCNN的stage的loss权重</span></span><br><span class="line">test_cfg = dict(</span><br><span class="line">    rpn=dict(</span><br><span class="line">        nms_across_levels=<span class="literal">False</span>,</span><br><span class="line">        nms_pre=<span class="number">2000</span>,</span><br><span class="line">        nms_post=<span class="number">2000</span>,</span><br><span class="line">        max_num=<span class="number">2000</span>,</span><br><span class="line">        nms_thr=<span class="number">0.7</span>,</span><br><span class="line">        min_bbox_size=<span class="number">0</span>),</span><br><span class="line">    rcnn=dict(</span><br><span class="line">        score_thr=<span class="number">0.05</span>, nms=dict(type=<span class="string">'nms'</span>, iou_thr=<span class="number">0.5</span>), max_per_img=<span class="number">100</span>),</span><br><span class="line">    keep_all_stages=<span class="literal">False</span>)         <span class="comment"># 是否保留所有stage的结果</span></span><br><span class="line"><span class="comment"># dataset settings</span></span><br><span class="line">dataset_type = <span class="string">'CocoDataset'</span></span><br><span class="line">data_root = <span class="string">'data/coco/'</span></span><br><span class="line">img_norm_cfg = dict(</span><br><span class="line">    mean=[<span class="number">123.675</span>, <span class="number">116.28</span>, <span class="number">103.53</span>], std=[<span class="number">58.395</span>, <span class="number">57.12</span>, <span class="number">57.375</span>], to_rgb=<span class="literal">True</span>)</span><br><span class="line">data = dict(</span><br><span class="line">    imgs_per_gpu=<span class="number">2</span>,</span><br><span class="line">    workers_per_gpu=<span class="number">2</span>,</span><br><span class="line">    train=dict(</span><br><span class="line">        type=dataset_type,</span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/instances_train2017.json'</span>,</span><br><span class="line">        img_prefix=data_root + <span class="string">'train2017/'</span>,</span><br><span class="line">        img_scale=(<span class="number">1333</span>, <span class="number">800</span>),</span><br><span class="line">        img_norm_cfg=img_norm_cfg,</span><br><span class="line">        size_divisor=<span class="number">32</span>,</span><br><span class="line">        flip_ratio=<span class="number">0.5</span>,</span><br><span class="line">        with_mask=<span class="literal">False</span>,</span><br><span class="line">        with_crowd=<span class="literal">True</span>,</span><br><span class="line">        with_label=<span class="literal">True</span>),</span><br><span class="line">    val=dict(</span><br><span class="line">        type=dataset_type,</span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/instances_val2017.json'</span>,</span><br><span class="line">        img_prefix=data_root + <span class="string">'val2017/'</span>,</span><br><span class="line">        img_scale=(<span class="number">1333</span>, <span class="number">800</span>),</span><br><span class="line">        img_norm_cfg=img_norm_cfg,</span><br><span class="line">        size_divisor=<span class="number">32</span>,</span><br><span class="line">        flip_ratio=<span class="number">0</span>,</span><br><span class="line">        with_mask=<span class="literal">False</span>,</span><br><span class="line">        with_crowd=<span class="literal">True</span>,</span><br><span class="line">        with_label=<span class="literal">True</span>),</span><br><span class="line">    test=dict(</span><br><span class="line">        type=dataset_type,</span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/instances_val2017.json'</span>,</span><br><span class="line">        img_prefix=data_root + <span class="string">'val2017/'</span>,</span><br><span class="line">        img_scale=(<span class="number">1333</span>, <span class="number">800</span>),</span><br><span class="line">        img_norm_cfg=img_norm_cfg,</span><br><span class="line">        size_divisor=<span class="number">32</span>,</span><br><span class="line">        flip_ratio=<span class="number">0</span>,</span><br><span class="line">        with_mask=<span class="literal">False</span>,</span><br><span class="line">        with_label=<span class="literal">False</span>,</span><br><span class="line">        test_mode=<span class="literal">True</span>))</span><br><span class="line"><span class="comment"># optimizer</span></span><br><span class="line">optimizer = dict(type=<span class="string">'SGD'</span>, lr=<span class="number">0.02</span>, momentum=<span class="number">0.9</span>, weight_decay=<span class="number">0.0001</span>)</span><br><span class="line">optimizer_config = dict(grad_clip=dict(max_norm=<span class="number">35</span>, norm_type=<span class="number">2</span>))</span><br><span class="line"><span class="comment"># learning policy</span></span><br><span class="line">lr_config = dict(</span><br><span class="line">    policy=<span class="string">'step'</span>,</span><br><span class="line">    warmup=<span class="string">'linear'</span>,</span><br><span class="line">    warmup_iters=<span class="number">500</span>,</span><br><span class="line">    warmup_ratio=<span class="number">1.0</span> / <span class="number">3</span>,</span><br><span class="line">    step=[<span class="number">8</span>, <span class="number">11</span>])</span><br><span class="line">checkpoint_config = dict(interval=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># yapf:disable</span></span><br><span class="line">log_config = dict(</span><br><span class="line">    interval=<span class="number">50</span>,</span><br><span class="line">    hooks=[</span><br><span class="line">        dict(type=<span class="string">'TextLoggerHook'</span>),</span><br><span class="line">        <span class="comment"># dict(type='TensorboardLoggerHook')</span></span><br><span class="line">    ])</span><br><span class="line"><span class="comment"># yapf:enable</span></span><br><span class="line"><span class="comment"># runtime settings</span></span><br><span class="line">total_epochs = <span class="number">12</span></span><br><span class="line">dist_params = dict(backend=<span class="string">'nccl'</span>)</span><br><span class="line">log_level = <span class="string">'INFO'</span></span><br><span class="line">work_dir = <span class="string">'./work_dirs/cascade_rcnn_r50_fpn_1x'</span></span><br><span class="line">load_from = <span class="literal">None</span></span><br><span class="line">resume_from = <span class="literal">None</span></span><br><span class="line">workflow = [(<span class="string">'train'</span>, <span class="number">1</span>)]</span><br></pre></td></tr></table></figure><p>参考链接：</p><p><a href="https://www.jiqizhixin.com/articles/2018-10-17-10" target="_blank" rel="noopener">https://www.jiqizhixin.com/articles/2018-10-17-10</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、简介&lt;br&gt;在使用mmdetection对模型进行调优的过程中总会遇到很多参数的问题，不知道参数在代码中是什么作用，会对训练产生怎样的影响，这里我以faster_rcnn_r50_fpn_1x.py和cascade_rcnn_r50_fpn_1x.py为例，简单介绍一下
      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
    
      <category term="目标检测" scheme="http://yoursite.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>Visual Genome 数据集</title>
    <link href="http://yoursite.com/2019/07/21/Visual-Genome-%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    <id>http://yoursite.com/2019/07/21/Visual-Genome-数据集/</id>
    <published>2019-07-21T02:48:54.000Z</published>
    <updated>2019-07-21T02:50:42.253Z</updated>
    
    <content type="html"><![CDATA[<ul><li>数据集介绍<br><a href="https://cloud.tencent.com/developer/article/1391855" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1391855</a></li></ul><p><a href="https://visualgenome.org/" target="_blank" rel="noopener">Visual Genome 主页</a></p><p><a href="https://visualgenome.org/api/v0/api_home.html" target="_blank" rel="noopener">Visual Genome Data</a></p><p><a href="https://visualgenome.org/api/v0/api_readme" target="_blank" rel="noopener">Visual Genome Readme</a></p><p>Visual Genome 数据集总览：</p><ul><li>108077 张图片</li><li>5.4 Million Region Descriptions</li><li>1.7 Million Visual Question Answers</li><li>3.8 Million Object Instances</li><li>2.8 Million Attributes</li><li>2.3 Million Relationships</li><li>Everything Mapped to Wordnet Synsets  </li><li>标注数据：  objects，attributes，图片内的 relationships</li><li>共 108K 张图片，每张图片平均有， 35 个 objects，26 个 attributes，21对 objects 见的成对 relationships.</li></ul><p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/rex8eso6p5.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/vtmiv1yyr6.png?imageView2/2/w/1620" alt="img"></p><h2 id="1-Visual-Genome-数据标注"><a href="#1-Visual-Genome-数据标注" class="headerlink" title="1. Visual Genome 数据标注"></a>1. Visual Genome 数据标注</h2><p>数据集主要包括七个主要部分：</p><ul><li>region descriptions</li><li>objects</li><li>attributes</li><li>relationships</li><li>region graphs</li><li>scene graphs</li><li>question answer pairs</li></ul><h3 id="1-1-Region-Descriptions"><a href="#1-1-Region-Descriptions" class="headerlink" title="1.1. Region Descriptions"></a>1.1. Region Descriptions</h3><p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/8kgo0p0qim.png?imageView2/2/w/1620" alt="img"></p><p>数据集标注了图片的 regions descriptions，每个 region 有一个 bounding box. </p><p>如上图中，图片有三个 regions descriptions： “man jumping over a fire hydrant,”，“yellow fire hydrant,” 和   “woman in shorts is standing behind the man.”.</p><h3 id="1-2-Objects"><a href="#1-2-Objects" class="headerlink" title="1.2. Objects"></a>1.2. Objects</h3><p>数据集中每张图片平均有 35 个 objects，每个 object 采用 bounding box 标注.</p><p>如图：   </p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/ih1qpz1p3s.png?imageView2/2/w/1620" alt="img"></p><p><a href="http://blog.csdn.net/zziahgf/article/details/72819043" target="_blank" rel="noopener">MS-COCO 数据集</a> 只标注了 80 个 object categories，没有描述图片中的所有 objects. 实际场景中，可能有更多的 objects 类别.</p><p>Visual Genome 数据集旨在对图片里出现的所有视觉 objects 进行标注，objects categories 类别达到 33877 种.</p><h3 id="1-3-Attributes"><a href="#1-3-Attributes" class="headerlink" title="1.3. Attributes"></a>1.3. Attributes</h3><p>数据集中每张图片平均有 26 个 attributes. Objects 可能没有或者有更多的相关 attributes. </p><p>Attributes 可以是 color(如 yellow)，states(如 standing) 等，如图：   </p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/k1n26a1mdt.png?imageView2/2/w/1620" alt="img"></p><p>Attributes 能够对 objects 进行更容易的描述、对比与分类. 即使以前未见到某 object，根据 attributes 仍能推断出与 object 相关的东西. 如，“yellow and brown spotted with long neck(长脖子上有黄色和棕色的斑点)”，很可能推断出 object 是 giraffe(长颈鹿).</p><p>关于 attributes 的研究：</p><ul><li>采用examplar SVMs，利用相似特征来寻找 objects；</li><li>采用纹理(textures) 研究 objects，或者预测颜色.</li><li>采用 attributes 来提高目标分类结果. 如 fine-grained 识别.</li></ul><p>Attributes 一般被定义为 parts(如 has legs)、shapes(如，spherical球形的)、materials(如 furry毛皮的)；用于对新的 objects 类别进行分类.</p><p>Visual Genome 数据集对于 attributes 进行扩展，其 attributes 不是 image-specific 的，而是真实场景中 object-specific 的. attributes 类型包括：size(如 small), pose(如bent), state (如 transparent), emotion (如 happy)等等.</p><ul><li>基于 VGG16 的 attributes 预测结果：   </li></ul><p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/373ih7qquc.png?imageView2/2/w/1620" alt="img"></p><h3 id="1-4-Relationships"><a href="#1-4-Relationships" class="headerlink" title="1.4. Relationships"></a>1.4. Relationships</h3><p>Relationships 是两个 objects 的连接关系.</p><p>Relationships 可以是 actions(如 jumping over)，spatial(如 is build)，comparative(如 taller than)，prepositional phrases (如 drive on). 如图：   </p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/5ljbd3m2av.png?imageView2/2/w/1620" alt="img"></p><ul><li>Relationship 预测结果：   </li></ul><p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/pgbhzj5ui4.png?imageView2/2/w/1620" alt="img"></p><h3 id="1-5-Region-Graphs"><a href="#1-5-Region-Graphs" class="headerlink" title="1.5. Region Graphs"></a>1.5. Region Graphs</h3><p>结合 objects、attributes 以及  region descriptions 提取的 relationships，创建每个 regions 的 graph representation. </p><h3 id="1-6-Scene-Graphs"><a href="#1-6-Scene-Graphs" class="headerlink" title="1.6. Scene Graphs"></a>1.6. Scene Graphs</h3><p>Region graphs 是图片的局部区域表示，将 region graphs 结合，生成单个 scene graph来表示整张图片.</p><p>Scene graph 是全部 region graphs 的统一，包含了全部的 objects、attributes以及每个 region description 的 relationships.</p><p>Scene Graph 将多种不同层次的 scene 信息以更加一致的方式结合在一起.</p><h3 id="1-7-Question-Answer-QA-Pairs"><a href="#1-7-Question-Answer-QA-Pairs" class="headerlink" title="1.7. Question Answer(QA) Pairs"></a>1.7. Question Answer(QA) Pairs</h3><p>数据集中每张图片有两种类型的 QA pairs：</p><ul><li>freeform QAs - 基于整张图片；</li><li>region-based QAs - 基于图片的选择区域. </li></ul><p>每张图片标注了 6 中不同类型的问题：what, where, how, when, who, why.</p><p>如图：   </p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/vbxbgpfi92.png?imageView2/2/w/1620" alt="img"></p><p>Figure . Visual Genome 数据集. 每张图片包括：region descriptions - 描述了图像的局部信息；两种类型的 question answer pairs(QAs) - free form QAs 和 region-based QAs. 每个 region 转化为 objects、attributes 和 pairwise relationships region 构成的 region graph 表示. 最终， 结合 region graphs 以形成图片内全部 objects 的 scene graph.</p><h2 id="2-Visual-Genome-数据集应用"><a href="#2-Visual-Genome-数据集应用" class="headerlink" title="2. Visual Genome 数据集应用"></a>2. Visual Genome 数据集应用</h2><p>基本应用：</p><ul><li>attribute classification 属性分类</li><li>relationship classification 关系分类</li><li>description generation 描述生成</li><li>question answering QA</li></ul><p>更多应用：</p><ul><li>Dense image captioning</li><li>Visual question answering</li><li>Image understanding</li><li>Relationship extraction</li><li>Semantic image retrieval</li><li>Completing the Set of Annotations</li></ul><p>注 - 与其它数据集对比：   </p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/cjqe5v7i44.png?imageView2/2/w/1620" alt="img"></p><h2 id="3-Reference"><a href="#3-Reference" class="headerlink" title="3. Reference"></a>3. Reference</h2><p>[1] - <a href="https://visualgenome.org/" target="_blank" rel="noopener">Visual Genome Home</a></p><p>[1] - <a href="https://visualgenome.org/static/paper/Visual_Genome.pdf" target="_blank" rel="noopener">Visual Genome Doc</a></p><p>[2] - <a href="https://arxiv.org/pdf/1701.02426.pdf" target="_blank" rel="noopener">Scene Graph Generation by Iterative Message Passing</a></p><p>本文参与<a href="https://cloud.tencent.com/developer/support-plan" target="_blank" rel="noopener">腾讯云自媒体分享计划</a>，欢迎正在阅读的你也加入，一起分享。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;数据集介绍&lt;br&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1391855&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cloud.tencent.com/dev
      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
    
      <category term="目标检测" scheme="http://yoursite.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>设置随机种子</title>
    <link href="http://yoursite.com/2019/07/21/%E8%AE%BE%E7%BD%AE%E9%9A%8F%E6%9C%BA%E7%A7%8D%E5%AD%90/"/>
    <id>http://yoursite.com/2019/07/21/设置随机种子/</id>
    <published>2019-07-21T02:15:15.000Z</published>
    <updated>2019-07-21T02:15:49.161Z</updated>
    
    <content type="html"><![CDATA[<p>def set_random_seed(seed):<br>    random.seed(seed)<br>    np.random.seed(seed)<br>    torch.manual_seed(seed)<br>    torch.cuda.manual_seed_all(seed)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;def set_random_seed(seed):&lt;br&gt;    random.seed(seed)&lt;br&gt;    np.random.seed(seed)&lt;br&gt;    torch.manual_seed(seed)&lt;br&gt;    torch.cuda.manual_s
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mmdetection的安装</title>
    <link href="http://yoursite.com/2019/07/20/mmdetection%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2019/07/20/mmdetection的安装/</id>
    <published>2019-07-20T06:33:47.000Z</published>
    <updated>2019-07-25T01:27:23.103Z</updated>
    
    <content type="html"><![CDATA[<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li><p>选择镜像：py36-pytorch0.4.0-cu90-ctc （即，准备一个cuda9.0的环境）</p></li><li><p>进入容器，安装anaconda</p></li></ul><h3 id="按着Github-install的步骤进行安装如下："><a href="#按着Github-install的步骤进行安装如下：" class="headerlink" title="按着Github install的步骤进行安装如下："></a>按着<a href="https://github.com/open-mmlab/mmdetection/blob/master/INSTALL.md" target="_blank" rel="noopener">Github install</a>的步骤进行安装如下：</h3><ul><li>Create a conda virtual environment and activate it. Then install Cython.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n open-mmlab python=<span class="number">3.7</span> -y</span><br><span class="line">source activate open-mmlab</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>** 以下的操作都是在进入open-mmlab环境之后进行的**</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="keyword">install</span> cython</span><br></pre></td></tr></table></figure></li><li><p>安装 numpy</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> numpy</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>安装<a href="https://github.com/open-mmlab/mmcv" target="_blank" rel="noopener">mmcv</a> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install mmcv</span><br></pre></td></tr></table></figure></li><li><p>安装pytorch<br>最好是离线下载，然后再安装，因为conda install 或者 pip install 可能连接不上（细节：pip install torch  就会出现下载链接，然后自己复制链接去网页下载即可），下载之后：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">pip</span> <span class="selector-tag">install</span> <span class="selector-tag">torch-1</span><span class="selector-class">.1</span><span class="selector-class">.0-cp37-cp37m-manylinux1_x86_64</span><span class="selector-class">.whl</span></span><br></pre></td></tr></table></figure></li><li><p>安装opencv</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="keyword">install</span> -c menpo opencv</span><br></pre></td></tr></table></figure></li></ul><ul><li>安装matplotlib<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> matplotlib</span><br></pre></td></tr></table></figure></li></ul><ul><li>安装 terminaltables<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> terminaltables</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>安装 pip install pycocotools</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> pycocotools</span><br></pre></td></tr></table></figure></li><li><p>选择一个看的顺眼的位置：Clone the mmdetection repository.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/open-mmlab/mmdetection.git</span><br><span class="line">cd mmdetection</span><br></pre></td></tr></table></figure></li><li><p>Install mmdetection</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py develop</span><br></pre></td></tr></table></figure></li><li><p>大功告成</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;选择镜像：py36-pytorch0.4.0-cu90-ctc （即，准备一个cuda9.0的环境）&lt;/p&gt;
&lt;/li&gt;

      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
    
      <category term="目标检测" scheme="http://yoursite.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>torch.no_grad</title>
    <link href="http://yoursite.com/2019/07/17/torch-no-grad/"/>
    <id>http://yoursite.com/2019/07/17/torch-no-grad/</id>
    <published>2019-07-17T04:14:09.000Z</published>
    <updated>2019-07-17T04:16:17.197Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://discuss.pytorch.org/t/model-eval-vs-with-torch-no-grad/19615/21" target="_blank" rel="noopener">https://discuss.pytorch.org/t/model-eval-vs-with-torch-no-grad/19615/21</a></li><li>with torch.no_grad()</li><li>可以减少内存，加快运行速度，同时可以使得batch_size 增大</li><li>但不是说非得必要</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://discuss.pytorch.org/t/model-eval-vs-with-torch-no-grad/19615/21&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://discuss.py
      
    
    </summary>
    
      <category term="pytorch" scheme="http://yoursite.com/categories/pytorch/"/>
    
    
      <category term="pytorch" scheme="http://yoursite.com/tags/pytorch/"/>
    
  </entry>
  
  <entry>
    <title>Spacy工具包</title>
    <link href="http://yoursite.com/2019/07/16/Spacy%E5%B7%A5%E5%85%B7%E5%8C%85/"/>
    <id>http://yoursite.com/2019/07/16/Spacy工具包/</id>
    <published>2019-07-16T03:12:34.000Z</published>
    <updated>2019-07-16T03:26:09.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="spaCy的主要操作："><a href="#spaCy的主要操作：" class="headerlink" title="spaCy的主要操作："></a>spaCy的主要操作：</h2><h3 id="1、分词断句"><a href="#1、分词断句" class="headerlink" title="1、分词断句"></a>1、分词断句</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import spacy</span><br><span class="line">nlp = spacy.<span class="built_in">load</span>(<span class="string">'en'</span>)</span><br><span class="line">doc = nlp(<span class="string">'Hello World! My name is HanXiaoyang'</span>)</span><br><span class="line"><span class="comment"># 分词</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">token</span> <span class="keyword">in</span> doc:</span><br><span class="line">    print(<span class="string">'"'</span> + <span class="keyword">token</span>.<span class="keyword">text</span> + <span class="string">'"'</span>)</span><br><span class="line"><span class="comment"># 断句</span></span><br><span class="line"><span class="keyword">for</span> sent <span class="keyword">in</span> doc.sents:</span><br><span class="line">    print(sent)</span><br></pre></td></tr></table></figure><p>每个token对象有着非常丰富的属性，如下的方式可以取出其中的部分属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">doc</span> <span class="string">=</span> <span class="string">nlp("Next</span> <span class="string">week</span> <span class="string">I'll</span>   <span class="string">be</span> <span class="string">in</span> <span class="string">Shanghai.")</span></span><br><span class="line"><span class="string">for</span> <span class="string">token</span> <span class="string">in</span> <span class="attr">doc:</span></span><br><span class="line">    <span class="string">print("&#123;0&#125;\t&#123;1&#125;\t&#123;2&#125;\t&#123;3&#125;\t&#123;4&#125;\t&#123;5&#125;\t&#123;6&#125;\t&#123;7&#125;".format(</span></span><br><span class="line">        <span class="string">token.text,</span></span><br><span class="line">        <span class="string">token.idx,</span></span><br><span class="line">        <span class="string">token.lemma_,</span></span><br><span class="line">        <span class="string">token.is_punct,</span></span><br><span class="line">        <span class="string">token.is_space,</span></span><br><span class="line">        <span class="string">token.shape_,</span></span><br><span class="line">        <span class="string">token.pos_,</span></span><br><span class="line">        <span class="string">token.tag_</span></span><br><span class="line">    <span class="string">))</span></span><br><span class="line"><span class="string">输出结果如下：</span></span><br><span class="line"><span class="string">Next</span>    <span class="number">0</span>   <span class="string">next</span>    <span class="literal">False</span>   <span class="literal">False</span>   <span class="string">Xxxx</span>    <span class="string">ADJ</span> <span class="string">JJ</span></span><br><span class="line"><span class="string">week</span>    <span class="number">5</span>   <span class="string">week</span>    <span class="literal">False</span>   <span class="literal">False</span>   <span class="string">xxxx</span>    <span class="string">NOUN</span>    <span class="string">NN</span></span><br><span class="line"><span class="string">I</span>   <span class="number">10</span>  <span class="bullet">-PRON-</span>  <span class="literal">False</span>   <span class="literal">False</span>   <span class="string">X</span>   <span class="string">PRON</span>    <span class="string">PRP</span></span><br><span class="line"><span class="string">'ll 11  will    False   False   '</span><span class="string">xx</span> <span class="string">VERB</span>    <span class="string">MD</span></span><br><span class="line">    <span class="number">15</span>      <span class="literal">False</span>   <span class="literal">True</span>        <span class="string">SPACE</span>   <span class="string">_SP</span></span><br><span class="line"><span class="string">be</span>  <span class="number">17</span>  <span class="string">be</span>  <span class="literal">False</span>   <span class="literal">False</span>   <span class="string">xx</span>  <span class="string">VERB</span>    <span class="string">VB</span></span><br><span class="line"><span class="string">in</span>  <span class="number">20</span>  <span class="string">in</span>  <span class="literal">False</span>   <span class="literal">False</span>   <span class="string">xx</span>  <span class="string">ADP</span> <span class="string">IN</span></span><br><span class="line"><span class="string">Shanghai</span>    <span class="number">23</span>  <span class="string">shanghai</span>    <span class="literal">False</span>   <span class="literal">False</span>   <span class="string">Xxxxx</span>   <span class="string">PROPN</span>   <span class="string">NNP</span></span><br><span class="line"><span class="string">.</span>   <span class="number">31</span>  <span class="string">.</span>   <span class="literal">True</span>    <span class="literal">False</span>   <span class="string">.</span>   <span class="string">PUNCT</span>   <span class="string">.</span></span><br></pre></td></tr></table></figure><h3 id="2、词性标注"><a href="#2、词性标注" class="headerlink" title="2、词性标注"></a>2、词性标注</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 词性标注</span></span><br><span class="line">doc = nlp(<span class="string">"Next week I'll be in Shanghai."</span>)</span><br><span class="line">print([(<span class="keyword">token</span>.<span class="keyword">text</span>, <span class="keyword">token</span>.tag_) <span class="keyword">for</span> <span class="keyword">token</span> <span class="keyword">in</span> doc])</span><br></pre></td></tr></table></figure><p>[(‘Next’, ‘JJ’), (‘week’, ‘NN’), (‘I’, ‘PRP’), (“‘ll”, ‘MD’), (‘be’, ‘VB’), (‘in’, ‘IN’), (‘Shanghai’, ‘NNP’), (‘.’, ‘.’)]</p><h3 id="3、组块分析"><a href="#3、组块分析" class="headerlink" title="3、组块分析"></a>3、组块分析</h3><p>spaCy可以自动检测名词短语，并输出根(root)词，比如下面的”Journal”,”piece”,”currencies”</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doc = nlp(<span class="string">"Wall Street Journal just published an interesting piece on crypto currencies"</span>)</span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> doc<span class="selector-class">.noun_chunks</span>:</span><br><span class="line">    print(chunk<span class="selector-class">.text</span>, chunk<span class="selector-class">.label_</span>, chunk<span class="selector-class">.root</span><span class="selector-class">.text</span>)</span><br></pre></td></tr></table></figure><p>输出结果：<br>Wall Street Journal NP Journal<br>an interesting piece NP piece<br>crypto currencies NP currencies</p><h3 id="4、命名实体识别"><a href="#4、命名实体识别" class="headerlink" title="4、命名实体识别"></a>4、命名实体识别</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doc = nlp(<span class="string">"Two years ago, I lived in my Beijing."</span>)</span><br><span class="line"><span class="keyword">for</span> ent <span class="keyword">in</span> doc<span class="selector-class">.ents</span>:</span><br><span class="line">    print(ent<span class="selector-class">.text</span>, ent.label_)</span><br></pre></td></tr></table></figure><p>输出结果：<br>Two years ago DATE<br>BeijingGPE</p><p>还可以用非常漂亮的可视化做显示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> spacy import displacy</span><br><span class="line">displacy.render(doc, <span class="attribute">style</span>=<span class="string">'ent'</span>, <span class="attribute">jupyter</span>=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="//upload-images.jianshu.io/upload_images/11681023-77f9837fa7e661dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/454/format/webp" alt></p><p>输出结果.png</p><h3 id="5、句法依存解析"><a href="#5、句法依存解析" class="headerlink" title="5、句法依存解析"></a>5、句法依存解析</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">doc = nlp(<span class="string">'Wall Street Journal just published an interesting piece on crypto currencies'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> doc:</span><br><span class="line">    print(<span class="string">"&#123;0&#125;/&#123;1&#125; &lt;--&#123;2&#125;-- &#123;3&#125;/&#123;4&#125;"</span>.format(</span><br><span class="line">        token<span class="selector-class">.text</span>, token<span class="selector-class">.tag_</span>, token<span class="selector-class">.dep_</span>, token<span class="selector-class">.head</span><span class="selector-class">.text</span>, token<span class="selector-class">.head</span><span class="selector-class">.tag_</span>))</span><br></pre></td></tr></table></figure><p>输出结果：<br>Wall/NNP &lt;–compound– Street/NNP<br>Street/NNP &lt;–compound– Journal/NNP<br>Journal/NNP &lt;–nsubj– published/VBD<br>just/RB &lt;–advmod– published/VBD<br>published/VBD &lt;–ROOT– published/VBD<br>an/DT &lt;–det– piece/NN<br>interesting/JJ &lt;–amod– piece/NN<br>piece/NN &lt;–dobj– published/VBD<br>on/IN &lt;–prep– piece/NN<br>crypto/JJ &lt;–compound– currencies/NNS<br>currencies/NNS &lt;–pobj– on/IN</p><h3 id="6、-词向量"><a href="#6、-词向量" class="headerlink" title="6、==词向量=="></a>6、==词向量==</h3><p>NLP中有一个非常强大的文本表示学习方法叫做==word2vec==，通过词的上下文学习到词语的稠密向量化表示，同时在这个表示形态下，语义相关的词在向量空间中会比较接近。也有类似v(爷爷)-v(奶奶) ≈ v(男人)-v(女人)的关系。<br>在spaCy中，要使用英文的词向量，需先下载预先训练好的结果。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">python3</span> -m spacy download en_core_web_lg</span><br></pre></td></tr></table></figure><p>词向量的应用：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">nlp = spacy.<span class="built_in">load</span>(<span class="string">'en_core_web_lg'</span>)</span><br><span class="line"><span class="built_in">from</span> scipy import spatial</span><br><span class="line"></span><br><span class="line"><span class="comment"># 余弦相似度计算</span></span><br><span class="line">cosine_similarity = lambda x, y: <span class="number">1</span> - spatial.distance.cosine(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 男人、女人、国王、女王 的词向量</span></span><br><span class="line">man = nlp.vocab[<span class="string">'man'</span>].vector</span><br><span class="line">woman = nlp.vocab[<span class="string">'woman'</span>].vector</span><br><span class="line">queen = nlp.vocab[<span class="string">'queen'</span>].vector</span><br><span class="line">king = nlp.vocab[<span class="string">'king'</span>].vector</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 我们对向量做一个简单的计算，"man" - "woman" + "queen"</span></span><br><span class="line">maybe_king = man - woman + queen</span><br><span class="line">computed_similarities = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 扫描整个词库的词向量做比对，召回最接近的词向量</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">word</span> <span class="keyword">in</span> nlp.vocab:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">word</span>.has_vector:</span><br><span class="line">        continue</span><br><span class="line"> </span><br><span class="line">    similarity = cosine_similarity(maybe_king, <span class="built_in">word</span>.vector)</span><br><span class="line">    computed_similarities.append((<span class="built_in">word</span>, similarity))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序与最接近结果展示</span></span><br><span class="line">computed_similarities = sorted(computed_similarities, key=lambda <span class="keyword">item</span>: -<span class="keyword">item</span>[<span class="number">1</span>])</span><br><span class="line">print([w[<span class="number">0</span>].<span class="keyword">text</span> <span class="keyword">for</span> w <span class="keyword">in</span> computed_similarities[:<span class="number">10</span>]])</span><br></pre></td></tr></table></figure><p>输出结果：<br>[‘Queen’, ‘QUEEN’, ‘queen’, ‘King’, ‘KING’, ‘king’, ‘KIng’, ‘Kings’, ‘KINGS’, ‘kings’]</p><h3 id="6、词汇与文本相似度"><a href="#6、词汇与文本相似度" class="headerlink" title="6、词汇与文本相似度"></a>6、词汇与文本相似度</h3><p>在词向量的基础上，spaCy提供了从词到文档的相似度计算的方法，下面的例子是它的使用方法。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 词汇语义相似度(关联性)</span></span><br><span class="line">banana = nlp.vocab['banana']</span><br><span class="line">dog = nlp.vocab['dog']</span><br><span class="line">fruit = nlp.vocab['fruit']</span><br><span class="line">animal = nlp.vocab['animal']</span><br><span class="line"> </span><br><span class="line">print(dog.similarity(animal), dog.similarity(fruit)) <span class="comment"># 0.6618534 0.23552845</span></span><br><span class="line">print(banana.similarity(fruit), banana.similarity(animal)) <span class="comment"># 0.67148364 0.2427285</span></span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文本语义相似度(关联性)</span></span><br><span class="line">target = nlp(<span class="string">"Cats are beautiful animals."</span>)</span><br><span class="line"> </span><br><span class="line">doc1 = nlp(<span class="string">"Dogs are awesome."</span>)</span><br><span class="line">doc2 = nlp(<span class="string">"Some gorgeous creatures are felines."</span>)</span><br><span class="line">doc3 = nlp(<span class="string">"Dolphins are swimming mammals."</span>)</span><br><span class="line"> </span><br><span class="line">print(target.similarity(doc1))  <span class="comment"># 0.8901765218466683</span></span><br><span class="line">print(target.similarity(doc2))  <span class="comment"># 0.9115828449161616</span></span><br><span class="line">print(target.similarity(doc3))  <span class="comment"># 0.7822956752876101</span></span><br></pre></td></tr></table></figure><p>作者：还是那个没头脑<br>链接：<a href="https://www.jianshu.com/p/74e6c5376bc0" target="_blank" rel="noopener">https://www.jianshu.com/p/74e6c5376bc0</a><br>来源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;spaCy的主要操作：&quot;&gt;&lt;a href=&quot;#spaCy的主要操作：&quot; class=&quot;headerlink&quot; title=&quot;spaCy的主要操作：&quot;&gt;&lt;/a&gt;spaCy的主要操作：&lt;/h2&gt;&lt;h3 id=&quot;1、分词断句&quot;&gt;&lt;a href=&quot;#1、分词断句&quot; cla
      
    
    </summary>
    
      <category term="自然语言理解" scheme="http://yoursite.com/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E7%90%86%E8%A7%A3/"/>
    
    
      <category term="自然语言理解" scheme="http://yoursite.com/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E7%90%86%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>pytorch-gather</title>
    <link href="http://yoursite.com/2019/07/12/pytorch-gather/"/>
    <id>http://yoursite.com/2019/07/12/pytorch-gather/</id>
    <published>2019-07-12T04:06:36.000Z</published>
    <updated>2019-07-12T04:09:41.504Z</updated>
    
    <content type="html"><![CDATA[<p>函数<code>torch.gather(input, dim, index, out=None) → Tensor</code><br> 沿给定轴 dim ,将输入索引张量 index 指定位置的值进行聚合.<br> 对一个 3 维张量,输出可以定义为:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">out[<span class="string">i</span>][<span class="symbol">j</span>][<span class="string">k</span>] = input[<span class="string">index[i</span>][<span class="symbol">j</span>][<span class="string">k</span>]][<span class="string">j</span>][<span class="symbol">k</span>]  # if dim == 0</span><br><span class="line">out[<span class="string">i</span>][<span class="symbol">j</span>][<span class="string">k</span>] = input[<span class="string">i</span>][<span class="symbol">index[i</span>][<span class="string">j</span>][<span class="symbol">k</span>]][<span class="symbol">k</span>]  # if dim == 1</span><br><span class="line">out[<span class="string">i</span>][<span class="symbol">j</span>][<span class="string">k</span>] = input[<span class="string">i</span>][<span class="symbol">j</span>][<span class="string">index[i</span>][<span class="symbol">j</span>][<span class="string">k</span>]]  # if dim == 2</span><br></pre></td></tr></table></figure><p>Parameters:</p><ul><li>input (Tensor) – 源张量</li><li>dim (int) – 索引的轴</li><li>index (LongTensor) – 聚合元素的下标(index需要是torch.longTensor类型)</li><li>out (Tensor, optional) – 目标张量</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;函数&lt;code&gt;torch.gather(input, dim, index, out=None) → Tensor&lt;/code&gt;&lt;br&gt; 沿给定轴 dim ,将输入索引张量 index 指定位置的值进行聚合.&lt;br&gt; 对一个 3 维张量,输出可以定义为:&lt;/p&gt;
&lt;fig
      
    
    </summary>
    
      <category term="pytorch" scheme="http://yoursite.com/categories/pytorch/"/>
    
    
      <category term="pytorch" scheme="http://yoursite.com/tags/pytorch/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/07/11/hello-world/"/>
    <id>http://yoursite.com/2019/07/11/hello-world/</id>
    <published>2019-07-11T08:28:40.629Z</published>
    <updated>2019-02-20T08:11:45.333Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>numpy 函数</title>
    <link href="http://yoursite.com/2019/06/16/numpy-%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/06/16/numpy-函数/</id>
    <published>2019-06-16T02:34:31.000Z</published>
    <updated>2019-06-16T11:51:39.372Z</updated>
    
    <content type="html"><![CDATA[<h2 id="np-round"><a href="#np-round" class="headerlink" title="np.round "></a><font color="#0099ff" size="7" face="黑体">np.round </font></h2><h3 id="round函数概念："><a href="#round函数概念：" class="headerlink" title="round函数概念："></a>round函数概念：</h3><p>英文：圆，四舍五入<br>是python内置函数，它在哪都能用，对数字取四舍五入。<br>round(number[, ndigits])<br>round 对传入的数据进行四舍五入，如果ngigits不传，默认是0（就是说保留整数部分）.ngigits&lt;0 的时候是来对整数部分进行四舍五入，返回的结果是浮点数.</p><h3 id="round-负数"><a href="#round-负数" class="headerlink" title="round 负数"></a>round 负数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 四舍五入是围绕着0来计算的，  </span></span><br><span class="line">round(<span class="number">0.5</span>) <span class="comment"># 1.0  </span></span><br><span class="line">round(<span class="number">-0.5</span>) <span class="comment">#-1.0</span></span><br></pre></td></tr></table></figure><h3 id="round-的陷阱"><a href="#round-的陷阱" class="headerlink" title="round 的陷阱"></a>round 的陷阱</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">round(<span class="number">1.675</span>, <span class="number">2</span>) <span class="comment">#1.68  </span></span><br><span class="line">round(<span class="number">2.675</span>, <span class="number">2</span>) <span class="comment">#2.67</span></span><br></pre></td></tr></table></figure><h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">round(<span class="number">3.4</span>) <span class="comment"># 3.0  </span></span><br><span class="line">round(<span class="number">3.5</span>) <span class="comment"># 4.0  </span></span><br><span class="line">round(<span class="number">3.6</span>) <span class="comment"># 4.0  </span></span><br><span class="line">round(<span class="number">3.6</span>, <span class="number">0</span>) <span class="comment"># 4.0  </span></span><br><span class="line">round(<span class="number">1.95583</span>, <span class="number">2</span>) <span class="comment"># 1.96  </span></span><br><span class="line">round(<span class="number">1241757</span>, <span class="number">-3</span>) <span class="comment"># 1242000.0  </span></span><br><span class="line">round(<span class="number">5.045</span>, <span class="number">2</span>) <span class="comment"># 5.05  </span></span><br><span class="line">round(<span class="number">5.055</span>, <span class="number">2</span>) <span class="comment"># 5.06</span></span><br></pre></td></tr></table></figure><h2 id="np-clip"><a href="#np-clip" class="headerlink" title="np.clip"></a><font color="#0099ff" size="7" face="黑体">np.clip</font></h2><p>numpy.clip(a, a_min, a_max, out=None)[source]<br>其中a是一个数组，后面两个参数分别表示最小和最大值，怎么用呢，老规矩，我们看代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x=np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>])</span><br><span class="line">np.clip(x,<span class="number">3</span>,<span class="number">8</span>)</span><br><span class="line">Out[<span class="number">88</span>]:</span><br><span class="line">array([<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;np-round&quot;&gt;&lt;a href=&quot;#np-round&quot; class=&quot;headerlink&quot; title=&quot;np.round &quot;&gt;&lt;/a&gt;&lt;font color=&quot;#0099ff&quot; size=&quot;7&quot; face=&quot;黑体&quot;&gt;np.round &lt;/font&gt;&lt;/h2
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>self-attention</title>
    <link href="http://yoursite.com/2019/06/16/self-attention/"/>
    <id>http://yoursite.com/2019/06/16/self-attention/</id>
    <published>2019-06-16T01:02:40.000Z</published>
    <updated>2019-07-16T03:27:01.686Z</updated>
    
    <content type="html"><![CDATA[<ul><li>一篇解读：<a href="https://kexue.fm/archives/4765" target="_blank" rel="noopener">https://kexue.fm/archives/4765</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;一篇解读：&lt;a href=&quot;https://kexue.fm/archives/4765&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://kexue.fm/archives/4765&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
      <category term="自然语言理解" scheme="http://yoursite.com/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E7%90%86%E8%A7%A3/"/>
    
    
      <category term="自然语言理解" scheme="http://yoursite.com/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E7%90%86%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>优先级队列式分支限界法---最小重量机器设计问题--python实现</title>
    <link href="http://yoursite.com/2019/05/22/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%BC%8F%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95-%E6%9C%80%E5%B0%8F%E9%87%8D%E9%87%8F%E6%9C%BA%E5%99%A8%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98-python%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/05/22/优先级队列式分支限界法-最小重量机器设计问题-python实现/</id>
    <published>2019-05-22T03:20:26.000Z</published>
    <updated>2019-05-22T03:23:20.359Z</updated>
    
    <content type="html"><![CDATA[<p>这里给出两个解决方案：</p><p>1）不使用优先级，简单使用队列式分支限界法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 普通的FIFO 队列式分支限界法</span></span><br><span class="line"><span class="comment">## 当 不满足总价格不超过d的要求时，则剪枝</span></span><br><span class="line"><span class="comment">## 当搜索到深度n时，即搜索到了叶节点，不再进行扩展节点的操作，而是针对于叶节点所对应的最小值，</span></span><br><span class="line"><span class="comment"># 反向求得该节点所对应的的路径</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># coding : utf-8</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = <span class="number">3</span></span><br><span class="line">m = <span class="number">3</span></span><br><span class="line">d = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">price = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line">weight = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到当前扩展节点所在的Level</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getlevel</span><span class="params">(m, currrent)</span>:</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    level = <span class="number">0</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> currrent == <span class="number">0</span>:</span><br><span class="line">        level = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> level</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">        level = level+<span class="number">1</span></span><br><span class="line">        sum = m**level + sum  <span class="comment"># sum=m</span></span><br><span class="line">        <span class="keyword">if</span> sum-m**level &lt; currrent &lt;= sum:  <span class="comment"># m-m^0 = m-1</span></span><br><span class="line">            <span class="keyword">return</span> level</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到当前扩展节点，所对应的首个子节点所在的索引</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_idx</span><span class="params">(m, current)</span>:</span></span><br><span class="line">    level = getlevel(m, current)</span><br><span class="line">    <span class="comment"># 求current 在该level中的相对索引，即 相对于该level第一个元素的位置</span></span><br><span class="line">    current_level_idx = current - sum([m**i <span class="keyword">for</span> i <span class="keyword">in</span> range(level)])</span><br><span class="line">    <span class="comment"># 子节点所在层的开始绝对索引</span></span><br><span class="line">    start_idx  = sum([m**i <span class="keyword">for</span> i <span class="keyword">in</span> range(level+<span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> start_idx + current_level_idx*m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到最优解之后，反向查找其路径</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_path</span><span class="params">(m, current)</span>:</span></span><br><span class="line">    path = []</span><br><span class="line">    path.append(current%m)  <span class="comment"># from 1, not from 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        level = getlevel(m, current)</span><br><span class="line">        <span class="keyword">if</span> level == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> path[::<span class="number">-1</span>]</span><br><span class="line">        current_level_idx = current - sum([m ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(level)])  <span class="comment"># # 求current 在该level中的相对索引，即 相对于该level第一个元素的位置</span></span><br><span class="line">        path.append(current_level_idx // m + <span class="number">1</span>)  <span class="comment"># 得到上一级的索引位置</span></span><br><span class="line">        current = sum([m ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(level<span class="number">-1</span>)]) + current_level_idx // m  <span class="comment">#得到上一级的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MinWighet</span><span class="params">(n,m,d,price,weight)</span>:</span></span><br><span class="line">    minweight = float(<span class="string">"inf"</span>)</span><br><span class="line">    <span class="comment"># 子集树中的节点数</span></span><br><span class="line">    vec_len = sum([m ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>)]) + <span class="number">1</span></span><br><span class="line">    que = queue.Queue()</span><br><span class="line">    que.put(<span class="number">0</span>)</span><br><span class="line">    vec_price = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(vec_len)]</span><br><span class="line">    vec_weight = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(vec_len)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">not</span> que.empty()):</span><br><span class="line">        current = que.get()  <span class="comment"># 得到当前扩展节点（索引号）</span></span><br><span class="line">        level = getlevel(m, current)  <span class="comment"># 当前 扩展节点所在的level</span></span><br><span class="line"></span><br><span class="line">        idx = get_idx(m, current)   <span class="comment"># 得到当前扩展节点，所对应的首个子节点所在的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 若搜索完了整棵树</span></span><br><span class="line">        <span class="keyword">if</span> getlevel(m, current) == getlevel(m, vec_len)<span class="number">-1</span>:</span><br><span class="line">            minweight = vec_price[current]</span><br><span class="line">            min_at_idx = current</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">not</span> que.empty()):</span><br><span class="line">                <span class="comment"># minweight = min(minweight, vec_price[que.get()])</span></span><br><span class="line">                tmp = que.get()</span><br><span class="line">                <span class="keyword">if</span> minweight &gt; vec_price[tmp]:</span><br><span class="line">                    minweight = vec_price[tmp]</span><br><span class="line">                    min_at_idx = tmp</span><br><span class="line">            path = get_path(m, min_at_idx)</span><br><span class="line">            <span class="keyword">return</span> minweight, path</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断当前的扩展结点下的所有子节点是否可以加入活结点队列中</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            vec_price[idx] = int(vec_price[current] + price[level][i])</span><br><span class="line">            <span class="keyword">if</span> vec_price[idx] &lt;= d:</span><br><span class="line">                vec_weight[idx] = int(vec_weight[current] + weight[level][i])</span><br><span class="line">                que.put(idx)</span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(MinWighet(n,m,d,price,weight))</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>2） 优先级队列式分支限界法</p><p>解空间：子集树，每个分支节点的分支数为m<br>解向量：x[1:n]  n为部件数量， x[i] 表示第i个部件使用哪个供应商。</p><p>算法：采用优先队列式分支限界法。<br>类似于单源最短路径，使用当前节点所确定下的采购方案对应的机器重量和最为优先级。<br>由于wij不是负值，当前节点所对应的当前机器重量和是解空间中以该节点为根的子树的中所有节点所对应的重量和的下界。</p><p>算法代码实现：</p><p>1）使用列表来代表队列，通过对列表中的活结点按照其当前重量和进行从小到大排序（实现了最小堆的维护）<br>2）定义一个节点类，属性有：节点所在的索引，以及节点当前的重量和<br>3）取出一个扩展节点：由于对活结点表进行了某种规则的排序，则直接取出列表的第一个元素即可<br>4）加入活结点表：将满足条件的子节点加入到活结点表中</p><p>失活当前扩展节点：删掉列表中的第一个元素即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 普通的FIFO 队列式分支限界法</span></span><br><span class="line"><span class="comment">## 当 不满足总价格不超过d的要求时，则剪枝</span></span><br><span class="line"><span class="comment">## 当搜索到深度n时，即搜索到了叶节点，不再进行扩展节点的操作，而是针对于叶节点所对应的最小值，</span></span><br><span class="line"><span class="comment"># 反向求得该节点所对应的的路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入优先级--使用当前节点的重量作为优先级，重量小优先级高</span></span><br><span class="line"><span class="comment"># 将队列改成列表，以append的方式加入到列表中，再以排序的方式维护当前列表的首个元素为最小权值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># coding : utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到当前扩展节点所在的Level</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getlevel</span><span class="params">(m, currrent)</span>:</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    level = <span class="number">0</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> currrent == <span class="number">0</span>:</span><br><span class="line">        level = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> level</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">        level = level+<span class="number">1</span></span><br><span class="line">        sum = m**level + sum  <span class="comment"># sum=m</span></span><br><span class="line">        <span class="keyword">if</span> sum-m**level &lt; currrent &lt;= sum:  <span class="comment"># m-m^0 = m-1</span></span><br><span class="line">            <span class="keyword">return</span> level</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到当前扩展节点，所对应的首个子节点所在的索引</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_idx</span><span class="params">(m, current)</span>:</span></span><br><span class="line">    level = getlevel(m, current)</span><br><span class="line">    <span class="comment"># 求current 在该level中的相对索引，即 相对于该level第一个元素的位置</span></span><br><span class="line">    current_level_idx = current - sum([m**i <span class="keyword">for</span> i <span class="keyword">in</span> range(level)])</span><br><span class="line">    <span class="comment"># 子节点所在层的开始绝对索引</span></span><br><span class="line">    start_idx  = sum([m**i <span class="keyword">for</span> i <span class="keyword">in</span> range(level+<span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> start_idx + current_level_idx*m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到最优解之后，反向查找其路径</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_path</span><span class="params">(m, current)</span>:</span></span><br><span class="line">    path = []</span><br><span class="line">    path.append(current%m)  <span class="comment"># from 1, not from 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        level = getlevel(m, current)</span><br><span class="line">        <span class="keyword">if</span> level == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> path[::<span class="number">-1</span>]</span><br><span class="line">        current_level_idx = current - sum([m ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(level)])  <span class="comment"># # 求current 在该level中的相对索引，即 相对于该level第一个元素的位置</span></span><br><span class="line">        path.append(current_level_idx // m + <span class="number">1</span>)  <span class="comment"># 得到上一级的索引位置</span></span><br><span class="line">        current = sum([m ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(level<span class="number">-1</span>)]) + current_level_idx // m  <span class="comment">#得到上一级的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为活结点表中的节点 定义了一个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, idx, weight)</span>:</span></span><br><span class="line">        self.idx = idx</span><br><span class="line">        self.weight = weight</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MinWighet</span><span class="params">(n,m,d,price,weight)</span>:</span></span><br><span class="line">    <span class="comment"># 子集树中的节点数</span></span><br><span class="line">    vec_len = sum([m ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>)]) + <span class="number">1</span></span><br><span class="line">    que = []</span><br><span class="line">    que.append(Node(<span class="number">0</span>,<span class="number">0</span>))  <span class="comment"># 在活结点表中加入根节点</span></span><br><span class="line">    <span class="comment"># vec_price = [0 for _ in range(vec_len)]</span></span><br><span class="line">    <span class="comment"># vec_weight = [0 for _ in range(vec_len)]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(que):  <span class="comment"># 当活结点表非空时</span></span><br><span class="line">        que = sorted(que, key=<span class="keyword">lambda</span> node: node.weight)  <span class="comment"># 类似于最小堆的维护</span></span><br><span class="line">        current = que[<span class="number">0</span>]  <span class="comment"># 得到当前扩展节点（索引号）</span></span><br><span class="line">        level = getlevel(m, current.idx)  <span class="comment"># 当前 扩展节点所在的level</span></span><br><span class="line"></span><br><span class="line">        new_node_idx = get_idx(m, current.idx)   <span class="comment"># 得到当前扩展节点，所对应的首个子节点所在的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 若搜索完了整棵树</span></span><br><span class="line">        <span class="keyword">if</span> getlevel(m, current.idx) == getlevel(m, vec_len)<span class="number">-1</span>:</span><br><span class="line">            minweight = current.weight</span><br><span class="line">            min_at_idx = current.idx</span><br><span class="line"></span><br><span class="line">            path = get_path(m, min_at_idx)</span><br><span class="line">            <span class="keyword">return</span> minweight, path</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断当前的扩展结点下的所有子节点是否可以加入活结点队列中</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> int(current.weight + price[level][i]) &lt;= d:</span><br><span class="line">                new_node = Node(new_node_idx, int(current.weight + weight[level][i]))</span><br><span class="line">                que.append(new_node)</span><br><span class="line">            new_node_idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将当前的扩展节点失活</span></span><br><span class="line">        <span class="keyword">del</span> que[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    n = <span class="number">3</span></span><br><span class="line">    m = <span class="number">3</span></span><br><span class="line">    d = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    price = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]]</span><br><span class="line">    weight = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]]</span><br><span class="line">    result = MinWighet(n,m,d,price,weight)</span><br><span class="line">    print(MinWighet(n,m,d,price,weight))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里给出两个解决方案：&lt;/p&gt;
&lt;p&gt;1）不使用优先级，简单使用队列式分支限界法&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/sp
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Grounded Video Description</title>
    <link href="http://yoursite.com/2019/05/10/Grounded-Video-Description/"/>
    <id>http://yoursite.com/2019/05/10/Grounded-Video-Description/</id>
    <published>2019-05-10T13:05:39.000Z</published>
    <updated>2019-05-12T09:50:06.760Z</updated>
    
    <content type="html"><![CDATA[<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><ul><li>这是CVPR 2019 做视频描述的一篇文章，该文的主要贡献是对已有的ActivityNet dense caption数据集进行加强—对其中的帧进行了object bbox的标注，这就为视频描述任务增加了非常有用的信息。</li><li>总的来说，<font color="#dd00dd">该文的出发点是：1. 利用object 信息来生成句子. 2. 希望生成的句子中的名词，在video中可以找到相对应的证据(object)。</font><br></li><li>grounded-based video description model ：联合生成的单词，并微调在description中生成的object。可以探索这种显式的监督对视频描述带来的益处，并与无监督（可能利用region feature，但是没有 penalize grounding）的方法进行对比。</li></ul><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><ul><li>video输出的句子中提到的object，并没有在该video中实际存在。那么为什么有这种现象，是因为前的视频描述模型是基于先验知识，在之前的训练过程中，存在一个视频与该视频有 similar contexts，从而使得输出的单词中涵盖了训练video中的obejct，而不是该video本身的object，导致了该现象。</li><li>因此本文的工作： 将句子中的名词与视频中的object一 一对应起来，这样就可以建立sentence 与 evidence of video 之间的联系。<br>这样可以<font color="#0099ff" size="5">在视频描述模型中使用这些object 信息</font>，同时，<font color="#0099ff" size="5">还可以评估模型</font>（“teaching models to explicitly rely on the corresponding evidence in the video frame  when generating words and evaluating how well models   are doing in grounding individual words or phrases they  generated.”）。<br>如：该模型生成的句子中的名词与已经标注的object是否是一 一对应的（即便一个模型说出争取的sentence，比如一个男孩正在玩耍，但是如果video中有多个个男孩，那么该sentence输出的一个男孩是指向哪一个呢？）。</li></ul><h2 id="标注bbox时的细节"><a href="#标注bbox时的细节" class="headerlink" title="标注bbox时的细节"></a>标注bbox时的细节</h2><ul><li>“we collect ActivityNet-Entities (short as ANet-Entities) which  grounds or links noun phrases in sentences with bounding  boxes in the video frames.”<br>“we only  annotate a single frame of the video for each noun phrase” 。<br>即， 是对照着已有的sentence中的名词对其进行加框(bbox)，而不是对该video中的所有示例进行标注。对于sentence中的一个名词只在一帧上进行标注（稀疏标注） </li></ul><h2 id="调研工作"><a href="#调研工作" class="headerlink" title="调研工作"></a>调研工作</h2><h3 id="1-结合object-feature-做captioning任务"><a href="#1-结合object-feature-做captioning任务" class="headerlink" title="1. 结合object feature 做captioning任务"></a>1. 结合object feature 做captioning任务</h3><ul><li><strong>当前的方法</strong>，主要是两步：（1）使用off-the-shelf 或者是fine-tuned 的 object detector 来得到 object proposals （2）对object features采用动态attention，或者是对region进行分类，然后送入 decoder中。</li><li><strong>存在的问题</strong>，使用现成的object detector 将会使得到的object proposals 更偏向于 source dataset , 而不是偏向于当前的视频描述target dataset。一种解决方案是针对于target dataset 来fine-tune object detector。但是这种那个方案需要大量的标注，尤其是对于video，数据量会更大，</li><li>因此提出了<font color="#0099ff" size="5" face="黑体">本文的方法(给出了fine-tune obejct detector的改进方案)</font>：“Instead of  fine-tuning a general detector, we transfer the object classification knowledge from off-the-shelf object detectors to  our model and then fine-tune this representation as part of  our generation model with sparse box annotations. ”。</li><li>在文章中的4.4节开头给出了具体的实现：已经得到了bbox，现在的目的是想要得到the class probability distribution for each region. 将在visual genome上预训练的detector迁移到我们的<strong>object classifier</strong> 任务上，另外关于classes集合，假定我们已经有了K个类别，则我们在Visual Genome中根据最近距离找到与其对应的classes。  定义一个softmax( Wx+b )的分类层，W 和 b 的初始化是预训练的detector的最后一个线性层（分类层）的参数值（W应该是根据找出的K个类别按照索引抽出的一个矩阵）。<h3 id="2-object-attention"><a href="#2-object-attention" class="headerlink" title="2. object attention"></a>2. object attention</h3></li><li>某些作者指出，attention model关注的region和人类的关注点并不一致，增加attention supervision几乎不能提高性能。另一方面，在feature map attention 上增加监督，是有益处的。</li><li>在该文作者的实验中，region attention with supervision 并不能带来性能的提升，作者分析，这可能是由于缺少object context 信息，因此<font color="#0099ff" size="5" face="黑体">该文作者在attention model中引入了基于context encoding 的self-attention</font>，这将会使得信息能够在被采样的视频帧中的regions 传递(我理解的是，region feature 不仅仅是单纯的从fc层中提取到的信息，同时也结合了其余信息来得到 grounding-aware region encoding， 在文章的4.3 以及 4.4节有关于<strong>R<sup>~</sup></strong> 的定义)。 </li></ul><h2 id="Description-with-Grounding-Supervision"><a href="#Description-with-Grounding-Supervision" class="headerlink" title="Description with Grounding Supervision"></a>Description with Grounding Supervision</h2><ul><li>这个框架包括三个模块: <strong>grounding</strong>, <strong>region attention</strong> and <strong>language generation</strong>.<br>grounding： 对于生成的word， 从video中检测到对应的visual clue。<br>region attention: 动态的将visual clue 形成一个high-level的视觉内容的表达，并将其送入decoder。   </li><li>这里包括三种方式来结合object-level supervision: <strong>region classification</strong>,  <strong>object grounding (localization)</strong>, and <strong>supervised attention</strong>.  </li><li><strong>（我的理解，supervised attention直接针对attention中的系数，查看与真实的对应关系，设计的这个loss对于视频描述生成由益处；object grounding 涉及到了region attention中的系数，因此与描述生成有一定的关联，反向传播可能是有益处的；region classification中设计的loss： 它的反向传播会更新M<sub>s</sub>( R ), 进一步作用于region encoding, 进一步作用于region attention 和 language generate；）</strong></li></ul><h3 id="Language-Generation-Module"><a href="#Language-Generation-Module" class="headerlink" title="Language Generation Module"></a>Language Generation Module</h3><ul><li>本文的decoder 部分采用 [1] 中提到的decoder，与bottom up[3] 的结构大致近似，但是<strong>在[1]中</strong>第二层 language lstm的输入部分，不仅包括attention of region feature， 还包括attention of 最后一个卷积层k girds的特征。对应到本文的视频描述任务上，第二层language lstm的输入，不仅包括attention of region features ，还包括 attention of frames features。即region attention 和 temporal attention</li><li>需要注意的是该文中使用的<font color="#0099ff" size="5" face="黑体">temporal attention</font>是[2]中提到的self-attention context encoder with Bidirectional GRU (Bi-GRU)，而不是[1]中使用的attention机制。</li><li><font color="#0099ff" size="5" face="黑体">region attention</font>采用的就是bottom up 中的attention结构</li><li>下面将[1] 中的原图贴一下：   <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2x5hlq801j30l20ezq4v.jpg">   </li></ul><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><h3 id="Region-proposal-and-features"><a href="#Region-proposal-and-features" class="headerlink" title="Region proposal and features"></a>Region proposal and features</h3><p>For each frame, we use a Faster  R-CNN detector [24] with ResNeXt-101 backbone [30] for  region proposal and feature extraction (fc6). The detector is  pretrained on Visual Genome。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] Neural baby talk. In CVPR 2018.<br>[2] End-to-end dense video captioning with masked transformer. In CVPR 2018.<br>[3] Bottom-up and top-down attention for image captioning and  visual question answering. In CVPR 2018.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;yaya&quot;&gt;&lt;a href=&quot;#yaya&quot; class=&quot;headerlink&quot; title=&quot;yaya&quot;&gt;&lt;/a&gt;yaya&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;这是CVPR 2019 做视频描述的一篇文章，该文的主要贡献是对已有的ActivityNet dense cap
      
    
    </summary>
    
      <category term="视频描述" scheme="http://yoursite.com/categories/%E8%A7%86%E9%A2%91%E6%8F%8F%E8%BF%B0/"/>
    
    
      <category term="视频描述" scheme="http://yoursite.com/tags/%E8%A7%86%E9%A2%91%E6%8F%8F%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>Spatio-Temporal Dynamics and Semantic Attribute Enriched Visual Encoding for Video Captioning（CVPR2019）</title>
    <link href="http://yoursite.com/2019/05/10/Spatio-Temporal-Dynamics-and-Semantic-Attribute-Enriched-Visual-Encoding-for-Video-Captioning-1/"/>
    <id>http://yoursite.com/2019/05/10/Spatio-Temporal-Dynamics-and-Semantic-Attribute-Enriched-Visual-Encoding-for-Video-Captioning-1/</id>
    <published>2019-05-10T10:31:48.000Z</published>
    <updated>2019-05-10T13:04:56.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul><li>我们的方法丰富视觉特征的<strong>时域动态temporal dynamics</strong>，通过在整个video上分层对CNN特征应用短的fourier 变换</li><li>从object detector 中提取高层语义，来丰富被检测object 的<strong>空间动态 spatial dynamics</strong></li><li>最终的表达映射到一个压缩的空间</li></ul><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul><li>object detector YOLO[1]</li><li>目标检测和C3D的输出层被用来得到高层语义属性，</li><li>提出的视觉特征包含检测的目标属性、目标发生的频率</li></ul><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>现有的video captioning model 一种使用平均池化得到特征，一种使用attention得到high level特征，但是这些视觉特征都是直接的被使用，则，这些方法没有充分利用CNN在视频字幕框架中的最新特性。我们的模型丰富了视觉特征，实验结果证明，该视觉特征与任意一个简单的语言模型相结合，可以提高其性能。</p><h2 id="Visual-Representation"><a href="#Visual-Representation" class="headerlink" title="Visual Representation"></a>Visual Representation</h2><ul><li>the visual representation of a  video V as v = [α; β; γ; η]</li><li>α; β; γ; η 是四个列向量，下面具体介绍如何得到这四个列向量<h3 id="Encoding-temporal-dynamics"><a href="#Encoding-temporal-dynamics" class="headerlink" title="Encoding temporal dynamics"></a>Encoding temporal dynamics</h3></li><li>首先已经有 f 帧 对应的CNN[2]特征向量，和c个clip对应的C3D[3]得到的特征向量</li><li>对某个video而言，其所有帧再某一个维度的神经元，组成了一个特征向量a，利用<strong>傅里叶变换</strong>得到一个p维度的特征向量，将a分成两半，分别进行傅里叶变换，得到一个p维度的特征向量，再次进行分半，等等一系列操作，可以得到 p×7的矩阵。则对于所有的神经元m 则得到m×p×7的张量。至此得到<strong>α</strong></li><li><strong>β</strong>同理，只是对clips对应的C3D特征进行处理</li><li>目前已经有将傅里叶变换应用在行为识别上的文章吗，但是本文是第一篇将傅里叶变换应用在视频描述上的文章。</li><li><font color="#0099ff" size="4" face="黑体">但是需要注意的是，该文并没有说明使用傅里叶变换的动机（rich temporal dynamics?），但是为什么使用傅里叶变换可以丰富？？</font></li></ul><h3 id="Encoding-Semantics-and-Spatial-Evolution"><a href="#Encoding-Semantics-and-Spatial-Evolution" class="headerlink" title="Encoding Semantics and Spatial Evolution"></a>Encoding Semantics and Spatial Evolution</h3><ul><li>比较复杂，利用object detector YOLO 来提取Object 以及C3D来加强语义信息，具体看论文吧</li></ul><h2 id="Experimental-Results-on-MSVD"><a href="#Experimental-Results-on-MSVD" class="headerlink" title="Experimental Results on MSVD"></a>Experimental Results on MSVD</h2><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2wd8q6kegj30dh0ig0wc.jpg">    <ul><li>GRU-MP - (C3D) 与 使用了傅里叶变换的GRU-EVEhft - (C3D)  相比，可知，使用傅里叶变换是有小鬼的</li><li>GRU-EVEhft - (CI) 与GRU-EVEhft+sem - (CI)相比，可得增加的senmatic 效果是不显著的。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] Yolo9000: better, faster, stronger.  In IEEE CVPR, 2017<br>[2] Inception-v4, inception-resnet and the impact of residual  connections on learning. In AAAI, volume 4, page 12, 2017.<br>[3] Learning spatiotemporal features with 3d convolutional networks. In Proceedings of the IEEE international conference  on computer vision, pages 4489–4497, 2015.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;我们的方法丰富视觉特征的&lt;strong&gt;时域动态temporal dynamic
      
    
    </summary>
    
      <category term="视频描述" scheme="http://yoursite.com/categories/%E8%A7%86%E9%A2%91%E6%8F%8F%E8%BF%B0/"/>
    
    
      <category term="视频描述" scheme="http://yoursite.com/tags/%E8%A7%86%E9%A2%91%E6%8F%8F%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>python-dict</title>
    <link href="http://yoursite.com/2019/05/08/python-dict/"/>
    <id>http://yoursite.com/2019/05/08/python-dict/</id>
    <published>2019-05-08T12:29:19.000Z</published>
    <updated>2019-05-08T12:32:17.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dict-的get-函数"><a href="#dict-的get-函数" class="headerlink" title="dict 的get 函数"></a>dict 的get 函数</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Python 字典(Dictionary) get() 函数返回指定键的值，如果值不在字典中返回默认值。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>get()方法语法：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict.<span class="builtin-name">get</span>(key, <span class="attribute">default</span>=None)</span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li>key – 字典中要查找的键。</li><li>default – 如果指定键的值不存在时，返回该默认值值。</li></ul><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>返回指定键的值，如果值不在字典中返回默认值None。</p><h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><p>get函数的作用是返回指定key的值，若key不存在，则返回default值，default值，默认为None，也可以自己指定</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;dict-的get-函数&quot;&gt;&lt;a href=&quot;#dict-的get-函数&quot; class=&quot;headerlink&quot; title=&quot;dict 的get 函数&quot;&gt;&lt;/a&gt;dict 的get 函数&lt;/h1&gt;&lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Show, Attend and Tell: Neural Image Caption Generation with Visual Attention</title>
    <link href="http://yoursite.com/2019/05/06/Show-Attend-and-Tell-Neural-Image-Caption-Generation-with-Visual-Attention/"/>
    <id>http://yoursite.com/2019/05/06/Show-Attend-and-Tell-Neural-Image-Caption-Generation-with-Visual-Attention/</id>
    <published>2019-05-06T02:32:38.000Z</published>
    <updated>2019-05-06T02:35:54.998Z</updated>
    
    <content type="html"><![CDATA[<ul><li>encoder  attention<br>本文的出发点是利用低层次的特征，并结合了attention 机制<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2re7nfbn3j30q70430sx.jpg"></li></ul><p>参考链接：<a href="https://blog.csdn.net/shenxiaolu1984/article/details/51493673" target="_blank" rel="noopener">https://blog.csdn.net/shenxiaolu1984/article/details/51493673</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;encoder  attention&lt;br&gt;本文的出发点是利用低层次的特征，并结合了attention 机制&lt;img src=&quot;http://ww1.sinaimg.cn/large/006uWRWVly1g2re7nfbn3j30q70430sx.jpg&quot;&gt;

      
    
    </summary>
    
      <category term="图像描述" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E6%8F%8F%E8%BF%B0/"/>
    
    
      <category term="图像描述" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E6%8F%8F%E8%BF%B0/"/>
    
  </entry>
  
</feed>
