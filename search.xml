<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>A Closer Look at the Robustness of Vision-and-Language Pre-trained Models</title>
    <url>/2021/02/24/A-Closer-Look-at-the-Robustness-of-Vision-and-Language-Pre-trained-Models/</url>
    <content><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>大规模的预训练多模态transformer将最新的视觉-语言任务推进到了一个新的高度。虽然在标准任务上实现了令人印象深刻的性能，但是，迄今为止，任然不清楚这些预训练模型的鲁棒性。</p>
<p>为了进行调查，我们针对现有的预训练模型对4种不同类型的V + L特定模型的鲁棒性进行了全面的评估：(i) Linguistic Variation; (ii) Logical Reasoning; (iii) Visual Content Manipulation; and (iv) Answer Distribution Shift. 有趣的是，by standard model finetuning，预训练的V+L模型相比于task-specific 模型展示出更好的鲁棒性。</p>
<p>为了<strong>进一步增强模型的鲁棒性</strong>，本文提出了<strong>MANGO</strong>，一个具有泛化性且鲁棒的方法，可以在embedding space 学习a Multimodal Adversarial Noise GeneratOr 以愚弄pre-trained V+L models。与以往针对一种特定类型的鲁棒性的研究不同，MANGO具有任务不可知性，并且可以针对各种任务（旨在评估鲁棒性的广泛方面）对预训练模型进行通用性能提升。</p>
<p> 全面的实验表明，MANGO在9个鲁棒性基准中有7个达到了最新水平，大大超过了现有方法。</p>
<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p>当前的 V+L pre-tranining model取得了很大的进展在各种 V+L tasks，但是这些benchmark 在测试集和数据集上的分布常常是相似的，textual query 几乎没有 linguistic variation, 使用干净的自然图像，而没有任何visual content manipulation。 因此，尽管这些标准基准对于通用模型评估有效，但仍<strong>缺乏明确评估模型鲁棒性的能力</strong>。（在本文中，我们不关注 adversarial robustness，<strong style="color:red;">因为目前没有可用的adversarial benchmark</strong>。因此，我们在已有的robustness benchmark上进行观测，这些benchmark 设有挑战性的设置，并且经过了人类的验证）</p>
<p>(i) VQA-Rephrasings[56] for <strong>linguistic variation</strong>;</p>
<p>(ii) VQA-LOL (Compose and Supplement) [18], VQA-Introspect [54] and GQA [25] for <strong>logical reasoning</strong>; </p>
<p>(iii) IV-VQA and CVVQA [2] for <strong>visual content manipulation</strong>;  </p>
<p>(iv) VQA-CP v2 [3] and GQA-OOD [31] for <strong>answer distribution shift</strong>.</p>
<h3 id="当前方法存在的问题"><a href="#当前方法存在的问题" class="headerlink" title="当前方法存在的问题"></a>当前方法存在的问题</h3><p>VILLA，在multimodal embedding 加入对抗扰动，<strong>projected gradient descent（PGD） attack training（AT）</strong> 可以在 linguistic variation and visual content manipulation 增强鲁棒性，但是在训练集和测试集之间有显著的数据分布差异时，会有收效甚微的影响甚至drop model performence。</p>
<h3 id="本文方法简介"><a href="#本文方法简介" class="headerlink" title="本文方法简介"></a>本文方法简介</h3><p>为了在所有方面都实现鲁棒性，本文提出了 MANGO，通过在multi-modal embedding space 引入adversarial noise来增强鲁棒性。</p>
<p><img src="https://i.loli.net/2021/02/24/yDSgc5JwWFHCU8h.png" alt="image-20210224120151245"></p>
<p>如图 figure 1a所示，不使用PGD来生成对抗扰动，而是使用一个基于可训练神经网络来学习一个adversarial noise generator。与 VILLA相同，在embedding space 加入扰动，因为本文的目标 是对抗训练的最终结果，而不是制造对抗样本。</p>
<p>【1】本文要学习的是一个 universial noise generator，但是在VILLA中使用的PGD方法是针对每个特定样本来生成的，本文提出的noise generator 是通用的，对输入训练样本是不加区别的。【2】而PGD的方法是<strong>耗时</strong>的，而本文提出的方法是轻量级的，不需要梯度计算中的重复迭代。同时，为了使能多样性的对抗embedding，本文进一步提出随机对image regions 和 textual tokens掩码。</p>
<h3 id="本文的贡献"><a href="#本文的贡献" class="headerlink" title="本文的贡献"></a>本文的贡献</h3><ul>
<li>第一个系统性的分析pre-trained V+L 模型的鲁棒性</li>
<li>提出了 MANGO，一个generic and efficient 对抗训练方法来增强 V+L model 鲁棒性</li>
<li>实验结果证明了本文提出方法的鲁棒性。</li>
</ul>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><h4 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h4><p>Perturbing clean images with Gaussian noise. we use Gaussian noise augmentation as a simple baseline to investigate model robustness under V+L setting. Instead of adding noise to raw image pixels as in [52], we add perturbations directly to the embeddings.</p>
<h4 id="Adversarial-Noise-Generator-our"><a href="#Adversarial-Noise-Generator-our" class="headerlink" title="Adversarial Noise Generator (our)"></a><strong>Adversarial Noise Generator</strong> (our)</h4><p>Adding Gaussian noise to clean image-text pairs 可以补充训练样本。但是，随着训练的持续，模型可以逐渐的适应这种扰动，因为扰动都是从同一个 Gaussian noise distribution 中采样来的。</p>
<p>为了得到 harder perturbations，本文提出了一个可学习的 adversarial noise generator。对抗性噪声发生器将高斯噪声样本作为输入，通过可学习神经网络产生对抗性噪声样本。</p>
<p>Intuitively, to maximally fool the backbone network, 【1】we want to <strong>maximize prediction errors on these adversarially perturbed samples.</strong> 【2】In the meantime, we want the model to possess <strong>less confidence in its predictions on perturbed samples</strong> than clean samples, to promote harder adversarial examples。因此，<strong>adversarial noise generator 的目标是</strong>最大化这两个损失的求和：【1】task-speficic loss 【2】KL loss, which measures the distance between the predicted answer distribution of perturbed samples and that of clean samples.</p>
<p>另一方面，the trained model 旨在通过将对抗性生成的嵌入作为数据增强来最大程度地减少这两种损失。</p>
<p>综合上述两种方面，提出了如下的min-max game:</p>
<script type="math/tex; mode=display">
\min _{\boldsymbol{\theta}} \max _{\boldsymbol{\phi}_{v}(\boldsymbol{v}, \boldsymbol{w}, \boldsymbol{y}) \sim \mathcal{D} \boldsymbol{\alpha} \in \mathcal{N}(\mathbf{0}, \mathbf{1})} \mathbb{E}\left[\mathcal{L}_{s t d}\left(\boldsymbol{\theta}, \boldsymbol{\phi}_{v}\right)+\beta \mathcal{R}_{k l}\left(\boldsymbol{\theta}, \boldsymbol{\phi}_{v}\right)\right]</script><p>where $\beta$ is a hyper-parameter, and</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\mathcal{L}_{s t d}\left(\boldsymbol{\theta}, \boldsymbol{\phi}_{v}\right)=\mathcal{L}_{\mathrm{BCE}}\left(f_{\boldsymbol{\theta}}\left(\boldsymbol{v}+g_{\boldsymbol{\phi}_{v}}(\boldsymbol{\alpha}), \boldsymbol{w}\right), \boldsymbol{y}\right) \\
\mathcal{R}_{k l}\left(\boldsymbol{\theta}, \boldsymbol{\phi}_{v}\right)=\mathcal{L}_{k l}\left(f_{\boldsymbol{\theta}}\left(\boldsymbol{v}+g_{\phi_{v}}(\boldsymbol{\alpha}), \boldsymbol{w}\right), f_{\boldsymbol{\theta}}(\boldsymbol{v}, \boldsymbol{w})\right)
\end{array}</script><p>在训练时，迭代跟新 an outer loop of the backbone network and an inner loop of noise generator.</p>
<p>本文提出的adversarial noise generator 是轻量级的，仅仅存在 a few linear layers。相比于一个深层模型，这种轻量模型更容易陷入局部最优。因此，定期地，we replace the learned noise generator with a new one trained from scratch。每次，new  generator is trained against the latese learned parameters of the backbone.</p>
<h4 id="Random-Masking"><a href="#Random-Masking" class="headerlink" title="Random Masking"></a>Random Masking</h4><p>虽然 adversarial noise generator 可以产生具有挑战性，更加多样化的噪声扰动，但是不会改变训练样本的内在统计（例如，问题长度和image regions的分布）。然而，实际上，在robustness benchmark 的训练和测试集中存在这种 significant mismatch。比如，the average length of questions in VQA-LOL 测试集是VQA V2 训练集的 2-3倍。</p>
<p>为了补偿这种统计上的不匹配，我们建议在向图像和单词嵌入中添加对抗性噪声时，<strong>随机掩盖图像区域</strong> and <strong>随机插入[MASK]令牌</strong>。</p>
<h3 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h3><p>进行实验分析了 pre-trained V+L model 的鲁棒性和 本文提出的MANGO framework 的有效性。本文使用UNITER作为 backbone，并将 MANGO与 UNITER和 VILLA 在9个 robustness datasets + VQA v2 dataset上进行了比较。本文在这10个 benchmark上进行研究，<strong style="color:red;"><strong>因为目前在其他任务上没有这种 robustness dataset。</strong></strong></p>
<p>VILLA 在预训练阶段和微调阶段都采用了 对抗训练，而本文只是在微调阶段（即针对特定任务）</p>
<p><img src="https://i.loli.net/2021/02/25/HwjDn2voZfWKFOk.png" alt="image-20210225095811994"></p>
<h3 id="Future-Work"><a href="#Future-Work" class="headerlink" title="Future Work"></a>Future Work</h3><p>investigate the adversarial robustness of pre-trained V+L models.</p>
<p>（在本文中，我们不关注 adversarial robustness，<strong style="color:red;">因为目前没有可用的adversarial benchmark</strong>。因此，我们在已有的robustness benchmark上进行观测，这些benchmark 设有挑战性的设置，并且经过了人类的验证）</p>
]]></content>
      <categories>
        <category>cross-modal</category>
        <category>对抗</category>
      </categories>
      <tags>
        <tag>cross-modal,对抗</tag>
      </tags>
  </entry>
  <entry>
    <title>A Novel Graph-based Multi-modal Fusion Encoder for Neural Machine Translation</title>
    <url>/2021/02/26/A-Novel-Graph-based-Multi-modal-Fusion-Encoder-for-Neural-Machine-Translation/</url>
    <content><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul>
<li>当前主流的multi-modal NMT models 不能充分利用不同模态语义单元之间的<strong>细粒度的语义对应。</strong></li>
<li>在本文中，提出了一个新颖的graph-based  cross-modal fusion encoder 来处理NMT task。具体地，（1）首先使用一个 unified multi-modal graph来编码input sentence and image。这种方式可以捕获到多模态语义单元（words and visual objects）之间各种语义关系。（2）使用多个 graph-based multi-modal fusion layers 来迭代的执行语义交互，以学习node representations。（3）以上获得的contextual representations 送入decoder中。</li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul>
<li><p>该任务的重要性，有很多现实的应用：包括翻译多媒体新闻，Web产品信息和电影字幕。</p>
<blockquote>
<p>A visual attention grounding neural model for multimodal machine translation.</p>
</blockquote>
</li>
<li><p>该任务对于提高机器翻译的准确性有作用：视觉环境有助于解决歧义的多义词。</p>
<blockquote>
<p>Distilling translations with visual awareness.</p>
</blockquote>
</li>
</ul>
<p>很显然，再在 multi-modal NMT 中，如何有效的利用视觉信息是一个核心的问题。</p>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p><img src="https://i.loli.net/2021/02/26/7IOXHm89QM5DNq4.png" alt="Untitled"></p>
<h3 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h3><ul>
<li><p>Multi-modal Graph</p>
<p><img src="https://i.loli.net/2021/02/26/w1vmXMebCR3Kt5y.png" alt="Untitled3"></p>
<ul>
<li><p>所有的单词都作为 textual nodes。使用Stanford parser来找到文本中的所有名词，然后使用 visual grounding tookit来检测 bbox，并作为visual nodes。</p>
<blockquote>
<p>visual grounding tookit: <strong>A fast and accurate one-stage approach to visual grounding</strong></p>
</blockquote>
</li>
<li><p>在 multi-modal graph中使用了两种类型的edges。<strong>intra-modal edge(fully-connected)</strong> and <strong>inter-modal edge(partly-connected)</strong></p>
</li>
</ul>
</li>
<li><p>Embedding Layer</p>
<ul>
<li>Before inputting the multi-modal graph into the stacked fusion layers，首先获得其初始特征。</li>
<li>对于textual modes， 使用word embedding 和 position embedding 的求和。</li>
<li>对于visual nodes，使用Faster-RCNN提取 roi pooling layer 的特征，然后使用MLP + RELU 将视觉特征映射到与文本特征相同的空间。</li>
</ul>
</li>
<li><p>Graph-based Multi-modal Fusion Layers</p>
<ul>
<li>On the top of embedding layer, stack multiple graph-based multimodal fusion layers to encode the above-mentioned multi-modal graph.</li>
<li>在每个融合层，序列地实施模态内和模态间的融合，来更新所有的节点状态。这种方式，可以使得最终的节点状态能够同时编码到相同模态和跨模态的语义信息。</li>
<li>由于视觉节点和文本节点是包含了不同模态信息的两种语义单元。因此，使用相同的操作，但是不同的参数（不共享）来更新它们的节点状态。</li>
</ul>
</li>
</ul>
<h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><ul>
<li><p>Our decoder is similar to the conventional Transformer decoder。堆叠多个相同的层来生成 target-side hidden states，每一层由三个子层组成。</p>
<p>前两个子层是一个masked self-attention 和 一个encoder-decoder attention 来分别聚合target-side and source-side contexts。</p>
<p>最后由a position-wise fully-connected forward neural network 和 线性变化来生成next-step predict word。</p>
</li>
</ul>
<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><ul>
<li>与本文类似的模型结构有以下两篇</li>
</ul>
<blockquote>
<p>Multi-Modality Cross Attention Network for Image and Sentence Matching</p>
<p>(LXMERT) LXMERT Learning Cross-Modality Encoder Representations from Transformers</p>
</blockquote>
]]></content>
      <categories>
        <category>cross-modal</category>
        <category>image-guided MT</category>
      </categories>
      <tags>
        <tag>cross-modal,image-guided MT</tag>
      </tags>
  </entry>
  <entry>
    <title>A negative case analysis of visual grounding methods for VQA</title>
    <url>/2020/04/15/A-negative-case-analysis-of-visual-grounding-methods-for-VQA/</url>
    <content><![CDATA[<h4 id="yaya简述"><a href="#yaya简述" class="headerlink" title="yaya简述"></a>yaya简述</h4><p>在VQA任务中，现在的方法尝试希望模型在回答问题时，同时能够关注到相对应的正确的物体（出发点：当模型关注到正确的物体时，能够更好的帮助模型选择出正确的答案）。于是，基于这样的方式，提出了一些方法 [1] [2]. 但是本文发现即便在模型中给了vision grounding 的监督，但是模型的grounding 能力却未必很好。那么提升VQA性能的真正原因其实是这个监督，仅仅是一种正则化效果。</p>
<p>作者使用了Grounding using irrelevant cues；Grounding using fixed random cues；Grounding using variable random cues 来说明，即使是错误的监督信息，相比于正确的监督也不会使得性能下降很多。</p>
<p>作者使用Regularization by zeroing out answers  来说明，给损失函数中加一个正则化项，使得training accuracy下降，就会达到正则化的效果，其VQA的性能与用grounding 监督的效果差距也不大。这就证明了使用grounding来监督，其实仅仅是起到了正则化的效果。</p>
<h4 id="Future-work"><a href="#Future-work" class="headerlink" title="Future work"></a>Future work</h4><ul>
<li><p>未来的方法必须设法通过使用与本文中介绍的类似的实验设置来验证性能增益不是源于spurious source.</p>
</li>
<li><p>创建一个数据集，使得能够评估  if methods are able to focus on relevant information.</p>
</li>
<li>Use tasks  that explicitly test grounding, e.g., in visual query detection an agent must output boxes around any regions of a scene that match the natural language query .</li>
</ul>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>[1] Ramprasaath R Selvaraju, Stefan Lee, Yilin Shen, Hongxia Jin, Shalini Ghosh, Larry Heck, Dhruv Batra, and Devi Parikh. <strong>Taking a hint: Leveraging explanations to make vision and language models more grounded.</strong>  In ICCV 2019. </p>
<p>[2] Jialin Wu and Raymond Mooney. <strong>Self-critical reasoning for robust visual question answering.</strong> In NeurIPS 2019</p>
]]></content>
      <categories>
        <category>Visual Grounding</category>
      </categories>
      <tags>
        <tag>Visual Grounding</tag>
      </tags>
  </entry>
  <entry>
    <title>A Survey of Evaluation Metrics Used for NLG Systems</title>
    <url>/2020/08/28/A-Survey-of-Evaluation-Metrics-Used-for-NLG-Systems/</url>
    <content><![CDATA[<h3 id><a href="#" class="headerlink" title=" "></a> </h3><h3 id="Recommendations-Possible-future-research-directions"><a href="#Recommendations-Possible-future-research-directions" class="headerlink" title="Recommendations (Possible future research directions)"></a>Recommendations (Possible future research directions)</h3><ul>
<li><p><strong style="color:blue;">为所有的评估指标构建一个通用的工具包</strong></p>
</li>
<li><p><strong style="color:blue;">构建一个包含 human judgments 的数据集。</strong></p>
<p>（1）human 会从不同的角度进行评估</p>
<p>（2）根据收集的数据，可以训练出来一个评价指标</p>
</li>
<li><p><strong style="color:blue;">提出 task-specific and context-dependent metrics</strong></p>
<p>类似于 dialog 这个任务，reference response 与 right prediction response 之间的word overlap 很小，因此，only reference dependent 的评价指标是有缺陷的，还需要结合 context 来设计评价指标</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gh954nipuej319z0k4q9z.jpg"></p>
</li>
<li><p><strong style="color:blue;">提出具有可解释性的评价指标</strong></p>
<p>当前大部分的评价指标， 对预测仅仅给出 a single score, 没有任何具体的指向。但是对于 human evaluation, 会从具体的层面，eg: fluency, adequency. coherence 来进行评价。因此 a single score 不够具有可解释性。</p>
<p>应该设计不同的评价指标，每一个评价指标，从特定的层面进行评价。</p>
</li>
<li><p><strong style="color:red;">Creating robust benchmarks for evaluating evaluation metrics </strong></p>
<p>early metrics, 例如，BLEU，METEOR 等，已经在各种各样的任务上进行了验证。</p>
<p>但是，最近新提出的评价指标还没有被 examined critically，为了实施这一研究，需要收集一个 <strong>对抗 evaluation benchmarks</strong>， <strong>这个 benchmarks可以测试这些metrics 的鲁棒性。</strong></p>
<p>举个例子：对于dialog，给定一个context， 可以收集一些 adversarially crafted responses（与 passage 有较高的 word overlap, 但实际上是不相关的，或者是不正确的）  。查看evaluation metrics 是否会对这种手工创造的对抗例子给<strong>低分</strong>，已验证其鲁棒性。</p>
<p><strong>除了这种 adversarial evaluations， 还需要研究 提出的evaluation metrics 是否有specific biases.</strong> 比如，GAN based evaluators 会在一些systems上进行训练，则其更容易对这些 systems 给高分。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
        <category>评价指标</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>(ACL 2019)Putting Evaluation in Context: Contextual Embeddings improve Machine Translation Evaluation</title>
    <url>/2020/04/01/ACL-2019-Putting-Evaluation-in-Context-Contextual-Embeddings-improve-Machine-Translation-Evaluation/</url>
    <content><![CDATA[<ul>
<li><p>没有认真阅读本篇文章，但是其中提到了尝试去拟合Human judgements，这一训练方案。</p>
<p> （1）We treat the human reference translation and the MT output as the premise and hypothesis, respectively 。</p>
<p>（2）Using squared error as part of regression loss – being better suited to Pearson’s r — and might be resolved through a different loss. Using hinge loss over pairwise preferences which would better reflect Kendall’s Tau</p>
</li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Adaptive Offline Quintuplet Loss for Image-Text Matching</title>
    <url>/2021/02/21/Adaptive-Offline-Quintuplet-Loss-for-Image-Text-Matching/</url>
    <content><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>现有的image-text matching 的方法一般使用<strong>在线</strong>负样本和三元组损失来训练模型。对于mini-batch中的 image 或 text anchor, 模型被训练以希望区分与anchor 相对应的 positive sample 和 most confusing negative sample。这种策略能够提高模型区分image 和 text 之间细粒度的对应或者是不对应。</p>
<p>但是，这种方法存在几个缺陷。（1）负样本的选择策略，给模型提供了较少的机会：从<strong>很难区分的样本</strong>中学习。（2）训练的模型从训练集到测试集的泛化性较差。（3）The penalty lacks hierarchy and adaptiveness for hard negatives with different “hardness” degrees。</p>
<p>在本文中，（1）我们提出了一个从整个训练集中采样 <strong>negative offline samples</strong> 的解决方法。这种方法，提供了 “harder” offline negatives than online hard negatives 让模型来区分。（2）基于 <strong>the offline hard negatives,</strong> 一个五元组损失被提出来，以提高模型的泛化性。（3）另外，提出了一个新颖的损失函数来结合 <strong>the knowledge of</strong> positives, online hard negatives and online hard negatives.</p>
<p>由于本文提出的方法，不是创建了一个新颖的模型，而是在采集样本与损失函数上做的改进，因此，本文在三个最好的模型上添加了本文提出的模块，并报告了实验结果，证明了本文提出方法的有效性。</p>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><ul>
<li>本文使用了<strong>两轮训练</strong>来增加<strong>offline “harder” negatives</strong>。在第一轮，本文使用原始的 online triple loss来训练matching model。 然后，使用训练好的模型，对于训练集中的 image or text anchor，模型预测它们与训练中的负样本的相似性分数，并对这些负样本进行排序。在第二轮，对于mini-batch 中的每个anchor，本文从 top negative list中采取采样offline negatives. 在这个过程中，多种offline hard negative pairs被构建，这些负样本与anchor之间共享或者不共享common elements。</li>
<li>进一步地，本文修改了损失函数，将offline hard negative pairs的信息融合到 online triplet loss中。The complete training loss实现了对(positive pairs， offline hard negatives、online hard negatives)  <strong>分等级</strong>和<strong>自适应</strong>的惩罚，</li>
</ul>
]]></content>
      <categories>
        <category>cross-modal</category>
        <category>Image-Text Matching</category>
      </categories>
      <tags>
        <tag>cross-modal,Image-Text Matching</tag>
      </tags>
  </entry>
  <entry>
    <title>Align2Ground: Weakly Supervised Phrase Grounding Guided by Image-Caption Alignment</title>
    <url>/2020/07/30/Align2Ground-Weakly-Supervised-Phrase-Grounding-Guided-by-Image-Caption-Alignment/</url>
    <content><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>本文提出使用caption-to-image retrieval 作为下游任务，来引导 phrase localization。</p>
<p>第一步，学习 RoIs 与 phrases 之间的隐式对应，并利用这些匹配的RoIs来生成具有判别性的image representation。</p>
<p>第二步，learnedd representaion 与caption 对齐。</p>
<p>本文的贡献是，构建了“caption-conditioned” image encodinng，这件所有的任务都耦合在一起，并使得弱监督可以有效的引导 visual grounding。</p>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><ul>
<li>监督学习的方法：依赖 region-phrase correspondence 数据。</li>
<li>弱监督：grounding free-form textual phrase，从image-caption pairs 这种weak correspondence中进行学习。</li>
</ul>
<p><strong>weakly supervised paradigm 的一个关键是，紧密耦合监督学习任务（image-caption matching）和无法获得显示标签的任务（region-phrase matching）。联合推理确保前者的监督损失可以有效的引导后者的学习。</strong></p>
<blockquote>
<p>[1] Andrej Karpathy and Li Fei-Fei. <strong>Deep visual-semantic alignments for generating image descriptions.</strong> In CVPR, 2015</p>
<p>[2] AndrejKarpathy,ArmandJoulin,andLiFFei-Fei. <strong>Deep fragment embeddings for bidirectional image sentence mapping.</strong> In NIPS,  2014</p>
</blockquote>
<p>[ 1 ] [ 2 ] 采用了 such paradigm，一般地，这种模型存在两个阶段：（1）local matching mudule: 得到 region-phrase 的隐式对应，进而生成local matching information.（2）gobal matching module: 使用（1）中得到的information来得到 image-caption matching.</p>
<p>需要注意的是，这种方案的设计，primary objective 是 image-caption matching 而不是 phrase matching。这种训练方式，将会放大selective regions 和 phrases 之间的相关性。举例说明：如果 第一阶段中，a small subset of phrases 存在很强的 match, 那么将会传递到第二阶段，<strong>via average pooling of the RoI–phrase matching scores</strong>, 使得image 和 caption 之间存在 high matching score。</p>
<p>这将会<strong>使得模型不去学习 准确的ground <strong style="color:red;">所有的</strong> phrases</strong>。分析可得，将visual grounding 作为 primary aim 不是一个有效的解决办法。<strong>这种“作弊”倾向，使模型学会了在下游任务上做得很好而不必在中间任务上做得更好。</strong></p>
<p>本文将这种现象称之为：“selective amplification” behavior</p>
<p>本文解决这个问题：我们通过提出一种novel mechanism 来解决这一问题，该机制以使两个阶段之间更紧密耦合的方式 to relay this information about the latent, inferred correspondences</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gh8vyf8slej30wt0q914q.jpg" style="zoom: 50%;"></p>
<p>Our novelty lies in designing this effective transfer of  information between the supervised and unsupervised parts  of the model such that the quality of image representations for the supervised matching task is a direct consequence of  <strong>the correct localization of all phrases.</strong> </p>
<h3 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a>Approach</h3><p>our proposed model uses a novel technique that builds a discriminative image representation from the matched RoIs and uses this representation for the image-caption matching. </p>
<p>Specifically, the image representation that is used to match an image with a caption is conditioned only on <strong style="color:red;">the subset of image regions</strong> that align semantically with <strong style="color:red;">all the phrases</strong> in that caption. </p>
<p>本文认为，与标准的 pooling-based method 相比，这种结构的设计使图像字幕对的监督，成为 visual grounding 的更强学习信号。</p>
<h4 id="The-Local-Matching-module"><a href="#The-Local-Matching-module" class="headerlink" title="The Local Matching module"></a>The Local Matching module</h4><p>将 region 和 phrase 映射到相同的空间，然后计算 cosine similarity。</p>
<p>infer the matched RoI for a phrase最直接的方法是 选择top scoring box，但是，这种方案容易<strong>过拟合</strong>，因为模型经常持续选择 相同的错误region。</p>
<p>改进：使用attened region vector 作为matched RoI，虽然这种方法在其他的多模态任务中是有效的，但在这个任务中不是一个有效的方法。这是因为在训练过程中，多个匹配的RoI的加权平均似乎会损害匹配的RoI的辨别力（discriminativeness）。</p>
<p>再次改进：选择 top-k (k=3) scoring RoI candidates，然后随机的选择其中的一个作为 query phrase 的 匹配 RoI。这种策略通过在巡林过程中探索多样性的选择，进而可以增加鲁棒性。</p>
<h4 id="The-Local-Aggregator-module"><a href="#The-Local-Aggregator-module" class="headerlink" title="The Local Aggregator module"></a>The Local Aggregator module</h4><p>这个模块的设计比较玄学。说是为了generate a caption-conditioned representation of the image.</p>
<p>设计的模块：a two-layer Multilayer Perceptron (MLP) with a mean operation. </p>
<p>这个模块的输入，是从上一步中得到的 matched RoIs for correspondance phrases.</p>
<h4 id="The-Global-Matching-module"><a href="#The-Global-Matching-module" class="headerlink" title="The Global Matching module"></a>The Global Matching module</h4><p>将 caption 映射到与 上一步中得到  representation of the image 相同的空间，然后利用 cosine similarity</p>
<h4 id="Loss-Function"><a href="#Loss-Function" class="headerlink" title="Loss Function"></a>Loss Function</h4><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gh939pfhcgj30tq040wen.jpg" style="zoom:33%;"></p>
<h3 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h3><p>motivation 挺好的 ，但是local aggregator 的设计比较朴素。</p>
]]></content>
      <categories>
        <category>Visual Grounding</category>
      </categories>
      <tags>
        <tag>Visual Grounding</tag>
      </tags>
  </entry>
  <entry>
    <title>Aligning Visual Regions and Textual Concepts for Semantic-Grounded Image Representations</title>
    <url>/2020/07/31/Aligning-Visual-Regions-and-Textual-Concepts-for-Semantic-Grounded-Image-Representations/</url>
    <content><![CDATA[<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p>Understanding the image, which necessitates the acquisition of grounded image representations. </p>
<p>以下，提供了几种方式来 表达image content.</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gha8v7kk80j316b0ciqmw.jpg"></p>
<p><strong style="color:blue;">[1]</strong> 基于 R-CNN 的方法可以获得 regions，但是却没有与 actual words关联起来，这将会造成两个域之间的语义不一致，并且需要由 downstream systems 自己学习 alignments。</p>
<p><strong style="color:blue;">[2]</strong> 此外，这些representations 仅包含局部特征，缺少全局结构信息。 这些问题 使system 难以有效地理解图像。</p>
<p>因此，本文提出一个 Mutual Iterative Attention (MIA) 模块，在编码阶段，从<strong style="color:red;">视觉域和语言域</strong>（解决[1]） 构建<strong style="color:red;">聚合的 image representations</strong>(解决[2])。</p>
<p>we perform mutual attention <strong style="color:blue;">iteratively </strong> between the two domains to realize the procedure <strong>without annotated alignment data.</strong> </p>
<p>The visual receptive fields gradually concentrate on salient visual regions, and the original word-level concepts are gradually merged to recapitulate corresponding visual regions. </p>
<p>In addition, the aligned visual features and textual concepts provide a more clear definition of the image aspects they represent. </p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gha9crz1pbj30de0s4jxg.jpg" style="zoom:50%;"></p>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gha9gjk5vbj31h50j3jvs.jpg"></p>
<h3 id="textual-concepts"><a href="#textual-concepts" class="headerlink" title="textual concepts"></a>textual concepts</h3><p>从下面这篇论文中提取 text concepts</p>
<blockquote>
<p> <strong>From captions to visual concepts and back.</strong> In CVPR, 2015</p>
</blockquote>
]]></content>
      <categories>
        <category>图像描述</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>An Empirical Study of Unsupervised Evaluation Metrics for Dialogue Response Generation</title>
    <url>/2020/07/01/An-Empirical-Study-of-Unsupervised-Evaluation-Metrics-for-Dialogue-Response-Generation/</url>
    <content><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>本文对 <code>对话响应生成系统的评估指标</code> 进行研究，这些对话响应生成系统没有监督标签。当前常采用的metric 采用了机器翻译任务中的metric，以将模型的生成响应与单个目标响应进行比较。</p>
<p>但是，本文发现，这些指标与非技术性Twitter领域中的人为判断之间的关联非常弱，而在技术性Ubuntu领域中则根本没有。（yaya: 即与human judgement的一致性很差）</p>
<p>本文提供定量和定性结果，<strong style="color:red;">突出显示现有指标中的特定弱点</strong> ，并为将来开发更好的对话系统自动评估指标提供建议。</p>
<h3 id="现有指标的缺陷"><a href="#现有指标的缺陷" class="headerlink" title="现有指标的缺陷"></a>现有指标的缺陷</h3><ul>
<li>从例子出发来进行阐述</li>
</ul>
<p>BLEU、METEOR、ROUGE，这些 metric 假设有效的答案与地面真实答案的单词重叠很大。对于对话系统，这是一个强有力的假设，在对话系统中，对给定上下文的有效响应空间存在很大差异。如下边的例子。</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ggbjo3dqgzj30rc0f3tam.jpg" style="zoom: 33%;"></p>
<p>在本文中，我们针对多种响应生成模型，研究了几种<strong>自动评估指标的得分</strong>与对话响应质量的<strong>人工判断</strong>之间的相关性。（即，也是进行了human judgement 数据的收集）</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ggbjvhzcnmj31gb0k24d8.jpg" style="zoom:50%;"></p>
<p>我们表明，这些指标在面向聊天的Twitter数据集上只有很小的正相关，而在技术性Ubuntu Dialogue语料库上则根本没有相关。</p>
<p>我们的结果表明，研究界必须改变这些指标，并强调需要一种与人类判断更紧密相关的新指标。</p>
]]></content>
  </entry>
  <entry>
    <title>An End-to-End Baseline for Video Captioning</title>
    <url>/2019/04/20/An-End-to-End-Baseline-for-Video-Captioning/</url>
    <content><![CDATA[<h3 id="积累梯度那里没有看明白-—-解决内存占用多的问题"><a href="#积累梯度那里没有看明白-—-解决内存占用多的问题" class="headerlink" title="积累梯度那里没有看明白 — 解决内存占用多的问题"></a>积累梯度那里没有看明白 — 解决内存占用多的问题</h3><p>我认为可能是积累 loss, 直到达到某一个batch size才进行反向传播<br>说是为了解决内存占用多的问题，可是这样，就解决了吗？？？</p>
<h3 id="灵魂反问"><a href="#灵魂反问" class="headerlink" title="灵魂反问"></a>灵魂反问</h3><p>为什么要是end-to-end，我最终需要的是一个效果比较好的模型，但是为了只得到这样的一点提升，反而会需要很多的GPU计算资源。这个end-to-end fine-tune 是否有必要。</p>
<h3 id="目前方法存在的问题"><a href="#目前方法存在的问题" class="headerlink" title="目前方法存在的问题"></a>目前方法存在的问题</h3><p>encoder：比如 CNN， 一般是在不同任务上的其他数据集上进行预训练的，之后，在训练video captioning任务时，得到的video/image feature就不再fine tune。这样得到的结果是次优的。<br>目前改进这一缺陷的文章有：[1][2][3]，他们尝试捕捉不同帧之间的动态时域，但是，他们没有从根本上改变一个事实：视频描述任务需要一个与该任务相关的特征。</p>
<h4 id="当前没有人去fine-tune-encoder的原因"><a href="#当前没有人去fine-tune-encoder的原因" class="headerlink" title="当前没有人去fine-tune encoder的原因"></a>当前没有人去fine-tune encoder的原因</h4><p>（1）because of the amount of memory required to process  video data for each batch。是因为每个批次都要处理视频数据，所需要的存储空间会很大。<br>（2）batch sizes for video captioning can become very high (e.g. 512), making training  prohibitive on a small number of GPUs。同时，视频描述的批次一般都比较大，使得所需要的GPU数量会很多。</p>
<h4 id="本文提取出的解决方案——即训练过程"><a href="#本文提取出的解决方案——即训练过程" class="headerlink" title="本文提取出的解决方案——即训练过程"></a>本文提取出的解决方案——即训练过程</h4><p>In this paper we address this issue by accumulating gradients over multiple steps, to update parameters only after  the required effective batch size is achieved.<br>在多步积累梯度，并只在达到有效的批次大小之后(当神经网络训练完512个examples)，才进行梯度更新。<br>这种训练方案相比于分别训练两部分收敛速度会慢，因为所需的迭代次数增加了。但是这里采用了一个加速训练过程的方案，先分别训练encoder和decoder，然后再end-to-end进行fine-tune。</p>
<h4 id="主要的贡献"><a href="#主要的贡献" class="headerlink" title="主要的贡献"></a>主要的贡献</h4><ol>
<li>可以得到与具体任务（视频描述）相关的特征</li>
<li>积累梯度来限制GPU存储消耗，因此可以处理大批次，这是基于RNN的decoders所需的。</li>
<li>使用了两阶段的训练来加速训练</li>
<li>为未来的工作，创建了一个简单的baseline</li>
</ol>
<h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><ol>
<li>先预训练encoder，例如利用图像识别、行为识别等</li>
<li>冻结encoder的参数，在视频描述任务上训练decoder，直到在验证数据集上表现出比较好的效果</li>
<li>整个网络，端到端的训练，冻结Inception-ResNet-v2中的BN层，由于该过程中占用的内存较多，作者采用了一种方法：accumulating gradients over multiple steps, to update parameters only after  the required effective batch size is achieved. </li>
</ol>
<ul>
<li>需要注意的是，在2. 3. 阶段的训练过程中，SA-LSTM都是使用target words(ground truth)作为输入，而不是使用之前的预测。</li>
</ul>
<h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p> Inception-ResNet-v2[5] as an encoder，and a modified version of  Soft-Attention LSTM as a decoder.<br> <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2ad637ykjj30hy0h677d.jpg">    </p>
<ul>
<li>decoder<ul>
<li>输入LSTM的input: <strong>x<sup>t</sup></strong> ：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2aeagi7o3j30a30280sl.jpg">    <ul>
<li>该step 生成的word：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2aeiriwanj30jd014mx7.jpg"></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>soft-attention这里，原文是采用attention机制进行加权求和 ，这里与原soft-attention[2] 略有不同。</p>
<ul>
<li><p>原soft-attention论文：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2aeagheogj308o03ct8l.jpg">     </p>
</li>
<li><p>现修改为：（增加了β<sub>t</sub>）</p>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2aeagka0rj30h504dq37.jpg"><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2aeaggzpdj309302xdfq.jpg">   </p>
<ul>
<li><font color="#0099ff" size="5" face="黑体">这里与Figure2 图中显示的结构并不一致，这里是全权求和，但是在图中却是concatenate !</font>

</li>
</ul>
<ul>
<li>还有一些其他的修改<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2aes6w62rj30il09xwgp.jpg"></li>
</ul>
<h3 id="实验效果"><a href="#实验效果" class="headerlink" title="实验效果"></a>实验效果</h3><ul>
<li>step1 : encoder先训练，然后固定encoder的参数，训练decoder的参数，不进行联合训练</li>
<li>step2：在step1的基础上，联合训练encoder-decoder。</li>
<li>MSR-VTT的实验结果<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2ajqfodpkj30kl0b9acc.jpg">  </li>
<li>MSVD的实验结果<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2ajqfqhbjj30ks0icn0q.jpg"></li>
</ul>
<h4 id="yaya：-本文step1训练效果比较好的原因（相较于soft-attention-lstm-原论文）"><a href="#yaya：-本文step1训练效果比较好的原因（相较于soft-attention-lstm-原论文）" class="headerlink" title=" yaya： 本文step1训练效果比较好的原因（相较于soft-attention lstm 原论文）"></a><font color="#0099ff" size="5" face="黑体"> yaya： 本文step1训练效果比较好的原因（相较于soft-attention lstm 原论文）</font></h4><p>这里step1的意思是：encoder、decoder 分开训练，并不进行联合训练</p>
<ol>
<li>该文使用的 Inception-ResNet-v2作为encoder来提取特征。会比其他论文中使用的encoder更复杂。</li>
<li>初始化的细节<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2ak8as8u4j309703pglo.jpg"></li>
<li>对SA-LSTM[2]而言，进行了一些修改：<br>（1）frame features 转为一个特征向量，使用的注意力机制，但是该文在soft-attention的基础上，还增加了一个系数β<sub>t</sub><br>（2）LSTM的内部结构的计算公式增加了一项，如下图<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2ajg7vn8rj31fi0ci427.jpg"><br>（3）在生成word时，主要差别就是E[y<sub>t-1</sub>]前边是否有权重的问题<ul>
<li>soft-attention 使用的公式：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2aeiriwanj30jd014mx7.jpg"></li>
<li>但是在本文中使用的公式为：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2ajjxtsplj30d103v74i.jpg"><ul>
<li>但是就该文3.3.2节中说：These changes are inspired by  the original code repository by Yao et al [2]，也就是有可能人家的源代码和在论文中提到的不一致。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1] Video captioning with  transferred semantic attributes. CVPR, 2017<br>[2] Describing videos by exploiting temporal  structure. ICCV, 2015.<br>[3] Task-driven dynamic fusion: Reducing ambiguity in video description. CVPR, 2017.<br>[4] Show and  tell: Lessons learned from the 2015 mscoco image captioning challenge. TPAMI, 2016.<br>[5] Inception-v4, inception-resnet and the impact of residual  connections on learning. AAAI, 2017</p>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>[All NLP Tasks Are Generation Tasks] A General Pretraining Framework</title>
    <url>/2021/03/20/All-NLP-Tasks-Are-Generation-Tasks-A-General-Pretraining-Framework/</url>
    <content><![CDATA[<h2 id="yaya-总结"><a href="#yaya-总结" class="headerlink" title="yaya 总结"></a>yaya 总结</h2><ul>
<li><p>模型结构上</p>
<p><strong style="color:red;">GLM 采用的是Transformer Model 中decoder 结构，而BERT采用的是 encoder 结构</strong></p>
</li>
<li><p>预训练任务上：<br>提出了两个 multi short span recover (benefit for NLU) and  a single longer span recover (benefit for NLG) 的预训练任务。</p>
<p>与这篇做 text filling 论文很相似：Enabling Language Models to Fill in the Blanks</p>
</li>
<li><p>下游任务的微调：</p>
<p>受到[1] [2] 的启发， 将分类任务转化为文本生成的填空任务。</p>
</li>
</ul>
<h2 id="1-存在的问题"><a href="#1-存在的问题" class="headerlink" title="1. 存在的问题"></a>1. 存在的问题</h2><p>目前基于预训练 的语言模型大致分为三类：</p>
<ul>
<li>autoregressive models (e.g.,GPT) 擅长长文本生成</li>
<li>autoencoding models (e.g., BERT) 擅长理解型任务，分类任务</li>
<li>encoder-decoder models (e.g., T5) 擅长基于条件的文本生成任务，比如 text summarize</li>
</ul>
<p>但是目前还未存在一个预训练框架可以在这三种任务上同时表现出优异的性能。这给模型的开发和选择带来了不便。</p>
<p>下表总结了不同的预训练框架可以处理的任务：</p>
<p><img src="https://i.loli.net/2021/03/20/ldKAem71a86xBcq.png" alt="image-20210320100920079" style="zoom: 25%;"></p>
<p>先前的工作试图通过多任务学习将各自的 objective 结合起来，从而统一不同的框架。但是，自回归和自编码的 objective 在本质上是不同的，简单的结合不能够充分的揭示所有框架的优势。</p>
<h2 id="2-本文的点"><a href="#2-本文的点" class="headerlink" title="2. 本文的点"></a>2. 本文的点</h2><h3 id="2-1-新颖的预训练框架GLM"><a href="#2-1-新颖的预训练框架GLM" class="headerlink" title="2.1 新颖的预训练框架GLM"></a>2.1 新颖的预训练框架GLM</h3><p>本文提出了一个新颖的预训练框架GLM（General Language Model）来解决这个问题。如图1。</p>
<p><img src="https://i.loli.net/2021/03/20/VrzfCnOFQi27NRU.png" alt="image-20210320103954828" style="zoom: 33%;"></p>
<ul>
<li>本文的预训练模型GLM基于autoregressive blank-filling（预训练方案），<strong style="color:red;">遵循自动编码(auto-encoding)的思想，我们从输入文本中随机消除了令牌的连续跨度。并遵循自回归预训练(auto-regressive)的思想训练模型以重建跨度。</strong></li>
<li>为了在一个框架中同时学习双向和单向的注意力机制，本文将文本分成两部分，未掩码的部分可以互相关注。掩码的部分不可以关注后续的掩码的token。</li>
<li>本文还提出了一个 2D位置编码技术，来指示inter- and intra- span position information。</li>
<li></li>
</ul>
<p>因此，本文的框架 GLM在预训练过程中，可以同时学习上下文表达和自回归生成。</p>
<h3 id="2-2-多任务预训练方案"><a href="#2-2-多任务预训练方案" class="headerlink" title="2.2 多任务预训练方案"></a>2.2 多任务预训练方案</h3><p>为了使本文的预训练模型更加适合文本生成任务，本文也研究了一个多任务预训练的设置：（1）采样多个short spans, 目标是重构masked spans，该预训练任务对下游NLU任务有益处（2）采样单个 longer span，目标是回复该单个spans。该预训练任务对下游NLG任务有益处。</p>
<p>这种多任务预训练方案，在理解型任务，条件生成任务和具有共享参数的语言建模任务方面均有改善。</p>
<h3 id="2-3-pretrain-finetune-consistency"><a href="#2-3-pretrain-finetune-consistency" class="headerlink" title="2.3 pretrain-finetune consistency"></a>2.3 pretrain-finetune consistency</h3><p>在下游任务微调GLM时，受到以下两篇文章[1] [2] 的启发，构建为blank-filling generation的形式。每个任务都与一个人工制作的完形填空问题相关联，并且该模型可以预测完形填空的答案。例如，情感分类任务被重新构造为一个 <strong>“[SENTENCE]. It’s really __ ”.</strong> 这种格式的填空任务。对于”good” or “bad” 的预测暗示了情感是积极地还是消极地。</p>
<p>在这种格式下，GLM 在预训练和微调的一致中受益。因为<strong style="color:blue;">预训练和微调都涉及到以给定上下文来生成文本的方式来训练模型</strong>。因此，GLM相比于BERT-like models 更适合下游分类任务。<strong style="color:red;"><strong>yaya：这里的因此，好像不能推断出来</strong></strong></p>
<h2 id="3-贡献"><a href="#3-贡献" class="headerlink" title="3. 贡献"></a>3. 贡献</h2><p>本文的结构有三个主要的优势：</p>
<ul>
<li>在一个预训练模型上，可以在三种任务上都表现的很好。</li>
<li>由于 <strong style="color:blue;">pretrain-finetune consistency</strong>，在分类任务上，本文提出的模型相比 BERT-like models 性能更加优异。</li>
<li>可以自然的处理 <strong style="color:red;">variable-length blank filling</strong>，这对很多下游任务是很重要的。</li>
</ul>
<h2 id="4-Method"><a href="#4-Method" class="headerlink" title="4. Method"></a>4. Method</h2><h3 id="4-1-Model-Architecture"><a href="#4-1-Model-Architecture" class="headerlink" title="4.1 Model Architecture"></a>4.1 Model Architecture</h3><p>本文提出的结构 GLM 与 BERT很相似。Following Megatron-LM, 对BERT的结构做了两点改动。（1）rearrange the order of layer normalization and the residual connection。（2）replace the feed-forward network for token prediction with a linear layer。</p>
<h3 id="4-2-Autoregressive-Blank-Infilling"><a href="#4-2-Autoregressive-Blank-Infilling" class="headerlink" title="4.2 Autoregressive Blank Infilling"></a>4.2 Autoregressive Blank Infilling</h3><p>通过优化 autoregressive blank infilling 任务对GLM进行训练。</p>
<p>给定 an input text $\boldsymbol{x}=\left[x_{1}, \cdots, x_{n}\right]$，多个被采样 text spans {$s_{1},…,s_{m}$} ，每个span $s_{i}$ 是一系列连续的tokens $\left[s_{i, 1}, \cdots, s_{i, l_{i}}\right]$。text spans 的数量和长度取决于预训练目标（将会在下文中被介绍）。</p>
<p>该模型以自回归的方式从损坏的文本中预测 span 中丢失的 tokens，这意味着在预测 span 中丢失的 tokens，模型可以访问损坏的文本<em>和</em>先前预测的spans。为了充分捕捉不同span之间的相互依存关系，我们随机地排列span的顺序。yaya: 以下公式中 $\boldsymbol{s}_{\boldsymbol{z}_{&lt;i}}$ 被随机排列了，并不是按照其在句子中的顺序。</p>
<p>预训练目标为：$\max _{\theta} \mathbb{E}_{\boldsymbol{z} \sim Z_{m}}\left[\sum_{i=1}^{m} \log p_{\theta}\left(\boldsymbol{s}_{z_{i}} \mid \boldsymbol{x}_{\text {corrupt }}, \boldsymbol{s}_{\boldsymbol{z}_{&lt;i}}\right)\right]$</p>
<p>该任务与SpanBERT 的区别在于 <strong>模型不知道span中丢失tokens 的数量</strong>。</p>
<p>具体来说，我们使用以下技巧实现了自动回归的空白填充任务。输入令牌分为两部分。A部分包含损坏的文本$x_{corrupt}$ ,其中采样的text span 被替换为 [MASK] 令牌。B部分由masked span 中的tokens 组成。A部分中的 tokens 可以 attend to A中的所有tokens ，但不能 attend to B中的任何tokens 。B部分中的tokens 可以 attend to A中的tokens 及其在B中的先行词，但不能attend to B中的任何后续位置。</p>
<p><strong style="color:red;">与原始Transformer 模型中的decoder 相似</strong>，span中的tokens被补充两个特殊token [START]和 [END]，以这种方式，本文提出的模型可以同时学习（1）一个双向encoder（PART A）和（2）一个单向decoder (PART B)。如下图2所示。</p>
<p><img src="https://i.loli.net/2021/03/21/i4AEV3J2psDv1aT.png" alt="image-20210321135425429"></p>
<h4 id="4-2-1-2D-Positional-Encoding"><a href="#4-2-1-2D-Positional-Encoding" class="headerlink" title="4.2.1 2D Positional Encoding"></a>4.2.1 2D Positional Encoding</h4><p>每个 token 都使用两个 position ids 进行编码。</p>
<p>第一个 position id 代表corrupted text 中的位置。对于B中的token，它是对应的[MASK] token的position。</p>
<p>第二位置id表示intra-span position。对于A中的令牌，第二个位置ID为0。对于B中的令牌，范围为1到span的长度。</p>
<p>这两个 position ids  通过两个单独的 embedding table 投影到两个位置向量中，并添加到 input embeddings 中。</p>
<h3 id="4-3-Pre-Training-Objectives"><a href="#4-3-Pre-Training-Objectives" class="headerlink" title="4.3 Pre-Training Objectives"></a>4.3 Pre-Training Objectives</h3><p>采样：the masked spans make up 15% of the original tokens.</p>
<p>span leagth:  drawn from a Poisson distribution with $\lambda$= 3</p>
<p>与其他BERT样式的模型类似，GLM 对 short spans 进行掩码，适用于NLU任务。 但是，我们对单个预训练模型可以同时处理NLU和text generation 感兴趣。</p>
<p>我们进一步研究了<em>多任务预训练</em>设置，第二个目标：生成更长文本。并与GLM联合优化。具体来说，我们采样了a single span 覆盖原始文本长度的50％–100％。跨度长度是从均匀分布中采样的。以与原始目标相同的方式定义新目标。唯一的区别是只有一个跨度，但跨度更长。</p>
<h3 id="4-4-Finetuning-GLM"><a href="#4-4-Finetuning-GLM" class="headerlink" title="4.4 Finetuning GLM"></a>4.4 Finetuning GLM</h3><h4 id="NLU-task"><a href="#NLU-task" class="headerlink" title="NLU task"></a>NLU task</h4><p><strong>对于NLU 任务，以前的PLMs 存在预训练-微调目标不一致的问题</strong>， 具体解释如下：</p>
<p>先前的方法处理NLU任务，通常采用将预训练模型得到的representation送入一个线性分类层中来预测答案。对于token classification: 使用 token representation；对于 sentence classification：使用 [CLS] token representation。但是对于预训练任务采用的是cloze filling task 。这就导致了预训练-微调目标不一致的问题。</p>
<p>本文中，将NLU中的分类任务定义为 blank filling task。</p>
<p>给定一个标注样本（$x$, y），经由一个包含了 single mask token 的 pattern。</p>
<p>将输入文本 $x$ 映射成一个 cloze question $c(x)$ 。情感分类任务被重新构造为一个 <strong>“[SENTENCE]. It’s really [MASK] ”.</strong>  </p>
<p>标签 $y$ 也映射为填空问题的答案，称为 verbalizer $v(y)$ 。在情感分类任务中消极和积极被映射到单词“好”或“坏”。</p>
<p>Therefore, the conditional probability of $y$ given $\boldsymbol{x}$ is</p>
<script type="math/tex; mode=display">
p(y \mid \boldsymbol{x})=\frac{p(v(y) \mid c(\boldsymbol{x}))}{\sum_{y^{\prime} \in \mathcal{Y}} p\left(v\left(y^{\prime}\right) \mid c(\boldsymbol{x})\right)}</script><p>where $\mathcal{Y}$ is the label set. Then we can finetune GLM with the cross entropy loss.</p>
<h4 id="NLG-task"><a href="#NLG-task" class="headerlink" title="NLG task"></a>NLG task</h4><p>对于文本生成任务，可以直接的将GLM作为一个自回归模型来使用。</p>
<p>给定的上下文构成了输入的A部分，其中有一个[MASK]结尾的令牌。然后，GLM自动在B部分中生成文本。我们可以将预训练的GLM直接应用于无条件生成，也可以在下游的有条件生成任务上微调GLM。</p>
<p><img src="https://i.loli.net/2021/03/21/k3E8uCchorg5LO9.png" alt="image-20210321151303074" style="zoom:80%;"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] [It’s Not Just Size That Matters] Small Language Models Are Also Few-Shot Learners</p>
<p>[2] Exploiting Cloze Questions for Few Shot Text Classification and Natural Language Inference</p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>BERT-ATTACK Adversarial Attack Against BERT Using BERT</title>
    <url>/2020/12/01/BERT-ATTACK-Adversarial-Attack-Against-BERT-Using-BERT/</url>
    <content><![CDATA[<h1 id="复旦大学李林阳：应用预训练模型实现对抗样本生成的高效方法"><a href="#复旦大学李林阳：应用预训练模型实现对抗样本生成的高效方法" class="headerlink" title="复旦大学李林阳：应用预训练模型实现对抗样本生成的高效方法"></a>复旦大学李林阳：应用预训练模型实现对抗样本生成的高效方法</h1><p>针对离散数据（例如文本）的对抗攻击比连续数据（例如图像）更具挑战性，因为很难使用基于梯度的方法生成对抗样本。当前成功的文本攻击方法通常在字符或单词级别上采用启发式替换策略，替换时难以保持语义一致性和语言流畅性。在本文中，作者提出了BERT-Attack，这是一种高质量且有效的方法，可以使用以BERT为例的MLM预训练语言模型来生成对抗性样本。作者使用BERT对抗其微调模型和其他预训练模型，以误导目标模型，使其预测错误。作者的方法在成功率和扰动百分比方面均优于最新的攻击策略，并且生成的对抗性样本很流利，并且在语义一致。而且作者的方法计算成本低，可以大规模生成。</p>
<p>本期AI TIME PhD直播间，我们有幸邀请到了复旦大学 NLP group2019级研究生李林阳分享他的观点。</p>
<p>李林阳：复旦大学 NLP group2019级研究生；导师为邱锡鹏教授；</p>
<hr>
<h2 id="一、针对文本任务的攻击"><a href="#一、针对文本任务的攻击" class="headerlink" title="一、针对文本任务的攻击"></a><strong>一、针对文本任务的攻击</strong></h2><p>尽管深度学习取得了成功，但最近的研究发现神经网络容易受到对抗样本的攻击，这些对抗样本是对原始输入进行细微扰动而制成的。尽管对抗性样本对于人而言几乎不可察觉，但是它们会误导神经网络进行错误的预测。针对对抗性攻击的学习可以提升神经网络的可靠性和健壮性，在计算机视觉领域，攻击策略及其防御措施都得到了很好的探索，但由于语言的离散性，对文本的对抗性攻击较为困难，难以保证语法流利且语义一致。</p>
<p><img src="https://i.loli.net/2020/12/01/S3DQcwvOEAt1uma.jpg"> </p>
<p> 表1 BERT-Attack方法生成样本的例子</p>
<p>当前对文本的成功攻击通常采用启发式规则来修改单词的字符，并用同义词替换单词。</p>
<p>之前的研究包括使用word embedding生成替换词；对原有句子的短语进行添加或删除；使用人工构建的规则进行词语替换。<strong>尽管上述方法取得了良好的效果，但在攻击成功率，语法正确性和语义一致性等方面，仍有很大的改进空间</strong>。此外，这些方法的替换策略通常很简单，受限于特定任务。</p>
<p>本文提出了一种有效且高质量的对抗样本生成方法：BERT-Attack，使用BERT作为生成器生成对抗样本。BERT-Attack的核心算法包括<strong>两个阶段</strong>：<strong>在给定输入序列中查找易受攻击的单词，然后用如BERT的生成器来生成易受攻击单词的替代词。</strong> BERT能够捕捉文本的上下文语义，因此生成的样本更为流畅且合理。作者将BERT这样的MLM语言模型用作生成器，并找到让BERT模型得到最大错误预测风险的扰动。另外，本文的方法只需要一次生成器前向，而且无需反复使用语言模型对对抗样本进行评分，速度有一定改进。表1展示了该攻击方法在几个数据集上的生成文本样例。</p>
<h2 id="二、BERT-ATTACK攻击方法"><a href="#二、BERT-ATTACK攻击方法" class="headerlink" title="二、BERT-ATTACK攻击方法"></a><strong>二、BERT-ATTACK攻击方法</strong></h2><p><img src="https://i.loli.net/2020/12/01/cOpDH2hWr81uzMS.png" alt="image-20201201154053279"></p>
<p>图1. BERT-ATTACK替换策略一步的样例</p>
<p>本文提出BERT-Attack，它使用原始BERT模型制作对抗性样本以对抗微调的BERT模型。对抗样本的生成包括两个步骤：（1）找出针对目标模型的易受攻击的单词，（2）用语义相似且语法正确的单词替换它们，直到成功攻击为止。具体而言：</p>
<p><strong>1.寻找易受攻击词(Vulnerable Words)</strong></p>
<p>作者给句子中的每一个词一个评分，得分与易受攻击程度呈正比，该评分按照去掉该词的句子在判别器上的输出结果的扰动程度给出。作者使用目标模型（微调的BERT或其他神经模型）的logit输出作为判别器。易受攻击词定义为序列中对最终输出logit有重要影响的单词。令表示输入语句，表示目标模型输出的正确标签y的logit，重要性得分定义为</p>
<p>$I_{w_{i}}=o_{y}(S)-o_{y}\left(S_{\backslash w_{i} j}\right.)$</p>
<p>其中，</p>
<p>$S_{\backslash w_{i}}=\left[w_{0} ; \ldots ; w_{i-1} ;[M A S K] ; w_{i+1} ; \ldots\right]$</p>
<p>就是将该词替换成“[MASK]”。然后，对降序排名，获取其中的前百分之的词组成可替换词表，记为L。</p>
<h2 id="2-BERT生成器的优点"><a href="#2-BERT生成器的优点" class="headerlink" title="2.BERT生成器的优点"></a><strong>2.BERT生成器的优点</strong></h2><p>找到易受攻击的单词后，将列表L中的单词一一替换，以寻找可能误导目标模型的干扰。以前的替换方法包括同义词词典，POS检查器，语义相似性检查器等。但是因为替换的时候只有词表，不考虑上下文，因此需要用传统语言模型给替换单词的句子打分。由于换一个词就得评价一次，时间成本比较高。</p>
<p>作者利用BERT进行单词替换，可确保所生成的句子相对流利且语法正确，还保留了大多数语义信息。此外，掩码语言模型的预测是上下文感知的，因此可以动态搜索扰动，而不是简单的同义词替换。而且针对一个词而言，仅通过一个前向即可产生候选文本，无需再用语言模型来对句子评分，提升了效率。</p>
<h2 id="3-替换策略"><a href="#3-替换策略" class="headerlink" title="3.替换策略"></a><strong>3.替换策略</strong></h2><p><img src="https://i.loli.net/2020/12/01/MIsY1JPptlRxGB5.png" alt="image-20201201153433807" style="zoom:50%;">图2 BERT-ATTACK替换算法</p>
<p>如图1所示，作者输入原句子给BERT，并根据BERT输出生成候选词。<strong style="color:red;">注意这里不用[MSAK]替换被攻击词语</strong>，其原因作者给出了如下解释：1. 有些词语替换后，和原句子几乎一样流畅但是语义可能变更。例如给定一个序列“I like the cat”，如果遮盖cat这个词，那么MLM模型很难预测原始单词cat，因为如“I like the dog”一样很流畅。2. MASK掉给定的单词后，每个候选词都需要运行一遍BERT前向，时间成本太高。</p>
<p>令M代表BERT模型，为原序列，是利用BERT的分词器分完词的序列，将H输入BERT中得到输出预测。使用top-K策略选择可能的替换词预测，其中K是超参数。作者遍历所有候选易攻击词表L生成替换词表。</p>
<p>由于BERT使用字节对编码（BPE）分词，候选词可能会被分开，因此还需要将所选单词与BERT中相应的子单词对齐。</p>
<p>针对未被分开的单个单词，作者使用相应的前K个预测候选逐一尝试替换，并使用NLTK过滤其中的停用词，另外对于情感分类任务候选词可能包括同义词和反义词，作者使用同义词词典过滤反义词。然后将替换完成的句子重新输入判别器，如果判别器给出与原label相反的判断那么输出该句子作为攻击句；否则，从筛选出的候选词中选择一个对logit影响最大的。</p>
<p>针对字词组（sub-word 应该不能翻译为字词组），由于无法直接获取其替代词，作者使用子词组合中所有词的预测中找到合适的词替代。作者首先使用MLM模型分析整个词组的易攻击程度，然后再选出词组的top-k组合。剩余过程与单个单词一致。</p>
<p><strong>三、实验结果</strong></p>
<p><strong>3.1 数据集和评价指标</strong></p>
<p>为了衡量所生成样本的质量，作者设计了几种评估指标：</p>
<p>●成功率（success rate）：攻击样本的判别器准确率。</p>
<p>●扰动百分比（perturbed percentage）更改文本的占比。</p>
<p>●每个样本的查询数量（query number per sample）一个样本生成对抗样本的需要访问判别器的次数。</p>
<p>●语义相似度（semantic similarity）使用通用句子编码器（Universal Sentence Encoder）评价的句子相似度。</p>
<p><img src="https://i.loli.net/2020/12/01/jgXqBTRfJYniZFe.png" alt="image-20201201153907478" style="zoom:50%;">表2 实验结果</p>
<p><strong>3.2 实验结果</strong></p>
<p>如表2所示，BERT-Attack方法成功欺骗了其下游的微调模型。在文本分类和自然语言推断任务中，经过微调的BERT均无法正确地对生成的对抗样本进行分类，攻击后的平均准确度低于10％。同时，扰动百分比小于10％，明显小于以前的工作，BERT-Attack方法更有效且更不易察觉。查询数量也要少得多。</p>
<p>另外可以观察到，由于扰动百分比非常低，因此通常更容易攻击评论分类任务。BERT-Attack仅替换少数几个单词就可能误导判别器。由于平均序列长度相对较长，因此判别器倾向于仅按序列中的几个词进行判断，这不是人类预测的自然方式。因此，这些关键字的干扰将导致目标模型的预测不正确，从而揭示了该模型的脆弱性。</p>
<p><strong>3.3人工验证</strong></p>
<p>为了进一步评估生成的对抗性样本，作者人工评估了流利性，语法以及语义保留方面生成的样本的质量。</p>
<p><img src="https://i.loli.net/2020/12/01/oDVS914hYZWJNje.png" alt="image-20201201153955115" style="zoom:50%;"></p>
<p>作者要求三名标注人员对生成的对抗性样本和原始序列的混合句子的语法正确性进行评分（1-5分），然后将原始文本和对抗文本混在一起进行人工预测。在IMDB和MNLI数据集中，作者分别选择100个原始样本和对抗样本验证。对于IMDB，将多数类作为人类预测标签，对于MNLI，则使用标注人员之间的平均分数。从表2中可以看出，对抗性样本的语义分数和语法分数接近原始样本。MNLI<strong>任务数据长且更加复杂（存在句子对（sentence pair）之间，重复出现的词汇较多，而基于替换的对抗样本则破坏了这种相同词汇的对应关系</strong>），使标注人员难以正确预测，因此其准确性要比简单的句子分类任务低。作者同样做了大量消融实验，实验结果表明该对抗方法生成的样本迁徙性强，生成速度快。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>在这项工作中，作者提出了一种高质量有效的BERT-Attack方法，以使用BERT<strong>掩蔽语言模型（masked-LM）生成对抗性样本。</strong>实验结果表明，该方法在保持最小扰动的同时，取得了较高的成功率。然而，从屏蔽语言模型生成的候选者有时可能是反义词或与原始单词无关，从而导致语义损失。因此，增强语言模型以生成更多与语义相关的扰动可能是将来完善BERT-Attack的一种可能解决方案。</p>
<hr>
<blockquote>
<p>整理：李键铨<br>排版：杨梦蒗<br>审稿：李林阳</p>
</blockquote>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Attacking Visual Language Grounding with Adversarial Examples: A Case Study on Neural Image Captioning</title>
    <url>/2020/05/10/Attacking-Visual-Language-Grounding-with-Adversarial-Examples-A-Case-Study-on-Neural-Image-Captioning/</url>
    <content><![CDATA[<h4 id="对抗样本的影响"><a href="#对抗样本的影响" class="headerlink" title="对抗样本的影响"></a>对抗样本的影响</h4><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1genh1kz7svj30i40dpag7.jpg" alt="Fig_stopsign_2_small.png"></p>
<p>图1，在image RGB 上添加了一些扰动，结果使得captioning model的输出也发生了很大的变化。基于此，发现了两个问题。（1）我们的结果指出了在tested image captioning systems中的致命问题。（2）captioning model 中的对抗性例子突出了 人与机器之间visual language grounding 的不一致，表明当前的机器视觉和感知机制可能存在缺陷。</p>
<h4 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h4><ul>
<li>本文提出了一种<strong>设计对抗样本</strong>的方法</li>
<li>本文的这种对抗样本可以拿去用来分析captioning model 的鲁棒性-</li>
<li>本文，还利用 对抗样本，来做什么了，有没有做一些对抗性的训练？？</li>
</ul>
]]></content>
      <categories>
        <category>图像描述</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>BERTScore: Evaluating Text Generation with BERT</title>
    <url>/2020/04/01/BERTScore-Evaluating-Text-Generation-with-BERT/</url>
    <content><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>我们提出BERTScore，这是一种用于文本生成的自动评估指标。</p>
<p>类似于通用指标，BERTScore计算候选句子中每个token与参考中每个token的相似性得分。但是，我们不是使用精确匹配，而是使用上下文化的BERT embedding 来计算相似度。</p>
<p>我们对几种机器翻译和图像字幕基准进行了评估，结果表明BERTScore与人为判断的关联性比现有指标更好，通常甚至大大超过特定于任务的监督指标。</p>
<h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><p>在本文中，我们将重点放在句子级别的生成评估上，并提出了：BERTScore，这是一种基于预训练的BERT上下文嵌入 （bert）的评估指标。 BERTScore将两个句子之间的相似度计算为它们的标记之间的余弦相似度的加权汇总。</p>
<p>基于n-gram matching metric 的常见缺陷：</p>
<ul>
<li><p>semantically-correct phrases are penalized because they differ from the surface form of the reference.</p>
<p>解决： In contrast to string matching (e.g., in BLEU) or matching heuristics (e.g., in METEOR), we compute similarity using contextualized token embeddings, which have been shown to be effective for paraphrase detection  </p>
</li>
<li><p>n-gram models fail to capture distant dependencies and penalize semantically-critical ordering changes.</p>
<p>解决： contextualized embeddings are trained to effectively capture distant dependencies and ordering  </p>
</li>
</ul>
<p>实验结果：（1）In machine translation, BERTSCORE shows stronger system-level and segment-level correlations<br>with human judgments than existing metrics on multiple common benchmarks.（2）BERTSCORE is well-correlated with human annotators for image captioning, surpassing SPICE.</p>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><ul>
<li>见论文，比较好理解</li>
</ul>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul>
<li>Moverscore: Text generation evaluating with contextualized embeddings and earth mover distance  <ul>
<li>同样尝试使用contextual word embeddings  来构建一个metric.</li>
</ul>
</li>
<li>Putting evaluation in context: Contextual embeddings improve machine translation evaluation. In ACL, 2019.  </li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>BART</title>
    <url>/2021/02/19/BART/</url>
    <content><![CDATA[<h1 id="BART-Denoising-Sequence-to-Sequence-Pre-training-for-Natural-Language-Generation-Translation-and-Comprehension"><a href="#BART-Denoising-Sequence-to-Sequence-Pre-training-for-Natural-Language-Generation-Translation-and-Comprehension" class="headerlink" title="BART: Denoising Sequence-to-Sequence Pre-training for Natural Language Generation, Translation, and Comprehension"></a>BART: Denoising Sequence-to-Sequence Pre-training for Natural Language Generation, Translation, and Comprehension</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul>
<li>本文提出了一个<strong>denoising autoencoder</strong> (BART)来预训练一个 sequence-to-sequence model。It is implemented as a sequence-to-sequence model<br>with a bidirectional encoder over corrupted text and a<br>left-to-right autoregressive decoder</li>
<li>BART 通过两点来训练：（1）使用一个<strong>arbitrary noising function</strong> 来对原始文本添加噪声。（2）让模型去学习重构原始文本。</li>
<li>BART使用<strong>一个标准的 transformer-based neural machine translation architecture</strong>。由于采用了 <strong style="color:blue;">bidirectional encoder</strong> 可以看做是对BERT的推广，由于其采用了 <strong style="color:blue;">the left-to-right decoder</strong> 也可以看做是对GPT2的推广，同时也采用了许多现在广泛使用的预训练方案。</li>
<li>本文对许多 noising approaches 进行评估，发现最好的方案是对原始的句子进行打乱顺序。本文采用了一个 novel in-filling scheme，<strong>使用spans of text 来代替 a single mask token</strong>。</li>
<li>实验结果：（1）当对文本生成进行微调之后，BART 对生成式任务的性能尤其的好。BART对理解型任务也表现很好。（2）BART与RoBERTa的性能相匹配，在 GLUE 和 SQuAD 上有可比较的training resources，在一系列  abstractive dialogue, question answering, and summarization tasks 取得了最新成果，并在ROUGE上获得了多达6个点的提升。（3）BART在机器翻译任务上，仅使用 target language 来预训练。在BLEU 指标上，获得了比 back translation system 1.1个点的提升。</li>
<li>消融实验：使用BART framework，采用不同的预训练方案，来确定影响了最终任务性能的关键因素是什么。</li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul>
<li>现存方法的一个问题：However, these methods typically focus on particular types of end tasks (e.g. span prediction, generation, etc.), limiting their applicability.<br>yaya: 现存的方法可以只限定对某一类任务有效，如只对 comprehensive tasks有效，而对 generation tasks无法使用。</li>
<li><p>在本文中，提出了一个可以结合 <strong style="color:red;">bidirectional</strong> and <strong style="color:blue;">auto-regressive</strong> Transformers. BART是使用<strong style="color:blue;">序列到序列</strong>模型构建的<strong style="color:red;">去噪自动编码器</strong>，BART可以适用于非常广泛的最终任务。</p>
</li>
<li><p>本文提出框架的优点：噪声的灵活性，可以将任意转换应用于原始文本，包括更改其长度。</p>
</li>
<li><p>本文对许多 noising approaches 进行评估，发现最好的方案是 shuffling the order of the<br>original sentences。本文采用了一个 novel in-filling scheme，使用spans of text 来代替 a single mask token。<br>本文提出的方法通过强制模型对更多的总体句子长度进行推理，并对输入进行更远距离的转换，从而泛化了BERT中的两个预训练任务（word masking and next sentence prediction）</p>
</li>
<li><p>BART还开辟了关于微调的新思路。本文提出了一种新的机器翻译方案，其中BART模型堆叠在其他几个transformer layers 之上。这些层经过培训，从而将外语从本质上翻译为噪声英语，可以通过BART进行传播，从而将BART用作预训练的目标方语言模型。</p>
</li>
</ul>
<h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><p><strong>BART</strong> is a denoising autoencoder that maps a corrupted document to the original document it was derived from. </p>
<p>It is implemented as <strong>a sequence-to-sequence model</strong> with <strong>a bidirectional encoder</strong> over corrupted text and <strong>a left-to-right autoregressive decoder</strong>. For pre-training, we optimize the negative log likelihood of the original document.</p>
<p><img src="https://i.loli.net/2021/02/19/BCSUOQkGX5KcJTR.png" alt="image-20210219151202969" style="zoom:50%;"></p>
<h2 id="Pre-training-BART"><a href="#Pre-training-BART" class="headerlink" title="Pre-training BART"></a>Pre-training BART</h2><p>Unlike existing denoising autoencoders, which are tailored to specific noising schemes, BART allows us to apply any type of document corruption.</p>
<p>解释：BERT 对句子中的token进行随机掩码，采用的特定类型的 noising schemes，而 BART 可以应用任意类型的corruption。<strong>极端情况下，当原句中的所有信息都丢失时，BART可以看做是一个 language model。</strong></p>
<p>本文采用了 几个先前提出的变换，和几个自己新提出的变换。</p>
<p><img src="https://i.loli.net/2021/02/19/LxrawUIdKp8TyFX.png" alt="image-20210219152433064"></p>
<p>（1）Token Masking.</p>
<p>（2）Token Deletion. 模型必须去决定哪个在位置丢失了。</p>
<p>（3）Text Infilling. 采样了多个 text spans, spans lengths 从一个泊松分布（$\lambda$ = 3）中随机采样。每个span被替换成一个[MASK]。<strong>Text infilling teaches the model to predict how many tokens are missing from a span.</strong> yaya:仅仅是预测[MASK 位置处有几个tokens，而不需要预测具体点的tokens是什么]</p>
<p>（4）Sentence Permutation. 根据停止符，将一个document分成多个句子，然后打乱句子的顺序，</p>
<p>（5）Document Rotation. A token is chosen uniformly at random, and the document is rotated so that it begins with that token. This task trains the model to identify the start of the document.</p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Batch Normalization(BN层)</title>
    <url>/2019/03/23/Batch-Normalization-BN%E5%B1%82/</url>
    <content><![CDATA[<p>参看：<a href="https://blog.csdn.net/donkey_1993/article/details/81871132" target="_blank" rel="noopener">https://blog.csdn.net/donkey_1993/article/details/81871132</a><br>参看：<a href="https://zhuanlan.zhihu.com/p/34879333" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34879333</a></p>
<h2 id="BN层的原理"><a href="#BN层的原理" class="headerlink" title="BN层的原理"></a>BN层的原理</h2><ul>
<li>在训练阶段，输入到网络中的是mini batch<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1chneox3hj30dv0bddgx.jpg"><br>解析：</li>
<li><p>Normalization操作我们虽然缓解了ICS问题，让每一层网络的输入数据分布都变得稳定，但却导致了数据表达能力的缺失。也就是我们通过变换操作改变了原有数据的信息表达（representation ability of the network），使得底层网络学习到的参数信息丢失。另一方面，通过让每一层的输入分布均值为0，方差为1，会使得输入在经过sigmoid或tanh激活函数时，容易陷入非线性激活函数的线性区域。  </p>
</li>
<li><p>因此，BN又引入了两个可学习（learnable）的参数  γ与β  。这两个参数的引入是为了恢复数据本身的表达能力，对规范化后的数据进行线性变换，即<img src="https://www.zhihu.com/equation?tex=%5Ctilde%7BZ_j%7D%3D%5Cgamma_j+%5Chat%7BZ%7D_j%2B%5Cbeta_j" alt="\tilde{Z_j}=\gamma_j \hat{Z}_j+\beta_j">。特别地，当  γ<sup>2</sup>=σ<sup>2</sup> ， β=μ 时，可以实现等价变换（identity transform）并且保留了原始输入特征的分布信息。</p>
</li>
</ul>
<h2 id="测试阶段如何使用Batch-Normalization？"><a href="#测试阶段如何使用Batch-Normalization？" class="headerlink" title="测试阶段如何使用Batch Normalization？"></a>测试阶段如何使用Batch Normalization？</h2><p>我们知道BN在每一层计算的  μ与σ<sup>2</sup>都是基于当前batch中的训练数据，但是这就带来了一个问题：我们在预测阶段，有可能只需要预测一个样本或很少的样本，没有像训练样本中那么多的数据，此时 μ与σ<sup>2</sup>的计算一定是有偏估计，这个时候我们该如何进行计算呢？</p>
<p>利用BN训练好模型后，我们保留了每组mini-batch训练数据在网络中每一层的<br> μ<sub>batch</sub>与σ<sup>2</sup><sub>batch</sub> 。此时我们使用整个样本的统计量来对Test数据进行归一化，具体来说使用均值与方差的无偏估计：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cmu_%7Btest%7D%3D%5Cmathbb%7BE%7D+%28%5Cmu_%7Bbatch%7D%29" alt="\mu_{test}=\mathbb{E} (\mu_{batch})"></p>
<p><img src="https://www.zhihu.com/equation?tex=%5Csigma%5E2_%7Btest%7D%3D%5Cfrac%7Bm%7D%7Bm-1%7D%5Cmathbb%7BE%7D%28%5Csigma%5E2_%7Bbatch%7D%29" alt="\sigma^2_{test}=\frac{m}{m-1}\mathbb{E}(\sigma^2_{batch})"></p>
<p>得到每个特征的均值与方差的无偏估计后，我们对test数据采用同样的normalization方法：</p>
<p><img src="https://www.zhihu.com/equation?tex=BN%28X_%7Btest%7D%29%3D%5Cgamma%5Ccdot+%5Cfrac%7BX_%7Btest%7D-%5Cmu_%7Btest%7D%7D%7B%5Csqrt%7B%5Csigma%5E2_%7Btest%7D%2B%5Cepsilon%7D%7D%2B%5Cbeta" alt="BN(X_{test})=\gamma\cdot \frac{X_{test}-\mu_{test}}{\sqrt{\sigma^2_{test}+\epsilon}}+\beta"></p>
<p>另外，除了采用整体样本的无偏估计外。吴恩达在Coursera上的Deep Learning课程指出可以对train阶段每个batch计算的mean/variance采用<a href="[https://zhuanlan.zhihu.com/p/29895933](https://zhuanlan.zhihu.com/p/29895933"><font color="#0099ff" size="5" face="楷体"> 指数加权平均</font></a>)来得到test阶段mean/variance的估计。</p>
<h2 id="Batch-Normalization的优势"><a href="#Batch-Normalization的优势" class="headerlink" title="Batch Normalization的优势"></a>Batch Normalization的优势</h2><p>Batch Normalization在实际工程中被证明了能够缓解神经网络难以训练的问题，BN具有的有事可以总结为以下三点：</p>
<p><strong>（1）BN使得网络中每层输入数据的分布相对稳定，加速模型学习速度</strong></p>
<p>BN通过规范化与线性变换使得每一层网络的输入数据的均值与方差都在一定范围内，使得后一层网络不必不断去适应底层网络中输入的变化，从而实现了网络中层与层之间的解耦，允许每一层进行独立学习，有利于提高整个神经网络的学习速度。</p>
<p><strong>（2）BN使得模型对网络中的参数不那么敏感，简化调参过程，使得网络学习更加稳定</strong></p>
<p>在神经网络中，我们经常会谨慎地采用一些权重初始化方法（例如Xavier）或者合适的学习率来保证网络稳定训练。<br>当学习率设置太高时，会使得参数更新步伐过大，容易出现震荡和不收敛。但是使用BN的网络将不会受到参数数值大小的影响。<br>在使用Batch Normalization之后，抑制了参数微小变化随着网络层数加深被放大的问题，使得网络对参数大小的适应能力更强，此时我们可以设置较大的学习率而不用过于担心模型divergence的风险。</p>
<p><strong>（3）BN允许网络使用饱和性激活函数（例如sigmoid，tanh等），缓解梯度消失问题</strong></p>
<p>在不使用BN层的时候，由于网络的深度与复杂性，很容易使得底层网络变化累积到上层网络中，导致模型的训练很容易进入到激活函数的梯度饱和区；通过normalize操作可以让激活函数的输入数据落在梯度非饱和区，缓解梯度消失的问题；另外通过自适应学习 γ与β又让数据保留更多的原始信息。</p>
<p><strong>（4）BN具有一定的正则化效果</strong></p>
<p>在Batch Normalization中，由于我们使用mini-batch的均值与方差作为对整体训练样本均值与方差的估计，尽管每一个batch中的数据都是从总体样本中抽样得到，但不同mini-batch的均值与方差会有所不同，这就为网络的学习过程中增加了随机噪音，与Dropout通过关闭神经元给网络训练带来噪音类似，在一定程度上对模型起到了正则化的效果。</p>
<p>另外，原作者通过也证明了网络加入BN后，可以丢弃Dropout，模型也同样具有很好的泛化效果。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Beam Search</title>
    <url>/2021/03/15/Beam-Search/</url>
    <content><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. <strong>前言</strong></h2><p>自然语言处理任务中，如机器翻译、对话、文本摘要等，都涉及到序列生成。文本序列生成解码过程中有用到 greedy search、维特比算法、beam search等。</p>
<h2 id="2-Beam-Search-介绍"><a href="#2-Beam-Search-介绍" class="headerlink" title="2. Beam Search 介绍"></a>2. Beam Search 介绍</h2><p>beam search尝试在广度优先基础上进行进行搜索空间的优化（类似于剪枝）达到减少内存消耗的目的。</p>
<ul>
<li><strong>算法过程</strong></li>
</ul>
<p>定义词表大小是V，beam size是 B，序列长度是L。</p>
<p>假设V=100，B=3：</p>
<ol>
<li><p>生成第1个词时，选择概率最大的3个词（假设是a，b，c），即从100个中选了前3个；</p>
</li>
<li><p>生成第2个词时，将当前序列a/b/c分别与词表中的 100个词组合，得到 3*100个序列，从中选 3个概率最大的，作为当前序列（假设现在是am，bq，as）；</p>
</li>
<li><p>持续上述过程，直到结束。最终输出3个得分最高的。</p>
</li>
</ol>
<ul>
<li><strong>算法复杂度</strong> $O(B<em>V</em>L)$</li>
</ul>
<p>在第2步，要计算 $B<em>V$ 次。序列长度是L，生成长度为L的序列，计算  $B</em>V*L$ 次。</p>
<h2 id="3-算法评价"><a href="#3-算法评价" class="headerlink" title="3. 算法评价"></a>3. 算法评价</h2><ul>
<li><strong>优点</strong></li>
</ul>
<p>(1) 减少计算开销。相对于广度优先搜索，广搜每次都要保留所有可能的结果，复杂度是  $O(V^L)$指数级。</p>
<ul>
<li><strong>缺点（第3部分详细讲）</strong></li>
</ul>
<p>(1) 数据下溢</p>
<p>(2) 倾向于生成短的序列</p>
<p>(3) 单一性问题</p>
<ul>
<li><strong>Beam size 设置</strong></li>
</ul>
<p>(1) B越大</p>
<p>优点：可考虑的选择越多，能找到的句子越好</p>
<p>缺点：计算代价更大，速度越慢，内存消耗越大</p>
<p>(2) B越小</p>
<p>优点：计算代价小，速度快，内存占用越小</p>
<p>缺点：可考虑的选择变少，结果没那么好</p>
<h2 id="4-问题解决"><a href="#4-问题解决" class="headerlink" title="4. 问题解决"></a>4. 问题解决</h2><h3 id="4-1-数据下溢"><a href="#4-1-数据下溢" class="headerlink" title="4.1 数据下溢"></a>4.1 数据下溢</h3><p>求序列概率的时候，序列概率是多个条件概率的乘积$P\left(y^{<1>} y^{<2>} \ldots y^{T_{y}}\right)=P\left(y^{<1>} \mid x\right) P\left(y^{<2>} \mid x, y^{<1>}\right) \ldots P\left(y^{T_{y}} \mid x, y^{<1>} \ldots, y^{T_{y}-1}\right)$.</1></1></2></1></2></1></p>
<p>每个概率都小于1甚至远远小于1，很多概率相乘起来，会得到很小很小的数字，会造成数据下溢，即数值太小，计算机的浮点表示不能精确储存。</p>
<p><strong>解决</strong>：<strong>将最大化的乘积式取对数</strong>，由 $\log M^{*} N=\log M+\log N$ 公式可得，上述需要最大化的王积式可以转化为: $\arg \max _{y} \sum_{y=1}^{T_{y}} \log P\left(y^{<t>} \mid x, y^{<1>}, \ldots, y^{<t-1>}\right)$</t-1></1></t></p>
<p>即乘积的log变成了log的求和，最大化这个log的求和值能够得到同样的结果，并且不会出现 数值下溢和四舍五入。</p>
<h3 id="4-2-倾向于生成短的序列"><a href="#4-2-倾向于生成短的序列" class="headerlink" title="4.2 倾向于生成短的序列"></a>4.2 倾向于生成短的序列</h3><p>生成的句子序列越长，对数概率相加的结果就越小（越为负值）, 所以倾向于生成短序列。 对序列长度进行惩罚，降低生成短序列的倾向。</p>
<p><strong>解决方法：</strong> 对数概率相加的结果, 除以序列长度 $L$ 。<br>实践中，通常采用更柔和的方法, 在 $L$ 上加上指数 $a \in(0,1),$ 即 $L^{a},$ 例如 $a=0.7$ 。如果 $a=1, \quad L^{a}=L$ 就相当于完全用长度来归一化; 如果 $a=0, \quad L^{a}=1$ 就相当于完全没有 归一化, $a \in(0,1)$ 就是在完全归一化和没有归一化之间。</p>
<p>或者更加复杂一点：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">norm</span> = self.opt.beam_search_norm</span><br><span class="line"><span class="attr">candidate_logprob</span> = (beam_logprobs_sum[q] * t ** norm + local_logprob) / ((t+<span class="number">1</span>) ** norm)</span><br></pre></td></tr></table></figure>
<h3 id="4-3-单一性问题"><a href="#4-3-单一性问题" class="headerlink" title="4.3 单一性问题"></a><strong>4.3 单一性问题</strong></h3><p>beam search 有一个大问题是输出的 $B$ 个句子的差异性很小，无法体现语言的多样性（比如文本摘要、机器翻译的生成文本，往往有不止一种表述方式）。</p>
<p><strong>解决方法：</strong> 分组 加入相似性惩罚。diverse beam search 来自<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1610.02424.pdf" target="_blank" rel="noopener">论文</a></p>
<p>具体如下：选择 Beam size 为 $B$，然后将其分为 $G$组，每一组就有 $B/G$个beam。每个单独的组内跟 beam search很像，不断延展序列。同时通过引入一个dissimilarity 项来保证组与组之间有差异。</p>
<p><img src="https://i.loli.net/2021/03/15/VQDxijZcGtzlEph.png" alt="image-20210315161115581" style="zoom: 50%;"></p>
<p>如上图所示，B = 6, G=3，每一组的beam width为2。</p>
<p>组内与 beam search 很像：从t-1到 t 时刻，不断的减少搜索空间（如同beam search一样）。</p>
<p>组间差异：对于t=4时刻，我们先对第一组输出y（t=4），然后我们开始对第二组输出y（t=4），但是第二组y（t=4）的score不仅取决于第二组之前的y（t=3），也取决于其与第一组的相似程度。以此类推，在t=4时刻对于第三组的输出，我们从上图可以看到其score的打分标准。这儿对于其 dissimilarity 项的计算采用的办法是 hamming diversity，这个理解起来很简单，比如这个时刻可能输出的词在上面的组出现过，我们就对这个词的分数-1，如果这个时刻可能输出的词在上面组没有出现过，我们就对这个词的分数不惩罚。</p>
<ul>
<li><strong>DBS算法：</strong></li>
</ul>
<p><img src="https://i.loli.net/2021/03/15/DdS1XPZvoEptVgw.png" alt="image-20210315161139107" style="zoom: 50%;"></p>
<p>DBS算法</p>
<ul>
<li><strong>附：</strong>很多论文里有对 beam search的改进，主要是针对生成序列的<strong>多样性</strong>的。多样性问题，在对话里很常见。</li>
</ul>
<h2 id="5-其他相关问题："><a href="#5-其他相关问题：" class="headerlink" title="5. 其他相关问题："></a><strong>5. 其他相关问题</strong>：</h2><h3 id="5-1-训练的时候需要-Beam-Search-吗？"><a href="#5-1-训练的时候需要-Beam-Search-吗？" class="headerlink" title="5.1 训练的时候需要 Beam Search 吗？"></a><strong>5.1 训练的时候需要 Beam Search 吗？</strong></h3><p>不需要。因为训练的时候知道每一步的正确答案，没必要进行这样的搜索。</p>
<p>5.2 为什么不用贪心搜索？**</p>
<p>贪心搜索相当于 Beam Search 中 B=1的情况，每次只选择概率最大的词，容易陷入局部最优，但我们真正需要的是一个序列，我们希望整个序列的概率最大。</p>
<h3 id="5-3-维特比算法"><a href="#5-3-维特比算法" class="headerlink" title="5.3 维特比算法"></a>5.3 维特比算法</h3><p>维特比算法是用动态规划的思想。简单来说就是：从开始状态之后每走一步，就记录下<strong>到达该状态的所有路径的概率最大值</strong>，然后以此最大值为基准继续向后推进。显然，如果这个最大值都不能使该状态成为最大似然状态路径上的结点的话，那些小于它的概率值（以及对应的路径）就更没有可能了。</p>
<p>Beam Search与Viterbi算法虽然都是解空间的剪枝算法，但它们的思路是不同的。Beam Search是对状态迁移的路径进行剪枝，而 Viterbi 算法是合并不同路径到达同一状态的概率值，用最大值作为对该状态的充分估计值，从而在后续计算中，忽略历史信息（这种以偏概全也就是所谓的Markov性），以达到剪枝的目的。<br>从状态转移图的角度来说，Beam Search是空间剪枝，而Viterbi算法是时间剪枝。</p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Beyond Accuracy: Behavioral Testing of NLP Models with CheckList</title>
    <url>/2020/10/28/Beyond-Accuracy-Behavioral-Testing-of-NLP-Models-with-CheckList/</url>
    <content><![CDATA[<p>转载：<a href="https://dy.163.com/article/FH8NB44C0511DPVD.html" target="_blank" rel="noopener">https://dy.163.com/article/FH8NB44C0511DPVD.html</a></p>
<p>现在，ACL2020各个奖项都已悉数公布，对此AI科技评论做了详细报道。其中，最受人瞩目的当属最佳论文奖，今年该奖项由微软团队的 《Beyond Accuracy: Behavioral Testing of NLP Models with CheckList》一举拿下。</p>
<p>　　小编看到论文题目的第一眼就觉得哪些有些不对，于是赶紧通读了一下文章，嗯~确实不太对，这貌似和之前我们熟悉的NLP“大力出奇迹”的模型套路不太一样啊？</p>
<p>　　那么这篇论文到底讲了什么呢，又何以摘得桂冠呢？</p>
<p>　　论文解读以外，我们进一步对论文的第二作者吴彤霜进行了专访，以更深入地了解最佳论文团队背后的工作。</p>
<h3 id="论文方法一览"><a href="#论文方法一览" class="headerlink" title="论文方法一览"></a><strong>论文方法一览</strong></h3><p>　　我们从论文的题目入手来了解一下这篇论文在讲什么。</p>
<p>　　首先是”Beyond Accuracy”：这是在说要超越Accuracy，这里Accuracy说的是NLP模型在各大数据集和任务上跑出的准确率，也即是性能的一种度量。</p>
<p>　　那既然要超越它总要有一个理由:</p>
<p>　　1.评估所用的训练-验证-测试划分集来估计模型的准确性时保留的数据集往往不全面。</p>
<p>　　2.测试集中往往包含与训练数据相同的偏差，这种方式可能高估了模型在真实世界的性能</p>
<p>　　3.通过Accuracy一刀切的方式很难找出模型失败在哪里，以及如何修复它。</p>
<p>　　对此本文提出的Beyond 方式又是如何呢？</p>
<p>　　Behavioral Testing of NLP Models with CheckList！也即用CheckList对NLP模型做行为测试。</p>
<h4 id="1、We-should-test-NLP-models"><a href="#1、We-should-test-NLP-models" class="headerlink" title="1、We should test NLP models"></a><strong>1、We should test NLP models</strong></h4><p>　　训练NLP模型的主要目标之一是泛化，虽然Accuracy是评价泛化的主要方法，但它往往高估了NLP模型的性能，用于评估模型的替代方法要么侧重于单个任务，要么侧重于特定的行为，benchmark的准确性不足以评估NLP模型。</p>
<p>　　除此之外许多额外的评估方法已经被提出来了，例如评估对噪声或对抗性变化的鲁棒性、公平性、逻辑一致性、可解释、诊断数据集和交互式错误分析。然而，这些方法要么侧重于单个任务，如问答或自然语言推理，要么侧重于一些能力（如鲁棒性），因此没有提供关于如何评估模型的全面指导。</p>
<p>　　因此在这这篇论文中，作者提出了CheckList(检查表)，一种新的评估方法和配套工具，用于NLP模型的综合行为测试。</p>
<h4 id="2、Software-engineering-gt-NLP"><a href="#2、Software-engineering-gt-NLP" class="headerlink" title="2、Software engineering-&gt;NLP"></a><strong>2、Software engineering-&gt;NLP</strong></h4><p>　　软件工程研究提出了测试复杂软件系统的各种范式和工具。特别是“行为测试”（黑盒测试）是指在不了解内部结构的情况下，通过验证输入输出行为来测试系统的不同能力。虽然有明显的相似之处，但软件工程的许多见解还没有应用到NLP模型中。</p>
<p>　　作者借鉴软件工程中行为测试的原理提出了CheckList：一种和模型、任务都无关的测试方法，它使用三种不同的测试类型来测试模型的各个功能。</p>
<p>　　作者用三个任务的测试来说明检查表的效用，识别商业和SOTA模型中的关键错误。在一项用户研究中，一个负责商业情绪分析模型的团队在一个经过广泛测试的模型中发现了新的、可操作的bug。在另一个用户研究中，使用CheckList的NLP实践者创建了两倍多的测试，发现的bug几乎是没有检查表的用户的三倍。</p>
<p>　　<img src="https://i.loli.net/2020/10/28/qk64rwGIt1lBJWE.png" alt="img"></p>
<p>　　图1</p>
<h4 id="3、What-is-CheckList"><a href="#3、What-is-CheckList" class="headerlink" title="3、What is CheckList"></a><strong>3、What is CheckList</strong></h4><p>　　CheckList包括一个通用语言能力和测试类型的矩阵，有助于全面的测试构思，以及一个快速生成大量不同测试用例的软件工具。从概念上讲，用户通过填写矩阵中的单元格来“检查”模型（图1），每个单元格可能包含多个测试。CheckList应用了“测试与实现脱钩”的行为测试原则，即将模型视为一个黑盒，允许对不同数据上训练的不同模型进行比较，或者对不允许访问训练数据或模型结构的第三方模型进行比较。</p>
<h4 id="4、What-to-test：capabilities"><a href="#4、What-to-test：capabilities" class="headerlink" title="4、What to test：capabilities"></a><strong>4、What to test：capabilities</strong></h4><p>　　CheckList通过提供适用于大多数任务的语言能力列表，指导用户测试什么。CheckList引入了不同的测试类型，比如在某些干扰下的预测不变性，或者一组“健全性检查”的性能。</p>
<p>　　虽然测试单个组件是软件工程中的常见实践，但现代NLP模型很少一次只构建一个组件。相反，CheckList鼓励用户考虑如何在手头的任务上表现出不同的自然语言能力，并创建测试来评估这些能力的模型。例如，词汇+POS能力取决于一个模型是否具有必要的词汇，以及它是否能够恰当地处理具有不同词性的单词对任务的影响。对于情绪，我们可能需要检查模型是否能够识别带有积极、消极或中性情绪的单词，方法是验证它在“这是一次很好的飞行”等示例上的行为。</p>
<p>　　基于此，作者建议用户至少考虑以下性能（capabilities）：</p>
<p>　　词汇+POS（任务的重要单词或单词类型）</p>
<p>　　Taxonomy（同义词、反义词等）</p>
<p>　　健壮性（对拼写错误、无关更改等）</p>
<p>　　NER（正确理解命名实体）</p>
<p>　　公平性</p>
<p>　　时态（理解事件顺序）</p>
<p>　　否定</p>
<p>　　共指（Coreference），</p>
<p>　　语义角色标记（理解诸如agent、object等角色）</p>
<p>　　逻辑（处理对称性、一致性和连词的能力）。</p>
<p>　　通过以上，CheckList实现包括多个抽象，帮助用户轻松生成大量测试用例，例如模板、词典、通用扰动、可视化和上下文感知建议。然而此功能列表并非详尽无遗，而是用户的一个起点，用户还应提供特定于其任务或域的附加功能。</p>
<h4 id="5、How-to-test"><a href="#5、How-to-test" class="headerlink" title="5、How to test"></a><strong>5、How to test</strong></h4><p>　　作者提示用户使用三种不同的测试类型来评估每个功能：最小功能测试、不变性和定向期望测试（矩阵中的列）。</p>
<p>　　1）最小功能测试（MFT）:它是受软件工程中单元测试的启发的一组简单的示例（和标签）的集合，用于检查功能中的行为。MFT类似于创建小而集中的测试数据集，尤其适用于在模型使用快捷方式处理复杂输入而不实际掌握功能的情况下进行检测。</p>
<p>　　<img src="https://i.loli.net/2020/10/28/2bFIGQ17wgVB3su.png" alt="img"></p>
<p>　　2）不变性测试（INV）：当对输入应用保留标签的扰动并期望模型预测保持不变时。不同的功能需要不同的扰动函数，例如，更改NER情感功能的位置名称，或者引入输入错误来测试健壮性能力。</p>
<p>　　<img src="https://i.loli.net/2020/10/28/c4Wa9IZzusY1Kj7.png" alt="img"></p>
<p>　　3）定向期望测试（DIR）：与不变性测试类似，只是标签会以某种方式发生变化。例如，我们预计，如果我们在针对某家航空公司的推文末尾添加“You are lame.”（图1C），情绪不会变得更积极。</p>
<p>　　<img src="https://i.loli.net/2020/10/28/Y78FjaetnpdgOJb.png" alt="img"></p>
<h4 id="6、可视化效果"><a href="#6、可视化效果" class="headerlink" title="6、可视化效果"></a><strong>6、可视化效果</strong></h4><p>　　调用test.visual_summary()</p>
<p>　　<img src="https://dingyue.ws.126.net/2020/0711/f079207eg00qdafs60095d200hr005pg00it0061.gif" alt="img"></p>
<p>　　在代码中调用suite.summary()（与test.summary相同）或suite.visual_summary_table() 显示测试结果如下：</p>
<p>　　<img src="https://dingyue.ws.126.net/2020/0711/c3640090g00qdafs701u7d200hr00bcg00it00c0.gif" alt="img"></p>
<p>　　模型保存和加载：精简至极！</p>
<p>　　<img src="https://i.loli.net/2020/10/28/KQDGslUnygeLESV.png" alt="img"></p>
<h4 id="7、更方便的大规模生成测试用例"><a href="#7、更方便的大规模生成测试用例" class="headerlink" title="7、更方便的大规模生成测试用例"></a><strong>7、更方便的大规模生成测试用例</strong></h4><p>　　用户可以从头开始创建测试用例，也可以通过扰动现有的数据集来创建测试用例。从头开始可以更容易地为原始数据集中可能未充分表示或混淆的特定现象创建少量高质量测试用例。然而，从头开始编写需要大量的创造力和努力，这通常会导致测试覆盖率低或者生成成本高、耗时长。扰动函数很难编写，但同时生成许多测试用例。为了支持这两种情况，作者提供了各种抽象，从零开始扩展测试创建，并使扰动更容易处理。</p>
<h4 id="8、使用CheckList测试SOTA模型"><a href="#8、使用CheckList测试SOTA模型" class="headerlink" title="8、使用CheckList测试SOTA模型"></a><strong>8、使用CheckList测试SOTA模型</strong></h4><p>　　作者通过付费API 检查了以下商业情绪分析模型：微软的文本分析、谷歌云的自然语言和亚马逊的Constract。我们还检查了在SST-23（acc:92.7%和94.8%）和QQP数据集（acc:91.1%和91.3%）上微调的BERT base和RoBERTa base。对于MC，作者使用了一个经过预训练的大BERT 微调阵容，达到93.2 F1。</p>
<p>　　<img src="https://i.loli.net/2020/10/28/pn7OqdKUx4shRLD.png" alt="img"></p>
<h4 id="9、测试商业系统"><a href="#9、测试商业系统" class="headerlink" title="9、测试商业系统"></a><strong>9、测试商业系统</strong></h4><p>　　作者联系了负责微软服务销售的通用情绪分析模型的团队（表1中的q）。由于它是一个面向公众的系统，模型的评估过程比研究系统更全面，包括公开可用的基准数据集以及内部构建的重点基准（例如否定、emojis）。此外，由于该服务已经成熟，拥有广泛的客户群，因此它经历了许多错误发现（内部或通过客户）和后续修复的周期，之后在基准测试中添加了新的示例。</p>
<p>　　作者的目标是验证检查表是否会增加价值，即使在这样的情况下，模型已经用当前的实践进行了广泛的测试。</p>
<p>　　作者邀请小组参加了一个持续约5小时的检查表会议。该团队集思广益地进行了大约30个测试，涵盖了所有功能。</p>
<p>　　从质量上讲，该小组称检查表非常有用：</p>
<p>　　（1）他们测试了他们没有考虑过的能力；</p>
<p>　　（2）他们测试了他们考虑过但不在benchmark中的能力；</p>
<p>　　（3）甚至他们有基准的能力（例如否定）也用检查表进行了更彻底和系统的测试。</p>
<p>　　他们发现了许多以前未知的错误，他们计划在下一个模型迭代中修复这些错误。最后，他们表示，他们肯定会将检查表纳入他们的开发周期，并要求访问我们的实现。</p>
<h4 id="10、用户研究"><a href="#10、用户研究" class="headerlink" title="10、用户研究"></a><strong>10、用户研究</strong></h4><p>　　作者进行了一项用户研究，以在一个更可控的环境中进一步评估检查表的不同子集，并验证即使是没有任务经验的用户也能获得洞察并发现模型中的错误。</p>
<p>　　尽管用户在使用CheckList时不得不解析更多的指令和学习新的工具，但他们同时为模型创建了更多的测试。</p>
<p>　　在实验结束时，作者要求用户评估他们在每个特定测试中观察到的失败的严重程度，研究结果令人鼓舞：有了检查表的子集，没有经验的用户能够在2小时内发现SOTA模型中的重大缺陷。此外，当被要求对检查表的不同方面进行评分时（1-5分），用户表示，测试环节有助于他们进一步了解模型，功能帮助他们更彻底地测试模型，模板也是如此。</p>
<p>　　评估特定语言能力的一种方法是创建挑战性数据集。我们的目标不是让检查表取代挑战或基准数据集，而是对它们进行补充。CheckList保留了挑战集的许多优点，同时也减轻了它们的缺点：用模板从头开始编写示例提供了系统控制，而基于扰动的INV和DIR测试允许在未标记的自然发生的数据中测试行为。</p>
<p>　　最后用户研究表明，CheckList可以轻松有效地用于各种任务：用户在一天内创建了一个完整的测试套件进行情绪分析，两个小时内创建了的MFTs，这两个都揭示了之前未知的严重错误。</p>
<h3 id="专访吴彤霜：最佳论文何以花落此家"><a href="#专访吴彤霜：最佳论文何以花落此家" class="headerlink" title="专访吴彤霜：最佳论文何以花落此家"></a>专访吴彤霜：最佳论文何以花落此家</h3><p>　　到这里我们大概明白了这篇论文到底在讲什么，但是我们还是心存疑惑，何以它能获得最佳论文殊荣？</p>
<p>　　<strong>以下为专访实录：</strong></p>
<p>　　<strong>AI 科技评论：</strong>首先恭喜您和您的团队斩获ACL2020最佳论文！我们想先了解一下这项工作的完成大概花了多长时间，把软件测试带入NLP模型检测的想法是最近才有的吗还是说之前就有了最近才实现？</p>
<p>　　<strong>吴彤霜：</strong>这个项目最早是一作快博士毕业时我们开始合作的，中间因为各种原因搁置了一段时间，实际做大概一年吧。引用软件测试应该可以算是一个新的想法。以前有很多nlp模型分析的论文本质上也可以说是我们论文里提到的那种“行为测试” (behavioral testing)，比如各种NLI challenge set。只不过这些工作大部分是针对某一个任务在做某个特定种类的分析，每次都要从头开始。我们工作其中的一个主要的一个贡献就是把这些分析做归一化，提供一个测试框架+开源系统。</p>
<p>　　<strong>AI 科技评论：</strong>这项测试系统是不是可以理解为对抗扰动系统啊？或者相比有什么优势呢？</p>
<p>　　<strong>吴彤霜：</strong>不变性测试 (INVariant test) 可以相当于扰动，就是模型在预测一个句子s和经修改后的版本s’时结果类似。CheckList还支持别的测试类别 (test type)：定向测试 (DIRectional test) 是用来测试预测结果的特定变化，最小功能测试 (Min Func Test) 不需要有配对的例子，只要一个能生成单个测试例句的模板就可以了。</p>
<p>　　只和INV（不变性测试 ）相比而言，现在NLP的大部分对抗句经常是在改拼写或者会产生乱码，比较难保证句子的连贯性，而能保证句子连贯性的居多是改近义词 (it’s a good movie -&gt; it’s a great movie)。CheckList因为允许自定义改写函数 (perturbation function)，所以可以更多样地测试模型的性能，比如看情感分析模型是否能辨认虚拟语气 (it’s a bad movie -&gt; it would have been a good movie)。这种测试也更系统化，因为可以生成很多对改写方法类似的句子/测试用例 (test case)。</p>
<p>　　当然相应的checklist的自动化就比较差，需要人来定义这些测试 :)</p>
<p>　　<strong>AI 科技评论：</strong>请问你们团队成员之前有过软件测试的经验吗，在CheckList的设计环节有什么亮点以及代码实现过程中有什么难点？</p>
<p>　　<strong>吴彤霜：</strong>应该不算有经验，没有在工业界实战过，顶多就是在软工课写单元测试，所以最开始其实也认真学习了一下软工 :)</p>
<p>　　设计上我觉得最大的亮点是对于性能 (capability) 的定义 。我们遇到一个瓶颈就是试图给每个NLP task设计需要测试的不同方面，但这样就非常繁琐，也失去了可拓展性。直到后来我们和其他researcher聊的时候意识到其实大部分的模型需要测试的“capability”基本比较稳定，只是不同任务里对标签的影响会有区别，比如[改主语]对NLI影响会比对情感分析要大。这样一个稳定的capability集合就让整个框架干净了很多。</p>
<p>　　开源上，其实NLP部分还是比较整洁的，但是为了让大家能比较流畅地在notebook里浏览和回顾test集，我们下了很大功夫研究怎们做交互插件，是一个大坑，但是最终效果还挺好看的，可以到readme里看看preview感受一下，哈哈。</p>
<p>　　写作上，因为marco在微软，我们很幸运能近水楼台找微软情感分析的工程组来做用户研究，让我们真的看到了CheckList在已经被认为是大规模测试过的模型仍然很有用。</p>
<p>　　<strong>AI 科技评论：</strong>很开心你们把这项工作开源，我想这项工作只是一个开始对吗？（大家都可以在你们开源的代码上进行哪些尝试和改进呢，比如自定义测试模板之类）</p>
<p>　　<strong>吴彤霜：</strong>最重要的是希望能看到大家提出的测试实例！其实比起很多NLP模型，CheckList是一个比较依靠人的力量的项目，测试者仔细设计实例才能用它最大程度暴露模型可能存在的缺陷。我们考虑的一个想法是希望可以做一个类似模型排行榜的测试榜，大家可以上传分享自己的测试集，甚至是顶或者踩别人的测试，最终让每个任务都能有一个比较稳定的测试集，也方便模型间的比较。</p>
<p>　　其次，我们也很期待看到大家会不会有关于如何让CheckList更自动化的想法，实现一键测试这个终极目标 :)</p>
<p>　　以及更研究向的：</p>
<p>　　我个人对于设计更稳定的测试也很感兴趣。CheckList对具体实例比较敏感，不同人在测试同一个模型性能时，如果实例设计不同，最终测试结果可能会有一些偏差。有没有什么交互手段能帮助测试者尽量穷尽一个性能所有的相关改写？甚至还有没有什么办法能慢慢形成一些自动的测试拓展？这个可能也和上面提到的自动化有一些关系。</p>
<p>　　最后测试带来的一个恒久不变的问题：so what？一个模型有问题之后，应该用什么样的标准来决定一个模型是不是可以被公开部署 (比如可能公平性测试的容错率可能远低于拼写错误)？应该如何改进它？</p>
<p>　　<strong>AI 科技评论：</strong>请问软件测试的思想只适用于NLP领域吗 ，在CV领域可行吗，应该怎么去设计测试系统？</p>
<p>　　<strong>吴彤霜：</strong>我相信是可行的！抽象来讲，本文图1的这种框架似乎能直接套用在CV上。</p>
<p>　　比如说一个最简单的狗和狼的分类，这个模型首先得能辨认有动物出现 (MFT)，然后改变图片的背景应该不影响预测 (INV)，但改变动物的头的形状应该是要影响的 (DIR)。vision里的“改写”效果其实比NLP好很多，也许更好用也说不定 :)</p>
<p>　　对设计系统而言，我觉得比较重要的是抽取基本组件。在NLP版本的CheckList里有一个重要组件就是写生成template/模板；也许在vision里则是需要提供一些基础像素之类的。</p>
<p>　　当然也可以考虑除了行为和单元测试之外的测试思想，比如如果是pipeline模型，考虑如何设计集成测试也许也会很有用 :)</p>
<p>　　<strong>AI 科技评论：</strong>可以简单介绍一下你们的团队成员吗，以及你们的近期工作、未来研究方向？</p>
<p>　　<strong>吴彤霜：</strong>隆重介绍一下没有出镜的一作吧，marco也是华大的博士，2018年毕业以后就加入了微软研究院，主要在做模型可解释性和分析，之前很有名的LIME（一种解释机器学习模型的方法——Local Interpretable Model-Agnostic Explanations）就是出自他手。除了CheckList，他今年在CVPR上也有一篇合作论文，是分析vqa model的稳定性的。现在主要在做vision模型的错误分析以及模型比较。</p>
<p>　　我们现在也在合作一个新工作，这项工作更多是关于如何人去探索模型的可解释性。虽然现在主要做的都是人如何检查模型，但是我们对于模型如何能反过来规范人或者帮助人也很感兴趣 :) 三四作Carlos和Sameer都是marco的导师，分别是ML和NLP的大佬。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>　　虽然CheckList目前也有一些不足比如CheckList不能直接用于非行为问题，例如数据版本控制问题、标记错误、注释器偏差、最坏情况下的安全问题或缺乏可解释性。</p>
<p>　　但是不可否认的是，使用CheckList创建的测试可以应用于任何模型，这使得它很容易被纳入当前的基准测试或评估pipeline中。用户研究表明，CheckList很容易学习和使用，对已经对模型进行了长时间测试的专家用户以及在任务中缺乏经验的实践者都很有帮助。</p>
<p>　　另外对吴同学的专访，我们相信， 本篇论文工作确实开创地把软件测试系统引入NLP模型的测试之中并且提供了完善的测试工具。 这将会给社区和企业带来很大的商业价值，比如CheckList测试工具将会节省很大的人力成本。</p>
<p>　　最后，我们相信，这种系统引进软件测试的思想也将会在CV乃至整个AI领域大有作为。</p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>[Behind the Scene] Revealing the Secrets of Pre-trained Vision-and-Language Models</title>
    <url>/2021/03/05/Behind-the-Scene-Revealing-the-Secrets-of-Pre-trained-Vision-and-Language-Models/</url>
    <content><![CDATA[<h3 id="本文研究的任务"><a href="#本文研究的任务" class="headerlink" title="本文研究的任务"></a>本文研究的任务</h3><p>最近Transformer-based 大规模预训练模型推动了 多模态任务的发展，比如，ViL-BERT，LXMERT and UNITER。然而，对于使它们取得成功的<strong>内部机制</strong>知之甚少。为了揭示内部机制，本文提出了VALUE（Vision-And-Language Understanding Evaluation），一组精心设计的<strong>探测任务</strong>（probing task, eg: Visual Coreference Resolution, Visual Relation Detection），可推广到标准的预训练V + L模型， 破译多模式预训练的内部运作方式（例如，在各个attention heads 中获得的隐性知识，通过上下文化多模式嵌入学习的 inherent cross-modal alignment）。</p>
<h3 id="本文的实验发现"><a href="#本文的实验发现" class="headerlink" title="本文的实验发现"></a>本文的实验发现</h3><p>经由这些探测任务，通过对每个原型模型体系结构的广泛分析，我们的主要观察结果是：（i）预训练的模型在推理过程中表现出对文本而不是图像的关注。 （ii）存在专门为捕获cross-modal interactions 而设计的 a subset of attetion heads（iii）在多个预训练模型中学习的注意力矩阵显示出图像区域和文本单词之间的<strong>潜在对齐</strong>，表现出<strong>一致的模式</strong>。 （iv）绘制的注意力模式(attention patern)揭示了图像区域之间的视觉可解释的关系。 （v）纯粹的语言知识也被有效地编码在注意力集中。 这些宝贵的见解可指导未来的工作，以设计更好的模型架构和多模式预训练的目标。</p>
]]></content>
  </entry>
  <entry>
    <title>Blank Language Model</title>
    <url>/2020/12/30/Blank-Language-Model/</url>
    <content><![CDATA[<h3 id="yaya-序"><a href="#yaya-序" class="headerlink" title="yaya 序"></a>yaya 序</h3><h4 id="直接做文本填充任务的模型"><a href="#直接做文本填充任务的模型" class="headerlink" title="直接做文本填充任务的模型"></a>直接做文本填充任务的模型</h4><ul>
<li><p>目前已知的做文本填充的模型有ilm, BLM</p>
<blockquote>
<p><strong>ilm</strong>: <strong>(ACL 2020) Enabling Language Models to Fill in the Blanks</strong></p>
<p><strong>BLM</strong>:  <strong>(EMNLP 2020) Blank Language Models</strong></p>
<p>Text Infilling</p>
<p>Langsmith An Interactive Academic Text Revision System</p>
<p>MaskGAN Better Text Generation via Filling in the__</p>
<p> (ACL 2020) INSET Sentence Infilling with INter-SEntential Transformer</p>
</blockquote>
</li>
</ul>
<h4 id="直接可以做文本填充任务的模型"><a href="#直接可以做文本填充任务的模型" class="headerlink" title="直接可以做文本填充任务的模型"></a>直接可以做文本填充任务的模型</h4><ul>
<li><p>其次，做文本任务 对抗的一些任务，其实也可以看做文本填充</p>
<ul>
<li>AdvExpander Generating Natural Language Adversarial Examples by Expanding Text</li>
<li>BERT-ATTACK Adversarial Attack Against BERT Using BERT</li>
<li>Generate Your Counterfactuals Towards Controlled Counterfactual Generation for Text</li>
</ul>
</li>
<li><p>另外 padlepadle/ ERNIE 的预训练任务，不使用 sub-word 来随机掩码，而是使用 fragment来做随机掩码，其预训练模型，也是可以用来做文本填充的。但是可能性能没有那么可靠</p>
</li>
</ul>
<h3 id="BLM介绍"><a href="#BLM介绍" class="headerlink" title="BLM介绍"></a>BLM介绍</h3><p>来源： <a href="https://mp.weixin.qq.com/s/cVUT4FMpgqARuWf5dWY0bA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/cVUT4FMpgqARuWf5dWY0bA</a></p>
<p>讲者提出了填空语言模型（Blank Language Model, BLM），<strong>该模型通过动态创建和填充空白来生成序列</strong>。空白用于控制要扩展序列的那一部分，使BLM成为各种文本编辑任务的理想选择。<strong>该模型可以从单个空白或在指定位置带有空白的部分完成文本开始，迭代地确定要在空白中放入哪个单词以及是否插入新的空白，并在没有新的空白填充时停止生成。</strong>使用边缘似然的下界可以有效地训练BLM。在填充缺失文本的任务上，BLM在准确性和流利性方面均明显优于所有其他方法。在情感迁移和修复古文字的实验中，证明该框架具有广泛的应用潜力。</p>
<h4 id="一、动机：传统语言模型的局限性"><a href="#一、动机：传统语言模型的局限性" class="headerlink" title="一、动机：传统语言模型的局限性"></a><strong>一、动机：传统语言模型的局限性</strong></h4><p>传统的语言模型通常是从左到右对文本序列进行建模，其模式是，首先生成第一个词，然后以第一个词作为condition来生成第二个词，继而以第二个词为condition生成第三个词，如此迭代计算后一个词。</p>
<p>该方法的优势在于算法简单、有效。但大多情况下，并不需要从头开始生成文本，而是已有部分文本，想自动生成剩下的部分内容。比如，文本编辑，是基于已有的draft，修改文本中任意位置的内容；或是template filling，针对一些表格等具有固定格式的文件，比如医疗或者法律文件等进行填空；或是text restoration，比如一些文件可能在任意位置缺失相关内容，需要做的是复原损失部分。由于Left-to-Right Language Model仅仅考虑blanks左边的文本语境，不能很好地对这些应用进行建模。</p>
<p><img src="https://i.loli.net/2020/12/30/b4piu9OP6x3VINC.png" alt="image-20201230120139264" style="zoom:50%;"></p>
<p><strong>因此，讲者提出了Blank Language Model（BLM）</strong>，其输入形式为任意文本，blanks可存在于文本的任意位置；每一个blank可以对应任意多个单词；且BLM模型会结合上下文语境决定需要填充几个单词。BLM与Mask Language Model的区别在于，Mask Language Model的一个mask只能对应一个单词，因此如果预先不知道blank中间丢失多少个单词，就不能使用Mask Language Model来实现。</p>
<p><img src="https://i.loli.net/2020/12/30/uN759vob1MEhyRO.png" alt="image-20201230120251358" style="zoom:50%;"></p>
<h4 id="二、实现：什么是BLM"><a href="#二、实现：什么是BLM" class="headerlink" title="二、实现：什么是BLM?"></a>二、实现：什么是BLM?</h4><h4 id="1）BLM工作原理介绍"><a href="#1）BLM工作原理介绍" class="headerlink" title="1）BLM工作原理介绍"></a><strong>1）BLM工作原理介绍</strong></h4><p><strong>BLM具体是如何实现填空的呢？</strong>首先存在一个画布，有单词和blank，其中blank用来控制单词能被放置的位置；然后BLM模型在这个画布上动态进行修改，每一步都会选择一个待填充的blank。</p>
<p>由于每个blank可以对应任意数量的词，因此当填充这个word w之后，还要决定是不是只填一个字，或者在w左边、右边、还是两边各补上blank。由此每个blank就可以继续迭代，且被扩展成任意多个词，当没有blank留下，模型达到终止条件。其实现步骤如图3所示。</p>
<p><img src="https://i.loli.net/2020/12/30/41uMQY2dqSroxZD.png" alt="image-20201230120357144" style="zoom:50%;"></p>
<p>yaya 觉得以下这个例子更好一些</p>
<p><img src="https://i.loli.net/2020/12/30/1N9C5R4ecJM6ADB.png" alt="image-20201230120728774" style="zoom: 50%;"></p>
<p><strong>讲者举如下例子，进一步说明模型的实现步骤。</strong>原句是They also have <strong><strong> which </strong></strong>.通过从canvas中一步步选择合适的word和blank，直至句子中没有新的blank生成为止，实现句子填空。</p>
<p><strong>继而，讲者概括BLM的工作方式</strong>，类似于一个Grammar，如图4所示。其与传统语法<strong>Context-Free Grammar</strong>的区别在于：讲者所提出的模型在<strong>Production rules</strong>上面的概率分布是取决于模型参数和当前的<strong>context</strong>。</p>
<p><img src="https://i.loli.net/2020/12/30/ucYZU5Ld7T9tysv.png" alt="image-20201230120451316" style="zoom: 50%;"></p>
<h4 id="2）BLM框架介绍"><a href="#2）BLM框架介绍" class="headerlink" title="2）BLM框架介绍"></a>2）BLM框架介绍</h4><p>首先采用transformer模块，将input通过这个transformer以得到一系列的representation，每个representation包含有其context信息；</p>
<p>然后将所有blank位置的representation通过Linear project和softmax得到blanks上的distribution，选择其中一个（假设是第二个）；</p>
<p>进一步将被选中的blank representation投影到整个vocabulary，由此可预测一个词，比方说预测really；</p>
<p>最后，将blank representation和被预测词的word embedding进行拼接，都输入给一个MLP进行如图所示的四种情况分类。假设是第四种情况，得到<strong><strong> really </strong></strong>，然后将其fill到第二个Blank中，并继续这个过程直至没有新的blank生成。</p>
<p><img src="https://i.loli.net/2020/12/30/9jZpWxPyeuR3Cdn.png" alt="image-20201230121033747" style="zoom: 50%;"></p>
<p>从一个初始的blank到一个没有blank的complete text这个过程称为<strong>trajectory</strong>，包括每一步的canvas和action；每一步的action包括了choose a blank，predict a word 以及create new blanks。</p>
<p>如果一个句子有n个单词，那么会有n！种不同的trajectory都可以生成它，每一种trajectory对应着不同的word insertion order。如图6所示的trajectory就对应着word insertion order “3 1 10 6 2 8 4 7 5 9” 。</p>
<p>因此，生成一个句子x的概率就是以所有trajectory/word insertion order生成它的概率之和，公式中的Sn为所有的n排列。而给定order，就可以确定每一步的canvas和action，概率可相应分解为每一步的概率的乘积。</p>
<p><img src="https://i.loli.net/2020/12/30/k4ZMPjR5TmFycXA.png" alt="image-20201230130236667" style="zoom:50%;"></p>
<p><strong>如何高效的训练BLM呢？</strong>讲者对上述的likelihood进行估计，对等式两边取log，并借助图7中蓝色不等式可得到最终评估的loss。但同时讲者介绍到该训练方式与left-to-right language model相比并不高效，原因在于：Left-to-Right Language Model在一个pass中是同时计算了n个词的Loss，而上述公式在一个pass中只计算了一个action loss。</p>
<p>基于此，讲者进一步介绍到ctx,o只与word insertion order o的前t个词有关，因此可在一个pass中，将前t个order相同且在t+1时不同的trajectory进行组合，共同计算loss。同时由于EOt+2:n不会影响第t步的action和canvas，则可改写最终的loss表达，实现在一个pass中计算期望n/2个action loss。</p>
<p><img src="https://i.loli.net/2020/12/30/2xnYKAswB6RO47o.jpg" alt="图片"></p>
<p>综上所述，BLM的training的规则如图8所示。讲者通过一个实例，详细介绍了模型的训练过程，给定sentence x，先sample t，再sample order o1:t，由此可构建动态画布ctx,o，并按照图7的loss进行训练。</p>
<p><img src="https://i.loli.net/2020/12/30/lUAgSP1uOX9r7sH.png" alt="image-20201230130440892" style="zoom:50%;"></p>
<p>训练好BLM后，可采用greedy decoding或beam search来填充输入文本中的空白。需要注意的是，greedy decoding/beam search寻找的不是具有最大边缘似然p(x;θ)的sentence，而是具有最大联合似然p(x;o;θ)的sentence 和trajectory。</p>
<h4 id="三、实验"><a href="#三、实验" class="headerlink" title="　三、实验"></a>　三、实验</h4><p>讲者主要进行了4种不同的实验验证模型的有效性，分别为<strong>Text infilling，Ancient text restoration，Sentiment transfer以及Language modeling。</strong>下述针对<strong>Text infilling</strong>的实验进行阐述。</p>
<h5 id="1）Text-infilling"><a href="#1）Text-infilling" class="headerlink" title="1）Text infilling"></a>1）Text infilling</h5><p>选择Yahoo Answers（100k的文档，且最大长度的为200个单词）作为实验数据集；在该数据集上随机mask掉比例为r的tokens，将连续的masked tokens用blank代替，由此得到的数据集作为测试数据集。在评价指标方面，分别选择Accuracy和Fluency来评价模型的有效性。具体是指通过计算初始文档与模型filling后文档间的BLEU score表征Accuracy；采用经过预训练的Left-to-Right Language Model计算perplexity表征Fluency。</p>
<p><strong>讲者分别选择以下模型作为在Baseline models:</strong></p>
<p><strong>a.BERT+LM</strong></p>
<p>指采用BERT模型得到每一个blank的representation，并将其输入给Left-to-Right Language Model生成不同blanks对应的tokens。</p>
<p><strong>b.Masked Language Model with oracle length (MLM)</strong></p>
<p>由于模型需要知道每一个blank对应单词个数，因此给定oracle length数量的masked tokens来代替blanks；此外MLM模型同时预测masked tokens时是相互独立的，并没有考虑filling的部分之间的consistency，因此使用most-confident-first heuristic来autoregressively一个一个进行填写。</p>
<p><strong>c.Insertion Transformer (Stern et al., 2019)</strong></p>
<p>该模型支持动态单词插入，与BLM不同，该模型可在所有位置插入，因此强制模型只在指定位置进行插入，避免出现较高的失败率。</p>
<p><strong>d.Seq2seq-full/fill (Donahue et al., 2020)</strong></p>
<p>指直接输出infill之后的句子序列，或者直接输出代替blanks的tokens并用分隔符“|”划分。这两种方法具有较高的失败率。</p>
<p><img src="https://i.loli.net/2020/12/30/2LU8x5dlnCcOJmH.png" alt="image-20201230131800545" style="zoom:50%;"></p>
<p>图a)</p>
<p><img src="https://i.loli.net/2020/12/30/aZrSFqPjty67nXu.png" alt="image-20201230131732735" style="zoom:50%;"></p>
<p>图 b)</p>
<p>图9 Text infilling 实验结果</p>
<p>实验结果如图9所示，其中图a)说明当mask ratio 越来越高时，所有模型的BLUE score都会降低，同时BLM表现出最高的BLUE score；图b)中BLM与InsT模型的perplexity要低于original data的perplexity，且当mask ratio 越来越高时，模型最终的output比原始data要更加typical，则perplexity会越来越低。</p>
<h4 id="四、结论与展望"><a href="#四、结论与展望" class="headerlink" title="四、结论与展望"></a>四、结论与展望</h4><p>讲者提出了BLM可以用来灵活地生成文本，其生成方式是动态创建以及填充blanks。实验表明BLM模型在Text infilling，Ancient text restoration和Sentiment transfer上具有很好的表现。</p>
<p>BLM也具有广阔的应用前景，比如Template filling，information fusion以及assisting human writing；同时BLM也可被扩展为conditional model，可以用来edit和refine机器翻译，或者在dialogue中根据给定内容生成一句话；最后可以探究BLM跟MLM/BERT在representation的学习上的差异性。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/8ld6oicYkZZtRCNqJf5KRcmmFmYpBTS6hibiad1Gyib2x0Lt4qGWjuMCERiaGibUT5ibK0ezrHch0nMNJqDnibRgELdMRQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>图12 结论与展望</p>
<h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a><strong>参考文献：</strong></h3><p>Mitchell Stern, William Chan, Jamie Kiros, and Jakob Uszkoreit. 2019. Insertion transformer: Flexible sequence generation via insertion operations. arXiv preprint arXiv:1902.03249.</p>
<p>Chris Donahue, Mina Lee, and Percy Liang. 2020. Enabling language models to fill in the blanks. arXiv preprint arXiv:2005.05339.</p>
<h3 id="论文地址："><a href="#论文地址：" class="headerlink" title="论文地址："></a><strong>论文地址：</strong></h3><p><a href="https://arxiv.org/pdf/2002.03079.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/2002.03079.pdf</a></p>
<h3 id="Github地址："><a href="#Github地址：" class="headerlink" title="Github地址："></a><strong>Github地址：</strong></h3><p><a href="https://github.com/Varal7/blank_language_model" target="_blank" rel="noopener">https://github.com/Varal7/blank_language_model</a></p>
]]></content>
      <categories>
        <category>NLP</category>
        <category>Text-Filling</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Bottom-Up and Top-Down Attention for Image Captioning and Visual Question Answering</title>
    <url>/2021/03/15/Bottom-Up-and-Top-Down-Attention-for-Image-Captioning-and-Visual-Question-Answering/</url>
    <content><![CDATA[<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>人类视觉系统存在两种attention机制。Top-down attention由当前任务所决定，我们会根据当前任务（即VQA中的问题），聚焦于与任务紧密相关的部分。Bottom-up attention指的是我们会被显著的、突出的、新奇的事物给吸引。</p>
<p>以前的方法用到的visual attention mechanisms大都属于top-down类型，即取问题作为输入，建模attention分布，然后作用于CNN提取的图像特征（image features）。然而，这种方法的attention作用的图像对应于下图的左图，没有考虑图片的内容。对于人类来说，注意力会更加集中于图片的目标或其他显著区域，所以作者引进Bottom-up attention机制，如下图的右图所示，attention作用于object proposal。</p>
<p><img src="https://i.loli.net/2021/03/15/p8WFURqkGw6iIfC.png" alt="image-20210315150105258" style="zoom:50%;"></p>
<h2 id="Basic-idea"><a href="#Basic-idea" class="headerlink" title="Basic idea"></a>Basic idea</h2><p>Bottom-Up注意力机制: 即基于目标（objects）或显著区域（salient image regions）来计算attention。具体来说，bottom-up机制基于Faster R-CNN，得到图片中每个目标或显著区域的特征向量（feature vector）表示。</p>
<p>Top-Down机制: 取question作为输入，建模特征权重（feature weightings）或者说attention分布。</p>
<h2 id="概括："><a href="#概括：" class="headerlink" title="概括："></a>概括：</h2><p><strong>（1）Bottom-Up</strong><br>使用Faster R-CNN 中的R-CNN来得到object feature。<br><strong>（2）Top-Down Attention</strong><br>得到了该层的隐层状态，并与object features  中的每一个<strong>v<sub>i</sub></strong>来计算一个attention 系数。<br><strong>（3）对object features 进行attention 权重求和</strong><br>得到image feature<br><strong>（4）Decoder：language LSTM</strong><br>输出预测单词</p>
<p><img src="https://i.loli.net/2021/03/15/IcK4HYAsGwjzPqv.jpg" alt="img" style="zoom: 67%;"><br><img src="https://i.loli.net/2021/03/15/lqZx5tngfd9r2Gs.jpg" alt="img" style="zoom:50%;"></p>
<h2 id="Bottom-Up"><a href="#Bottom-Up" class="headerlink" title="Bottom-Up"></a>Bottom-Up</h2><ul>
<li><strong>主要介绍一下Faster R-CNN 的训练过程</strong><br>（1）首先Resnet-101 是在ImageNet上预训练的<br>（2）Faster R-CNN在MS COCO上进行预训练<br>rpn 的score classification loss，bbox regression loss<br>r-cnn 的score classification loss，bbox regression loss<br>（3）Faster R-CNN在Visual Genome上再进行预训练<br>为了得到更好的特征表达，增加一个预测属性的输出： </li>
<li><strong>具体的网络：</strong><br>To predict attributes for region i, we concatenate the mean  pooled convolutional feature vi with a learned embedding  of the ground-truth object class, and feed this into an additional output layer defining a softmax distribution over each  attribute class plus a ‘no attributes’ class.</li>
</ul>
]]></content>
      <categories>
        <category>图像描述</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>Bridging the Gap between Training and Inference for Neural Machine Translation</title>
    <url>/2021/03/15/Bridging-the-Gap-between-Training-and-Inference-for-Neural-Machine-Translation/</url>
    <content><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>本文是ACL 2019 的 最佳长文奖。</p>
<p><strong style="color:red;">论文主要解决神经网络在翻译领域，训练和测试时所用的上文信息不同造成的偏差问题。</strong></p>
<p><strong>论文提出了新的训练方法，而非新的模型。读完之后，发现这种方法适用于许多领域的训练-测试不匹配的问题，如：阅读理解、语言模型。</strong></p>
<h2 id="2-存在的问题"><a href="#2-存在的问题" class="headerlink" title="2. 存在的问题"></a>2. 存在的问题</h2><p>传统的神经机器翻译有两个问题：</p>
<ul>
<li><strong>exposure bias</strong> （训练和测试时所用的上文信息不同的问题）</li>
<li><strong>overcorrection</strong>（过度矫正）</li>
</ul>
<h3 id="2-1-exposure-bias"><a href="#2-1-exposure-bias" class="headerlink" title="2.1 exposure bias"></a>2.1 exposure bias</h3><p>那么，什么叫<code>训练和测试时所用的上文信息不同的问题</code>呢？</p>
<p>训练时, 无论上一步模型的预测输出是什么，在当前步decoder模型的输入都是ground truth word的，即：模型的输入都是正确的，如：<strong>are</strong> 。</p>
<p><img src="https://i.loli.net/2021/03/14/tMrJqWR1huDFHQ4.png" alt="image-20210314192737439" style="zoom:33%;"></p>
<p>在测试时，由于没有正确答案，所以用模型预测的上一个字的结果作为输入，如：is、 you 。</p>
<p>这就导致了在测试时，<strong>如果在某个地方预测错，那么之后模型的输入都是错误的</strong>，这就造成了错误会一直累积；或许模型在某个地方所预测的是另一种翻译的词，但是在训练时没有碰到过这种情况，所以模型无法进行处理。</p>
<p>这种偏差叫做<code>exposure bias</code>。</p>
<h3 id="2-2-overcorrection"><a href="#2-2-overcorrection" class="headerlink" title="2.2 overcorrection"></a>2.2 overcorrection</h3><p>训练翻译模型时，还会碰到另一个问题：<strong>overcorrection</strong>（过度矫正）</p>
<p>什么意思呢？</p>
<p><img src="https://i.loli.net/2021/03/15/k8USC1drMGB6Jwh.png" alt="img"></p>
<p>当模型在第三个位置预测出‘abide’时，为了让这句话的loss最小，模型之后会预测 with the rule，但是 abide with the rule 是错误的；正确的应该是 abide by the rule。</p>
<p>注解: abide 与 by 搭配，而不是与with 搭配。</p>
<h2 id="3-Method"><a href="#3-Method" class="headerlink" title="3. Method"></a>3. Method</h2><p><img src="https://i.loli.net/2021/03/14/QLSZEk4dqNln6jV.png" alt="image-20210314193828727" style="zoom:50%;"></p>
<p>为了消除或减轻train阶段和infer阶段的差别, 论文提出从真实的词 $y_{t-1}^{*}$ 和预测的词 $y_{t-1}^{\text {oracle }}$ 中抽样, decoder根据抽样的词来预测下一个词 $y_{t}$ 。使用论文提出的方法, 在时间步 $t$ 预测 $y_{t}$ 分为三步:</p>
<p>[1] 设真实输出中上一个词为 $y_{j-1}^{*}$ 。从预测的词中选择oracle word $y_{j-1}^{\text {oracle }},$ 论文提出了两种方法来选择oracle word，分别是词级别的方法和句子级别的方法。</p>
<p>[2] 接着从 $\left\{y_{j-1}^{\text {oracle }}, y_{j-1}^{<em>}\right\}.$ 中抽样一个词，抽中 $y_{j-1}^{</em>}$ 的概率为 $p$, 抽中 $y_{j-1}^{\text {oracle }}$ 的概率为 $1-p_{\circ}$ </p>
<p>[3] 最后, decoder根据抽样的这个词来预测 $y_{j}$。</p>
<h3 id="3-1-Oracle-Word-Selection"><a href="#3-1-Oracle-Word-Selection" class="headerlink" title="3.1 Oracle Word Selection"></a>3.1 Oracle Word Selection</h3><p>传统的方法中， decoder会根据上一个时间步真实的 $y_{t-1}^{*}$ 来预测 $y_{t}$ 。</p>
<p>为了消除train阶段的infer阶段的 差别，可以从预测的词中选择oracle word $y_{t-1}^{\text {oracle }}$ 来代替 $y_{t-1^{\circ}}^{*}$ </p>
<p>一种方法是每个时间步采用词级别的 greedy search来生成oracle word, 称为word-level oracle(WO)。另一种方法是采用beam-search, 扩大搜索空间, 用句子级的衡量指标(如：BLEU)对beam-search的结果进行排序，称为sentence-level oracle(SO).</p>
<h4 id="3-1-1-Word-Level-Oracle"><a href="#3-1-1-Word-Level-Oracle" class="headerlink" title="3.1.1 Word Level Oracle"></a>3.1.1 <strong>Word Level Oracle</strong></h4><p><img src="https://i.loli.net/2021/03/14/oJlrVILE6FgkcyM.png" alt="image-20210314200245535" style="zoom: 33%;"></p>
<p><img src="https://i.loli.net/2021/03/14/wc7Ql4js39KBCXg.png" alt="image-20210314200310765" style="zoom:33%;"></p>
<p>选择 $y_{t-1}^{\text {oracle }}$ 最简单直观的方法是, 在时间步$t$-1 , 选择公式 $P_{t-1}$ 中概率最高的词作为 $y_{t-1}^{\text {oracle }},$ 如Fig.2所 示。 为了获得更健壮的 $y_{t-1}^{\text {oracle }}$, 更好地选择是使用<a href="https://www.cnblogs.com/initial-h/p/9468974.html" target="_blank" rel="noopener">gumbel max技术</a>来冲离散分布中进行抽样, 如 Fig.3所示。<br>具体地讲, 将gumbel noise <strong style="color:blue;">$\eta$</strong> 作为正则化项加到decoder的预测概率分布上，进而再做softmax操作。</p>
<p>$\eta=-\log (-\log u)$<br>$\tilde{o}_{j-1}=\left(o_{j-1}+\eta\right) / \tau$<br>$\tilde{P}_{j-1}=\operatorname{softmax}\left(\tilde{o}_{j-1}\right)$</p>
<p>其中变量 $u \sim U(0,1)$ 服从均匀分布。 $\tau$ 为温度系数, 当 $\tau \rightarrow 0$ 时， 公式(8)的softmax()逐渐相当于<br>$\operatorname{argmax}()$ 函数 $;$ 当 $\tau \rightarrow \infty$ 时, $\operatorname{softmax}()$ 函数逐渐相当于均匀分布。</p>
<p>则 $y_{t-1}^{\text {oracle }}$ 为：$y_{j-1}^{\text {oracle }}=\operatorname{argmax}\left(\tilde{P}_{j-1}\right)$</p>
<p>需要注意的是gumbel noise $\eta$ 只用来选择oracle word，而不会影响train阶段的目标函数。</p>
<h4 id="3-1-2-Sentence-Level-Oracle"><a href="#3-1-2-Sentence-Level-Oracle" class="headerlink" title="3.1.2 Sentence Level Oracle"></a>3.1.2 <strong>Sentence Level Oracle</strong></h4><p>在每一次训练前，模型先用 beam search找到最好的 k 个候选翻译，然后将这 k 句话与正确答案计算 BLEU得分，取得分最高的当作备选句子。</p>
<p>有了备选句子后怎么办？比如，模型现在要预测第四个词，那么模型的输入是第三个词，这第三个词可以是正确译文的第三个词（传统做法）、可以是模型所预测的第三个词（Word Level）、也可以是这句备选句子的第三个词（Sentence-Level）。</p>
<p>现在有一个问题： 如果备选句子的长度与答案的长度不一样怎么办，这样备选句子与ground truth不是一一对应的了，那么这样的替换就没有意义了，因为我们希望这个词和对应答案的词是意思相近的或者是近义词。</p>
<p>作者给出了办法：</p>
<p>beam search在生成句子时，直到模型预测出结尾符<eos>才结束。</eos></p>
<p>假设ground truth的长度是 n ：</p>
<p>1、若模型在 n 之前就预测出<eos>结尾符，那么，我们选择概率第二的作为预测词。</eos></p>
<p>2、若模型在 n 时没有预测出<eos>结尾符，那么，我们选择<eos>结尾符，并使用它的概率。</eos></eos></p>
<p>作者的思路就是这样，然后就是最小化每一个字与<strong>ground truth</strong>对应字的负似然对数。</p>
<p>是与<strong>原始的ground truth</strong>的词计算loss！！！ 而不是与替换了的词，这个替换只发生在模型的输入。</p>
<h3 id="3-2-Sampling-with-Decay"><a href="#3-2-Sampling-with-Decay" class="headerlink" title="3.2 Sampling with Decay"></a>3.2 Sampling with Decay</h3><p>在train阶段刚开始时，抽中真实的词 $y_{j-1}^{*}$ 的概率比较大，随着模型逐渐收敛，抽中预测的词 $y_{j-1}^{\text {oracle }}$ 的概率变大，让模型有能力处理”过度纠正的问题”。</p>
<p>在训练的初始阶段, 如果过多地选择 $y_{t-1}^{\text {oracle }},$ 会导致模型收敘速度慢; 在训练的后期阶段，如果过多地选择 $y_{t-1}^{*},$ 会导致模型在train阶段没有学习到如何处理infer阶段的差别。 </p>
<p>因此，好的选择是：在训练的初始阶段， 更大概率地选择 $y_{t-1}^{*}$ 来加快模型收敛，当模型逐渐收敛后, 以更大概率选择 $y_{t-1}^{\text {oracle }},$ 来让模型学习到如何处理infer阶段的差别以及让模型有能力处理”过度纠正的问题”。从数学表示上，概率 $p$ 先大后逐渐衰减，$p$ 随着训练轮数 $e$ 的增大而逐渐变小。</p>
<p>$p=\frac{\mu}{\mu+\exp \left(\frac{e}{\mu}\right)}$</p>
<p><img src="https://i.loli.net/2021/03/15/H6U7Dc5wP8KAsNG.png" alt="image-20210315173055286" style="zoom: 67%;"></p>
<h3 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h3><p>本文主要的两点贡献：</p>
<p>(1) word level oracle selection</p>
<p>(2) sampling with decay</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://zhuanlan.zhihu.com/p/76227765" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/76227765</a></p>
<p><a href="https://spring-quan.github.io/2019/08/02/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E3%80%8ABridging-the-Gap-between-Training-and-Inference-for-Neural-Machine-Translation%E3%80%8B/" target="_blank" rel="noopener">https://spring-quan.github.io/2019/08/02/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E3%80%8ABridging-the-Gap-between-Training-and-Inference-for-Neural-Machine-Translation%E3%80%8B/</a></p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>C3D</title>
    <url>/2019/04/09/C3D/</url>
    <content><![CDATA[<h2 id="pytorch-中"><a href="#pytorch-中" class="headerlink" title="pytorch 中"></a>pytorch 中</h2><h3 id="Conv2d"><a href="#Conv2d" class="headerlink" title="Conv2d"></a>Conv2d</h3><p><a href="https://pytorch.org/docs/stable/nn.html#conv2d" target="_blank" rel="noopener">https://pytorch.org/docs/stable/nn.html#conv2d</a><br>the shape of input:  <font size="5," color="#0099ff">batch×channel×height×width</font></p>
<h2 id="Conv3d"><a href="#Conv3d" class="headerlink" title="Conv3d"></a>Conv3d</h2><p><a href="https://pytorch.org/docs/stable/nn.html#conv3d" target="_blank" rel="noopener">https://pytorch.org/docs/stable/nn.html#conv3d</a><br>the shape of input: <font size="5," color="#0099ff">batch×channel×depth×height×width</font></p>
<h2 id="C3D-用于行为识别-1-2"><a href="#C3D-用于行为识别-1-2" class="headerlink" title="C3D 用于行为识别[1][2]"></a>C3D 用于行为识别[1][2]</h2><p>[1] C3D 的网络结构</p>
<ul>
<li>输入： bs×3×<font size="5," color="#0099ff">16</font>×H×W，即输入一个长为16的视频序列clip， 实际是 bs×3×16×12×12</li>
<li>输出： bs×feature_size</li>
</ul>
<p>对于一个video，含有N帧，则将这N帧分成16帧的clips，每相邻的两个clips重叠8帧，然后将这些clips得到的fc6 activations 进行平均得到video feature，进而送入分类层得到video class label</p>
<h2 id="解读论文Learning-Spatio-Temporal-Features-with-3D-Residual-Networks-for-Action-Recognition"><a href="#解读论文Learning-Spatio-Temporal-Features-with-3D-Residual-Networks-for-Action-Recognition" class="headerlink" title="解读论文Learning Spatio-Temporal Features with 3D Residual Networks for Action Recognition"></a>解读论文<code>Learning Spatio-Temporal Features with 3D Residual Networks for Action Recognition</code></h2><h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><ul>
<li>当前行为识别的方法，参数量不能过多的原因是，现在可以用于训练的数据集较小，一旦参数量过大，使得模型过拟合</li>
<li>但是，现在有了kinetics 这样的大型数据集，这时，便可以提出一个参数量大的model</li>
</ul>
<h3 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h3><ul>
<li>生成一个用于 spatio-temporal recognition的标准预训练模型</li>
</ul>
<h3 id="关于image-size-部分的介绍"><a href="#关于image-size-部分的介绍" class="headerlink" title="关于image size 部分的介绍"></a>关于image size 部分的介绍</h3><ul>
<li>截取帧时，固定长宽比，并设置高为360（resneXt是240），</li>
</ul>
<h4 id="train"><a href="#train" class="headerlink" title="train"></a>train</h4><ul>
<li>以一个 16 连续帧组成的clip来代表 video</li>
<li>先以最小边为尺寸进行裁剪（裁剪为一个正方形），然后再进行resize 112</li>
<li>为了数据增强，这里有三个trick  (1) 最小边=min(height, weight) * sacle (2) 选取哪个区域进行裁剪，有五种选择 四个角和中心 (3)以50%的概率进行随机水平翻转</li>
</ul>
<h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><ul>
<li>一个video 去选择 没有重叠的所有 16 连续帧，然后对这所有的clip的得分进行取平均作为video的得分</li>
<li>不再进行数据增强</li>
<li>先按照最小边，固定长宽比进行缩放</li>
<li>再 中心裁剪成指定的 <code>112*112</code></li>
</ul>
<h3 id="分析-resnet34-c3d-比-rgb-i3d-差的原因"><a href="#分析-resnet34-c3d-比-rgb-i3d-差的原因" class="headerlink" title="分析 resnet34-c3d 比 rgb-i3d 差的原因"></a>分析 resnet34-c3d 比 rgb-i3d 差的原因</h3><ol>
<li><p>rgb-i3d 使用了64个GPU，可能他们使用的batch size 也比较大。而 resnet34-c3d 仅使用了4个GPU，256 batch size。</p>
</li>
<li><p>rgb-i3d 使用的 clip 分辨率为：3 × 64 × 224 × 224.  而 resnet34-c3d 的 clip 分辨率为 3 × 16 × 112 × 112 。    </p>
<p>即，i3d 使用连续的 <strong>64</strong> 帧组成一个clip，并且 image 分辨率为 <strong>224</strong>，</p>
<p>而， resnet c3d 使用连续的 <strong>16</strong> 帧组成一个clip，并且 image 分辨率为 <strong>112</strong>，</p>
</li>
</ol>
<h2 id="解读论文Can-Spatiotemporal-3D-CNNs-Retrace-the-History-of-2D-CNNs-and-ImageNet"><a href="#解读论文Can-Spatiotemporal-3D-CNNs-Retrace-the-History-of-2D-CNNs-and-ImageNet" class="headerlink" title="解读论文Can Spatiotemporal 3D CNNs Retrace the History of 2D CNNs and ImageNet?"></a>解读论文<code>Can Spatiotemporal 3D CNNs Retrace the History of 2D CNNs and ImageNet?</code></h2><h3 id="Goal-1"><a href="#Goal-1" class="headerlink" title="Goal"></a>Goal</h3><ul>
<li>本文的目的是为了验证当前存在的数据集是否足够支撑训练一个很深的3d网络</li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1] Learning Spatio-Temporal Features with 3D Residual Networks for Action Recognition .  ICCV 2017<br>[2] Can Spatiotemporal 3D CNNs Retrace the History of 2D CNNs and ImageNet?  CVPR 2018</p>
]]></content>
      <categories>
        <category>行为识别</category>
      </categories>
      <tags>
        <tag>行为识别</tag>
      </tags>
  </entry>
  <entry>
    <title>Bridging by Word Image Grounded Vocabulary Construction for Visual Captioning</title>
    <url>/2020/08/01/Bridging-by-Word-Image-Grounded-Vocabulary-Construction-for-Visual-Captioning/</url>
    <content><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>当前 普遍使用的 CNN-RNN 策略，基于整个 training dataset构建 vocabulary，但是，这会<strong>导致生成的句子中的 N-grams 也是在训练集中常见的</strong>，但是语义上却与given image 无关。</p>
<p>为了解决这个问题，本文提出了构建一个 image-grounded vocabulary。具体地，提出了一个 two-step approach，通过结合 visual information 和 relationships among words来构建 新的vocabulary。</p>
<p>并提出了两个策略在 text generation过程中<strong>利用</strong>构建的vocabulary。（1）generator 从image-grounded vocabulary中挑选words （2）soft-attention聚合 vocabulary information 到RNN cell 中来生成下一个单词。</p>
<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p>当前生成单词的方式，是从整个vocab 中select，但是当描述一个 particular image时，the possible words 应该是从一小部分单词集中挑选出来。因此，可以想一个方案，在image caption generation 过程中，有效的约束 word selection space。这将会解决 生成的句子中常常是 irrelavant n-gram problem. </p>
<p>本文，提出构建一个 image-grounded vocabulary，</p>
<h3 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a>Approach</h3><p>整个结构包括两个阶段：(1) image-grounded vocabulary construction, (2) text generation with vocabulary constraints.</p>
<p><strong>The image-grounded vocabulary</strong> constructor builds a  vocabulary related to a given image.</p>
<p><strong>The text generator</strong> with vocabulary constraints generates captions using the constructed vocabulary in two different ways. (1) words generated are strictly limited to those in the image-grounded vocabulary. (2) words in the image-grounded vocabulary are re-weighted within the RNN cell such that they are more likely to be generated.</p>
<h4 id="Image-Grounded-Vocabulary-Construction"><a href="#Image-Grounded-Vocabulary-Construction" class="headerlink" title="Image-Grounded Vocabulary Construction"></a>Image-Grounded Vocabulary Construction</h4><p>caption 中的单词，一般可以分类两类，一类是直接与image content 相关的单词（entities or objects depicted in the image），另一类是function words or words which 没有和image content 有直接的对应关系。</p>
<p>本文假设， directly-related words 可以由视觉信息来决定，而第二类单词，可以由第一类单词之间的relationship 来决定。因此提出了两步策略来构建 image-grounded vocabulary。</p>
<ul>
<li><p>第一步</p>
<p>使用 <code>From captions to visual concepts and back</code> 中提到的方法，获取 textual concept as H.</p>
<p>H中words 与 image 的相关性分布：</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ghbctjwumaj30cz02ga9z.jpg" style="zoom:33%;"></p>
</li>
<li><p>第二步</p>
<p>计算  full vocabulary <code>V</code> 中单词的 相关性分数，</p>
<p>The probability distribution of words in <code>V</code>:</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ghbd1t40doj30if03b3yt.jpg" style="zoom:33%;"></p>
</li>
</ul>
<p>本文挑选 top k words 来构成 <strong style="color:red;">the image-grounded vocabulary ($W_i$) </strong>for given image.</p>
<h4 id="Text-Generation-with-Vocabulary-Constraints"><a href="#Text-Generation-with-Vocabulary-Constraints" class="headerlink" title="Text Generation with Vocabulary Constraints"></a>Text Generation with Vocabulary Constraints</h4><p>提出了两个不同的策略来利用 the image-grounded vocab-ulary $W_i$ 和 word relevance distribution  $S_i^{(V)}$ : 一种，使用$W_i$ 作为 hard constraint; 另一种，聚合每个单词的相关性到 RNN cell 来生成 caption.</p>
<p><strong>Generator with Hard Constraint</strong></p>
<p>正常的方法，是生成 full vocab 的 概率分布，然后取 argmax。</p>
<p>但是在 hard constraint 下，生成 $W_i$ 的概率分布，再取 argmax。</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ghbdj6x0ruj30m402haa0.jpg" style="zoom: 50%;"></p>
<p>对于在 $W_i$ 中没有出现的单词，打掩码：a mask operation $m_i$ is introduced  to replace the $j_{th}$ value in the vector with 1 if $w_j$ is not found in $W_i$ 。</p>
<p><strong>Generator with Soft Constraint </strong></p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ghbdt8khggj31cg0mw4i2.jpg" style="zoom:50%;"></p>
<p>图中展示的 image-grounded vocabulary 其实是 $S_i^{V}$</p>
<p>结合到RNN cell: </p>
<p>这个新的 RNN cell 结合了image-grounded vocabulary，因此，会更加容易生成该vocab中的单词。</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ghbe0h10qcj30pt0avmy9.jpg" style="zoom:33%;"></p>
]]></content>
      <categories>
        <category>图像描述</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>[COCO-LM] Correcting and Contrasting Text Sequences for Language Model Pretraining</title>
    <url>/2021/03/04/COCO-LM-Correcting-and-Contrasting-Text-Sequences-for-Language-Model-Pretraining/</url>
    <content><![CDATA[<p>转自：<a href="https://zhuanlan.zhihu.com/p/353624306" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/353624306</a></p>
<p>该篇文章2021年2月16日上传，提出了一种新的预训练模型的框架，个人认为<strong>COCO-LM结合了许多当下比较新进的思想，在后bert时代，一定程度上突破了对BERT模型传统的预训练方法</strong>。</p>
<p>We present COCO-LM, a new self-supervised learning framework that pretrains Language Models by COrrecting challenging errors and COntrasting text sequences. COCO-LM employs an auxiliary language model to mask-and-predict tokens in original text sequences. It creates more challenging pretraining inputs, where noises are sampled based on their likelihood in the auxiliary language model. COCO-LM then pretrains with two tasks: <strong style="color:blue;">The first task, corrective language modeling</strong>, learns to correct the auxiliary model’s corruptions by recovering the original tokens. <strong style="color:blue;">The second task, sequence contrastive learning</strong>, ensures that the language model generates sequence representations that are invariant to noises and transformations. In our experiments on the GLUE and SQuAD benchmarks, COCO-LM outperforms recent pretraining approaches in various pretraining settings and few-shot evaluations, with higher pretraining efficiency. Our analyses reveal that COCO-LM’s advantages come from its challenging training signals, more contextualized token representations, and regularized sequence representations.</p>
<p><img src="https://i.loli.net/2021/03/04/xOA857rdWJktsEY.png" alt="FireShot Capture 018 -  - arxiv.org"></p>
<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p>在标准语言模型预训练框架内，可以观察到PLM在下游任务上的the empirical performance 仅随着参数大小和预训练成本的指数增长而线性提高，<strong>这是不可持续的</strong>，因为PLM已达到数万亿个参数。</p>
<p>最近的研究揭示了现有预训练框架的某些固有局限性，这些局限性可能导致这种亚线性效率（sublinear efficiency）。【1】一个挑战是，<strong>使用随机更改的文本</strong>（<em>例如</em>，randomly masked tokens）进行预训练会<strong>产生许多非信息性信号</strong>，经过一定程度的预训练后它们不再有用。【2】另外一个挑战是，在 token level 进行预训练不会在 sequence level 上显式学习语言语义，并且在预训练过程中，<strong>Transformers可能无法有效地推广到 higher level 的语义 。</strong></p>
<p>在本文中，我们旨在通过一个<strong>新的自我监督学习框架</strong>COCO-LM来克服这些限制。该框架通过使用 more challenging noises 来 COrrecting and COntrasting text sequences，进而预训练语言模型。</p>
<p>【1】leverages an auxiliary language model，to corrupt text sequences by <strong>sampling more contextually plausible noises</strong> from its masked language modeling (MLM) probability. COCO-LM revives a language modeling task, corrective language modeling (CLM), which pretrains the Transformer to <strong>not only detect the challenging noises in the corrupted texts, but also correct them via a multi-task setting.</strong></p>
<p>【2】To improve the learning of sequence level semantics, COCOLM introduces a sequence level pretraining task, sequence contrastive learning (SCL), that uses contrastive learning to enforce the pretraining model to <strong>align the corrupted text sequence and its cropped original sequence close</strong> in the representation space, while away from other random sequences.</p>
<h3 id="COCO-LM框架延续了ELECTRA预训练模型的思想"><a href="#COCO-LM框架延续了ELECTRA预训练模型的思想" class="headerlink" title="COCO-LM框架延续了ELECTRA预训练模型的思想"></a>COCO-LM框架延续了ELECTRA预训练模型的思想</h3><p>ELECTRA预训练模型主要应用了GAN对抗神经网络的思想，不了解的小伙伴们可以参考一些其他资料，这里我简单说一下我的理解。</p>
<p>GAN对抗神经网络在CV领域上应用比较成熟，在CV的应用上GAN主要包括两个神经网络模型：一个是生成式模型G，一个是判别式模型D。生成式模型的作用是通过随机噪声生成和原始样本相似的数据（注意这里是通过随机噪声），判别式模型的作用是判断给定的实例是真实实例还是人为伪造的（也就是生成式模型所生成的）。那么这里就包含了对抗的思想，即生成式模型的目的是能够生成欺骗判别式模型的实例，判别式模型的目的是判别给定的实例是否是人为伪造的。</p>
<p>ELECTRA当中引用了这样的“对抗”思想，将判别式模型引入到了模型的预训练之中。像BERT、ROBERTA、XLNET等等预训练模型都属于生成式模型，在输入上用 [MASK] 遮蔽掉部分 tokens，再训练一个模型以重建出原始的 tokens。而ELECTRA预训练模型使用了判别式模型，其效果也出乎意料的好。</p>
<blockquote>
<p>ELECTRA: Pre-training Text Encoders as Discriminators Rather Than Generators</p>
</blockquote>
<p>ELECTRA模型的主要思想也是包括了两个神经网络模型：一个生成式模型G，一个生成式模型D。生成式模型G是MLM（Masked Language Model）模型，给定一个真实样例（GAN的生成式模型给定的是随机噪声），用 [MASK] 遮蔽掉部分 tokens，生成替换的tokens；判别式模型D判断输入中每个 token 是否是由生成器生成。其过程如图所示：</p>
<p><img src="https://i.loli.net/2021/03/04/V7kIJGSo3L1m5ua.png" alt="image-20210304111201636" style="zoom:50%;"></p>
<p>通过实验表明这种新的预训练任务比 MLM 更高效，该任务定义于全部的输入 tokens，而非仅仅被遮蔽掉的那一部分小小的输入子集。</p>
<p>在COCO-LM模型中<strong>Corrective Language Modeling (CLM)</strong>也延续了这样的思想。</p>
<h3 id="COCO-LM模型引入了对比学习的思想"><a href="#COCO-LM模型引入了对比学习的思想" class="headerlink" title="COCO-LM模型引入了对比学习的思想"></a>COCO-LM模型引入了对比学习的思想</h3><p>我认为是非常非常棒的创新点。最近刚好再看对比学习的相关paper，更多的是在CV领域中使用了对比学习，而COCO-LM刚好将对比学习带入到了NLP领域中。</p>
<p>什么是对比学习呢？</p>
<p>对比学习是一种自监督的学习方法。其主要思想我的理解是，把正样本距离拉近，正样本与负样本距离拉远。对比学习的例子如下：</p>
<ul>
<li>给每个例子绘制两个独立的增强函数</li>
<li>使用两种增强机制，为每个示例生成两个互相关联的视图</li>
<li>让相关视图互相吸引，同时排斥其他示例</li>
</ul>
<p><img src="https://i.loli.net/2021/03/04/A3wEY1gPnTxIOaQ.jpg" alt="SimCLR论文解读- 知乎" style="zoom:33%;"></p>
<p>如上图，（Z1，Z2），（Z3，Z4）…（Z2n-1，Z2n）这些可以看作正例对，而Z1可以与除Z1、Z2的任何实例组成负例对，如（Z1，Z3）（Z1，Z4）等等。那么这样一个实例X，在一个大小为N的batch里便可以产生一个正例，以及N-1个负例，那么这个 loss 就可以看做是一个 N 分类问题，实际上就是一个交叉熵，由此可以进行网络模型的训练。</p>
<p>以上是我认为COCO-LM框架比较出色的地方，框架的一些细节还需要进一步的理解，之后会进一步的更新，欢迎知乎各位巨佬一起讨论~</p>
<h3 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h3><ul>
<li><p>在预训练任务中，引入了对抗扰动，且通过对比学习的思想来训练。</p>
</li>
<li><p>这种扰动+对比学习的思想，在vision-text pretraining model 中是否有使用？</p>
</li>
<li>本篇的idea 是如何来的，motivation 是什么？</li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Cross-modal Coherence Modeling for Caption Generation</title>
    <url>/2020/04/22/Cross-modal-Coherence-Modeling-for-Caption-Generation/</url>
    <content><![CDATA[<h4 id="现在图像描述中存在的问题"><a href="#现在图像描述中存在的问题" class="headerlink" title="现在图像描述中存在的问题"></a>现在图像描述中存在的问题</h4><ul>
<li>标注方式上：让工作人员标注出image 对应的text。</li>
<li>这导致的问题：（1）Unfortunately, such dedicated annotation efforts cannot yield enough data for training robust generation models; the resulting generated captions are plagued by content<br>hallucinations (Rohrbach et al., 2018; Sharma et al., 2018) that effectively preclude them for being used in real-world applications. </li>
</ul>
]]></content>
      <categories>
        <category>图像描述</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>CV vs PIL</title>
    <url>/2019/03/20/CV-vs-PIL/</url>
    <content><![CDATA[<h2 id="PIL"><a href="#PIL" class="headerlink" title="PIL"></a>PIL</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line">pil_image = Image.open(<span class="string">'test.jpg'</span>) <span class="comment"># 图片是360x480 宽x高  </span></span><br><span class="line">print(type(pil_image)) <span class="comment"># out: PIL.JpegImagePlugin.JpegImageFile  </span></span><br><span class="line">print(pil_image.size)  <span class="comment"># out: (360,480) # w,h  </span></span><br><span class="line">print(pil_image.mode) <span class="comment"># out: 'RGB'  </span></span><br><span class="line">  </span><br><span class="line">pil_image = np.array(pil_image,dtype=np.float32) <span class="comment"># image = np.array(image)默认是uint8  </span></span><br><span class="line">print(pil_image.shape) <span class="comment"># out: (480, 360, 3)  </span></span><br><span class="line"><span class="comment"># 神奇的事情发生了，w和h换了，变成(h,w,c)了  </span></span><br><span class="line"><span class="comment"># 注意ndarray中是 行row x 列col x 维度dim 所以行数是高，列数是宽</span></span><br></pre></td></tr></table></figure>
<blockquote>
<pre><code>输出结果：
&lt;class &#39;PIL.JpegImagePlugin.JpegImageFile&#39;&gt;
(360, 480)
RGB
(480, 360, 3)
</code></pre></blockquote>
<p>这里截图在pycharm下调试的信息（未转化成numpy array之前）</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g193y86ko4j30lt0ixmy8.jpg">  </p>
<blockquote>
<p>可以看到PIL.Image读出的image格式为（w,h,c）且image.mode = ‘RGB’<br>并且由代码的注释可以看到，当PIL.Image转化成numpy.array格式之后，image.size将转为（h,w,c）,c 仍为“RGB”</p>
</blockquote>
<h2 id="CV"><a href="#CV" class="headerlink" title="CV"></a>CV</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line">cv_image = cv2.imread(<span class="string">'test.jpg'</span>)  </span><br><span class="line">print(type(cv_image)) <span class="comment"># out: numpy.ndarray  </span></span><br><span class="line">print(cv_image.dtype) <span class="comment"># out: dtype('uint8')  </span></span><br><span class="line">print(cv_image.shape) <span class="comment"># out: (360,480, 3) (h,w,c) 和skimage类似  </span></span><br><span class="line"><span class="comment"># print(image) # BGR</span></span><br></pre></td></tr></table></figure>
<h2 id="为了比较PIL-和-CV"><a href="#为了比较PIL-和-CV" class="headerlink" title="为了比较PIL 和 CV"></a>为了比较PIL 和 CV</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(cv_image == pil_image)</span><br></pre></td></tr></table></figure>
<p>可以看到 分别是 False True False<br><strong>原因是PIL提取的是“RGB”，而CV提取的是“BGR”</strong><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g194ap1lw4j306d07zmx0.jpg"></p>
<p>综上，可以凝练为以下几点：</p>
<ol>
<li>PIL提取的是PIL.image类型的数据（w,h,c），通道是“RGB”。</li>
<li>将该数据转为numpy.array之后，得到的是（h,w,c），通道仍是“RGB”。</li>
<li>CV提取的是numpy.array类型的数据（h,w,c），注意通道是“BGR”。</li>
</ol>
<ul>
<li>再</li>
<li>在pytorch中输入的image模式是“RGB”</li>
<li>在caffe中输入的是“BGR”</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pytorch_normalze</span><span class="params">(img)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    https://github.com/pytorch/vision/issues/223</span></span><br><span class="line"><span class="string">    return appr -1~1 RGB</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    normalize = tvtsf.Normalize(mean=[<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>],</span><br><span class="line">                                std=[<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">    img = normalize(t.from_numpy(img))</span><br><span class="line">    <span class="keyword">return</span> img.numpy()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">caffe_normalize</span><span class="params">(img)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    return appr -125-125 BGR</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    img = img[[<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>], :, :]  <span class="comment"># RGB-BGR</span></span><br><span class="line">    img = img * <span class="number">255</span></span><br><span class="line">    mean = np.array([<span class="number">122.7717</span>, <span class="number">115.9465</span>, <span class="number">102.9801</span>]).reshape(<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    img = (img - mean).astype(np.float32, copy=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> img</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>[DeepFuse] HKU’s Multimodal Machine Translation System for VMT’20</title>
    <url>/2021/02/26/DeepFuse-HKU%E2%80%99s-Multimodal-Machine-Translation-System-for-VMT%E2%80%9920/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/02/26/bTNP7oqc3nxXfMV.png" alt="image-20210226154022062" style="zoom:50%;"></p>
<p>VATEX： video-guided machine translation(EN-&gt;CH) Challenge</p>
<p>ACL 2020 workshop <a href="https://alvr-workshop.github.io/2020/index.html" target="_blank" rel="noopener">https://alvr-workshop.github.io/2020/index.html</a></p>
<h3 id="以前方法存在的问题"><a href="#以前方法存在的问题" class="headerlink" title="以前方法存在的问题"></a>以前方法存在的问题</h3><p>以前的image-guied Machine Translations, 在encode 阶段，往往单独对 视觉信息和语言信息进行编码。然后，在decode 阶段使用attention将视觉信息结合进来。模态之间的信息仅仅进行了浅融合。</p>
<h3 id="本文提出的方案"><a href="#本文提出的方案" class="headerlink" title="本文提出的方案"></a>本文提出的方案</h3><p>本文中，提出了一个 video-augmented encoder，以此，获得一个multi-modal representation 来作为decoder的输入。使用attention 机器在多个层融合了多模态的表征。</p>
<p>实验证明，这种深融合方法相比于之前的浅融合方法要更加的有效。</p>
<h3 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h3><p><img src="https://i.loli.net/2021/02/26/7qgti5pwnDkcWNZ.png" alt="image-20210226160753355" style="zoom:50%;"></p>
<p>本文提出的visual-augmented encoder 如图1所示，encoder 包括L=6层相同的层。</p>
<p>将sentence表征为一个embedding的输入序列： $\mathbf{X}=x_{1}, x_{2}, \ldots, x_{n}$</p>
<p>将 video 使用I3D提取clips的特征，表征为segment-level feature 的序列：$\mathbf{E}=e_{1}, e_{2}, \ldots, e_{m}$</p>
<h4 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h4><p>The encoder process the input X and E as follows:</p>
<p>【1】input X 输入<strong>Multi-Head attention and Feed Forward</strong> 这两个sub layers， 得到 $H^L$</p>
<p>【2】在video-encoder attention module, 使用$H^L$ 作为 query 来选择与query 相关的 video representation。 </p>
<p>$\overline{\mathcal{H}}=$ Attention $\left(\mathbf{H}^{L}, \mathbf{K}_{E}, \mathbf{V}_{E}\right)$</p>
<p>【3】使用权重求和来得到多模态特征：</p>
<p>$\mathcal{H}=\mathbf{H}^{L}+\lambda \overline{\mathcal{H}}$， where，$\lambda=\operatorname{sigmoid}\left(\mathbf{W}_{\lambda} \overline{\mathcal{H}}+\mathbf{U}_{\lambda} \mathbf{H}^{L}\right)$</p>
<p>【4】最后的输出是：$\operatorname{LayerNorm}\left(\mathbf{H}^{L}+\mathcal{H}\right)$</p>
<p>【yaya】最后一步，似乎是有问题，因为，这样多模态特征，似乎就是加了两遍 $H^L$</p>
<h4 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h4><p>遵循transformer 中 decoder的设计，存在L=6个相同的层。</p>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><h4 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h4><p>学习率的变化曲线：lrate $=d_{\text {model }}^{-0.5} \cdot \min \left(K^{-0.5}, K \cdot N^{-1.5}\right)$，where K is the current number of step and N=4000 is the number of warm-up steps.</p>
<h4 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h4><p>（1）<strong>lstm</strong>: Text-only LSTM-based encoderdecoder NMT </p>
<p>（2）<strong>vatex</strong>: The LSTM-based videoguided machine translation system proposed in VATEX<br>（3）<strong>Transformer</strong>: standard text-only transformer architecture proposed by “Attention is all you need.”</p>
<p><img src="https://i.loli.net/2021/02/26/ZD7SxmKUBMA3tIE.png" alt="image-20210226170500065" style="zoom:33%;"></p>
<ul>
<li>相比于text-only transformer 有一个显著的提高。证明了，使用深层融合来结合视觉信息的有效性。</li>
</ul>
<h3 id="收获与总结"><a href="#收获与总结" class="headerlink" title="收获与总结"></a>收获与总结</h3><ul>
<li><p>本文的关键是提出了使用transformer 的结构来融合文本和视觉信息。</p>
</li>
<li><p>在image-guided machine translation 任务中，也存在两篇使用co-attention 来融合两个模态信息的。如下：</p>
<blockquote>
<p>[1] (ACL 2020) Multimodal Transformer for Multimodal Machine Translation</p>
<p>[2] (ACL 2020) A Novel Graph-based Multi-modal Fusion Encoder for Neural Machine Translation 【Graph Fusion】</p>
</blockquote>
</li>
</ul>
<p>【Graph Fusion】与本文相比，encoder 的设计方式不同，但是decoder的设计是相同的。关于不同：【Graph Fusion】首先对两个模态各自self-attention 而后再根据graph edge 进行co-attention。而本文对视觉信息没有进行self-attention，仅对语言信息进行了self-attention, 在co-attention步骤中也没有显示的graph edge,而是采用了隐式的全连接。</p>
]]></content>
      <categories>
        <category>cross-modal</category>
        <category>video-guided MT</category>
      </categories>
      <tags>
        <tag>cross-modal,video-guided MT</tag>
      </tags>
  </entry>
  <entry>
    <title>Describing like Humans on Diversity in Image Captioning</title>
    <url>/2020/07/17/Describing-like-Humans-on-Diversity-in-Image-Captioning/</url>
    <content><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>当前的automatic metric 仅仅评估 generated caption 与 human annotations 之间的相似性。</p>
<p>但是，一张图片中包含很多内容和细节，不同的人对 image content 会有不同的兴趣点，则 human captions 也会不同。</p>
<p>基于此，仅仅去评估accuracy 是不足以评估captioning models的性能的。生成的captions 的多样性也应该考虑进来。</p>
<p>本文，针对 多样性-diversity 提出了一个评价指标。</p>
<h3 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h3><ul>
<li>即，该文要评价的系统 是可以生成多个caption的系统。是来评估，生成的这几个captions 之间的多样性是怎样的。</li>
<li>本文提到一句话：The drawback of using retrieval model is that the fluency of the captions could be poor [20], and using a very large weight for the retrieval reward will cause the model to repeat the distinctive words.</li>
</ul>
<h3 id="以下转自知乎"><a href="#以下转自知乎" class="headerlink" title="以下转自知乎"></a>以下转自知乎</h3><p><a href="https://zhuanlan.zhihu.com/p/67904095" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/67904095</a></p>
<p>这周读了CVPR 2019一篇有关测试Image Captioning多样性的文章，<a href="https://link.zhihu.com/?target=http%3A//arxiv.org/abs/1903.12020" target="_blank" rel="noopener">Describing like humans: on diversity in image captioning</a>，其主要的亮点是用Latent semantic analysis (LSA)方法来定量地衡量多样性。</p>
<h3 id="Latent-semantic-analysis-LSA"><a href="#Latent-semantic-analysis-LSA" class="headerlink" title="Latent semantic analysis (LSA)"></a>Latent semantic analysis (LSA)</h3><p>1990年的论文<a href="https://link.zhihu.com/?target=http%3A//lsa.colorado.edu/papers/JASIS.lsi.90.pdf" target="_blank" rel="noopener">Indexing by latent semantic analysis</a>最早在信息检索领域提出了LSA，其原理比较简单，核心思想是利用SVD来提取文本的潜在语义信息。</p>
<p>在Image Captioning这个特定的应用场景中，对于一张图片，假设有 <img src="https://www.zhihu.com/equation?tex=m" alt="[公式]"> 条与之相关的caption，且词汇表的总数为 <img src="https://www.zhihu.com/equation?tex=d" alt="[公式]"> ，则这组caption可以用一个 <img src="https://www.zhihu.com/equation?tex=d+%5Ctimes+m" alt="[公式]"> 的矩阵 <img src="https://www.zhihu.com/equation?tex=M" alt="[公式]"> 表示，其中的每个列向量是一条caption的bag-of-words表示。 对 <img src="https://www.zhihu.com/equation?tex=M" alt="[公式]"> 应用SVD进行分解，得到： <img src="https://www.zhihu.com/equation?tex=M+%3D+USV%5E%5Ctop" alt="[公式]"> 。 参考Quora上<a href="https://link.zhihu.com/?target=https%3A//www.quora.com/What-is-an-intuitive-explanation-of-singular-value-decomposition-SVD%23" target="_blank" rel="noopener">对SVD的讨论</a>，我们可以认为，SVD的最大作用是找到数据的“pattern”：</p>
<ul>
<li><img src="https://www.zhihu.com/equation?tex=U" alt="[公式]"> 的每一个列向量代表一种pattern，在这里可以引申为一个topic；</li>
<li>singular values <img src="https://www.zhihu.com/equation?tex=S%3Ddiag%28%5Csigma_1%2C...%2C%5Csigma_m%29" alt="[公式]"> （ <img src="https://www.zhihu.com/equation?tex=%5Csigma_1%3E%5Csigma_2%3E...%3E0" alt="[公式]"> ）则代表这些pattern对原数据的影响程度。当 <img src="https://www.zhihu.com/equation?tex=%5Csigma_1" alt="[公式]"> 明显大于其他所有 <img src="https://www.zhihu.com/equation?tex=%5Csigma_i" alt="[公式]"> 时，表示原数据仅仅受一种pattern“支配”，体现了较差的多样性；而当所有 <img src="https://www.zhihu.com/equation?tex=%5Csigma_i" alt="[公式]"> 都趋向于一致时，表示原数据由 <img src="https://www.zhihu.com/equation?tex=m" alt="[公式]"> 种pattern共同组成，说明原来的 <img src="https://www.zhihu.com/equation?tex=m" alt="[公式]"> 个caption彼此之间差异较大，体现了丰富的多样性。</li>
</ul>
<p>因此，文章认为，一组caption的多样性可以用 <img src="https://www.zhihu.com/equation?tex=r+%3D+%5Cfrac+%7B%5Csigma_1%7D+%7B%5Csum%5Em_%7Bi%3D1%7D%5Csigma_i%7D" alt="[公式]"> 度量。结合上面的分析， <img src="https://www.zhihu.com/equation?tex=r" alt="[公式]"> 的值域是 <img src="https://www.zhihu.com/equation?tex=%5B1%2Fm%2C+1%5D" alt="[公式]"> ，为了把多样性映射到 <img src="https://www.zhihu.com/equation?tex=%5B0%2C+1%5D" alt="[公式]"> ，文章对 <img src="https://www.zhihu.com/equation?tex=r" alt="[公式]"> 进行了对数变换，得到最终的多样性分数 <img src="https://www.zhihu.com/equation?tex=div+%3D+-%5Clog_m%28r%29" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=div" alt="[公式]"> 越大表示多样性越强。</p>
<h3 id="结合CIDEr的核方法"><a href="#结合CIDEr的核方法" class="headerlink" title="结合CIDEr的核方法"></a>结合CIDEr的核方法</h3><p>根据SVD的定义，得到的singular value等于矩阵 <img src="https://www.zhihu.com/equation?tex=K+%3D+M%5E%5Ctop+M" alt="[公式]"> 的eigenvalue的平方根。可以把 <img src="https://www.zhihu.com/equation?tex=K" alt="[公式]"> 看作一个核矩阵，其中的元素 <img src="https://www.zhihu.com/equation?tex=K_%7Bij%7D" alt="[公式]"> 表示caption <img src="https://www.zhihu.com/equation?tex=i" alt="[公式]"> 和caption <img src="https://www.zhihu.com/equation?tex=j" alt="[公式]"> 的相似度，因此，完全可以应用核方法（Kernelized Method），直接构造出一个 <img src="https://www.zhihu.com/equation?tex=K" alt="[公式]"> ，然后通过 <img src="https://www.zhihu.com/equation?tex=K" alt="[公式]"> 的eigenvalue计算出 <img src="https://www.zhihu.com/equation?tex=div" alt="[公式]"> 。 CIDEr是一个度量两个句子相似度的指标，主要从n-gram和TF-IDF的角度来进行度量，比起上述基于bag-of-words的方法，它显得更加合理。所以文章把CIDEr作为核函数，即 <img src="https://www.zhihu.com/equation?tex=K_%7Bij%7D+%3D+CIDEr%28c_i%2C+c_j%29" alt="[公式]"> ，从而得到另一种多样性分数，称为Self-CIDEr。</p>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>文章对多个Image Captioning模型进行了Accuracy和Diversity的测试，分别用常规的CIDEr和上述的Self-CIDEr度量。实验结果如下，其中的红色五角星代表人类标记员的表现，可以看到，人类的标记结果很好地兼顾了Accuracy和Diversity，与实际的情况相符。</p>
<p><img src="https://pic2.zhimg.com/80/v2-27a4cd22fa5acf55682d4b77d742311e_1440w.jpg" alt="img"></p>
<p>但这还不足以充分证明文章这种度量方法的合理性，于是文章计算了自动化多样性指标与人工标注的多样性分数之间的相关度，结果如下：</p>
<p><img src="https://pic4.zhimg.com/80/v2-8546e7cad02e0de2e3a5448e109049f0_1440w.jpg" alt="img"></p>
<p>其中的mBLEU-mix计算了一组caption内部的平均相似度，被一些研究者用来简单地度量多样性，但从这个实验结果可以看到，mBLEU-mix与人工标注的相关度远不如该文章提出的基于LSA的方法，证明了后者的合理性。同时，应用了核方法的Self-CIDEr又优于朴素的LSA。</p>
]]></content>
      <categories>
        <category>图像描述</category>
        <category>评价指标</category>
      </categories>
      <tags>
        <tag>评价指标</tag>
      </tags>
  </entry>
  <entry>
    <title>End-to-End Learning of Visual Representations from Uncurated Instructional Videos</title>
    <url>/2020/12/30/End-to-End-Learning-of-Visual-Representations-from-Uncurated-Instructional-Videos/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/12/30/yfHDiZusbKvM2AY.png" alt="image-20201230171856275" style="zoom:67%;"></p>
<p><img src="https://i.loli.net/2020/12/30/C1HmZXKLzFlBDGM.png" alt="image-20201230171925959" style="zoom:67%;"></p>
<p><img src="https://i.loli.net/2020/12/30/3AudkSImHtnrwha.png" alt="image-20201230172037294"></p>
]]></content>
      <categories>
        <category>Video Pre-trained Models</category>
      </categories>
      <tags>
        <tag>Video Pre-trained Models</tag>
      </tags>
  </entry>
  <entry>
    <title>DirectQE Direct Pretraining for Machine Translation Quality Estimation</title>
    <url>/2020/12/24/DirectQE-Direct-Pretraining-for-Machine-Translation-Quality-Estimation/</url>
    <content><![CDATA[<p>AAAI2021论文：基于数据生成的机器翻译质量评估方法</p>
<p>来源：<a href="https://mp.weixin.qq.com/s?__biz=Mzg3ODA0NTA2OA==&amp;mid=2247484204&amp;idx=1&amp;sn=1b24bb494110fff68beedde3cb422066&amp;chksm=cf18f1cff86f78d9bdd2d883201af98c4296ec45fe8fae91509421b226ccee923ae7bd158451&amp;mpshare=1&amp;scene=1&amp;srcid=1224CwmzTjgig5X1t5fCbU0T&amp;sharer_sharetime=1608779809453&amp;sharer_shareid=ab44667880fa06ced8bfa560d1d64d36&amp;key=22efb95c8c04cdfbe43c8f83a69b76927ad01c4ab53016600f84450f07570ee6fb6b4747790c342eb1180e349f3fbc3fa8a1ab1219b80a6d725aacd79413c692d47bc3d763cd18ca87eaf3dd823648170186d2f2873bc5c2ef24ff36d3b519a54723506b60b7d4161912fd28659694c1100797e597da6bfe583dad4ef0c80802&amp;ascene=1&amp;uin=MjQwOTk2MzUwOA%3D%3D&amp;devicetype=Windows+10+x64&amp;version=6300002f&amp;lang=zh_CN&amp;exportkey=A8kVBtMx05%2Bw41YTdHRse0I%3D&amp;pass_ticket=5UOCG2UJoSjTMMc7Gh82YYMCZ5iDMMdAZnDIpIDdHbP7%2FsA%2FS9I%2B%2FHaK1%2BTsQBXL&amp;wx_header=0" target="_blank" rel="noopener">南大NLP</a></p>
<h3 id="研究问题"><a href="#研究问题" class="headerlink" title="研究问题"></a>研究问题</h3><p>目前机器翻译在各个领域得到广泛应用，不同的机器翻译系统，对于同样的原文句子可能会给出不同的翻译结果（如表1所示），质量有好有坏。该如何自动评价译文的翻译质量呢？</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>原文</th>
<th>黄河之水天上来，奔流到海不复回</th>
</tr>
</thead>
<tbody>
<tr>
<td>翻译1</td>
<td>The water of the Yellow River comes from the sky, rushes to the sea and never returns</td>
</tr>
<tr>
<td>翻译2</td>
<td>The Yellow River never comes back to the sea</td>
</tr>
<tr>
<td>翻译3</td>
<td>The Yellow River comes from the sky, runs to the sea and never comes back</td>
</tr>
<tr>
<td>翻译4</td>
<td>The water of the Yellow River came from the sky and ran to the sea</td>
</tr>
<tr>
<td>翻译5</td>
<td>The water of the Yellow River comes from the sky, and the waves rush to the East China Sea and never look back</td>
</tr>
</tbody>
</table>
</div>
<p>表格 1：机器翻译的不同结果</p>
<h3 id="研究现状"><a href="#研究现状" class="headerlink" title="研究现状"></a>研究现状</h3><p>目前的评价指标主要有两类。一类需要依赖参考译文，比如BLEU、TER、Meteor等，主要依赖机器翻译译文和参考译文之间的匹配程度，<strong style="color:red;">但参考译文在现实应用场景下往往难以获取。</strong>第二类评价指标不需要依赖参考译文，如质量评估Quality Estimation (QE)，仅通过原文和机器译文对翻译质量进行估计。</p>
<p>QE的粒度有很多种，包括词级别、句子级别、短语级别、文档级别等，<strong style="color:red;">本文主要关注词级别与句子级别QE任务。</strong>词级别QE将译文中的每一个词标记为“Ok”或“Bad“；句子级别QE给每一个句子标注一个[0, 1]之间的打分（0表示很好，1表示很差），这些标记都由人工标记得到，或基于人工编辑结果得到。表2展示了一个英-中语向的QE数据示例。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>原文（英）</th>
<th>this insubordination earned him a now famous reprimand from the King .</th>
</tr>
</thead>
<tbody>
<tr>
<td>机器译文（中）</td>
<td>这种 <strong style="color:blue;">不 服从命令</strong> 的 态度 使 他 <strong style="color:blue;">赢得 了 国王 现在 著名</strong> 的 <strong style="color:blue;">训斥</strong> .</td>
</tr>
<tr>
<td>词级别标记</td>
<td>O B B O O O O B B B B B O B B</td>
</tr>
<tr>
<td>句子级别标记</td>
<td>0.6429</td>
</tr>
</tbody>
</table>
</div>
<p>表格 2：QE数据示例（WMT20英-中）</p>
<p>早期QE任务依赖人工设计的特征，例如原文、译文中的单词数量，词频等，但是该方法的适应性较弱，效果较差。<strong style="color:red;">随后有研究者使用神经网络对QE数据进行端到端建模，取得了一定的成绩。</strong>神经网络需要大规模数据进行训练，但是<strong style="color:red;">QE数据由于需要人工进行标记，暂时规模较小</strong>（万句级别），这限制了神经网络的训练。<strong style="color:red;">目前最流行的QE模型利用知识迁移技术，从无QE标记但具有大规模（百万句级别）的平行语料中迁移QE任务所需要的知识。</strong></p>
<p>Predictor-Estimator是一种流行的基于知识迁移的QE框架，它是一种两阶段模型（如图一所示）。第一阶段，预测器（Predictor）将在平行语料上进行预训练，其预训练任务一般为“词预测”类型的任务。第二阶段，使用预测器提取QE句对的特征，通过评估器（Estimator）学习如何在这些特征上拟合QE标记。</p>
<p><img src="https://i.loli.net/2020/12/30/hLHD7IOQgznTZJd.png" alt="image-20201230101547991" style="zoom:33%;"></p>
<p>我们可以使用神经机器翻译模型NMT（Kim et al. 2017, Fan et al. 2018, Zhou et al. 2019）或者预训练语言模型PLM（Kepler et al. 2019, Kim et al. 2019）来作为预测器，使用LSTM模型作为评估器。</p>
<p><strong style="color:red;">该框架的问题在于，其两阶段之间存在差异，包括数据的差异和训练目标的差异。</strong> 数据的差异是指，<strong style="color:blue;">预测器</strong>在大规模平行语料上训练，平行语料由原文和正确译文组成；<strong style="color:blue;">评估器</strong>在QE数据上训练，句对由原文和包含错误的机器翻译译文组成。训练目标的差异是指，预测器是在做“词预测”任务；评估器是在预测词和句子的质量。那么预测器的预训练过程与目标QE任务存在差异，会导致学习不到QE任务真正需要的知识，无法充分利用大规模双语平行数据。</p>
<h3 id="本文提出的方法"><a href="#本文提出的方法" class="headerlink" title="本文提出的方法"></a>本文提出的方法</h3><p>QE模型的现存问题主要是，1.大规模神经网络训练参数依赖大量数据；2.数据分布及训练目标的差异可能对两阶段训练带来不利影响。</p>
<p>为了解决这两个问题，我们采取的改进方向是：</p>
<ol>
<li><p>使用相同/相似的数据进行预训练；</p>
</li>
<li><p>使用相同/相似的预训练目标。</p>
</li>
</ol>
<p>QE数据中包含一些翻译噪音，QE的训练目标需要质量标签。那么如何基于平行语料，获得带有一定噪音的数据，并且可以获得噪音数据的质量标签？</p>
<p>我们的解决方法是，<strong style="color:green;">首先基于平行数据训练生成器（generator）进行词改写任务；接着对平行语料进行词改写，从而引入一定量的可控噪音并利用可控噪音自动生成质量标签。最终可以将这些生成数据提供给判别器（detector）直接为QE任务进行预训练。</strong> 接下来具体介绍生成器的训练与生成过程。</p>
<p>首先，我们以Masked Language Model (MLM)的方式训练生成器。给定平行句对，随机的隐藏（mask）译文中某个位置的词，然后让模型预测被隐藏的词（如图2所示）。</p>
<p><img src="https://i.loli.net/2020/12/30/UfN9cyzTM8CZb6n.png" alt="image-20201230101626106" style="zoom: 50%;"></p>
<p>生成器训练结束后，我们将使用生成器对平行语料进行转化，具体分为两个步骤。</p>
<ol>
<li>生成伪造机器翻译译文。给定平行语料并隐藏译文中某个位置的词，让生成器进行预测并输出概率分布，根据概率分布采样新的词替换被隐藏词（如图3所示），即完成了对被隐藏词的改写。</li>
</ol>
<p><img src="https://i.loli.net/2020/12/30/HJvEwk2ZhzyC7KB.png" alt="image-20201230101742561" style="zoom:50%;"></p>
<ol>
<li><p>生成对应标签。</p>
<p>根据译文中的词是否被改写来获得词级别标签（见公式1）。</p>
<p>根据译文中被改写词的比例获得句子级别标签q’（见公式2）。</p>
<p>公式1： $o_{j}^{\prime}=\left\{\begin{array}{ll}1, &amp; \text { if } y_{j}=y_{j}^{\prime} \\ 0, &amp; \text { otherwise }\end{array}\right.$</p>
<p>公式2： $q^{\prime}=1-\frac{\operatorname{sum}\left(\mathbf{O}^{\prime}\right)}{\operatorname{len}\left(\mathbf{O}^{\prime}\right)}$</p>
</li>
</ol>
<p>通过生成器，我们能够将大规模平行语料转化为更大规模的伪造QE数据。比起平行译文，伪造的机器翻译译文在数据分布上与QE中的译文更加接近。同时，伪造QE数据针对每一个词有表示“是否由机器生成“的标签，对整个句子有表示”句子改写程度“的标签，形式上与QE数据类似。<strong style="color:green;">基于大规模伪造QE数据以及真实QE数据，我们将使用同样的训练目标，对判别器（Detector）分别在伪造数据上进行预训练、在真实数据上微调参数。最终也只需要使用判别器来做QE分数预测。</strong></p>
<blockquote>
<p>即，生成的数据，仅仅是在estimator 上提供预训练数据</p>
<p>即本文，并没有对 predictor做改动，是对estimator 的训练策略上做了改动</p>
</blockquote>
<p>我们对比了Predictor-Estimator框架中的两种具体实现。一种是基于NMT的QE模型，具体实现仿照QE Brain模型(Fan et al. 2018)；一种是基于PLM的QE模型，具体使用的PLM模型来自于huggingface。在本文的实现中，我们所提出的<strong>DirectQE</strong>参数量是最小的。</p>
<p>实验结果如表3，4，5所示，可以发现我们的模型在绝大多数情况下都是具有优势的。</p>
<p>表格 3：单模型结果（英-德）</p>
<p><img src="https://i.loli.net/2020/12/30/4OZDeJgo7CmGX5l.png" alt="image-20201230102042709"></p>
<p>表格 4：集成模型结果（英-德）</p>
<p><img src="https://i.loli.net/2020/12/24/UkC5rKy9ZoWh8Ab.png" alt="image-20201224114950396" style="zoom:33%;"></p>
<p>表格 5：单模型结果（英-中、英-俄）</p>
<p><img src="https://i.loli.net/2020/12/24/87bizODk5VYjdxQ.png" alt="image-20201224115010524" style="zoom: 25%;"></p>
<p>为了找出我们模型性能具体的增长点，我们按照错误词的比例划分了真实QE数据集，并评估了模型在数据每个部分的性能。如图4所示，在翻译质量存在问题时（错误词比例&gt;12.5%），DirectQE的性能更好。</p>
<p>图表 4：模型在不同错误比例数据上的性能对比</p>
<p><img src="https://i.loli.net/2020/12/30/SOFaCUxnjHIuV4X.png" alt="image-20201230101815866"></p>
<p>为了研究预训练使用的数据分布对QE性能的影响，我们使用基于NMT的QE模型，并且将其中训练预测器用到的平行语料替换为生成器制造的伪造机器翻译译文，其余部分均保持不变。从表6中可以看出，使用伪造译文的模型性能有所上升，说明对于QE任务而言，使用伪造译文预训练比平行译文更好。</p>
<p>表格 6：使用伪造译文/平行译文训练基于NMT的QE系统</p>
<p><img src="https://i.loli.net/2020/12/24/r2zCSgNepfovnET.png" alt="image-20201224115311979" style="zoom: 33%;"></p>
<p>为了研究预训练数据质量对QE性能的影响，我们测试了不同质量的数据下QE性能，这里数据质量具体指是译文质量，可以体现在替换词比例上（在相同替换策略下，替换词比例越大，译文质量越差）。从图5中可以看出，伪造译文质量太好或者太坏都不利于最终QE的性能。伪造译文质量太好（替换比例很低），句子将接近于平行语料本身，数据中几乎没有噪音；而伪造译文质量太差时，会破坏句子结构，与真实QE译文数据分布有较大差异。图5中红点表示使用随机噪音替换被隐藏词，此时的译文质量很差，可以看到QE性能也很低。</p>
<p>图表 5：不同伪造译文质量下的QE模型性能</p>
<p><img src="https://i.loli.net/2020/12/30/kSiwhoP47EzGx9Y.png" alt="image-20201230101837656" style="zoom: 33%;"></p>
<p>在固定规模的平行语料上，生成器每一次采样会产生不同的伪造QE数据，最终用于训练判别器的数据规模是超百万级别的，且更多样化。为了研究多样性的价值，我们使用生成器产生了固定数量的伪造QE数据，对比了在固定生成的数据上以及持续生成的数据上预训练的模型性能。结果（图6）显示，<strong style="color:red;">伪造QE数据的多样性对提升模型性能来说很重要。</strong></p>
<p>图6：</p>
<p><img src="https://i.loli.net/2020/12/30/nh5G1rxMRPpDgmO.png" alt="image-20201230101857603" style="zoom:50%;"></p>
<p>词级别QE任务需要判别当前词的质量，那么模型在建模当前词时，包含更多当前词的信息是有必要的。为了体现模型隐层表示含有当前词信息的多与少，我们计算了隐层表示与当前词之间的互信息（模型指判别器/预测器）。在图7中可以看到，DirectQE学到的表示中包含有更多当前词的信息。</p>
<p>图表 7：模型隐层表示 v.s. 当前词信息</p>
<p><img src="https://i.loli.net/2020/12/30/b43AOK7aHm1QklR.png" alt="image-20201230101937525" style="zoom:33%;"></p>
<p>假设当模型针对下游任务进行微调时，模型的隐层表示改变越小，则原始的表示更适合该下游任务。为了研究是否DirectQE可以学习到更加适合QE任务的表示，我们测试了在真实QE数据上微调前后，DirectQE和基于NMT的QE模型的隐层表示之间的相似度。表7显示，DirectQE隐层表示的相似度较高，说明DirectQE可以学到更加适合QE任务的表示。</p>
<p>表格 7：微调前后隐层表示变化</p>
<p><img src="https://i.loli.net/2020/12/30/F5c2lrWGv8wuMnP.png" alt="image-20201230101958503" style="zoom:33%;"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>大规模的QE模型需要大规模数据进行参数训练。现有的两阶段方法，由于数据和训练目标差异，无法最大化利用大规模平行语料知识。我们提出一种直接为QE模型进行预训练的框架（DirectQE）——使用生成器由平行语料得到伪QE数据，而后使用判别器，在伪QE数据上进行预训练，并且使用真实QE数据微调。我们模型的优势是，参数规模更小，模型性能更好，并且易于使用。</p>
<p>未来，我们将考虑使用更多样化的方式来构造伪QE数据，进一步缓解数据差异带来的影响，最大程度利用大规模语料，提升QE模型性能。</p>
<h3 id="可查看的参考文献"><a href="#可查看的参考文献" class="headerlink" title="可查看的参考文献"></a>可查看的参考文献</h3><ul>
<li><p>Predictor-Estimator: Neural Quality Estimation Based on Target Word Prediction for Machine Translation</p>
<p><a href="https://unbabel.github.io/OpenKiwi/cli/train_predictor_estimator.html" target="_blank" rel="noopener">https://unbabel.github.io/OpenKiwi/cli/train_predictor_estimator.html</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Egoshots, an ego-vision life-logging dataset and semantic fidelity metric to evaluate diversity in image captioning models</title>
    <url>/2020/04/01/Egoshots-an-ego-vision-life-logging-dataset-and-semantic-fidelity-metric-to-evaluate-diversity-in-image-captioning-models/</url>
    <content><![CDATA[<h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><ul>
<li><p>当前的image caption dataset 存在的问题</p>
<p>图像字幕模型已经能够生成语法正确且易于理解的句子。但是，大多数字幕传达的信息有限，因为所使用的模型是在数据集上训练的，而该数据集并未为日常生活中存在的所有可能的对象提供字幕。由于缺少先验信息，因此大多数字幕仅偏向场景中出现的少数几个对象，因此限制了它们在日常生活中的使用。在本文中，我们试图证明当前现有图像字幕模型的偏向性，并提出一个新的图像字幕数据集<em>Egoshots</em>，由978张不带字幕的现实生活图像组成。我们进一步利用最先进的预训练图像字幕和对象识别网络来注释我们的图像并显示现有作品的局限性。</p>
</li>
<li><p>当前的standard metric存在的问题</p>
<p>此外，为了评估所生成字幕的质量，我们提出了一种新的图像字幕度量标准，即基于对象的<em>语义保真度</em>（SF）。现有的图像字幕度量标准只能在存在其相应注释（reference captions）的情况下评估字幕。但是，SF允许评估为图像生成的字幕而没有注释，这对于现实生活中生成的字幕非常有用。</p>
</li>
</ul>
<h4 id="SF"><a href="#SF" class="headerlink" title="SF"></a>SF</h4><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gdel85qhz8j30se0g97eb.jpg" alt="搜狗截图20200401212845.png"></p>
<h4 id="Annotation-Pipline-and-Sementic-Fidelity-Metric"><a href="#Annotation-Pipline-and-Sementic-Fidelity-Metric" class="headerlink" title="Annotation Pipline and Sementic Fidelity Metric"></a>Annotation Pipline and Sementic Fidelity Metric</h4><ul>
<li><p>annotation pipline</p>
<p>使用三个预训练好的caption model: Show Attend And Tell (SAT), nocaps: novel object captioning at scale (NOC), and Decoupled Novel Object Captioner (DNOC) 在新的数据集Egoshots上进行captioning 任务。</p>
</li>
<li><p>sementic fidelity metric</p>
<p>我们提出了一种称为<em>语义保真</em>度的新图像字幕指标。SF考虑了两个元素：1）生成的字幕与图像中检测到的对象的语义接近度； 2）相对于检测到的对象实例数量的对象多样性。假设有一个最新的准完美对象检测器，通过考虑这两组（带字幕和检测到的）实体（即对象）之间的语义亲密性，当一个模型输出的caption中包含了并没有出现在image scene中的objects时，将进行惩罚。</p>
<p>公式：<img src="http://ww1.sinaimg.cn/large/006uWRWVly1gdelh0afpej3055021a9x.jpg" alt="搜狗截图20200401213725.png"></p>
<p>对于图像i，si是其预测字幕c i中的名词词与OD检测到的对象名词之间的语义相似性，＃O是O O D的基数，＃N是名词的数量（表示对象in N i）存在于caption i中。SF的范围为[0，1]：SF接近1的字幕传达更多信息，并且在语义上更接近于要字幕的场景（就字幕所涉及的对象而言）。</p>
<p>关于si的计算：Recent works (Mikolov et al., 2013; Conneau et al., 2017) show the ability of word embeddings that is transforming a word into its vectored form efficiently capture the semantic closeness of two given words. The SF metric uses this approach to calculate such semantic similarity between the noun words and objects in an image.</p>
<p>上述公式存在一个假设：that #O ≥ #N (Assumption 1) for all images. This approach to compute SF will work only assuming robust object detectors satisfying enough scene annotation granularity.  </p>
<p>同时为保证分母不为0，还需要一个假设：Assumption 2: #O ！= 0 (i.e., the object detector can at least detect one object in the image). </p>
<h4 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h4></li>
<li><p>在上述新提出的metric中，如果使用SF执行字幕评估，则良好通用化且鲁棒的对象检测模型将扮演最重要的角色。（a well generalized and robust object detection model plays the most important role if<br>the evaluation of captions is performed using SF. ）</p>
</li>
<li>在物体检测器发生故障的情况下，度量是不可靠的。由于SF将无法惩罚字幕模型，因为它不能依赖忠实（即足够鲁棒）的对象检测器（＃O = 0，假设2损坏），因此无法应用SF。</li>
</ul>
<h4 id="Appendix-指标限制"><a href="#Appendix-指标限制" class="headerlink" title="Appendix: 指标限制"></a>Appendix: 指标限制</h4><ul>
<li><p>我们必须注意到度量标准的一些局限性，应加以补充/扩展为（1）解释字幕的动词和其他句法元素（当前只考虑了名词）；（2）根据解释的质量对字幕进行评分，并考虑图像中相同类型的对象相对于字幕中存在的对象的数量。诸如（Cohen17）之类的特定计数模型是有关如何增强此处提出的无标签数据集注释管道的特定示例。</p>
<p>应该在更有针对性的应用程序使用案例中评估指标，例如，在诸如导航，对目标用户（如盲人）的有用性。</p>
</li>
</ul>
<h4 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h4><ul>
<li>其实本文尝试使用一个open-domain dataset 来测试在 in-domain 上训练的captioning model的泛化性能。但是这本身就存在问题！因为，model本身就会受限于训练数据，因此这里却希望它有很强的泛化性能，这本身就太难为model了。<code>eg: 不能要求一个学了小学课程的人来做高中生的题目</code></li>
</ul>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul>
<li><p>Tomas Mikolov, Ilya Sutskever, Kai Chen, Gregory S. Corrado, and Jeffrey Dean. </p>
<p>Distributed Representations of Words and Phrases and their  Compositionality. In NIPS, 2013. </p>
</li>
<li><p>Alexis Conneau, Guillaume Lample, Marc’Aurelio Ranzato, Ludovic Denoyer, and Herve J ´ egou. ´<br>Word Translation Without Parallel Data. ArXiv, abs/1710.04087, 2017 </p>
</li>
<li><p>Joseph Paul Cohen, Genevieve Boucher, Craig A. Glastonbury, Henry Z. Lo, and Yoshua Bengio.<br>Count-ception: Counting by Fully Convolutional Redundant Counting. In The IEEE International<br>Conference on Computer Vision (ICCV) Workshops, Oct 2017. </p>
</li>
</ul>
]]></content>
      <categories>
        <category>图像描述</category>
        <category>评价指标</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>Evaluating Models&#39; Local Decision Boundaries via Contrast Sets</title>
    <url>/2021/02/19/Evaluating-Models-Local-Decision-Boundaries-via-Contrast-Sets/</url>
    <content><![CDATA[<p><strong>论文标题：</strong>Evaluating Models’ Local Decision Boundaries via Contrast Sets</p>
<p><strong>论文链接：</strong><a href="https://arxiv.org/abs/2004.02709" target="_blank" rel="noopener">https://arxiv.org/abs/2004.02709</a></p>
<p><strong>数据集：</strong><a href="https://allennlp.org/contrast-sets" target="_blank" rel="noopener">https://allennlp.org/contrast-sets</a></p>
<p><strong>Main Contribution：</strong>训练集与测试集 i.i.d 的假设使得模型很难泛化，文章提出了在原始测试集构建 contrast test set 的方法，可以真实的评估模型的语言能力。</p>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a><strong>Motivation</strong></h2><p>这里用了一个 toy example 和一个真实示例来表示作者想要提出并解决的问题。</p>
<p><strong>Toy Example</strong></p>
<p>考虑二维的情况，下图中的两分类问题需要一个非常复杂的 decision boundary。</p>
<p><img src="https://i.loli.net/2021/02/19/sfK5PyknNElIVoJ.png" alt="image-20210219175052164" style="zoom:33%;"></p>
<p>但是在很多情况下，由于采样的 biased，我们很可能得到如下的数据集：</p>
<p><img src="https://i.loli.net/2021/02/19/PBUDYm6LK7S3IN5.png" alt="image-20210219175104378" style="zoom:33%;"></p>
<p>网络通过一个很简单的 decision boundary 就可以将它们分类，而由于训练测试数据集独立同分布，虽然这个 decision boundary 非常差，但它在测试集表现得非常好。理想情况下，如果我们完整采样整个数据集，所有问题都迎刃而解，但这显然是很难做到的。为了正确的测试模型的能力，作者提出了对测试集做 perturbation 的方法：对测试集的每一个实例，我们生成一系列与之类似的测试样本（Contrast Set：下图中的灰色圆圈）。</p>
<p><img src="https://i.loli.net/2021/02/19/CdF9GOxAJe2aEv3.png" alt="image-20210219175121207" style="zoom:33%;"></p>
<p><strong>Complex NLP Task</strong></p>
<p>我们很难用图把 NLP task 中存在的问题进行描述，但是有很多工作支撑了这一观点。比较有意思的示例为在 SNLI 数据集中，表明单词”睡觉”，”电视”和”猫”几乎从来没有同时出现数据中，但是它们经常出现在 contradiction 的例子中。所以 model 很容易的学到“同时出现’睡觉’和’猫’的句子都是 contradiction sentence，并且这一分类标准工作得很好”。 </p>
<p>在初始数据收集过程中完全消除这些差距将是非常理想化的，在一个非常高维的空间中，语言有太多的可变性。相反，该文使用 Contrast Set 来填补测试数据中的空白，从而给出比原始数据提供的更全面的评估。</p>
<h2 id="Contrast-sets"><a href="#Contrast-sets" class="headerlink" title="Contrast sets"></a><strong>Contrast sets</strong></h2><p>假设我们现在为测试样本 构建 Contrast Set，有两个要点 (i) 构建样本距离与  小于某个阈值。(ii) Label 与 <strong>不一致</strong>。下图是在 NLVR2 数据集上的一些实例，在这里，句子和图像都通过一些很简单的方式进行修改（例如，通过改变句子中的一个词或找到一个相似但有区别的词），从而使输出标签发生变化。</p>
<p><img src="https://i.loli.net/2021/02/19/tlN7BZIVnDCsYed.png" alt="image-20210219175240236" style="zoom:50%;"></p>
<p>我们需要注意，contrast set 和 adversarial examples 是不一样的，对抗样本的目的是对句子/图像做 perturbation，但是保持原标签不变。 </p>
<p>不过文章中如何计算样本距离，阈值的确定，label 是否发生变化，都是由 expert 给出的。</p>
<h2 id="How-to-Create-Contrast-Sets"><a href="#How-to-Create-Contrast-Sets" class="headerlink" title="How to Create Contrast Sets"></a><strong>How to Create Contrast Sets</strong></h2><p>作者用了三个数据集来展示 Contrast Sets 的构造过程。</p>
<p><strong>DROP</strong></p>
<p>DROP 是一个阅读理解数据集，旨在涵盖对段落中的数字进行组合推理，包括过滤、排序和计数，以及进行数值运算。数据主要来自 (i) Wikipedia (ii) 美国足球联赛的描述。(iii) 人口普查结果说明。(iv) 战争摘要。作者发现数据集中存在明显的 bias，比如一旦问题是”How many…”，结果很多情况都是 2。关于事件顺序的问题通常遵循段落的线性顺序，而且大部分问题不需要理解。 </p>
<p>作者从三个方面改进这个数据集：</p>
<ul>
<li>关于足球联赛的问题往往需要推理和比较（比如询问两场比赛得分的差值），但是其他类型的数据很少需要推理比较，因此作者为他们提供额外的需要推理比较的问题；</li>
<li>将问题的部分语义颠倒，类似于 shortest 变为 longest, later 变为 earlier, How many countries 变为 which countries 等等；</li>
<li>改变事件发生的顺序，使得与事件顺序相关的问题推理难度增加。</li>
</ul>
<p><strong>NLVR2</strong></p>
<p>给模型一对图像与一个句子，判断这句话正确与否。这个数据集的特点在于 compositional reasoning，我们需要模型理解图像中的物体的属性，物体与物体的关系，物体与场景的关系。 </p>
<p>我们通过修改句子或用网络搜索中获得自由许可的图片替换其中一张图片来构建 NLVR2 的 Contrast Set。 </p>
<p>比如将句子”The leftimage contains twice the number of dogs as theright image”改为“The left image containsthree timesthe number of dogs as the right image”。或者对一个图像对，将原本 4 条狗的图像换成其他数目。也可以对一些量词比如”at least one”改为”exactly one”，或者实体”dogs”改为”cats”，或者属性”yellow”改为“red”。</p>
<p><strong>UD  Parsing</strong> </p>
<p>这是一个 dependency parsing 的数据集。作者想要通过这个数据集证明 Contrast set 不仅在 high-level 的 NLP 任务中有效，也在语义分析的任务中有效。具体方法可以查看原文。</p>
<p><img src="https://i.loli.net/2021/02/19/CzWXEFJs63dDHAq.png" alt="image-20210219175335245"></p>
<p>可以看到，再加上 Contrast Set 之后，SOTA models 的性能都有了显著的下降。</p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP,evaluation</tag>
      </tags>
  </entry>
  <entry>
    <title>From Recognition to Cognition: Visual Commonsense Reasoning</title>
    <url>/2020/05/16/From-Recognition-to-Cognition-Visual-Commonsense-Reasoning/</url>
    <content><![CDATA[<h4 id="Visual-Commonsense-Reasoning-VCR"><a href="#Visual-Commonsense-Reasoning-VCR" class="headerlink" title="Visual Commonsense Reasoning (VCR)"></a>Visual Commonsense Reasoning (VCR)</h4><p>VCR: Given an image, a list of regions, and a question, a model must answer the question and provide a rationale explaining why its answer is right. </p>
<p>标注数据：为了避免生成式问题中评价指标的缺陷，本任务设计成 <strong>选择题</strong> 任务，即，提供一个image，一个question，多个answer，该任务要求从多个答案中选择一个正确的答案。对于correct answer：给定一张图片，要求AMT workers 写一个question，一个answer。对于wrong answer：使用adversarial matching 来获得其余的negative answer。</p>
<h4 id="The-Motivation-of-Adversarial-Matching"><a href="#The-Motivation-of-Adversarial-Matching" class="headerlink" title="The Motivation of Adversarial Matching"></a>The Motivation of Adversarial Matching</h4><p>在构建数据集时，常常存在两种挑战：</p>
<ul>
<li><p><strong>A crucial challenge</strong> in constructing a dataset of this complexity at this scale is how to avoid <strong>annotation artifacts</strong>. </p>
</li>
<li><p><strong>A recurring challenge</strong> in most recent QA datasets has been that human-written answers contain unexpected but distinct <strong>biases</strong> that models can easily exploit. 现实世界中的偏置</p>
</li>
</ul>
<p>通常，这些<strong>偏见</strong>非常明显，以至于模型无需看问题就可以选择正确的答案。</p>
<h4 id="Adversarial-Matching"><a href="#Adversarial-Matching" class="headerlink" title="Adversarial Matching"></a>Adversarial Matching</h4><p>negative answer的生成可以在correct answer上进行改造，但是这个过程非常耗钱，更甚，可能会引入annotation artifacts，subtle patterns that are by themselves highly predictive of the ‘correct’ or ‘incorrect’ label. 【1，2，3】</p>
<p>The key idea of Adversarial Matching is to <strong>recycle</strong> each correct answer for a question exactly three times — as a <strong>negative answer</strong> for three other questions.  这样每个answer 将会有1/4的机会是正例。这可以<strong>解决掉 answer-only bais 的问题</strong>，从而避免了模型总是选择 most generic answer. </p>
<p>在为每个image 选择negative answer时，希望<strong>negative answer: relevant as possible to the context/question (so that they appeal to machines), while they cannot be overly similar to the correct response (so that they don’t become correct answers incidentally).</strong> </p>
<p>因此计算一个weight，能够同时考虑到与query中的questeion相关度大，但是与query 的correct answer的相似性小。在本文中使用bert来计算相关度，用ESIM+ELM来计算相似性。</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1geuprb6zmvj310305qwfg.jpg"></p>
<p>为了获得多个negative answer，需要执行多次的双向匹配。为了确保nagetive pairs是多样性的，在依次获得negative answer的过程中，在下一次从其他的image中查找negative answer时，需要遍历当前所有的negative answer，然后取最大值。（replace the similarity term with the maximum similarity between a candidate response rj and all responses currently assigned to qi.）</p>
<h4 id="Language-Priors-and-Annotation-Artifacts-Discussion"><a href="#Language-Priors-and-Annotation-Artifacts-Discussion" class="headerlink" title="Language Priors and Annotation Artifacts Discussion"></a>Language Priors and Annotation Artifacts Discussion</h4><p><strong>Answer Priors</strong>: A model can select a correct answer without even looking at the question. </p>
<p><strong>Non-Visual Priors ：</strong>A model can select a correct answer using only non-visual elements of the question. </p>
<p>这些priors可能是来自于现实世界中的偏置，比如，当问消火栓是什么颜色的，模型常常预测出，红色。这是由于现实世界中消火栓是红色的。 </p>
<p>又可能来自于annotation artifacts ， 人们在编写class-conditioned answers 时出现的模式。比如：标注者经常使用否定之类的方式写与句子相矛盾的句子。</p>
<ul>
<li><strong>实验证明，对抗匹配的方式，可以帮助消除 artificial bias。</strong> </li>
</ul>
<h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><ol>
<li>The effect of different writing tasks on linguistic style: A case study of the ROC story cloze task.  </li>
<li>Annotation artifacts in natural language inference data. </li>
<li>Hypothesis Only Baselines in Natural Language Inference. </li>
</ol>
]]></content>
      <categories>
        <category>cross-modal</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
      </tags>
  </entry>
  <entry>
    <title>FPN</title>
    <url>/2019/08/01/FPN/</url>
    <content><![CDATA[<ul>
<li><a href="https://vision.cornell.edu/se3/wp-content/uploads/2017/07/fpn-poster.pdf" target="_blank" rel="noopener">poster</a></li>
<li><a href="https://blog.csdn.net/WZZ18191171661/article/details/79494534" target="_blank" rel="noopener">某篇博客</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Full Instructions</title>
    <url>/2020/07/01/Full-Instructions/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>Finding It: Weakly-Supervised Reference-Aware Visual Grounding in Instructional Videos</title>
    <url>/2019/12/02/Finding-It-Weakly-Supervised-Reference-Aware-Visual-Grounding-in-Instructional-Videos/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>GAN简介</title>
    <url>/2020/07/30/GAN%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<blockquote>
<p>From: <a href="https://blog.csdn.net/shanlepu6038/article/details/84335117?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">GAN（一）:基本框架</a></p>
</blockquote>
<p>一个GAN包含两部分，一个generator,一个discriminator（互相对抗）<br>generator和discriminator就像是猎食者和猎物之间的关系，一个产生图片，一个辨别图片的真假，互相促进，使得最终产生的图片接近realistic</p>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><ol>
<li><p>随机初始化 generator 和 discriminator</p>
</li>
<li><p>In each training iteration：</p>
<ul>
<li><p>固定generator，更新discriminator</p>
<p>Discriminator learns to assign high scores to real objects and low scores to generated objects.</p>
</li>
<li><p>固定discriminator， 更新generator</p>
</li>
</ul>
</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gh9bgltng3j30hu0djage.jpg"></p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p><strong>G和D是互相促进的：</strong>G的目的是产生的图像让D感到模糊不知道该分成realistic（看起来像是现实的）还是fake（看起来是假的），D的目的是将realistic和fake的图像准确分辨。所以G产生的图像会越来越真，D的辨别能力会越来越强，最终达到一个平衡。</p>
<p>P<sub>data</sub> 表示真实数据的分布，P<sub>g</sub> 表示generator产生的分布，最终的目的就是让P<sub>g</sub> 的分布尽可能的和P<sub>data</sub> 相同。<br>我们用D(x)表示真实图像经过discriminator后的分数，G(z)表示随机变量z经过generator后产生的图像，那么有：D(G(z)) 表示generator产生的图像经过discriminator后的分数</p>
<p>第一阶段，固定 generator，更新discriminator，最大化下面对的这个式子：</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gh9bxggo1rj30gv01lwf1.jpg"></p>
<p>第二阶段，固定discriminator，更新generator，最大化下面的这个式子：</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gh9bxgfqjnj30ad01s3yt.jpg"></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub+Hexo 搭建个人网站详细教程</title>
    <url>/2019/02/21/GitHub-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26625249</a></p>
<p><a href="https://blog.csdn.net/xuezhisdc/article/details/53130328" target="_blank" rel="noopener">https://blog.csdn.net/xuezhisdc/article/details/53130328</a></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>node.js 使用 12 版本</p>
<h3 id="部署在本地"><a href="#部署在本地" class="headerlink" title="部署在本地"></a>部署在本地</h3><ul>
<li><p>部署</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo clean</span></span><br><span class="line"><span class="attribute">hexo g -s</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用端口 5000</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">hexo s -<span class="selector-tag">p</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="增加本地搜索功能"><a href="#增加本地搜索功能" class="headerlink" title="增加本地搜索功能"></a>增加本地搜索功能</h3><h4 id="自定义站点内容搜索"><a href="#自定义站点内容搜索" class="headerlink" title="自定义站点内容搜索"></a>自定义站点内容搜索</h4><ol>
<li><p>安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-generator-searchdb <span class="comment">--save</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑博客配置文件，新增以下内容到任意位置：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">search:</span></span><br><span class="line"><span class="symbol">      path:</span> search.xml</span><br><span class="line"><span class="symbol">      field:</span> post</span><br><span class="line"><span class="symbol">      format:</span> html</span><br><span class="line"><span class="symbol">      limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑主题配置文件，启用本地搜索功能：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p><a href="https://www.jianshu.com/p/44e211829447" target="_blank" rel="noopener">https://www.jianshu.com/p/44e211829447</a></p>
<p><a href="http://npm.taobao.org/package/hexo-blog-encrypt" target="_blank" rel="noopener">http://npm.taobao.org/package/hexo-blog-encrypt</a></p>
<p><a href="https://github.com/MikeCoder/hexo-blog-encrypt/" target="_blank" rel="noopener">https://github.com/MikeCoder/hexo-blog-encrypt/</a></p>
]]></content>
      <categories>
        <category>杂类</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Going Beneath the Surface: Evaluating Image Captioning for Grammaticality, Truthfulness and Diversity</title>
    <url>/2020/07/02/Going-Beneath-the-Surface-Evaluating-Image-Captioning-for-Grammaticality-Truthfulness-and-Diversity/</url>
    <content><![CDATA[<h3 id="yaya-总结"><a href="#yaya-总结" class="headerlink" title="yaya 总结"></a>yaya 总结</h3><ul>
<li>本文提出了一个 GTD ， Grammaticality, Truthfulness and Diversity 三个方面对captioning model 进行评价，为未来 captioning model metric 提供了一个探索的方向。</li>
<li>本文需要特别说明的是，（1）本文是在自己设计的一个diagnostic dataset 上进行的实验，并不是在真实的captioning dataset 上进行的实验。（2）本文并没有提出一个具体可用的评价指标，而是提出了一个类似于协议的东西，即，本文主要是探究，在未来的评价指标里，需要去评估captioning model 的哪些层面，来弥补当前评价指标的不足，与当前的评价指标做一个互为补充！（英文： GTD, consider it as an evaluation protocol covering necessary aspects of the multifaceted captioning task, rather than a specific metric.）</li>
<li>该文选用 diagnostic dataset的原因：  <ul>
<li>The primary motivation is to reduce complexity which is considered irrelevant to the evaluation focus, to enable better control over the data, and to provide more detailed insights into strengths and limitations of existing models.</li>
</ul>
</li>
<li>该文不提出一个具体的评价指标：<ul>
<li>这得抨击一下啊。。。这给未来的研究提供了一个方向。但是，，，，feel is bad</li>
</ul>
</li>
</ul>
<h3 id="yaya学到了"><a href="#yaya学到了" class="headerlink" title="yaya学到了"></a>yaya学到了</h3><h2 id="使用ERG进行语法分析，若能够获得语法分析，则该句子在语法上被认为是格式正确的。反之。。"><a href="#使用ERG进行语法分析，若能够获得语法分析，则该句子在语法上被认为是格式正确的。反之。。" class="headerlink" title="- 使用ERG进行语法分析，若能够获得语法分析，则该句子在语法上被认为是格式正确的。反之。。"></a>- 使用ERG进行语法分析，若能够获得语法分析，则该句子在语法上被认为是格式正确的。反之。。</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><ul>
<li><strong style="color:red;">【当前评价指标存在的问题】</strong>: 当前存在的评价指标，只去关注于a candidate caption and<br>a set of reference captions之间的相似性，但是不去检查 generated caption 与 当前视觉内容之间的相关性。</li>
<li>本文提出了一个为 image captioning task 设计的 evaluation framework. 目的是直接评估生成caption的语法性、真实性和多样性(GTD).</li>
<li>使用本文新提出的evaluation framework 为 image caption models 进行评估, 并在多个数据集上进行测试，来证明本文提出的评估框架的潜力。</li>
<li>本文用实验来证明，与 <strong>diagnostic dataset</strong> 结合使用，本文的GTD 评估框架可以提供对 caption model 的 能力以及限制(capabilities and limit)的进一步思考。并补充 standard evaluations 的不足。</li>
<li></li>
</ul>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><ul>
<li>BLEU，METEOR，ROUGLE，CIDEr基于 n_gram 的评价指标仅能够评价cadidate caption 与 reference caption之间的<strong>表面相似性</strong>，</li>
<li>SPICE，将 captions转化为 graph-based 语义表达，进而来评估候选与参考之间的<strong>语义相似性</strong>。</li>
</ul>
<p><strong style="color:red;">automatic metric 使用的依据 (reference captions 来作为参照的使用依据)</strong></p>
<ul>
<li>【1】The rationale behind these evaluation metrics is that human reference captions serve as an approximate target and comparing model outputs to this target is a proxy for how well<br>a system performs. Thus, a candidate caption is not directly evaluated with respect to image content, but compared to a set of human statements about that image.</li>
<li>这里存在一个假设条件，即假设认为 human reference captions 是一个近似的target. 将caption model 输出与该target 进行比较是评估该model 性能好坏的一个proxy。基于这种假设，一个candidate caption 可以不直接与image content进行比较评估，而是与人类对image的statements 进行比较。</li>
</ul>
<p><strong style="color:red;">reference captions based automatic metric 存在的缺陷</strong></p>
<ul>
<li>reference-based metrics</li>
<li>由于视觉场景存在多个objects 和 relations，进而存在多个具有多样性的合理描述。但是由于reference caption 数量的限制，未必能够对图片的完整内容进行充分的描述。因此用reference captions 来近似替代 image 的内容是令人怀疑的。</li>
<li>当前存在的评价指标对于真实世界的 captioning评估是非常有用的，这是不可置疑的。这些方法仅关注于近似的表面比较，限制了对captioning models 学习过程和最终行为的进一步分析 。</li>
</ul>
<p><strong style="color:red;">本文提出的解决办法</strong></p>
<ul>
<li>为了解决这个问题，本文提出了几个原则性的评估准则，来对image captioning model 的语法性，真实性，多样性进行评估。这几个准则对应着image captioning systems的必要需求：（1）输出是符合语法规则的（2）对于image, 输出的陈述是对的（3）输出是多样化的, 反映training captions 的可变性。</li>
<li>GTD 当前只能在人造的数据上进行实际的评估。本文设计了一系列的数据集来进行图像描述的评估。我们将这个诊断评估数据集称为ShapeWorldCE. </li>
<li>BLEU 和 SPICE 不能捕捉 true caption-image agreement in all scenarios, 但是 GTD 对于现有模型如何很好地应对各种视觉环境和语言构造，却能有一个细粒度的观测。</li>
</ul>
<h3 id="GTD-evaluation-framework"><a href="#GTD-evaluation-framework" class="headerlink" title="GTD evaluation framework"></a>GTD evaluation framework</h3><ul>
<li>将GVD视为涵盖多方面字幕任务的必要方面的评估协议, 而不是一个具体的评估指标。</li>
<li><p><strong style="color:red;">【Grammaticality】</strong></p>
<ul>
<li>在一般情况下，对语法的完全准确的评估本身是一项艰巨的任务，但在诸如我们的诊断语言数据这样的非常有限的情况下，变得更加可行。【即在真实场景下的数据集是无法实现的？！！！】</li>
<li>如果我们使用ERG获得语法分析，则该句子在语法上被认为是格式正确的。</li>
</ul>
</li>
<li><p><strong style="color:red;">【Truthfulness】</strong></p>
<ul>
<li>candidate caption 与 image content 之间是否相容。</li>
</ul>
</li>
<li><p>truthfulness, that is, whether a candidate caption is compatible with the content of the image it is supposed to describe.  </p>
</li>
<li><p><strong style="color:red;">【Diversity】  </strong></p>
<h3 id="一些实验结果的分析"><a href="#一些实验结果的分析" class="headerlink" title="一些实验结果的分析"></a>一些实验结果的分析</h3></li>
<li>越高的BLEU得分，并不意味着准确性的提高。 换句话说，与reference captions的重叠度高（high n_gram overlap），并不代表语义内容是正确的. 仅仅是由于reference caption的词表有限所致。<strong>具体的分析可以查看论文实验部分：Correlation between the BLEU/SPICE scores and the<br>ground truth.</strong></li>
<li>虽然CNN可以为视觉任务提供丰富的视觉表达，但是对于多模态任务，其是否可以满足<br>但是这种浓缩的视觉表达对于需要higher-level 场景理解，视觉推理的多模态任务是否足够充分，仍然是一个开放性问题。</li>
<li>生成句子的多样性受到训练数据是否多样性的影响</li>
<li>未来的工作：本文发现：the caption agreement 并不总是随着训练损失的下降而提高。<br>理想情况下，训练目标应该与模型最终被评估的方式保持一致。在未来，计划实现一个GTD-aware loss,进而研究如何把GTD信号融合到训练过程中。</li>
</ul>
]]></content>
      <categories>
        <category>图像描述</category>
        <category>评价指标</category>
      </categories>
  </entry>
  <entry>
    <title>Graph Matching Networks for Learning the Similarity of Graph Structured Objects</title>
    <url>/2019/12/20/Graph-Matching-Networks-for-Learning-the-Similarity-of-Graph-Structured-Objects/</url>
    <content><![CDATA[<ul>
<li>ICML 2019</li>
</ul>
<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><ul>
<li>本文主要是提出了一种 新的方法来计算图的相似度问题</li>
<li>普通的方法分别单独计算 graph vector，而后再计算graph 之间的相似性</li>
<li>新提出的方法在计算  graph vector 时考虑了 cross graph matching vector来得到 更具有判别性的 graph vector，从而更好的用于 计算 graph similarity.</li>
</ul>
<h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><ul>
<li>Graph Edit Distance（GED）：文中对问题进行了简化，两个graph（G1, G2），相同数量的节点数和边数, 如何变动一个图中的edge(i, j) 到 edge(i’, j’) 才能使两个graph 完全一样。以下是 GED=1 的例子。</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ga3ats0xyzj308p07jaaw.jpg" alt="搜狗截图20191220170651.png"></p>
<ul>
<li>该文主要是想解决graph 的相似性问题，而不是真正的要求解出来需要几步的 graph edit distance。因此对问题做了如下的设定：<code>positive pair:（原图G，对G变动一条边：G1）</code>，<code>negative pair: （原图G，对G变动两条边：G1）</code></li>
<li>positive pair 认为这两个 graph 是相似的，label=1; 而negative pair认为两个graph 是不相似的, label=-1。</li>
</ul>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ga3b3udt8bj30pe0bsgnq.jpg" alt="搜狗截图20191220171642.png"></p>
<ul>
<li><p>一般的计算两个graph之间的相似性问题采用上图中的左图的方法，分别单独计算出 graph vector，而后再计算 vector space similarity</p>
</li>
<li><p>而本文：计算两个graph之间的匹配，然后互相作为补充特征（cross-graph matching vector），得到更加 <strong>discriminative</strong>  graph representation， 从而更加有效的graph 之间的相似度问题。</p>
</li>
<li>yaya: 文中使用的是 <code>difference between node_i and its closest neighbor in the other graph</code>  来计算  <code>cross-graph matching vector</code> 。我认为还可以有其他的方法或许会更加有效。</li>
</ul>
]]></content>
      <categories>
        <category>图卷积网络</category>
      </categories>
      <tags>
        <tag>图卷积网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Graph R-CNN for Scene Graph Generation</title>
    <url>/2019/03/24/Graph-R-CNN-for-Scene-Graph-Generation/</url>
    <content><![CDATA[<p>这是ECCV 2018 场景图生成 的一篇文章。<br>写在前面，本文使用的GCN网络与“Graph Attention Networks”一致，都是计算两个节点之间的attention来计算邻接矩阵中的元素值，更新节点特征的公式是AXW。</p>
<ul>
<li><strong>查看本文的原因，主要是想看，其是如何提取relation feature的，但是文中仅使用了union box feature 作为relation feature。较为朴素！</strong>————————-不好</li>
<li><strong>同时也将relation 作为node放入graph 中，但是是object feature 与 realtion feature之间的混合graph，与“Auto-Encoding Scene Graphs for Image Captioning”一样采用的是异构图</strong>  </li>
<li><strong>文中对W<sup>sr</sup>Z<sup>r</sup>α<sup>sr</sup>， 为该node<sub>i</sub>与所有的relation nodes之间计算的注意力系数，并不合理，因为object 可能仅有一两个relation，怎么可能与所有的relation有关系呢</strong>—————————————不好（后又考虑了一下，可能没有关系的直接算0，就不再计算attention了）</li>
</ul>
<p>思索良久，终于发现是哪里不对了，一般的情况下，都是X’=AXW，这样的形式，以 X 为中心，更新X的特征，而Z<sub>i</sub><sup>r</sup>的更新公式中是以Z<sup>o</sup>为中心，因此是不是有些不对头呢？？？</p>
<p>本文的<strong>两个主要的贡献</strong>：</p>
<ol>
<li><strong>GCN</strong> with attention 用于scene graph generate 任务。Updating each object and relationship representation based on its neighbors</li>
<li>对于N个object ,若两两配对，则会产生N×N个relation，数量是N的二次，数量很多，但是很多又是没有必要的，以前的工作采用随机采样的方式，但是本文提出了<strong>RePN 网络来采样relation</strong>。</li>
<li>提出了一个新的用于scene graph generate 的评价指标，SGGen+（不是笔者关注的内容，因此此处忽略了对SGGen+的介绍）</li>
</ol>
<h2 id="场景图生成任务的主要步骤"><a href="#场景图生成任务的主要步骤" class="headerlink" title="场景图生成任务的主要步骤"></a>场景图生成任务的主要步骤</h2><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1dxanmhpfj312o08p75l.jpg">    </p>
<ol>
<li>P( V|I )  指：在给定image的情况下，去得到 <strong>object proposals</strong><br>使用pytorch 版本[1]的faster R-CNN来得到 bbox，类似于[2]，采用分段训练的方式，先对faster R-CNN进行预训练，然后，固定faster r-cnn参数，训练整个场景图生成网络。  </li>
<li>P( E|V, I ) 指：在给定image 和 bbox的情况下来得到 <strong>relation proposals</strong><br>如果假设每个object proposals 之间都会有一个relation，则有N×N个relation，或者是说，有N×N个object pairs。但是含有很多不合适的relation（本身这object pairs 之间不存在关系，但是却指定了某种关系），因此本文提出使用ReRN 网络来采样得到 relatedness relations。</li>
<li>P( R,O|V,E,I ) 指： 在给定image，object proposals以及relation proposal之后，得到object label 和 relation label。<br>一般的方法是采用iterative refinement process[2]，本文使用的是用GCN来迭代。</li>
</ol>
<ul>
<li>overview<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1dy02tb1zj31du0crajb.jpg"></li>
</ul>
<h2 id="Object-Proposal"><a href="#Object-Proposal" class="headerlink" title="Object Proposal"></a>Object Proposal</h2><p>使用faster r-cnn来提取<strong>object proposals</strong>，并得到相对应的一维特征向量（<strong>pooled feat</strong>），faster r-cnn 使用类别可知，则可以得到每个object 对应的<strong>label</strong><br>使用</p>
<h2 id="Relation-Proposal-Network"><a href="#Relation-Proposal-Network" class="headerlink" title="Relation Proposal Network"></a>Relation Proposal Network</h2><p>输入： <strong>labels</strong> of object pairs<br>输出：relatedness relations/ m 个object pairs<br>主要的步骤见下图：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e8ud0p66j32v311qjyg.jpg"></p>
<h2 id="Attention-GCN"><a href="#Attention-GCN" class="headerlink" title="Attention GCN"></a>Attention GCN</h2><h3 id="Formulation"><a href="#Formulation" class="headerlink" title="Formulation"></a>Formulation</h3><ul>
<li>与GAT的公式是一致的，具体可以参看论文GAT[ 3]，<strong>α<sub>i</sub></strong> 是注意力系数<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e8wl8yubj30f60360sr.jpg" style="zoom:60%"><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e8wl8m92j30gn04sjrp.jpg" style="zoom:60%"></li>
</ul>
<h3 id="aGCN-for-Scene-Graph-Generation"><a href="#aGCN-for-Scene-Graph-Generation" class="headerlink" title="aGCN for Scene Graph Generation"></a>aGCN for Scene Graph Generation</h3><ul>
<li>只构建一个graph，在这个graph中，object是node，relation也是node。<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e98pvy7aj30dh0cq0t3.jpg" style="zoom:60%">  </li>
<li><p>用skip代表object node之间的连接；构建的是有向边；捕捉了三中类型的连接：<br><strong>object &lt;—&gt; relationship</strong>， <strong>relationship &lt;—&gt; subject</strong> and <strong>object &lt;—&gt; object</strong><br><strong>s</strong>=subjects, <strong>o</strong>=objects, and <strong>r</strong>=relationships<br>object and relationship features as  <strong>Z<sup>o</sup></strong> and <strong>Z<sup>r</sup></strong><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e9gaiumnj30vp0dg0v2.jpg" style="zoom:60%"><br>对上图的解读：<br>（1）虽说是一个图，但是进行了两个aGCN的计算，使用的object and relationship node representation是什么？文中说，visual aGCN 使用visual feature 来进行计算，semantic aGCN 使用pre-softmax outputs来进行计算。（没看懂）<br>（2）WZα公式是GCN的计算公式，</p>
<ul>
<li>以 <strong>W<sup>skip</sup> Z<sup>o</sup> α<sup>skip</sup></strong> 为例，<strong>W<sup>skip</sup></strong> 是可学习参数，<strong>Z<sup>o</sup></strong> 是object nodes feature 组成的矩阵（d,N），<strong>α<sup>skip</sup></strong> 是一个向量，为该 node<sub>i</sub>与所有的object nodes之间计算的注意力系数，维度为(1,N）（N个objects）</li>
<li>以 <strong>W<sup>sr</sup> Z<sup>r</sup> α<sup>sr</sup></strong> 为例，<strong>W<sup>sr</sup></strong> 是可学习参数，<strong>Z<sup>r</sup></strong> 是realtion nodes feature 组成的矩阵（d,m），<strong>α<sup>sr</sup></strong> 是一个向量，为该node<sub>i</sub>与所有的relation nodes之间计算的注意力系数，维度为(1,m）（m个realtion）</li>
<li>以 <strong>W<sup>rs</sup> Z<sup>o</sup> α<sup>rs</sup></strong> 为例，<strong>W<sup>rs</sup></strong> 是可学习参数，<strong>Z<sup>o</sup></strong> 是object nodes feature 组成的矩阵（d,N），<strong>α<sup>rs</sup></strong> 是一个向量，为该relation<sub>i</sub>与所有的object nodes之间计算的注意力系数，维度为(1,N）（N个objects）  </li>
</ul>
<p>（3）需要注意的是，<strong>α<sub>ii</sub></strong>=1，这将使得，每一行想加不为1</p>
</li>
</ul>
<h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1ea7p889dj313l0dzwj3.jpg"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] A faster pytorch implementation of faster  r-cnn. <a href="https://github.com/jwyang/faster-rcnn.pytorch" target="_blank" rel="noopener">https://github.com/jwyang/faster-rcnn.pytorch</a><br>[2] Scene graph generation by iterative message passing<br>[3] Graph Attention Networks<br>[3] Graph Attention Networks</p>
]]></content>
  </entry>
  <entry>
    <title>Grounded Situation Recognition</title>
    <url>/2020/03/31/Grounded-Situation-Recognition/</url>
    <content><![CDATA[<h4 id="Grounded-Situation-Recognition-Task"><a href="#Grounded-Situation-Recognition-Task" class="headerlink" title="Grounded Situation Recognition Task"></a>Grounded Situation Recognition <strong>Task</strong></h4><h5 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h5><ul>
<li><p>以前的situation recognition task: </p>
<p><strong>Situation Recognition</strong> is the task of recognizing the activity happening in an image, the actors and objects involved in this activity, and the roles they play. Semantic roles describe how objects in the image participate in the activity described by the verb. </p>
<p>While situation recognition addresses <strong><em>what</em></strong> is happening in an image, <strong><em>who</em></strong> is playing a part in this and <strong><em>what</em></strong> their roles are, it does not address a critical aspect of visual understanding: <strong>where</strong> the involved entities lie in the image. </p>
</li>
<li><p>本文：We address this shortcoming and present <strong>Grounded Situation Recognition (GSR)</strong>, a task that builds upon situation recognition and requires one to not just identify the situation observed in the image but also visually ground the identified roles within the corresponding image.</p>
</li>
</ul>
<h4 id="Challenge-of-Grounded-Situation-Recognition-GSR"><a href="#Challenge-of-Grounded-Situation-Recognition-GSR" class="headerlink" title="Challenge of Grounded Situation Recognition (GSR)"></a>Challenge of Grounded Situation Recognition (GSR)</h4><ul>
<li><em>语义显著性</em>：与识别图像中的所有实体不同，它需要在呈现的<strong>主要活动的背景下</strong>识别关键对象和参与者。</li>
<li><em>语义稀疏性</em>：GSR存在语义稀疏性问题，  在训练中很少见到role and groundings 的许多组合。这一挑战要求模型从有限的数据中学习。</li>
<li><em>Ambiguity</em>：将角色定位到图像中通常需要消除在同一类别下的多个观察到的实体之间的歧义。</li>
<li><em>Scale</em>：grounded entities 的比例尺变化很大，图像中也缺少某些实体（在这种情况下，模型负责检测这种缺失）。</li>
<li><em>Hallucination</em>：标记语义角色并grounding 通常需要弄清物体的存在，因为它们可能被完全遮挡或不在屏幕上。</li>
</ul>
<h4 id="Situations-With-Groundings-SWiG-dataset"><a href="#Situations-With-Groundings-SWiG-dataset" class="headerlink" title="Situations With Groundings (SWiG) dataset"></a>Situations With Groundings (SWiG) dataset</h4><p><a href="https://prior.allenai.org/assets/project-content/gsr/gsr_banner.png" target="_blank" rel="noopener"><img src="https://prior.allenai.org/assets/project-content/gsr/gsr_banner.png" alt="SWiG examples">A sample of images from the SWiG dataset</a></p>
<p>We present the Situations With Groundings (SWiG) Dataset for training and evalutation on the GSR task. This dataset builds upon the <a href="https://homes.cs.washington.edu/~ali/papers/SituationRecognition.pdf" target="_blank" rel="noopener">Situation Recognition dataset</a> presented by Yatskar et al. The SWiG dataset contains approximately 125,000 images. Each image is associated with one verb. Three different annotators then label each <strong>entity</strong> in the frame associated with that <strong>verb</strong> and mark the <strong>location</strong> of the entity in the image. All three labels for each role are given in the SWiG dataset as well as an average of the three localizations.</p>
]]></content>
  </entry>
  <entry>
    <title>Grounded Video Description</title>
    <url>/2019/05/10/Grounded-Video-Description/</url>
    <content><![CDATA[<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><ul>
<li>这是CVPR 2019 做视频描述的一篇文章，该文的主要贡献是对已有的ActivityNet dense caption数据集进行加强—-对其中的帧进行了object bbox的标注，这就为视频描述任务增加了非常有用的信息。</li>
<li>总的来说，<font color="#dd00dd">该文的出发点是：1. 利用object 信息来生成句子. 2. 希望生成的句子中的名词，在video中可以找到相对应的证据(object)。</font><br></li>
<li>grounded-based video description model ：联合生成的单词，并微调在description中生成的object。可以探索这种显式的监督对视频描述带来的益处，并与无监督（可能利用region feature，但是没有 penalize grounding）的方法进行对比。</li>
</ul>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><ul>
<li>video输出的句子中提到的object，并没有在该video中实际存在。那么为什么有这种现象，是因为前的视频描述模型是基于先验知识，在之前的训练过程中，存在一个视频与该视频有 similar contexts，从而使得输出的单词中涵盖了训练video中的obejct，而不是该video本身的object，导致了该现象。</li>
<li>因此本文的工作： 将句子中的名词与视频中的object一 一对应起来，这样就可以建立sentence 与 evidence of video 之间的联系。<br>这样可以<font color="#0099ff" size="5">在视频描述模型中使用这些object 信息</font>，同时，<font color="#0099ff" size="5">还可以评估模型</font>（“teaching models to explicitly rely on the corresponding evidence in the video frame  when generating words and evaluating how well models   are doing in grounding individual words or phrases they  generated.”）。<br>如：该模型生成的句子中的名词与已经标注的object是否是一 一对应的（即便一个模型说出争取的sentence，比如一个男孩正在玩耍，但是如果video中有多个个男孩，那么该sentence输出的一个男孩是指向哪一个呢？）。</li>
</ul>
<h2 id="标注bbox时的细节"><a href="#标注bbox时的细节" class="headerlink" title="标注bbox时的细节"></a>标注bbox时的细节</h2><ul>
<li>“we collect ActivityNet-Entities (short as ANet-Entities) which  grounds or links noun phrases in sentences with bounding  boxes in the video frames.”<br>“we only  annotate a single frame of the video for each noun phrase” 。<br>即， 是对照着已有的sentence中的名词对其进行加框(bbox)，而不是对该video中的所有示例进行标注。对于sentence中的一个名词只在一帧上进行标注（稀疏标注） </li>
</ul>
<h2 id="调研工作"><a href="#调研工作" class="headerlink" title="调研工作"></a>调研工作</h2><h3 id="1-结合object-feature-做captioning任务"><a href="#1-结合object-feature-做captioning任务" class="headerlink" title="1. 结合object feature 做captioning任务"></a>1. 结合object feature 做captioning任务</h3><ul>
<li><strong>当前的方法</strong>，主要是两步：（1）使用off-the-shelf 或者是fine-tuned 的 object detector 来得到 object proposals （2）对object features采用动态attention，或者是对region进行分类，然后送入 decoder中。</li>
<li><strong>存在的问题</strong>，使用现成的object detector 将会使得到的object proposals 更偏向于 source dataset , 而不是偏向于当前的视频描述target dataset。一种解决方案是针对于target dataset 来fine-tune object detector。但是这种那个方案需要大量的标注，尤其是对于video，数据量会更大，</li>
<li>因此提出了<font color="#0099ff" size="5" face="黑体">本文的方法(给出了fine-tune obejct detector的改进方案)</font>：“Instead of  fine-tuning a general detector, we transfer the object classification knowledge from off-the-shelf object detectors to  our model and then fine-tune this representation as part of  our generation model with sparse box annotations. ”。</li>
<li>在文章中的4.4节开头给出了具体的实现：已经得到了bbox，现在的目的是想要得到the class probability distribution for each region. 将在visual genome上预训练的detector迁移到我们的<strong>object classifier</strong> 任务上，另外关于classes集合，假定我们已经有了K个类别，则我们在Visual Genome中根据最近距离找到与其对应的classes。  定义一个softmax( Wx+b )的分类层，W 和 b 的初始化是预训练的detector的最后一个线性层（分类层）的参数值（W应该是根据找出的K个类别按照索引抽出的一个矩阵）。<h3 id="2-object-attention"><a href="#2-object-attention" class="headerlink" title="2. object attention"></a>2. object attention</h3></li>
<li>某些作者指出，attention model关注的region和人类的关注点并不一致，增加attention supervision几乎不能提高性能。另一方面，在feature map attention 上增加监督，是有益处的。</li>
<li>在该文作者的实验中，region attention with supervision 并不能带来性能的提升，作者分析，这可能是由于缺少object context 信息，因此<font color="#0099ff" size="5" face="黑体">该文作者在attention model中引入了基于context encoding 的self-attention</font>，这将会使得信息能够在被采样的视频帧中的regions 传递(我理解的是，region feature 不仅仅是单纯的从fc层中提取到的信息，同时也结合了其余信息来得到 grounding-aware region encoding， 在文章的4.3 以及 4.4节有关于<strong>R<sup>~</sup></strong> 的定义)。 </li>
</ul>
<h2 id="Description-with-Grounding-Supervision"><a href="#Description-with-Grounding-Supervision" class="headerlink" title="Description with Grounding Supervision"></a>Description with Grounding Supervision</h2><ul>
<li>这个框架包括三个模块: <strong>grounding</strong>, <strong>region attention</strong> and <strong>language generation</strong>.<br>grounding： 对于生成的word， 从video中检测到对应的visual clue。<br>region attention: 动态的将visual clue 形成一个high-level的视觉内容的表达，并将其送入decoder。   </li>
<li>这里包括三种方式来结合object-level supervision: <strong>region classification</strong>,  <strong>object grounding (localization)</strong>, and <strong>supervised attention</strong>.  </li>
<li><strong>（我的理解，supervised attention直接针对attention中的系数，查看与真实的对应关系，设计的这个loss对于视频描述生成由益处；object grounding 涉及到了region attention中的系数，因此与描述生成有一定的关联，反向传播可能是有益处的；region classification中设计的loss： 它的反向传播会更新M<sub>s</sub>( R ), 进一步作用于region encoding, 进一步作用于region attention 和 language generate；）</strong></li>
</ul>
<h3 id="Language-Generation-Module"><a href="#Language-Generation-Module" class="headerlink" title="Language Generation Module"></a>Language Generation Module</h3><ul>
<li>本文的decoder 部分采用 [1] 中提到的decoder，与bottom up[3] 的结构大致近似，但是<strong>在[1]中</strong>第二层 language lstm的输入部分，不仅包括attention of region feature， 还包括attention of 最后一个卷积层k girds的特征。对应到本文的视频描述任务上，第二层language lstm的输入，不仅包括attention of region features ，还包括 attention of frames features。即region attention 和 temporal attention</li>
<li>需要注意的是该文中使用的<font color="#0099ff" size="5" face="黑体">temporal attention</font>是[2]中提到的self-attention context encoder with Bidirectional GRU (Bi-GRU)，而不是[1]中使用的attention机制。</li>
<li><font color="#0099ff" size="5" face="黑体">region attention</font>采用的就是bottom up 中的attention结构</li>
<li>下面将[1] 中的原图贴一下：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2x5hlq801j30l20ezq4v.jpg">   </li>
</ul>
<h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><h3 id="Region-proposal-and-features"><a href="#Region-proposal-and-features" class="headerlink" title="Region proposal and features"></a>Region proposal and features</h3><p>For each frame, we use a Faster  R-CNN detector [24] with ResNeXt-101 backbone [30] for  region proposal and feature extraction (fc6). The detector is  pretrained on Visual Genome。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] Neural baby talk. In CVPR 2018.<br>[2] End-to-end dense video captioning with masked transformer. In CVPR 2018.<br>[3] Bottom-up and top-down attention for image captioning and  visual question answering. In CVPR 2018.</p>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>Gumbel-Softmax Trick和Gumbel分布</title>
    <url>/2021/03/15/Gumbel-Softmax-Trick%E5%92%8CGumbel%E5%88%86%E5%B8%83/</url>
    <content><![CDATA[<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><ul>
<li><p>由于最近看到的几篇论文中都有提及到gumble softmax的操作，因此想要具体了解一下。</p>
</li>
<li><p>用到gumbel softmax 的论文包括以下几篇</p>
<ul>
<li><p>解决不可微分问题</p>
<p>【ICCV 2019】Learning to Assemble Neural Module Tree Networks for Visual Grounding</p>
<p>【arXiv: 2101.12059v1】VX2TEXT: End-to-End Learning of Video-Based Text Generation From Multimodal Inputs</p>
<p>【arXiv: 2103.08862】Gumbel-Attention for Multi-modal Machine Translation</p>
<blockquote>
<p><strong>Categorical reparameterization with gumbel-softmax.</strong>  ICLR 2017</p>
</blockquote>
</li>
<li><p>在概率分布上添加gumble noise，再从新的概率分布上以概率检索样本</p>
<p> Bridging the Gap between Training and Inference for Neural Machine Translation</p>
<blockquote>
<p><strong>A* sampling.</strong> NIPS 2017</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>来源:  <a href="https://www.cnblogs.com/initial-h/p/9468974.html" target="_blank" rel="noopener">https://www.cnblogs.com/initial-h/p/9468974.html</a></p>
<p>之前看MADDPG论文的时候，作者提到在离散的信息交流环境中，使用了Gumbel-Softmax estimator。于是去搜了一下，发现该技巧应用甚广，如深度学习中的各种GAN、强化学习中的A2C和MADDPG算法等等。只要涉及在离散分布上运用重参数技巧时(re-parameterization)，都可以试试Gumbel-Softmax Trick。</p>
<p>  这篇文章是学习以下链接之后的个人理解，内容也基本出于此，需要深入理解的可以自取。</p>
<ul>
<li><a href="http://amid.fish/humble-gumbel" target="_blank" rel="noopener">The Humble Gumbel Distribution</a></li>
<li><a href="https://hips.seas.harvard.edu/blog/2013/04/06/the-gumbel-max-trick-for-discrete-distributions/" target="_blank" rel="noopener">The Gumbel-Max Trick for Discrete Distributions</a></li>
<li><a href="https://casmls.github.io/general/2017/02/01/GumbelSoftmax.html" target="_blank" rel="noopener">The Gumbel-Softmax Trick for Inference of Discrete Variables</a></li>
<li><a href="https://www.zhihu.com/question/62631725/answer/201338234" target="_blank" rel="noopener">如何理解Gumbel-Max trick？</a></li>
</ul>
<p>  这篇文章从直观感觉讲起，先讲Gumbel-Softmax Trick用在哪里及如何运用，再编程感受Gumbel分布的效果，最后讨论数学证明。</p>
<h2 id="一、Gumbel-Softmax-Trick用在哪里"><a href="#一、Gumbel-Softmax-Trick用在哪里" class="headerlink" title="一、Gumbel-Softmax Trick用在哪里"></a>一、Gumbel-Softmax Trick用在哪里</h2><h3 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h3><p>  通常在强化学习中，如果动作空间是离散的，比如上、下、左、右四个动作，通常的做法是网络输出一个四维的one-hot向量(不考虑空动作)，分别代表四个动作。比如 [1,0,0,0] 代表上，[0,1,0,0] 代表下等等。而具体取哪个动作呢，就根据输出的每个维度的大小，选择值最大的作为输出动作, 即argmax(v)。</p>
<p>  例如网络输出的四维向量为v=[−20,10,9.6,6.2]，第二个维度取到最大值10，那么输出的动作就是[0,1,0,0]，也就是下，这和多类别的分类任务是一个道理。但是这种取法有个问题是不能计算梯度，也就不能更新网络。通常的做法是加softmax函数，把向量归一化，这样既能计算梯度，同时值的大小还能表示概率的含义。softmax函数定义：$\sigma\left(z_{i}\right)=\frac{e^{z_{i}}}{\sum_{j=1}^{K} e^{z_{j}}}$</p>
<p>  那么将v=[−20,10,9.6,6.2]通过softmax函数后有σ(v)=[0,0.591,0.396,0.013]，这样做不会改变动作或者说类别的选取，同时softmax倾向于让最大值的概率显著大于其他值，比如这里10和9.6经过softmax放缩之后变成了0.591和0.396，6.2对应的概率更是变成了0.013，这有利于把网络训成一个one-hot输出的形式，这种方式在分类问题中是常用方法。</p>
<p>  但是这么做还有一个问题，这个表示概率的向量σ(v)=[0,0.591,0.396,0.013]并没有真正显示出概率的含义，因为一旦某个值最大，就选择相应的动作或者分类。比如σ(v)=[0,0.591,0.396,0.013]和σ(v)=[0,0.9,0.1,0]在类别选取的结果看来没有任何差别，都是选择第二个类别，但是从概率意义上讲差别是巨大的。所以需要一种方法不仅选出动作，而且遵从概率的含义。</p>
<p>  很直接的方法是依概率分布采样就完事了，比如直接用<code>np.random.choice</code>函数依照概率生成样本值，这样概率就有意义了。这样做确实可以，但是又有一个问题冒了出来：这种方式怎么计算梯度？不能计算梯度怎么用BP的方式更新网络？</p>
<p>  这时重参数(re-parameterization)技巧解决了这个问题，<a href="https://casmls.github.io/general/2017/02/01/GumbelSoftmax.html" target="_blank" rel="noopener">这里</a>有详尽的解释，不过比较晦涩。简单来说重参数技巧的一个用处是把采样的步骤移出计算图，这样整个图就可以计算梯度BP更新了。之前我一直在想分类任务直接softmax之后BP更新不就完事了吗，为什么非得采样。后来看了VAE和GAN之后明白，还有很多需要采样训练的任务。这里举简单的VAE(变分自编码器)的例子说明需要采样训练的任务以及重参数技巧，详细内容来自<a href="https://www.bilibili.com/video/av20165127" target="_blank" rel="noopener">视频</a>和<a href="http://kvfrans.com/variational-autoencoders-explained/" target="_blank" rel="noopener">博客</a>。</p>
<h3 id="Re-parameterization-Trick"><a href="#Re-parameterization-Trick" class="headerlink" title="Re-parameterization Trick"></a>Re-parameterization Trick</h3><p>  最原始的自编码器通常长这样：</p>
<p><img src="C:\Users\shiyaya\Desktop\1428973-20180813165000500-1207992534.jpg" alt="img" style="zoom: 67%;"></p>
<p>  左右两边是端到端的出入输出网络，中间的绿色是提取的特征向量，这是一种直接从图片提取特征的方式。<br>  而VAE长这样:</p>
<p><img src="https://i.loli.net/2021/03/18/yO5L9kCMPhrwJub.png" alt="image-20210318135149420"></p>
<p>  VAE的想法是不直接用网络去提取特征向量，而是提取这张图像的分布特征，也就把绿色的特征向量替换为分布的参数向量，比如说均值和标准差。然后需要decode图像的时候，就从encode出来的分布中采样得到特征向量样本，用这个样本去重建图像，这时怎么计算梯度的问题就出现了。<br>  重参数技巧可以解决这个问题，它长下面这样:</p>
<p><img src="https://i.loli.net/2021/03/18/27e1EIhVFfWyJKi.png" alt="img" style="zoom:67%;"></p>
<p>假设图中的 $x$ 和 $\phi$ 表示VAE中的均值和标准差向量, 它们是确定性的节点。而需要输出的样本 $z$ 是带有随机性的节点， 重参数就是把带有随机性的 $z$ 变成确定性的节点, 同时随机性用另一个输入节点 $\epsilon$ 代替。<br>例如，这里用正态分布采样, 原本从均值为 $x$ 和标准差为 $\phi$ 的正态分布 $N\left(x, \phi^{2}\right)$ 中采样得到 $z_{\circ}$ 现在将其转化成从标准正态分布 $N(0,1)$ 中采样得到 $\epsilon$ , 再计算得到 $z=x+\epsilon \cdot \phi_{\circ}$ 这样一来, 采样的过程移出了计算图, 整张计算图就可以计算梯度进行更新了，而新加的 $\epsilon$ 的输入分支不 做更新，只当成一个没有权重变化的输入。</p>
<p>到这里，需要采样训练的任务实例以及重参数技巧基本有个概念了。</p>
<h3 id="Gumbel-Softmax-Trick"><a href="#Gumbel-Softmax-Trick" class="headerlink" title="Gumbel-Softmax Trick"></a>Gumbel-Softmax Trick</h3><p>VAE的例子是一个连续分布(正态分布)的重参数，离散分布的情况也一样，首先需要可以采样，使得离散的概率分布有意义而不是只取概率最大的值，其次需要可以计算梯度。那么怎么做到的，具体操作如下：</p>
<p>对于n维概率向量$\pi$, 对$\pi$对应的离散随机变量 $x_{\pi}$ 添加Gumbel噪声，再取样$x_{\pi}=\arg \max \left(\log \left(\pi_{i}\right)+G_{i}\right)$<br>其中, $G_{i}$ 是独立同分布的标准Gumbel分布的随机变量，标准Gumbel分布的CDF为$F(x)=e^{-e^{-x}}$</p>
<p>这就是<strong style="color:red;">Gumbel-Max trick</strong>。可以看到由于这中间有一个argmax操作，这是不可导的。所以用softmax函数代替之，也就是<strong style="color:red;">Gumbel-Softmax Trick</strong>，而$G_{i}$ 可以通过Gumbel分布求逆从均匀分布生成，即 $G_{i}=-\log \left(-\log \left(U_{i}\right)\right), U_{i} \sim U(0,1)$</p>
<p>算法流程如下：</p>
<ul>
<li><p>对于网络输出的一个 $n$ 维向量 $v$ （predict logits）, 生成 $n$ 个服从均匀分布 $U(0,1)$ 的独立样本 $\epsilon_{1}, \ldots, \epsilon_{n}$</p>
</li>
<li><p>通过 $G_{i}=-\log \left(-\log \left(\epsilon_{i}\right)\right)$ 计算得到 $G_{i}$</p>
</li>
<li><p>对应相加得到新的值向量 $v^{\prime}=\left[v_{1}+G_{1}, v_{2}+G_{2}, \ldots, v_{n}+G_{n}\right]$</p>
</li>
<li><p>通过Softmax函数</p>
</li>
</ul>
<script type="math/tex; mode=display">
\sigma_{\tau}\left(v_{i}^{\prime}\right)=\frac{e^{v_{i}^{\prime} / \tau}}{\sum_{j=1}^{n} e^{v_{j}^{\prime} / \tau}}</script><p>计算概率大小得到最终的类别。其中 $\tau$ 是温度参数。</p>
<p>temperature控制着softmax的soft程度，温度越高，生成的分布越平滑（接近这里的均匀分布）；温度越低，生成的分布越接近离散的one-hot分布（argmax）。因此，<strong>训练时可以逐渐降低温度，以逐步逼近真实的离散分布。</strong></p>
<p><strong>yaya: 其实这里的 gumbel softmax 不是针对网络输出$v$ 进行一个离散采样，而是对 $v$ 添加噪声之后，再取softmax，而后得到新的概率分布，而这个新的概率分布也不是去argmax, 而是对于每个 $v_i$ 重新分配一个概率权重。其优点在于可以调控 temperature， 当温度低时，近似做了argmax 采样</strong></p>
<p>直观上来说，Gumbel-Softmax就是在原来的输出上加入了一个噪声，对于强化学习来说，在选择动作之前加一个Gumbel扰动，相当于增加了探索度，感觉上是合理的，而同时他又能保证采样是对原分布的逼近。对于深度学习的任务来说，添加随机性去模拟分布的样本生成，也是合情合理的。</p>
]]></content>
      <categories>
        <category>杂类</category>
      </categories>
      <tags>
        <tag>杂类</tag>
      </tags>
  </entry>
  <entry>
    <title>Hierarchical Global-Local Temporal Modeling for Video Captioning</title>
    <url>/2019/07/23/Hierarchical-Global-Local-Temporal-Modeling-for-Video-Captioning/</url>
    <content><![CDATA[<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><ul>
<li>使用object features能够更好地检测出action 和 关键的Object</li>
</ul>
<h3 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h3><ul>
<li><p>两个LSTM层</p>
</li>
<li><p>global : frame features and C3D features</p>
</li>
<li><p>local : objects </p>
</li>
</ul>
<h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><ul>
<li>Top Down decoder<ul>
<li>Bottom LSTM：mean of regions</li>
<li>Top LSTM : attention of  regions</li>
</ul>
</li>
<li><p>Grounded video description的decoder：</p>
<ul>
<li>Bottom LSTM：mean of  fc+motion</li>
<li>Top LSTM: attention of  regions and attention of  fc+motion</li>
</ul>
</li>
<li>==Hierarchical Global-Local Temporal Modeling（本文） ==<ul>
<li>Bottom LSTM：attention of fc+motion</li>
<li>Top LSTM: attention of regions</li>
<li>本文不一样的地方是在Bottom LSTM的输入也加入了attention</li>
</ul>
</li>
</ul>
<h3 id="提取特征"><a href="#提取特征" class="headerlink" title="提取特征"></a>提取特征</h3><ul>
<li>等间隔提取帧的特征</li>
<li>由于帧之间的间隔，会使得没有运动信息，所以再使用C3D来补充运动信息（以该该为中心，提取16帧，输入C3D中）</li>
<li>object features: faster rcnn 去掉rcnn部分的类别/分数预测，提取head_to_heal处的pooled_feats</li>
</ul>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>Hierarchical Boundary-Aware Neural Encoder for Video Captioning</title>
    <url>/2019/02/22/Hierarchical-Boundary-Aware-Neural-Encoder-for-Video-Captioning/</url>
    <content><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0g5c5cwmxj30l00mh45o.jpg"><br>In this paper, we focus on the video encoding stage. we propose a recurrent network which can learn to adapt its temporal structure to input data.Our network is the first proposal which exploits temporal segments in<br>video captioning。<br>在这篇文章中，给出了一个循环视频编码方案，该方案可以发现和利用视频的分层结构。不同于经典的编码解码方法（视频由一个循环层来连续的编码），我们提出了一个新颖的LSTM单元， 其可以识别帧/段之间非连续的点，相应地修改编码层的时间连接。</p>
<h2 id="Encoder-Model"><a href="#Encoder-Model" class="headerlink" title="Encoder Model"></a>Encoder Model</h2><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0g57reyepj316c0m7k74.jpg">  </p>
<ul>
<li><strong>traditional lstm network</strong><br>使用LSTM来获得video feature，将每个frames 按每time step 依次送入LSTM，最后一个LSTM cell 的hidden state 用来得到video feature。  <ul>
<li><strong>Time Boundary-aware LSTM network</strong> <strong><em>(ours)</em></strong><br>figure1 与 figure2 结合来看，存在BD（boundary detection ）来检测该帧是否为一个边界（an appearance or action change），若BD检测到存在一个边界，则<strong>保存当前LSTM的输出</strong>，并开始一个新的LSTM（即，hidden state and the cell memory 被重新初始化）。这就确保了在边界之后的输入数据，不受边界之前数据的影响。<br>经过对all frames of video 进行这样的操作，于是得到可变长度的输出 (s1; s2; …; sm), m是检测到segments的数量。<br>这组输出又经过另外一个LSTM层（称为第二LSTM层），第二LSTM层的hidden state 作为整个视频的特征（参考figure1）。<br>Decoder model</li>
</ul>
</li>
</ul>
<hr>
<p>A Gated Recurrent Unit (GRU) layer</p>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>How Many Data Points is a PromptWorth?</title>
    <url>/2021/03/20/How-Many-Data-Points-is-a-PromptWorth/</url>
    <content><![CDATA[<p>转载：<a href="https://mp.weixin.qq.com/s/vX6o4lJKP4ajVfGSw8-tqg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/vX6o4lJKP4ajVfGSw8-tqg</a></p>
<blockquote>
<p>今天介绍的是一篇 NAACL’21 新鲜出炉的工作！NAACL 上周四出的结果，这篇工作本周一上传 arxiv，周二被王苏小哥哥发现，周三拜读了一下，今天就来和大家分享啦！！</p>
</blockquote>
<p>给大家提个问题：如果训练样本只有几百条，这时候我们该怎么办呢？</p>
<p>传统的 RNN 在这个样本大小下很难被训练好，自然地，我们会想到使用预训练模型，在其基础上进行 finetune。具体来讲，就是将预训练模型作为模型的底层，在上面添加与当前任务特点相关的网络结构。这样就引入了预训练的知识，对当前任务能产生很大的帮助。</p>
<p><img src="https://i.loli.net/2021/03/21/QodMJ9GWgv6fcUy.png" alt="微信截图_20210321123106" style="zoom:33%;"></p>
<p>除了预训练的知识，是不是还有其他的信息我们没有用上呢？近年来，越来越多的人在使用另一种 finetune 方法，即<strong>结合具体场景，设计新的 finetune 任务形式，从而将与当前任务相关的提示信息（prompt）引入模型</strong>。我们大名鼎鼎的 GPT 系列就是这么干的。比如我们拿 GPT3 做 QA 的 finetune，直接喂给他一串“<em>Question：问题内容 Answer：</em>”，剩下的答案部分就让 GPT3 自己填完。</p>
<p><img src="https://i.loli.net/2021/03/21/s8DHwgmNJY7Ryvk.png" alt="image-20210321123155512" style="zoom: 33%;"></p>
<p>这类 finetune 技巧虽然陆续被使用，但并没有人论证：<strong>这种做法相比于传统的 finetune 方法，真的能带来提升吗</strong>？如果答案是肯定的，<strong>那么究竟能提升多少呢（能否量化这种提升）？</strong></p>
<p>今天这篇来自 Huggingface 的文章就填补了上述两个问题的答案。他们通过大量实验证明：<strong>引入提示信息和多标注几百条数据带来的性能提升是相当的</strong>！所以，下次老板只给少量样本，就要你 finetune 模型——不要慌！我们今天又多学了一个 trick！</p>
<p><strong>论文题目</strong>:<br><strong><em>How Many Data Points is a Prompt Worth?</em></strong></p>
<p><strong>论文链接</strong>:<br><em><a href="https://arxiv.org/abs/2103.08493" target="_blank" rel="noopener">https://arxiv.org/abs/2103.08493</a></em></p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>前文提到，这一类 finetune 是将任务对应的输入改写成新的完形填空格式，让模型预测 <mask> 部分的词，作为抽取任务的答案或者生成任务的结果。这种方法不需要改变模型结构、没有额外的参数，简直不要太方便！</mask></p>
<h3 id="引入描述集合"><a href="#引入描述集合" class="headerlink" title="引入描述集合"></a>引入描述集合</h3><p>本文对这类方法进行了进一步简化：不要求 <mask> 处生成任意的文本，而是只需要完成类似于有选项的完形填空任务。这里的选项是固定的几个词，我们称之为描述集合（verbalizer），不同任务会有不同的描述集合。</mask></p>
<p>比如，对于判断题的阅读理解任务，就可以将阅读文本、问题和 <mask> 拼接，让预训练模型直接预测 <mask> 属于描述集合 {yes, no} 中的哪一种描述：</mask></mask></p>
<blockquote>
<p>小明天天码代码码到天明 [SEP] <strong>小明有女朋友吗？</strong> <mask></mask></p>
</blockquote>
<p>其中前半部分是阅读文本，后面<strong>加粗</strong>的部分是问题。模型只需要判断 <mask> 属于描述集合 {yes, no} 中的哪一种。</mask></p>
<p>可能读到这里，大家会疑惑：直接拼起来搞一个 True / False 的二分类不就好了嘛，何必让模型填空呢？嘿嘿，这恰好是作者的用意：通过让模型填空，<strong>模型可以习得描述集合中标签文本的语义信息</strong>。</p>
<h3 id="引入提示信息"><a href="#引入提示信息" class="headerlink" title="引入提示信息"></a>引入提示信息</h3><p>直接拼接是最朴素的，但这能让模型知道自己在做什么任务嘛？为此，作者引入了<strong>提示信息</strong>（prompt）。</p>
<p>还是判断题的阅读理解任务，对文章 和问题 ，作者将他们与一些固定的词进行整合，以此输入模型，让模型预测 <mask> 。作者提出了三种整合方式：</mask></p>
<p><img src="https://i.loli.net/2021/03/21/QEPwMG7bfI2UzNH.png" alt="image-20210321123632246" style="zoom: 33%;"></p>
<p>没错，就是这么简单！这些固定的词作为提示信息，让模型了解当前在做的任务；同时，提示词文本的含义也对于模型的理解产生了一定的帮助。</p>
<p>除了单选阅读理解，这篇文章还关注了文本蕴含、多选阅读理解、指代销歧等共六个任务。对于不同的任务，有不同的提示信息与输入格式：</p>
<p>对于文本蕴含任务，可以将前提 (premise, ) 与假设 (hyphothesis, ) 通过提示信息整合，作者提出了两种整合方式：</p>
<p><img src="https://i.loli.net/2021/03/21/k1ul7icFX69IKnL.png" alt="image-20210321123241288" style="zoom: 33%;"></p>
<p>这样就只需要让模型预测 <mask> 属于描述集合 {yes, no, maybe} 中的哪一种，以此判断前提能否支撑假设。</mask></p>
<p>对于指代销歧任务，可以将句子 、带标记的介词 与名词 通过提示信息整合：</p>
<p><img src="https://i.loli.net/2021/03/21/sRZIGzn2Pg76mpd.png" alt="image-20210321123253166" style="zoom: 33%;"></p>
<p>这样就只需要让模型预测 <mask> ，以此判断介词是否指代名词。这里的描述集合是不受限制的，即让模型在 <mask> 处预测指代的名词 。</mask></mask></p>
<p>其他任务也采用类似的整合方式，感兴趣可以参考原文～</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>作者发现，这种使用提示信息的整合方式，在低资源的情况下对模型性能有非常大的提升！</p>
<p>比如在阅读理解任务的 BoolQ 数据集上，作者将使用提示信息整合的 finetune 方法与增加一层分类层的 finetune 方法进行了对比。下图是在使用不同数量的样本训练时，模型准确率的对比。</p>
<p><img src="https://i.loli.net/2021/03/21/31cqsF5Q7VoSeLX.png" alt="image-20210321123431996" style="zoom:50%;"></p>
<p>可以发现，在数据量比较小的时候，使用提示信息整合的 finetune 方法（黄色）比增加一层分类层的 finetune 方法（紫色）有更好的表现。</p>
<p>在某些任务上，这种表现的提升是惊人的：</p>
<p><img src="https://i.loli.net/2021/03/21/WCo9uUakm1rOH8N.png" alt="image-20210321123504144" style="zoom:50%;"></p>
<p>这是在指代销歧任务的 WSC 数据集上的实验结果。在水平方向看，<strong>仅使用 25 个样本，就达到传统 fintune 方法使用 300 个样本才能达到的效果！</strong></p>
<p>此外，作者还进行了一系列的消融实验，得到一些有意思的结论：</p>
<ol>
<li>模型通过预测 <mask> 属于描述集合中的哪种，以此完成任务。如果将这里改为不带语义的单纯的分类，性能也会有所下降。</mask></li>
<li>作者为每个任务都提供了多种整合提示信息的方式，但是发现，不同方式的区别对性能影响甚微。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章对基于提示信息的 finetune 方法在进行了大量实验，证明了这类方法在低资源的情况下性能大幅优于传统方法。这种 finetune 的思路应该是可以应用于各类 NLP 下游任务的。尤其是低资源场景下，应该会非常有帮助。如果老板真的只给几百条数据让训练模型，这样的方法说不定就有奇效！</p>
]]></content>
      <categories>
        <category>NLP</category>
        <category>few-shot</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>few-shot</tag>
      </tags>
  </entry>
  <entry>
    <title>I3D</title>
    <url>/2019/04/09/I3D/</url>
    <content><![CDATA[<ul>
<li>参考:<a href="https://zhuanlan.zhihu.com/p/34919655" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34919655</a></li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1wgkib11aj310b0ew77m.jpg">  </p>
<h3 id="训练和预测"><a href="#训练和预测" class="headerlink" title="训练和预测"></a>训练和预测</h3><ul>
<li>写在前面，方便看，哈哈哈哈</li>
<li>video 以25帧/秒的帧率来提取关键帧</li>
<li>在训练时，以64帧组成的snippets进行训练。</li>
<li>在测试时，同样以64帧组成的snippets进行测试，但是对于该video上的所有的snippet的预测结果进行取平均作为该video的预测结果</li>
</ul>
<h3 id="方法1：ConvNet-LSTM"><a href="#方法1：ConvNet-LSTM" class="headerlink" title="方法1：ConvNet+LSTM"></a><strong>方法1：ConvNet+LSTM</strong></h3><ul>
<li>该方案主要考虑到cnn在图像分类领域的成功以及LSTM对于序列建模的能力，很自然提出将两者结合起来的方案。如果只是用cnn的话，需要对每一帧都提取特征，然后将视频的所有帧特征进行总汇，以此来表达对视频的表示，显然这样做忽略的时间结构特征。而LSTM可以处理长时间依赖的问题，可以对视频从第一帧开始建模直到最后一帧，使用cnn网络对每帧提取特征，然后将特征送入LSTM来捕捉时间特征，最后一帧的输出用来对视频特征表示。<br>  LSTM往往依赖cnn的最后一层特征最为输入，因此不能够捕捉到<code>low-level motion</code>的特征，而且对于遍历整个视频也很难去训练。<h3 id="方法2：3D-ConvNets"><a href="#方法2：3D-ConvNets" class="headerlink" title="方法2：3D ConvNets"></a><strong>方法2：3D ConvNets</strong></h3></li>
<li><code>3D ConvNets</code>是对视频建模最自然的方式，和标准cnn区别在于由<code>2d conv</code>变为<code>3d conv</code>，来捕捉<code>spatio-temporal feature</code>。想法很好，但目前遇到一些问题，问题一：<code>3D ConvNets</code>的<code>3d conv</code>多了一个维度，参数量有较大增加，这将会很难去训练。问题二：没有利用那些Imagenet上成功的预训练模型来迁移学习，往往使用层数少的cnn在小数据集上从头训练。简要说就是要利用已有预训练模型，要减少参数或增大数据集。<br>  论文中实现了C3D（与原版略有差异）有8 conv layer、5 pooling layer 和 2 fc layer，并在所有圈卷积层和fc层加bn。输入是16×112×112（通过crop方法），将第一个pooling layer对时间的stride由1变成2，为了可以减少memory和允许更大batch。<h3 id="方法3：Two-Stream-Networks"><a href="#方法3：Two-Stream-Networks" class="headerlink" title="方法3：Two-Stream Networks"></a><strong>方法3：Two-Stream Networks</strong></h3></li>
<li>该方案利用短的视频段来建模，用每个clip的预测分数平均的方式（其实C3D也是类似），但不同的是输入，包括一张RGB和10张<code>optical flow</code>(其实是5张，x/y两个方向，运动特征)。模型能使用<code>two-branch</code>方式，利用预训练的imagenet模型，最后将预测结果平均下（最原始的，或者在最后softmax做融合），这样建模的模型比较好训练，同时也能获得更高的分数。  </li>
<li>模型的两个输入流也可以在后面的cnn层来进行融合，以提升相同，同时可以<code>end-to-end</code>训练。论文实现一个类似的two-stream方案，在最后一层用<code>3d conv</code>将spatial和flow特征进行融合。<h3 id="方法4：Two-Stream-Inflated-3D-ConvNets"><a href="#方法4：Two-Stream-Inflated-3D-ConvNets" class="headerlink" title="方法4：Two-Stream Inflated 3D ConvNets"></a><strong>方法4：Two-Stream Inflated 3D ConvNets</strong></h3></li>
<li>该方案是论文提出的，出发点是要利用imagenet的预训练模型，同时利用<code>3d conv</code>来提取<code>RGB stream</code>的<code>temporal feature</code>，最后再利用<code>optical-flow stream</code>提升网络性能，也就大融合的方案（把有效的技巧都用上）。  </li>
<li>通过对预训练的<code>2D conv</code>增加temporal维度，把N×N的filter变为N×N×N。简单的办法就是对N×N的filter重复复制N遍，并归一化，这样多的出发点是短期内时间不变性的假设，姑且把这当成<code>3D filter</code>初始化的一种策略吧。  </li>
<li>池化操作怎么膨胀？stride怎么选？主要依赖感受野尺寸，如果图像水平方向和竖直方向相等，那么stride也相等，而且越深的特征感受野越大。但是考虑到时间因素，对称感受野不是必须的，这主要还是依赖帧率和图片大小。时间相对于空间变化过快，将合并不同object的边信息，过慢将不能捕捉场景变化。  </li>
<li>虽然3D conv能够捕捉motion信息，但是与光流优化的方式和效果还是不一样，因此使用<code>two-stream</code>的方式构建，并分开训练两个网络。</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-34f1d3ac14884d5c9114d4e9383c2e89_hd.jpg" alt></p>
<hr>
<ul>
<li><p>数据集不同，评测结果也不同。flow在UCF-101上效果比HMDB-51、kinetics上好（有更多camera运动的原因）。<br><img src="https://pic2.zhimg.com/80/v2-e719a0a3a022e348838d4b6a5c0b8a55_hd.jpg" alt></p>
</li>
<li><p>在imagenet上训练后迁移到kinetics和直接在kinetics上的对比，迁移后的效果好，说明RGB流起的作用大。整体上I3D模型参数更少，更深，训练输入在时间和空间维度上都比C3D大。<br><img src="https://pic3.zhimg.com/80/v2-b358535638c000de801577fc84296252_hd.jpg" alt></p>
</li>
</ul>
]]></content>
      <categories>
        <category>行为识别</category>
      </categories>
      <tags>
        <tag>行为识别</tag>
      </tags>
  </entry>
  <entry>
    <title>Image Caption 常用评价指标</title>
    <url>/2019/03/24/Image-Caption-%E5%B8%B8%E7%94%A8%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Improving Image Captioning Evaluation by Considering Inter References Variance</title>
    <url>/2020/07/26/Improving-Image-Captioning-Evaluation-by-Considering-Inter-References-Variance/</url>
    <content><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><ul>
<li><p>one-to-one metrics的方法存在缺陷：without considering the intrinsic variance between ground truth captions.  </p>
<p>bertscore 是最新的one-to-one metric， 可以实现与human很好的相关性，但是如果一些问题可以解决的话，可以能够进一步的提升性能。</p>
<p>本文则基于 bertscore，提出了一个新方法。</p>
</li>
</ul>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><ul>
<li><p><strong>当前的评价指标</strong>—over penalize：对于M个reference，metric 通过one-to-one 的方式得到M个得分，通过 pooling 操作，得到最终得分。<br>但是不同的reference caption关注到image的不同方面，因此会存在 variance。所以基于 pooling 的操作，太过简单。</p>
<p>如果度量标准仅查看一个参考字幕，那么为这种过度惩罚而寻找补救措施是一项挑战。</p>
</li>
<li><p><strong>bertscore</strong>—under penalize</p>
<p>由于在计算 bertscore 时，采用了贪婪搜索的方式，而且对于每个reference word, pick 一个最大值，这里有可能 没有candidate word 与 reference word相匹配，却给了一个高分。因此，导致 under-penalize</p>
</li>
<li><p><strong>分析</strong>： In one-to-one evaluation，尽管很难直接考虑所有reference，但可以使用来自预训练语言模型的上下文嵌入将references 合并为单个reference。</p>
</li>
</ul>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><ul>
<li><p>3.1  Preliminary concept of references<br>combination  </p>
</li>
<li><p>3.2 Mismatch detection with overlap and<br>cosine similarity  </p>
</li>
<li>3.3 The combination of references  </li>
<li>3.4 Importance of different words</li>
<li>3.5 Summary and metric formula   </li>
</ul>
]]></content>
      <categories>
        <category>图像描述</category>
        <category>评价指标</category>
      </categories>
      <tags>
        <tag>评价指标</tag>
      </tags>
  </entry>
  <entry>
    <title>Improving Translation Robustness with Visual Cues and Error Correction</title>
    <url>/2021/03/17/Improving-Translation-Robustness-with-Visual-Cues-and-Error-Correction/</url>
    <content><![CDATA[<h2 id="本文研究的任务"><a href="#本文研究的任务" class="headerlink" title="本文研究的任务"></a>本文研究的任务</h2><p>多模态机器翻译任务中对噪声样本的鲁棒性。</p>
<p>神经机器翻译模型对输入噪声很脆弱。当前的鲁棒性技术大多使模型<strong>适应</strong>现有的嘈杂文本，但是这些模型通常在<strong>遇到看不见的噪声</strong>时会失效，并且在clean  text 上的性能会下降（即相比于那些普通的模型，使用噪声样本来扩充数据的模型，其在clean text 上的性能会下降）。</p>
<h2 id="本文提出的点"><a href="#本文提出的点" class="headerlink" title="本文提出的点"></a>本文提出的点</h2><p>（1） 模型上：引入了<strong><em>视觉上下文</em></strong>的概念，以提高针对嘈杂文本的翻译鲁棒性。</p>
<p>（2）多任务：通过<strong>将纠错作为辅助任务</strong>来提出一种新的<strong><em>纠错训练</em>方案</strong>，以进一步提高鲁棒性。</p>
<p>实验证明，在 English-French and English-German 翻译任务上，（1）对于训练中遇到的噪声以及未遇到的噪声都有很好的鲁棒性。（2）同时保持了在 clean text 上的翻译质量。</p>
<h3 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h3><ul>
<li>不是重点来做 MMT model 的，略过</li>
</ul>
]]></content>
      <categories>
        <category>cross-modal</category>
        <category>image-guided MT</category>
      </categories>
      <tags>
        <tag>cross-modal,image-guided MT</tag>
      </tags>
  </entry>
  <entry>
    <title>[It’s Not Just Size That Matters] Small Language Models Are Also Few-Shot Learners</title>
    <url>/2021/03/20/It%E2%80%99s-Not-Just-Size-That-Matters-Small-Language-Models-Are-Also-Few-Shot-Learners/</url>
    <content><![CDATA[<p>转载：<a href="https://www.sohu.com/a/422484297_500659" target="_blank" rel="noopener">https://www.sohu.com/a/422484297_500659</a></p>
<p>显然，这标题对标的就是 GPT-3，于是笔者饶有兴趣地点进去看看是谁这么有勇气挑战 GPT-3，又是怎样的小模型能挑战 GPT-3？经过阅读，原来作者提出通过适当的构造， <strong>用 BERT 的 MLM 模型</strong>也可以做小样本学习，看完之后颇有一种“原来还可以这样做”的恍然大悟感。在此与大家分享一下。</p>
<h2 id="冉冉升起的MLM"><a href="#冉冉升起的MLM" class="headerlink" title="冉冉升起的MLM"></a><strong>冉冉升起的MLM</strong></h2><p>MLM，全称“Masked Language Model”，可以翻译为“掩码语言模型”，实际上就是一个完形填空任务，随机 Mask 掉文本中的某些字词，然后要模型去预测被 Mask 的字词，示意图如下：</p>
<p><img src="https://i.loli.net/2021/03/20/izGapk4S6ZRqgFI.png" alt="img" style="zoom:50%;"></p>
<p>▲ BERT的MLM模型简单示意图</p>
<p>其中被 Mask 掉的部分，可以是直接随机选择的 Token，也可以是随机选择连续的能组成一整个词的 Token，后者称为 WWM（Whole Word Masking）。</p>
<p>开始，MLM 仅被视为 BERT 的一个预训练任务，训练完了就可以扔掉的那种，因此有一些开源的模型干脆没保留 MLM 部分的权重，比如 brightmart 版 [3] 和 clue 版 [4] 的 RoBERTa，而哈工大开源的 RoBERTa-wwm-ext-large [5]则不知道出于什么原因随机初始化了 MLM 部分的权重，因此如果要复现本文后面的结果，这些版本是不可取的。</p>
<p>然而，随着研究的深入，研究人员发现不止 BERT 的 Encoder 很有用，预训练用的 MLM 本身也很有用。</p>
<p>比如论文 <strong>BERT has a Mouth, and It Must Speak: BERT as a Markov Random Field Language Model</strong>[6]指出 MLM 可以作为一般的生成模型用，论文 <strong>Spelling Error Correction with Soft-Masked BERT</strong>[7] 则将 MLM 用于文本纠错。</p>
<p>笔者之前在 的实验也表明 MLM 的预训练权重也可以当作 UniLM 来用做 Seq2Seq 任务，还有一文将 MLM 的思想用于无监督分词和句法分析了。可以说 MLM 已经是大放异彩了。</p>
<h2 id="将任务转成完形填空"><a href="#将任务转成完形填空" class="headerlink" title="将任务转成完形填空"></a><strong>将任务转成完形填空</strong></h2><p>在本文里，我们再学习 MLM 的一个精彩应用：用于小样本学习或半监督学习，某些场景下甚至能做到零样本学习。</p>
<p>怎么将我们要做的任务跟 MLM 结合起来呢？很简单， <strong>给任务一个文本描述，然后转换为完形填空问题</strong>即可。举个例子，假如给定句子“这趟北京之旅我感觉很不错。”，那么我们补充个描述，构建如下的完形填空：</p>
<blockquote>
<p> <strong>__</strong>满意。这趟北京之旅我感觉很不错。</p>
</blockquote>
<p>进一步地，我们限制空位处只能填一个“很”或“不”，问题就很清晰了，就是要我们根据上下文一致性判断是否满意，如果“很”的概率大于“不”的概率，说明是正面情感倾向，否则就是负面的，这样我们就将<strong>情感分类问题</strong>转换为一个完形填空问题了，它可以用 MLM 模型给出预测结果，而 MLM 模型的训练可以不需要监督数据，因此理论上这能够实现零样本学习了。</p>
<p><strong style="color:blue;">多分类问题</strong>也可以做类似转换，比如<strong>新闻主题分类</strong>，输入句子为“八个月了，终于又能在赛场上看到女排姑娘们了。”，那么就可以构建：</p>
<blockquote>
<p> 下面播报一则<strong>__</strong>新闻。八个月了，终于又能在赛场上看到女排姑娘们了。</p>
</blockquote>
<p>这样我们就将新闻主题分类也转换为完形填空问题了，一个好的 MLM 模型应当能预测出“体育”二字来。</p>
<p>还有一些<strong style="color:blue;">简单的推理任务</strong>也可以做这样的转换，常见的是给定两个句子<strong>，判断这两个句子是否相容</strong>，比如“我去了北京”跟“我去了上海”就是矛盾的，“我去了北京”跟“我在天安门广场”是相容的，常见的做法就是将两个句子拼接起来输入到模型做，作为一个二分类任务。如果要转换为完形填空，那该怎么构造呢？一种比较自然的构建方式是：</p>
<blockquote>
<p>我去了北京？<strong>__</strong>，我去了上海。</p>
<p>我去了北京？<strong>__</strong>，我在天安门广场。</p>
<p>其中空位之处的候选词为 是 的 不 是 。</p>
</blockquote>
<h2 id="Pattern-Exploiting-Training"><a href="#Pattern-Exploiting-Training" class="headerlink" title="Pattern-Exploiting Training"></a><strong>Pattern-Exploiting Training</strong></h2><p>读到这里，读者应该不难发现其中的规律了，就是给输入的文本增加一个前缀或者后缀描述，并且 Mask 掉某些 Token，转换为完形填空问题，这样的转换在原论文中称为 <strong>Pattern</strong>，这个转换要尽可能与原来的句子组成一句自然的话，不能过于生硬，因为预训练的 MLM 模型就是在自然语言上进行的。</p>
<p>显然同一个问题可以有很多不同的 Pattern，比如情感分类的例子，描述可以放最后，变成“这趟北京之旅我感觉很不错。<strong><strong>满意。”；也可以多加几个字，比如“觉得如何？</strong></strong>满意。这趟北京之旅我感觉很不错。”。</p>
<p>然后，我们需要构建预测 Token 的候选空间，并且建立 Token 到实际类别的映射，这在原论文中称为 <strong>Verbalizer</strong>，比如情感分类的例子，我们的候选空间是 很 不 ，映射关系是 很 正 面 不 负 面 ，候选空间与实际类别之间不一定是一一映射，比如我们还可以加入“挺”、“太”、“难”字，并且认为 很 挺 太 正 面 以 及 不 难 负 面 ，等等。</p>
<p>不难理解，不少 NLP 任务都有可能进行这种转换，但显然这种转换一般只适用于 <strong>候选空间有限</strong>的任务，说白了就是只用来做 <strong>选择题</strong>，常见任务的就是 <strong>文本分类</strong>。</p>
<p>刚才说了，同一个任务可以有多种不同的 Pattern，原论文是这样处理的：</p>
<ol>
<li><p>对于每种 Pattern，单独用训练集 Finetune一个 MLM 模型出来；</p>
</li>
<li><p>然后将不同 Pattern对应的模型进行集成，得到融合模型；</p>
</li>
<li><p>用融合模型预测未标注数据的伪标签；</p>
</li>
<li><p>用伪标签数据 Finetune 一个常规的（非 MLM 的）模型。</p>
</li>
</ol>
<p>具体的集成方式大家自己看论文就行，这不是重点。这种训练模式被称为 <strong>Pattern-Exploiting Training（PET）</strong>，它首先出现在论文 <strong>Exploiting Cloze Questions for Few Shot Text Classification and Natural Language Inference</strong>。</p>
<p><strong style="color:blue;">yaya: 与 这篇论文思想很类似：How Many Data Points is a PromptWorth? （arXiv: 2103.08493v1）</strong></p>
<p>本文要介绍的这篇论文则进一步肯定和完善了 Pattern-Exploiting Training 的价值和结果，并整合了多任务学习，使得它在 SuperGLUE 榜单上的小样本学习效果超过了 GPT3。两篇论文的作者是相同的，是一脉相承的作品。</p>
<p><img src="https://i.loli.net/2021/03/20/dOMZNLsKykIDioQ.png" alt="img"></p>
<p>▲ PET在SuperGLUE上的小样本学习的结果</p>
<p>不过要吐槽一个点是，上图中 PET 的 223M 参数，所用的模型是 ALBERT-xxlarge-v2，事实上称 ALBERT 为“小模型”是一种很耍流氓的行为，因为它前向计算的速度并没有得到任何提升。ALBERT-xxlarge 共有 12 层，层与层之间参数是共享的，就前向计算而言，它应该等价于约 2700M（12 倍）参数的 GPT 才对。</p>
<h2 id="中文实践，检验效果"><a href="#中文实践，检验效果" class="headerlink" title="中文实践，检验效果"></a><strong>中文实践，检验效果</strong></h2><p>要真正确认一个方法或模型的价值，看论文的实验表格是不够的，论文给出的实验结果谁都不好说能否复现，其次就算英文上能复现也不代表中文上有价值，因此最实际的还是亲自动手做实验验证。下面是笔者的实验代码，供读者参考：</p>
<p>Github 地址：</p>
<p><a href="https://github.com/bojone/Pattern-Exploiting-Training" target="_blank" rel="noopener">https://github.com/bojone/Pattern-Exploiting-Training</a></p>
<p>我们将从以下几个角度来探讨 PET 的可行性：</p>
<p>\1. 直接利用现成的 MLM 模型效果如何？ <strong>（零样本学习1）</strong></p>
<p>\2. 用“大量无标签数据”微调现成的 MLM 模型效果如何？ <strong>（零样本学习2）</strong></p>
<p>\3. 用“小量标签数据”微调现成的 MLM 模型效果如何？ <strong>（小样本学习）</strong></p>
<p>\4. 用“小量标签数据+大量无标签数据”微调现成的MLM模型效果如何？ <strong>（半监督学习）</strong></p>
<p>下面主要给出 <strong>情感二分类</strong>的实验结果。另外还有一个新闻主题的多分类，代码也放到 Github 了，其结果是类似的，就不重复陈述了。</p>
<h3 id="4-1-零样本学习1"><a href="#4-1-零样本学习1" class="headerlink" title="4.1 零样本学习1"></a><strong>4.1 零样本学习1</strong></h3><p>这里主要探索的是给输入文本补上对应的 Pattern 后，直接基于现成的 MLM 模型进行预测，预测的准确率。由于构建模型的整个过程都不涉及到标签数据监督训练，因此这算是一种“零样本学习”。我们需要比较的是不同 Pattern、不同 MLM 模型上的效果：</p>
<p>下面是实验的几个 Pattern，其中空位处候选词语都为“很”和“不”：</p>
<p>P1：____满意。这趟北京之旅我感觉很不错。</p>
<p>P2：这趟北京之旅我感觉很不错。____满意。</p>
<p>P3：____好。这趟北京之旅我感觉很不错。</p>
<p>P4：____理想。这趟北京之旅我感觉很不错。</p>
<p>P5：感觉如何？____满意。这趟北京之旅我感觉很不错。</p>
<p>至于 MLM 模型，则是下面几个：</p>
<p>M1：Google 开源的中文版 BERT Base：</p>
<p><a href="https://github.com/google-research/bert" target="_blank" rel="noopener">https://github.com/google-research/bert</a></p>
<p>M2：哈工大开源的 RoBERTa-wwm-ext Base：</p>
<p><a href="https://github.com/ymcui/Chinese-BERT-wwm" target="_blank" rel="noopener">https://github.com/ymcui/Chinese-BERT-wwm</a></p>
<p>M3：腾讯 UER 开源的 BERT Base：</p>
<p><a href="https://share.weiyun.com/5QOzPqq" target="_blank" rel="noopener">https://share.weiyun.com/5QOzPqq</a></p>
<p>M4：腾讯 UER 开源的 BERT Large：</p>
<p><a href="https://share.weiyun.com/5G90sMJ" target="_blank" rel="noopener">https://share.weiyun.com/5G90sMJ</a></p>
<p>实验结果如下表（验证集/测试集）：</p>
<p><img src="https://i.loli.net/2021/03/20/8Yg2qH5CXoFPkcx.png" alt="img"></p>
<p>可以观察到，不同的 Pattern、不同的预训练模型之间还是有一定的差异的，整体而言 Large 版本的效果要明显好于 Base 版本的模型，说明像 GPT 到 GPT2 再到 GPT3 一样，还是把模型做得更大会更好。</p>
<p>此外，这还有可能说明实际上 MLM 还没有被充分训练好，或许是因为 BERT 这种 Mask 掉一部分的训练方式过于低效了，可能用 修改 Transformer 结构，设计一个更快更好的 MLM 模型 一文提到的改进版 MLM 会更好。</p>
<h3 id="4-2-零样本学习2"><a href="#4-2-零样本学习2" class="headerlink" title="4.2 零样本学习2"></a><strong>4.2 零样本学习2</strong></h3><p>看完上述结果，读者可能会想到：如果我用领域内的数据继续预训练 MLM 模型，那么能不能提升效果呢？答案是：能！下面是我们的实验结果，算力有限，我们只在 RoBERTa-wwm-ext（上述的 M2，继续预训练后的模型我们称为 M2+ 无监督）的基础上做了比较：</p>
<p><img src="https://i.loli.net/2021/03/20/Y8CdHbW1cjqByrD.png" alt="img"></p>
<p>要注意的是，这里我们只是用领域内的数据继续做 MLM 训练，这个过程是无监督的，也不需要标注信号，因此也算是“零样本学习”。同时，从到目前为止的结果我们可以看出，给输入本文加入“前缀”的效果比“后缀”更有优势一些。</p>
<h3 id="4-3-小样本学习"><a href="#4-3-小样本学习" class="headerlink" title="4.3 小样本学习"></a><strong>4.3 小样本学习</strong></h3><p>刚才我们讨论了无标签数据继续预训练 MLM 的提升，如果回到 PET 的目标场景，直接用小量的标签数据配合特定的 Pattern 训练 MLM 又如何呢？</p>
<p>这也就是真正的“小样本学习”训练了，这里我们保留约 200 个标注样本，构造样本的时候，我们先给每个句子补上 Pattern，除了 Pattern 自带的 Mask 位置之外，我们还随机 Mask 其他一部分，以增强对模型的正则。最终实验结果如下：</p>
<p><img src="https://i.loli.net/2021/03/20/qVFgDbyLQrXpZUt.png" alt="img"></p>
<p>结论就是除了“后缀式”的 P2 之外，其它结果都差不多，这进一步说明了“前缀式”的 Pattern 会比“后缀式”更有竞争力一些。在效果上，直接用同样的数据用常规的方法去微调一个 BERT 模型，大概的结果是 88.93 左右，所以基于 “MLP+Pattern” 的小样本学习方法可能带来轻微的性能提升。</p>
<h3 id="4-4-半监督学习"><a href="#4-4-半监督学习" class="headerlink" title="4.4 半监督学习"></a><strong>4.4 半监督学习</strong></h3><p>无监督的零样本学习和有监督的小样本学习都说完了，自然就轮到把标注数据和非标注数据都结合起来的“半监督学习”了。还是同样的任务，标注数据和非标注数据的比例大约是 1:99，标注数据带 Pattern，非标注数据不带 Pattern，大家都 Mask 掉一部分 Token 进行 MLM 预训练，最终测出来的效果如下：</p>
<p><img src="https://i.loli.net/2021/03/20/4QKcUYDtgAmeGqM.png" alt="img"></p>
<p>还是同样的，“后缀”明显比“前缀”差，“前缀”的效果差不多。具体效果上，则是肯定了额外的无标注数据也是有作用的。</p>
<p>直觉上来看，“前缀”比“后缀”要好，大体上是因为“前缀”的 Mask 位置比较固定，微弱的监督信号得以叠加增强？但这也不能解释为什么零样本学习的情况下也是“前缀”更好，估计还跟模型的学习难度有关系，可能句子前面部分的规律更加明显，相对来说更加容易学一些，所以前面部分就学习得更加充分？这一切都还只是猜测。</p>
<h3 id="4-5-汇总与结论"><a href="#4-5-汇总与结论" class="headerlink" title="4.5 汇总与结论"></a><strong>4.5 汇总与结论</strong></h3><p>将上述结果汇总如下：</p>
<p><img src="https://i.loli.net/2021/03/20/cpGqLZ2twR5z4di.png" alt="img"></p>
<p>读者还可以对比我们之前在文章 泛化性乱弹：从随机噪声、梯度惩罚到虚拟对抗训练 中用虚拟对抗训练（VAT）做半监督学习的结果，可以看到不管是零样本学习、小样本学习还是半监督学习，基于 MLM 模型的方式都能媲美基于 VAT 的半监督学习的结果。</p>
<p>我们在做短新闻多分类实验时的结果也是相似的。因此，这说明了 MLM 模型确实也可以作为一个优秀的零样本/小样本/半监督学习器来使用。</p>
<p>当然，基于 MLM 模型的缺点还是有的，比如 MLM 所使用的独立假设限制了它对更长文本的预测能力（说白了空位处的文字不能太长），以及无法预测不定长的答案也约束了它的场景（所以当前只能用于做选择题）。我们期待有更强的 MLM 模型出现，那时候就有可能在所有任务上都能与 GPT3 一较高下了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文介绍了 BERT 的 MLM 模型的一个新颖应用：配合特定的描述将任务转化为完形填空，利用 MLM 模型做零样本学习、小样本学习和半监督学习。</p>
<p>在原论文的 SuperGLUE 实验里边，它能达到媲美 GPT3 的效果，而笔者也在中文任务上做了一些实验，进一步肯定了该思路的有效性。整个思路颇为别致，给人一种“原来还可以这样做”的恍然大悟感，推荐大家学习一下。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://arxiv.org/abs/2005.14165" target="_blank" rel="noopener">https://arxiv.org/abs/2005.14165</a></p>
<p>[2] <a href="https://arxiv.org/abs/2009.07118" target="_blank" rel="noopener">https://arxiv.org/abs/2009.07118</a></p>
<p>[3] <a href="https://github.com/brightmart/roberta_zh" target="_blank" rel="noopener">https://github.com/brightmart/roberta_zh</a></p>
<p>[4] <a href="https://github.com/CLUEbenchmark/CLUEPretrainedModels" target="_blank" rel="noopener">https://github.com/CLUEbenchmark/CLUEPretrainedModels</a></p>
<p>[5] <a href="https://github.com/ymcui/Chinese-BERT-wwm" target="_blank" rel="noopener">https://github.com/ymcui/Chinese-BERT-wwm</a></p>
<p>[6] <a href="https://arxiv.org/abs/1902.04094" target="_blank" rel="noopener">https://arxiv.org/abs/1902.04094</a></p>
<p>[7] <a href="https://kexue.fm/archives/7661" target="_blank" rel="noopener">https://kexue.fm/archives/7661</a></p>
<p>[8] <a href="https://arxiv.org/abs/2001.07676" target="_blank" rel="noopener">https://arxiv.org/abs/2001.07676</a></p>
<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><p>不懂的问题：</p>
<ul>
<li><p>mask 一个 Span, 多个空位然后逐词预测？？</p>
</li>
<li><p>在 [MASK] 位置 预测空间是多大？整个vocabulary ??</p>
</li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
        <category>few-shot</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>few-shot</tag>
      </tags>
  </entry>
  <entry>
    <title>Improving Image Captioning with Conditional Generative Adversarial Nets</title>
    <url>/2020/07/31/Improving-Image-Captioning-with-Conditional-Generative-Adversarial-Nets/</url>
    <content><![CDATA[<p>From:  <a href="https://zhuanlan.zhihu.com/p/39890390" target="_blank" rel="noopener">GAN in Image Captioning</a></p>
<h3 id="Improving-Image-Captioning-with-Conditional-Generative-Adversarial-Nets"><a href="#Improving-Image-Captioning-with-Conditional-Generative-Adversarial-Nets" class="headerlink" title="Improving Image Captioning with Conditional Generative Adversarial Nets"></a><strong>Improving Image Captioning with Conditional Generative Adversarial Nets</strong></h3><h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><p>本文提出了一种新的基于条件生成对抗网络的图像字幕框架，作为传统的基于增强学习(RL)的编解码结构的扩展。为了应对不同的目标语言的指标之间不一致的评价问题，，论文设计了两种鉴别器网络来自动地、逐步地确定生成的描述是人工描述的还是机器生成的。</p>
<p>生成器是采用传统图像描述的模型，<strong>在强化学习自我批判算法（SCST）下进行优化</strong>。</p>
<p>由于基于CNN和RNN的结构各有其优点，因此引入了两种鉴别器结构。</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gha02tza7dj31im0hvtk0.jpg"></p>
<h4 id="CNN-discriminator："><a href="#CNN-discriminator：" class="headerlink" title="CNN discriminator："></a><strong>CNN discriminator：</strong></h4><p>（1）首先创建了一个feature map,编码了图像与句子特征。</p>
<p>（2）接着采用了m组有不同窗大小，核数目的卷积核来获取不同的特征，</p>
<p>（3）然后把所有特征作max pooling操作再联结在一起，并用一个highway架构提升性能。</p>
<p>（4）最后激活特征通过全连接层与sigmoid 转换来获得决策器的输出。输出在[0,1]之间。</p>
<h4 id="RNN-discriminator："><a href="#RNN-discriminator：" class="headerlink" title="RNN discriminator："></a><strong>RNN discriminator：</strong></h4><p>基于RNN的决策器采用了一种标准的LSTM架构，把图像特征输入到第一个LSTM，接下来输入的LSTM是输入是单词编码信息。最后通过全连接层与softmax层获得RNN决策器的输出。</p>
<h4 id="固定G，更新D："><a href="#固定G，更新D：" class="headerlink" title="固定G，更新D："></a>固定G，更新D：</h4><p>Discriminator的目标函数为：</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gha04mt3u7j31m4070tal.jpg"></p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gha02tyrdqj31j50kxdv1.jpg"></p>
<h4 id="固定D，更新G"><a href="#固定D，更新G" class="headerlink" title="固定D，更新G"></a>固定D，更新G</h4><p>设计reward，以强化学习来更新generator。</p>
<p>在强化学习的设定下，本文采用GAN与RL结合的reward来权衡<strong style="color:red;">图像描述的保真度</strong>（在评价标准下获得高得分）与<strong style="color:red;">自然性</strong>（生成描述符合人类的风格）。</p>
<blockquote>
<p><strong style="color:blue;">这也是本文主要的创新点，结合 保真度 的评价</strong></p>
</blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gha06jgm6tj31e409cmz3.jpg" style="zoom: 50%;"></p>
<h4 id="整个算法的伪代码如下："><a href="#整个算法的伪代码如下：" class="headerlink" title="整个算法的伪代码如下："></a>整个算法的伪代码如下：</h4><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gha09ceqgkj30ns0wg13f.jpg" style="zoom: 50%;"></p>
<h3 id="GAN-image-captioning-task"><a href="#GAN-image-captioning-task" class="headerlink" title="GAN + image captioning task"></a>GAN + image captioning task</h3><p><strong>[1703.06029] Towards Diverse and Natural Image Descriptions via a Conditional GAN</strong></p>
<p><strong>[1703.10476] Speaking the Same Language Matching Machine to Human Captions by Adversarial Training</strong></p>
<p><strong>[1705.00930] Show, Adapt and Tell Adversarial Training of Cross-domain Image Captioner</strong></p>
<p><strong>[1805.00063] Improved Image Captioning with Adversarial Semantic Alignment</strong></p>
<p><strong>[1804.00861] Generating Diverse and Accurate Visual Captions by Comparative Adversarial Learning</strong></p>
]]></content>
      <categories>
        <category>图像描述</category>
        <category>GAN</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>Instructions</title>
    <url>/2020/06/20/Instructions/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>(LSTM-E)Jointly Modeling Embedding and Translation to Bridge Video and Language</title>
    <url>/2019/02/22/LSTM-E-Jointly-Modeling-Embedding-and-Translation-to-Bridge-Video-and-Language/</url>
    <content><![CDATA[<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><p>本文的主要贡献：</p>
<ol>
<li>同时使用了action feature of C3D and frames features。但是由于对C3D的特征也采用了mean pooling的方法，有缺陷，对action 特征的一种破坏。</li>
<li>提出了relevance loss ， 来加强整个句子的语义与视觉特征之间的关系。  </li>
</ol>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>目前存在的方法，依据给定的先前的单词以及视觉信息，来生成words，但是并没有利用句子语义与视觉内容之间的关系，导致生成的句子可能上下文是正确的，但是语义是错误的。<br>如 figure1，LSTM model 生成的句子是a man is riding a horse，逻辑上是没有错误的，但是语义却错了，图中出现的是woman 而不是man。<br>　　<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0f0qr6d2ij30lq0biq8s.jpg" width="500" hegiht="313" align="center"></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>  简单介绍LSTM-E：LSTM-E可以同时利用LSTM学习和视觉-语义embedding。LSTM 学习是为了在给定先前的单词以及视觉特征的基础上，最大化生成下一个单词的概率，后者是为了生成视觉-语义embedding，来加强整个句子的语义与视觉特征之间的关系。<br>  <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0f87gorc9j316d0kr11m.jpg" title="overview">  </p>
<ul>
<li><strong>Overview</strong><br>2D/3D 卷积神经网络被用来提取视频frames/clips的特征，平均池化来得到视频的特征。<br>基于视频特征<strong><em>v</em></strong>和句子语义<strong><em>s</em></strong>，生成sentences的<strong>LSTM model</strong> 和<strong>视觉-语义embeddeing model</strong> 联合学习。</li>
<li><strong>The sprit of LSTM-E</strong><br>在coherence和relevance之间的相互增强下来生成sentences。<strong><em>coherence:</em></strong>表达了生成words与视频内容之间的相关关系，由LSTM优化完成。<strong><em>relevance:</em></strong>整个句子的语义与视频内容之间的关系，由视觉-语义embeddeing model来度量。通过联合学习coherence和relevance，期望生成的句子在语境和语义上是正确的。</li>
<li><strong>说人话</strong><br>由两个model组成，一个是sequence learning 都有的coherence loss ，来最大化生成next word的似然概率；另一个是本文添加的relevance loss，通过优化视频特征与生成句子之间的差距，使得生成的句子语义上能对应video的内容。即同时考虑了句子单词之间的上下文关系，也考虑了句子语义与视频内容之间的关系。</li>
<li><strong>contribution</strong><br>提出了relevance loss !  </li>
</ul>
<h2 id="Video-Description-with-Relevance-and-Coherence"><a href="#Video-Description-with-Relevance-and-Coherence" class="headerlink" title="Video Description with Relevance and Coherence"></a>Video Description with Relevance and Coherence</h2><ul>
<li><strong>Visual-Semantic Embedding: Relevance</strong><br><strong><em>v</em></strong> 和 <strong><em>s</em></strong> 分别是视频的特征和sentences的特征（即，都是已知的），Ts和Tv用来降维到相同的维度，为了度量视频内容与句子语义之间的相关性，一个自然地方法是计算embedding之间的距离，因此定义relevance loss:<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0f8zoni8tj30bc01pmx2.jpg" 　style="zoom:45%"></li>
<li><strong>Translation by Sequence Learning: Coherence</strong><br>coherence loss：即为在给定视频特征的条件下，生成sentences的最大似然概率。<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0f9l8bbvoj30ph02pglq.jpg" style="zoom:50%"><br>由overview的图可知，在实际的情况下LSTM的输入是：第一个LSTM输入是视频特征，其余的是前一个time step 生成的单词（在train时：是caption中给定的第t个单词，在test时：是前一个time step 生成的单词）。因此似然函数可以具体的表示为：  　　<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0f9lgy6nfj317806fgm5.jpg" style="zoom:40%"></li>
</ul>
<h2 id="Joint-Modeling-Embedding-and-Translation"><a href="#Joint-Modeling-Embedding-and-Translation" class="headerlink" title="Joint Modeling Embedding and Translation"></a>Joint Modeling Embedding and Translation</h2><ul>
<li><strong>simultaneously minimizing the relevance loss and coherence loss.</strong><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0fa1y3nkgj30nu05pq3p.jpg" style="zoom:70%"></li>
<li><p><strong>LSTM结构 </strong><br>这里有多种方式来结合visual content 和 word of last time step。法一：each time step 都输入视频特征；法二：只在第一步输入视频特征。但是在[ 1 ]中指出，由于网络可以显式地利用噪声和更容易覆盖，所以每次输入图像都会产生劣质的效果。 因此，采用第二种方法，在给定视频特征v 和相对应的 sentence W ≡ [w0, w1, …, wNs]，LSTM的更新步骤如下：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0fcc8tiqej30z708l0t3.jpg"><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0faic2fuzj30n508njs2.jpg" style="width: 50%; height: 50%"><br>在初始的第一步，视频特征作为LSTM的输入；在第二步，&lt;#start#&gt;开始的标志作为LSTM的输入，同时接受上一步的hidden state, cell state，以后每一步，都将上一步生成的word 作为输入，直至生成&lt;#end#&gt;。<br>从第二步开始，使用LSTM cell 的hidden state 来预测 word( 对于LSTM output 与 hidden[0] 是一样的，参考：<a href="https://mp.csdn.net/postedit/87516958" target="_blank" rel="noopener">https://mp.csdn.net/postedit/87516958</a>)</p>
<blockquote>
<p><code>output, hidden = self.rnn(input, hidden)</code></p>
</blockquote>
</li>
</ul>
<h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><ul>
<li><strong>dataset</strong><br>MSVD:<br>Microsoft Research Video Description Corpus (YouTube2Text) , which contains 1,970 YouTube snippets. There are roughly 40 available English descriptions per video. In our experiments, we follow the setting used in prior works, taking 1,200 videos for training, 100 for validation and 670 for testing.</li>
<li><strong>result</strong><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0fcs7kt8cj31ap0bhgow.jpg"></li>
<li><strong>The effect of hidden layer size</strong><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0fcvqbzvsj30qz09x760.jpg" style="width: 70%; height: 70%">  </li>
</ul>
<h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>a visual-semantic embedding space is additionally incorporated into LSTM learning. In this way, <strong>a global relationship between the video content and sentence semantics</strong> is simultaneously measured in addition to <strong>the local contextual relationship between the word at each step and the previous ones</strong> in LSTM learning. On the popular YouTube2Text dataset, the results of our experiments demonstrate the success of our approach, outperforming the current state-ofthe-art models </p>
<h2 id="Future-Work"><a href="#Future-Work" class="headerlink" title="Future Work"></a>Future Work</h2><p>视频作为一个时域序列，未来将会探究使用RNN来获得更好的特征；另外，如果有更大的数据集，更多的video sentences pairs ，那么可以使用更深的RNN，来得到更好的视频描述</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] O. Vinyals, A. Toshev, S. Bengio, and D. Erhan. Show and tell: A neural image caption generator. In CVPR, 2015.</p>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>(LSTM_TSA)Video Captioning with Transferred Semantic Attributes</title>
    <url>/2019/03/03/LSTM-TSA-Video-Captioning-with-Transferred-Semantic-Attributes/</url>
    <content><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>在这篇文章中，我们提出了一个 Long Short-Term Memory with Transferred Semantic Attributes （LSTM-TSA）model，这是一个新颖的结构，可以将从images 和 videos 中学习到的transferred semantic attributes  结合到 encoder - decoder 结构中去。</p>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>Learning to Compose Topic-Aware Mixture of Experts for Zero-Shot Video Captioning</title>
    <url>/2020/09/15/Learning-to-Compose-Topic-Aware-Mixture-of-Experts-for-Zero-Shot-Video-Captioning/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>Learning Video Representations from Correspondence Proposals</title>
    <url>/2019/07/26/Learning-Video-Representations-from-Correspondence-Proposals/</url>
    <content><![CDATA[<h3 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h3><ul>
<li>与Non-local 类似，都是在现有CNN（2D， 3D）模型中加入一个设计的模块</li>
</ul>
<h3 id="CPNet-介绍"><a href="#CPNet-介绍" class="headerlink" title="CPNet 介绍"></a>CPNet 介绍</h3><p>（1）在CNN的某一层，得到了<code>T*H*W*d</code>的特征，这<code>T*H*W</code>个特征，是经过conv来的，即一个特征，返回到原图对应的是一个块（区域）的特征。   </p>
<p>（2）类似于graph 中的邻接矩阵的操作，计算这个<code>T*H*W</code>个节点之间的相似性，相似性近的前K个（且不在同一帧），认为他们之间存在对应关系，即找到了一个区域对应到其他帧的对应区域。   </p>
<p>（3）将原区域，与对应区域的特征，与他们之间的位置关系，输入到MLP中，得到了一个更新的特征。对每个对应区域都采取这样的操作，得到K个特征。取max，得到了一个鲁棒的特征（可以去掉不是对应块区域的特征，即去掉噪声）。   </p>
<p><img src="https://i.loli.net/2019/07/26/5d3a7afee6b0178187.png" alt="搜狗截图20190726120054.png" title="搜狗截图20190726120054.png"></p>
<ul>
<li>是不是跟Non-Local很像，==CP Module就是融合了相似区域的特征，对原区域的特征进行更新。==</li>
</ul>
<h3 id="Non-local-vs-CPNet"><a href="#Non-local-vs-CPNet" class="headerlink" title="Non-local  vs   CPNet"></a>Non-local  vs   CPNet</h3><ul>
<li><p>在toy dataset （figure4）上设计了toy model（两层 CNN）,将现有的三个SOTA model以及自己设计的CPNet上进行试验</p>
</li>
<li><p>可以看到 I3D，ARTNet ，TRN三个模型的效果都不是很好</p>
</li>
<li>ARTNet ，TRN 是由于只使用了两个卷积层，不能捕捉长范围的运动信息</li>
<li>Non-local 可以捕捉长范围的运动信息，但是为什么效果还是不好：==NL block 没有加进去位置信息==（作者这么说的原因，就是因为在他们的CP module中有position information）</li>
</ul>
<p><img src="https://i.loli.net/2019/07/26/5d3a6c44659ae30922.png" alt="搜狗截图20190726102546.png" title="搜狗截图20190726102546.png"></p>
<h3 id="CPNet-可以退化成这三个model-没看懂-之后可以结合代码再深入分析"><a href="#CPNet-可以退化成这三个model-没看懂-之后可以结合代码再深入分析" class="headerlink" title="CPNet 可以退化成这三个model: ( 没看懂 ,之后可以结合代码再深入分析)"></a>CPNet 可以退化成这三个model: ( 没看懂 ,之后可以结合代码再深入分析)</h3><p><img src="https://i.loli.net/2019/07/26/5d3a889e2ce0b69830.png" alt="搜狗截图20190726125811.png" title="搜狗截图20190726125811.png"></p>
]]></content>
      <categories>
        <category>行为识别</category>
      </categories>
      <tags>
        <tag>行为识别</tag>
      </tags>
  </entry>
  <entry>
    <title>Large-Scale Zero-Shot Image Classification from Rich and Diverse Textual Descriptions</title>
    <url>/2021/03/22/Large-Scale-Zero-Shot-Image-Classification-from-Rich-and-Diverse-Textual-Descriptions/</url>
    <content><![CDATA[<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><ul>
<li><p>【目前常用的benchmark都比较小，且常常使用手工标注的类别属性作为补充数据。但是这种类型的补充数据，由于是手工标注的因此很难扩展到大规模数据集上（eg: ImageNet）。因此，目前在ImageNet 这样的大规模数据集上的零样本学习性能比较差】</p>
<p>ZSL benchmarks mostly cover either a very <strong>small</strong> or narrow set of classes, where <strong>human-made class attributes</strong> are often used as auxiliary data. Unfortunately, on ImageNet, where such attributes are not available, the performance is still very low.</p>
</li>
<li><p>【小规模数据集提供的类别有限，有可能训练集，测试集都是动物类别，无法评估模型在一个新颖类别上的性能，比如汽车。因此对于零样本学习任务，有必要发展一个大规模的数据集】</p>
<p>The large-scale setup enables us to study the main challenges of a more realistic and practical zero-shot image classification scenario and study the generalization of models to novel groups of classes (e.g., animal species in general), not only  individual classes (e.g., specific animal species).</p>
</li>
</ul>
<h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><ul>
<li><p>不对算法进行改进，而是研究 补充数据类型（auxiliary data type）对性能的影响。为 ImageNet class 收集对应的 wikipedia article，作为text descriptions。本文是第一个在大规模数据集上使用文本描述的。</p>
</li>
<li><p>在 ImageNet mp500 测试集上，使用本文提供的wikipedia文本描述作为补充数据，性能上取得了很大的提高，比以往的方法都好。</p>
</li>
<li>以前的小数据集受到类别有限的限制，无法评估在新颖类别上的泛化性。在本文提出的数据集上，证明了当前的ZSL model 的泛化性是比较差的。</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>Image Classification</category>
      </categories>
      <tags>
        <tag>Image Classification</tag>
      </tags>
  </entry>
  <entry>
    <title>Learning to Contrast the Counterfactual Samples for Robust Visual Question Answering</title>
    <url>/2021/03/12/Learning-to-Contrast-the-Counterfactual-Samples-for-Robust-Visual-Question-Answering/</url>
    <content><![CDATA[<p>转自：<a href="https://blog.csdn.net/weixin_45347379/article/details/112182143" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45347379/article/details/112182143</a></p>
<p>学习对比反事实样本，以实现稳健的视觉问答<br>Learning to Contrast the Counterfactual Samples for Robust Visual Question Answering<br>在阅读本文之前，一定要阅读论文：Counterfactual Samples Synthesizing for Robust Visual Question Answering（简称CSS）</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><img src="https://i.loli.net/2021/03/12/gODk8QFCNWaUsVP.png" alt="image-20210312175656070"></p>
<p>文章的方法主要包括三个部分：（1）一个基本的VQA模型。（2）一个事实和反事实样本合成（CSS）模块。（3）一个对比学习（CL）目标。</p>
<h4 id="第一部分和第二部分"><a href="#第一部分和第二部分" class="headerlink" title="第一部分和第二部分"></a><strong>第一部分和第二部分</strong></h4><p>属于CSS已经实现的，主要作用在于：</p>
<p>（1）并通过多分类的方法预测答案，并产生图中右上方基本VQAloss。</p>
<p><img src="https://i.loli.net/2021/03/12/z3Q52bActwqMhov.png" alt="在这里插入图片描述"></p>
<p>（2）得到（I, I+, I-）和（Q, Q+, Q-），</p>
<p><img src="https://i.loli.net/2021/03/12/din9DctNLV1EORo.png" alt="在这里插入图片描述"></p>
<h4 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a><strong>第三部分</strong></h4><p>以（I, I+, I-）为例，将（I, I+, I-）和Q喂给VQA模型，分别产生原始样本的嵌入mm（V, Q）作为anchor（a），事实样本的嵌入mm(V+, Q)作为positive（p），反事实样本嵌入mm(V-, Q)作为negati（n）<br>利用余弦相似度作为评分函数，对正样本输出高值，对负样本输出低值，公式如下：</p>
<p><img src="https://i.loli.net/2021/03/12/XIjKWu7szqi3A4w.png" alt="在这里插入图片描述"></p>
<p>同样的方法得到anchor和negative之间的评分s(a, n), 这就相当于图中展示的，拉近原始图像与事实区域图像的关系，推远原始图像与反事实区域的距离。<br>对比损失定义为：（这就是图片下方得到的Contrastive loss）</p>
<p><img src="https://i.loli.net/2021/03/12/CY4OJ7PZmD9Eaud.png" alt="在这里插入图片描述"></p>
<p>最后，这种对比损失与基础分类损失的加权总和弥补了整体损失：</p>
<p><img src="https://i.loli.net/2021/03/12/8GL3BxlSEpAg951.png" alt="在这里插入图片描述"></p>
<p>虽然文章说，<strong style="color:red;">这种方法能够使模型学习他们之间的关系，并从更有因果关系的方面预测正确答案。</strong>但是，个人感觉如果仅仅使以上方法，并不能从理论上提高模型的能力。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><img src="https://i.loli.net/2021/03/12/wAmbOSxRU97dN12.png" alt="在这里插入图片描述"></p>
<h3 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h3><ul>
<li>看了本文博客之后，没有看原文，个人任务这种方法有限，</li>
<li>可能模型的设计上，是有新意的，使用对比学习来增强VQA模型的性能，但是往往自己做的时候会收效甚微</li>
</ul>
]]></content>
      <categories>
        <category>cross-modal</category>
        <category>VQA</category>
      </categories>
      <tags>
        <tag>cross-modal,VQA</tag>
      </tags>
  </entry>
  <entry>
    <title>Learning to Evaluate Image Captioning</title>
    <url>/2020/05/09/Learning-to-Evaluate-Image-Captioning/</url>
    <content><![CDATA[<h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><p>本文提出一个可学习的图像描述评价指标。</p>
<p><strong>Motivation</strong>: 由于当前的评价指标不是很完美，不能处理句子中存在的所有的病理行为，或者是说，当遇到某些病理行为时，则不能正常工作，比如，SPICE对字幕的语义很敏感，但往往会忽略其句法质量，SPICE倾向于对带有重复子句的长句子给予高分。每个评估指标都有其众所周知的盲点，基于规则的指标通常不灵活，无法应对新的病理病例。</p>
<p>因此本文提出，使用几种数据增强的方式，来扩展出很多的存在特征几种病理问题的对抗样本，并纳入训练过程中，使得训练出来的评价指标对于这些对抗样本更加的鲁棒。（即，可以识别出这些对抗样本的能力）</p>
<h4 id="How-to-Use-the-Proposed-Metric-in-Practice"><a href="#How-to-Use-the-Proposed-Metric-in-Practice" class="headerlink" title="How to Use the Proposed Metric in Practice"></a>How to Use the Proposed Metric in Practice</h4><p>由于涉及到需要学习 ，则评价指标的训练的数据分布 与 被测试的captioning dataset 之间存在差异。</p>
<p>本文解决: 假设要评估 coco  <strong>test</strong> captioning, 则将该份submission 分成两半，一半用于scratch 训练该评价指标，另外一半则使用该训练好的评价指标得到得分；然后交替，则得到了所有的得分！</p>
<h4 id="Future-Work"><a href="#Future-Work" class="headerlink" title="Future Work"></a>Future Work</h4><ul>
<li>(1) One direction of future work could aim to capture the heterogeneous nature of human annotated captions and incorporate such information into captioning evaluation.  <strong>Human annotated captions 带有人的个性</strong></li>
<li>(2) Another direction for future work could be training a caption generator together with the proposed evaluation metric (discriminator) in a generative adversarial setting. <strong>captioning model 与提出的评价指标，一起生成对抗的训练</strong></li>
<li>(3) Finally, gameability is definitely a concern, not only for our learning based metric, but also for other rule-based metrics. Learning to be more robust to adversarial examples is also a future direction of learning based evaluation metrics.  <strong>对 对抗样本更加的鲁棒，是基于学习的评价指标的一个未来的方向</strong></li>
</ul>
]]></content>
      <categories>
        <category>图像描述</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>[Less is More] CLIPBERT for Video-and-Language Learning via Sparse Sampling</title>
    <url>/2021/03/18/Less-is-More-CLIPBERT-for-Video-and-Language-Learning-via-Sparse-Sampling/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>cross-modal</category>
        <category>end-to-end</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
        <tag>end-to-end</tag>
      </tags>
  </entry>
  <entry>
    <title>Learning to Generate Grounded Visual Captions without Localization Supervision</title>
    <url>/2019/12/01/Learning-to-Generate-Grounded-Visual-Captions-without-Localization-Supervision/</url>
    <content><![CDATA[<h3 id="ICLR-2020-under-view"><a href="#ICLR-2020-under-view" class="headerlink" title="ICLR 2020 under view"></a>ICLR 2020 under view</h3><h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><ul>
<li><p>问题：在captioning 任务中，当前的评价指标并不能很好的反应生成的句子与该视频之间的契合度（Groud），有可能生成的句子只是基于在训练过程中学习到的priors（一种统计特性，而不是基于该视频本身）</p>
</li>
<li><p>当前模型对于 groud 这个任务，存在的困难：（1）由于当前的 language model 常使用 attention 机制来关注某一个 region，以此来预测下一个生成的单词。换句话说，就是在不知道将会生成什么单词的情况下，却要先定位region， 另外，一篇论文 [1] 提出，attention机制关注的region与人类所关注的并不一致（2）更难的是：传入 attention网络的是 RNN 的 hidden_state，由于 RNN 的记录历史的特性，这个输入包括的是过去所有的信息，而不是针对于某一个individual word。  </p>
</li>
</ul>
<h3 id="Contributions"><a href="#Contributions" class="headerlink" title="Contributions"></a>Contributions</h3><ul>
<li>不同于 GVD，该文不使用 annotation bbox 作为监督信号，而是使用了 decoder + localizer + redecoder的结构来自我监督（self-supervision）</li>
<li>由于其自监督的特性，在一些infrequent word上该文的方法比监督的方法，效果更好</li>
<li>不仅使用一般的为每个 object class 计算 grounding accuracy， 还提出了一个新的指标：为每个sentence 计算grounding accuracy。</li>
</ul>
<h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><ul>
<li><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g9heo6n8glj318k0lp0ze.jpg" alt="搜狗截图20191201183637.png"></p>
</li>
<li><p><strong>分阶段训练</strong></p>
</li>
<li>（1）正常的 encoder-decoder先训练 ~30个epoch</li>
<li>（2）在正常的基础上进行添加。 （a）<strong>re-localize</strong>: language_lstm 会得到y1, y2, …, yT 个预测的序列，将这些序列作为attention机制中的 查询向量，赋给每个region一个attention系数，这样就可以在每一个step重构attention系数分配，这样也解决了motivation中提到的问题，即attention是由某一个individual word 而计算得来的。（b）每个step 有了attention对齐之后的attention_region， 再输入到language_LSTM中，得到<strong>再次预测的sequence of word</strong>。</li>
<li><p>在这第二阶段，就是两个loss 交叉熵损失进行权重加和来训练</p>
</li>
<li><p>可以发现一个问题，对于visual-words 和 non-visual-words都进行了re-localize。实际上对于，on a 等这类词汇，并不需要在image中找到 grounded region。 该文作者在补充材料里给出了一些额外的实验， eg, 将这些non-visual words 进行抑制，不计算reconstruction loss, 或者给这些localized region representation重新赋给invalid representaion。但是实验表明，在Flickr30 上性能（caption and ground）有提升，但是在 activity上（caption 没变化，ground下降）。</p>
</li>
<li>但是作者并没有给出分析，我个人总觉得实验设计的不完善，分析的也不多。</li>
</ul>
<h3 id="Measuring-grounding-per-generated-sentence"><a href="#Measuring-grounding-per-generated-sentence" class="headerlink" title="Measuring grounding per generated sentence"></a>Measuring grounding per generated sentence</h3><ul>
<li>提该指标的原因：（Such metrics （F1all, F1loc） are extremely stringent as captioning models are generally biased toward certain words in the vocabulary, given the long-tailed distribution of words. ）</li>
</ul>
<h3 id="Analysis-Grounding-performance-when-using-a-better-object-detector"><a href="#Analysis-Grounding-performance-when-using-a-better-object-detector" class="headerlink" title="Analysis:  Grounding performance when using a better object detector."></a>Analysis:  Grounding performance when using a better object detector.</h3><ul>
<li>在 Flickr30k Entities 上进行实验，分析 better detector 对 grounding性能的影响</li>
<li>（1）使用 GT box (ubrealistically) ，进行实验，发现 caption metric 和 grounding accuracy都有提升</li>
<li>（2）在 Flickr30k上训练一个detector（之前使用的是在 visual genome上训练好的），进行实验，发现，使得caption metirc下降，（作者分析：由于在本数据集上进行训练，得到的 the ROI features and their associated object predictions 更偏向于 该数据中的  the annotated object words 却不能很好地泛化以预测 diverse captions， 从而导致了captioning 指标下降）</li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1] Abhishek Das, Harsh Agrawal, Larry Zitnick, Devi Parikh, and Dhruv Batra.  <strong>Human attention in visual question answering: Do humans and deep networks look at the same regions?</strong>  Computer Vision and Image Understanding, 163:90–100, 2017. </p>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>[LightningDOT] Pre-training Visual-Semantic Embeddings for Real-Time Image-Text Retrieval</title>
    <url>/2021/03/18/LightningDOT-Pre-training-Visual-Semantic-Embeddings-for-Real-Time-Image-Text-Retrieval/</url>
    <content><![CDATA[<h2 id="1-任务"><a href="#1-任务" class="headerlink" title="1. 任务"></a>1. 任务</h2><p>本文发表在 NAACL 2021，本文要研究的内容是如何提高 <strong>Image-text retrieval 任务的计算效率。</strong></p>
<h2 id="2-存在的问题"><a href="#2-存在的问题" class="headerlink" title="2. 存在的问题"></a>2. 存在的问题</h2><p>基于预训练的跨模态模型取得了很好的进展，但是在测试阶段存在<strong>推理速度慢</strong>的问题。 主要是由于Transformer 结构中的cross-modal attention 造成的巨大的计算消耗。 这种延迟以及计算消耗使其很难在实际中应用。</p>
<p>下图可视化了近年来 ITR task 的研究进展，（a） 早期，使用CNN和RNN分别提取视觉和语言特征，然后使用dot-product 来计算similarity。 （b）后来有人提出使用faster-RCNN 和 RNN 分别提取两个模态的特征，使用使用cross-attention，最后再计算相似性。（c）随着BERT的发展，有人使用BERT扩展出 V+L BERT 模型。(d) 由于cross-modal attention 是耗时的，因此，本文中提出去掉cross-modal 这个模块。</p>
<p><img src="https://i.loli.net/2021/03/18/fdU3lxwpkZo8yuG.png" alt="image-20210318143100485" style="zoom:50%;"></p>
<h2 id="3-本文的点"><a href="#3-本文的点" class="headerlink" title="3. 本文的点"></a>3. 本文的点</h2><ul>
<li>本文希望可以重新回归到 <strong>dot-product</strong> 这个简单的操作。本文中使用dot product 来做多模态融合，而不是使用计算量的self-attention。同时，为了利用有效的多模态嵌入学习，本文在两个encoder上都使用 [CLS] token。</li>
<li><p>通过消除模态之间耗时的交叉注意力，该模型可以在推理过程中学习视觉语义嵌入而无需在每个图像-文本对之间进行广泛匹配。此外，通过消除对图像-文本对的实时计算的依赖，我们可以一次<strong>离线地独立地</strong>计算所有图像和文本嵌入，并将这些嵌入重新用作新查询的<strong>缓存索引</strong>。</p>
</li>
<li><p>LightningDOT通过预先训练<strong>三个新颖的学习目标</strong>：Visual-embedding fused MLM (namely VMLM), Semantic-embedding  fused MRM (namely SMRM) and a cross-modal retrieval objective (namely CMR).</p>
<p>前两个预训练任务（VMLM 和 SMRM）是为了确保跨模态信息可以被获取到。CMR是为了鼓励模型在预训练阶段获得多模态融合。</p>
</li>
<li><p>重新排名（re-ranking）机制</p>
</li>
</ul>
<p>Note: 本文不是从模型压缩的角度来解决问题。</p>
<h2 id="4-贡献"><a href="#4-贡献" class="headerlink" title="4. 贡献"></a>4. 贡献</h2><p>提出了一个简单有效的方法，在不牺牲accuracy 的情况下，LightningDOT 可以数千倍的加速推理时间。</p>
<p>我们的工作是在基于预训练视觉语义嵌入，实现低延迟的实时跨模式检索的第一个已知工作。</p>
<h2 id="5-Method"><a href="#5-Method" class="headerlink" title="5. Method"></a>5. Method</h2><p><img src="https://i.loli.net/2021/03/18/kASuJa8xc6hYFne.png" alt="image-20210318175408610" style="zoom: 67%;"></p>
<p>在本节中，我们介绍LightningDOT框架，该框架由两个深层的Transformer作为图像和语言编码器。我们首先介绍三个预训练任务，然后介绍从<strong>离线特征提取</strong>到<strong>在线即时检索</strong>的 <strong>推理流程（inference pipline）</strong>。</p>
<p>图像编码器得到region features: $f_{\theta_{V}}(\mathbf{v})=\mathbf{h}=\left\{\mathbf{h}_{0}, \ldots, \mathbf{h}_{N}\right\}\left(\mathbf{h}_{j} \in \mathbb{R}^{d}\right)$</p>
<p>语言编码器得到token representations: $f_{\theta_{L}}(\mathbf{w})=\mathbf{z}=\left\{\mathbf{z}_{0}, \ldots, \mathbf{z}_{T}\right\}\left(\mathbf{z}_{j} \in \mathbb{R}^{d}\right)$</p>
<p>regard the output [CLS] embedding <strong><strong style="color:red;">$h_0$</strong> as global image representation</strong>, and <strong><strong style="color:red;">$z_0$</strong>as global text representation</strong></p>
<h3 id="5-1-Model-Pre-training"><a href="#5-1-Model-Pre-training" class="headerlink" title="5.1 Model Pre-training"></a>5.1 Model Pre-training</h3><h4 id="Visual-embedding-Fused-Masked-Language-Modeling-VMLM"><a href="#Visual-embedding-Fused-Masked-Language-Modeling-VMLM" class="headerlink" title="Visual-embedding Fused Masked Language Modeling (VMLM)"></a>Visual-embedding Fused Masked Language Modeling (VMLM)</h4><p>设有M个 masked tokens</p>
<p>对于 sentence $t$ and image $i$ ， The loss function of VMLM can be formulated as:</p>
<p>$\mathcal{L}_{\mathrm{VMLM}}(t, i)=-\log P_{\theta}\left(\mathbf{w}_{\mathbf{m}} \mid \mathbf{w}_{\backslash \mathbf{m}}, i\right)$<br>$=-\frac{1}{M} \sum_{k=1}^{M} \log P_{\theta_{\mathrm{mlm}}}\left(\mathbf{w}_{\mathbf{m}_{k}} \mid \mathbf{z}_{\mathbf{m}_{k}}+\mathbf{h}_{0}\right)$</p>
<p>其中 $z$ 是 hidden state。</p>
<p>Note： 这里的 +$h_0$ 是显式的加和，而不是使用cross-modal attention.</p>
<h4 id="Semantic-embedding-Fused-Masked-Region-Modeling-SMRM"><a href="#Semantic-embedding-Fused-Masked-Region-Modeling-SMRM" class="headerlink" title="Semantic-embedding Fused Masked Region Modeling (SMRM)"></a>Semantic-embedding Fused Masked Region Modeling (SMRM)</h4><p>$\mathcal{L}_{\mathrm{SMRM}}(i, t)=\mathcal{D}_{\theta_{\mathrm{mrm}}}\left(\mathbf{v}_{\mathbf{m}}, f_{\theta_{V}}\left(\mathbf{v}_{\backslash \mathbf{m}}\right), t\right)$<br>$=\frac{1}{M} \sum_{k=1}^{M} \mathcal{D}_{\theta_{\mathrm{mrm}}}\left(\mathbf{v}_{\mathbf{m}_{k}}, \mathbf{h}_{\mathbf{m}_{k}}+\mathbf{z}_{0}\right)$</p>
<p>这里的 $\mathcal{D}_{\theta_{\mathrm{mrm}}}$ 代表两个损失，一个是使用L2 distance 的 掩码区域特征回归，另外一个是用KL散度的掩码区域分类。</p>
<h4 id="Cross-modal-Retrieval-Objective-CMR"><a href="#Cross-modal-Retrieval-Objective-CMR" class="headerlink" title="Cross-modal Retrieval Objective (CMR)"></a>Cross-modal Retrieval Objective (CMR)</h4><p>The similarity score between query t and image i is defined as:</p>
<p>$S(t, i)=\left\langle\mathbf{z}_{0}, \mathbf{h}_{0}\right\rangle$</p>
<p>损失函数：</p>
<p>$\mathcal{L}_{\mathrm{IR}}^{(t)}=-\log \frac{e^{S\left(t, i_{1}\right)}}{\sum_{k=1}^{n} e^{S\left(t, i_{k}\right)}}$</p>
<p>$\mathcal{L}_{\mathrm{TR}}^{(i)}=-\log \frac{e^{S\left(i, t_{1}\right)}}{\sum_{k=1}^{n} e^{S\left(i, t_{k}\right)}}$</p>
<p>$\mathcal{L}_{\mathrm{CMR}}(B)=\frac{1}{2 n} \sum_{k=1}^{n} \mathcal{L}_{\mathrm{TR}}^{\left(i_{k}\right)}+\mathcal{L}_{\mathrm{IR}}^{\left(t_{k}\right)}$</p>
<h3 id="5-2-Real-time-Inference"><a href="#5-2-Real-time-Inference" class="headerlink" title="5.2 Real-time Inference"></a>5.2 Real-time Inference</h3><p>以text-to-image retrieval 作为样例来介绍 real-time inference pipline：</p>
<p>（1）离线图片特征提取与编码；（2）text query 在线检索；（3）使用top-retrieval images 做在线重拍</p>
<h4 id="Offline-Feature-Extraction"><a href="#Offline-Feature-Extraction" class="headerlink" title="Offline Feature Extraction"></a>Offline Feature Extraction</h4><p>首先使用 image encoder 来处理数据集中的所有图片，并存储其 global image representation 进入索引的内存中供以后使用。</p>
<p>整个image-to-index 过程，包括 faster rcnn 提取特征 以及 image transformer encoder 都是离线处理的。</p>
<h4 id="Online-Retrieval"><a href="#Online-Retrieval" class="headerlink" title="Online Retrieval"></a>Online Retrieval</h4><p>对于 text query, 使用language encoder 提取特征，然后依次计算与每个图片的相似度。图片将会被排序。实际中，人们感兴趣的是前top-k 检索结果。</p>
<p>使用FAISS来优化检索。</p>
<p>类似地，对于文本检索，可以通过简单地为所有句子预先计算嵌入并使用图像作为查询来应用相同的体系结构</p>
<h4 id="Re-ranking"><a href="#Re-ranking" class="headerlink" title="Re-ranking"></a>Re-ranking</h4><p>为了进一步提高检索结果，本文通过采用可选的<strong>重新排名模型</strong>提出了一种两阶段方法。</p>
<p>第一阶段，使用LightingDOT来检索 top-M images(or texts)。</p>
<p>第二阶段，使用一个性能更好的检索模型（通常比较慢）来重新排序从第一阶段检索到的 top-M pairs.</p>
<p>实验证明，可以同时从性能和效率两方面受益。</p>
<h2 id="6-Experiments"><a href="#6-Experiments" class="headerlink" title="6. Experiments"></a>6. Experiments</h2><h3 id="6-1-Results-on-Flickr30K-and-COCO"><a href="#6-1-Results-on-Flickr30K-and-COCO" class="headerlink" title="6.1 Results on Flickr30K and COCO"></a>6.1 Results on Flickr30K and COCO</h3><p><img src="https://i.loli.net/2021/03/18/TpcoUY7Zjel39dM.png" alt="image-20210318175824380" style="zoom: 50%;"></p>
<ul>
<li><p>在仅使用一阶段排序的情况下：</p>
<ul>
<li>相比于不使用预训练的模型，性能上有显著提升 CAAN (SOTA method with cross-attention）</li>
<li>与使用预训练的模型相比，UNITER，性能上仅下降了一点，但是速度上有600/1900倍的提升(Flickr30K/COCO)</li>
</ul>
</li>
<li><p>使用两阶段排序：</p>
<ul>
<li>性能上相比于一阶段有提升，同时比单纯的UNITER模型有 46-95倍速度的提升，</li>
</ul>
</li>
</ul>
<h3 id="6-2-Speed-amp-Space-Improvement"><a href="#6-2-Speed-amp-Space-Improvement" class="headerlink" title="6.2 Speed &amp; Space Improvement"></a>6.2 Speed &amp; Space Improvement</h3><ul>
<li><p>检索图像，比较推理速度差异</p>
<p>以 UNITER_base 作为比较对象。</p>
<p>SCAN，是一个不使用预训练的模型，但是采用了cross-modal attention.</p>
<p><img src="https://i.loli.net/2021/03/18/umlFqkgLfyKQ6Cx.png" alt="image-20210318180604083" style="zoom: 33%;"></p>
</li>
<li><p>扩大搜索池，性能仍然很好</p>
<p><img src="https://i.loli.net/2021/03/18/jelLQRdcFwWpaEU.png" alt="image-20210318180918374"></p>
</li>
</ul>
<h3 id="6-3-Ablation-Studies"><a href="#6-3-Ablation-Studies" class="headerlink" title="6.3 Ablation Studies"></a>6.3 Ablation Studies</h3><ul>
<li><p>观察各个模块的作用</p>
<p>(1) 【R-CNN only】不使用 image encoder, 直接使用 faster rcnn 提取的特征</p>
<p>(2)【 “+Image Encoder”】</p>
<p>(3)【+PT】 MLM+MRM+CMR 上预训练， 注意本文采用的预训练方案是 VMLM+SMRM+CMR</p>
<p><img src="https://i.loli.net/2021/03/18/ewAYK8M6idSBvEb.png" alt="image-20210318181810013" style="zoom: 33%;"></p>
<p><strong style="color:blue;">yaya: 其实，本文提出的预训练任务带来的提升并不明显。</strong></p>
</li>
<li><p>观察各个预训练任务的作用</p>
<p><img src="https://i.loli.net/2021/03/18/OkTcr9IVbxYBPgu.png" alt="image-20210318182135676" style="zoom: 50%;"></p>
<p>预训练任务对于本文提出的模型是有提升的，但是，提升的显著性似乎没有那么大。</p>
<p><strong style="color:blue;">yaya: 奇怪，为什么 这个 PT(ALL) 与 上个表Table 4 中的LightingDOT结果 不一致呢都？都是在Flickr30k validation上的结果</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>cross-modal</category>
        <category>Image-Text Retrieval</category>
        <category>real time</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
        <tag>Image-Text Retrieval</tag>
        <tag>real time</tag>
      </tags>
  </entry>
  <entry>
    <title>Memory-Attended Recurrent Network for Video Captioning</title>
    <url>/2019/07/25/Memory-Attended-Recurrent-Network-for-Video-Captioning/</url>
    <content><![CDATA[<h3 id="词频"><a href="#词频" class="headerlink" title="词频"></a>词频</h3><p>“&gt; =3”的保留</p>
<p>MSR-VTT :11K   MSVD:4K</p>
<h3 id="Attention-Decoder"><a href="#Attention-Decoder" class="headerlink" title="Attention Decoder"></a>Attention Decoder</h3><ul>
<li><p>采用SA-LSTM的结构</p>
</li>
<li><p>细节：</p>
<ul>
<li><p>==共享attention==<br>由于需要对frames_feature ==(L帧)==  与 C3D_feature ==（L帧 -&gt; L/16个特征向量）== 都进行attention，这里进行了共享attention，好处：   &lt;/br&gt;  </p>
<p>（1）将2D 和 3D 特征映射到相似的特征空间  &lt;/br&gt;</p>
<p>（2）像是一种正则化，减少了参数，避免过拟合  &lt;/br&gt;  </p>
</li>
<li><p>降维<br>将2D 和 3D 的2048维度的特征，降维到512</p>
</li>
</ul>
</li>
</ul>
<h3 id="Attended-Memory-Decoder"><a href="#Attended-Memory-Decoder" class="headerlink" title="Attended Memory Decoder"></a>Attended Memory Decoder</h3><ul>
<li><p>当前模型的不足：</p>
<ul>
<li>现有的模型在生成word的时候，只依赖于当前video的信息，而不能依赖于那些，出现过该单词的其他video的信息</li>
<li>生成下一个单词，仅依赖于video信息和当前单词，没有建模相邻两个单词之间的兼容性（没看懂）</li>
</ul>
</li>
<li><p>具体的memeory设计详见论文</p>
</li>
</ul>
<h3 id="Attention-Coherent-Loss-AC-Loss"><a href="#Attention-Coherent-Loss-AC-Loss" class="headerlink" title="Attention-Coherent Loss (AC Loss)"></a>Attention-Coherent Loss (AC Loss)</h3><ul>
<li>将C3D 输入的L帧作为1个time interval,希望对一个time interval 中的frames feature 的attention系数值相近</li>
<li>仅对frames_features 的attention 系数，计算这样的一个loss</li>
</ul>
<p><img src="https://i.loli.net/2019/07/25/5d397582d36f640160.png" alt="搜狗截图20190725172350.png" title="搜狗截图20190725172350.png"></p>
]]></content>
  </entry>
  <entry>
    <title>Maxout Networks</title>
    <url>/2019/02/27/Maxout-Networks/</url>
    <content><![CDATA[<p>本文是蒙特利尔大学信息与信息技术学院的几位大牛2013年在ICML上发表的一篇论文，提出了一种叫maxout的新模型，到目前用的比较少，可能这个算法参数个数会成k倍增加(k是maxout的一个参数)。文中提到这样命名的原因：（1）它的输出是一组输入的最大值（2）它与dropout是天然的组合。</p>
<p>文章首先肯定了dropout的意义，从音频分类到超大规模物体识别都有很好的改进，同时提出不应该把dropout作为一个适用于任意模型的轻微性能增强，而是通过直接设计一个模型来提高dropout能力，作为模型平均技术，可以获得最好的性能。</p>
<p>Dropout：</p>
<ul>
<li>dropout可以训练集成模型，它们共享参数并近似的对这些模型的预测进行了平均。它可以被当作一种通用的方法用在任何一种MLP和CNN模型中，但是在论文中，由于dropout的模型平均过程没有被证明，因而一个模型最好的性能的获得，应该通过直接设计这个模型使之可以增强dropout的模型平均的能力。使用了dropout的训练过程和一般的SGD方法完全不同。dropout在更新时使用更大的步长最有效，因为这样可以在不同的训练子集上对不同的模型有明显的影响来使得目标函数有持续的波动性，理想情况下整个训练过程就类似于使用bagging来训练集成的模型（带有参数共享的约束）。而一般的SGD更新时会使用更小的步长，来使得目标函数平滑的下降。对于深度网络模型，dropout只能作为模型平均的一种近似，显式的设计模型来最小化这种近似误差也可以提高dropout的性能。</li>
<li>dropout训练的集成模型中，所有模型都只包括部分输入和部分隐层参数。对每一个训练样本，我们都会训练一个包括不同隐层参数的子模型。dropout与bagging的相同点是不同的模型使用不同数据子集，不同点是dropout的每个模型都只训练一次且所有模型共享参数。</li>
<li>对于预测时如何平均所有子模型的问题，bagging一般使用的是算数平均，而对dropout产生的指数多个子模型则并非显而易见。但是如果模型只有一层 <img src="https://www.zhihu.com/equation?tex=p%28y+%7C+v%3B%CE%B8%29%3Dsoftmax%28v%5E%7BT%7D%2Bb%29" alt="p(y | v;θ)=softmax(v^{T}+b)">作为输出（p(y | v;θ)的几何平均），则最终的预测分布就是简单的 <img src="https://www.zhihu.com/equation?tex=softmax%28v%5E%7BT%7DW%2F2%2Bb%29" alt="softmax(v^{T}W/2+b)">，即指数多个子模型的平均预测就是完整模型的预测仅仅将权重减半而已。这个结果只能用在单softmax层的模型中，如果是深层模型如MLP，那么权重减半的方法只是几何平均的一种近似。</li>
</ul>
<p>Maxout是深度学习网络中的一层网络，就像池化层、卷积层一样等，我们可以把maxout 看成是网络的激活函数层。我们假设网络某一层的输入特征向量为：X=（x1,x2,……xd），也就是我们输入是d个神经元。Maxout隐藏层每个神经元的计算公式如下：</p>
<p><img src="https://www.zhihu.com/equation?tex=h_%7Bi%7D%3D%5Cmax_%7Bj+%5Cin+%5B1%2Ck%5D%7D%7Bz_%7Bij%7D%7D" alt="h_{i}=\max_{j \in [1,k]}{z_{ij}}"></p>
<p>上面的公式就是maxout隐藏层神经元i的计算公式。其中，k就是maxout层所需要的参数了，由我们人为设定大小。就像dropout一样，也有自己的参数p(每个神经元dropout概率)，maxout的参数是k。公式中Z的计算公式为： <img src="https://www.zhihu.com/equation?tex=z_%7Bij%7D%3Dx%5E%7BT%7DW_%7B..ij%7D%2Bb_%7Bij%7D" alt="z_{ij}=x^{T}W_{..ij}+b_{ij}"> ，权重w是一个大小为(d,m,k)三维矩阵，b是一个大小为(m,k)的二维矩阵，这两个就是我们需要学习的参数。如果我们设定参数k=1，那么这个时候，网络就类似于以前我们所学普通的MLP网络。</p>
<p>我们可以这么理解，本来传统的MLP算法在第i层到第i+1层，参数只有一组，然而现在我们不怎么干了，我们在这一层同时训练n组参数，然后选择激活值最大的作为下一层神经元的激活值。下面还是用一个例子进行讲解，比较容易搞懂。</p>
<p>（1）以前MLP的方法。<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0ldm6b5ujj30ix08mdg0.jpg"></p>
<p>其中 f 就是我们所谓的激活函数，比如Sigmod、Relu、Tanh等。</p>
<p>(2)Maxout 的方法。如果我们设置maxout的参数k=5，maxout层就如下所示：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0ldmxgg2zj30n60e33zh.jpg"></p>
<p>相当于在每个输出神经元前面又多了一层。这一层有5个神经元。<br>所以这就是为什么采用maxout的时候，参数个数成k倍增加的原因。本来我们只需要一组参数就够了，采用maxout后，就需要有k组参数。</p>
<ul>
<li>对MLP而言，2个输入节点先构成5个“隐隐层”节点，然后在5个“隐隐层”节点中使用最大的构成了本层的一个节点，本层其他节点类似。<strong>实现技巧：</strong><code>maxout</code>和<code>relu</code>唯一的区别是，<code>relu</code>使用的max(x,0)是对隐层每一个单元执行的与0比较最大化操作，而<code>maxout</code>是对5个“隐隐层”单元的值执行最大化操作。如果将“隐隐层”单元在隐层展开，那么隐层就有20个“隐隐层”单元，<code>maxout</code>做的就是在这20个中每5个取一个最大值作为最后的隐层单元，最后的隐层单元仍然为4个。这里每5个取一个最大值也称为最大池化步长（max pooling stride）为5，最大池化步长默认和“隐隐层”个数相等，如果步长更小，则可以实现重叠最大池化。实现的时候，可以将隐层单元数设置为20个，权重维度（2，20）偏置维度（1，20），然后在20个中每5个取一个最大值得到4个隐层单元。</li>
<li>对于CNN而言，假设上一层有2个特征图，本层有4个特征图，那么就是将输入的2个特征图用5个滤波器卷积得到5张仿射特征图（affine feature maps），然后从这5张仿射特征图每个位置上选择最大值（跨通道池化，pool across channels）构成一张本层的特征图，本层其他特征图类似。<strong>实现技巧：</strong><code>relu</code>使用的max(x,0)是对每个通道的特征图的每一个单元执行的与0比较最大化操作，而<code>maxout</code>是对5个通道的特征图在通道的维度上执行最大化操作。而如果把5个特征图在本层展开，那么本层就有20个特征图，<code>maxout</code>做的就是在这20个中每5个取在通道维度上的最大值作为最后的特征图，最后本层特征图仍然为4个。同样最大池化步长默认为5。实现的时候，可以将本层特征图数设置为20个，权重维度（20，2，3，3）偏置维度（1，20，1，1），然后在20个中每5个取一个最大特征图得到4个特征图。<strong>注意：</strong> 对于CNN而言，在maxout输出后如果连接一个一般的降采样最大池化层，则可以将这个降采样最大池化融合进跨通道池化中，即在仿射特征图的每个池化窗口中选择最大值（相当于同时在通道间和空间取最大值）。这样就可以在maxout网络中省略显式的降采样最大池化层。</li>
</ul>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><ol>
<li>MNIST</li>
</ol>
<p>排列不变限制的MNIST（MNIST with permutation invariant，即像素排列顺序可以改变，输入的数据是2维的），使用两个全连接maxout层再接上一个softmax层，结合dropout和权重衰减。验证集选取训练集中后10000个样本。在得到最小的验证集误差时记录下前50000个样本的训练集对数似然L，接着在整个60000样本的训练集上<strong>继续训练</strong>直到验证集的对数似然达到L。<em>0.94%</em></p>
<p>无排列不变限制的MNIST（MNIST without permutation invariant，即像素排列顺序不变，输入的数据是3维的），使用三个卷积maxout层，之后接上空间最大池化层，最后接上一个softmax层。还可以使用扩充数据集的方法进一步提高。<em>0.45%</em></p>
<p>\2. CIFAR-10</p>
<p>预处理：全局像素归一化和ZCA白化</p>
<p>过程与MNIST类似，只是将继续训练改为了<strong>重新训练</strong>，因为继续训练的学习率很低训练太久。</p>
<p>使用三个卷积maxout层，之后接上全连接maxout层，最后接上一个softmax层。<em>13.2%</em>（不使用验证集数据）<em>11.68%</em>（使用验证集数据）<em>9.35%</em>（使用平移、水平翻转的扩充数据集）</p>
<p>\3. CIFAR-100</p>
<p>超参数使用和CIFAR-10一样</p>
<p><em>41.48%</em>（不使用验证集数据）<em>38.57%</em>（使用验证集数据）</p>
<p>\4. SVHN</p>
<p>验证集为训练集每类选取400个样本和额外集每类选取200个样本，其他的为训练集。</p>
<p>预处理：局部像素归一化</p>
<p>使用三个卷积maxout层，之后接上全连接maxout层，最后接上一个softmax层（同CIFAR-10）。<em>2.47%</em></p>
<h2 id="maxout对比relu"><a href="#maxout对比relu" class="headerlink" title="maxout对比relu"></a>maxout对比relu</h2><ul>
<li>跨通道池化可以减少网络状态并减少模型所需要的参数。</li>
<li>对于maxout，性能与跨通道池化时滤波器数量有很大关系，但对relu，性能与输出单元的数量没有关系，也就是relu并不从跨通道池化中受益。</li>
<li>要让relu达到maxout的表现，需要使之具有和maxout相同数量的滤波器（即使用比原来k倍的滤波器，同样也要k倍的relu单元），但网络状态和所需要的参数也是原来的k倍，也是对应maxout的k倍。</li>
</ul>
<h2 id="模型平均"><a href="#模型平均" class="headerlink" title="模型平均"></a>模型平均</h2><ul>
<li>单层softmax有对模型进行平均的能力，但是通过观察，多层模型中使用dropout也存在这样的模型平均，只是有拟合精度的问题。</li>
<li>训练中使用dropout使得maxout单元有了更大的输入附近的线性区域，因为每个子模型都要预测输出，每个maxout单元就要学习输出相同的预测而不管哪些输入被丢弃。改变dropout mask将经常明显移动有效输入，从而决定了输入被映射到分段线性函数的哪一段。使用dropout训练的maxout具有一种特性，即当dropout mask改变时每个maxout单元的最大化滤波器相对很少变化。</li>
<li>maxout网络中的线性和最大化操作可以让dropout的拟合模型平均的精度很高。而一般的激活函数几乎处处都是弯曲的，因而dropout的拟合模型平均的精度不高。</li>
</ul>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ul>
<li>训练中使用dropout时，maxout的优化性能比relu+max pooling好</li>
<li>dropout使用更大的步长最有效，使得目标函数有持续的波动性。而一般的SGD会使用更小的步长，来使得目标函数平滑的下降。dropout快速的探索着许多不同的方向然后拒绝那些损害性能的方向，而SGD缓慢而平稳的朝向最可能的方向移动。</li>
<li>实验中SGD使得relu饱和在0值的时间少于5%，而dropout则超过60%。由于relu激活函数中的0值是一个常数，这就会阻止梯度在这些单元上传播（无论正向还是反向），这也就使得这些单元很难再次激活，这会导致很多单元由激活转变为非激活。而maxout就不会存在这样的问题，梯度在maxout单元上总是能够传播，即使maxout出现了0值，但是这些0值是参数的函数可以被改变，从而maxout单元总是激活的。单元中较高比例的且不易改变的0值会损害优化性能。</li>
<li>dropout要求梯度随着dropout mask的改变而明显改变，而一旦梯度几乎不随着dropout mask的改变而改变时，dropout就简化成为了SGD。relu网络的低层部分会有梯度衰减的问题（梯度的方差在高层较大而反向传播到低层后较小）。maxout更好的将变化的信息反向传播到低层并帮助dropout以类似bagging的方式训练低层参数。relu则由于饱和使得梯度损失，导致dropout在低层的训练类似于一般的SGD。</li>
</ul>
<h2 id="总结文中的点"><a href="#总结文中的点" class="headerlink" title="总结文中的点"></a>总结文中的点</h2><ul>
<li>单个<code>maxout</code>激活函数可以理解成一种分段线性函数来近似任意凸函数（任意的凸函数都可由分段线性函数来拟合）。它在每处都是局部线性的（k个“隐隐层”节点都是线性的，取其最大值则为局部线性，分段的个数与k值有关），而一般的激活函数都有明显的曲率。</li>
<li>如同MLP一样，maxout网络也可以拟合任意连续函数。只要<code>maxout</code>单元含有任意多个“隐隐层”节点，那么只要两个隐层的maxout网络就可以实现任意连续函数的近似。</li>
<li>maxout网络不仅可以学习到隐层之间的关系，还可以学习到每个隐层单元的激活函数。</li>
<li>maxout放弃了传统激活函数的设计，它产生的表示不再是稀疏的，但是它的梯度是稀疏的，且dropout可以将它稀疏化。</li>
<li>maxout没有上下界，所以让它在某一端饱和是零概率事件。</li>
<li>如果训练时使用dropout，则dropout操作在矩阵相乘之前，而并不对<code>max</code>操作的输入执行dropout。</li>
<li>使用maxout会默认一个先验：样本集是凸集可分的。</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>[MDMMT] Multidomain Multimodal Transformer for Video Retrieval</title>
    <url>/2021/03/22/MDMMT-Multidomain-Multimodal-Transformer-for-Video-Retrieval/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Motion Guided Spatial Attention for Video Captioning</title>
    <url>/2019/07/28/Motion-Guided-Spatial-Attention-for-Video-Captioning/</url>
    <content><![CDATA[<h3 id="当前的问题"><a href="#当前的问题" class="headerlink" title="当前的问题"></a>当前的问题</h3><ul>
<li>spatial attention 很少有人去探索</li>
<li>motion information 被利用通常是使用3D-CNNs来作为另外一种模态</li>
</ul>
<h3 id="本文的工作"><a href="#本文的工作" class="headerlink" title="本文的工作"></a>本文的工作</h3><ul>
<li>两个贡献： MGSA、GARU</li>
<li>The proposed MGSA utilize motion information between consecutive frames by applying CNN to stacked optical flows. </li>
<li>In addition, a gated recurrent unit named GARU is designed to adaptively relate spatial attention maps across time.<br><img src="https://i.loli.net/2019/07/28/5d3d877e9c0d546970.png" alt="搜狗截图20190728193057.png" title="搜狗截图20190728193057.png">    </li>
</ul>
<h3 id="Encoder-部分我的理解"><a href="#Encoder-部分我的理解" class="headerlink" title="Encoder 部分我的理解"></a>Encoder 部分我的理解</h3><ul>
<li>对一个video 采取N帧，对这N帧提取appearences feature，得到<code>N*H*W*D</code>的特征向量</li>
<li>以每帧为中心，采取连续的M帧，这M帧计算optical flow，并将这个<code>N*M</code>帧的optical flow images送入CNN中，得到<code>N*H*W*1</code>的特征向量。</li>
<li>==构造一个长度为N的GRU时域序列，每次送入一帧==  appearence feature 和 optical flow cnn feature，并得到一个输出,维度为<code>H*W</code>，</li>
<li>该输出作为一个attention系数，并与 ==当前帧== frame feature 相乘。得到一个为该帧的每个像素点（<code>H*W</code>）分配的权重系数。即进行加权求和，则可以得到该帧的spatial attention</li>
</ul>
<h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><p><img src="https://i.loli.net/2019/07/28/5d3d87b91afaa36288.png" alt="搜狗截图20190728193156.png" title="搜狗截图20190728193156.png" width="440px" height="400px">    </p>
<h3 id="Experimental-results"><a href="#Experimental-results" class="headerlink" title="Experimental results"></a>Experimental results</h3><ul>
<li>这里只是想提一点，就是有一些论文在MSR-VTT上的实验结果，是使用了==音频信息==。<br><img src="https://i.loli.net/2019/07/28/5d3d80835814750581.png" alt="搜狗截图20190728190107.png" title="搜狗截图20190728190107.png"></li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><p>基于 spatial attention的 video captioning model</p>
</li>
<li><p>Li, X.; Zhao, B.; and Lu, X. 2017. MAM-RNN: multi-level attention model based RNN for video captioning. In IJCAI, 2208–2214. </p>
</li>
<li><p>Yang, Z.; Han, Y.; and Wang, Z. 2017. Catching the temporal regions-of-interest for video captioning. In ACM MM, 146–153. attention, spatial. </p>
</li>
</ul>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>Motivation of Learning based Evaluation Metrics for Text Generation</title>
    <url>/2020/07/30/Motivation-of-Learning-based-Evaluation-Metrics-for-Text-Generation/</url>
    <content><![CDATA[<p>From : <strong>Evaluation of Text Generation: A Survey</strong></p>
<p>现在评估 text generation 的方法有三种：</p>
<p>(1) human-centric evaluation metrics, </p>
<p>(2) automatic metrics that require no training, </p>
<p>(3) machine-learned metrics. </p>
<h3 id="Human-centric-evaluation-metrics"><a href="#Human-centric-evaluation-metrics" class="headerlink" title="Human-centric evaluation metrics,"></a>Human-centric evaluation metrics,</h3><p>就是由人<strong>手工</strong>为 生成的文本进行打分，但是这种方式比较耗费人力</p>
<h3 id="Automatic-metrics-that-require-no-training"><a href="#Automatic-metrics-that-require-no-training" class="headerlink" title="Automatic metrics that require no training,"></a>Automatic metrics that require no training,</h3><ul>
<li><p>n-gram Overlap Metrics for Content Selection</p>
<ul>
<li><p>F-SCORE(F1)</p>
</li>
<li><p>BLEU</p>
</li>
<li><p>NIST</p>
</li>
<li><p>ROUGE</p>
</li>
<li><p>METEOR</p>
</li>
<li><p>HLEPOR</p>
</li>
<li><p>RIBES</p>
</li>
<li><p>CIDER</p>
</li>
</ul>
</li>
<li>Distance-Based Evaluation Metrics for Content Selection</li>
<li>n-gram-Based Diversity Metrics</li>
<li>Explicit Semantic Content Match Metrics<ul>
<li>SPICE </li>
</ul>
</li>
<li>Syntactic Similarity-Based Metrics</li>
</ul>
<h3 id="Machine-Learned-Evaluation-Metrics"><a href="#Machine-Learned-Evaluation-Metrics" class="headerlink" title="Machine-Learned Evaluation Metrics"></a>Machine-Learned Evaluation Metrics</h3><ul>
<li><p>Sentence Semantic Similarity Based Evaluation</p>
</li>
<li><p>Evaluating Factual Correctness</p>
</li>
<li>Regression-based Evaluation</li>
<li>Evaluation Models with Human Judgments</li>
<li>BERT-Based Evaluation</li>
<li>Composite Metric Scores</li>
</ul>
<p>由于语言的灵活性，GT texts 不可能覆盖所有的情况，下图展示了两个例子。在这两个任务中，给定输入，由模型生成的输出都是合理的，但它们与真实的输出不共享任何单词。</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gh954nipuej319z0k4q9z.jpg"></p>
<p>一种解决办法是使用 embedding based method，来衡量语义相似性，而非 word overlap。但是 embedding-based methods 不能解决 generated output 与 reference 语义不同的情况，如上图中 dialog 的例子。</p>
<p>在这种情况下，可以构建 machine-learned models (在 human judgment data上 进行训练) 来模拟 human judgments，进而评估output 的质量，例如事实正确性，自然性，流利性，连贯性等。</p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>[MultiSubs] A Large-scale Multimodal and Multilingual Dataset</title>
    <url>/2021/03/03/MultiSubs-A-Large-scale-Multimodal-and-Multilingual-Dataset/</url>
    <content><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="目前存在的问题"><a href="#目前存在的问题" class="headerlink" title="目前存在的问题"></a>目前存在的问题</h3><p>使用视觉信息对 language grounding 的计算模型的研究导致了许多有趣的应用，例如图像字幕，视觉问答和视觉对话。各种各样的多模态数据集（由图片和文本组成）被构建，并且用于不同的应用。大部分数据集，图像被标注了文本标签，但是没有提供应用文本或图像的上下文。</p>
<p>在 image captioning dataset 中，为每张图片标注了 sentence-level text。虽然这些句子为图片提供了strong concept，但是存在一个基本的缺点：每个 sentence-level text 将 image 看做一个整体，但是实际上，text 中的内容仅仅包含了image中的部分元素。这将使得很难学到视觉和文本中的元素的对应（correspondences between elements）。图像和文本之间的连接是多样的。比如，很难用单个句子描述整个图像或用单个图像说明整个句子。因此，为了了解单词和图像之间更好的基础（grounding），需要在图像和文本段之间建立<strong>更紧密的局部对应关系</strong>。</p>
<p>此外，文本仅限于非常特定的领域（图像描述），而图像也仅限于极少数和非常特定的对象类别或人类活动；这使得很难概括可能的现实世界场景的多样性。</p>
<h3 id="本文的解决办法"><a href="#本文的解决办法" class="headerlink" title="本文的解决办法"></a>本文的解决办法</h3><p>在本文中，提出了一个新的大规模 多模态和多语言的数据集 (MultiSubs)，可以促进 <strong style="color:red;"><strong>grounding words to images</strong> </strong>in the context of their corresponding sentences。如下图1。</p>
<p><img src="https://i.loli.net/2021/03/03/PCQZBX2DtnaFzAu.png" alt="image-20210303162030516" style="zoom: 33%;"></p>
<p>与以前的数据集相比，我们的基础单词不仅针对图像，而且还针对其在语言中的上下文用法，从而有可能对现实世界中的人类语言学习产生更深刻的见解。具体来说：（1）MultiSubs中的文本片段和图像具有更紧密的局部对应，便于学习文本片段及其对应的视觉表示之间的关联；（2）与图像字幕数据集相比，图像更通用，范围更广，并且不受特定域的限制；（3）每个给定的文本片段和句子都可以有多个图像；（4）文字包含类似于自由形式的真实世界文字的grammar ot syntax；（5）文本是多语言的，而不仅仅是单语言或双语的。</p>
<p>从电影字幕的平行语料库开始，我们提出了一种<strong>跨语言多模态消歧方法</strong>，通过利用并行多语言文本来消歧文本中单词的含义，来说明文本片段。如图2所示。</p>
<p><img src="https://i.loli.net/2021/03/03/wBsAvKgbT2LSk16.png" alt="image-20210303163357136"></p>
<p>据我们所知，目前尚未对在文本插图的上下文中对此进行探讨。我们还通过人工判断来评估数据集和 illustrated text fragments 的质量。</p>
<p>使用本文提出的MultiSubs 数据集，本文提出了两个不同的多模态任务：（1）A fill-inn-the-blank task：to guess a missing word from a sentence, with or without image(s) of the word as clues。（2）Lexical translation：在给定 source sentence 和与该source word 相关联的零个或多个图像的情况下，我们将带有句子上下文的 source word 翻译为外语中的target word。</p>
<h2 id="语料库和文本片段选择"><a href="#语料库和文本片段选择" class="headerlink" title="语料库和文本片段选择"></a>语料库和文本片段选择</h2><p><em>MultiSubs</em>基于OpenSubtitles 2016（OPUS）语料库，该语料库是从 OpenSubtitles 中获得的，涵盖了65种语言的movie subtitles。</p>
<blockquote>
<p>OpenSubtitles2016: Extracting large parallel corpora from movie and TV subtitles.</p>
<p>OpenSubtitles: Subtitles - download movie and TV Series subtitles. <a href="http://www.opensubtitles.org/" target="_blank" rel="noopener">http://www.opensubtitles.org/</a></p>
</blockquote>
<p>本文挑选了5类电影：冒险，动画，喜剧，纪录片和家庭。大多数 subtitles 是对话性的（对话）或叙事性的（故事叙事或纪录片）。进一步将字幕过滤为仅在OPUS中与来自语料库的前30种非英语语言中的至少一种字幕对接的英语字幕的子集。这样一来，总共有45,482个电影实例<em>≈</em>38M个英语句子。对于前30种语言，电影的数量从2,354到31,168不等。</p>
<p>我们的目标是选择可能“在视觉上可描绘”的文本片段，并因此可以用图像进行说明。我们首先将英语字幕通过spacy  POS （en_core_web_md）来提取名词，动词，复合名词和简单形容词名词短语。这些 text frgments 的图像可成像性评分是通过MRC心理语言学数据库PaetzoldSpecia：2016通过引导获得的 ; 对于多词短语，我们将每个单词的图像可比性得分平均，为每个未见单词分配零得分。我们 retain text fragments 的可成像性得分至少为500，这是通过人工检查单词的子集来确定的。删除掉仅出现一次的 text fragments 后，输出为一组144,168个唯一候选片段（超过1600万个实例）<em>≈</em>1100万个句子。</p>
<h2 id="Illustration-of-text-fragments"><a href="#Illustration-of-text-fragments" class="headerlink" title="Illustration of text fragments"></a>Illustration of text fragments</h2><h3 id="Cross-lingual-sense-disambiguation"><a href="#Cross-lingual-sense-disambiguation" class="headerlink" title="Cross-lingual sense disambiguation"></a>Cross-lingual sense disambiguation</h3><p>本文提出的text illustration approach 的关键直觉是：一个带有歧义的英语句子，在另外一种语言的parallel sentence 中 可能没有歧义。</p>
<p>【1】<strong>Cross-lingual word alignment</strong> </p>
<p>在选择正确的图像 to illustrate our candidate text fragments (nouns) 时，我们尝试了多达四种<em>目标</em>语言：<strong>西班牙语</strong>（<strong>ES</strong>）和<strong>巴西葡萄牙语</strong>（<strong>PT</strong>），以及<strong>法文</strong>（<strong>FR</strong>）和<strong>德文</strong>（<strong>DE</strong>）。对于每种语言，选择字幕，以使（i）每个字幕都与英语字幕对齐；（ii）每个都至少包含一个感兴趣的名词。对于英语和每个目标语言，我们在全组平行句（不管句子中是否含有候选片段）中训练 <strong><em>fast_align</em></strong> DyerEtAl：2013，以获得在两种语言中词与词之间的对齐 。<strong>这将生成一个字典，该字典将英语名词映射到目标语言中的单词。</strong>我们对此字典进行过滤，以删除不常见的目标短语（语料库的1％以下）对。我们还将目标语言中具有相同lemmas 的单词归为一组。</p>
<p>【2】<strong>Sense disambiguation</strong></p>
<p>source -&gt; target </p>
<p>将名词翻译成不同的词(in the target language) 并不一定意味着它是模棱两可的。target phrases 可以简单地是指代相同概念的同义词。因此，我们进一步尝试在target side 对同义词进行分组，同时还通过查看跨多语言语料库的对齐短语来确定正确的词义。</p>
<p>对于 word senses，我们使用<strong>BabelNet</strong> NavigliPonzetto：2012，这是一个大型语义网络和涵盖多种语言的多语言百科全书，并统一了其他语义网络。</p>
<p>为了帮助我们确定给定上下文中英语名词的正确含义，我们使用目标语言中平行句子中的对齐词来消除歧义。我们计算两个查询返回的BabelNet同义词集ID之间的交集。比如 bank(english) -&gt; banco(spanish) ，如果使用英语bank 来查询将得到 financial-bank 和river-bank，如果用西班牙语banco查询将得到 financial-bank。取这两个查询结果的交集。</p>
<p>如果仅针对一种语言对执行上述操作，则该目标语言可能不足以消除英语术语的歧义，因为该术语在两种语言中可能是歧义的。对于紧密相关的语言（例如葡萄牙语和西班牙语）尤其如此。因此，<strong>我们建议利用<em>多种</em>目标语言，以进一步提高我们消除英语单词歧义的信心</strong>。我们的假设是，更多的语言最终将允许识别单词的正确上下文。</p>
<p>更具体地说，我们研究了包含<strong>多达四种目标语言</strong>的并行句子的字幕。对于每个英语短语，我们保留所有实例之间的同义词集ID之间<strong>至少有一个交集的实例</strong></p>
<p>【3】<strong>Image Selection</strong></p>
<p>构造<em>MultiSubs</em>的最后一步是为每个歧义的英语术语分配至少一个图像，and by design the term in the aligned target language(s)。由于BabelNet通常为给定的同义词集ID提供多个图像，因此我们用与该同义词集关联的所有Creative Commons images 说明该term。</p>
<h2 id="Human-evaluation"><a href="#Human-evaluation" class="headerlink" title="Human evaluation"></a>Human evaluation</h2><p>为了定量评估我们的automated cross-lingual sense disambiguation cleaning procedure，我们收集了人类注释，<strong>以确定<em>MultiSubs</em>中的图像是否确实对预测填空任务中的遗漏单词有用</strong>。<strong>注释还可以作为任务的人工上限</strong></p>
<p>我们将注释任务设置为<em>The Gap Filling Game</em>（图 <a href="https://www.arxiv-vanity.com/papers/2103.01910/#S5.F5" target="_blank" rel="noopener">5</a>）。在此游戏中，用户尝试进行<strong>三种尝试来猜测从<em>MultiSubs</em>的句子中删除的确切单词</strong>。在<strong>第一次尝试</strong>中，游戏仅显示句子（以及遗漏单词的空白）。在<strong>第二次尝试</strong>中，游戏还会为丢失的单词提供一个图像作为线索。在第三次也是<strong>最后一次尝试</strong>中，系统将显示与缺失单词关联的所有图像。在每次尝试中，如果用户输入的单词与原始单词完全匹配，则用户将获得1.0分；否则，将按预先训练的CBOW word2vec MikolovEtAl：2013之间的余弦相似度计算得出的部分分值（介于0.0和1.0之间） 预测词和原始词的嵌入。当用户输入完全匹配的内容时，或者在用尽所有三个尝试之后（以先发生者为准），每个“转”（一个句子）都会结束。第二次和第三次尝试的得分乘以<em>惩罚因子</em>（分别为0.90和0.80），以鼓励用户尽早正确猜出该单词。用户单回合的得分是所有三个尝试中的最高分，每个用户的最终累积得分是所有带注释的句子中分的总和。该最终分数确定了游戏结束时（在预定的截止日期之后）的获胜者和亚军，他们两人都分别获得了亚马逊代金券。在游戏过程中，不会为用户提供确切的“当前最高得分”表，而是会为他们提供比其当前得分更低的所有得分的所有用户所占的百分比</p>
<h3 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h3><p>visual grounding of words</p>
<p>language grounding</p>
]]></content>
      <categories>
        <category>cross-modal</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
      </tags>
  </entry>
  <entry>
    <title>Multi-task Collaborative Network for Joint Referring Expression Comprehension and Segmentation</title>
    <url>/2020/03/30/Multi-task-Collaborative-Network-for-Joint-Referring-Expression-Comprehension-and-Segmentation/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>Multi-Label Image Recognition with Graph Convolutional Networks</title>
    <url>/2019/08/02/Multi-Label-Image-Recognition-with-Graph-Convolutional-Networks/</url>
    <content><![CDATA[<h3 id="Motivation：建模-label-之间的依赖"><a href="#Motivation：建模-label-之间的依赖" class="headerlink" title="Motivation：建模  label 之间的依赖"></a>Motivation：建模  label 之间的依赖</h3><ul>
<li>使用GCN来建模label之间的依赖</li>
<li>有向图</li>
<li>每个节点用 label 的词向量来表达</li>
</ul>
<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><h4 id="GCN"><a href="#GCN" class="headerlink" title="GCN"></a>GCN</h4><ul>
<li><p>GCN 的输入：GCN 的 输入是label的word embedding，使用预训练的glove vector，如果label 是含有多个词的，那么对这多个词的词向量取平均，</p>
</li>
<li><p>GCN的输出<code>C*D</code>是为了得到一个分类器，<code>C</code>是类别数，<code>D</code>是image representation的维度，</p>
</li>
<li><p>邻接矩阵：a<sub>ij</sub>用条件概率来表示：当label<sub>i</sub>出现时，label<sub>j</sub>出现的概率，因此这不是一个对称矩阵，具体地论文中还给出了更加细节的修改。</p>
</li>
</ul>
<h4 id="image-representation"><a href="#image-representation" class="headerlink" title="image representation"></a>image representation</h4><ul>
<li>使用 ResNet101 得到 conv5层的输出，再经过全局池化得到一个<code>D</code>维度的特征向量</li>
</ul>
<h4 id="multi-label-classifier"><a href="#multi-label-classifier" class="headerlink" title="multi-label classifier"></a>multi-label classifier</h4><ul>
<li>将上两步的输出进行矩阵相乘，就可以得到 计算的multi-label</li>
</ul>
<p><img src="https://i.loli.net/2019/08/03/cdwYEWSF9q6tk3p.png" alt="搜狗截图20190802221229.png"></p>
<h3 id="不同点-vs-semi-supervised-gcn"><a href="#不同点-vs-semi-supervised-gcn" class="headerlink" title="不同点 vs semi-supervised gcn"></a>不同点 vs semi-supervised gcn</h3><p>1.</p>
<ul>
<li>不同于一般的GCN，输入节点的特征，和边，经过GCN之后，得到的是更新后的节点特征</li>
<li>本文GCN的输出<code>C*D</code>是为了得到一个分类器，<code>C</code>是类别数，<code>D</code>是image representation的维度，</li>
<li>GCN 的 输入是label的word embedding，使用预训练的glove vector，如果label 是含有多个词的，那么对这多个词的词向量取平均</li>
</ul>
<p>2.</p>
<ul>
<li>一般的GCN的邻接矩阵是预先定义好的，</li>
<li>但是本文的邻接矩阵：need to construct the <code>A</code> from scrach</li>
</ul>
]]></content>
      <categories>
        <category>图卷积网络</category>
      </categories>
      <tags>
        <tag>图卷积网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Multimodal Transformer for Multimodal Machine Translation</title>
    <url>/2021/02/26/Multimodal-Transformer-for-Multimodal-Machine-Translation/</url>
    <content><![CDATA[<h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><p>多模态机器翻译任务，是从其他模态中引入信息（一般是静态的图像）来提高翻译质量。先前的方法没有考虑多个模态的相对重要性，它们常常平等对待文本和图像信息，并分别编码，但是这种方式，将会导致从图像中<strong>引入许多无关的信息</strong>。</p>
<p>在本文中，提出了一个multi-modal self-attention in Transformer 来解决上述的问题。本文提出的方法能够based on text to encode vision, 从而避免了编码图像中与文本无关的信息。</p>
<h1 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h1><ul>
<li>The focus of our work is to build a powerful encoder to incorporate the information from other modality.</li>
</ul>
<p><img src="https://i.loli.net/2021/02/26/4AnNwV85DpBkqZm.png" alt="image-20210226172540508" style="zoom:50%;"></p>
]]></content>
      <categories>
        <category>cross-modal</category>
        <category>image-guided MT</category>
      </categories>
      <tags>
        <tag>cross-modal,image-guided MT</tag>
      </tags>
  </entry>
  <entry>
    <title>N-Gram模型</title>
    <url>/2020/10/27/N-Gram%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>转载：<a href="https://zhuanlan.zhihu.com/p/32829048" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32829048</a></p>
<h2 id="一、什么是n-gram模型"><a href="#一、什么是n-gram模型" class="headerlink" title="一、什么是n-gram模型"></a><strong>一、什么是n-gram模型</strong></h2><p>N-Gram是一种基于统计语言模型的算法。它的基本思想是将文本里面的内容按照字节进行大小为N的滑动窗口操作，形成了长度是N的字节片段序列。</p>
<p>每一个字节片段称为gram，对所有gram的出现频度进行统计，并且按照事先设定好的阈值进行过滤，形成关键gram列表，也就是这个文本的向量特征空间，列表中的每一种gram就是一个特征向量维度。</p>
<p>该模型基于这样一种假设，第N个词的出现只与前面N-1个词相关，而与其它任何词都不相关，整句的概率就是各个词出现概率的乘积。这些概率可以通过直接从语料中统计N个词同时出现的次数得到。常用的是二元的Bi-Gram和三元的Tri-Gram。</p>
<p>说完了n-gram模型的概念之后，下面讲解n-gram的一般应用。</p>
<h2 id="二、n-gram模型用于评估语句是否合理"><a href="#二、n-gram模型用于评估语句是否合理" class="headerlink" title="二、n-gram模型用于评估语句是否合理"></a><strong>二、n-gram模型用于评估语句是否合理</strong></h2><p>如果我们有一个由 m 个词组成的序列（或者说一个句子），我们希望算得概率 $P(w_1, w_2,…,w_m)$，根据链式规则，可得</p>
<p><img src="https://i.loli.net/2020/10/27/ye3X8vh6LcKTzjr.png" alt="image-20201027172437915"></p>
<p>这个概率显然并不好算，不妨利用马尔科夫链的假设，即当前这个词仅仅跟前面几个有限的词相关，<strong><em>因此也就不必追溯到最开始的那个词，这样便可以大幅缩减上述算式的长度\</em></strong>。即</p>
<p><img src="https://i.loli.net/2020/10/27/XjDPInlQY9GN7ZU.png" alt="image-20201027172458291" style="zoom: 67%;"></p>
<p><strong><em>这个马尔科夫链的假设为什么好用？我想可能是在现实情况中，大家通过真实情况将n=1，2，3，….这些值都试过之后，得到的真实\</em></strong>的效果和时间空间的开销权衡之后，发现能够使<strong><em>用。\</em></strong></p>
<p>下面给出一元模型，二元模型，三元模型的定义：</p>
<p>当 n=1, 一个一元模型（unigram model)即为 ：</p>
<p><img src="https://i.loli.net/2020/10/27/UMNPucLtdw3zxgo.png" alt="img"></p>
<p>当 n=2, 一个二元模型（bigram model)即为 ：</p>
<p><img src="https://i.loli.net/2020/10/27/UmZkyzIK4fws7Nj.png" alt="img"></p>
<p>当 n=3, 一个三元模型（trigram model)即为</p>
<p><img src="https://i.loli.net/2020/10/27/Vr1LZIG7snCvokK.png" alt="img"></p>
<p>然后下面的思路就很简单了，在给定的训练语料中，利用贝叶斯定理，将上述的条件概率值（<strong>因为一个句子出现的概率都转变为右边条件概率值相乘了</strong>）都统计计算出来即可。下面会给出具体例子讲解。这里先给出公式：</p>
<p><img src="https://i.loli.net/2020/10/27/locAQnW9bGpXa3K.png" alt="img"></p>
<p>对第一个进行解释，后面同理,如下：</p>
<p><img src="https://i.loli.net/2020/10/27/iGbljDacPTSWu92.png" alt="image-20201027172711422"></p>
<p>下面给出具体的例子。</p>
<h2 id="三、二元语言模型判断句子是否合理"><a href="#三、二元语言模型判断句子是否合理" class="headerlink" title="三、二元语言模型判断句子是否合理\"></a><strong><em>三、二元语言模型判断句子是否合理\</em></strong></h2><p><strong><em>下面例子来自于：\</em></strong><a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/baimafujinji/article/details/51281816" target="_blank" rel="noopener">自然语言处理中的N-Gram模型详解 - 白马负金羁 - CSDN博客</a>和《北京大学 常宝宝 以及 The University of Melbourne “Web Search and Text Analysis” 课程的幻灯片素材》</p>
<p>假设现在有一个语料库，我们统计了下面的一些词出现的数量</p>
<p><img src="https://i.loli.net/2020/10/27/ufWOseUyrAm9qV3.png" alt="img"></p>
<p>下面的这些概率值作为已知条件：</p>
<p><img src="https://i.loli.net/2020/10/27/G2Y6zKZNxBCitVo.png" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-a7c0d77143e0c997abd45e1535eaeb8c_1440w.jpg" alt="img"></p>
<p>$p(want|<s>) = 0.25$</s></p>
<p>下面这个表给出的是基于Bigram模型进行计数之结果</p>
<p><img src="https://i.loli.net/2020/10/27/G2Y6zKZNxBCitVo.png" alt="img"></p>
<p><img src="https://i.loli.net/2020/10/27/az7ewSWFYZGUbIu.png" alt="img"></p>
<p>例如，其中第一行，第二列 表示给定前一个词是 “i” 时，当前词为“want”的情况一共出现了827次。据此，我们便可以算得相应的频率分布表如下。</p>
<p><img src="https://i.loli.net/2020/10/27/9WhUqaZtcC3xDn7.jpg" alt="img"></p>
<p>比如说，我们就以表中的$p(eat|i)=0.0036$这个概率值讲解，从表一得出“i”一共出现了2533次，而其后出现eat的次数一共有9次，$p(eat|i)=p(eat,i)/p(i)=count(i,eat)/count(i)=9/2533 = 0.0036$</p>
<p>下面我们通过基于这个语料库来判断$s1=“<s> i want english food</s>” $ 与 $s2 = “<s> want i english food</s>“$哪个句子更合理：通过例子来讲解是最人性化的，我在网上找了这么久发现这个例子最好：</p>
<p><strong>首先来判断$p(s1)$</strong></p>
<p>$P(s1)=P(i|<s>)P(want|i)P(english|want)P(food|english)P(</s>|food)$</p>
<p>=$0.25×0.33×0.0011×0.5×0.68=0.000031$</p>
<p><strong>再来求$p(s2)$</strong></p>
<p>$P(s2)=P(want|<s>)P(i|want)P(english|want)P(food|english)P(</s>|food)$</p>
<p>=$0.25×0.0022×0.0011×0.5×0.68 = 0.00000002057$</p>
<p><strong>通过比较我们可以明显发现0.00000002057&lt;0.000031,也就是说s1= “i want english food&lt;/s&gt;”更像人话。</strong></p>
<p><strong>再深层次的分析，我们可以看到这两个句子的概率的不同，主要是由于顺序i want还是want i的问题，根据我们的直觉和常用搭配语法，i want要比want i出现的几率要大很多。所以两者的差异，第一个概率大，第二个概率小，也就能说的通了。</strong></p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Neural Machine Translation with universal Visual Representation</title>
    <url>/2021/03/03/Neural-Machine-Translation-with-universal-Visual-Representation/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>为了降低Multi-modal NMT对有图像标注的翻译数据集的依赖，本文提出通过建立Topic-image Lookup Table的方式更高效地利用已有图像文本数据，并且在训练和测试NMT的时候通过Image Retrieval的方式获得图像信息，从而在更大规模的数据上训练Multi-modal NMT。</p>
<p>通过Retrieval的方式来扩充数据的工作其实有很多，比如这篇：<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1904.02331" target="_blank" rel="noopener">Extract and Edit: An Alternative to Back-Translation for Unsupervised Neural Machine Translation</a>。</p>
<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p>长期以来，机器翻译都只涉及到文本之间的转换，但实际上，人的感知功能可以是“多模态”的。</p>
<p><strong>本文提出一种通用的视觉表征，将图片信息融合到机器翻译模型中。</strong></p>
<p>使用这种视觉知识融合方法，<strong>不需要额外的<strong style="color:red;">双语-图片</strong>标注数据，模型就能够在多个数据集上取得显著的效果提升。</strong></p>
<h3 id="多模态与机器翻译"><a href="#多模态与机器翻译" class="headerlink" title="多模态与机器翻译"></a><strong>多模态与机器翻译</strong></h3><p>机器翻译是两种语言间的转换，比如“A dog is playing in the snow”翻译为中文就是“小狗在雪地里玩耍”。</p>
<p>但人类理解世界不只是用文字，还有视觉、听觉等感知能力；并且<strong style="color:blue;">翻译的过程需要保持“语义”不变</strong>。比如下面的图：</p>
<p><img src="https://i.loli.net/2021/03/03/31QcdLfykOoiCEX.jpg" alt="img" style="zoom:50%;"></p>
<p>讲中文的人会说“小狗在雪地里玩耍”，而讲英文的人会说“A dog is playing in the snow”。也就是说，人们对客观世界的本质认知是相同的，只是“方法”不同，体现在语言上，就是语法上的差异。</p>
<p>为此，我们可以假设<strong style="color:blue;">在机器翻译模型中，融入这种“客观的世界知识”，比如把图片信息加入，以此期望增强翻译能力。</strong>同时考虑文本和图片，这就是一种多模态。</p>
<p>然而，过去的翻译-图片研究大都需要大量的双语-图片标注数据，这在数据上成为一个研究的瓶颈。本文针对这种情况，<strong>提出“通用的视觉表示”，<strong style="color:red;">仅用单语-图片标注数据</strong>，就能显著提高机器翻译的效果。</strong></p>
<p>本文的方法<strong>在数据集EN-RO，EN-DE，EN-FR上均有约一个BLEU值的提高</strong>，这说明了本方法的有效性。</p>
<h3 id="本文贡献"><a href="#本文贡献" class="headerlink" title="本文贡献"></a>本文贡献</h3><ul>
<li>提出一种通用的视觉表示方法，无需双语-图片标注语料；</li>
<li>该方法<strong>可以在只有文本的数据集上使用</strong>；</li>
<li>实验证明了该方法效果提升的一致性。</li>
</ul>
<h3 id="通用视觉表示"><a href="#通用视觉表示" class="headerlink" title="通用视觉表示"></a><strong>通用视觉表示</strong></h3><p>首先我们有一个单语-图片数据集 $\mathcal{S}=\{X, E\}$，也就是，其中的每条数据都是一张图片 $e$ 和对图片的描述 $X_{e}=\left\{x_{1}, \cdots, x_{I}\right\},$ 把其中的停用词去掉后得到了 $X_{e}^{\prime}=\left\{x_{1}^{\prime}, \cdots, x_{J}^{\prime}\right\}$ 。</p>
<p>然后, 对 $X_{e}^{\prime}$ 中的每个词 $x_{j},$ 计算它在整个数据集 $\mathcal{S}$ 中的TF-IDF值， 然后取 $X_{e}^{\prime}$ 中TF-IDF值最大的前 $w$个词作为这个图片 $e$ 的主题词 $T_{e}$, 也就是和图片最相关的 $w$ 个词。</p>
<p>这样一来，<strong>每个图片e都有它主题词</strong> $T_{e},$ 同时，<strong>每个词都有可能同时是多个图片的主题词</strong>。我们可以把这看成一个 “主题词-图片” 查询表，输入一个词 $t$ ，就可以在表中查询以 $t$ 为主题的所有图片 $E_{t}=\left\{e_{1}, \cdots, e_{n}\right\}$。</p>
<p>那么，现在输入一个句子，我们就可以按照同样的步骤：</p>
<p>1.去除停用词；</p>
<p>2.计算每个词的TF-IDF；</p>
<p>3.取前$w$个TF-IDF最高的词；</p>
<p>4.在查询表中找到所有对应的图片；</p>
<p>5.按照出现次数的多少排序，取出前$m$个出现次数最多的图片（因为多个词可能对应同一个图片），得到集合 $G$</p>
<p>现在，这个图片集合 $G$ 就可以认为是和输入句子对应的视觉信息，可以用它去增强翻译效果了。下图是流程示意图：</p>
<p><img src="https://i.loli.net/2021/03/03/wMeWCU7jfD4NqIO.png" alt="image-20210303203731211" style="zoom: 50%;"></p>
<h3 id="在机器翻译中融合图片信息"><a href="#在机器翻译中融合图片信息" class="headerlink" title="在机器翻译中融合图片信息"></a><strong>在机器翻译中融合图片信息</strong></h3><p>为了把图片融合进去，我们首先用一个预训练的ResNet提取图片集$G$ 的表示，然后计算 $\bar{H}=$ Self-Attention $\left(H^{L}, K_{G}, V_{G}\right)$ 与 $H=H^{L}+\lambda \bar{H}$<br>这里, $H^{L}$ 是Transformer Encoder的最后一层, $K_{G}, V_{G}$ 是用ResNet得到的图片集的表示, $\lambda$ 使用<br>sigmoid 计算。<br>在Decoder端，直接把 $H$ 送入即可。融合步骤如下所示：</p>
<p><img src="https://i.loli.net/2021/03/03/SWYB4lDXt7ysVrO.png" alt="image-20210303204216912" style="zoom:50%;"></p>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a><strong>实验</strong></h3><p>我们在三个数据集上进行实验：WMT16 En-RO, WMT14 EN-DE和WMT14 EN-FR。这三个数据集大小从小到大增加，从而在不同大小的数据集上都能验证该方法。</p>
<p>下表是在这三个数据集上的结果，++表示显著更优。</p>
<p>可以看到，和基线模型(Trans.(base/big))相比，本文的方法(+VR)在三个数据集上都能得到显著的提升，平均提升约一个BLEU值。同时，只引入了很少的参数量，这就不会使训练时间几乎不会增加。</p>
<p><img src="https://i.loli.net/2021/03/03/F8z9SReVPkuNdov.png" alt="image-20210303205316435" style="zoom:33%;"></p>
<p>下表是在数据集Multi30K上的结果，这是一个多模态数据集。可以看到，即使在多模态设置下，本文方法依旧能够取得显著结果。</p>
<p><img src="https://i.loli.net/2021/03/03/taQRuKN6ElJYbLg.png" alt="image-20210303205337060" style="zoom:33%;"></p>
<p>最后，我们来看看每个句子对应的图片集 $G$ 的大小 $m$, 和手动控制参数 $\lambda$ 的影响。下图分别是两个因素的影响结果。从图片数量来看，并不是越多的图片数量越好, 也不是越少越好,而是在 $m=5 \sim 15$ 的区间较好。这是因为， <strong>过少的图片信息不充分, 过多的图片噪声太多。</strong></p>
<p>参数$\lambda$控制的是图片信息融合的程度，可以看到，无论融合多少，效果都比不融合图片信息要好，这说明多模态是有效果的。</p>
<p>而且，手动控制它都没有模型自动学习好，这也说明模型对不同的输入句子，需要的视觉信息也是不同的。</p>
<p><img src="https://i.loli.net/2021/03/03/De8nVYPabyIrBwE.png" alt="image-20210303205616909" style="zoom:33%;"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>本文提出了一种简单、有效的多模态视觉知识融合方法——首先构建从主题词到图片的查询表，然后对输入句子找到相关的图片，然后使用ResNet提取图片信息融入到机器翻译模型中。</p>
<p>使用这种方法，可以避免对大规模双语-图片数据的依赖。实验结果也表明，这种方法可以一致地提高翻译效果。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul>
<li><p>如果要翻译单语-图片数据集中没有的语言，可以怎么做？</p>
<p>比如$S$没有日语，我们可以用一个日语的image caption模型去自动标注每个图片的描述。</p>
<p>或者可以用X-日语的机器翻译得到图片翻译后的描述；或者直接用一个现有的词典，把图片的主题词直接翻译成日语。其他方法亦可。</p>
</li>
<li><p>在融合步骤，是否可以有其他的方法进行融合？</p>
<p>另外一个简单的方法是，把ResNet得到的图片表示和句子一起，送入Encoder，再像往常一样解码。</p>
</li>
<li><p><strong>你认为本文这种方法从逻辑上是否真的有效？为什么？</strong></p>
<p>见仁见智，笔者倾向于有效，但是作用不大，因为只从模型的角度难以验证图片和文本之间语义的相关性，至于效果的提升，有可能是ResNet和Aggregate的共同结果。</p>
<p>笔者认为，可以考虑加一个图片预测描述的任务，和翻译一起学习；再将ResNet替换为普通的CNN进行实验。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>cross-modal</category>
        <category>image-guided MT</category>
      </categories>
      <tags>
        <tag>cross-modal,image-guided MT</tag>
      </tags>
  </entry>
  <entry>
    <title>NLP: 自编码 and 自回归</title>
    <url>/2020/03/24/NLP-%E8%87%AA%E7%BC%96%E7%A0%81-and-%E8%87%AA%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<ul>
<li><p><a href="https://www.infoq.cn/article/4SRM7UMVS4GdD9A90wff" target="_blank" rel="noopener">https://www.infoq.cn/article/4SRM7UMVS4GdD9A90wff</a>      </p>
</li>
<li><p>这篇博文写的不错<br><a href="https://www.infoq.cn/article/4SRM7UMVS4GdD9A90wff" target="_blank" rel="noopener">https://www.infoq.cn/article/4SRM7UMVS4GdD9A90wff</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Neural Motifs: Scene Graph Parsing with Global Context</title>
    <url>/2019/09/18/Neural-Motifs-Scene-Graph-Parsing-with-Global-Context/</url>
    <content><![CDATA[<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><ul>
<li>给出了一个对 repeated structures 的量化分析</li>
<li>分析显示，（1）由object label对预测 relation label是有效的，但是反之却不成立。（2）在一个image graph中会出现重复的模板（eg：大象有耳朵，大象有鼻子，  XX has YY）</li>
</ul>
<h2 id="Models"><a href="#Models" class="headerlink" title="Models"></a>Models</h2><ul>
<li>给定 object feature 和 object label 来去预测 relation label</li>
</ul>
]]></content>
      <categories>
        <category>场景图解析</category>
      </categories>
      <tags>
        <tag>场景图解析</tag>
      </tags>
  </entry>
  <entry>
    <title>Non-Autoregressive Coarse-to-Fine Video Captioning</title>
    <url>/2021/03/19/Non-Autoregressive-Coarse-to-Fine-Video-Captioning/</url>
    <content><![CDATA[<p>发表在AAAI 2021</p>
<h2 id="现在存在的问题"><a href="#现在存在的问题" class="headerlink" title="现在存在的问题"></a>现在存在的问题</h2><ul>
<li>由于自回归解码（autoregressive decoding）导致的 <strong>slow inference speed</strong> </li>
<li>由于对视觉单词的训练不充分，而使得模型更加<strong>偏向于生成泛化性句子</strong>，缺乏细节和多样性。</li>
<li>此外，具有误差累积倾向的模型产生令人满意的字幕是具有挑战性的。 因此，还需要一种<strong>支持单词修改的灵活解码范例</strong>（decoding paradigm）。</li>
</ul>
<h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><p><img src="https://i.loli.net/2021/03/22/Kyegni76dZ4kCrH.png" alt="image-20210322164100678" style="zoom:33%;"></p>
<ul>
<li>我们提出了一种具有粗略至精细 （coarse-to-fine）字幕过程的基于非自回归解码（nonautoregressive<br>decoding）的模型</li>
<li><p><strong>For achieving inference speedup</strong>：employ a bi-directional self-attention based network as our language model for achieving inference speedup</p>
</li>
<li><p><strong>For improving caption quality：</strong>propose an alternative paradigm to decompose the captioning procedure into two stages,</p>
</li>
</ul>
<h2 id="Other-non-autoregressive"><a href="#Other-non-autoregressive" class="headerlink" title="Other non-autoregressive"></a>Other non-autoregressive</h2><ul>
<li>Masked Non-Autoregressive Image Captioning</li>
<li>Non-Autoregressive Image Captioning with Counterfactuals-Critical Multi-Agent Learning</li>
</ul>
<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><ul>
<li>看看这篇论文是如何获得 tags of video</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Object Hallucination in Image Captioning </title>
    <url>/2020/03/25/Object-Hallucination-in-Image-Captioning/</url>
    <content><![CDATA[<h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><ul>
<li>当前captioning task 存在的问题<ul>
<li>当前的caption model 目前存在的问题是，生成的句子中出现的object 常常是在corresponding vision scene 中没有出现到的。</li>
<li>当前使用的评价指标只能评估 candidate caption 与 gt captions 之间的一个相似性，不能捕捉到candidate caption 与 image information之间的relevance. </li>
</ul>
</li>
</ul>
<ul>
<li>因此本文进行的一个工作：<ul>
<li>We analyze how captioning model architectures and learning objectives contribute to object hallucination, explore when hallucination is likely due to image misclassification or language priors, and assess how well current sentence metrics capture object hallucination.  </li>
</ul>
</li>
</ul>
<h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><ul>
<li><p>（一）关于 object hallucination 的四点讨论</p>
<ul>
<li><p>从人类的角度</p>
<ul>
<li>丢失对显著物体的描述是一个 failure mode，但是captions is summaries，<strong>因此一般不期待其描述出场景中的所有的objects.</strong> 另外在人类的标注数据中，也不偏向于标注出所有出现在scene 中的objects</li>
<li>研究报告表明，human judgements 比较不待见那些caption中包含了image content中未出现的 object，<strong>Correctness is more important to human judges than specificity.   </strong></li>
<li>Many visually impaired who <strong>value correctness over coverage, </strong>hallucination is an obvious concern.  </li>
</ul>
</li>
<li>从模型的角度<ul>
<li>object hallucination  揭示了caption model 存在的一个问题，可能caption model并没有对视觉场景学习到一个很好的视觉表征，而是对损失函数过拟合。</li>
</ul>
</li>
</ul>
</li>
<li><p>（二）本文要研究的问题</p>
<ul>
<li>本文研究当前captioning models中存在的object hallucination现象</li>
<li>考虑了几个关键问题：<ul>
<li>(1) <strong>Which models are more prone to hallucination?</strong>  spanning different architectures and learning objectives.   <ul>
<li>一个新的评价指标来评估object hallucination：CHAIR (Caption Hallucination Assessment with Image Relevance)  </li>
</ul>
</li>
<li>(2) <strong>What are the likely causes of hallucination?   </strong><ul>
<li>造成object hallucination这一现象的原因主要有两点：visual misclassification and over-reliance on language priors  <ul>
<li>提出：image and language model consistency scores  </li>
</ul>
</li>
</ul>
</li>
<li>(3) <strong>How well do the standard metrics capture hallucination?</strong>  <ul>
<li>当前的评价指标并不能很好的捕捉到object hallucination 这一现象。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><h5 id="CHAIR-Metric"><a href="#CHAIR-Metric" class="headerlink" title="CHAIR Metric"></a>CHAIR Metric</h5><ul>
<li>同时使用GT sentence 和 coco image segmentation这两个信息 to measure object hallucination。</li>
</ul>
<p>  <img src="http://ww1.sinaimg.cn/large/006uWRWVly1gd7d25xmjcj30h605k0te.jpg" alt="搜狗截图20200326152719.png"></p>
<h5 id="Image-Consistency"><a href="#Image-Consistency" class="headerlink" title="Image Consistency"></a>Image Consistency</h5><ul>
<li>对比 <strong>caption model 与 image (alone) model</strong> 两个模型对于预测objects 之间的一致性误差。</li>
</ul>
<h5 id="Language-Consistency"><a href="#Language-Consistency" class="headerlink" title="Language Consistency"></a>Language Consistency</h5><ul>
<li>对比 <strong>caption model 与 sentence (alone) model</strong> 两个模型对于预测下一个word 之间的一致性误差。</li>
</ul>
<h4 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h4><h5 id="Which-Models-Are-More-Prone-To-Hallucination"><a href="#Which-Models-Are-More-Prone-To-Hallucination" class="headerlink" title="Which Models Are More Prone To Hallucination?"></a>Which Models Are More Prone To Hallucination?</h5><ul>
<li>一般情况下 ，在标准的evaluation metrics 上表现性能好的模型，在CHAIR metric 上也能表现的比较好，即object hallucination现象相对较弱。但是当模型基于 cider 进行强化学习的训练之后，则不是这种一致的现象。</li>
<li>（1）使用attention 的模型更加偏向于有较低的object hallucination；NBT模型在标准的evaluation metrics 上表现性能没有topdown-BB 好，但是CHAIR性能却更好，原因在于其使用的pre-trained  detector 与 captioning dataset is in a same domain 。</li>
<li>（2）当模型基于 cider 进行强化学习的训练之后，将会增加hallucination 的数量。</li>
<li>（3）LRCN Model 比 FC Model有更多的object hallucination，说明仅仅在第一个 time step 输入视觉特征，将会产生更少的object hallucination </li>
<li>（4）the GAN loss actually helps decrease hallucination.  the GAN loss encourages sentences to be human-like。</li>
<li>（5）CE loss: beam size 5, object hallucination 会比 lower beam size 小很多；self-critical loss: beam size sometimes leads to worse performance on CHAIR.   即object hallucination 数量会更多。</li>
</ul>
<h5 id="What-Are-The-Likely-Causes-Of-Hallucination"><a href="#What-Are-The-Likely-Causes-Of-Hallucination" class="headerlink" title="What Are The Likely Causes Of Hallucination?"></a>What Are The Likely Causes Of Hallucination?</h5><ul>
<li><p>We rely on the deconstructed TopDown models to analyze the impact of model components on hallucination  </p>
<ul>
<li>通过设计的 几个 deconstructed TopDown models 的分析可以看出，使得object hallucination 数量减少的原因是：due to access to feature maps with spatial locality, not the actual attention mechanism.  </li>
<li>LRCN Model 比 FC Model 有更多的object hallucination，说明仅仅在第一个 time step 输入视觉特征，将会产生更少的object hallucination 。作者在文中对这一现象给出的解释是，在每一步都输入视觉特征 fc_feature, 而不是 spatial feature, 这将导致对视觉特征的过拟合。</li>
</ul>
</li>
<li><p>Investigate what causes hallucination using the deconstructed TopDown models and the image consistency and language consistency scores. </p>
<ul>
<li>We note that models with less hallucination tend to make errors consistent with the image model, whereas models with more hallucination tend to make errors consistent with the  language model.  这说明有更少object hallutition 的models 有更强的能力从Image 中提取知识到句子生成过程中。</li>
<li>在Robust split 上进行实验发现，所有models之间的language consistency 差异度不大；相比于 Karpathy split，相对应下的models image consistency 有所下降。这是由于 Robust split 在测试集上，会出现 novel compositions of objects at test time. 使得所有的模型有很强的language prior.</li>
</ul>
</li>
<li><p>在训练过程中，分析FC model 的image/language consistency，结果发现在训练开始，与language model 的一致性更好，随着训练的结束，与 image model 的一致性更好。这说明，模型首先学习生成流畅的语言，而后再去学习结合视觉信息。</p>
<h5 id="How-Well-Do-The-Standard-Metrics-Capture-Hallucination"><a href="#How-Well-Do-The-Standard-Metrics-Capture-Hallucination" class="headerlink" title="How Well Do The Standard Metrics Capture Hallucination?"></a>How Well Do The Standard Metrics Capture Hallucination?</h5></li>
<li><p>作者分析了 standard metric 与 CHAIRs  之间的 pearsom correlation coefficient ，结果发现 SPICE 的一致性更好。</p>
</li>
<li><p>object hallucination can not be always predicted based on the traditional sentence metrics.  </p>
</li>
<li><p><strong>与当前使用的standard metrci 互为补充，可以提升与人类评分的一致程度。</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gd8997jm24j30gi08375g.jpg" alt="搜狗截图20200327100117.png"></p>
<p>这个意思是说，第一列，单独分析各个automatic metric 与 human judgement 的一致性。第二/三列，各个评价指标分别加上1-CHs/ 1-CHi 之后再与human judgement 计算一致性。可以发现，一致性得到提升。即 <strong>CHAIR is complementary to standard metrics</strong></p>
</li>
</ul>
<h5 id="Does-hallucination-impact-generation-of-other-words"><a href="#Does-hallucination-impact-generation-of-other-words" class="headerlink" title="Does hallucination impact generation of other words?"></a>Does hallucination impact generation of other words?</h5><ul>
<li>Hallucinating objects 影响句子生成的质量，不仅是由于 object 没有被正确的预测，也是由于hallucinated word 影响到了生成的其他的words.</li>
<li>通过比较TopDown 和 TD-Restrict 生成的句子可以分析这个现象。We find that after the hallucinated word is generated, the following words in the sentence are different 47.3% of  the time.  </li>
<li>一旦一个hallucination words 被生成，则其又会由于language prior(hallucinating a “cat” leading to hallucinating<br>a “chair”  )，产生更多的hallucination words 。</li>
</ul>
<h4 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h4><ul>
<li><p>the popular self critical loss increases CIDEr score, but also the amount of hallucination. </p>
</li>
<li><p>CHAIR complements the standard sentence metrics in capturing human preference( judgements ).  </p>
</li>
<li><p>Models with stronger image consistency frequently hallucinate fewer objects, suggesting that strong visual processing is important for  avoiding hallucination.  </p>
</li>
<li><strong>Advises for captioning task:</strong> 仅使用CE-loss/ standard sentence metrics来优化，不太能解决object hallucination 这个问题，若同时以 image relevance 来优化，会更好。</li>
</ul>
<h4 id="yaya-总结"><a href="#yaya-总结" class="headerlink" title="yaya 总结"></a>yaya 总结</h4><ul>
<li>在设计评价指标上给我的几点启发<ul>
<li>(1) 不需要要求machine generated caption 可以概括所有的objects which have been occurred in the vision scene</li>
<li>(2) machine generated caption 进行评价时，正确性比全面性更加重要</li>
</ul>
</li>
<li><p>本文的一个巧妙的点</p>
<ul>
<li>本文为了查看object hallucination，使用COCO的80个类。对于candidata caption 首先将其token， 然后调整成单数形式，然后使用同义词的思想，去跟COCO 的80个类别进行匹配。</li>
<li>另外对于GT sentences，也提出一个list，这个地方不太知道它说的什么意思？？？？？  </li>
</ul>
</li>
<li>GVD 好像也类似的提到过类似的思想</li>
<li>关于the image consistency and language consistency scores.<ul>
<li>在这个得分的计算方式上，是否还有什么可以改进的地方？</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>图像描述</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>Object Relational Graph with Teacher-Recommended Learning for Video Captioning</title>
    <url>/2021/03/13/Object-Relational-Graph-with-Teacher-Recommended-Learning-for-Video-Captioning/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
U2FsdGVkX19WOFURl3uWyFVqgyfsNL5fqfIq6/xuk+QgBX0OgH2t8rnkodSC3HWPl19G2SABv7+ULseOyosXhF4tQ+wMy8SwEW4YO10QmqyoJyWuix+roPE6TdPcnaXRA99lX1cJBN42x0+bk/BGIYtPOFaYqFUc/GqLqGlcuf5e4kK+NtO9Uo3vOYOj9LahmkVehPHfFbz7l0v16BUND2Azajus/Au54zFxn8yK1tJeuS/AC+xz9oaSnUdZn7RhTZcLW4L/A8PW2Q1B6VUuahi7WCTtkH0b4EQZNTdUrDCS0PPS80ZGrfpLb1/GO+bkcuSrKxpbDGAE1KW1Hys5MeKvkvXDSKsg/2HNg+TRkypF0ArX8UDqqInEQi1g/04IAfaExSPH2MAbOfcMN0SeqT1Eem4MeoYeYlIJfrSVnzn/pWg1L4YTtxwkn6kK1AlpjiJBwpPGgJTVbiuIKaFGleaadUiVN/r8Tdlq9U9NnsyUfUjnur2KS+w/H/C0qLjxb/XRpRNgEJZ1XMdN0BqlFh4c/UaRf7WkOBIHPDJwMg5wUqctNwtXcJ3gUeCAJgUc2S83sfxI0lpoKT6ka4G0ytwYoPGxD7Ug1TDmB8sVKSG0rIRD2w9zVYjUVLvwzRObtDI3Qgz38E2+D44TnwcXMvEAU3CHWeHbiS3+S/kC1Io/AkEM8rNm+ampQbtaYhcUHvUs90CfTjad9FA0qM4S+qD8ehRjp3Wj8ps+9V74rBxD1HW02fHqJzbWIt8RjoD4w4FMjtdEjIRMBYqtua5nSGctKo/cq9FG4BDim+R68aJBSmVMrOwS28IoPVV47wLPV5UAuf2IOIE6BgKPZCnJnd9k0OC72p1qFRmxWMfYMqPC+MoaV5QwE0rq+Ph/VK602P3cbYaTUplrOeTy4DYIRfFwoyDCZHoBj0GSso/hjTOyp7bzbBiDqTZeo9aiJmAEsI71MamVoQRo89gp0tfkx/1ye1i9wBPJkMVdk7wE2f8qXsrLAJ+QDrhaZLbOWdGle3GbFA7f5rj6A5F5bYJxiNF5xZUlF/leGDAwgIIt9TH3m2hvIwEmh0aqyMn1ktLrtMl2F4FvKu+VXPX8fVYzso2QgArNUx85T2C8TbtT1seVaUBAghWg4Qt3x1rXHbdny65gxHjkb6cedRuE6LGPCpy/jP/kbMcZ7hQCF7iF9r0yrOvMnfcG85RyzjEEr0fvfYQsfKZWO8J8W+lmA2qLO4tuPnG6NJFuPZ1QdhZW/Vh8TAAbDz7reKXw16KrgS8GNAgcxV+H9c2gOZe0Q72BRkFX/Meg1NiT3T1ETduk+OAY02KJUjHm5ao/26ifKDrlCXeXUtvWqGdGdBAi9COyAW3i+5OFktbC2A8ADYDYNVSoBqXjd7VERyDVV/WmeLmCPkJr4rBObNi5ttvwg9gurOxuRWzMbsLHp9w3g6uB827u7MoLFUDc5si0bNfsOnQItmkXYU3tuUP+F87a8jFnUyYg7kC5Vab1aq5QU6IR2/y8YTIsma0K11WnosZ0H65VAQamJ2mxECSd45IqkjvFH3MQ5nB4A3XfQHi01wPtrrEPHqZwZdUlWZct41Sssy8W9N8+OqCDksHzehYJuRlL9V0yckwD6Tqtorzb/PmrYp+NpliS55OasjVL3hY2ljLlZ0uXjNIrPNb1/9yjFSQ35Ik5Qr0h8ayI7ABX9MBxNIlp8AL62AMWVUsvZ0xvrB2ViVHLYqapeGoWa8pqzwePrHrlKMnzMd2l7icRBDsS30rbESfqYSdGu96UFUDKV2k6gfw7LWx/gStuZAhNPYDT1bEng4uOfIwt5IDGBprfwxVKkapco6ESJKiN2WhFFsWI0BofJSJVzU9V/euYGqyPXvpznjmZwZe4q7hQRFLVogw5nk9SlKm67HmiSViFGAlc9gUUDq+CV3dyfznX+7ThYdhtkOJaqwyYuRghb5gfd7kH/IqZd6Xh6zB0ofDD5mSlH0THGx5g4r1ZKhbvwXTURUmoXJMdMTxZmKzNmrnlbbXtwNQQB5OPqvT25BJmaGgjMnJm3rQ63XG6HDBV4bI/yrH0+ARPtFChvp35YqbYSfmo9InvmjRnGXU+A3Oho8r1BaWzDq7ooSJkGpaOHgAwQvfp1ded27qmNaQBcsCyU10rbrSNNB3v+DEnnDtNMXgSBKblT7QD5Lf9CWi/X/DL+4U5n7LW4vAuXOSglYas0GsclYONUYgKs1h65YUsY1du/y1YlgZq6veFlxjkjrdxz/69c1tWVdd9ZXlp55sRlDQlpaSsR+JpJsvnKKpyqCng19eztoSHA2G+7Tq1oMmk/TNJutI+QfVG/9UMFjIjS4ZlsIGBaeDgMNx/0bZpoU/1hmFKCU7KBmzBH+J16BauzNWxXtktDa9Tu+ipPlaKb4lu/aEaotPikWbUvpCC8gQ/GhA0HvG5GvUAFJsqjGAFbCkgaKMmJbeJYAL+Q0gHCDNIfrW8VcbH+rpaEC6zDRpHyMLwl0YYSC3MKi2YqqYdm/O5Hjg4xW1W/iULvLeHmzl3eFDbJysodPR4LUE5qo8IgOZIrIrvgjSfAvbCk9VPoCukBNSKQ268+dCxovGvIbq1qX0FCtZVM8JtheQAg0UpJvVUSP1NdH+vvgJHWnJcEqHN/y72NveD0ayOPS3GiERcdpUtmnTtH6CQnt9ZIFnBqNuEAiPcoLd75RHJPDgYk9zL4UmyCGBmd020x+MrnJ041c6w0W64OiGUqI7O1hCia9eX/p4HXK3sgp52PZxNWXf8kBO0kqeS5PA6A8I+enTVjNHkTdbQ+vAkZlUkBrGuUqJ7qTHMhnQWA07P25QF1/SSt5RLZyJBQyfhI4KOedu3iu9iLtEptMMdOewQulOFcvCD7OJZPEdsWzucX7BzzZ9l3GtACYp+nzzsVrwzvCDWQATNMvbd5hUMBRu2NNShyhfxSX8My3AXLx2AX5nrISvB8vMLJ5rXhBikj5XnHbuBR4mAagDjgYyxH2QBIF+91m0TOOVsD/wGzKn1HTu6YESyMG7pWPm7plPjtH7HPctj/LxXwEJ2/GDyrrNYxnAdzzNxcHI46UHZNrMlZubud8lYiWfRqRw0SLEjbyUHPX3D/GaRhtrd5ZY+v8VtR1n4GvQeU07Yvf8XdwWgJC42apU4hFqSEQi3pEyITodbawraNhI5VIg3KFLF6Ey34GW/aPLYguKNpM/ruqDy6DlAnpIbtTzcrWIbRRhiw/4OimP4YcT2WiKcokq2dbVXsP+zcVzjhv6nDuPgDrtiJN0B+j7HQd6EVhTi2r92zybT3krFC58oAmg1l0fmkeTOW6/Dp5Q/E+P0ZfPqvRe2Z4LnZkeI5Umj8wDc67Tn7MvSpEOeGGuAC59KXF/o+GxArEY0pAPPtr1ZCsDfQywTSczDVkzipBkarU5QDh3O4QIoLh73mI48J64gQ6wDWwXPF7I4Vm6+9GL7oUe0Bd0b02wR4QxorTPodF9a8VpkXucP6szXyyM9q2clWFNOBFX8gptjKOnOj3ua8zsRZLJyf35aBQRbhviZaLcN9Jl1d4ZsjI28UHS8YSRV1UZb3x3J8ZJsQG00XiRBnuDMVOk37jH6X1HX1MJUtRQs7pmAEYmsBJYrxHgOnKpFzTobW/Z/yzXCYt5oRCsuRYBixg1OltibnOaEmm3KLSbYKe4q8Mo+A9kAfBIKkL/OJQpObQZSmJfqvziRik7ynihh9K2SkcEd02nm8I8h2gUTSiD+C5HKNio1qovsW+WEGb1KdwuLUX4JWlmaBzoQHt4F78w/VIEWFfgEqPSp8HyDH+KUjPakAjdZT7nRi61uXqNyzR6NUwCJCHpKhhIACFyEYb+hzuQcnOzUmr3zUiVNIxubmZglMv7Qr6su29lUhW6MaWv+UylGUGwFf1OhA27bBWhQflTr/rQakxrPSveDJtw0dmPjQ6u6dGx95Pi3NLEVkgFANlyWNQzN49AkvgQxfQ+CRkcbQ0N030NDnCb7vIng727oeL2d4Yzj3vizXFsN6JQRhPe8QTqZCwW5vJPQprjgcZRQB6CRpPhcBKHE8vs+JVpAaH2d+plzeQMcrD9kKelxCTsvrYvm7IzeVgNrOSoRC6FJPU7NQxNggO1BWeWdm1g3iFk3ZtEEBu/g9OuRatkC9K74RpZPfa9ygYFP3IF/m+ZAGVwtbJSgO/hOzwL5knRpVJ0B9/UvFyiex0rsFnqaZy+qCmdhE3fd6rW6m3rjD/w7YuJ2JyfphE34OEXrZt9Aml0xNsmaC7la7IU4OOAbuFJ0GON3TSH3SmwsM0Okj9yHTGP8WcHx17Fk7PRI3imSFSXwoCBZVvViBNfarjJZCAN/z6P5YC+F897MMhIB/XwF4RbTAnwPdFevobpNkIa0Nm2u4qEFMvT7O1o6IUHzBltN/i1dAvz8cMTbVdPTYGIXOIvmits3/2f+OR6N9qPkWxdbKilf4tv/a2uBhYnL9spOT28HRCmJoZ63EwoTrbxn6+Mas5l/LzzkH7JpLMIB0FKnN7i4E4hbfbSYymXmBjuLqlBtpjTKLpurJLT32oQaaUqZMAnGw3r/PZCzqtA/XNrLm9aAqRaOGXxFUt5GWm3PnGxkYgHJ+Hu2davGXLi7Q86H8fJB/dxUbe30Hah2Yd/nzQ+qnu9E8/ZergYvx7p0YZIicA8bqLg+MluIhbDMl0Tdm15cMT/ief6RWOVbuNTHYXq1DM122zQ8LVHJomfsv3saSsdUsJxEsEYZjBy70rOvueREb+MJ6vOmEDp829tY6nr409+hBy/wNNdNPvtI340N5sovlMwGSW1No+BASDKP/Voy0r1NxLJJSV3sSgULv29qXrMPHUNHUlZcv7TW5zmrQRexQRSQ/IHSwBtDQSkEo3Rs/l+UbKbNyrqraVaz0r14aR73R6gydhOO57Nc4SZcadu7h2Ayj2PX2CPPoUlFmtKh/WA5434Pxat1VVY27VNeBMu1DVg8ZfZfyooy/CrMEPzKYLuEupI5WI+SCGrgnfQyVRXglthUQcfnOEt/u/vremJ57HwcRkWgddwyaeA5RJffusQXqpBUQBeDnwxHjoaU4IfvNDQey50x5j7j/08otqjmUo4e5zCNS1qqN7l0wb5PjMxVSNYZrkoYKePlHJagXFfXwYpN/Rue6EXAfseqS84eZ/gMFpQkVWzKHjPmfPzVPwhCchROQZWGGYtiAH5M0oNzD8bFJxyeMlRmVb/es6bEv4pwhN7I8s/+/plkPQZSR9lgUTd000aAq+lIBPH/sQ3U/zwm+gnu6Hcg66hHwatFDocktS9AvgaHySDqWk6dAYA94y2jLN/laRWbNWzU+XPEnxxF5kTJquwBhaOrNjU5z6FrK9W7xY2nldWj+0JwG5amtXDs0LeoNO+XTvSWRtI3tNs4dm9HZIXkoMiGuY1jdjJBgWyEiUFCcoO0gexAKYGj0f6EBrRq5veumGkC5kzoQVWV5OZYUv3LaqJhofAoyGhR9loV7pbdr9amZLUqRAZ6FSYb4dQvScSOr1nyY4jq0T4qiInhcOGuJ6mAWKdzPdUpwrWHWyrikhvnMbLmtlO8nVYQnvRPfUbVRKPv7XzuP0D4TmWLW7WGdoeR01Ne96f60tqRze1tvn8q+pHPz7rcw9Ia2DvqdRHREpLNtUoGErWJ8ngUhZiIDnLugbo8iAusqBpi800KzfnhuxkjmZL9mrjBPIPP0c48U4ItYHdH8P0jNnbDH511p1iybF6bKSV8VibNjOpDTAS1vFroW6lNm0wqOVjuFbFtVEAZXaAMIeOBuQDbYpsCgUtrKEuyiu2a13JAn6pOAmj6Q2tD4RY/yfAOkN+YSYsYVoXSOT1PRvwqmfv4OrkmHdL1ktfK+myAOLyHHUm0qQffdj43gkp+isHAUFZNFePlWK9p5jN8rWPEDOjhzsdM2Z0lV9+mPYIQDKehnQAa0AiXjwwJgsfPFQtMDuwXjWJkI4d+sJwMy1vwGVDuAv5cT4a/8hJpdk4Sxqoo11qSKExv8sXINNICunQuU/frziSBpe3VP8XJCHAbhJ96JvL+5uPBYkyMb/5v2Jz+3Idh7Ak6wCNUzZjUBCmQN0MPfro/1aV0OBXereLcLXqYA218KLEhr5Aev802CL1tmLi/xxuhyx2rFdf7UmAKdGwugebOZK0DQGZRYBktyjf9rFsBnNGq1+oP/IopnpiY226Xhaa9TXnWvYnwHMfhemmAEWlQh9Uh3EnwOoepf9UKnN/Z6h10biBz4iZ1xV89nA3W7vjjquVvKG/URZIAhJWfp+Srvv4Szr7bjakCo/PghgvS4BaTW/9Vr67ELxCx6mTFmgtX4n2GXHa+MGsYtglP2RXnBD+dbgNT6SBER6yv//H3TfA3TZ4iissUYe2/Ue9Q1fi2HXXa4djm6V4zJkbTIUjhvACk7NniNPxMbHhnfwZzgxsQtmsTJAoVvmoeZUfz5RZRo6MeJN+ItqOLQCakhavp3siveuhXimHXCD71dfJgOCQp96J+0N1jSuvgfHMVPvEHc4eYUOvTw5jQGr+WeNTwWSS2HqPtVDTxzuzjuI3ifSsN1cClXI0qFK1Jr2w7lu4OW7lNIvfGnfbDERIId+QqZUtyrLjwNaTxwcPBYibZOpGTu9pudivoH5iLQEI7KwTHNqY6sfTzuBHd31scmwa7jFKE/f191FlhHANcu6gFh3bsVqk7/mNYt30cw1nkzYU5uLVCkBjbHCDoPjuX45haNn05h86ORw70pGelDOz0Hp+rlwPh0yC5fvSLK4n1ec1vVQfy7pG7JNt4suikv6pY9DmFqFBK6Z6AnR9YVwMFMLyJYsn56e6CiKREKn75J7smzBaXCE7LyX3Pc/m/sQ0MffwvqdRx+cBq610pnotXlQi0QInCPOLRBHMgA000SrFzMdmKqtL537sMNke4goIh+Rs5fj29ru/mzjSdljvola2eN5NHo7EAkOfX6pe/fbPXwpZn3UOoSZwV5FMFdfDAZxNRbgSVPl7+464oYAEGDxihdHNdVH1gLh2tg/JW6CeKBZaaBpun+1eQ4AbeRSasWr8vUMaBQD8D76wtf1zH+aNhF+oIG2dnuAbEdZjC6OmiUMcqWyVoo4njpC67Kt2pvPGTDI+3FW8ROFRkUJy86qHb28C/unk423bI76JMCgRvd8IE3aELYCgGRJ+OUISHzOj/3lBTNeTl+APEhCHgll+urXmGmqVFI+nJkQlfN8kp0NzTaLgtd/Bxd9v7Cj5hIO9W5tHFzQRp1WkwVfRqt3cejYUzsW/M7OmoXZ/PNrTzGAXT0FMNMgJBM7TMuRTbGERIpCrWC2sk1bVLE2FCIvswmPTQEbXRSWnRItN5dv/IAZfOA3Wwvh4vZdgV0et6XHYldSRl6Jon9l/3F+J/TKxlE0DzyIJOGb/ku/dA6JRb2DH1RVc/AXwJJHPJLcYVqxNLSyJI//AEzdovVZA7c8Xug8N10fOHALeX+wkdz4UKLLGpKvDiggJOihTREO2AhUjWiEOGcQlAt0l9QmDkLWm0PyWc5pyK22t9l+KX/Bkqy8JJ15Ua0cgsQcM6uwaT3kEeQkqIFV/AfpYn6YNI/5t7dFqQOKoIpfAPhY7e05l1Yxtc5m88CndtEMHeEA2RXbRWali9eUNSzhCN+1plhsIjDwGfHOj0fzjCKvVljT1FVp4lT1xMr8DDdmhrqL91Y6MY5sHJN0+51nsTRrDzSn0l6DDCZkioMSVsKcfcyUEHBpGi05UtQ1YoVN3oawJFsvUj56lJQhqKDNs3RUlIhGuAV1r5xfshH6/GvbYVRmjhI0h9nlSKTo0B6GhZhRKp/L65HGSk4azLUDUSMLq07nAN2+eSqdo+AbDzL+VFltITld1EAPEcyultFn5Xk+3HHHkaOS4Za/KicXFMIuSs0GBbtAhQPXnP5qTWyDSiZ3J5rDGCUpDNJwkuEvvZtbAYna/FmpSk7k+K/ALSzyxUUmlzpNEKe14Yl6eEYHrzPKWwWveI07MU+vitHv0wcyZ7ATIxT+/2JCsfvZxM35aK8hYLikClUOUuoVSoQpzim1t5TR6UUn2N/21boacafQqyPtUIGGS8rAlm83d/WARrD4KPLtmnnl2IezO5vm71qgGx3nZxisyvksxBxsjbsqGo12Ad+me7CFHKpjso/PSwO6iD2fu9pHwV9oaww0VyZ76M4qekh2uYC2k0ztADCCoyqP4Hlpfdxm7ei1zZ+tpwjJRDqKE7kvEJMv7G1zOo59BXSHzu5WRYBWop52FsdGhq2VyWC3p0fNiFUMcKQNOcoXOdFqTXoytJ1TpQkeMhYaH+DNDy9B0UkLQSgRMkt1khk8UGs0vO9owOOF3e9AvNmaXA3CvJLwGqI7w+R/ZWmlZ56m5ZApXf6uAoM4cwuO9N5QN4BovNXQu/u6C601dwdY9mLHmV3HeerizJT062rhEQDMe703YI+XhVkDw3mY3rs5VziDM4iL7SZkpmpAWWQfIUnn8bLuAgTelbF7WCF4bJAG99fA+yzFr5J1i4TCXPJV791NrSafDsKpenr2xKTRbn+iPkPvhdfqQcdlt7RjK+Q2/3LdGxylwOq062dKcxGi2kayDGzMehXjfQd/n23QjGLWo9ZuK0N46yGKAbJpJ0WEHgYHsOWjweLKcF6nlQDs9ZM6ssEtZzX+bCaiIA210Fj+s+/aA3cBCrTMpJV1fN0B5F8Nqx4Y1iWNP4/30JihpWd76AC8VxmswFlBCGKNy6TgtP1QHgB7MF5lIrx/hOS9qWDHim3T3yCtkHFE/IgimwUovCFn6UFVm3iST8vVfHe39rdSGBG9syiIOLx9zEdHKjC/mFF3f/epMfq2EuOxQwNYA8Zo7JFg3je37FX5tcgUyHsfFvCWFxVshQNddOOF+Ar5MNlEOut+eK+PYiAlUD/PhlOb6lfp2WVbOxHwIsRygd5DoeUIoEBRZAIxQn1kjokEZ/uA1HbVL52eciQWZs5nJnAzMKEizNWz+G6pu5+WKoc5EVEVlt3sB0ooDA6U4j0KBRPsLM+uEwaZvts0ngI1Y7k39LSd7jMwKOTT03d63iZpDgkX4e43+w4zZvaTwvnIXFMj5WkBoJRa0WGR8SKzmPP0SEylhyQclilvdrIpCgiRhmfE7ItBxlvcKlJudTkh4GxAsn6WjZzLjbCxiLWMMF8srcpu6uhx0QJOJfTsmxDZIUW8ZIZkdlftEWzdr1YYqVFPdoIj5NQtCWwU5zjshv9r0j6LoM+htUpslAm/BYhai7SesNiBu7m9g7grhOhMbUJj8dtEiS/hGffDdID5g9z+Y7qrHY4jNtj5IbWjuVqdwx3f6vXZqR2oB0DmXWX87lvwQNYhmM1rViPvnPewiadTzCBor+vTsi6V3JHMhkEcZ+uT1ht3L+hQ3HCikW8hR7tv1DB/94QJh97AfEduI533ye8agc9E4iu9GiPZiJz5PIdyg+CwJMBpkiC5Vb2qH0/V38iOG7cN3Ie8OTUth2+vTVHHS5gIbIs4ouZurGEdEJlySFd/09zFWKUNGAy8nMktyU3WgNTizduXMp1o8Z6I4GYURjuqhWvRLz+lrfrH227SPrcC+ni2R3XS7rA3tzcB7JF+if4FjS5udmdNoK+WxXa1357EFh0Mz5hvvuuYMpefNG00VAsfe80J7/ArdLQJZ9//ntCeQxLVGoDK3TkTs3ZHFqcC8lyPCKY4/FOEhTEu4Kc1w1gSCIyqGlpHPWgDpNd4nbgW81XPhDLPxC5jSqWAuQ2j4aeZ+CoWs1avxQQZQ8QpZA7oy2kkoQJfEx+BJa5jvrzZsS8LJSbeKBhetqkepYcNBS4iAwdWbOdUt7EKCguTI1FM6zYGMyRdy3NUZZmub6laqU1T9ZHNZLiZ7WCaQSR2HGrZPN1ZkJTWr0AitbA1bz8qwXPXcSgfGqYhMv9Q0XwrzsuJ9HFUCRbM7cvA4hxAOhN89+eS/SrEY47VxY6yXRvKK+XTbLzIH1drX+D2DMS/AMmuwY1SkAvfB8OA80noKKl/nDugcNl0aZ0G1lnAUufnGdCxcN9ptiGHAkFTnZvRwPhfIOkPhQkg+4+bTxq0+D1as7L3wFBK2gzjcAIMB0sBdQoPIBVFXJk0Qy9rLX2Z/4kIHv9BrHhAhbMn71txFNUZMnIDW75mbmQVgeZ6cYPx7WUBxAr6VNTeajUkDU9udoROiYuNU+AuVcamVu5ACpPXTwdS5534gq/sTTHAh2jxh354TTPjUWIE0ot/EWSISeRf6Jsr18cWuuXUpN1xkUrEzjN6/370JFr/KQ7cVh7jFpDRcauGMy12m/lf0zTekIhI8aTSB8iQCm34BaYfXaUYUf22lTALUcqaIqlvRiPIxcFrN4sA0sFY5B+l+/WZ2qms7/2Wec2FEvCXRTRLBYLQtIROzguuQI3+hcyusoffdkijFoxg3pd/bn9GhD10idquDy7lZy9Y1f2AuGKT5jfQCyrtMjnKCpGFs5sYl98DgXIuGg+cp0UN4ScNG7MsNN+HJv3UvhpihpE7f3LA0FM2JdAEQ+C1oXTF4QKtjk1sAPOP0BZPGeIYf9A6GPEkmO/L4wuIqP1U0wgbbTdl5tsE5cP1sUc+NNc8vpHJo3FbIGUwP0Qki9N57gWEGTAaVUmu9PdeRLDKyjZecoaR5eQhIYflJj2ui0FNSpL/CP6SiO7chbvNfsz1JE5+x9SoYNMtcCUu2HFxgFX4FVXRchDjYlZaOXdxMfdU20dytNQwXg9TqH7ITCmIMYlBOdoClsMYv1cZzbxxuELCKCirsyXIyvamq+O9udNZgaXvjeRODdpWSCejOx40kQ7qeskvtR95VkBbl5r0ouG+iFCRHQH8sSIo3wO3DCmv+Ce1gI/GP3/bPYIMwNz3sXT5J4UG50QVj6rV3mlC92Zit/tE7D30XzzuKdpiqsaaRyxKf18hN5W7gEhyef1rgIe+breBYH1hKX+O/llKDB7uAHLjbcx814NIU545il+2xp67iSO00BfAXUm6rkCu7dwBEM4602raajJYm42xpTHmu2cIg/ENa84HCo2Iq0OvCKr+j3hR9vVlAOHQYTNkrC1RK0a3164IlLRgGvJNgG5CAJ/2gLBVkqy/LOX9gfNBJpd6wHkHLhL+Gw1qTurY5Az9RVJ/HYLpPZHH4faJs3wjneMyw+mQxRcE38Qi/VhEXZlMJYbiecGun6WpGBh36KmLCBwCFfsLaU2DuOS4k7oiRwfC6ioAJG+fZA9ZgP5oHzwH/51GdK37IonTKvfByQBmwDgJgI0CbLYbwix2mCeKuM2lMnaQRLCxP24Orc+CcpEoRkq2KOiaI1Fy02lrZqRk2S4WLq/ocYWs1q0LdcR8rzqxMa639h3KSG9YVz4FovYbOT7UiSV+EsLXqv2girbGnlzEOdgfTo6g6tT8APKXl58RCN8h8byPTAIYpMBiG97YG3MLlgzcg74SrafniEKsek0R6N3WB8DFAvHmCT0QpUdgqVMVGIleXZRPU661q3MVpxDlnau8Ls/vV7ksP3DWZDb9MgbqU1ww5NMvSa9sbNtf/nGIjdBPXArDk0EIOFXOd1CqUk4b1XJfR0lEl9IJFes/m3WTXZrjb3URoxyTJnLC5BO/lj7B2E4ds+9jy8Zz+dVIlRpg2rHYJD4gGQCEc3ieo/8ZCXj//qckoDxWQW7GMeTfVH0BixDd3wMHkRsU11xZmfSEtBpnoOJJ+l4bCkC794auDgQpTKSzDHVpp44pWf6iTV62Wr8KIjMA4emA9klrgfaBQbbtHpA1OE4iopWSDboIy0gnhUt6KkGv7uxVlCX4eJk0l+boKet4gNrbHGn0UPhsV2hqzl6QO8RZEzN09emuuQDXWtf6xmyVvZHGU8RNlN+NJ16aOcQPHw0iPd8CAvebO+ERtgNRhg90Bl2I2dbYZhMz9zDTbF4E21+X9suVESHMzvvk6soTaXrw3fvjNOy5zYHQJ9hv3XjwsXlp887aoL4zJpUhEYRkECQq+D68KFlMVPkxnnjM2BvAvbNJGBpIblF7h3jiRNh2mHrPrJ2sQP/BEzFaFosbFNmh80/slQQnsEWC6TX9xG7y6OJ8LFkOoYt9rV6xC2nf9j2Fweo69agIQqFfNWlGjgtqUM+0fZJd+8/bDFSakziKS5kwbywZYNW5cxtnCG/RTfSJcfNoJqDI1gofFi/cud+28TIY8vqLJqmy7lR+QIN9bGO6ZXFisWIijOg0sKI6SyYfHQtL6uoMrWiSBYxtMaY/C+KfZBi/lC4AYrAyQUShcgk2EizNH0QdknloSaV4XbwtikNlLua1ecnT3+GD2G4inIkSIY9w8H+vwKHObCVdkjysvmuq2xWl62ktiH1HpnGUVFNaFpKdFe9JL7rTmGuBRqktmOoqE7I0T7HF+pnkgKVLxJSoZHBnyEKD9xILwsjFCtFbLHTX+EZsra6SdBJ30njU/NI6gCFbuF4sjHX0hq9PBROkMAc3UBWAzqEQY3lw==
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>cross-modal</category>
        <category>video captioning</category>
      </categories>
      <tags>
        <tag>cross-modal,video captioning</tag>
      </tags>
  </entry>
  <entry>
    <title>NumPy 副本和视图</title>
    <url>/2019/03/13/NumPy-%E5%89%AF%E6%9C%AC%E5%92%8C%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="NumPy-副本和视图"><a href="#NumPy-副本和视图" class="headerlink" title="NumPy 副本和视图"></a>NumPy 副本和视图</h1><p><strong>副本（赋值）</strong>是一个数据的完整的拷贝，如果我们对副本进行修改，它不会影响到原始数据，物理内存不在同一位置。</p>
<p><strong>视图（引用）</strong>是数据的一个别称或引用，通过该别称或引用亦便可访问、操作原有数据，但原有数据不会产生拷贝。如果我们对视图进行修改，它会影响到原始数据，物理内存在同一位置。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>视图（引用）一般发生在：</strong></p>
<ul>
<li>1、numpy 的切片操作返回原数据的视图。</li>
<li>2、调用 ndarray 的 view() 函数产生一个视图。</li>
</ul>
<p><strong>副本一般发生在：</strong></p>
<ul>
<li>Python 序列的切片操作，调用deepCopy()函数。</li>
<li>调用 ndarray 的 copy() 函数产生一个副本。</li>
</ul>
<h2 id="yaya-举例："><a href="#yaya-举例：" class="headerlink" title="yaya 举例："></a>yaya 举例：</h2><p><strong>视图（引用）一般发生在：</strong></p>
<ul>
<li>1、numpy 的切片操作返回原数据的视图。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>)  <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b = a[:]   <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">10</span>  <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line">print(a)   <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line"><span class="comment"># 修改b数据值，将修改原数据a的值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>)  <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b = a[:]   <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b.shape = <span class="number">2</span>,<span class="number">3</span>  <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line">print(b)  </span><br><span class="line"><span class="comment"># [[0 1]</span></span><br><span class="line"><span class="comment">#  [2 3]</span></span><br><span class="line"><span class="comment">#  [4 5]]</span></span><br><span class="line">print(a)   <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line"><span class="comment"># 修改b数据形状，不会修改原数据a的形状</span></span><br></pre></td></tr></table></figure>
<ul>
<li>2、调用 ndarray 的 view() 函数产生一个视图。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>)  <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b = a.view()   <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">10</span>  <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line">print(a)   <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line"><span class="comment"># 修改b数据值，将修改原数据a的值</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>)  <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b = a[:]   <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b.shape = <span class="number">2</span>,<span class="number">3</span>  <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line">print(b)  </span><br><span class="line"><span class="comment"># [[0 1]</span></span><br><span class="line"><span class="comment">#  [2 3]</span></span><br><span class="line"><span class="comment">#  [4 5]]</span></span><br><span class="line">print(a)   <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line"><span class="comment"># 修改b数据形状，不会修改原数据a的形状</span></span><br></pre></td></tr></table></figure>
<p><strong>副本一般发生在：</strong></p>
<ul>
<li>Python 序列的切片操作，调用deepCopy()函数。</li>
<li>调用 ndarray 的 copy() 函数产生一个副本。</li>
</ul>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><h3 id="无复制-指向同一地址"><a href="#无复制-指向同一地址" class="headerlink" title="无复制 (指向同一地址)"></a>无复制 (指向同一地址)</h3><p>简单的赋值不会创建数组对象的副本。 相反，它使用原始数组的相同id()来访问它。 id()返回 Python 对象的通用标识符，类似于 C 中的指针。</p>
<p>此外，一个数组的任何变化都反映在另一个数组上。 例如，一个数组的形状改变也会改变另一个数组的形状。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np    </span><br><span class="line">a = np.arange(<span class="number">6</span>)   </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'我们的数组是：'</span>) </span><br><span class="line"><span class="keyword">print</span> (a) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'调用 id() 函数：'</span>) </span><br><span class="line"><span class="keyword">print</span> (id(a)) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'a 赋值给 b：'</span>) </span><br><span class="line">b = a  <span class="keyword">print</span> (b) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'b 拥有相同 id()：'</span>) </span><br><span class="line"><span class="keyword">print</span> (id(b)) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'修改 b 的形状：'</span>) </span><br><span class="line">b.shape =  <span class="number">3</span>,<span class="number">2</span>   </span><br><span class="line"><span class="keyword">print</span> (b) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'a 的形状也修改了：'</span>) </span><br><span class="line"><span class="keyword">print</span> (a)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">我们的数组是：</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">调用 id() 函数：</span><br><span class="line"><span class="number">4349302224</span></span><br><span class="line">a 赋值给 b：</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">b 拥有相同 id()：</span><br><span class="line"><span class="number">4349302224</span></span><br><span class="line">修改 b 的形状：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">a 的形状也修改了：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br></pre></td></tr></table></figure>
<h3 id="视图或浅拷贝"><a href="#视图或浅拷贝" class="headerlink" title="视图或浅拷贝"></a>视图或浅拷贝</h3><p>ndarray.view() 方会创建一个新的数组对象，该方法创建的新数组的维数更改不会更改原始数据的维数。但是修改新数组的数值将会更改原始数据的数值。</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  numpy  <span class="keyword">as</span>  np  </span><br><span class="line">a = np.arange(<span class="number">6</span>)  </span><br><span class="line"><span class="keyword">print</span>  (<span class="string">'我们的数组是：'</span>)  </span><br><span class="line"><span class="keyword">print</span>  (a)  </span><br><span class="line"><span class="keyword">print</span>  (<span class="string">'调用 id() 函数：'</span>)  </span><br><span class="line"><span class="keyword">print</span>  (id(a))  </span><br><span class="line"><span class="keyword">print</span>  (<span class="string">'a 赋值给 b：'</span>)  </span><br><span class="line">b = a  <span class="keyword">print</span>  (b)  </span><br><span class="line"><span class="keyword">print</span>  (<span class="string">'b 拥有相同 id()：'</span>)  </span><br><span class="line"><span class="keyword">print</span>  (id(b))  </span><br><span class="line"><span class="keyword">print</span>  (<span class="string">'修改 b 的形状：'</span>)  </span><br><span class="line">b.shape = <span class="number">3</span>,<span class="number">2</span>  </span><br><span class="line"><span class="keyword">print</span>  (b)  </span><br><span class="line"><span class="keyword">print</span>  (<span class="string">'a 的形状也修改了：'</span>)  </span><br><span class="line"><span class="keyword">print</span>  (a)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">数组 a：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">创建 a 的视图：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">两个数组的 id() 不同：</span><br><span class="line">a 的 id()：</span><br><span class="line"><span class="number">4314786992</span></span><br><span class="line">b 的 id()：</span><br><span class="line"><span class="number">4315171296</span></span><br><span class="line">b 的形状：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">a 的形状：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br></pre></td></tr></table></figure>
<p>使用切片创建视图修改数据会影响到原始数组：</p>
<h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np   </span><br><span class="line">arr = np.arange(<span class="number">12</span>) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'我们的数组：'</span>) </span><br><span class="line"><span class="keyword">print</span> (arr) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'创建切片：'</span>) </span><br><span class="line">a=arr[<span class="number">3</span>:] </span><br><span class="line">b=arr[<span class="number">3</span>:] </span><br><span class="line">a[<span class="number">1</span>]=<span class="number">123</span> </span><br><span class="line">b[<span class="number">2</span>]=<span class="number">234</span> </span><br><span class="line">print(arr) </span><br><span class="line">print(id(a),id(b),id(arr[<span class="number">3</span>:]))</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">我们的数组：</span><br><span class="line">[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br><span class="line">创建切片：</span><br><span class="line">[  <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span> <span class="number">123</span> <span class="number">234</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>]</span><br><span class="line"><span class="number">4545878416</span> <span class="number">4545878496</span> <span class="number">4545878576</span></span><br></pre></td></tr></table></figure>
<p>变量 a,b 都是 arr 的一部分视图，对视图的修改会直接反映到原数据中。但是我们观察 a,b 的 id，他们是不同的，也就是说，视图虽然指向原数据，但是他们和赋值引用还是有区别的。</p>
<h3 id="副本或深拷贝"><a href="#副本或深拷贝" class="headerlink" title="副本或深拷贝"></a>副本或深拷贝</h3><p>ndarray.copy() 函数创建一个副本。 对副本数据进行修改，不会影响到原始数据，它们物理内存不在同一位置。</p>
<h2 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np    </span><br><span class="line">a = np.array([[<span class="number">10</span>,<span class="number">10</span>],  [<span class="number">2</span>,<span class="number">3</span>],  [<span class="number">4</span>,<span class="number">5</span>]])   </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'数组 a：'</span>) </span><br><span class="line"><span class="keyword">print</span> (a) <span class="keyword">print</span> (<span class="string">'创建 a 的深层副本：'</span>) </span><br><span class="line">b = a.copy()   </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'数组 b：'</span>) </span><br><span class="line"><span class="keyword">print</span> (b) <span class="comment"># b 与 a 不共享任何内容   </span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">'我们能够写入 b 来写入 a 吗？'</span>) </span><br><span class="line"><span class="keyword">print</span> (b <span class="keyword">is</span> a) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'修改 b 的内容：'</span>) </span><br><span class="line">b[<span class="number">0</span>,<span class="number">0</span>]  =  <span class="number">100</span>   </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'修改后的数组 b：'</span>) </span><br><span class="line"><span class="keyword">print</span> (b) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'a 保持不变：'</span>) </span><br><span class="line"><span class="keyword">print</span> (a)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">数组 a：</span><br><span class="line">[[<span class="number">10</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>]]</span><br><span class="line">创建 a 的深层副本：</span><br><span class="line">数组 b：</span><br><span class="line">[[<span class="number">10</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>]]</span><br><span class="line">我们能够写入 b 来写入 a 吗？</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">修改 b 的内容：</span><br><span class="line">修改后的数组 b：</span><br><span class="line">[[<span class="number">100</span>  <span class="number">10</span>]</span><br><span class="line"> [  <span class="number">2</span>   <span class="number">3</span>]</span><br><span class="line"> [  <span class="number">4</span>   <span class="number">5</span>]]</span><br><span class="line">a 保持不变：</span><br><span class="line">[[<span class="number">10</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>]]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>Object-aware Aggregation with Bidirectional Temporal Graph for Video Captioning</title>
    <url>/2019/07/27/Object-aware-Aggregation-with-Bidirectional-Temporal-Graph-for-Video-Captioning/</url>
    <content><![CDATA[<h3 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h3><ul>
<li>本文旨在于捕捉基于object的运动信息(capture object-based trajectory)，以前向流为例，以第一帧中的object regions 作为anchor， 来寻找在其他帧中相对应的regions， 计算该anchor 与 第i帧中的regions的相似性【相似性不仅考虑了特征相似性，还考虑了空间位置相似性】，然后相似性最大的那个region，认为是与anchor一致的objects， 然后将他们组成一组。反向流类似。  </li>
<li>这个捕捉运动信息的思想与 【Learning Video Representations from Correspondence Proposals】中的很相似。   </li>
</ul>
<h3 id="当前存在的问题"><a href="#当前存在的问题" class="headerlink" title="当前存在的问题"></a>当前存在的问题</h3><ul>
<li>当前的工作主要使用 global frame 或者是 salient regions而不是使用specific objects，那么将不能捕捉到每个object 的细节的时域动态。</li>
</ul>
<h3 id="文章的主要工作"><a href="#文章的主要工作" class="headerlink" title="文章的主要工作"></a>文章的主要工作</h3><h4 id="encoder"><a href="#encoder" class="headerlink" title="encoder"></a>encoder</h4><ul>
<li>constructs ==bidirectional temporal graph== to extract  the temporal trajectories for each object instance, which captures the detailed temporal dynamics in video content.    </li>
<li>==aggregation process on object regions==, which can capture the object-aware semantic information， 这里主要是得到了 VLAD[5, 6] representation   </li>
</ul>
<h4 id="decoder"><a href="#decoder" class="headerlink" title="decoder"></a>decoder</h4><ul>
<li><p>对object VLAD representation实施了temporal attention 和 object attention</p>
</li>
<li><p>对 frames VLAD representation 实施了 temporal attention</p>
</li>
<li><p>然后分别进行nn.linear 线性变换后，相加</p>
</li>
<li><p>再与word_embedding相加送入GRU</p>
</li>
<li></li>
<li><p><font color="#0099ff" size="5" face="黑体">前向流和后向流的融合：</font>在分别得到两流输出的word score 之后，进行 sum</p>
<p><img src="https://i.loli.net/2019/07/28/5d3d37324d6d283934.png" alt="搜狗截图20190728134820.png" title="搜狗截图20190728134820.png">   </p>
</li>
</ul>
<h3 id="本文的性能分析"><a href="#本文的性能分析" class="headerlink" title="本文的性能分析"></a>本文的性能分析</h3><ul>
<li>可以准确的描述video，比如关键的objects。</li>
<li><strong>但是！不能很好地去描述 objects 之间的交互</strong></li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li>【NetVLAD】Relja Arandjelovic, Petr Gronat, Akihiko Torii, Tomas Pajdla, and Josef Sivic. Netvlad: Cnn architecture for weakly supervised place recognition. In CVPR, pages 5297–5307, 2016.</li>
<li>【SeqVLAD】Youjiang Xu, Yahong Han, Richang Hong, and Qi Tian. Sequential video vlad: Training the aggregation locally and temporally. IEEE Transactions on Image Processing (TIP), 27(10):4933–4944, 2018</li>
</ul>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>On calibration of modern neural networks</title>
    <url>/2021/01/07/On-calibration-of-modern-neural-networks/</url>
    <content><![CDATA[<p>On Calibration of Modern Neural Networks</p>
<h2 id="Calibration-一个工业价值极大，学术界却鲜有研究的问题！"><a href="#Calibration-一个工业价值极大，学术界却鲜有研究的问题！" class="headerlink" title="Calibration: 一个工业价值极大，学术界却鲜有研究的问题！"></a>Calibration: 一个工业价值极大，学术界却鲜有研究的问题！</h2><p>原创 kid丶 <a href="javascript:void(0" target="_blank" rel="noopener">夕小瑶的卖萌屋</a>;) </p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>文 | kid丶(知乎作者)<br>编 | 夕小瑶</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>尽管深度学习给工业界带来了一波上线春天，但是总有很多比较难的业务，模型反复迭代后准确率依然达不到预期的产品标准，难以满足用户期望。</p>
<p>以下为工业界常见讨（si）论（b）场景：</p>
<p>R&amp;D小哥哥一顿调参输出，RoBERTa都用上了，终于将模型从80%准确率提升到了90%，但是PM小姐姐说，“不行！咱们必须要达到95%准确率才能上线！否则就是对用户和产品逼格的伤害！”</p>
<p>怎么办呢？</p>
<p>熟悉工业界上线套路的小伙伴马上就能给出答案，那就是 <strong><em>提高模型决策的阈值！</em></strong> PM小姐姐只是根据产品标准定义了模型准确率（或者说精确率，precision），但是并不在乎召回率有多高（毕竟模型只要没上线，就相当于召回率为0）。</p>
<p>那么基于上面的思路：假如模型的softmax输出可靠，比如二分类场景，模型softmax之后1类的输出是0.92，能表征模型有92%的把握说这是个正例，并且模型的这个把握是精准的，那么PM小姐姐说要达到95%准确率，那我们就疯狂提高模型的决策阈值就好了，这样把那些不确定性高的样本砍掉了，模型准确率自然就上来了。</p>
<p>然而，神经网络并不一定这么靠谱，你看模型的测试集输出的话，却常常发现模型要么以99.999的概率输出来判定正例，要么0.0001的概率输出来判定负例，基本没有样本落在0.1~0.9区间内。那么这时候上面的思路就失效了。</p>
<p>那么有没有办法<strong>让模型的softmax输出能真实的反映决策的置信度呢？</strong> 这个问题，就被称为Calibration问题（直译是叫“校准”）。</p>
<p>故事要从一篇发表于2017年的ICML顶会论文开始，目前这篇论文引用量1001。</p>
<p><strong>论文标题：</strong></p>
<p>On Calibration of Modern Neural Networks</p>
<p><strong>链接：</strong></p>
<p><a href="https://arxiv.org/pdf/1706.04599.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1706.04599.pdf</a></p>
<p>Arxiv访问慢的小伙伴可以在【<strong>夕小瑶的卖萌屋</strong>】后台回复关键词【<strong><em>0106</em></strong>】下载论文pdf~</p>
<h2 id="神经网络的-overconfidence"><a href="#神经网络的-overconfidence" class="headerlink" title="神经网络的 overconfidence"></a>神经网络的 overconfidence</h2><p><img src="https://i.loli.net/2021/01/07/cDzC2UkMQGL3y8I.png" alt="image-20210107121456693" style="zoom: 50%;"></p>
<p>首先，让咱们来思考一个普通图像分类任务。对于一张“koala”的图像，在经过神经网络后会得到 logits 输出 ，经过 softmax 层后得到对各类别的预测的后验概率，接着我们选择概率最大的类别（ koala）输出为最后的预测类别。这里，最终的预测类别 ，其对应的置信度为 。在大多情况下，我们只关心类别的预测 有多准，根本不 care 置信度是怎样的。然而，在一些实际应用场景下，置信度的度量也同样重要。例如：</p>
<p><img src="https://i.loli.net/2021/01/07/HILjXfdVBk7v1hw.png" alt="image-20210107121544230" style="zoom: 50%;"></p>
<p>如上图，对于自动驾驶中的目标识别任务，车辆的前方出现了一个人，神经网络会将其识别成塑料袋，此时输出的置信度为50%（低于阈值），则可通过其它传感器进行二次的正确识别（识别为人）。但想想看，若神经网络对塑料袋预测的置信度为90%会怎样？再例如：</p>
<p><img src="https://i.loli.net/2021/01/07/3CUylrwH4u6csDG.png" alt="image-20210107121606617" style="zoom:50%;"></p>
<p>使用 Resnet 模型简单的对一些图片任务进行训练，收敛后的模型对测试集的平均置信度高达80%-85%，然而只有将近70%的图片能被正确分对（红色代表分错，绿色代表分对）。这意味着啥？训练好的模型好像有点盲目自信，即出现 <strong>overconfidence</strong> 现象，或者可以称为模型的准确率和置信度不匹配（<strong>miscalibration</strong>）。</p>
<h2 id="预期校准误差（ECE）"><a href="#预期校准误差（ECE）" class="headerlink" title="预期校准误差（ECE）"></a>预期校准误差（ECE）</h2><p>直观的来看，模型的准确率应当和置信度相匹配。一个完美校准的模型可定义成如下所示：</p>
<p>即，模型置信度 等于概率 的条件下模型的预测 为真实标记 的概率同样也为 。因此，本文提出一个新的度量方式叫做 <strong>预期校准误差（Expected Calibrated Error, ECE）</strong> 来描述模型学习的匹配程度：很简单，其实就是将前面那个完美校准模型的等式写成差的期望的形式。我们将期望进一步展开可得到：</p>
<p>其中： 这里的 代表着一个个根据置信度区间划分的一个个桶（用来装样本的），如下图所示：</p>
<p><img src="https://i.loli.net/2021/01/07/KS6p2nRIhMdtgjv.png" alt="image-20210107121742204" style="zoom:50%;"></p>
<p>例如，我们将置信区间平均划分成5份，然后将样本按照其置信度挨个送到对应的桶中，分别计算每个桶中的平均置信度和准确率，两者的差值（Gap）的期望就是所定义的 <strong>ECE。</strong></p>
<p><strong>读到这的读者</strong>应该能逐步体会本文想干一件啥事了。本文首先引出这样一个问题，深度模型在学习过程中出现准确率和置信度的严重不匹配问题，接着提出了一个合理的评价指标来描述模型学习的匹配程度，所以接下来，它要提出方法来想办法<strong>最小化期望校准误差（ECE）。</strong></p>
<h2 id="什么原因导致神经网络出现准确率与置信度不匹配？"><a href="#什么原因导致神经网络出现准确率与置信度不匹配？" class="headerlink" title="什么原因导致神经网络出现准确率与置信度不匹配？"></a>什么原因导致神经网络出现准确率与置信度不匹配？</h2><p>然而 <strong>ECE</strong> 是没办法直接最小化的，因此本文尝试着做一些探索性的实验来观察啥因素会使得模型的 ECE 变大。本文分别从三个方面上去进行实验：</p>
<p><img src="https://i.loli.net/2021/01/07/kniAWZNqaVBwQPG.png" alt="image-20210107121834360"></p>
<p>▲网络复杂度对ECE的影响</p>
<p><strong>网络复杂度对 ECE 的影响：</strong> 首先，作者使用两个模型（LeNet和ResNet）分别对CIFAR-100数据集进行了训练，准确率分别为55.1%和69.4%，ResNet 在预测性能上完爆LeNet。然而，ResNet 置信度（右图蓝色+红色部分）的分布和准确率（右图蓝色部分）出现了严重的不匹配，导致二者的 Gap （红色部分）非常大。**注意完美校准模型的分布应当是蓝色部分刚好和对角线重合，且没有红色 Gap 部分。</p>
<p><img src="https://i.loli.net/2021/01/07/OQX8Ir64DqyBwdl.png" alt="image-20210107114831568" style="zoom: 33%;"></p>
<p>▲网络的宽度和深度对ECE的影响</p>
<p><strong>网络宽度和深度对 ECE 的影响：</strong> 在得知模型复杂度会影响模型的 ECE 后，作者紧接着做了网络宽度和深度对模型 ECE 和错误率（Error）的影响。可以看到，在控制变量前提下，单方面的增加网络的深度和宽度均会使得模型的 Error 降低，这是我们所期望的；然而，ECE也会同样的随着上升。<strong>换句话来说，一昧的增加模型复杂度能有效的提高模型的预测性能，但同样带来的问题是模型的 overconfidence 问题愈发严重。</strong></p>
<p><img src="https://i.loli.net/2021/01/07/v1S9YrfQBt5sl4O.png" alt="image-20210107114951774" style="zoom:33%;"></p>
<p>▲归一化和权重衰减对ECE的影响</p>
<p><strong>normalization 和 weight decay 对 ECE 的影响：</strong> 接着的实验也是我们为提高模型性能经常使用的 batch normalization 和 loss regularization。<strong>左图：</strong> 使用 batch normalization 会有效的提升模型的性能，但同时也会提升模型的 ECE。<strong>右图：</strong> weight decay 通常用来调节 L2 正则的权重衰减系数，随着其系数的增加相当于更多的强调模型参数 w 要尽可能的小，能有效的防止模型过拟合。<strong>该现象表明，模型越不过拟合，其ECE是越小的，也就是说模型越不会 overconfidence ；换句话说，模型对样本的拟合程度和对样本的置信度是息息相关的，拟合得越好，置信度越高，所以 ECE 越大。（个人理解，欢迎评论区指正~）</strong></p>
<h2 id="我们该如何对模型进行校准呢？"><a href="#我们该如何对模型进行校准呢？" class="headerlink" title="我们该如何对模型进行校准呢？"></a>我们该如何对模型进行校准呢？</h2><p><img src="https://i.loli.net/2021/01/07/8WvRUEQtXg6iseY.png" alt="image-20210107115025920" style="zoom:33%;"></p>
<p>作者接下来又做了一个很有意思的实验，在CIFAR-100上训练模型500个 epoch，其中在第250个 epoch 和第375个 epoch 下调节学习率，观察测试集上的 test error 和 test NLL 的变化情况。Test NLL 的定义如图中所示，它其实等价于测试集上的交叉熵。这个实验啥意思呢？我调节了一下学习率后，测试性能得到了提升，但是测试集上的交叉熵却出现了过拟合现象（出现了反常的上升现象）。<strong>有意思的点来了！</strong> 有人肯定会 argue 不是说好本文研究的是overconfidence嘛？即模型的置信度太高而准确率过低，这里对 NLL overfitting 岂不是好事，因为负对数似然上升了等价于模型的置信度的降低了。<strong>注意：这里的</strong> <strong>是对正确类上的置信度，而前面的实验是对预测类的置信度</strong> <strong>！其实认真想想，是一个意思，前面之所以 confident 很高的样本准确率很低，正是因为其在正确类别上的置信度太低导致的！！（这部分卡了很久）</strong></p>
<p>该结果可以表明，模型置信度和准确率的不匹配很大可能的原因来自于模型对 NLL 的过拟合导致的。所以，咋办呢？最小化 NLL 呗。</p>
<p><img src="https://i.loli.net/2021/01/07/gzr4juPYwMFyiSH.png" alt="image-20210107121901763"></p>
<p>此时，本文提出在验证集上对带 temperature 参数的 softmax 函数进行校准。即我们训练完模型后，最小化 NLL 来学习 temperature 参数，注意到对该项的优化并不会影响模型预测的准确率，只会对模型的 confidence 进行校准。最终的结果是这样的，详细可参考论文。</p>
<p><img src="https://i.loli.net/2021/01/07/dDNYosvc2tprZaE.png" alt="image-20210107115122188"></p>
<h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a><strong>讨论</strong></h2><p>上述得实验结果我觉得对很多研究领域都是很有启发意义的。</p>
<ol>
<li>模型的置信度应当是和准确率匹配的，这样的模型我觉得才是有意义的，否则以很高置信度进行很离谱的预测错误的模型会让人感觉这个模型好像什么都会、又好像什么都不会。</li>
<li>ECE 的指标是否能反应样本的一些性质，例如难易程度、是否为噪声等。</li>
<li>该文章是间接的去优化ECE的，能否有直接优化的形式，或者主动学习里面能否考虑这一点来挑选样本？</li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>PPL-语句通顺</title>
    <url>/2020/10/27/PPL-%E8%AF%AD%E5%8F%A5%E9%80%9A%E9%A1%BA/</url>
    <content><![CDATA[<h3 id="语句通顺-一些调研"><a href="#语句通顺-一些调研" class="headerlink" title="语句通顺 - 一些调研"></a>语句通顺 - 一些调研</h3><ul>
<li><p>BERT模型通过在大量语料的训练可以判断一句话是否通顺</p>
</li>
<li><p>理解 NNLM <a href="https://zhuanlan.zhihu.com/p/65446874" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/65446874</a></p>
<p>以上推理就是</p>
<ol>
<li>用词汇的联合概率表达一个语句是否通顺；</li>
<li>将计算联合概率转换为计算条件概率；</li>
<li>将条件概率由不定长度的且一般较大的t维降到一般较小的n-1维;</li>
</ol>
</li>
<li><p><a href="https://blog.csdn.net/blmoistawinde/article/details/104966127" target="_blank" rel="noopener">https://blog.csdn.net/blmoistawinde/article/details/104966127</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/76912493" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/76912493</a></p>
</li>
</ul>
<h3 id="PPL-评价指标"><a href="#PPL-评价指标" class="headerlink" title="PPL-评价指标"></a>PPL-评价指标</h3><p>在得到不同的语言模型（一元语言模型、二元语言模型….）的时候，我们如何判断一个语言模型是否好还是坏，一般有两种方法：</p>
<p>1、一种方法将其应用到具体的问题当中，比如机器翻译、speech recognition、spelling corrector等。然后看这个语言模型在这些任务中的表现（extrinsic evaluation，or in-vivo evaluation）。但是，这种方法一方面难以操作，另一方面可能非常耗时，可能跑一个evaluation需要大量时间，费时难操作。</p>
<p>2、针对第一种方法的缺点，大家想是否可以根据与语言模型自身的一些特性，来设计一种简单易行，而又行之有效的评测指标。于是，人们就发明了perplexity这个指标。</p>
<p><img src="https://i.loli.net/2020/10/27/UcxVWKjtlCi5Tw7.png" alt="image-20201027113452950" style="zoom: 25%;"></p>
<p>困惑度（perplexity）的基本思想是：<strong>给测试集的句子赋予较高概率值的语言模型较好,当语言模型训练完之后，测试集中的句子都是正常的句子，那么训练好的模型就是在测试集上的概率越高越好，</strong></p>
<p>由公式可知，<strong>句子概率越大，语言模型越好，迷惑度越小。</strong></p>
<p>$P(W_1, W_2, … , W_t)$</p>
<p>= $P(W_t | W_{t-1}, … , W_2, W_1) * P(W_{t-1}, … , W_2, W_1))$</p>
<p>= $P(W_t | W_{t-1}, … , W_2, W_1)$ <em> $P(W_{t-1} | W{t-2}, …, W_2, W_1) $ </em> $ P(W{t-2}, …, W_2, W_1)$</p>
<p>= $P(W_t | W_{t-1}, … , W_2, W_1)$ <em> $ P(W_{t-1} | W_{t-2}, …, W_2, W_1) $ </em> $ … $ <em> $ P(W_2 | W_1) </em> P(W_1)$</p>
<p>一些 ngram 模型经 训练文本后在测试集上的困惑度值：</p>
<p><img src="https://i.loli.net/2020/10/31/bYtXO3hgJs8TE6f.jpg" alt="img" style="zoom: 50%;"></p>
<ul>
<li>求通俗解释NLP里的perplexity是什么？ - 习翔宇的回答 - 知乎 <a href="https://www.zhihu.com/question/58482430/answer/412012509" target="_blank" rel="noopener">https://www.zhihu.com/question/58482430/answer/412012509</a></li>
<li>也可以用交叉熵损失函数来表示</li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>On Semantic Similarity in Video Retrieval</title>
    <url>/2021/03/19/On-Semantic-Similarity-in-Video-Retrieval/</url>
    <content><![CDATA[<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><ul>
<li>当前的检索任务是目标实例进行检索（ target instance-based retrieval）（IVR），即，给定一个query caption，仅一个 origami video 被认为是正确的检索结果。但，实际上，数据集中的许多视频can be similar to the point of being identical。检索此类视频的顺序不应影响方法的评估。</li>
</ul>
<h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><p>本文提出 Semantic Similarity Video Retrieval（SVR），相比于 normal IVR 的不同点是：</p>
<ul>
<li>对于1个video，允许有多个captions与其 的相似度为1</li>
<li>如果 $sim(x_i, y_j)$ = $sim(x_i, j_k)$，$x_i$ 为 video set 中的一个video。则表示这两个caption被认为是与该video有相等的相关度。可以以任意的顺序来检索，并且不能被evaluation metric 惩罚。</li>
</ul>
<h2 id="Proxy-Measures-for-Semantic-Similarity"><a href="#Proxy-Measures-for-Semantic-Similarity" class="headerlink" title="Proxy Measures for Semantic Similarity"></a>Proxy Measures for Semantic Similarity</h2><p>video $x_i$ 与 caption $y_{i}$ 是ground truth pair。</p>
<p>定义video 与 other captions 的语义相似度为：corresponding caption 与 other captions 之间的语义相似度。</p>
<p>$S_{S}\left(x_{i}, y_{j}\right)=\left\{\begin{array}{ll}1 &amp; i==j \\ S^{\prime}\left(y_{i}, y_{j}\right) &amp; \text { otherwise }\end{array}\right.$</p>
<p>关于 $S^{\prime}$ ，本文使用了四种方式来度量文本之间的语义相似度：bag of words, part-of- speech knowledge, synset similarity and the METEOR metric。</p>
<h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p><img src="https://i.loli.net/2021/03/22/oMS76vcp2HX5DgK.png" alt="image-20210322144739237" style="zoom:50%;"></p>
<h2 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h2><p>the log-ratio loss :</p>
<blockquote>
<p>Tao Qin, Tie-Yan Liu, and Hang Li. A general approximation framework for direct optimization of information retrieval measures. Information retrieval, 2010. </p>
</blockquote>
<p>nDCG loss</p>
<blockquote>
<p>Sungyeon Kim, Minkyo Seo, Ivan Laptev, Minsu Cho, and Suha Kwak. Deep metric learning beyond binary supervision. In CVPR, 2019. </p>
</blockquote>
]]></content>
      <categories>
        <category>cross-modal</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
      </tags>
  </entry>
  <entry>
    <title>Oscar: Object-Semantics Aligned Pre-training for Vision-Language Tasks</title>
    <url>/2020/04/16/Oscar-Object-Semantics-Aligned-Pre-training-for-Vision-Language-Tasks/</url>
    <content><![CDATA[<h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><ul>
<li>现在基于bert 来处理的vision-language task 存在的问题：现在的方将image region features 和 text features 拼起来，然后利用自我注意机制以暴力方式学习图像区域和文本之间的语义对齐。（1）<strong>由于没有显示的region 与 text poses之间的对齐监督，因此是一种弱监督的任务。</strong> （2）另外，vision region常常过采样(region之间有重叠)，从而带来噪声和歧义（由于重叠，导致region之间的特征区分性不大），这将会使得vision-language task任务更加具有挑战性。</li>
<li>本文通过引入从images中检测出的object tags 作为anchor points来减轻images 和 text 之间语义对齐的学习。</li>
<li>本文提出了一个新的vision-language pre-training method <strong>OSCAR</strong> ，设计训练样本是一个三元组：（word sequence, a set of object tags, and a set of image region features. ）</li>
<li>Motivated by: the salient objects in an image can be accurately detected by modern object detectors, and that these objects are often mentioned in the paired text.</li>
</ul>
<p><img src="https://i.loli.net/2021/03/24/4CDOtMWl29nxbef.jpg" alt="搜狗截图20200416190213.png"></p>
<h2 id="object-tags-对模型性能的影响"><a href="#object-tags-对模型性能的影响" class="headerlink" title="object tags 对模型性能的影响"></a>object tags 对模型性能的影响</h2><p><img src="https://i.loli.net/2021/03/24/pisT2h5IxnCwj1z.png" alt="image-20210324105618554"></p>
]]></content>
  </entry>
  <entry>
    <title>Pointing Novel Objects in Image Captioning</title>
    <url>/2019/07/26/Pointing-Novel-Objects-in-Image-Captioning/</url>
    <content><![CDATA[<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><img src="https://i.loli.net/2019/07/27/5d3c1676f301a18995.png" alt="搜狗截图20190727171628.png" title="搜狗截图20190727171628.png"></p>
<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul>
<li>当前的模型，都是以image-caption对来进行训练，因此训练模型只能输出in-domain objects，但是，在实际应用中有些图片含有丰富的信息，但是用现有的模型却不能充分的表达。   </li>
</ul>
<h4 id="解决1"><a href="#解决1" class="headerlink" title="解决1"></a>解决1</h4><ul>
<li>希望可以生成新的words,(没有出现在training dataset)   </li>
<li>本文提出了解决办法：用object learner 来扩增标准的deep caption 结构。即，由一个图像分类任务，则可以得到该图像中出现的obects。这可以作为一个补充信息，加入到当前现有的deep caption Model 中。   </li>
<li>具体地：（1）标准的LSTM decoder 会输出一个predicted word,  （2）objects learner 通过一个copying layer 也可以得到一个预测单词。那么该选谁，本文并不硬选择，而是软选择，即给一个系数，来给这两个分配个概率，然后加和。这个选择的过程称为 <strong>Pointing Mechanism</strong>   </li>
<li>loss:<br><img src="https://i.loli.net/2019/07/27/5d3c1c012cccc48971.png" alt="搜狗截图20190727173939.png" title="搜狗截图20190727173939.png">   </li>
</ul>
<h4 id="解决2"><a href="#解决2" class="headerlink" title="解决2:"></a>解决2:</h4><ul>
<li>希望将image中的所有信息，在句子中都可以覆盖到</li>
<li>提出了一个新的损失。target caption中含有 n词，即对应到image 中的 objects。那么希望生成的句子中含有的n词信息能够包含image中所有出现到的objects（即 target caption中的所有名词）</li>
<li>那么可以根据预测的单词是否生成了 target caption 中的名词，来计算损失（文章中这里在计算损失的时候忽略了语法结构，即不要求名词出现的在句子中的位置，只要求出现就可以）.   </li>
<li>loss:</li>
</ul>
<p><img src="https://i.loli.net/2019/07/27/5d3c1c754b56a83488.png" alt="搜狗截图20190727174134.png" title="搜狗截图20190727174134.png"><br><img src="https://i.loli.net/2019/07/27/5d3c1c7536e6674709.png" alt="搜狗截图20190727174147.png" title="搜狗截图20190727174147.png"> </p>
]]></content>
      <categories>
        <category>图像描述</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>Python:理解 yield 关键字</title>
    <url>/2019/02/25/Python-%E7%90%86%E8%A7%A3-yield-%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<pre><code>转载：https://liam.page/2017/06/30/understanding-yield-in-python/
</code></pre><h1 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h1><p>为了理解<a href="https://github.com/sususushi/reconstruction-network-for-video-captioning" target="_blank" rel="noopener">reconstruction-network</a> 代码中，如下代码是如何实现的，查看了此篇博客，并转载。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cycle</span><span class="params">(iterable)</span>:</span>  </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> iterable:  </span><br><span class="line">            <span class="keyword">yield</span> x</span><br><span class="line"></span><br><span class="line">train_data_loader = iter(cycle(MSVD.train_data_loader))</span><br><span class="line"><span class="keyword">for</span> iteration, batch <span class="keyword">in</span> enumerate(train_data_loader, <span class="number">1</span>):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> iteration == C.train_n_iteration:  </span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<p>解释：<strong>iter()</strong> 是python的一个函数，用来生成迭代器。而cycle中一整个for循环是对整个数据集调用一遍，而外部又有一个while true，该判断是一直成立的，则，会一直调用数据。因此此处不适用n_epoch 来停止加载数据，而是使用train_n_iteration。</p>
<hr>
<p>Python 是非常灵活的语言，其中 <code>yield</code> 关键字是普遍容易困惑的概念。</p>
<p>此篇将介绍 <code>yield</code> 关键字，及其相关的概念。</p>
<h2 id="迭代、可迭代、迭代器"><a href="#迭代、可迭代、迭代器" class="headerlink" title="迭代、可迭代、迭代器"></a>迭代、可迭代、迭代器</h2><h3 id="迭代（iteration）与可迭代（iterable）"><a href="#迭代（iteration）与可迭代（iterable）" class="headerlink" title="迭代（iteration）与可迭代（iterable）"></a>迭代（iteration）与可迭代（iterable）</h3><blockquote>
<p>迭代是一种操作；可迭代是对象的一种特性。</p>
</blockquote>
<p>很多数据都是「容器」；它们包含了很多其他类型的元素。实际使用容器时，我们常常需要逐个获取其中的元素。<strong>逐个获取元素的过程，就是「迭代」</strong>。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iteration</span></span><br><span class="line">a_list = [1, 2, 3]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a_list:</span><br><span class="line">    <span class="builtin-name">print</span>(i)</span><br></pre></td></tr></table></figure>
<p>如果我们可以从一个对象中，逐个地获取元素，那么我们就说这个对象是「可迭代的」。</p>
<p>Python 中的顺序类型，都是可迭代的（<code>list</code>, <code>tuple</code>, <code>string</code>）。其余包括 <code>dict</code>, <code>set</code>, <code>file</code> 也是可迭代的。对于用户自己实现的类型，如果提供了 <code>__iter__()</code> 或者 <code>__getitem__()</code> 方法，那么该类的对象也是可迭代的。</p>
<h3 id="迭代器（iterator）"><a href="#迭代器（iterator）" class="headerlink" title="迭代器（iterator）"></a>迭代器（iterator）</h3><blockquote>
<p>迭代器是一种对象。</p>
</blockquote>
<p>迭代器抽象的是一个「数据流」，是只允许迭代一次的对象。对迭代器不断调用 <code>next()</code> 方法，则可以依次获取下一个元素；当迭代器中没有元素时，调用 <code>next()</code> 方法会抛出 <code>StopIteration</code> 异常。迭代器的 <code>__iter__()</code> 方法返回迭代器自身；因此迭代器也是可迭代的。</p>
<h3 id="迭代器协议（iterator-protocol）"><a href="#迭代器协议（iterator-protocol）" class="headerlink" title="迭代器协议（iterator protocol）"></a>迭代器协议（iterator protocol）</h3><blockquote>
<p>迭代器协议指的是容器类需要包含一个特殊方法。</p>
</blockquote>
<p>如果一个容器类提供了 <code>__iter__()</code> 方法，并且该方法能返回一个能够逐个访问容器内所有元素的迭代器，则我们说该容器类实现了迭代器协议。</p>
<p>Python 中的迭代器协议和 Python 中的 <code>for</code> 循环是紧密相连的。</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">iterator</span> protocol <span class="keyword">and</span> <span class="keyword">for</span> <span class="keyword">loop</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> something:</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure>
<p>Python 处理 <code>for</code> 循环时，首先会调用内建函数 <code>iter(something)</code>，它实际上会调用 <code>something.__iter__()</code>，返回 <code>something</code> 对应的迭代器。而后，<code>for</code> 循环会调用内建函数 <code>next()</code>，作用在迭代器上，获取迭代器的下一个元素，并赋值给 <code>x</code>。此后，Python 才开始执行循环体。</p>
<h2 id="生成器、yield-表达式"><a href="#生成器、yield-表达式" class="headerlink" title="生成器、yield 表达式"></a>生成器、<code>yield</code> 表达式</h2><h3 id="生成器函数（generator-function）和生成器（generator）"><a href="#生成器函数（generator-function）和生成器（generator）" class="headerlink" title="生成器函数（generator function）和生成器（generator）"></a>生成器函数（generator function）和生成器（generator）</h3><blockquote>
<p>生成器函数是一种特殊的函数；生成器则是特殊的迭代器。</p>
</blockquote>
<p>如果一个函数包含 <code>yield</code> 表达式，那么它是一个生成器函数；调用它会返回一个特殊的迭代器，称为生成器。</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">def <span class="built_in">func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">def <span class="built_in">gen</span>():</span><br><span class="line">    yield <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>(<span class="built_in">type</span>(func))   <span class="meta"># &lt;class 'function'&gt;</span></span><br><span class="line"><span class="keyword">print</span>(<span class="built_in">type</span>(gen))    <span class="meta"># &lt;class 'function'&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>(<span class="built_in">type</span>(<span class="built_in">func</span>())) <span class="meta"># &lt;class 'int'&gt;</span></span><br><span class="line"><span class="keyword">print</span>(<span class="built_in">type</span>(<span class="built_in">gen</span>()))  <span class="meta"># &lt;class 'generator'&gt;</span></span><br></pre></td></tr></table></figure>
<p>如上，生成器 <code>gen</code> 看起来和普通的函数没有太大区别。仅只是将 <code>return</code> 换成了 <code>yield</code>。用 <code>type()</code> 函数打印二者的类型也能发现，<code>func</code> 和 <code>gen</code> 都是函数。然而，二者的返回值的类型就不同了。<code>func()</code> 是一个 <code>int</code> 类型的对象；而 <code>gen()</code> 则是一个迭代器对象。</p>
<h3 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield 表达式"></a><code>yield</code> 表达式</h3><p>如前所述，如果一个函数定义中包含 <code>yield</code> 表达式，那么该函数是一个生成器函数（而非普通函数）。实际上，<code>yield</code> 仅能用于定义生成器函数。</p>
<p>与普通函数不同，生成器函数被调用后，其函数体内的代码并不会立即执行，而是返回一个生成器（generator-iterator）。当返回的生成器调用成员方法时，相应的生成器函数中的代码才会执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">yield</span> x ** <span class="number">2</span></span><br><span class="line">square_gen = square()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> square_gen:</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure>
<p>前面说到，<code>for</code> 循环会调用 <code>iter()</code> 函数，获取一个生成器；而后调用 <code>next()</code> 函数，将生成器中的下一个值赋值给 <code>x</code>；再执行循环体。因此，上述 <code>for</code> 循环基本等价于：</p>
<figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line">genitor = square_gen.__iter__()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    x = geniter.<span class="keyword">next</span>()<span class="meta"> # Python 3 是 __next__()</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>
<p>注意到，<code>square</code> 是一个生成器函数；作为它的返回值，<code>square_gen</code> 已经是一个迭代器；迭代器的 <code>__iter__()</code> 返回它自己。因此 <code>geniter</code> 对应的生成器函数，即是 <code>square</code>。</p>
<p>每次执行到 <code>x = geniter.next()</code> 时，<code>square</code> 函数会从上一次暂停的位置开始，一直执行到下一个 <code>yield</code> 表达式，将 <code>yield</code> 关键字后的表达式列表返回给调用者，并再次暂停。注意，<strong>每次从暂停恢复时，生成器函数的内部变量、指令指针、内部求值栈等内容和暂停时完全一致</strong>。</p>
<h3 id="生成器的方法"><a href="#生成器的方法" class="headerlink" title="生成器的方法"></a>生成器的方法</h3><p>生成器有一些方法。调用这些方法可以控制对应的生成器函数；不过，若是生成器函数已在执行过程中，调用这些方法则会抛出 <code>ValueError</code> 异常。</p>
<ul>
<li><code>generator.next()</code>：从上一次在 <code>yield</code> 表达式暂停的状态恢复，继续执行到下一次遇见 <code>yield</code> 表达式。当该方法被调用时，当前 <code>yield</code> 表达式的值为 <code>None</code>，下一个 <code>yield</code> 表达式中的表达式列表会被返回给该方法的调用者。若没有遇到 <code>yield</code> 表达式，生成器函数就已经退出，那么该方法会抛出 <code>StopIterator</code> 异常。</li>
<li><code>generator.send(value)</code>：和 <code>generator.next()</code> 类似，差别仅在与它会将当前 <code>yield</code> 表达式的值设置为 <code>value</code>。</li>
<li><code>generator.throw(type[, value[, traceback]])</code>：向生成器函数抛出一个类型为 <code>type</code> 值为 <code>value</code> 调用栈为 <code>traceback</code> 的异常，而后让生成器函数继续执行到下一个 <code>yield</code> 表达式。其余行为与 <code>generator.next()</code> 类似。</li>
<li><code>generator.close()</code>：告诉生成器函数，当前生成器作废不再使用。</li>
</ul>
<h3 id="举例和说明"><a href="#举例和说明" class="headerlink" title="举例和说明"></a>举例和说明</h3><h4 id="如果你看不懂生成器函数"><a href="#如果你看不懂生成器函数" class="headerlink" title="如果你看不懂生成器函数"></a>如果你看不懂生成器函数</h4><p>如果你还是不太能理解生成器函数，那么大致上你可以这样去理解。</p>
<ul>
<li>在函数开始处，加入 <code>result = list()</code>；</li>
<li>将每个 <code>yield</code> 表达式 <code>yield expr</code> 替换为 <code>result.append(expr)</code>；</li>
<li>在函数末尾处，加入 <code>return result</code>。</li>
</ul>
<h4 id="关于「下一个」yield-表达式"><a href="#关于「下一个」yield-表达式" class="headerlink" title="关于「下一个」yield 表达式"></a>关于「下一个」<code>yield</code> 表达式</h4><p>介绍「生成器的方法」时，我们说当调用 <code>generator.next()</code> 时，生成器函数会从当前位置开始执行到下一个 <code>yield</code> 表达式。这里的「下一个」指的是执行逻辑的下一个。因此</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f123</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> f123(): <span class="comment"># 1, 2, and 3, will be printed</span></span><br><span class="line">    print(item)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f13</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">False</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> f13(): <span class="comment"># 1 and 3, will be printed</span></span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure>
<h4 id="使用-send-方法与生成器函数通信"><a href="#使用-send-方法与生成器函数通信" class="headerlink" title="使用 send() 方法与生成器函数通信"></a>使用 <code>send()</code> 方法与生成器函数通信</h4><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">def <span class="function"><span class="keyword">func</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        y = (yield x)</span><br><span class="line">        x += y</span><br><span class="line"></span><br><span class="line">geniter = <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">geniter.<span class="keyword">next</span>()  <span class="meta"># 1</span></span><br><span class="line">geniter.<span class="built_in">send</span>(<span class="number">3</span>) <span class="meta"># 4</span></span><br><span class="line">geniter.<span class="built_in">send</span>(<span class="number">10</span>)<span class="meta"># 14</span></span><br></pre></td></tr></table></figure>
<p>此处，生成器函数 <code>func</code> 用 <code>yield</code> 表达式，将处理好的 <code>x</code> 发送给生成器的调用者；与此同时，生成器的调用者通过 <code>send</code> 函数，将外部信息作为生成器函数内部的 <code>yield</code> 表达式的值，保存在 <code>y</code> 当中，并参与后续的处理。</p>
<p>这一特性是使用 <code>yield</code> 在 Python 中使用协程的基础。</p>
<h2 id="yield-的好处"><a href="#yield-的好处" class="headerlink" title="yield 的好处"></a><code>yield</code> 的好处</h2><p>Python 的老用户应该会熟悉 Python 2 中的一个特性：内建函数 <code>range</code> 和 <code>xrange</code>。其中，<code>range</code> 函数返回的是一个列表，而 <code>xrange</code> 返回的是一个迭代器。</p>
<blockquote>
<p>在 Python 3 中，<code>range</code> 相当于 Python 2 中的 <code>xrange</code>；而 Python 2 中的 <code>range</code> 可以用 <code>list(range())</code> 来实现。</p>
</blockquote>
<p>Python 之所以要提供这样的解决方案，是因为在很多时候，我们只是需要逐个顺序访问容器内的元素。大多数时候，我们不需要「一口气获取容器内所有的元素」。比方说，顺序访问容器内的前 5 个元素，可以有两种做法：</p>
<ul>
<li>获取容器内的所有元素，然后取出前 5 个；</li>
<li>从头开始，逐个迭代容器内的元素，迭代 5 个元素之后停止。</li>
</ul>
<p>显而易见，如果容器内的元素数量非常多（比如有 <code>10 ** 8</code> 个），或者容器内的元素体积非常大，那么后一种方案能节省巨大的时间、空间开销。</p>
<p>现在假设，我们有一个函数，其产出（返回值）是一个列表。而若我们知道，调用者对该函数的返回值，只有逐个迭代这一种方式。那么，如果函数生产列表中的每一个元素都需要耗费非常多的时间，或者生成所有元素需要等待很长时间，则使用 <code>yield</code> 把函数变成一个生成器函数，每次只产生一个元素，就能节省很多开销了。</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>REO-Relevance, Extraness, Omission: A Fine-grained Evaluation for Image Captioning</title>
    <url>/2020/07/02/REO-Relevance-Extraness-Omission-A-Fine-grained-Evaluation-for-Image-Captioning/</url>
    <content><![CDATA[<h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><ul>
<li>BLEU 和 CIDEr 是当前广泛使用的评价指标，来评估模型的整体性能。</li>
<li>但是这个<strong style="color:red;">得分往往不具备充分的信息量来说明被评估系统的specific errors.</strong></li>
<li>该文提出了一个细粒度的评估方法REO来自动的评估图像描述系统的性能。REO从三个层面来分析captions的质量：（1）与Ground Truth 的相关性（2）与ground truth 无关的额外性（3）在images 和 human references 中被忽略的元素。</li>
<li>在三个benchmark datasets上进行实验，本文提出的方法实现了与human judgments的高度一致性；与当前可用的评价指标相对比，该文提出的方法可以提供更加直观的评估结果。</li>
</ul>
<h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><ul>
<li><p>当前研究方法存在的问题</p>
<ul>
<li>当前自动的评估图像描述系统仍然是一个挑战，尤其是在量化图像描述系统生成的error仍有难度。</li>
<li>当前存在的评价指标可以分为两类，（1）rule-based metrics, 基于确切的字符串匹配。（2）learning-based metrics, 通过学习来预测test-caption 是人类生成的可能性。</li>
<li>大体上，先前的工作评估一个文本生成系统时，主要关注的是，相对于 ground truth data, 生成的description是否充分。虽然这个方面在之前的评价指标中已经被强调，但是当前存在的评价指标存在的一个共同的限制是，由于只能为caption quality 提供一个合成的分数，因此缺乏对 description errors的一个可解释性。缺乏这种细粒度的分析，开发人员便不能得到他们开发系统的确切的description errors.</li>
</ul>
</li>
<li><p>本文的解决办法：</p>
<ul>
<li>因此本文提出了一个称为REO的评估方法，从三个层面来评估caption, (1) Relevance: 相对于ground truth, candidate caption 与其相关性。(2) Extraness: 与ground truth 无关的额外性（3）Omission: 相对于在image content和 human references, condidate caption 中被忽略的元素。</li>
<li>如果将 caption generation看做image imformation embedding 的编码过程，我们可以通过根据有关图像内容的解码信息的<strong>相关性</strong>以及<strong>丢失或多余</strong>信息的数量来衡量解码过程的有效性，从而评估图像字幕系统。</li>
<li><strong>同时使用image 和 reference captions 作为评估的ground truth information</strong>, 本文的方法建立在一个由 grounding model 定义的共享的image-text embedding space， 该grounding model在一个大的benchmark数据集上进行预训练。</li>
<li>基于向量相似性来计算candidate caption 与 ground truth 之间的相关性。通过应用向量正交映射，来等同在candidate caption中携带的多余的和丢失的信息。</li>
</ul>
</li>
<li><p>实验部分</p>
<ul>
<li>在三个数据集上测试我们的方法，实验结果证明我们提出的方法与现存的评价指标相比，our method 与人类的评估更加一致。</li>
<li><strong style="color:red;"><strong>在本文的研究中发现，相对于caption与given image的相关性，人类标注者对caption中多余或者丢失的信息更加关注。</strong></strong></li>
<li>相比于单独仅仅使用image 或者 references作为ground truth, 同时使用效果更佳。</li>
</ul>
</li>
</ul>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><ul>
<li><p>Feature Extraction</p>
<ul>
<li>C: candidate caption; R: reference caption; V:region feature</li>
<li>Based on the SCAN model, extract the context information from the caption words for each detected region.</li>
</ul>
</li>
<li><p>Metric Scores</p>
<ul>
<li>具体的查看论文</li>
<li><strong style="color:red;">Relevance</strong> : The relevance between a candidate caption and a ground-truth reference based on the i-th region is computed by the cosine similarity</li>
<li><strong style="color:red;">Extraness</strong> : The extraness of C is captured by performing an orthogonal projection of a<sub>i</sub><sup>C</sup> to gi, which returns the vertical context vector a<sub>i</sub><sup>C</sup>? to represent the irrelevant content of C to the ground truth at the ith region.</li>
<li><strong style="color:red;">Omission</strong>: 类似于Extraness</li>
</ul>
</li>
</ul>
<h4 id="Experiments-Results"><a href="#Experiments-Results" class="headerlink" title="Experiments Results"></a>Experiments Results</h4><ul>
<li>==【yaya疑问】==<ul>
<li>关于pascal-50S 这个数据集，没太弄明白是怎么回事，如何计算accuracy</li>
<li>Kendall’s tau (τ) rank correlation 如何计算也不知道呢。。</li>
</ul>
</li>
<li><p><strong style="color:red;">【Can extra &amp; missing information be captured?】</strong></p>
<ul>
<li>在Extraness 和 Omission 这两个方面，本文提出的方法是用candidate caption 与 reference caption vector 上应用 orthogonal projection来计算 vector difference， 进而来得到Extraness/Omission representation。</li>
<li>但是这是<strong>一种</strong>本文设计的表征方式，为了评估该表征方式的合理性，本文作者又随机的采样了一些数据，手工标注出这些数据中真实的extraness和 omission。这样相当于得到了对于 extraness和omission的 ground truth</li>
<li>使用本文设计的方法而计算得到的 Extraness/Omission representation与 该文作者手工标注的  Extraness/Omission ground truth计算cosine similarity. 结果发现，相似度很高，说明本文提出的方法可以有效的捕捉 extraness和omission的表达。</li>
<li><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gc9jnm2041j30i90clq92.jpg" alt="搜狗截图20200226092626.png"></li>
<li>==【yaya疑问】== 该如何获得actual extraness E<sup>C</sup> 以及true omission O<sup>C</sup> 的特征表示？？？</li>
<li></li>
</ul>
</li>
<li><p><strong style="color:red;">【Do error-aware evaluation metrics help?】</strong></p>
<ul>
<li>相比于之前的评价指标，REO，尤其是extrance和omission, 在tau (τ) 上带来了显著的提高，</li>
<li>实验结果表明，human evaluation更加关注于候选caption 与 GT之间的无关性（相比于有关性而言）。</li>
<li>同时将image 和 reference captions作为 GT reference, 来评估candidate caption的效果好于单独使用这两个元素的效果。</li>
<li>human written descriptions 在单词的选择和句子的结构上更加灵活，当candidate caption与多样性的 reference  captions进行比较的时候，就会存在一个挑战。</li>
<li>extraness metric更加适合评估machine-generated captions</li>
<li>omission metric 更加适合评估testing data 是human-written descriptions</li>
<li></li>
</ul>
</li>
<li><p><strong style="color:red;">【What can we learn from the metric outputs?】</strong></p>
<ul>
<li>该段主要是想说明，本文提出的三个层面的评估，可以为开发者提供一个关于被开发模型的errors的具体分析，使开发者可以从evaluation score中分析model到底存在哪些specific error.</li>
<li>eg: 若generated caption是对图片内容的细节性描述，则Relevance 指标会提高，但是omission评价指标会降低.</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>图像描述</category>
        <category>评价指标</category>
      </categories>
  </entry>
  <entry>
    <title>Quality Estimation for Image Captions Based on Large-scale Human Evaluations</title>
    <url>/2019/12/12/Quality-Estimation-for-Image-Captions-Based-on-Large-scale-Human-Evaluations/</url>
    <content><![CDATA[<h3 id="Quality-Estimation-QE-of-image-captions"><a href="#Quality-Estimation-QE-of-image-captions" class="headerlink" title="Quality Estimation (QE) of image-captions"></a>Quality Estimation (QE) of image-captions</h3><ul>
<li>本文提出了在图像描述领域一个新的问题，Quality Estimation。由于当前的 automatic metric 非常依赖 ground-truth references，因此当一个模型训练好后，若是对一个 unseen images which don’t have gt sentence 进行描述，则无法对该描述进行评价。    </li>
</ul>
<h3 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h3><h4 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h4><ul>
<li>（1）首先在 Conceptual Captions dataset  上训练多个 image-captioning model （这个数据集会在比 coco上训练的captioning model 更好），captioning model的差异可以体现在 image feature extraction model，object detection提取的object 数量，caption decoder。    </li>
<li>（2）以上的 image-captioning model 可以为一个image 提供多个 sentence，作者对image 进行了脱敏处理    </li>
</ul>
<h4 id="数据打分及处理"><a href="#数据打分及处理" class="headerlink" title="数据打分及处理"></a>数据打分及处理</h4><ul>
<li><p>（1）这些 image-caption pairs 放到 crowdsource.google上让大家对这些 captioning，进行评价：好、坏或者跳过。每个image-captioning pair 被分配给10个人进行打分     </p>
</li>
<li><p>（2）得到收集的 rating image-captioning pairs 之后，对 unique image，将10个评分进行处理， using the equation y = round(mean(ri) ∗ 8)/8.     </p>
</li>
</ul>
<h4 id="QE-Model"><a href="#QE-Model" class="headerlink" title="QE Model"></a>QE Model</h4><ul>
<li>本文作者设计了两个模型（并把这两个模型进行融合）来处理 QE task。一个是使用到 image-captioning model，两一个是不使用   </li>
<li>（1）使用image-captioning model：<strong>Confidence-based Features QE Model</strong><br><img src="http://ww1.sinaimg.cn/large/006uWRWVgy1g9txhzr2swj30yc0i642k.jpg" alt="搜狗截图20191212143453.png"></li>
<li>（2） 不使用 image-captioning model：<strong>Generation-independent Bilinear QE model</strong><br><img src="http://ww1.sinaimg.cn/large/006uWRWVgy1g9txhzmt4rj30xs0apq5u.jpg" alt="搜狗截图20191212143515.png"></li>
</ul>
<h4 id="Spearman’s-ρ-Analysis"><a href="#Spearman’s-ρ-Analysis" class="headerlink" title="Spearman’s ρ Analysis"></a>Spearman’s ρ Analysis</h4><ul>
<li>该文的主要目的就是希望在 没有gt sentence 的情况下，对 unseen-image 进行描述时，可以给出一个caption 的评分。或者是说，该captioning与 人类的描述的相近程度。</li>
<li>该任务也是希望提出一个 machine learning metric similar to human evaluation （trained-metric），则对该模型好坏的一个的评判就是这个模型给出的评分与人类评分的相近程度。</li>
<li>predict： 模型对image-caption pair 的评分， Gt:  人类给出的评分</li>
<li>指标：Spearman’s correlation.  <a href="https://github.com/ShiYaya/spearman-rank" target="_blank" rel="noopener">my github explanation</a></li>
</ul>
]]></content>
      <categories>
        <category>图像描述</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>[Retrieve Fast, Rerank] Smart Cooperative and Joint Approaches for Improved Cross-Modal Retrieval</title>
    <url>/2021/03/23/Retrieve-Fast-Rerank-Smart-Cooperative-and-Joint-Approaches-for-Improved-Cross-Modal-Retrieval/</url>
    <content><![CDATA[<h2 id="现存的问题"><a href="#现存的问题" class="headerlink" title="现存的问题"></a>现存的问题</h2><ul>
<li>本文主要研究基于预训练跨模态模型<ul>
<li>pretrained from scratch and less scalable</li>
<li>huge retrieval latency</li>
</ul>
</li>
</ul>
<h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><ul>
<li>为了同时提高模型<strong>性能</strong>与<strong>效率</strong>。提出了一个新颖的微调框架，可以将任意预训练的 text-image 多模态模型转化为一个有效的检索模型。</li>
<li>该框架基于对检索和重新排序进行协作，该方法结合了：（1）双胞胎网络分别对语料库的所有项目进行编码，从而实现有效的初始检索； 2）交叉编码器组件，用于对检索到的小项目集进行更细微（即更智能）的排名。 </li>
<li>我们还建议通过共享权重共同微调这两个分量，从而产生一个参数更有效的模型。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Re-evaluating Evaluation in Text Summarization</title>
    <url>/2020/10/16/Re-evaluating-Evaluation-in-Text-Summarization/</url>
    <content><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><ul>
<li><p>ROUGE 在 text summarization 任务中被广泛使用，但是，关于ROUGE是否可能偏离human judgement 以及这种偏离可能改变有关baseline 和 proposed methods的相对优势得出的结论的讨论很少。</p>
</li>
<li><p>为了表征<strong>评估指标</strong>的相对优势，有必要执行meta-evaluation。</p>
<p>where a dataset annotated with human judgments is used to test the degree to which automatic metrics correlate there with.</p>
</li>
<li><p>现在存在关键问题：现有的人类判断数据集很少，尚不清楚<strong>现有指标</strong>在<em>当前得分最高的摘要系统</em>上的表现。</p>
</li>
<li><p>在本文中提出一个问题：摘要模型中模型开发的快速发展是否需要我们<strong>重新评估</strong>用于文本摘要的<strong>评估过程</strong>。因此，在本文中，收集了一个large benchmark 来用于 meta-evaluating summarization metrics。</p>
<ul>
<li><p>数据来源于：25 top-scoring extractive and abstractive summarization systems on the CNN/DailyMail dataset.</p>
</li>
<li><p>Automatic: traditional metrics (e.g. ROUGE) and modern semantic matching metrics (e.g.  BERTScore, MoverScore).</p>
</li>
<li><p>Manual evaluations: 使用轻量级金字塔方法（Shapira等，2019），我们将其用作summarization systems 和 automated metrics的黄金标准。（yaya: 收集的human judgements 既可以作为评判systems好坏的标准，也可以作为评判metrics好坏的标准）</p>
<blockquote>
<p>Ori Shapira, <strong>Crowdsourcing lightweight pyramids for manual summary evaluation.</strong>  NAACL 2019</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="标注过程"><a href="#标注过程" class="headerlink" title="标注过程"></a>标注过程</h3><ul>
<li>对于一个document，仅存在一个reference，对该reference, 提取SCUs, 如下表展示出来的所示。该步骤由作者本人完成。</li>
<li>对于该document 的 candidate summary, 查看 SCUs 是否出现在 candidate summary 中，并标注为 “present” 或者是 “not present”。该步骤的操作由4个workers共同完成。</li>
<li>对于 each documents，查验是否存在 noisy worker, 即对于一个SCU，大多数认为其”present”，但是他却认为”not present”，在该document的大多数SCUs中他的annotations都与众数不同，则定义为 noisy workers，并将其标注的结果去除掉。</li>
</ul>
<p><img src="https://i.loli.net/2020/10/16/m7Cxl6hnvOwPeSc.png" alt="image-20201016121420397"></p>
<h3 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h3><p>本文想要研究的核心问题：“does the rapid progress of model development in summarization models require us to re-evaluate the evaluation process used for text summarization?”</p>
<p>因此本文从四个方面 to meta-evaluate current metrics。(1) evaluate all systems; (2) evaluate top-k strongest systems; (3) compare two systems; (4) evaluate individual summaries.</p>
<h4 id="evaluate-all-systems"><a href="#evaluate-all-systems" class="headerlink" title="evaluate all systems"></a>evaluate all systems</h4><p><img src="https://i.loli.net/2020/10/16/Cy7RSaKrP6XOUnY.png" alt="image-20201016160058531" style="zoom:33%;"></p>
<p>通过对比不同的metrics 在 system level 的相关性发现，在不同的数据集上，metrics的相关性，性能并不一致。</p>
<blockquote>
<p>that metrics run the risk of overfitting to some datasets</p>
</blockquote>
<p>本文建议，在不同的数据集上，使用不同的metric来评估该数据集上不同的systems 的性能好坏</p>
<h4 id="evaluate-top-k-strongest-systems"><a href="#evaluate-top-k-strongest-systems" class="headerlink" title="evaluate top-k strongest systems"></a>evaluate top-k strongest systems</h4><p><img src="https://i.loli.net/2020/10/16/Zfn4Hh6g8uG5eXM.png" alt="image-20201016160240565"></p>
<p>结论：当 top-systems 数量较少时，或者说数量不稳定时，不同的metrics在同一个数据集上的效果也不稳定。</p>
<h4 id="compare-two-systems"><a href="#compare-two-systems" class="headerlink" title="compare two systems"></a>compare two systems</h4><p>we only have 100 annotated summaries to compare any two systems, sys1 and sys2, we use paired bootstrap resampling,</p>
<p>对于人类在sys1/2 上对所有的summaries 都有一个得分。</p>
<p>现，要比较两个system, 若有95%以上的confidence认为sys1 better than sys2, 则 ytrue=1, 否则 ytrue=2, 如果confidence&lt;95%, ytrue=0.</p>
<p>同理，对于所有的metrics, 通过同样的方式，也可以有此比较得分 ypred。</p>
<p>现有 J 个systems, 则可以得到 J<em>(J-1)/2 个compaired paris. 即，得到 长度为 J</em>(J-1)/2的mask.</p>
<p>计算 ytrue_mask 与 ypred_mask 的F1score.即可评估metrics在 compare two systems上的性能与human 的一致性。</p>
<p><img src="https://i.loli.net/2020/10/16/ys241wqHUpGmltO.png" alt="image-20201016161340716" style="zoom:33%;"></p>
<p>结论：Different metrics are better suited for different datasets. For example, on the CNNDM datasets, we recommend using R-2 while, on the TAC datasets, we recommend using JS-2.</p>
<h4 id="evaluate-individual-summaries"><a href="#evaluate-individual-summaries" class="headerlink" title="evaluate individual summaries"></a>evaluate individual summaries</h4><p><img src="https://i.loli.net/2020/10/16/iWLrRBSITJGpMoN.png" alt="image-20201016162009349" style="zoom: 50%;"></p>
<ul>
<li>以上三个实验都是system-level , 此实验是 summary-level</li>
</ul>
<p>分析：在不同的数据集上，同一metrics的性能不一致。如，R_1在TAC上与human相关性较低，但是在CNNDM上相关性较高。</p>
<p>另，前有文章表明，automatic metrics趋向于在system level 与 human的相关性较好，但是在 instance-level (summary-level) 相关性较差。我们进行实验发现，这种现象仅在TAC-2009 上表现明显。</p>
<p>结论：autometrics 在 summary-level 与 system-level 上的性能是一样的。</p>
<blockquote>
<p>Even though some metrics might be good at comparing summaries, they may point in the wrong direction when comparing systems</p>
</blockquote>
<p>另外，<strong>some metric在不同的数据集上的性能是不同的，因此是有必要在不同的数据集上测试各个评价指标的有效性</strong></p>
<h3 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h3><ul>
<li>（1）metric的选择不仅取决于不同的任务（例如，摘要，翻译），而且还取决于不同的数据集（例如，TAC，CNNDM）和应用程序场景（例如，系统级别，摘要级别）。未来的meta-evaluating 工作应调查效果这些设置对指标性能的影响。</li>
<li>（2）指标很容易在有限的数据集上过拟合。多数据集meta-evaluate 可以帮助我们更好地了解每个指标的特殊性，从而在各种情况下获得更好的指标选择。</li>
<li>（3）我们收集的人工判断可以用作监督，以实例化最近提出的预训练-然后-微调框架（最初用于机器翻译）（Sellam等，2020），学习一个强大的文本摘要指标。</li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
        <category>评价指标</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>(SGAE)Auto-Encoding Scene Graphs for Image Captioning</title>
    <url>/2019/03/16/SAGE-Auto-Encoding-Scene-Graphs-for-Image-Captioning/</url>
    <content><![CDATA[<p>本文是CVPR2019 的关于图像描述的文章，主要让我关注的原因是用到了scene graph 和 GCN，这也是本文最大的创新点。但是本文利用的是saptial GCN（悄悄说，构建的graph节点数量少，而且是异质的，不如说是多方面融合信息已达到丰富信息的目的 :-) ）</p>
<ul>
<li>后记<br>这里讲一下图卷积中spatial  gcn①②③ 与 spectral gcn ④⑤⑥<br>①Learning task-dependent distributed representations by backpropagation through structure.<br>②A new model for  learning in graph domains<br>③The graph neural network model<br>④Spectral networks and locally connected networks on graphs.<br>⑤Deep convolutional networks on graph-structured data.<br>⑥Semi-supervised classification with graph convolutional networks</li>
</ul>
<p>关于这篇论文采用的graph  convolutional network：采用的数</p>
<ul>
<li>为什么这样说？<br>本文提到了两类graph，一类是sentence scene graph，另一类是image scene graph，而在这两类下，又进行细分为relationship、attribute、object graph。但是，每个graph 中节点是异质的，比如在relationship graph中，obejct<sub>a</sub>， obejct<sub>b</sub>，relationship<sub>ab</sub>构成了一个graph，目的是来更新relationship embedding。从我的角度来看，只是融合相关信息来更新某一目标的特征，与graph无关。  </li>
<li>写在最前面，我个人的理解，在得到graph 节点的embedding 之后，就要输入gcn layer 来更新特征，这里，gcn layer 的表达公式可以这样理解： 该graph中所有的节点v<sub>i</sub>，经过concatenate之后，再经过一个全连接层。<br>gcn(.) = fc( concatenate(v1, v2, … , vn) )**</li>
</ul>
<p>下面说正文：</p>
<h1 id="General-encoder-decoder-network-for-image-captioning"><a href="#General-encoder-decoder-network-for-image-captioning" class="headerlink" title="General encoder-decoder network for image captioning"></a>General encoder-decoder network for image captioning</h1><ul>
<li><p>目前一般的encoder-decoder network for image captioning 是<strong>CNN提取image的特征，然后RNN来生成句子</strong>，例如下图所示。<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14r211sidj30kb0fy0v3.jpg" style="zoom:80%"></p>
</li>
<li><p>进一步有<strong>加入attention</strong> [1]，下图是提取14×14×512 feature map of the fourth  convolutional layer，然后 flatten to 196 × 512 before feed into decoder。在输入到decoder时对这196个feature vector进行attention的加权求和。<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14rdh7wg7j33ak1ep7wj.jpg" style="zoom:50%"></p>
</li>
<li><p>也有<strong>提取images 中的object，以此来提取显著信息，对object feature 进行attention的加权求和并送入decoder</strong>。具体地，使用RPN 的ROI pooling来提取objects feature，然后对LSTM的每一个step ,对这所有的object features进行attention操作，再作为输入送入LSTM[2]。如下图<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14u74yahwj30q30modsg.jpg" style="zoom:70%"></p>
</li>
</ul>
<h1 id="本文的encoder-decoder-baseline"><a href="#本文的encoder-decoder-baseline" class="headerlink" title="本文的encoder-decoder baseline"></a>本文的encoder-decoder baseline</h1><h2 id="1-Encoder"><a href="#1-Encoder" class="headerlink" title="1. Encoder"></a><strong>1.</strong> <strong>Encoder</strong></h2><p>本文有两个encoder ： image-encoder；sentence-encoder<br>本文sentence-encoder  是用来预训练Dictionary，并共享给 image-encoder。但是在baseline中不用GCN/MGCN 和 Dictionary，因此image-encoder与sentence-encoder 之间是没有交集的。（我猜测 baseline中没有用到sentence-encoder）</p>
<p><strong>（1）对于image encoder 得到object embedding，relationship embedding , attribute embedding。</strong></p>
<p>如何得到object embedding，relationship embedding , attribute embedding？</p>
<ul>
<li>object detector : 采用与[1]一致的方式来训练faster r-cnn， 0.7的阈值 for proposal NMS， 0.3的阈值for object NMS。Faster R-CNN在visual genome上预训练，预训练之后，对proposals采取0.7的IoU阈值进行NMS，对objects 采取0.3的IoU阈值进行NMS，对每个image，采取10-100个object。使用RoI pooling 来提取object features，该object features 将作为后边relationship classifier 和attribute classifier的输入。</li>
<li>relationship classifier：使用在[5] 中提到的LSTM结构来作为关系分类器，来为两个object 分配一个relationship label。</li>
<li>attribute classifier : 为某个object 分配属性标签，将该object feature输入fc-relu-fc-softmax网络，则得到属性标签。</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14vip74y0j311l09eq4y.jpg" style="zoom:60%">      </p>
<ul>
<li><p>以上三个输出的所有构成一个image scene graph  </p>
</li>
<li><p>需要说明以上三个是在<strong>Visual Genome数据集</strong>上预训练的，该数据集具有丰富的scene graph 标注，含有obejct’s categories，obejct’s attributes and pairwise relationships，因此可以用来训练目标检测器、属性分类器、关系分类器。但是由于这些标注含有很多噪声，因此采用一定的措施进行过滤：对于在数据集中出现超过2000次的objects，attributes，relationships保留下来，其余的去掉。经过这样的处理，则得到305个objects类，103个属性类，64个关系类  </p>
</li>
<li><p>经过分类器得到 label 之后，还需要得到相对应的embedding: <strong>u<sub>o</sub> , u<sub>r</sub> , u<sub>a</sub></strong> 。<br>其中 label 的维度472 = 305 + 103 + 64，即object/realation/attribute label的one hot vector 维度是三种节点的总类别数。<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14w80gi8tj30w70ik0xu.jpg" style="zoom:70%">  </p>
</li>
</ul>
<p><strong>（2）对于sentence encoder 使用[6] 来得到 parse scene graph，进而得到object embedding，relationship embedding , attribute embedding</strong><br>注意这里的sentences使用的是<strong>MS COCO</strong>中的caption，而不是Visual Genome中的caption。同样对其进行过滤，过滤掉在all parsed scene graph中出现的objects、attributes、relationships次数少于10的，则剩下5364个objects类，1308个realtionships类，3430个attributes类。<br>sentence encoder 使用[6] 来得到 parse scene graph，但实际上，[6]又是使用[7]中的方法，所以读者最好看[7]<br>这里介绍 一下[6] SPICE 是用来评价image caption的一个性能指标，这里为什么使用它，它是用来做为一个评价指标的吗？首先回答第二个问题，不是用来作为评价指标的，而是利用了它的原理：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1dwj56im1j30iq0nmk00.jpg"></p>
<p>parse scene graph 的过程：sentence-&gt; syntax dependency tree-&gt; scene graph<br>给定一个句子，首先分析句法依赖树，再根据给定句法依赖树的情况下，输出scene graph，而scene graph 的输出是对sentence中的每一个次元，输出其是object，还是 relation，还是attribute（即，对每个word 输出一个one hot vector （我的猜测））。如下图所示：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1gbldqsamj30q50kntkm.jpg"></p>
<p>经过parse scene graph得到的是object <strong>label</strong>、relationship <strong>label</strong>、attributes <strong>label</strong>的one hot vector（注意one hot 的长度是 5346+1308+3430 = 10102，即 将三种node合在了一起）。得到label之后，再经过word embedding层即可得到对应的word embedding: <strong>e<sub>o</sub> , e<sub>r</sub> , e<sub>a</sub></strong>。<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14w6j9aouj31670aqdiw.jpg" style="zoom:50%"></p>
<h2 id="2-Decoder"><a href="#2-Decoder" class="headerlink" title="2.  Decoder"></a><strong>2.</strong>  <strong>Decoder</strong></h2><p>由两层LSTM组成（该部分与论文[1][4] 的decoder部分是完全一致的，只是输入的encoder output不一样而已），下图给出了我自己画的decoder 结构[1]给出的结构[4]中给出的decoder结构</p>
<ul>
<li>在[4]中encoder output是GCN输出的object features（两个graph生成的encoder output分别送入decoder）。</li>
<li>但是在本文中encoder output是 <strong>u<sub>o</sub> , u<sub>r</sub> , u<sub>a</sub></strong> 组合成的d×M 矩阵，或者是 <strong>e<sub>o</sub> , e<sub>r</sub> , e<sub>a</sub></strong> 组合成的d×M 矩阵 。M = num_objects + num_relationships + num_attributes  注意：在sentence-encoder中的输出，这里的M是该句子的parse scene graph实际生成的object、relation、attribute的数量（有可能baseline 中不使用 sentence-encoder）；在image-encoder中的输出，这里也是实际的object detector、relationship classifier、attribute classifier 输出的实际数量总和</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14xg3jwvdj30mo0h2wfi.jpg" style="zoom:60%"><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g19d1x7kiij30im0bvaat.jpg" style="zoom:60%"><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14v8kb8kmj30sr0gzwgz.jpg" style="zoom:60%"><br>具体地，这里也给出本文的表达方式如下表:<br>这里的10369是对MS COCO中的captions 进行预处理之后，得到的 len of vocabulary<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14wrwfzplj30ze0hcjwe.jpg" style="zoom:60%"></p>
<h1 id="在baseline-上加东西"><a href="#在baseline-上加东西" class="headerlink" title="在baseline 上加东西"></a>在baseline 上加东西</h1><ul>
<li>一般的encoder-decoder如下图中的top所示，本文提出加入MGCN for image和GCN for sentence，同时加入Dictionary（共享参数 betwen sentence and image）<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14yn2vbtej30k40jzac6.jpg" style="zoom:50%"><br>由以上可知，构建了image scene graph 和 sentence scene graph，下面将本文的主要创新点，加入GCN和Dictionary  </li>
</ul>
<h2 id="sentence-graph-gt-GCN-更新embedding"><a href="#sentence-graph-gt-GCN-更新embedding" class="headerlink" title="sentence graph -&gt; GCN (更新embedding )"></a>sentence graph -&gt; GCN (更新embedding )</h2><p>经上面的分析构建的sentence scene graph 在得到了object、relation、attribute label 对应的word embedding之后，将通过GCN来更新embedding。</p>
<ul>
<li>表中的（7）（8）（9）可以认为是三个relationship、attribute、object graph。<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14y1f5p02j31370e1jw1.jpg" style="zoom:60%"></li>
<li>解释这里的<strong>g<sub>r</sub> g<sub>a</sub> g<sub>o</sub> g<sub>s</sub></strong><br>以<strong>g<sub>r</sub></strong> 为例：g<sub>r</sub> (D<sub>in</sub>，D<sub>out</sub>）。输入维度为什么是3000？因为e<sub>oi</sub> , e<sub>rij</sub> , e<sub>oj</sub>的维度分别均是1000，论文中省略了将其concatenate的操作的说明，但是实际上是进行了concatenate操作，使得维度变为3000，并作为g<sub>r</sub>的输入。输出是1000维度。</li>
<li><strong>因此这里图卷积层，可以认为是 该graph中所有的节点v<sub>i</sub>，经过concatenate之后，再经过一个全连接层。<br>g(.) = fc( concatenate(v1, v2, … , vn) )</strong><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14y594pa8j30og0ksdi2.jpg" style="zoom:50%">  </li>
</ul>
<h2 id="image-graph-gt-Multi-modal-GCN-更新embedding"><a href="#image-graph-gt-Multi-modal-GCN-更新embedding" class="headerlink" title="image graph -&gt; Multi-modal GCN (更新embedding )"></a>image graph -&gt; Multi-modal GCN (更新embedding )</h2><p>与sentence graph 对应的GCN类似，这里的 multimodal 也没什么意思，就是特征融合时（9）（10）（11），既使用了label 对应的word embedding，又使用了feature。<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14yf14p1mj30sp0k0ten.jpg">  </p>
<ul>
<li>解释这里的<strong>f<sub>r</sub> f<sub>a</sub> f<sub>o</sub> f<sub>s</sub></strong><br>与sentence scene graph 对应的g一致，首先对输入进行了concatenate操作<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14yhc6gpzj314l0gktax.jpg"></li>
</ul>
<h2 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h2><ul>
<li><strong>该部分的作用</strong>是一个memory network。首先Dictionary在<strong>S-&gt;G-&gt;D-&gt;S</strong>上预训练，之后才被用于<strong>I-&gt;G-&gt;D-&gt;S</strong>  。即是参数共享的。而在<strong>S-&gt;G-&gt;D-&gt;S</strong>中，输入的sentence是由human generated。因此Dictionary中就preserve human’s inductive bias。进而与<strong>I-&gt;G-&gt;D-&gt;S</strong>  共享，使得由image 生成的predict caption也含有 human’s inductive bias</li>
<li>由上文分析可知，经过GCN/MGCN更新的embedding的维度均是1000，则Dictionary的输入维度均是1000，D是可学习参数矩阵1000*10000，输入的x经过Dictionary得到 x^<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14yrlt89sj310c07e40b.jpg">  </li>
</ul>
<h2 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h2><p>经过encoder 结合GCN/MGCN之后，输出发生了改变，这里再讲一下decoder的输入。</p>
<ul>
<li>在<strong>S-&gt;G-&gt;D-&gt;S</strong> 这个序列过程中由D-&gt;S 即输入decoder LSTM的过程，输入的是D的输出。</li>
<li>而在<strong>I-&gt;G-&gt;D-&gt;S</strong> 这个序列过程中，输入decoder LSTM的过程，输入的是D的输出v’和G的输出v^，即concate[v’, v^]<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1507wpmlij30zf0h8dku.jpg"></li>
</ul>
<h1 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h1><ul>
<li>首先使用交叉熵损失函数训练 <strong>S-&gt;G-&gt;S</strong>  20 epoch。注意D不参与训练</li>
<li>使用交叉熵损失函数训练 <strong>S-&gt;G-&gt;D-&gt;S</strong>  20 epoch。这里的D参与训练</li>
<li>使用交叉熵损失函数训练 <strong>I-&gt;G-&gt;D-&gt;S</strong>  20 epoch。这里的D使用在上一步骤中预训练的参数，并fine-tune</li>
<li>使用RL-based reward 训练 <strong>I-&gt;G-&gt;D-&gt;S</strong>  40 epoch。 D参与训练  </li>
</ul>
<h1 id="推理过程"><a href="#推理过程" class="headerlink" title="推理过程"></a>推理过程</h1><ul>
<li>文章中没有写，但是我认为是<strong>I-&gt;G-&gt;D-&gt;S</strong>  </li>
</ul>
<h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><ul>
<li>由下表可知，实验结果并不突出，尤其是与GCN-LSTM[7]对比可知，GCN-LSTM的结构更加简单的情况下，两个模型的结果却相差不多。</li>
<li>可以看到表中有三个GCN-LSTM， 最上边那个是本文作者的复现，由于GCN-LSTM的作者batch_size 太大，本文作者觉得对比不公平，因此重新复现了代码（没公开代码）并减小了bs进行实验得到的结果。第二个GCN-LSTM（sem graph）是原作者论文中的实验数据。第三个GCN-LSTM是融合了semantic graph 和saptial graph。</li>
<li>对于SGAE的融合应该是输入decoder的不仅是<strong>I-&gt;G-&gt;D-&gt;S</strong> 中D的输出v’，而且也输入G的输出 v^，即concate[v’,  v^]<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14zjng66yj30oc0f0djs.jpg">   </li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] Bottom-up and top-down attention for image captioning and visual question answering<br>[2] Show, Attend and Tell: Neural Image Caption  Generation with Visual Attention<br>[3] Image Captioning with Object Detection and Localization<br>[4] Exploring Visual Relationship  for Image Captioning<br><strong>[5] Neural motifs: Scene graph parsing with global context</strong><br><strong>[6] Spice:  Semantic propositional image caption evaluation</strong><br><strong>[7] Generating Semantically Precise Scene Graphs from Textual Descriptions for Improved Image Retrieval</strong></p>
]]></content>
      <categories>
        <category>图像描述</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
        <tag>图卷积网络</tag>
      </tags>
  </entry>
  <entry>
    <title>(SCST)Self-critical Sequence Training for Image Captioning</title>
    <url>/2019/04/08/SCST-Self-critical-Sequence-Training-for-Image-Captioning/</url>
    <content><![CDATA[<p>强化学习中的策略梯度法可以针对那些不可微分的度量进行优化，<br>本文中，使用强化学习的方法来优化图像描述任务，将这个新的优化方法称为self-critical sequence training (SCST)。</p>
<p><strong>sequence models for image captioning的理想训练过程， 应该是避免 exposure bias 并且可以直接优化任务中的度量</strong></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="图像描述方面的现状"><a href="#图像描述方面的现状" class="headerlink" title="图像描述方面的现状"></a><strong>图像描述方面的现状</strong></h3><p>[1] <strong>show attend and tell</strong> 证明在caption任务中，使用attention机制是有益处的。<br>[2] <strong>Teacher-Forcing</strong> 用于文本的deep generative models 的训练方法一般是：给定上一步word的ground truth 来最大化该步生成word的最大似然，来反向传播。这个方法称为“Teacher-Forcing”  。但是这种方法导致在训练和测试时很不匹配。因为在测试时，该步生成的单词是在给定上一步预测出的单词的前提下。  </p>
<ul>
<li><p>这个exposure  bias [2]导致在测试时产生误差累积，因为模型从未暴露于其自己的预测中。<br>This exposure  bias [2], results in error accumulation during generation at  test time,<br>since the model has never been exposed to its own  predictions</p>
<p>一些克服exposure bias的方法[3] [4]<br>[3] <strong>Scheduled sampling</strong> 他们表明，反馈模型自己的预测，并在训练过程中缓慢地增加反馈概率p，可以显着地提高测试时间的性能。<br>[4] <strong>Professor forcing</strong> a  technique that uses adversarial training to encourage the dynamics of the recurrent network to be the same when training conditioned on ground truth previous words and when  sampling freely from the network</p>
</li>
</ul>
<h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><h3 id="实验结果证明"><a href="#实验结果证明" class="headerlink" title="实验结果证明"></a>实验结果证明</h3><p>we find that directly optimizing the CIDEr metric with  SCST and greedy decoding at test-time is highly effective.</p>
<h2 id="Image-Features"><a href="#Image-Features" class="headerlink" title="Image Features"></a>Image Features</h2><ul>
<li>FC Models<br>由CNN+FC得到image 的 特征向量，并送入LSTM中，来生成caption<br>但是需要注意的是仅在first step 输入该特征向量，其余步输入上一步生成的word (embedding)   </li>
<li>Spatial CNN features for Attention models<br>在不缩放也不裁剪图片的基础上，使用resnet-101来提取最后一个卷积层的特征，并应用apply spatially adaptive max-pooling来得到一个固定的尺寸14 × 14 × 2048。在每一个time step，attention model在这14 × 14=196个位置上计算一个<font color="#0099ff" size="6" face="黑体"> attention mask</font>（注意力系数/权重）。由这个mask 计算所有位置的加权求和，以此得到image feature。  </li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] Show, attend and tell: Neural image caption generation with visual attention. In ICML,  2015.<br>[2] Sequence level training with recurrent neural networks. ICLR, 2015.<br>[3] Scheduled sampling for sequence prediction with recurrent neural networks. In NIPS, 2015.<br>[4] Professor forcing: A  new algorithm for training recurrent networks. Neural Information Processing Systems. (NIPS) 2016.  </p>
]]></content>
      <categories>
        <category>图像描述</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>SPICE</title>
    <url>/2019/03/25/SPICE/</url>
    <content><![CDATA[<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><h3 id="Ubuntu下安装Stanford-CoreNLP"><a href="#Ubuntu下安装Stanford-CoreNLP" class="headerlink" title="Ubuntu下安装Stanford CoreNLP"></a><a href="https://blog.csdn.net/Hay54/article/details/82313535" target="_blank" rel="noopener">Ubuntu下安装Stanford CoreNLP</a></h3>]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Score_Videos</title>
    <url>/2020/06/21/Score-Videos/</url>
    <content><![CDATA[<p>Video: 8iPflOxQaao_000018_000028</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1Xf4y1y7AP&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: UArdunmwEdA_000049_000059</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1mt4y1X7fE&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: vTSO26j_g3E_000006_000016</p>
<iframe src="//player.bilibili.com/player.html?aid=286089586&bvid=BV1Rf4y1y7nN&cid=203899418&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: gf37sAjEfRc_000013_000023</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1Bz4y1Q7Ai&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: GXO1eYu4kr8_000000_000010</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1JT4y1J7R6&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: saXahlRV7s4_000022_000032</p>
<iframe src="//player.bilibili.com/player.html?aid=286068284&bvid=BV1df4y1y7oD&cid=203899246&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: Hgo7xkutPno_000059_000069</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1Ez411e7QD&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: NRC5oMoNHn0_000003_000013</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV12t4y1X7tM&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: IbDcOoO9m6g_000139_000149</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1ni4y1x7xP&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: tGiBJQ5RhZQ_000077_000087</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1cV411k7yR&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: _YWpv2_K8Pk_000054_000064</p>
<iframe src="//player.bilibili.com/player.html?aid=456121030&bvid=BV1D5411W7zB&cid=203800090&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: KvVRY61JS7A_000023_000033</p>
<iframe src="//player.bilibili.com/player.html?aid=841065180&bvid=BV1U54y1B7ga&cid=204027776&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: VNXpHy5Tb_U_000064_000074</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1if4y1y71S&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: dC2Ih_JFoOM_000000_000010</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1cD4y1Q7BX&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: lcUJjVgqXp4_000000_000010</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV19V411r7FF&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: uh50grtCQSA_000026_000036</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1ma4y1Y7HQ&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: cb3RvnukQVs_000159_000169</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1vk4y1z7GR&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: 5D4HjS92zSQ_000126_000136</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV17i4y1G7rb&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: kRdxCmOsY2Y_000003_000013</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV15A411i7Cg&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: _PdB7OGolCo_000191_000201</p>
<iframe src="//player.bilibili.com/player.html?aid=838500851&bvid=BV1Eg4y1q7fp&cid=203798508&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: 38Jn4r_pcpg_000167_000177</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1Xt4y1X7L1&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: 53Ia-BtpM5A_000002_000012</p>
<iframe src="//player.bilibili.com/player.html?aid=841116130&bvid=BV1X54y1B7pu&cid=203898322&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: 7QyQVBclhT4_000000_000010</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV18a4y1Y7Bn&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: QyMTEHd-VCc_000004_000014</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1v54y1B7X4&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: t-COcCPV-T4_000020_000030</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1ff4y1y7xc&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: oGpVHf4xooM_000160_000170</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1Bp4y1D7NJ&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p>Video: WU5KZsG_mQk_000483_000493</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1XC4y1a7Cf&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



]]></content>
  </entry>
  <entry>
    <title>Sentence-BERT: Sentence Embeddings using Siamese BERT-Networks</title>
    <url>/2020/05/31/Sentence-BERT-Sentence-Embeddings-using-Siamese-BERT-Networks/</url>
    <content><![CDATA[<h4 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h4><p>BERT 和 RoBERTa 在 sentence-pair regression tasks (eg: semantic textual similarity ) 上取得了非常不错的成绩，但是由于需要将两个句子都送入到网络中，这将造成计算量过载。举个例子，若在10000个句子中要找到最相似的对，则需要50 million的推理计算（需要计算一个上三角阵：（10000+1）*10000/2）, 使用BERT，则需要 65 hours。</p>
<p><strong>这可以看到the construction of BERT，不适于semantic similarity search、 像聚类这种无监督任务、information retrieval via semantic search等等。</strong></p>
<p><strong>因此本文：</strong> 本文提出了 sentence-BERT, 是建立在 预训练的BERT上的一种修改，使用siamese 和 triplet 网络结构来得到语义上有意义的sentence embeddings, 从而方便的计算cosine similarity.</p>
<h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h4><p>三种训练策略，现在只说到了一种，分类损失，，另外两种，是在哪些数据集上使用的？</p>
<h4 id="yaya-启发"><a href="#yaya-启发" class="headerlink" title="yaya 启发"></a>yaya 启发</h4><p>一、本文中提出的当前 BERT存在的缺陷，也正是 video-text retrieval ，这种多模态任务存在的缺陷。</p>
<p>二、We showed in (Reimers et al., 2016)[1] that Pearson correlation is badly suited for  STS. Instead, we compute the Spearman’s rank correlation between the cosine-similarity of the sentence embeddings and the gold labels  </p>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>[1] Nils Reimers, Philip Beyer, and Iryna Gurevych. 2016.<br><strong>Task-Oriented Intrinsic Evaluation of Semantic Textual Similarity.</strong><br>In Proceedings of the 26th International Conference on Computational Linguistics (COLING), pages 87–96.      </p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Show, Attend and Tell: Neural Image Caption Generation with Visual Attention</title>
    <url>/2019/05/06/Show-Attend-and-Tell-Neural-Image-Caption-Generation-with-Visual-Attention/</url>
    <content><![CDATA[<ul>
<li>encoder  attention<br>本文的出发点是利用低层次的特征，并结合了attention 机制<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2re7nfbn3j30q70430sx.jpg"></li>
</ul>
<p>参考链接：<a href="https://blog.csdn.net/shenxiaolu1984/article/details/51493673" target="_blank" rel="noopener">https://blog.csdn.net/shenxiaolu1984/article/details/51493673</a></p>
]]></content>
      <categories>
        <category>图像描述</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>Semantic Equivalent Adversarial Data Augmentation for Visual Question Answering</title>
    <url>/2021/03/12/Semantic-Equivalent-Adversarial-Data-Augmentation-for-Visual-Question-Answering/</url>
    <content><![CDATA[<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p>受到深度学习的快速发展，VQA 近年来取得了非常成功的进展。数据增强是深度学习中的一个有用的技巧，但是，目前很少有工作关注于VQA任务的数据增强。</p>
<p>对于image side: 一些简单的数据增强操作不能直接应用到VQA这一场景下，比如，rotation and flipping 等操作，都可能导致<image, question, answer> 这一结构的正确性遭到破坏。</image,></p>
<p>对于text side (eg: questions) , it is challenging to come up with <strong>generalized rules for language transformation.</strong> 另外，有一类任务是Visual Question Generation，根据image和 answer来生成问题，但是生成的问题常常是有语法错误的，而且，他们在同一个目标数据集上进行学习，生成的数据与原始数据的分布是一致的，因此，<strong>若使用这种方案来做数据扩充，难以解决过拟合问题</strong>(通常训练数据和测试数据不是同一个分布)。</p>
<p>在本文中，不直接对image或者是question进行操作，而是对images 和 questions生成对抗样本作为数据增强。增强的样本不会改变image的原始语义，也不会改变questions中的semantic meaning。对抗性示例是经过<strong>策略</strong>修改的样本，可以成功地欺骗深层模型以做出不正确的预测。这种修改是难以察觉的，<strong>它在使对抗性示例的基础分布远离原始数据的同时保持了数据的语义。</strong>本文是第一个同时对image 和 text进行数据扩充的方法（已有的方法只是单独对一方面进行数据扩充）。</p>
<p>进而，使用本文方法产生的<strong>数据增强样本</strong>和<strong>对抗训练</strong>来训练经典的VQA model (BUTD) 。</p>
<p>实验结果证明，不仅可以提高 VQAv2的整体性能，而且相比于baseline还可以有效抵抗对抗攻击。</p>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p><img src="https://i.loli.net/2021/03/12/rmyqUFXQewT2PBK.png" alt="image-20210312165449352" style="zoom:50%;"></p>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><h4 id="何时加入对抗样本"><a href="#何时加入对抗样本" class="headerlink" title="何时加入对抗样本"></a>何时加入对抗样本</h4><ul>
<li><p>本文发现，将干净样本和对抗样本进行混合，然后<strong>从头到尾</strong>的训练，这种方案不会在干净样本上收敛。因此本文只在特定的训练时期对样本进行混合，最后使用干净样本进行微调。</p>
<p>本文实验中max-epoch=25.</p>
<p><img src="https://i.loli.net/2021/03/12/YOblV6WT4rtMkSf.png" alt="image-20210312171853940" style="zoom: 50%;"></p>
<p>本文的解释：与干净样本相比，对抗样本与其有不同的分布。如果把提升模型在VQA任务上的性能作为我们的主要目标，那么模型在干净样本上的拟合能力需要<strong>在结束</strong>的时候to be retrieved。而<strong>在开始</strong>时，模型需要warm up，此时不适合加入对抗样本。因此在中间阶段加入融合对抗样本的训练。</p>
</li>
<li><p>实验证明本文提出的方法不仅可以提高在干净样本上的VQA任务的性能，还能提高<strong>在对抗样本上的鲁棒性</strong>。</p>
</li>
</ul>
<h4 id="相比于baseline还可以有效抵抗对抗攻击"><a href="#相比于baseline还可以有效抵抗对抗攻击" class="headerlink" title="相比于baseline还可以有效抵抗对抗攻击"></a>相比于baseline还可以有效抵抗对抗攻击</h4><p><img src="https://i.loli.net/2021/03/12/np4eUgXwkz2rK5M.png" alt="image-20210312172242341" style="zoom:50%;"></p>
<h3 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h3><ul>
<li><strong>何时加入对抗样本</strong> 这个实验告诉我们：一般情况，我们提出一种数据增强方案，通常会从头到尾的使用，但是未必是好的。</li>
</ul>
]]></content>
      <categories>
        <category>cross-modal</category>
        <category>VQA</category>
      </categories>
      <tags>
        <tag>cross-modal,VQA</tag>
      </tags>
  </entry>
  <entry>
    <title>Score_sentences</title>
    <url>/2020/06/21/Score-sentences/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>Slot Filling</title>
    <url>/2021/03/15/Slot-Filling/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Spacy工具包</title>
    <url>/2019/07/16/Spacy%E5%B7%A5%E5%85%B7%E5%8C%85/</url>
    <content><![CDATA[<h2 id="spacy的主要操作："><a href="#spacy的主要操作：" class="headerlink" title="spacy的主要操作："></a>spacy的主要操作：</h2><h3 id="1、分词断句"><a href="#1、分词断句" class="headerlink" title="1、分词断句"></a>1、分词断句</h3><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">import spacy</span><br><span class="line">nlp = spacy.<span class="built_in">load</span>(<span class="string">'en'</span>)</span><br><span class="line">doc = nlp(<span class="string">'Hello World! My name is HanXiaoyang'</span>)</span><br><span class="line"><span class="comment"># 分词</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">token</span> <span class="keyword">in</span> doc:</span><br><span class="line">    print(<span class="string">'"'</span> + <span class="keyword">token</span>.<span class="keyword">text</span> + <span class="string">'"'</span>)</span><br><span class="line"><span class="comment"># 断句</span></span><br><span class="line"><span class="keyword">for</span> sent <span class="keyword">in</span> doc.sents:</span><br><span class="line">    print(sent)</span><br></pre></td></tr></table></figure>
<p>每个token对象有着非常丰富的属性，如下的方式可以取出其中的部分属性。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">doc</span> <span class="string">=</span> <span class="string">nlp("Next</span> <span class="string">week</span> <span class="string">I'll</span>   <span class="string">be</span> <span class="string">in</span> <span class="string">Shanghai.")</span></span><br><span class="line"><span class="string">for</span> <span class="string">token</span> <span class="string">in</span> <span class="attr">doc:</span></span><br><span class="line">    <span class="string">print("&#123;0&#125;\t&#123;1&#125;\t&#123;2&#125;\t&#123;3&#125;\t&#123;4&#125;\t&#123;5&#125;\t&#123;6&#125;\t&#123;7&#125;".format(</span></span><br><span class="line">        <span class="string">token.text,</span></span><br><span class="line">        <span class="string">token.idx,</span></span><br><span class="line">        <span class="string">token.lemma_,</span></span><br><span class="line">        <span class="string">token.is_punct,</span></span><br><span class="line">        <span class="string">token.is_space,</span></span><br><span class="line">        <span class="string">token.shape_,</span></span><br><span class="line">        <span class="string">token.pos_,</span></span><br><span class="line">        <span class="string">token.tag_</span></span><br><span class="line">    <span class="string">))</span></span><br><span class="line"><span class="string">输出结果如下：</span></span><br><span class="line"><span class="string">Next</span>    <span class="number">0</span>   <span class="string">next</span>    <span class="literal">False</span>   <span class="literal">False</span>   <span class="string">Xxxx</span>    <span class="string">ADJ</span> <span class="string">JJ</span></span><br><span class="line"><span class="string">week</span>    <span class="number">5</span>   <span class="string">week</span>    <span class="literal">False</span>   <span class="literal">False</span>   <span class="string">xxxx</span>    <span class="string">NOUN</span>    <span class="string">NN</span></span><br><span class="line"><span class="string">I</span>   <span class="number">10</span>  <span class="bullet">-PRON-</span>  <span class="literal">False</span>   <span class="literal">False</span>   <span class="string">X</span>   <span class="string">PRON</span>    <span class="string">PRP</span></span><br><span class="line"><span class="string">'ll 11  will    False   False   '</span><span class="string">xx</span> <span class="string">VERB</span>    <span class="string">MD</span></span><br><span class="line">    <span class="number">15</span>      <span class="literal">False</span>   <span class="literal">True</span>        <span class="string">SPACE</span>   <span class="string">_SP</span></span><br><span class="line"><span class="string">be</span>  <span class="number">17</span>  <span class="string">be</span>  <span class="literal">False</span>   <span class="literal">False</span>   <span class="string">xx</span>  <span class="string">VERB</span>    <span class="string">VB</span></span><br><span class="line"><span class="string">in</span>  <span class="number">20</span>  <span class="string">in</span>  <span class="literal">False</span>   <span class="literal">False</span>   <span class="string">xx</span>  <span class="string">ADP</span> <span class="string">IN</span></span><br><span class="line"><span class="string">Shanghai</span>    <span class="number">23</span>  <span class="string">shanghai</span>    <span class="literal">False</span>   <span class="literal">False</span>   <span class="string">Xxxxx</span>   <span class="string">PROPN</span>   <span class="string">NNP</span></span><br><span class="line"><span class="string">.</span>   <span class="number">31</span>  <span class="string">.</span>   <span class="literal">True</span>    <span class="literal">False</span>   <span class="string">.</span>   <span class="string">PUNCT</span>   <span class="string">.</span></span><br></pre></td></tr></table></figure>
<h3 id="2、词性标注"><a href="#2、词性标注" class="headerlink" title="2、词性标注"></a>2、词性标注</h3><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 词性标注</span></span><br><span class="line">doc = nlp(<span class="string">"Next week I'll be in Shanghai."</span>)</span><br><span class="line">print([(<span class="keyword">token</span>.<span class="keyword">text</span>, <span class="keyword">token</span>.tag_) <span class="keyword">for</span> <span class="keyword">token</span> <span class="keyword">in</span> doc])</span><br></pre></td></tr></table></figure>
<p>[(‘Next’, ‘JJ’), (‘week’, ‘NN’), (‘I’, ‘PRP’), (“‘ll”, ‘MD’), (‘be’, ‘VB’), (‘in’, ‘IN’), (‘Shanghai’, ‘NNP’), (‘.’, ‘.’)]</p>
<h3 id="3、组块分析"><a href="#3、组块分析" class="headerlink" title="3、组块分析"></a>3、组块分析</h3><p>spaCy可以自动检测名词短语，并输出根(root)词，比如下面的”Journal”,”piece”,”currencies”</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">doc = nlp(<span class="string">"Wall Street Journal just published an interesting piece on crypto currencies"</span>)</span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> doc<span class="selector-class">.noun_chunks</span>:</span><br><span class="line">    print(chunk<span class="selector-class">.text</span>, chunk<span class="selector-class">.label_</span>, chunk<span class="selector-class">.root</span><span class="selector-class">.text</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果：<br>Wall Street Journal NP Journal<br>an interesting piece NP piece<br>crypto currencies NP currencies</p>
<h3 id="4、命名实体识别"><a href="#4、命名实体识别" class="headerlink" title="4、命名实体识别"></a>4、命名实体识别</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">doc = nlp(<span class="string">"Two years ago, I lived in my Beijing."</span>)</span><br><span class="line"><span class="keyword">for</span> ent <span class="keyword">in</span> doc<span class="selector-class">.ents</span>:</span><br><span class="line">    print(ent<span class="selector-class">.text</span>, ent.label_)</span><br></pre></td></tr></table></figure>
<p>输出结果：<br>Two years ago DATE<br>BeijingGPE</p>
<p>还可以用非常漂亮的可视化做显示：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> spacy import displacy</span><br><span class="line">displacy.render(doc, <span class="attribute">style</span>=<span class="string">'ent'</span>, <span class="attribute">jupyter</span>=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p><img src="//upload-images.jianshu.io/upload_images/11681023-77f9837fa7e661dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/454/format/webp" alt></p>
<p>输出结果.png</p>
<h3 id="5、句法依存解析"><a href="#5、句法依存解析" class="headerlink" title="5、句法依存解析"></a>5、句法依存解析</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">doc = nlp(<span class="string">'Wall Street Journal just published an interesting piece on crypto currencies'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> doc:</span><br><span class="line">    print(<span class="string">"&#123;0&#125;/&#123;1&#125; &lt;--&#123;2&#125;-- &#123;3&#125;/&#123;4&#125;"</span>.format(</span><br><span class="line">        token<span class="selector-class">.text</span>, token<span class="selector-class">.tag_</span>, token<span class="selector-class">.dep_</span>, token<span class="selector-class">.head</span><span class="selector-class">.text</span>, token<span class="selector-class">.head</span><span class="selector-class">.tag_</span>))</span><br></pre></td></tr></table></figure>
<p>输出结果：<br>Wall/NNP &lt;—compound— Street/NNP<br>Street/NNP &lt;—compound— Journal/NNP<br>Journal/NNP &lt;—nsubj— published/VBD<br>just/RB &lt;—advmod— published/VBD<br>published/VBD &lt;—ROOT— published/VBD<br>an/DT &lt;—det— piece/NN<br>interesting/JJ &lt;—amod— piece/NN<br>piece/NN &lt;—dobj— published/VBD<br>on/IN &lt;—prep— piece/NN<br>crypto/JJ &lt;—compound— currencies/NNS<br>currencies/NNS &lt;—pobj— on/IN</p>
<h3 id="6、-词向量"><a href="#6、-词向量" class="headerlink" title="6、==词向量=="></a>6、==词向量==</h3><p>NLP中有一个非常强大的文本表示学习方法叫做==word2vec==，通过词的上下文学习到词语的稠密向量化表示，同时在这个表示形态下，语义相关的词在向量空间中会比较接近。也有类似v(爷爷)-v(奶奶) ≈ v(男人)-v(女人)的关系。<br>在spaCy中，要使用英文的词向量，需先下载预先训练好的结果。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">python3</span> -m spacy download en_core_web_lg</span><br></pre></td></tr></table></figure>
<p>词向量的应用：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">nlp = spacy.<span class="built_in">load</span>(<span class="string">'en_core_web_lg'</span>)</span><br><span class="line"><span class="built_in">from</span> scipy import spatial</span><br><span class="line"></span><br><span class="line"><span class="comment"># 余弦相似度计算</span></span><br><span class="line">cosine_similarity = lambda x, y: <span class="number">1</span> - spatial.distance.cosine(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 男人、女人、国王、女王 的词向量</span></span><br><span class="line">man = nlp.vocab[<span class="string">'man'</span>].vector</span><br><span class="line">woman = nlp.vocab[<span class="string">'woman'</span>].vector</span><br><span class="line">queen = nlp.vocab[<span class="string">'queen'</span>].vector</span><br><span class="line">king = nlp.vocab[<span class="string">'king'</span>].vector</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 我们对向量做一个简单的计算，"man" - "woman" + "queen"</span></span><br><span class="line">maybe_king = man - woman + queen</span><br><span class="line">computed_similarities = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 扫描整个词库的词向量做比对，召回最接近的词向量</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">word</span> <span class="keyword">in</span> nlp.vocab:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">word</span>.has_vector:</span><br><span class="line">        continue</span><br><span class="line"> </span><br><span class="line">    similarity = cosine_similarity(maybe_king, <span class="built_in">word</span>.vector)</span><br><span class="line">    computed_similarities.append((<span class="built_in">word</span>, similarity))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序与最接近结果展示</span></span><br><span class="line">computed_similarities = sorted(computed_similarities, key=lambda <span class="keyword">item</span>: -<span class="keyword">item</span>[<span class="number">1</span>])</span><br><span class="line">print([w[<span class="number">0</span>].<span class="keyword">text</span> <span class="keyword">for</span> w <span class="keyword">in</span> computed_similarities[:<span class="number">10</span>]])</span><br></pre></td></tr></table></figure>
<p>输出结果：<br>[‘Queen’, ‘QUEEN’, ‘queen’, ‘King’, ‘KING’, ‘king’, ‘KIng’, ‘Kings’, ‘KINGS’, ‘kings’]</p>
<h3 id="6、词汇与文本相似度"><a href="#6、词汇与文本相似度" class="headerlink" title="6、词汇与文本相似度"></a>6、词汇与文本相似度</h3><p>在词向量的基础上，spaCy提供了从词到文档的相似度计算的方法，下面的例子是它的使用方法。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 词汇语义相似度(关联性)</span></span><br><span class="line">banana = nlp.vocab['banana']</span><br><span class="line">dog = nlp.vocab['dog']</span><br><span class="line">fruit = nlp.vocab['fruit']</span><br><span class="line">animal = nlp.vocab['animal']</span><br><span class="line"> </span><br><span class="line">print(dog.similarity(animal), dog.similarity(fruit)) <span class="comment"># 0.6618534 0.23552845</span></span><br><span class="line">print(banana.similarity(fruit), banana.similarity(animal)) <span class="comment"># 0.67148364 0.2427285</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文本语义相似度(关联性)</span></span><br><span class="line">target = nlp(<span class="string">"Cats are beautiful animals."</span>)</span><br><span class="line"> </span><br><span class="line">doc1 = nlp(<span class="string">"Dogs are awesome."</span>)</span><br><span class="line">doc2 = nlp(<span class="string">"Some gorgeous creatures are felines."</span>)</span><br><span class="line">doc3 = nlp(<span class="string">"Dolphins are swimming mammals."</span>)</span><br><span class="line"> </span><br><span class="line">print(target.similarity(doc1))  <span class="comment"># 0.8901765218466683</span></span><br><span class="line">print(target.similarity(doc2))  <span class="comment"># 0.9115828449161616</span></span><br><span class="line">print(target.similarity(doc3))  <span class="comment"># 0.7822956752876101</span></span><br></pre></td></tr></table></figure>
<p>作者：还是那个没头脑<br>链接：<a href="https://www.jianshu.com/p/74e6c5376bc0" target="_blank" rel="noopener">https://www.jianshu.com/p/74e6c5376bc0</a><br>来源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Spatio-Temporal Dynamics and Semantic Attribute Enriched Visual Encoding for Video Captioning</title>
    <url>/2019/03/01/Spatio-Temporal-Dynamics-and-Semantic-Attribute-Enriched-Visual-Encoding-for-Video-Captioning/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Spatio-Temporal Dynamics and Semantic Attribute Enriched Visual Encoding for Video Captioning（CVPR2019）</title>
    <url>/2019/05/10/Spatio-Temporal-Dynamics-and-Semantic-Attribute-Enriched-Visual-Encoding-for-Video-Captioning-1/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/09/02/T5AzpW8DHkVL2Oy.png" alt="搜狗截图20190902152617.png"></p>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul>
<li>我们的方法丰富视觉特征的<strong>时域动态temporal dynamics</strong>，通过在整个video上分层对CNN特征应用短的fourier 变换</li>
<li>从object detector 中提取高层语义，来丰富被检测object 的<strong>空间动态 spatial dynamics</strong></li>
<li>最终的表达映射到一个压缩的空间</li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul>
<li>object detector YOLO[1]</li>
<li>目标检测和C3D的输出层被用来得到高层语义属性，</li>
<li>提出的视觉特征包含检测的目标属性、目标发生的频率</li>
</ul>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>现有的video captioning model 一种使用平均池化得到特征，一种使用attention得到high level特征，但是这些视觉特征都是直接的被使用，则，这些方法没有充分利用CNN在视频字幕框架中的最新特性。我们的模型丰富了视觉特征，实验结果证明，该视觉特征与任意一个简单的语言模型相结合，可以提高其性能。</p>
<h2 id="Visual-Representation"><a href="#Visual-Representation" class="headerlink" title="Visual Representation"></a>Visual Representation</h2><ul>
<li>the visual representation of a  video V as v = [α; β; γ; η]</li>
<li>α; β; γ; η 是四个列向量，下面具体介绍如何得到这四个列向量<h3 id="Encoding-temporal-dynamics"><a href="#Encoding-temporal-dynamics" class="headerlink" title="Encoding temporal dynamics"></a>Encoding temporal dynamics</h3></li>
<li>首先已经有 f 帧 对应的CNN[2]特征向量，和c个clip对应的C3D[3]得到的特征向量</li>
<li>对某个video而言，其所有帧再某一个维度的神经元，组成了一个特征向量a，利用<strong>傅里叶变换</strong>得到一个p维度的特征向量，将a分成两半，分别进行傅里叶变换，得到一个p维度的特征向量，再次进行分半，等等一系列操作，可以得到 p×7的矩阵。则对于所有的神经元m 则得到m×p×7的张量。至此得到<strong>α</strong></li>
<li><strong>β</strong>同理，只是对clips对应的C3D特征进行处理</li>
<li>目前已经有将傅里叶变换应用在行为识别上的文章吗，但是本文是第一篇将傅里叶变换应用在视频描述上的文章。</li>
<li><font color="#0099ff" size="4" face="黑体">但是需要注意的是，该文并没有说明使用傅里叶变换的动机（rich temporal dynamics?），但是为什么使用傅里叶变换可以丰富？？</font>

</li>
</ul>
<h3 id="Encoding-Semantics-and-Spatial-Evolution"><a href="#Encoding-Semantics-and-Spatial-Evolution" class="headerlink" title="Encoding Semantics and Spatial Evolution"></a>Encoding Semantics and Spatial Evolution</h3><ul>
<li>比较复杂，利用object detector YOLO 来提取Object 以及C3D来加强语义信息，具体看论文吧</li>
</ul>
<h2 id="Experimental-Results-on-MSVD"><a href="#Experimental-Results-on-MSVD" class="headerlink" title="Experimental Results on MSVD"></a>Experimental Results on MSVD</h2><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2wd8q6kegj30dh0ig0wc.jpg">    </p>
<ul>
<li>GRU-MP - (C3D) 与 使用了傅里叶变换的GRU-EVEhft - (C3D)  相比，可知，使用傅里叶变换是有小鬼的</li>
<li>GRU-EVEhft - (CI) 与GRU-EVEhft+sem - (CI)相比，可得增加的senmatic 效果是不显著的。</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] Yolo9000: better, faster, stronger.  In IEEE CVPR, 2017<br>[2] Inception-v4, inception-resnet and the impact of residual  connections on learning. In AAAI, volume 4, page 12, 2017.<br>[3] Learning spatiotemporal features with 3d convolutional networks. In Proceedings of the IEEE international conference  on computer vision, pages 4489–4497, 2015.</p>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>Spectral Networks and Deep Locally Connected Networks on Graphs</title>
    <url>/2019/04/08/Spectral-Networks-and-Deep-Locally-Connected-Networks-on-Graphs/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Stanford Scene Graph Parser</title>
    <url>/2019/03/26/Stanford-Scene-Graph-Parser/</url>
    <content><![CDATA[<ul>
<li>官网：<a href="https://nlp.stanford.edu/software/scenegraph-parser.shtml#Usage" target="_blank" rel="noopener">https://nlp.stanford.edu/software/scenegraph-parser.shtml#Usage</a></li>
</ul>
<h2 id="下载相应的文件（官网有）"><a href="#下载相应的文件（官网有）" class="headerlink" title="下载相应的文件（官网有）"></a>下载相应的文件（官网有）</h2><ul>
<li>stanford-corenlp-full-2015-12-09.zip</li>
<li>scenegraph-1.0.jar<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2></li>
</ul>
<ol>
<li>将stanford-corenlp-full-2015-12-09.zip解压，然后按照博客<a href="https://shiyaya.github.io/2019/03/26/ubuntu-%E5%AE%89%E8%A3%85-Stanford-CoreNLP/" target="_blank" rel="noopener">ubuntu 安装 Stanford CoreNLP</a>来安装corenlp</li>
<li>需要将 scenegraph-1.0.jar 放入解压之后的文件夹stanford-corenlp-full-2015-12-09中，</li>
</ol>
<ul>
<li>需要注意版本</li>
<li>java  idk 1.8+ 按照博客来就可以</li>
<li><p>corenlp 使用人家给定的2015的，不要升级</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>法1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -mx2g -cp <span class="string">"*"</span> edu.stanford.nlp.scenegraph.RuleBasedParser</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意该命令是在stanford-corenlp-full-2015-12-09文件夹下执行的<br>该方法是交互式的，提示你输入句子，他给出相对应的解析出的scene graph</p>
</li>
</ul>
<p>法2：</p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Temporal Deformable Convolutional Encoder-Decoder Networks for Video Captioning</title>
    <url>/2019/07/28/Temporal-Deformable-Convolutional-Encoder-Decoder-Networks-for-Video-Captioning/</url>
    <content><![CDATA[<h3 id="当前存在的问题"><a href="#当前存在的问题" class="headerlink" title="当前存在的问题"></a>当前存在的问题</h3><ul>
<li>RNN 存在梯度消失和梯度下降的问题</li>
<li>RNN 的本质的循环依赖，限制了其并行计算</li>
<li>因此本文提出了 ==Temporal Deformable Convolutional Encoder-Decoder Networks (dubbed as TDConvED) ==that fully employ convolutions in both encoder and decoder networks for video captioning. </li>
</ul>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>TIGEr: Text-to-Image Grounding for Image Caption Evaluation</title>
    <url>/2020/01/15/TIGEr-Text-to-Image-Grounding-for-Image-Caption-Evaluation/</url>
    <content><![CDATA[<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><ul>
<li>当前在图像描述领域使用的 automatic metric 仅仅考虑了 gt 与 pred sentence 之间的匹配度。这就存在问题：（1）给出的 references 可能不能  fully cover the image content。（2）自然语言本质上就是有歧义的（模棱两可的）</li>
<li><p>因此提出了 TIGEr，该指标，（1）不仅可以评估 pred caption 与  image content 之间的匹配度，（2）也能评估 pred caption 与 gt caption 之间的匹配度</p>
</li>
<li><p>（1） 对于  pred caption 与 gt caption， 使用预训练的 image-text grounding model 来 grounds the content of texts。然后分别比较 relevance ranking 和 distribution of grounding weights。</p>
</li>
<li>（2）计算 pred 与 gt caption 之间的匹配度时，不采用 n-gram matching，而是将他们映射到一个共同的语义空间，再对得到的映射向量进行比较。</li>
</ul>
<h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><ul>
<li>现在方法的缺点<ul>
<li>Popular metrics, such as BLEU and CIDEr, are based solely on text matching between reference captions and machinegenerated captions, potentially leading to biased evaluations because references may not fully cover the image content and natural language is inherently ambiguous. </li>
</ul>
</li>
</ul>
<h4 id="本文提出的方法：TIGEr"><a href="#本文提出的方法：TIGEr" class="headerlink" title="本文提出的方法：TIGEr"></a>本文提出的方法：TIGEr</h4><ul>
<li>yaya:本文提出了一个learned-based 和 ruled-based 相结合的方法。（1）learned-based: 首先预训练一个 grounding model , 利用这个grounding model可以分别得到reference caption 和 candidate caption 对regions in image的关注度。（2）再对这两个关注度进行两个方面的比较：==<strong>a:</strong>==  The first one measures how similarly these image regions are ordered (by their grounding scores) in the two vectors. ==<strong>b:</strong>== The second one measures how similarly the<br>attention (indicated by grounding scores) is distributed among different regions of the image in the two vectors.(KL 散度) ==<strong>c:</strong>==The TIGEr score is the average score of the resulting two similarity scores.</li>
</ul>
<h4 id="关于实验部分，可以给人思考的点"><a href="#关于实验部分，可以给人思考的点" class="headerlink" title="关于实验部分，可以给人思考的点"></a>关于实验部分，可以给人思考的点</h4><ul>
<li>Changing Reference Number</li>
<li>Text Component Sensitivity</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gcmt5o6s5ij30do0b60vf.jpg" alt="搜狗截图20200308204541.png"><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gcmt5o7hyyj30b80eftc7.jpg" alt="搜狗截图20200308204629.png">    </p>
<h4 id="yaya-不赞同文中提到的观点"><a href="#yaya-不赞同文中提到的观点" class="headerlink" title="yaya 不赞同文中提到的观点"></a>yaya 不赞同文中提到的观点</h4><ul>
<li>For example, if a human judge wrote a caption solely based on a particular region of an image (e.g., a human face or a bottle as shown in Figure 1) while ignoring the rest of the image, then a good machine-generated caption would be expected to describe only the objects in the same region</li>
<li>yaya分析：<strong>不同的人</strong>当看到一张图片的时候，关注的点是不尽相同的，在这种情况下，由reference 对 region 的attention，当成machine generated caption <strong>target</strong> 本身就不是正确的！</li>
<li>yaya: 本文提出的方法，是希望 learning-based 和 ruled-based method 结合，但是显然，ruled-based metric 就会存在一些缺陷，比如，只能评价caption system performence 的某一方面，换句话说，评价的不够全面！</li>
<li>yaya认为该metric的一个缺点：该metric 同时依赖 reference caption 和 image content, 缺一不可。==对于那些没有reference captions的描述任务，就不可以适用。==</li>
</ul>
]]></content>
      <categories>
        <category>图像描述</category>
        <category>评价指标</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>Task-Oriented Intrinsic Evaluation of Semantic Textual Similarity</title>
    <url>/2020/06/29/Task-Oriented-Intrinsic-Evaluation-of-Semantic-Textual-Similarity/</url>
    <content><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>语义文本相似性（STS），为了评价设计的 STS system 的性能，通常使用 Pearson 相关性进行比较。</p>
<p>在本文中，证明了依靠具有Pearson相关性的内在评估可能会产生误导。在三个基于STS的常见任务中，我们可以观察到Pearson相关性特别不适用于为该任务检测最佳STS系统，而其他评估措施则更适合。</p>
<p>In this work we define how <strong>the validity of an intrinsic evaluation can be assessed</strong> and compare different intrinsic evaluation methods.</p>
<font color="red"> 即本文来分析metric 的有效性</font>

<h3 id="key-words"><a href="#key-words" class="headerlink" title="key words"></a>key words</h3><p>intrinsic evaluations == metric</p>
<p>an STS based task  == a task that heavily depends on the output of an STS system </p>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>下面的图中，四种不同的图，计算得到的pearson 系数都是0.86. </p>
<p>即通过仅比较皮尔逊相关性，所有系统都将被视为同样良好。</p>
<p>同时也可以看到，<strong>Pearson</strong>相关对局外点敏感，只能测量线性关系以及两个变量需要近似正态分布的局限性。</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gg89uax2zvj31fs0sl41x.jpg"></p>
<p><strong>Spearman</strong>的排名相关性不使用实际值来计算相关性，而是使用值的排名。因此，它对异常值，非线性关系或非正态分布的数据不敏感。 但是，大多数STS系统的内在评估仅报告了Pearson相关性。</p>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p>本文还提出了一个 <strong>predictiveness</strong> 的概念。由于，STS system 不会单独使用，常常会将其应用于下游任务。对于那些STS system 上得分高的，且在下游任务上得分也高的，称其为 high predictiveness。</p>
<p>为了探索各种metric 哪种更加适合 STS system 的评价（适合==high predictiveness）。本文用各种  metric 来评估14个 STS system。并使用spearman’rank 来计算，这些metric  得到的STS system <strong>得分</strong> 与 STS based task本身任务的<strong>得分</strong>，这两个得分之间的相关性。相关性越高，则有 high predictiveness, 即，该metric 更加适合用来做STS system 的评价。</p>
<p>通过下图，可以看到，Pearson 作为metric 并不是很好。</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gg8a5wby91j30wb0qmte1.jpg"></p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>[The GEM Benchmark] Natural Language Generation, its Evaluation and Metrics</title>
    <url>/2021/03/01/The-GEM-Benchmark-Natural-Language-Generation-its-Evaluation-and-Metrics/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>The Style-Content Duality of Attractiveness: Learning to Write Eye-Catching Headlines via Disentanglement</title>
    <url>/2021/02/26/The-Style-Content-Duality-of-Attractiveness-Learning-to-Write-Eye-Catching-Headlines-via-Disentanglement/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/02/26/9xToFaqiXjyKLOU.png" alt="image-20210226094912200" style="zoom: 50%;"></p>
<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>抢眼的头条新闻是触发更多点击的第一个设备，在制作人和观众之间产生了相互影响。生产者可以获得更多的流量和利润，而读者可以访问优秀的文章。生成吸引人的头条新闻时，不仅要捕捉吸引人的<strong>内容</strong>，而且要遵循醒目的书面<strong>风格</strong>。</p>
<p>本文中，提出了一个a Disentanglement-based Attractive Headline Generator (DAHG)。该标题生成器根据有吸引力的样式来捕获有吸引力的内容的标题。具体而言，【1】我们首先设计一个解纠缠模块，将引人注目的原型标题的样式和内容划分为潜在空间，并带有两个辅助约束以确保两个空间确实被纠缠。【2】然后，潜在内容信息将用于进一步polish the document representation 并帮助捕获重要部分。【3】最后，生成器将 polished document 作为输入，以在引人注目的样式的指导下生成标题。</p>
<p>本文在Kuaibao dataset 上实现了最好的性能。人工评估还表明，与现有模型相比，DAHG触发的点击次数增加了22％。</p>
<h3 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h3><h4 id="Headline-Generation"><a href="#Headline-Generation" class="headerlink" title="Headline Generation"></a>Headline Generation</h4><p>头条生成目前是NLP中的一个研究热点，目前大部分存在的头条生成工作仅仅关注于 summarizing the document。目前在Attractive headline generation上的研究还相对较少，目前有以下几篇。据我们所知，目前没有工作considers the style-content duality of attractiveness（考虑  吸引力的 内容-风格 二重性）。</p>
<blockquote>
<p>【1】Clickbait? Sensational Headline Generation with Auto-tuned Reinforcement Learning</p>
<p>【2】Improving Latent Alignment in Text Summarization by Generalizing the Pointer Generator. EMNLP 2019</p>
<p>【3】Structure Learning for Headline Generation.</p>
<p>【4-（not）】Hooks in the Headline: Learning to Generate Headlines with Controlled Styles</p>
</blockquote>
<h4 id="Disentanglement"><a href="#Disentanglement" class="headerlink" title="Disentanglement."></a>Disentanglement.</h4><p>现有作品集中于学习learning the disentangled representation，并且我们进一步采取了这种方法来利用这种representation来生成attractive headlines。</p>
]]></content>
      <categories>
        <category>title</category>
        <category>style</category>
      </categories>
      <tags>
        <tag>title,style</tag>
      </tags>
  </entry>
  <entry>
    <title>USR An Unsupervised and Reference Free Evaluation Metric for Dialog Generation</title>
    <url>/2020/07/01/USR-An-Unsupervised-and-Reference-Free-Evaluation-Metric-for-Dialog-Generation/</url>
    <content><![CDATA[<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p>缺乏有意义的自动评估指标是开放域对话框生成研究的重要障碍。标准语言生成指标已被证明对对话评估无效。</p>
<blockquote>
<p><strong>Survey on Evaluation Methods for Dialogue Systems</strong></p>
</blockquote>
<p>在没有公认的有意义的自动度量标准的情况下，开放域对话框研究人员开始依赖人工评估。由于其时间和成本密集的性质，人工评估通常仅用于最终的对话模型。因此，在开发过程中，对话系统通常针对不相关的自动指标（例如F-1，BLEU，PPL）进行了优化，这可能会导致不佳的人类评估分数。</p>
<p>为了促进开放域下对话模型在有意义的自动评价指标下发展，本文提出了无监督、无reference的评价指标。</p>
<h3 id="当前-automatic-metric-的缺陷"><a href="#当前-automatic-metric-的缺陷" class="headerlink" title="当前 automatic metric 的缺陷"></a>当前 automatic metric 的缺陷</h3><p>从dialog 的特性出发来分析 当前 automatic metric 的缺陷</p>
<ul>
<li><p>dialog 的一对多性质会使那些基于计算words overlap 的 metric无效，无法对偏离groun-truth response 的有效系统输出进行评分。</p>
<p>一对多：</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ggbir2x8l4j30ir0okmy9.jpg" style="zoom:33%;"></p>
</li>
<li><p>人类往往会对dialog 评估多个属性（例如，适当，有趣，一致）。而 automatic metric 将对话质量的多面性浓缩为一个无法解释的得分。</p>
</li>
<li><p>关于什么是<em>好的对话</em>，有很多定义，因此，构建<em>“一刀切”</em>是不可行的。根据任务和数据，对话系统的期望质量可能会有所不同</p>
</li>
</ul>
<h3 id="本文提出的指标"><a href="#本文提出的指标" class="headerlink" title="本文提出的指标"></a>本文提出的指标</h3><p>USR是一种reference-free metric ，由几个可解释的子指标组成，这些子指标以可配置的方式组合在一起。无需依赖于ground-truth reference response，而是可以训练无监督模型来测量所需的对话质量（例如，有趣，自然）。<br>因此，USR：<br>（1）减轻了标准度量标准的一对多问题，<br>（2）为dialog的所需属性提供了可解释的度量标准，<br>（3）提供了一种可配置的机制，用于将多个子度量标准合并为总体质量得分。</p>
<h3 id="本文的贡献"><a href="#本文的贡献" class="headerlink" title="本文的贡献"></a>本文的贡献</h3><ul>
<li><strong style="color:blue;">【提出了一个评价指标】</strong>提出了a strongly-correlated, unsupervised and reference free metric，用于评估开放域对话系统。</li>
<li><strong style="color:blue;">【提出了一个带有人类质量注释的数据集】</strong>进行了全面的human quality annotation 并发布了该数据集，以方便将来使用对话评估指标的 <strong>benchmarking</strong>。</li>
</ul>
<h3 id="Human-Quality-Annotation"><a href="#Human-Quality-Annotation" class="headerlink" title="Human Quality Annotation"></a>Human Quality Annotation</h3><ul>
<li><p>数据集构成<br>为了评估自动度量与人类判断的相关性，在两个开放域对话语料库之间进行了人类质量注释。</p>
<p>每个上下文包含的相应有：（1）模型生成的response，（2）人工再编写一个response，（3）原始的真实响应。<strong>Topic-Chat</strong> 的 每个上下文进行了六个响应（四个系统输出，一个新注释的人类输出，一个原始的真实响应）。<strong>PersonaChat</strong>  的 每个上下文进行了五个响应（少一个系统的输出）。</p>
<p>其中，每个数据集包含60个dialog context.</p>
</li>
<li><p>人类打分</p>
<p>human worker 在 这两个数据集上进行 human quality annotation。</p>
<p>每个相应均得到6个不同的分数：可理解（0-1），自然（1-3），保持情境（1-3），有趣（1-3），使用知识（0-1），总体质量（1- 5）。三个human为每个响应进行打分。</p>
</li>
<li><p>人类打分的Instructions</p>
<p><strong style="color:red;">任务说明非常详细，以最大程度地减少human quality annotation 中的主观性。</strong> 例如，个人对<code>有趣</code>的定义可能有所不同（例如，有些人发现足球很有趣，而另一些人则没有）。因此，这些说明中包含了一个对 <code>有趣</code>清晰的定义，尽管有些僵化。但是，“ <em>总体质量”</em>注释的说明不太严格，因此这些注释包含一些特定于注释器的主观性。</p>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ggbi8h871nj31ed0r5ae2.jpg" style="zoom:33%;"></p>
<h3 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h3><ul>
<li><p>看一下，他引用的参考文献，说 automatic metric 不好，文章中是怎么说的</p>
<blockquote>
<p>arxiv: 1603.08023</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Transformer</title>
    <url>/2021/03/19/Transformer/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/03/19/DrhRUENTcwXPo89.png" alt="image-20210319185913348" style="zoom:50%;"></p>
<p>Transformer模型中采用了 encoer-decoder 架构。论文中encoder层由6个encoder堆叠在一起，decoder层也一样。</p>
<h2 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h2><p>对于encoder，包含两层，一个self-attention层和一个前馈神经网络，self-attention能帮助当前节点不仅仅只关注当前的词，从而能获取到上下文的语义。</p>
<h2 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h2><p>decoder也包含encoder提到的两层网络，但是在这两层中间还有一层attention层，帮助当前节点获取到当前需要关注的重点内容。</p>
<p>Decoder 和 Encoder的结构差不多，但是多了一个attention的sub-layer，这里先明确一下decoder的输入输出和解码过程：</p>
<ul>
<li>输出：对应 $i$ 位置的输出词的概率分布</li>
<li>输入：encoder的输出 与 对应  $i-1$ 位置decoder的输出。所以中间的attention不是self-attention，它的<strong style="color:blue;">K，V来自encoder</strong>，<strong style="color:blue;">Q来自上一位置decoder的输出</strong></li>
<li><p>解码：这里要注意一下，训练和预测是不一样的。在训练时，解码是一次全部decode出来，用上一步的ground truth来预测（mask矩阵也会改动，让解码时看不到未来的token）；而预测时，因为没有ground truth了，需要一个个预测。</p>
<p>为了确保按照生成顺序：从左到右，使用sequence mask。</p>
<p>sequence mask 是为了使得 decoder 不能看见未来的信息。也就是对于一个序列，在 time_step 为 t 的时刻，我们的解码输出应该只能依赖于 t 时刻之前的输出，而不能依赖 t 之后的输出。因此我们需要想一个办法，把 t 之后的信息给隐藏起来。</p>
<p>那么具体怎么做呢？也很简单：产生一个上三角矩阵，上三角的值全为0。把这个矩阵作用在每一个序列上，就可以达到我们的目的。</p>
</li>
</ul>
<p><img src="https://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase64156846899939997439.gif" alt="img"></p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIMO Towards Unified-Modal Understanding and Generation via Cross-Modal Contrastive Learning</title>
    <url>/2021/02/23/UNIMO-Towards-Unified-Modal-Understanding-and-Generation-via-Cross-Modal-Contrastive-Learning/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>cross-modal</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
      </tags>
  </entry>
  <entry>
    <title>Unexpected key(s) in state_dict: “**module**.features.conv1.0.weight”</title>
    <url>/2019/03/20/Unexpected-key-s-in-state-dict-%E2%80%9C-module-features-conv1-0-weight%E2%80%9D/</url>
    <content><![CDATA[<ul>
<li><p>参考此处<a href="https://discuss.pytorch.org/t/when-loading-a-model-unexpected-key-s-in-state-dict-module-features-conv1-0-weight/20505" target="_blank" rel="noopener">[link]</a></p>
</li>
<li><p>问题描述：在使用pytorch 加载预训练的模型时:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">decoder.load_state_dict(checkpoint[<span class="string">'dec'</span>])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>出现错误：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Missing</span> <span class="selector-tag">key</span>(<span class="selector-tag">s</span>) <span class="selector-tag">in</span> <span class="selector-tag">state_dict</span>: “<span class="selector-tag">features</span><span class="selector-class">.conv1</span><span class="selector-class">.0</span><span class="selector-class">.weight</span>”,</span><br><span class="line"><span class="selector-tag">Unexpected</span> <span class="selector-tag">key</span>(<span class="selector-tag">s</span>) <span class="selector-tag">in</span> <span class="selector-tag">state_dict</span>: “**<span class="selector-tag">module</span>**<span class="selector-class">.features</span><span class="selector-class">.conv1</span><span class="selector-class">.0</span><span class="selector-class">.weight</span>”,</span><br></pre></td></tr></table></figure></p>
<ul>
<li>原因：<br>在训练阶段，使用的是多GPU，采用了nn.DataParallel，因此在测试阶段，对应的模型也需要是多GPU的。</li>
</ul>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>[VATEX Captioning Challenge 2019] Multi-modal Information Fusion and Multi-stage Training Strategy for Video Captioning</title>
    <url>/2021/03/13/VATEX-Captioning-Challenge-2019-Multi-modal-Information-Fusion-and-Multi-stage-Training-Strategy-for-Video-Captioning/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>cross-modal</category>
        <category>video captioning</category>
      </categories>
      <tags>
        <tag>cross-modal,video captioning</tag>
      </tags>
  </entry>
  <entry>
    <title>VATEX: a video caption dataset</title>
    <url>/2019/07/23/VATEX-a-video-caption-dataset/</url>
    <content><![CDATA[<h2 id="VATEX数据集"><a href="#VATEX数据集" class="headerlink" title="VATEX数据集"></a>VATEX数据集</h2><ul>
<li>一个新的数据集，41269个video， 时长大约10s, 每个video有10个中文，10个英文，同时这10个之中，中英文之间有5个是两两配对的</li>
<li>提出了两个新的任务：（1）一个encoder-decoder模型，在两种语言之间共享参数，即希望一个模型，可以得到两种语言的描述。（2）提出了一种新的机器翻译任务，即当进行中英文的机器翻译任务时，可以添加视频的视觉特征作为辅助信息</li>
<li>数据集的来源：来自于kinetics的validation dataset, 然后它们找人进行了caption的标注。它们将这41269个video 分成了4部分，train, validation, public test, secret test(不公开，用于比赛)</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g8e7blhuobj30js0lfwkf.jpg" alt="搜狗截图20191028204431.png"></p>
<h3 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h3><ul>
<li>encoder-decoder 就是 TopDown的形式</li>
<li>视觉特征：通过I3D（在kinetics train上预训练且不再fine-tune）来提取视觉特征，应该是把video分成了很多segments，对每个segment都提取I3D的特征，每个特征作为vi。</li>
</ul>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>VIFIDEL: Evaluating the Visual Fidelity of Image Descriptions</title>
    <url>/2020/01/16/VIFIDEL-Evaluating-the-Visual-Fidelity-of-Image-Descriptions/</url>
    <content><![CDATA[<h3 id="当前指标存在的问题"><a href="#当前指标存在的问题" class="headerlink" title="当前指标存在的问题"></a>当前指标存在的问题</h3><ul>
<li>BLEU, ROUGE, Meteor, CIDEr 这些指标， 他们依靠精确的字符串匹配来测量 condidate 文本和reference文献之间的surface-level 、 n-gram 重叠。当 references 有限的情况下，这会导致样本稀疏问题 （reference数量对 metric 得分有很大影响，因为reference 数量越多，多样性更好）。Meteor 通过匹配字典和释义表中的同义词来部分解决此问题，但受限于此类字典的可用性，也不能很好地适用于其他的 language。SPICE and BAST 通过计算语义级别的相似性来解决 exact string matching。但是这个方法严重的依赖于语言资源，例如 parsers, semantic role labellers, tailored rules, 使其很难适应到不同的语言和领域。</li>
</ul>
<h3 id="仅仅使用-reference-description-来-评估-image-description-的缺点"><a href="#仅仅使用-reference-description-来-评估-image-description-的缺点" class="headerlink" title="仅仅使用 reference description 来 评估 image description 的缺点"></a>仅仅使用 reference description 来 评估 image description 的缺点</h3><ul>
<li>受限于 reference 的数量，可能会造成<strong>样本稀缺</strong>的问题。</li>
<li>reference description 是<strong>主观的，有歧义的</strong>，可能不能涵盖 image 中所有的关键信息，可能只包含 image content 的一个子集。<strong>使用 object labels 可以解决这个问题</strong> </li>
<li>references 可能含有错误的信息。</li>
</ul>
<h3 id="基于-object-information-来-作为评价指标的优点"><a href="#基于-object-information-来-作为评价指标的优点" class="headerlink" title="基于 object information 来 作为评价指标的优点"></a>基于 object information 来 作为评价指标的优点</h3><ul>
<li><strong>少的标注时间消耗</strong>： 若仅使用 multiple descriptions 来作为参考，则必然需要人类为 每个 image 来标注 多个 descriptions，在标注数据上需要花费很多时间。且为每个 image 标注的description 数量越多，评估的越准确，则也需要更多的标注时间。</li>
<li>但是若使用基于 object imformation ， 则可以使用 predicted objects 或者 object annotations</li>
</ul>
<h3 id="本文的方法简述"><a href="#本文的方法简述" class="headerlink" title="本文的方法简述"></a>本文的方法简述</h3><p>我们认为，衡量特定标准的细粒度度量标准对于理解IDG系统如何比另一个系统更有用。 </p>
<p>我们专注于这样一种标准，即视觉保真度。 </p>
<p>该标准旨在衡量<strong>description相对于图像中所描述内容的真实性</strong>，对description中多余的信息进行惩罚，对正确的信息进行奖励</p>
<p>This criterion aims to measure how faithful a description is with respect to what is depicted in the image (i.e.<strong style="color:red;"> <strong>systems should be rewarded for describing elements depicted in the image and penalised for describing things that are not depicted</strong></strong>). </p>
<blockquote>
<p>Introduction</p>
</blockquote>
<h3 id="Modelling-object-importance-with-reference-descriptions"><a href="#Modelling-object-importance-with-reference-descriptions" class="headerlink" title="Modelling object importance with reference descriptions"></a>Modelling object importance with reference descriptions</h3><ul>
<li><p>human reference 可以作为一种guidance 提供信息 — 人类对该张图片关注的重点在哪里。</p>
</li>
<li><p>与 CIDEr 很相似，都是考虑与 human reference 之间的consensus 信息，但是有以下两点不同：  </p>
<p>（1）使用reference 来建模object的重要性，而不是直接将 候选与 参考进行比较。<br>（2）在语义空间使用word embedding来执行 word matching，而不是直接在计算表面的匹配度（eg: n-gram）   </p>
</li>
</ul>
]]></content>
      <categories>
        <category>图像描述</category>
        <category>评价指标</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>VIOLIN: A Large-Scale Dataset for Video-and-Language Inference</title>
    <url>/2020/03/28/VIOLIN-A-Large-Scale-Dataset-for-Video-and-Language-Inference/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>[VIVO] Surpassing Human Performance in Novel Object Captioning with Visual Vocabulary Pre-Training</title>
    <url>/2020/10/18/VIVO-Surpassing-Human-Performance-in-Novel-Object-Captioning-with-Visual-Vocabulary-Pre-Training/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>VIVO可以在没有文本标签的数据上进行文本和图像的多模态预训练，摆脱了对配对图文数据的依赖，可以直接利用ImageNet等数据集的类别标签。借助VIVO，模型可以学习到物体的视觉外表和语义之间的关系，建立视觉词表。</p>
<p>这个视觉词表是啥呢？其实就是一个图像和文本的联合特征空间，在这个特征空间中，语义相近的词会聚类到一起，如金毛和牧羊犬，手风琴和乐器等。</p>
<p>预训练建好词表后，模型只需在有少量共同物体的配对图文的数据上进行微调，模型就能自动生成通用的模板语句，使用时，即使出现没见过的词，也能从容应对，相当于把图片和描述的各部分解耦了。</p>
<p>所以VIVO既能利用预训练强大的物体识别能力，也能够利用模板的通用性，从而应对新出现的物体。</p>
<p><img src="https://i.loli.net/2020/10/17/gakiQWDp3YAITCd.png" alt="image-20201017185401941" style="zoom:50%;"></p>
<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>本文要针对describe novel objects which are unseen in caption-labeled training data。This paper presents VIsual VOcabulary pretraining (VIVO) that performs pre-training in the absence of caption annotations。</p>
<p>By breaking the dependency of paired image-caption training data in VLP, VIVO can leverage large amounts of <strong>paired image-tag data</strong> to learn <strong>a visual vocabulary</strong>.<br>This is done by pre-training a <strong>multi-layer Transformer model</strong> that learns to align image-level tags with their corresponding image region features. Given that tags are not ordered, we employ <strong>the Hungarian matching loss</strong> for tag prediction optimization. </p>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p><img src="https://i.loli.net/2020/10/17/JuOMYRtzW7LEgfo.png" alt="image-20201017193144259"></p>
<h4 id="VIVO-Pre-training"><a href="#VIVO-Pre-training" class="headerlink" title="VIVO Pre-training"></a>VIVO Pre-training</h4><p>We pre-train the Transformer model on a large-scale dataset with abundant tags, e.g., the Open Images training set with <strong>6.4K classes of image-level tags.</strong></p>
<p><strong>The training objective</strong> is to predict the missing (masked) tags given a bag of image-level tags and image regions. </p>
<p>We denote the training set: N images $I_i$ and their corresponding tags $G_i$. 一个image有多个tags.</p>
<p>use <strong>bi-directional attention mask</strong> in VIVO pre-training.</p>
<h4 id="Fine-tuning-and-Inference"><a href="#Fine-tuning-and-Inference" class="headerlink" title="Fine-tuning and Inference"></a>Fine-tuning and Inference</h4><p>After pre-training, the Transformer model is fine-tuned on a dataset where both captions and tags are available, e.g., the COCO set annotated with tags from 80 object classes and captions.</p>
<p>the input to the model during <strong>fine-tuning is a triplet of image region features $V$, a set of tags $T$ and a  caption $C$</strong>, where $V$ and $T$ are constructedin the same way as described in pre-training, and $C$ is a sequence of tokens. During fine-tuning, we <strong>randomly mask outsome of the tokens in a caption sentence</strong> for  prediction, and optimize the model parameters using the cross-entropy loss.</p>
<p>during fine-tuning we apply <strong>the uni-directional attention mask</strong> on a caption sequence to prevent the positions from attending to subsequent positions.</p>
<p>During inference, we first extract image region features and detect tags from a given image. Then the model is applied to <strong>generate a sequence, one token at a time,</strong> until it outputs the end of sentence token or reaches the maximum length.</p>
<p><strong>detect tags</strong> ：We use an object detector trained on the Open Images dataset （500 classes bboxes）to detect object tags for all datasets.</p>
<p><strong style="color:red;"><strong>yaya：</strong> tags detector的限制，仅能输出 500个类别tags, 因此，novel objects 的生成也是受到限制的</strong></p>
<p>以下这个表就可以说明问题，当不预训练时，是第一行的数据；当仅使用tags detector 的500个类时，是第二行的数据；当使用open-image 所有的 6.4k 个类时，是第三行的数据。因此，在inference阶段，使用 tag detector 来提供tags 是存在问题的。至少限制了模型的性能。</p>
<p><strong>改进</strong>：本文的model，pre-training, fine-tune，都是在一个fix model上。但是pre-training 的目的，仅仅是为了构建 image-tag vocabulary, 可以先构建，然后再离线使用！！！</p>
<p><img src="https://i.loli.net/2020/10/18/eyKJkcQPibhX3nS.png" alt="image-20201018115538016" style="zoom:33%;"></p>
]]></content>
      <categories>
        <category>图像描述</category>
        <category>region-word-embedding</category>
      </categories>
      <tags>
        <tag>region-word-embedding</tag>
      </tags>
  </entry>
  <entry>
    <title>VMSMO Learning to Generate Multimodal Summary for Video-based News Articles</title>
    <url>/2021/02/21/VMSMO-Learning-to-Generate-Multimodal-Summary-for-Video-based-News-Articles/</url>
    <content><![CDATA[<h2 id="VMSMO-Learning-to-Generate-Multimodal-Summary-for-Video-based-News-Articles"><a href="#VMSMO-Learning-to-Generate-Multimodal-Summary-for-Video-based-News-Articles" class="headerlink" title="VMSMO: Learning to Generate Multimodal Summary for Video-based News Articles"></a>VMSMO: Learning to Generate Multimodal Summary for Video-based News Articles</h2><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul>
<li>当前受欢迎的多媒体新闻格式是提供<strong>一个视频和相对应的文章</strong>。 这种格式广泛应用于 new media (CNN and BBC)，social media (Twitter and Weibo)。<br>在这种情况下，自动选择<strong>合适的视频封面</strong>并生成相应的<strong>文章摘要</strong>可帮助编辑人员节省时间，并使读者更有效地做出决定。</li>
<li>因此，在本文中，we propose the task of <strong>Video-based Multimodal Summarization with Multimodal Output</strong> (VMSMO) to tackle such a problem. </li>
<li>此任务中的主要挑战是使用文章的语义共同对视频的时间依赖性进行建模。</li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>视频的封面应该是整个视频最显著的要素，而文本摘要应该是从原文章中提取出来的重要信息。因为视频和文章都关注于同一个报告内容中的相同事件，因此这两种信息形式在 summarizing 过程中应该是<strong>互为补充的</strong>。但是由于视频和文章是不同的模态（空间），如何充分的探索视频中的时域依赖与文章中的语义内容<strong>之间的关系</strong>仍然是一个问题。</p>
<p>因此，在本文中，我们提出了一个模型（DIMS）。该模型通过在过程中实施一个 dual interaction strategy 来同时summarize video and article。（1）使用 RNN 来编码 text and video. （2）设计了一个对偶交互模块（a dual interaction module）来让视频和文章相互交互。具体地，包括一个conditional self-attention mechanism 该模块可以在文章的指导下学习 local video representation。还包括一个global-attention mechanism 来学习 high level representation of video-aware article and article-aware video。（3）最后，based on fusion repersentation multimodal generator generates textual summary and cover image。</p>
<p>为了证明本文提出模型的有效性，本文从社会媒体网站上收集了 a large-scale news article-summary dataset associated with video-cover。实验证明，在当前广泛使用的评价标准上，DIMS可以显著的超过当前最好的baseline methods.</p>
<h2 id="本文的贡献"><a href="#本文的贡献" class="headerlink" title="本文的贡献"></a>本文的贡献</h2><ul>
<li>提出了一个任务，需要同时生成一个视频封面和一个文本摘要。</li>
<li>针对该任务，提出了一个模型，该模型可以同时建模视频中对的时域依赖和文章中的语义信息。</li>
<li>本文提出了一个大规模的数据集。在该数据集上，本文提出的方法在 automatic and human evaluation上都显著好于 baseline methods。</li>
</ul>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><ul>
<li><p>Text Summarization: (1) Extractive models：从原文中提取一句话来表征整个文章的内容。（2）abstractive models：generate a summary from scratch</p>
</li>
<li><p>Multimodal Summarization：（1）结合多模态的输入，生成更高的texual summaries。（2）Multimodal<br>summarization with multimodal output 这一方向，研究的相对较少。[zhu 2018] 提出同时输出一个 textual summary 和 从6个候选中挑选出来的most relevent image。[zhu 2020] 增加了一个多模态的目标函数。</p>
<p>但是，在实际应用中，我们通常需要为包含数百帧的视频选择封面图。 因此，视频中帧之间的时间相关性不能通过几种静态编码方法简单地建模。</p>
<blockquote>
<p>[zhu 2018] Msmo: multimodal summarization with multimodal output. EMNLP/IJCNLP. </p>
<p>[zhu 2020] Multimodal summarization with guidance of multimodal reference.</p>
</blockquote>
</li>
</ul>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p><img src="https://i.loli.net/2021/02/21/KqO2uQEkZj1fyPB.png" alt="image-20210221114344434"></p>
<h2 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h2><p>本文从 <strong>微博</strong> 上收集了做 VMSMO task 的数据集。视频的平均时长是1分钟，帧率是25fps。对于文本，文章的平均长度是96个字，文章summary的长度是12个字。整体上，有184k 个样本被收集，180k作为训练集，2.4k作为验证集，2.4k作为测试集。</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><ul>
<li><p>compare baseline：本文提出的方法与summarization baseline 和 VQA baseline 进行比较。</p>
</li>
<li><p>evaluation metrics：<br>（1）评估生成的summary：standard full-length <strong>Rouge F1</strong>. R-1, R-2, and R-L refer to unigram, bigrams, and the longest common2 subsequence respectively.</p>
<p>（2）评估chosen cover frame: mean average precision （MAP）and recall at precision（$R_n@k$）。$R_n@k$用来评估是否positive sample 被排在n candidatas的前k个位置。</p>
</li>
<li><p>实验结果证明，（1）本文提出的方法相比于 baseline methods 都要好。（2）本文提出了一个联合损失，同时训练两个任务，可以看做是一个 Multi-task。在本文的实验中，探索了，如果分别训练这两个任务，是怎样的结果。从倒数第二列中可以发现，我们采用的多任务方式训练，效果会好。（3）在本文实验中探索了conditional self-attention 和 global-attention对效果的影响。从最后一列的实验结果可以发现，self-attention 模块对挑选 封面图有很大的贡献，global attention对生成文本摘要有很大的贡献。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/02/21/PcFyBkTZNQlHY8m.png" alt="image-20210221154509463"></p>
<h2 id="Future-work"><a href="#Future-work" class="headerlink" title="Future work"></a>Future work</h2><ul>
<li>本文最后说到，可以结合video  script (subtitles) 来做该任务。</li>
</ul>
]]></content>
      <categories>
        <category>cross-modal</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
      </tags>
  </entry>
  <entry>
    <title>Video Description: A Survey of Methods, Datasets and Evaluation Metrics</title>
    <url>/2019/07/29/Video-Description-A-Survey-of-Methods-Datasets-and-Evaluation-Metrics/</url>
    <content><![CDATA[<h3 id="视频描述仍然处于起步阶段的原因"><a href="#视频描述仍然处于起步阶段的原因" class="headerlink" title="视频描述仍然处于起步阶段的原因"></a>视频描述仍然处于起步阶段的原因</h3><ul>
<li>对视频描述模型的分析是困难的，很难去判别是visual feature 亦或是 language model 哪个做的贡献大</li>
<li>当前的数据集，既没有包含足够的视觉多样性，也没有复杂的语言结构</li>
<li>当前的凭据指标并不能非常正确的去评估生成的句子与人类生成的句子之间的一致程度</li>
</ul>
<h3 id="the-difficulty-of-video-caption"><a href="#the-difficulty-of-video-caption" class="headerlink" title="the difficulty of video caption"></a>the difficulty of video caption</h3><ul>
<li>并不是在video中的所有object 都是与description相关的，可能其只是背景中的一个元素。    </li>
<li>此外，还需要objects的运动信息，以及 事件，动作，对象之间的因果关系。   </li>
<li>视频中的action可能有不同的长度，不同的action之间，可能有重叠。    </li>
</ul>
<h3 id="Sequence-Learning-based-Video-Captioning-Methods"><a href="#Sequence-Learning-based-Video-Captioning-Methods" class="headerlink" title="Sequence Learning based Video Captioning Methods"></a>Sequence Learning based Video Captioning Methods</h3><h4 id="CNN-RNN-based"><a href="#CNN-RNN-based" class="headerlink" title="CNN-RNN-based"></a>CNN-RNN-based</h4><ul>
<li><p>第一个 end-to-end：</p>
<p>S. Venugopalan, H. Xu, J. Donahue, M. Rohrbach, R. Mooney, and K. Saenko. 2014. Translating videos to natural language using deep recurrent neural networks. arXiv preprint arXiv:1412.4729, (2014).<br><img src="https://i.loli.net/2019/07/29/5d3ea016090c918345.png" alt="图片1.png" title="图片1.png"></p>
</li>
<li><p>S2VT （变长输入，变长输出）</p>
<p>I. Sutskever, O. Vinyals, and Q. V. Le. 2014. Sequence to sequence learning with neural networks. In Advances in Neural Information Processing Systems. 3104-3112.<br><img src="https://i.loli.net/2019/07/29/5d3ea01536b3144846.png" alt="图片2.png" title="图片2.png">   </p>
</li>
<li><p>TA ( 加入C3D[1] )</p>
<p>L. Yao, A. Torabi, K. Cho, N. Ballas, C. Pal, H. Larochelle, and A.Courville. 2015. Describing videos by exploiting temporal structure. In IEEE ICCV<br><img src="https://i.loli.net/2019/07/29/5d3ea016a248c95582.png" alt="图片3.png" title="图片3.png">  </p>
</li>
<li><p>LSTM-E （making a common visual-semantic-embedding ）</p>
<p>Y. Pan, T. Mei, T. Yao, H. Li, and Y. Rui. 2016. Jointly modeling embedding and translation to bridge video and language. In IEEE CVPR.<br><img src="https://i.loli.net/2019/07/29/5d3ea421aaf9013065.png" alt="图片4.png" title="图片4.png"></p>
</li>
</ul>
<ul>
<li><p>GRU-EVE  ( short fourier transform)</p>
<p>N. Aafaq, N. Akhtar, W. Liu, S. Z. Gilani and A. Mian. 2019. Spatio-Temporal Dynamics and Semantic Attribute Enriched Visual Encoding for Video Captioning. In IEEE CVPR.<br><img src="https://i.loli.net/2019/07/29/5d3ea0163113561600.png" alt="搜狗截图20190729152752.png" title="搜狗截图20190729152752.png">   </p>
</li>
<li><p>h-RNN<br>H. Yu, J. Wang, Z. Huang, Y. Yang, and W. Xu. 2016. Video paragraph captioning using hierarchical recurrent neural networks. In IEEE CVPR.<br><img src="https://i.loli.net/2019/07/29/5d3ea63af2e0354548.png" alt="图片5.png" title="图片5.png"></p>
</li>
</ul>
<h4 id="RL-based"><a href="#RL-based" class="headerlink" title="RL-based"></a>RL-based</h4><ul>
<li><p>Z. Ren, X. Wang, N. Zhang, X. Lv, and L. Li. 2017. Deep reinforcement learning-based image captioning with embedding reward. arXiv preprint arXiv:1704.03899, (2017).</p>
</li>
<li><p>Y. Chen, S. Wang, W. Zhang, and Q. Huang. 2018.  ==Less Is More: Picking Informative Frames for Video Captioning.==  arXiv preprint arXiv:1803.01457, (2018).</p>
<p>提出了一个基于强化学习的方法，来选择 key informative frames 来表达一个 complete video ，希望这样的操作可以忽略掉噪声和不必要的计算。</p>
</li>
<li><p>L. Li and B. Gong. 2018. End-to-End Video Captioning with Multitask Reinforcement Learning. arXiv preprint arXiv:1803.07950,<br>(2018).</p>
</li>
<li><p>R. Pasunuru and M. Bansal. 2017. Reinforced video captioning with entailment rewards. arXiv preprint arXiv:1708.02300, (2017).</p>
</li>
<li><p>S. Phan, G. E. Henter, Y. Miyao, and S. Satoh. 2017. Consensusbased Sequence Training for Video Captioning. arXiv preprint arXiv:1712.09532, (2017).</p>
</li>
<li><p>X. Wang, W. Chen, J. Wu, Y. Wang, and W. Y. Wang. 2017.  ==Video Captioning via Hierarchical Reinforcement Learning.==  arXiv preprint arXiv:1711.11135, (2017).</p>
<p>在 decoder阶段，使用 深度强化学习，这个方法证明可以捕捉到视频内容中的细节，并生成细粒度的description，但是！这个方法相对于当前的baseline 没有多大的提高。（我自己还需要再看看， 使用DRL的motivation）</p>
</li>
</ul>
<h3 id="Evaluation-Metrics"><a href="#Evaluation-Metrics" class="headerlink" title="Evaluation Metrics"></a>Evaluation Metrics</h3><ul>
<li><p><a href="https://blog.csdn.net/joshuaxx316/article/details/58696552" target="_blank" rel="noopener">参考链接</a></p>
</li>
<li><p>BLEU、ROUGE、METEOR  来源于 机器翻译</p>
</li>
<li><p>CIDEr、SPICE 来源于图像描述   </p>
</li>
</ul>
<h4 id="BLEU"><a href="#BLEU" class="headerlink" title="BLEU"></a>BLEU</h4><ul>
<li><a href="https://blog.csdn.net/allocator/article/details/79657792" target="_blank" rel="noopener">BLEU参考链接</a></li>
<li>==BLEU实质是对两个句子的共现词频率计算==，但计算过程中使用好些技巧，追求计算的数值可以衡量这两句话的一致程度。 </li>
<li>BLEU容易陷入常用词和短译句的陷阱中，而给出较高的评分值。本文主要是对解决BLEU的这两个弊端的优化方法介绍。</li>
<li>缺点</li>
</ul>
<ol>
<li>　不考虑语言表达（语法）上的准确性；<br>2.　 测评精度会受常用词的干扰；<br>3.　 短译句的测评精度有时会较高； </li>
<li>　没有考虑同义词或相似表达的情况，可能会导致合理翻译被否定；</li>
</ol>
<h4 id="ROUGE"><a href="#ROUGE" class="headerlink" title="ROUGE"></a>ROUGE</h4><p><img src="https://i.loli.net/2019/07/29/5d3ed71f2086769963.png" alt="20170228224903951.png" title="20170228224903951.png"></p>
<h4 id="METEOR"><a href="#METEOR" class="headerlink" title="METEOR"></a>METEOR</h4><p><img src="https://i.loli.net/2019/07/29/5d3edcce1761442736.png" alt="20170228225011405.png" title="20170228225011405.png">   </p>
<h4 id="CIDEr"><a href="#CIDEr" class="headerlink" title="CIDEr"></a>CIDEr</h4><p><img src="https://i.loli.net/2019/07/29/5d3edcce646d089162.png" alt="20170228225056046.png" title="20170228225056046.png"></p>
<h4 id="SPICE"><a href="#SPICE" class="headerlink" title="SPICE"></a>SPICE</h4><ul>
<li>基于 gt 和 pred 的场景图解析，来对预测结果进行评价，</li>
<li>不被广泛使用的原因是，当前sentence scene graph 的能力还比较若，很容易解析错误(eg:dog swimming through river”, the failure case could be the word “swimming” being parsed as “object” and the word “dog” parsed as “attribute” )</li>
<li>对句子解析错误了，那么给出的评价指标也不会很好！！！</li>
</ul>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p><img src="https://i.loli.net/2019/07/29/5d3edd503479c20027.png" alt="搜狗截图20190729194921.png" title="搜狗截图20190729194921.png">    </p>
<h3 id="当前的瓶颈："><a href="#当前的瓶颈：" class="headerlink" title="当前的瓶颈："></a>当前的瓶颈：</h3><h4 id="缺乏有效的评价指标"><a href="#缺乏有效的评价指标" class="headerlink" title="缺乏有效的评价指标"></a>缺乏有效的评价指标</h4><ul>
<li>我们的调查显示，阻碍这一研究进展的一个主要瓶颈是缺乏有效和有目的设计的视频描述评价指标。目前，无论是从机器翻译还是从图像字幕中，都采用了现有的度量标准，无法衡量机器生成的视频字幕的质量及其与人类判断的一致性。改进这些指标的一种方法是增加引用语句的数量。我们认为，从数据本身学习的目的构建的度量标准是推进视频描述研究的关键。    </li>
<li><p>王鑫也曾说：human evaluation在video captioning任务中是有必要的       </p>
<h4 id="视觉特征部分的瓶颈"><a href="#视觉特征部分的瓶颈" class="headerlink" title="视觉特征部分的瓶颈"></a>视觉特征部分的瓶颈</h4></li>
<li>在一个video中，可能出现多个activity，但是caption model只能检测出部分几个，导致性能下降。   </li>
<li>可能这个video中 action 的持续时间较长，但是，当前的video representation方法只能捕捉时域较短的运动信息（eg:C3D），因此不能很好地提取视频特征。   </li>
<li>大多数特征提取器只适用于静态或平稳变化的图像，因此难以处理突然的场景变化。目前的方法通过表示整体视频或帧来简化视觉编码部分。可能需要进一步探索注意力模型，以关注视频中具有重要意义的空间和时间部分。   </li>
<li>当前的encoder 与 decoder 部分，并 ==不是端到端的==，需要先提取 video representation再进行decoder，这样分布进行，而不是端到端的训练是不好的！    </li>
</ul>
<h3 id="captioning-model-的可解释性不足"><a href="#captioning-model-的可解释性不足" class="headerlink" title="captioning model 的可解释性不足"></a>captioning model 的可解释性不足</h3><ul>
<li>举个例子：当我们从包含“白色消防栓”的帧中看到视频描述模型生成的标题“红色消防栓”时，很难确定颜色特征是视觉特征提取器编码错误还是由于使用的语言模型bias( 由于有过多的训练数据是“红色消防栓)。<br><img src="https://i.loli.net/2019/07/29/5d3ee4996cf7480633.png" alt="搜狗截图20190729202028.png" title="搜狗截图20190729202028.png"></li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li>[1] D. Tran, L. D. Bourdev, R. Fergus, L. Torresani, and M. Paluri. 2014. C3D: Generic Features for Video Analysis. CoRR abs/1412.0767, (2014). </li>
</ul>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>VX2TEXT End-to-End Learning of Video-Based Text Generation From Multimodal Inputs</title>
    <url>/2021/02/23/VX2TEXT-End-to-End-Learning-of-Video-Based-Text-Generation-From-Multimodal-Inputs/</url>
    <content><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><ul>
<li>本文提出了一个框架 for text generation from multimodal inputs consisting of video plus text, speech, or audio。</li>
<li><p>为了利用 transformer networks，每个模态通过一个 learnable tokenzier 首先转换为 a set of language embeddinngs。这将使得我们的方法可以在语言空间执行多模态融合，从而消除了对ad-hoc cross-modal fusion modules 的需要。</p>
</li>
<li><p>为了解决在连续输入（例如视频或音频）上tokenization 的不可微性，我们利用了一种放松方案，该方案可进行端到端训练。</p>
</li>
<li><p>进一步地，不像先前的 encoder-only models。本文提出的网络包括一个 autoregressive decoder来生成 open-ended text。同时在语言空间执行多模态融合，这使我们的方法完全具有生成性，并使其<strong>直接适用于不同的“video + $x $ to text” 问题，而无需为每个任务设计专门的网络.</strong></p>
</li>
<li><p>本文提出的框架不仅概念简单，而且效果显着。实验结果证明，our approach based on a single architecture 在三个video basedd text-generation task （captioning, question answering and audio-visual scene-aware dialog）上实现了最好的性能，而且本文提出的方法不需要任何的预训练任务。</p>
</li>
</ul>
<h3 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h3><p>While this and a few other recent works [55] have leveraged decoders for text-generation from multimodal inputs, we believe <strong>we are the first</strong> to empirically demonstrate via systematic ablation the performance improvements achieved with generative learning with decoding, compared to discriminative learning applied to the same encoder model.</p>
<p>当前的multimodal transformer-based models inspired by the success of pretext tasks in the language domain（预训练任务）。这些工作，依赖消耗大的预训练任务。但是本文提出的VX2TEXT 可以在 unified language space 执行 跨模态融合，这不需要multimodal pretext pretraining.</p>
<blockquote>
<p>Hero: Hierarchical encoder for video language omni-representation pre-training</p>
<p>Vilbert: Pretraining task-agnostic visiolinguistic representations for vision-and-language tasks.</p>
<p>Videobert: A joint model for video and language representation learning, 2019.</p>
<p>Lxmert: Learning crossmodality encoder representations from transformers.</p>
<p>Unified vision-language pre-training for image captioning and vqa</p>
</blockquote>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p>本文提出的方法可以概括为三步: (1) 利用一个 预训练的 modality-specific classifiers来为每个模态获得最可能的类别预测。(2) 将预测类别的textual names 经由本文提出的可微分tokenization scheme 嵌入到一个语义语言空间，这将使得整个系统可以端到端的训练（including the modality-specific classifiers)。（3）最终，使用一个generative encoder-decoder language model 将 多个模态的，embedding vector 映射到 free-form text，这将使得 不同形式的 ”video+$x$ to text” 问题变形为一个 sequence-to-sequence task。</p>
<h4 id="Differentiable-Tokenization"><a href="#Differentiable-Tokenization" class="headerlink" title="Differentiable Tokenization"></a>Differentiable Tokenization</h4><ul>
<li>We first leverage modality-specific classifiers trained  to predict a large set of categories over <strong>predefined language vocabularies</strong>.</li>
<li>虽然概念上是简单的，但是这个方法有一些缺点。第一，预训练的 modality-specific classifiers 可能不能泛化到目标数据。第二，每个分类器中选择top categories，这一操作是不可微分的，这阻止我们针对 target task 来微调modality-specific classifiers。</li>
<li>为了解决这些限制，本文提出了一个 differentiable tokenization scheme，这个方案可以在整个系统（modality specific classifer + sequence-to-sequence model）上进行端到端的训练。</li>
<li><strong>将预测类别的textual names 嵌入到一个语义语言空间</strong>：（1）对于每个模态的类别概率输出，采样top $K_m$个类别。（2）将采样的类别名称嵌入到语言空间：$\mathbf{e}_{m}^{k}=\mathbf{W}_{m}^{T} \mathbf{c}_{m}^{k}$，the embedding transformation  $\mathbf{W}_{m}$ can be initialized using a pretrained language embedding space </li>
</ul>
<h3 id="Generative-Encoder-Decoder"><a href="#Generative-Encoder-Decoder" class="headerlink" title="Generative Encoder-Decoder"></a>Generative Encoder-Decoder</h3><p>上一阶段，将不同的模态嵌入到了一个相同的语言空间，因此，现在可以使用一个<strong>text encoder</strong>来融合多模态信息。将多个模态得到的embedding vectors 组成一个长为L的序列，并结合<strong>task token</strong> 输入到 <strong>text encoder</strong>，并生成一个长为L的序列，该序列从多个模态中捕捉到了task  specific information。</p>
<p>将得到的新序列送入 decoder 中来做text generation。本文提出的decoder使用auto-regressive的方式。</p>
<h3 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h3><ul>
<li>使用 teacher-forcing 和 cross-entropy 来训练模型</li>
</ul>
<h3 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h3><ul>
<li>大部分先前的 multimodal transformer 依赖 task-specific heads 来处理不同的任务。具体而言，为生成式任务设计的heads 通常与 判别式任务是不同的。但是，本文提出的VX2TEXT 可以同时处理这两种任务，而不需要改变结构</li>
<li>对于生成式任务，captioning and video dialog，使用 beam search and greedy decoding 来生成句子。</li>
<li>对于判别式任务，QA on TVQA，模型需要从候选答案中挑选出一个最可能的答案。在这种情况下，本文include the entire set of candidate answers as additional input to the model (using separator tokens to mark them)。然后评估每个候选答案，根据autoregressive decoder对它们输出的概率分布。</li>
</ul>
<h3 id="Implementation-Details"><a href="#Implementation-Details" class="headerlink" title="Implementation Details"></a>Implementation Details</h3><p>We use T5-base [39] as our text transformer including the text token embedding layer, the encoder and the decoder. We use pretrained weights provided in HuggingFace [50]</p>
<h3 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h3><ul>
<li>简要总结本文有效的点</li>
<li>（1）提出将不同的模态，通过一个modality-specific classifier 映射到语言空间。（2）提出了一个端到端训练的模式，同时可以将 classifier 一起训练，这样解决了 迁移，泛化性不好的问题。（3）为了可以进行端到端的训练，采取了一些技术方案。we leverage the Gumbel-Softmax trick [18] and a differentiable approximation of tokenization [8].</li>
</ul>
<blockquote>
<p>Eric Jang, Shixiang Gu, and Ben Poole. <strong>Categorical reparameterization with gumbel-softmax.</strong>  arXiv preprint arXiv:1611.01144, 2016. <strong>ICLR 2017</strong></p>
<p>Yoshua Bengio, Nicholas L´eonard, and Aaron Courville. <strong>Estimating or propagating gradients through stochastic neurons for conditional computation.</strong> arXiv preprint arXiv:1308.3432, 2013.</p>
</blockquote>
]]></content>
      <categories>
        <category>cross-modal</category>
        <category>end-to-end</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
        <tag>end-to-end</tag>
      </tags>
  </entry>
  <entry>
    <title>Video as Space-Time Region Graphs</title>
    <url>/2019/03/15/Video-as-Space-Time-Region-Graphs/</url>
    <content><![CDATA[<p>本篇文章主要是讲图卷积网络应用在行为识别任务中。<br>使用的两个数据集是：charades和something-something数据集</p>
<ul>
<li>从数据集中video丰富性方面：其中charades数据集含有丰富的室内场景，video中的object较为复杂，也不居中。而，something-something 数据集中的video只含有1~2个object，且位于画面中的中心位置。</li>
<li>从数据集中video时长：charades的一整个video近30s长，但是annotation是对clips of video进行的标注，clips的分割也不具备规律性，几秒到几十秒不等。something-something数据集的video 时长为3s-6s。均为较短的视频。  </li>
</ul>
<p>由以上对数据集的分析，与作者的实验结果，结合，由于something-something的video时长短，objects of video 也较小，因此gcn+i3d 相比于对i3d的提升不大，而相反，charades数据集的提升较大。</p>
<ul>
<li>这里给出自己的看法：由于在charades上的提升较为明显，因此使用该网络应用到其他的网络中时，最好可以使用charades数据集进行pre-train，而不要使用something-something数据集。</li>
</ul>
<h2 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h2><p>在训练阶段，首先对video以6 fps的帧率进行截取帧，输入网络时，每个video选取30帧，这样相当于video中的5s。即在训练阶段，每个5s长的clips作为一个sample，赋给它相对应的label，进行训练。</p>
<h2 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h2><p>在测试阶段，charades对每个video 提取10个clips ，对每个clips的输出结果，以最大池化的方式进行聚合，对于something-something数据集，每个video提取2个clips，其他同理。</p>
<h2 id="Construct-Graph"><a href="#Construct-Graph" class="headerlink" title="Construct Graph"></a>Construct Graph</h2><p>对于charades dataset，每帧中提取50个object，对于something-something dataset ，每帧中提取10个object。</p>
<ul>
<li>Similarity Graph<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g13qsziabzj30fk0ahjrw.jpg" style="zoom:65%"><br>Similarity graph 含有可学习参数</li>
<li>Spatial Graph</li>
<li>无可学习参数</li>
<li>We denote the IoU between object i in frame t and object  j in frame t + 1 as σ<sub>ij</sub><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g13qv0z3bxj30fq0b30t3.jpg" style="zoom:65%"></li>
</ul>
]]></content>
      <categories>
        <category>行为识别</category>
      </categories>
      <tags>
        <tag>行为识别</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>VideoGraph: Recognizing Minutes-Long Human Activities in Videos</title>
    <url>/2019/07/30/VideoGraph-Recognizing-Minutes-Long-Human-Activities-in-Videos/</url>
    <content><![CDATA[<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><ul>
<li>当前基于CNN或者non-lcoal的方法，可以建模 temporal concepts，但是却不能建模分钟级长的时域依赖。</li>
<li>学习一个无向图，节点和边都是直接从video中得到，而不需要进行单独的节点标注。</li>
<li>这里的节点是：组成activity的一个unit-action，比如 “煎鸡蛋” 这个activity里的 “打破鸡蛋” 。</li>
<li>边，表示 (units-action) 运动单元之间的时域关系</li>
</ul>
<h3 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h3><ul>
<li>建模长范围的activity</li>
<li>捕捉到细节信息</li>
</ul>
<h3 id="Vs-Video-as-space-time-region-graph"><a href="#Vs-Video-as-space-time-region-graph" class="headerlink" title="Vs  Video as space-time region graph"></a>Vs  <code>Video as space-time region graph</code></h3><ul>
<li>Video as space-time region graph： 需要提取 key objects</li>
<li>Video graph：自动的从video中学到 nodes</li>
</ul>
]]></content>
      <categories>
        <category>行为识别</category>
      </categories>
      <tags>
        <tag>行为识别</tag>
      </tags>
  </entry>
  <entry>
    <title>Visual Grounding in Video for Unsupervised Word Translation</title>
    <url>/2020/10/18/Visual-Grounding-in-Video-for-Unsupervised-Word-Translation/</url>
    <content><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>我们的目标是使用视觉基础来改进语言之间的非监督词映射。其核心思想是通过学习母语教学视频中未配对的嵌入语，在两种语言之间建立一种共同的视觉表达。</p>
<p>本文的工作就是<strong>向机器提供不同的教学视频</strong>，这些视频的内容是人们用本国语言的教学视频。比如说，说中文和英文教别人榨橙汁的教学视频。这类视频有两个特点：视频网站上<strong>大量存在</strong>和<strong>内容相似度高</strong>，非常适合用于训练。但是这些视频也有一些弊端，会有很多无关废话（如“观众老爷们记得素质三连哦~”）。</p>
<p>即使如此，这种基于视觉的翻译提高了翻译的精度。</p>
<h3 id="Unsupervised-Multilingual-Learning"><a href="#Unsupervised-Multilingual-Learning" class="headerlink" title="Unsupervised Multilingual Learning"></a>Unsupervised Multilingual Learning</h3><p><img src="https://i.loli.net/2020/10/18/qzv2QN3bd8oInSx.png" alt="image-20201018172741937"></p>
<p>一个无监督的系统，该系统通过将语言嵌入视频中翻译单词。其中，不需要任何配对数据来学习翻译。</p>
<p><strong>Our method</strong> is unsupervised in that it learns the correspondences between two languages $X$ and $Y$ (e.g. English and French) without any parallel (paired) corpora.</p>
<p>given two distinct collections of instructional videos, i.e. n videos narrated with language $X$and another m different videos with language $Y$.</p>
<p><strong>Our goal</strong> is to learn to map languages $X$ and $Y$ by leveraging the shared visual modality $Z$ – the videos.</p>
<p><strong>Loss function</strong></p>
<p><img src="https://i.loli.net/2020/10/18/uYrymIKnJwvL2G6.png" alt="image-20201018173014409" style="zoom: 25%;"></p>
<h4 id="Multilingual-Visual-Embedding-Architecture"><a href="#Multilingual-Visual-Embedding-Architecture" class="headerlink" title="Multilingual Visual Embedding: Architecture"></a>Multilingual Visual Embedding: Architecture</h4><p><img src="https://i.loli.net/2020/10/18/XU2slICkuhyLBRT.png" alt="image-20201018172904212" style="zoom:33%;"></p>
<p><strong>yaya:</strong>  通过 视觉将两种语言做一种映射是存在困难的。文中列出了三点：<br>（1）learning video-text embeddings from instructional videos is difficult as the speech in these videos is only loosely related to the scene.</p>
<p>（2）in multilingual setting, such errors compound since both languages have this low video-text relevance;<br>（3）visually similar videos may not be semantically similar.</p>
<p>因此本文不同video 作为桥梁直接学习两种语言的映射，而是采取了间接的方式：we learn a joint (monolingual) video-text embedding space from instructional videos.</p>
<p>对于一种语言X, 学习视频及其字幕的映射，对于另一种语言，也学习一种映射，同时，在这种语言上加一个Adaptlayer, 使得 X和Y 能够映射到一个共同的空间。</p>
<p><strong>模型细节：</strong></p>
<p>其中X编码器 = WordEmbed + （Liner + ReLU MaxPool) + Linear</p>
<p>（WordEmbed层，度向量的转换；Linear层，建立与 Joint Embedding Space的映射）</p>
<p>而Y编码器则多了一个调整层（AdaptLayer），进行的是跨语言共享模型的权重分配，尽量让Y语言的词和X语言的词有相似的嵌入。</p>
<h4 id="MUVE-Improving-Unsupervised-Translation"><a href="#MUVE-Improving-Unsupervised-Translation" class="headerlink" title="MUVE: Improving Unsupervised Translation"></a>MUVE: Improving Unsupervised Translation</h4><p>略</p>
]]></content>
  </entry>
  <entry>
    <title>Visual Genome 数据集</title>
    <url>/2019/07/21/Visual-Genome-%E6%95%B0%E6%8D%AE%E9%9B%86/</url>
    <content><![CDATA[<ul>
<li>数据集介绍<br><a href="https://cloud.tencent.com/developer/article/1391855" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1391855</a></li>
</ul>
<p><a href="https://visualgenome.org/" target="_blank" rel="noopener">Visual Genome 主页</a></p>
<p><a href="https://visualgenome.org/api/v0/api_home.html" target="_blank" rel="noopener">Visual Genome Data</a></p>
<p><a href="https://visualgenome.org/api/v0/api_readme" target="_blank" rel="noopener">Visual Genome Readme</a></p>
<p>Visual Genome 数据集总览：</p>
<ul>
<li>108077 张图片</li>
<li>5.4 Million Region Descriptions</li>
<li>1.7 Million Visual Question Answers</li>
<li>3.8 Million Object Instances</li>
<li>2.8 Million Attributes</li>
<li>2.3 Million Relationships</li>
<li>Everything Mapped to Wordnet Synsets  </li>
<li>标注数据：  objects，attributes，图片内的 relationships</li>
<li>共 108K 张图片，每张图片平均有， 35 个 objects，26 个 attributes，21对 objects 见的成对 relationships.</li>
</ul>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/rex8eso6p5.png?imageView2/2/w/1620" alt="img"></p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/vtmiv1yyr6.png?imageView2/2/w/1620" alt="img"></p>
<h2 id="1-Visual-Genome-数据标注"><a href="#1-Visual-Genome-数据标注" class="headerlink" title="1. Visual Genome 数据标注"></a>1. Visual Genome 数据标注</h2><p>数据集主要包括七个主要部分：</p>
<ul>
<li>region descriptions</li>
<li>objects</li>
<li>attributes</li>
<li>relationships</li>
<li>region graphs</li>
<li>scene graphs</li>
<li>question answer pairs</li>
</ul>
<h3 id="1-1-Region-Descriptions"><a href="#1-1-Region-Descriptions" class="headerlink" title="1.1. Region Descriptions"></a>1.1. Region Descriptions</h3><p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/8kgo0p0qim.png?imageView2/2/w/1620" alt="img"></p>
<p>数据集标注了图片的 regions descriptions，每个 region 有一个 bounding box. </p>
<p>如上图中，图片有三个 regions descriptions： “man jumping over a fire hydrant,”，“yellow fire hydrant,” 和   “woman in shorts is standing behind the man.”.</p>
<h3 id="1-2-Objects"><a href="#1-2-Objects" class="headerlink" title="1.2. Objects"></a>1.2. Objects</h3><p>数据集中每张图片平均有 35 个 objects，每个 object 采用 bounding box 标注.</p>
<p>如图：   </p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/ih1qpz1p3s.png?imageView2/2/w/1620" alt="img"></p>
<p><a href="http://blog.csdn.net/zziahgf/article/details/72819043" target="_blank" rel="noopener">MS-COCO 数据集</a> 只标注了 80 个 object categories，没有描述图片中的所有 objects. 实际场景中，可能有更多的 objects 类别.</p>
<p>Visual Genome 数据集旨在对图片里出现的所有视觉 objects 进行标注，objects categories 类别达到 33877 种.</p>
<h3 id="1-3-Attributes"><a href="#1-3-Attributes" class="headerlink" title="1.3. Attributes"></a>1.3. Attributes</h3><p>数据集中每张图片平均有 26 个 attributes. Objects 可能没有或者有更多的相关 attributes. </p>
<p>Attributes 可以是 color(如 yellow)，states(如 standing) 等，如图：   </p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/k1n26a1mdt.png?imageView2/2/w/1620" alt="img"></p>
<p>Attributes 能够对 objects 进行更容易的描述、对比与分类. 即使以前未见到某 object，根据 attributes 仍能推断出与 object 相关的东西. 如，“yellow and brown spotted with long neck(长脖子上有黄色和棕色的斑点)”，很可能推断出 object 是 giraffe(长颈鹿).</p>
<p>关于 attributes 的研究：</p>
<ul>
<li>采用examplar SVMs，利用相似特征来寻找 objects；</li>
<li>采用纹理(textures) 研究 objects，或者预测颜色.</li>
<li>采用 attributes 来提高目标分类结果. 如 fine-grained 识别.</li>
</ul>
<p>Attributes 一般被定义为 parts(如 has legs)、shapes(如，spherical球形的)、materials(如 furry毛皮的)；用于对新的 objects 类别进行分类.</p>
<p>Visual Genome 数据集对于 attributes 进行扩展，其 attributes 不是 image-specific 的，而是真实场景中 object-specific 的. attributes 类型包括：size(如 small), pose(如bent), state (如 transparent), emotion (如 happy)等等.</p>
<ul>
<li>基于 VGG16 的 attributes 预测结果：   </li>
</ul>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/373ih7qquc.png?imageView2/2/w/1620" alt="img"></p>
<h3 id="1-4-Relationships"><a href="#1-4-Relationships" class="headerlink" title="1.4. Relationships"></a>1.4. Relationships</h3><p>Relationships 是两个 objects 的连接关系.</p>
<p>Relationships 可以是 actions(如 jumping over)，spatial(如 is build)，comparative(如 taller than)，prepositional phrases (如 drive on). 如图：   </p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/5ljbd3m2av.png?imageView2/2/w/1620" alt="img"></p>
<ul>
<li>Relationship 预测结果：   </li>
</ul>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/pgbhzj5ui4.png?imageView2/2/w/1620" alt="img"></p>
<h3 id="1-5-Region-Graphs"><a href="#1-5-Region-Graphs" class="headerlink" title="1.5. Region Graphs"></a>1.5. Region Graphs</h3><p>结合 objects、attributes 以及  region descriptions 提取的 relationships，创建每个 regions 的 graph representation. </p>
<h3 id="1-6-Scene-Graphs"><a href="#1-6-Scene-Graphs" class="headerlink" title="1.6. Scene Graphs"></a>1.6. Scene Graphs</h3><p>Region graphs 是图片的局部区域表示，将 region graphs 结合，生成单个 scene graph来表示整张图片.</p>
<p>Scene graph 是全部 region graphs 的统一，包含了全部的 objects、attributes以及每个 region description 的 relationships.</p>
<p>Scene Graph 将多种不同层次的 scene 信息以更加一致的方式结合在一起.</p>
<h3 id="1-7-Question-Answer-QA-Pairs"><a href="#1-7-Question-Answer-QA-Pairs" class="headerlink" title="1.7. Question Answer(QA) Pairs"></a>1.7. Question Answer(QA) Pairs</h3><p>数据集中每张图片有两种类型的 QA pairs：</p>
<ul>
<li>freeform QAs - 基于整张图片；</li>
<li>region-based QAs - 基于图片的选择区域. </li>
</ul>
<p>每张图片标注了 6 中不同类型的问题：what, where, how, when, who, why.</p>
<p>如图：   </p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/vbxbgpfi92.png?imageView2/2/w/1620" alt="img"></p>
<p>Figure . Visual Genome 数据集. 每张图片包括：region descriptions - 描述了图像的局部信息；两种类型的 question answer pairs(QAs) - free form QAs 和 region-based QAs. 每个 region 转化为 objects、attributes 和 pairwise relationships region 构成的 region graph 表示. 最终， 结合 region graphs 以形成图片内全部 objects 的 scene graph.</p>
<h2 id="2-Visual-Genome-数据集应用"><a href="#2-Visual-Genome-数据集应用" class="headerlink" title="2. Visual Genome 数据集应用"></a>2. Visual Genome 数据集应用</h2><p>基本应用：</p>
<ul>
<li>attribute classification 属性分类</li>
<li>relationship classification 关系分类</li>
<li>description generation 描述生成</li>
<li>question answering QA</li>
</ul>
<p>更多应用：</p>
<ul>
<li>Dense image captioning</li>
<li>Visual question answering</li>
<li>Image understanding</li>
<li>Relationship extraction</li>
<li>Semantic image retrieval</li>
<li>Completing the Set of Annotations</li>
</ul>
<p>注 - 与其它数据集对比：   </p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/cjqe5v7i44.png?imageView2/2/w/1620" alt="img"></p>
<h2 id="3-Reference"><a href="#3-Reference" class="headerlink" title="3. Reference"></a>3. Reference</h2><p>[1] - <a href="https://visualgenome.org/" target="_blank" rel="noopener">Visual Genome Home</a></p>
<p>[1] - <a href="https://visualgenome.org/static/paper/Visual_Genome.pdf" target="_blank" rel="noopener">Visual Genome Doc</a></p>
<p>[2] - <a href="https://arxiv.org/pdf/1701.02426.pdf" target="_blank" rel="noopener">Scene Graph Generation by Iterative Message Passing</a></p>
<p>本文参与<a href="https://cloud.tencent.com/developer/support-plan" target="_blank" rel="noopener">腾讯云自媒体分享计划</a>，欢迎正在阅读的你也加入，一起分享。</p>
]]></content>
      <categories>
        <category>目标检测</category>
      </categories>
      <tags>
        <tag>目标检测</tag>
      </tags>
  </entry>
  <entry>
    <title>Video captioning summary</title>
    <url>/2019/02/23/Video-captioning-summary/</url>
    <content><![CDATA[<ul>
<li>总结一下各论文使用的encoder的model分别是什么，是否采用了C3D，若采用了C3D,每16帧输出一个特征向量，这样的话，n_frames/16 个特征向量，那么论文中又是如何聚合特征来得到video 特征的？<h2 id><a href="#" class="headerlink" title=" "></a> </h2></li>
</ul>
<h2 id="训练和测试的一般过程"><a href="#训练和测试的一般过程" class="headerlink" title="训练和测试的一般过程"></a>训练和测试的一般过程</h2><p>The training process predicts the next word given the previous words from groundtruth, while the generation process conditions the prediction on the ones previously generated by itself.  </p>
<h2 id="训练损失"><a href="#训练损失" class="headerlink" title="训练损失"></a>训练损失</h2><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0iyn2xsz9j30r00higpg.jpg" style="zoom:70%"></p>
<h2 id="Code-总结"><a href="#Code-总结" class="headerlink" title="Code 总结"></a>Code 总结</h2><div class="table-container">
<table>
<thead>
<tr>
<th>model</th>
<th>batch_size</th>
<th>epoch</th>
<th>learning_rate</th>
<th>MSVD&lt;/br&gt;train-dataset</th>
<th>MSR-train-dataset</th>
</tr>
</thead>
<tbody>
<tr>
<td>video-caption.pytorch</td>
<td>128</td>
<td>6001（MSR）</td>
<td>0.0004 (每200epoch下降0.8)</td>
<td>✘</td>
<td>6513 pairs&lt;/br&gt;(每一次随机的从captions中选择一个作为label)</td>
</tr>
<tr>
<td>SA-tensorflow</td>
<td>100</td>
<td>200</td>
<td>0.0001（不变）</td>
<td>1200×41个pairs</td>
<td>✘</td>
</tr>
<tr>
<td>reconstruction-network</td>
<td>100</td>
<td>iter=100000  （epoch=100000×100/(1200*41）=203</td>
<td>0.00001（不变）</td>
<td>1200×41个pairs</td>
<td>✘</td>
</tr>
<tr>
<td>saliency-based</td>
<td>100</td>
<td>100</td>
<td>0.0003（不变）</td>
<td>略</td>
<td>✘</td>
</tr>
<tr>
<td>HRNE</td>
<td>200</td>
<td>128</td>
<td>0.0002</td>
<td>略</td>
<td>✘</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>model</th>
<th>construct vocab use which dataset</th>
</tr>
</thead>
<tbody>
<tr>
<td>video-caption.pytorch</td>
<td>MSR: all</td>
</tr>
<tr>
<td>SA-tensorflow</td>
<td>MSVD: train</td>
</tr>
<tr>
<td>reconstruction-network</td>
<td>MSVD: all</td>
</tr>
<tr>
<td>saliency-based</td>
<td></td>
</tr>
<tr>
<td>HRNE</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>model</th>
<th>loss function</th>
<th>input of decoder</th>
</tr>
</thead>
<tbody>
<tr>
<td>video-caption.pytorch</td>
<td>output of decoder（bs, hidden size）,经过一个全连接层得到one-hot形式(bs, n_vocab），在经过F.log_softmax。则损失函数 nn.NLLLoss（）</td>
<td>rnn1的输入是video feature;&lt;/br&gt;rnn2的输入是rnn1的输出cancatenate 上一步ground truth的word embedding&lt;/br&gt; output1, state1 = self.rnn1(vid_feats, state1)&lt;/br&gt; input2 = torch.cat((output1, padding_words), dim=2)&lt;/br&gt;          output2, state2 = self.rnn2(input2, state2)</td>
</tr>
<tr>
<td>SA-tensorflow</td>
<td><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0izmumz8sj30ry01l74i.jpg">LSTM的output/hidden state、经过attention加权求和得到的videofeature、上一步step的groundtruth word embedding进行concatenate，在经过全连接层、非线性层、全连接层、输入交叉熵损失函数：tf.nn.softmax_cross_entropy_with_logits</td>
<td>LSTM的输入是concatenate(video_feature, 上一步ground truth的word embdedding）</td>
</tr>
<tr>
<td>reconstruction-network</td>
<td>output of decoder（bs, hidden size）,经过一个全连接层得到one-hot形式(bs, n_vocab），在经过dropout。  则损失函数 nn.CrossEntropyLoss()</td>
<td>LSTM的输入是concatenate(video_feature, 上一步ground truth的word embdedding）</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h2 id="Paper-总结"><a href="#Paper-总结" class="headerlink" title="Paper 总结"></a>Paper 总结</h2><div class="table-container">
<table>
<thead>
<tr>
<th>model</th>
<th>dataset</th>
<th>n_frames</th>
</tr>
</thead>
<tbody>
<tr>
<td>S2VT</td>
<td>MSVD</td>
<td>每10帧取1帧</td>
</tr>
<tr>
<td>SA</td>
<td>MSVD</td>
<td>前240帧等间隔取26帧</td>
</tr>
<tr>
<td>h-RNN</td>
<td>MSVD</td>
<td>没讲( ˇˍˇ )</td>
</tr>
<tr>
<td>HRNE</td>
<td>MSVD</td>
<td>fixed 160帧</td>
</tr>
<tr>
<td>LSTM-TSA</td>
<td>MSVD</td>
<td>等间隔采取25帧</td>
</tr>
<tr>
<td>LSTM-E</td>
<td>MSVD</td>
<td>all frames</td>
</tr>
<tr>
<td>Reconstruction</td>
<td>MSVD  MSR-VTT</td>
<td>等间隔28帧</td>
</tr>
<tr>
<td>M3</td>
<td>MSVD  MSR-VTT</td>
<td>28帧for MSVD; 40帧for MSR-VTT</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>model</th>
<th>词频</th>
<th>MSVD  vocabulary</th>
<th>MSR-VTT  vocabulary</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hierarchical Boundary-Aware Neural Encoder for Video Captioning</td>
<td>大于等于5</td>
<td>4215</td>
<td></td>
</tr>
<tr>
<td>Multimodal Memory Modelling for Video Captioning</td>
<td></td>
<td>13,000</td>
<td>29,000</td>
</tr>
<tr>
<td>Spatio-Temporal Dynamics and Semantic Attribute Enriched Visual Encoding for Video Captioning</td>
<td></td>
<td>9450</td>
<td>23500</td>
</tr>
<tr>
<td>Describing Videos by Exploiting Temporal Structure</td>
<td></td>
<td>16,000</td>
<td></td>
</tr>
<tr>
<td>Video Paragraph Captioning Using Hierarchical Recurrent Neural Networks</td>
<td></td>
<td>12, 766（1, 297 and 670 videos ）</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>model</th>
<th>feature</th>
<th>METER</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mean Pool + LSTM</td>
<td>在COCO上预训练的Alex net</td>
<td>29.1</td>
</tr>
<tr>
<td>S2VT</td>
<td>RGB frames on VGG Net&lt;/br&gt;optical flows on AlexNet</td>
<td>29.8</td>
</tr>
<tr>
<td>SA</td>
<td>GoogLeNet and 3D-CNN</td>
<td>29.6</td>
</tr>
<tr>
<td>LSTM-E</td>
<td>VGGNet and C3D</td>
<td>31.0</td>
</tr>
<tr>
<td>h-RNN</td>
<td>VGGNet and C3D</td>
<td>32.6</td>
</tr>
<tr>
<td>HRNE</td>
<td>GooLeNet</td>
<td>33.1</td>
</tr>
<tr>
<td>Reconstruction</td>
<td>Inception-V4&lt;/br&gt; last pooling layer</td>
<td>34.1</td>
</tr>
</tbody>
</table>
</div>
<h2 id="提取frames-features-之后，获取video-feature的几种方法："><a href="#提取frames-features-之后，获取video-feature的几种方法：" class="headerlink" title="提取frames features 之后，获取video feature的几种方法："></a>提取frames features 之后，获取video feature的几种方法：</h2><p><strong>1. Mean pooling</strong></p>
<ul>
<li>Translating videos to natural language using deep recurrent neural networks. NACACL, 2015</li>
<li>Jointly modeling embedding and translation to bridge video and language. CoRR,  2015  </li>
</ul>
<p><strong>2. Weighted mean Pooling with an attention model</strong>    </p>
<ul>
<li>Describing videos by exploiting temporal structure. ICCV, 2015  </li>
<li>Exploring Visual Relationship for Image Captioning</li>
<li>2层LSTM，第一层LSTM的输入是对object/frames features进行平均池化，第二层LSTM的输入是给定第一层的hidden state 来得到attention 系数，从而对object/frames features进行加权求和。 即第一层用平均池化的特征来表征 global feture，第二层用加权求和的特征来表征 global feature</li>
</ul>
<p><strong>3. Taking the last output from an RNN encoder which summarizes the feature sequence</strong>    </p>
<ul>
<li>Long-term recurrent convolutional networks for visual recognition and description. CVPR, 2015</li>
<li>Sequence to sequence - video to tex. ICCV, 2015</li>
<li>A multi-scale multiple instance video description network. CoRR, 2015  </li>
</ul>
<h2 id="video-captioning-的模型中，含有extract-object-proposal的论文"><a href="#video-captioning-的模型中，含有extract-object-proposal的论文" class="headerlink" title="video captioning 的模型中，含有extract object proposal的论文"></a>video captioning 的模型中，含有extract object proposal的论文</h2><ul>
<li>Video paragraph captioning using hierarchical recurrent neural networks.  CVPR, 2016.  </li>
<li>object-aware aggregation with bidirectional temporal graph for video capioning. CVPR, 2019</li>
</ul>
<h2 id="loss"><a href="#loss" class="headerlink" title="loss"></a>loss</h2><ul>
<li>一般的情况下是对decoder的部分计算loss, 并反向传播，encoder采用预训练好的model，并不在进行finetune。</li>
</ul>
<h2 id="使用objects-feature-的文章"><a href="#使用objects-feature-的文章" class="headerlink" title="使用objects feature 的文章"></a>使用objects feature 的文章</h2><ul>
<li></li>
<li>video as graph : charades 每帧提取50个objects(当objects 的数量将为25的时候，score只降了0.2), something2 :每帧提取10个objects</li>
<li>我的msr-vtt: 提取5个效果比较好，不会包含太多的噪声</li>
<li>==尽量让一个video中的objects 不同，去聚类帧之间的objects==  </li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>论文</th>
<th>charades( 30s)</th>
<th></th>
<th>something-something( 3-6s )</th>
<th>activity</th>
<th>MSVD（10-25s）</th>
</tr>
</thead>
<tbody>
<tr>
<td>video as graph</td>
<td>16帧 *50</td>
<td></td>
<td>16帧* 10</td>
<td>10帧*100</td>
<td></td>
</tr>
<tr>
<td>HTM （video captioning)</td>
<td>80帧 *30</td>
<td></td>
<td></td>
<td></td>
<td>28帧*30</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>论文</th>
<th>object detector</th>
<th>return</th>
</tr>
</thead>
<tbody>
<tr>
<td>(ACM 2019)Hierarchical Global-Local Temporal Modeling for VideoCaptioning</td>
<td>Faster rcnn 去掉rcnn的分类层，</td>
<td>提取_head_to_tail之后的特征 2048维</td>
</tr>
<tr>
<td>(CVPR 2019)Spatio-Temporal Dynamics and Semantic Attribute Enriched Visual Encoding for Video Captioning</td>
<td>YoLo</td>
<td>没说</td>
</tr>
<tr>
<td>(CVPR 2019)Grounded Video Description</td>
<td>a Faster RCNN model [24] with a ResNeXt-101 FPN backbone (在VG上预训练，类别会比coco 多，同时训练目标检测和属性分类)</td>
<td>返回的是fc6,我认为是_head_to_tail</td>
</tr>
<tr>
<td>( ECCV 2018)Videos as Space-Time Region Graph</td>
<td>the RPN with ResNet-50 backbone and FPN ==(需要注意，这里具体的：先由I3D得到THWd的特征，然后对32帧，每2帧取1帧，去得到这16帧的bbox，得到了bbox不是直接去得到pooled_feats，而是通过I3D的空间特征，bbox, Roi Align来得到bbox 的 region feat) ==</td>
<td>返回的是roi_pooling的7*7的，然后再进行平均池化</td>
</tr>
<tr>
<td>(CVPR 2019)Object-aware Aggregation with Bidirectional Temporal Graph for Video Captioning</td>
<td>MASK RCNN，在COCO上预训练，</td>
<td>将得到的regions 裁剪成图像，再送入ResNet-200中，得到res-layer5c的局部特征</td>
</tr>
<tr>
<td>（CVPR 2019）Auto-Encoding Scene Graphs for Image Captioning</td>
<td>faster rcnn , 使用 r-cnn 输出的 rois， 然后作用到 base feat上，使用 roi pooling 的到 pooled feats</td>
<td>返回 7*7的pooled feats</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>根据faster r-cnn 的网络结构，rpn部分输出bbox的预测，rcnn部分也输出bbox的预测，在目标检测任务中，采用rcnn的输出作为最后的结果。</li>
<li>但是在视频帧提取 object 的任务中，一般采用的是rpn部分输出的bbox,  why？ 这是因为，想要得到的不是bbox的坐标，而是bbox feats， 因此，直接取pooled_feats更加简洁方便。</li>
<li>所以在利用mmdetection时，设置 在rpn部分的max_region_per</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>[VisualSparta] Sparse Transformer Fragment-level Matching for Large-scale Text-to-Image Search</title>
    <url>/2021/03/16/VisualSparta-Sparse-Transformer-Fragment-level-Matching-for-Large-scale-Text-to-Image-Search/</url>
    <content><![CDATA[<h2 id="1-任务"><a href="#1-任务" class="headerlink" title="1. 任务"></a>1. 任务</h2><p>本文是做跨模态检索问题。文本到图像的检索是多模态信息检索中的一项基本任务，即在给定文本查询的情况下从大型且未标记的图像数据集中检索相关图像。</p>
<h2 id="2-存在的问题"><a href="#2-存在的问题" class="headerlink" title="2. 存在的问题"></a>2. 存在的问题</h2><p>图文检索问题上存在两个核心挑战：<strong style="color:red;">准确率以及速度</strong>。</p>
<h2 id="3-本文提出的点"><a href="#3-本文提出的点" class="headerlink" title="3. 本文提出的点"></a>3. 本文提出的点</h2><p>在本文中，提出了基于transformer 的 VisualSparta 模型，这是一种新颖的文本到图像检索模型，该模型在准确性和效率上都比现有模型显著提高。</p>
<p>本文提出的模型关注点在于两点：</p>
<p>（1）准确率，学习query tokens 与 image regions之间的细粒度关系，以丰富跨模态理解。</p>
<p>（2）有效性，独立的学习query 和 answer（image）的特征表示，从而使得模型可以<strong><strong style="color:red;">离线的</strong>索引所有的candidate images</strong>。整个VisualSparta 模型可以作为一个经典的反向索引（Inverted index）搜索引擎，以实现高效搜索。</p>
<h2 id="4-本文的贡献"><a href="#4-本文的贡献" class="headerlink" title="4. 本文的贡献"></a>4. 本文的贡献</h2><p>1) 性能优势：提出了一个新的基于片段交互（fragment-level interaction）的图文检索模型，并取得了SOTA的性能；</p>
<p>2) 速度优势：相比于标准的向量搜索，VisualSparta 有391x 速度提升。且实验证明，由于VisualSparta 可以有效的进行<strong>反向索引</strong> ，因此对于更大的数据集，速度优势会更加的明显，</p>
<p>3) 第一：VisualSparta 是<strong>第一个</strong>可以在大规模数据集上实现<strong>实时搜索</strong>的，基于transformer的 text-to-image retrieval model，并且实现了显著的性能提升。本文的方法证明了large pretrained model 也可以占用<strong>较少的内存和较少的计算时间</strong>。</p>
<p>4) 对当前存在的 text-to-image retrieval models 进行了 accuracy-latency comparisons。</p>
<h2 id="5-Method"><a href="#5-Method" class="headerlink" title="5. Method"></a>5. Method</h2><p>本文提出了 <strong>VisualSparta retriever</strong>, a fragment-level transformer-based model for efficient text-image matching.</p>
<p><img src="https://i.loli.net/2021/03/16/ZTKckhILpCEBv19.png" alt="image-20210316192344412"></p>
<h3 id="5-1-Query-representation"><a href="#5-1-Query-representation" class="headerlink" title="5.1 Query representation"></a>5.1 Query representation</h3><p>在检索中，<strong style="color:red;">query 的处理是一个在线操作</strong>。需要很好的考虑query 编码的效率。以前的方法，使用bi-RNN来处理 query sentence，为每个token获得上下文特征表示。</p>
<p>本文中，不采用序列处理的方式。丢掉query中的顺序信息，仅仅使用预训练的word embedding 来表征每个token。<strong>这种方法可以使得每个token的特征表达损失独立的，与上下文无关的</strong>。同时这种方式对于高效的indexing and inference 是必要的。</p>
<p>a query is represented as $\hat{w}=\left\{\hat{w}_{1}, \ldots, \hat{w}_{m}\right\}$</p>
<h3 id="5-2-Visual-Representation"><a href="#5-2-Visual-Representation" class="headerlink" title="5.2 Visual Representation"></a>5.2 Visual Representation</h3><p>相比于 query 需要实时在线处理，answer candidates 可以在 query 到来之前离线编制索引 (indexed offline)。因此，answer candidates 的处理可以更加丰富和复杂。因此，本文 follow OSCAR的工作，对于answer candidates 本文提取其上下文特征。</p>
<p>具体的看上图.</p>
<p>$H_{\text {image }} \in \mathbb{R}^{(n+k) \times d_{H}}$ is the final contextualized representation for one answer.</p>
<h3 id="5-3-Scoring-Function"><a href="#5-3-Scoring-Function" class="headerlink" title="5.3 Scoring Function"></a>5.3 Scoring Function</h3><p>第一个等式：学习 image element 和 每个query token 之间的fragment-level 交互。</p>
<p>$y_{i} =\max _{j \in[1, n+k]}\left(\hat{w}_{i}^{T} h_{j}\right) $              <strong>（equation 10）</strong></p>
<p>第二个等式：经过一个 ReLu 和 可训练的bias来得到sparse embedding。</p>
<p>$ \phi\left(y_{i}\right) =\operatorname{ReLU}\left(y_{i}+b\right) $              <strong>（equation 11）</strong></p>
<p>第三个等式：对于所有的分数求和，并为了抑制过大的分数，使用log operation</p>
<p>$ f(q, v) =\sum_{i=0}^{m} \log \left(\phi\left(y_{i}\right)+1\right) $             <strong>（equation 12）</strong></p>
<h3 id="5-4-Retriever-Training"><a href="#5-4-Retriever-Training" class="headerlink" title="5.4 Retriever Training"></a>5.4 Retriever Training</h3><p>最小化如下目标：</p>
<p>$J=f\left(q, v^{+}\right)-\log \sum_{k \in K^{-}} e^{\left.f\left(q, v_{k}\right)\right)}$</p>
<p><strong style="color:blue;"><strong>yaya: 这个损失函数其实与正常的NCE损失不同</strong></strong></p>
<p>负样本的选择：从相同batch 中的其他image samples作为负样本。</p>
<p><strong>而且本文发现，相比于一些复杂的负样本选择策略（比如，使用有相近标签的相似图像作为负样本），这种负样本的选择策略是简单有效地，效果相当。</strong></p>
<p><strong style="color:blue;">yaya: 为什么这种选择策略比复杂的策略是有效的？？是不是在不同的场合，应该使用不同的策略呢？？</strong></p>
<h3 id="5-5-Efficient-Indexing-and-Inference"><a href="#5-5-Efficient-Indexing-and-Inference" class="headerlink" title="5.5 Efficient Indexing and Inference"></a>5.5 Efficient Indexing and Inference</h3><p><strong style="color:red;">real-time inference</strong></p>
<p>定义 testing query 为 $q=\left[w_{0}, \ldots w_{m}\right]$</p>
<p>the <strong>ranking score</strong> between $q$ and an image is （利用5.3 中第二个等式得到的 sparse embedding）:</p>
<p>​    $\operatorname{CACHE}(w, v)=\log ($ sparse embedding $) \quad w \in W $             <strong>（equation 14）</strong></p>
<p>​    $f(q, v)=\sum_{i=1}^{m} \operatorname{CACHE}\left(w_{i}, v\right)$             <strong>（equation 15）</strong></p>
<p>由于query term embedding 不是基于上下文得到。因此，可以预先计算 vocabulary $W$ 中每个<strong>term</strong> $w$  与 每个 image candidates 之间的 ranking feature $\phi(w, v)$，<strong style="color:red;">生成的分数 is cached during indexing</strong>，如等式14 所示。得到了一个一个  <strong style="color:red;">$N_{vocab}*M_{images} $的矩阵</strong></p>
<p><strong>during inference time，最终的分数可以经过 O(1)的查询和一个简单的求和运算得到，如 公式15所示。</strong></p>
<p><strong style="color:red;">Inverted Index</strong></p>
<p>更加重要的是，以上的计算可以经由一个 Inverted Index 来高效的实施。 Inverted Index 是现代搜索引擎的基础数据结构，如图1所示。</p>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95</a></p>
</blockquote>
<h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><h3 id="Datasets"><a href="#Datasets" class="headerlink" title="Datasets"></a>Datasets</h3><ul>
<li><p>使用图像描述数据集作为本文text-to-image model 的数据来源。<strong>benchmark: MSCOCO; Flickr 30K</strong></p>
</li>
<li><p>for large-scale efficiency experiments: 由于目前不存在大规模的图像描述数据集。</p>
<p>因此，we <strong>manually design 113K and 1M datasets</strong> for testing the inference speed of different models in the large-scale setting.   对于这两个数据集，我们只关注于speed comparison。在数据上的模型性能忽略不比较。</p>
<p>The 113K dataset refers to the MSCOCO training set。</p>
<p>The 1M dataset we design consists of 1 million images randomly sampled from the MSCOCO training set.</p>
<p>所有的 <strong>efficiency test  experiments</strong> 都是在MSCOCO 1K and 5k test splits 再加上这113k 和 1M 数据上进行的。</p>
</li>
</ul>
<h3 id="Recall-Performance"><a href="#Recall-Performance" class="headerlink" title="Recall Performance"></a>Recall Performance</h3><p><img src="https://i.loli.net/2021/03/17/8dVeNz7bngQEwKl.png" alt="image-20210317120703074" style="zoom:50%;"></p>
<h3 id="Speed-Performance"><a href="#Speed-Performance" class="headerlink" title="Speed Performance"></a>Speed Performance</h3><p>三个模型使用相同的Faster-rcnn image region features。下表中没有考虑这部分时间。</p>
<p><img src="https://i.loli.net/2021/03/17/GfApECsXomRWHPq.png" alt="image-20210317120800787" style="zoom:50%;"></p>
<p>（1）在不同size的数据集下，本文提出的模型的速度远高于另外两个模型（一个使用dual encoding, 另一个使用transformer model）</p>
<p>（2）Table 2 also reveals that as the number of images increases, <strong>the performance drop is much slower</strong> when comparing VisualSparta with other two methods.</p>
<h3 id="Speed-Accuracy-Flexibility"><a href="#Speed-Accuracy-Flexibility" class="headerlink" title="Speed-Accuracy Flexibility"></a>Speed-Accuracy Flexibility</h3><p>在 Efficient Indexing and Inference 这一节，得到了一个  <strong style="color:red;">$N_{vocab}*M_{images} $的矩阵</strong>， 对于每个image, 与 N个words 计算出了weights, 可以挑选出 top-K， 这样更新为一个  <strong style="color:red;">$K_{words}*M_{images} $的矩阵</strong>，K 越小，检索效率越高。</p>
<p><img src="https://i.loli.net/2021/03/17/nkhj8yC6dPxugfw.png" alt="image-20210317132243925" style="zoom: 67%;"></p>
<p><img src="https://i.loli.net/2021/03/17/FmkRlfDp4WqTzOV.png" alt="image-20210317132318637" style="zoom: 50%;"></p>
<h3 id="Implementation-details"><a href="#Implementation-details" class="headerlink" title="Implementation details"></a>Implementation details</h3><ul>
<li>image encoder 的初始权重 从 Oscar-base model （12 layers and 768 hidden dimensions）中获得。</li>
<li>the query embedding， 使用Oscar-base word embedding的参数作为初始权重</li>
</ul>
<h2 id="可以查看的其他文献"><a href="#可以查看的其他文献" class="headerlink" title="可以查看的其他文献"></a>可以查看的其他文献</h2><p>本文受到此篇论文的启发: <strong>Sparta: Efficient open-domain question answering via sparse transformer matching retrieval.</strong></p>
<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a><strong>yaya</strong></h2><ul>
<li><p>对于输入的消融实现，如果不提供 object label ？</p>
<p><strong>本文没有做这个实验。</strong></p>
</li>
<li><p>实验结果与 transformer-based retrieval model 的对比， eg: Oscar, Unicoder-VL 等</p>
<p><strong>本文没有做对比，只是与不基于pre-trained models 进行了对比。</strong></p>
<p><strong>但是实际上，本文的实验效果在准确率上，是不如那些基于预训练模型的。</strong></p>
</li>
<li><p>使用了 transformer 结构，那么本文的学习率是如何设计的？先warm up吗？？</p>
<p><strong>本文学习率为 1e-5， bs=20, 没有对学习率的变化进行说明。</strong></p>
</li>
<li><p>本文发现，相比于一些复杂的负样本选择策略（比如，使用有相近标签的相似图像作为负样本），这种负样本的选择策略是简单有效地，效果相当。</p>
<p><strong>对于这部分，论文中并没有相关的解释与实验数据说明</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>cross-modal</category>
        <category>real time</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
        <tag>real time</tag>
      </tags>
  </entry>
  <entry>
    <title>Vokenization Improving Language Understanding with Contextualized, Visual-Grounded Supervision</title>
    <url>/2020/10/18/Vokenization-Improving-Language-Understanding-with-Contextualized-Visual-Grounded-Supervision/</url>
    <content><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><h4 id="现存问题"><a href="#现存问题" class="headerlink" title="现存问题"></a>现存问题</h4><p>人类学习语言都是结合多模态信息，但是当前的 language pre-training frameworks 仅通过自监督的方式，学习语言这一种模态。</p>
<p>虽然这种自监督的方式取得了很大的成功，但是它们没有利用grounding information from external visual word.</p>
<blockquote>
<p>Emily M Bender and Alexander Koller. 2020. <strong>Climbing towards nlu: On meaning, form, and understanding in the age of data.</strong> In ACL.</p>
<p>Yonatan Bisk, Ari Holtzman, Jesse Thomason, Jacob Andreas, Yoshua Bengio, Joyce Chai, Mirella Lapata,<br>Angeliki Lazaridou, Jonathan May, Aleksandr Nisnevich, Nicolas Pinto, and Joseph Turian. 2020. <strong>Experience grounds language.</strong> In EMNLP</p>
</blockquote>
<h4 id="本文的解决"><a href="#本文的解决" class="headerlink" title="本文的解决"></a>本文的解决</h4><p><img src="https://i.loli.net/2020/10/17/1cz3MHUdNXA9o5J.png" alt="image-20201017095623630" style="zoom:33%;"></p>
<p>本文：介绍了一个 <strong>视觉</strong>监督语言模型，如图1，该模型使用 language tokens 作为输入，使用token-related images 作为视觉监督。本文将这些images称作 vokens，which act as visualizations of the corresponding tokens.</p>
<p>假若a large aligned token-voken dataset 存在，那么模型可以通过voken-prediction task 从这些vokens中进行学习。但是不幸的是，不存在这种大型数据集，主要是有两个挑战：(1) 视觉性单词与 其他非视觉性单词之间，数量上存在很大的差异。如，在visually-grounded language datasets中仅有120M tokens, 但是在BERT的训练数据中有3300M tokens。grounded language 一般会更短，偏向于instructive descriptions, 因此在句子长度和有效词的数量上与其他语言类型的分布不同。(2) 自然语言中的大部分单词是 not visually grounded，因此对是否建立一个 visual supervision的数据集提出了质疑。粗略估计，英语维基百科中 grounded tokens 的比例仅为大约28％。 这种 low grounded ratio 导致以前方法中的视觉监控覆盖率低。</p>
<p><img src="https://i.loli.net/2020/10/17/27sWCBNOiqp13Vz.png" alt="image-20201017111702738"></p>
<p>为解决以上的两个挑战，本文提出了一个 <strong>vokenization method, that contextually maps the tokens to the visualized tokens (i.e., vokens) by retrieval.</strong>  而不是直接使用具有visually grounded的语言数据集来监督语言模型。</p>
<p>解决第一个挑战：(1) relative small datasets to train the <strong>vokenization processor</strong> (2) generate vokens for large language corpora.<br>our visually-supervised language model will take the input supervision from these large datasets, thus <strong>bridging the gap between different data sources,</strong> which solves the first challenge.</p>
<p>解决第一个挑战：low grounded ratio 的第二个挑战似乎是语言的固有特征。 但是，我们发现，考虑到它的上下文，可以将一些非可视化的tokens 有效地映射到相关图像。by our contextual token-image matching model (defined in Sec. 3.2) inside our vokenization processor, where we map tokens to images by viewing the sentence as the context.</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Using our proposed vokenizer with a <strong>contextualized</strong> token-image matching model, we generate vokens for English Wikipedia. </p>
<p>Supervised by these generated vokens, we show consistent improvements upon a BERT model on several diverse NLP tasks such as GLUE (Wang et al., 2019), SQuAD (Rajpurkar et al., 2016), and SWAG (Zellers et al., 2018).  We also show the transferability of our vokens to other frameworks (i.e., RoBERTa).</p>
<h3 id="Vokenization"><a href="#Vokenization" class="headerlink" title="Vokenization"></a>Vokenization</h3><p><img src="https://i.loli.net/2020/10/17/fUWtQpIO8kZjAcY.png" alt="image-20201017120304025" style="zoom:50%;"></p>
<p>we <strong>retrieve an image for a token</strong> from a set of images $X$ = {$x_1; x_2; … ; x_n$} regarding a token-image-relevance scoring function $r_\theta(w_i; x; s)$. This scoring function $r_\theta(w_i; x; s)$, parameterized by $\theta$</p>
<h4 id="Contextual-Token-Image-Matching-Model"><a href="#Contextual-Token-Image-Matching-Model" class="headerlink" title="Contextual Token-Image Matching Model"></a>Contextual Token-Image Matching Model</h4><p>输入：The model takes a sentence $s$ and an image $x$ as input.</p>
<p>输出：The output $r_\theta(w_i; x; s)$ is the relevance score between the token $w_i \in s$ and the image $x$ while considering the whole sentence $s$ as a context.</p>
<p>Model: an inner product of the language feature representation $f_\theta(w_i; s)$ and the visual feature representation $g_\theta(x)$: $r_\theta(w_i; x; s)$ = $f_\theta(w_i; s)^T$ $g_\theta(x)$</p>
<p>token-image paris: 使用MS-COCO image caption pairs， 将caption中的所有tokens的vokens 都指定为该 image.</p>
<p>Training: 训练模型，maximizing the relevance score of these aligned token-image pairs over unaligned pairs. 使用 hinge loss.</p>
<h3 id="Visually-Supervised-Language-Models"><a href="#Visually-Supervised-Language-Models" class="headerlink" title="Visually-Supervised Language Models"></a>Visually-Supervised Language Models</h3><p>Based on these vokens, we propose a new pre-training task for language: voken classification.</p>
<h4 id="The-Voken-Classification-Task"><a href="#The-Voken-Classification-Task" class="headerlink" title="The Voken-Classification Task"></a>The Voken-Classification Task</h4><p><img src="https://i.loli.net/2020/11/04/j32ZMfNUpHWwez4.png" alt="image-20201104160728232"></p>
<p>BERT 的结果，会在每个token $w_i$的位置输出一个localized feature representation ${h_i}$，因此这将会很容易增加一个 token-level classification task, 而不需要修改模型的结构。Suppose the vokens come<br>from a finite set $X$, we convert the hidden output to ${h_i}$ a probability distribution ${p_i}$ with a linear layer and a softmax layer. </p>
<h3 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h3><ul>
<li>受到这篇文章对的影响，是否可以结合视频，设计一个这种模型，比如有一些动词，仅能在视频中体现出来。</li>
</ul>
]]></content>
      <tags>
        <tag>region-word-embedding</tag>
      </tags>
  </entry>
  <entry>
    <title>WMT Shared Tasks -- Human Evaluation </title>
    <url>/2020/05/14/WMT-Shared-Tasks-Human-Evaluation/</url>
    <content><![CDATA[<h3 id="WMT-Shared-Tasks-—-Human-Evaluation"><a href="#WMT-Shared-Tasks-—-Human-Evaluation" class="headerlink" title="WMT Shared Tasks — Human Evaluation"></a>WMT Shared Tasks — Human Evaluation</h3><h4 id="Human-Evaluation"><a href="#Human-Evaluation" class="headerlink" title="Human Evaluation"></a>Human Evaluation</h4><p>两种评估的方式：direct assessments (DA); language pairs evaluated with relative ranking (RR)</p>
<p>但是DA相比于RR更具有优势，namely，对翻译质量的评估采取 absolute score 的方式。可以<strong>实施quality control</strong> 。</p>
<h4 id="Human-judgement-quality-control"><a href="#Human-judgement-quality-control" class="headerlink" title="Human judgement quality control"></a>Human judgement quality control</h4><ul>
<li><p>每个标注者，每次任务：给定100个 （reference+ candidate）pair, 针对给定的reference, 评估生成的candidate的好坏。</p>
</li>
<li><p>100个pair中有60个用于quality control，40个由participating systems 生成的翻译组成。</p>
<p>（1）这60个pair，是官方设计出来的，包括三类，repeat pairs (expecting a similar judgment), damage MT outputs/ bad reference (expecting significantly worse scores) and use references instead of MT outputs (expecting high scores). 因此仅仅会有20%的资源消耗：bad reference; good reference</p>
<p>Specifically，先从正常的MT system 中 得到30个 （reference, MT output）pair，如 table 5 中的 original system output， 然后1)对1-10对，进行重复，得到10对。2）对11-20对，将MT output搞破坏。得到10对。3）对21-30对，取corresponding reference—&gt; (reference_1, reference_2)，得到10对。</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gepxhtqcpgj311h052abz.jpg"></p>
<p>（2）within each 100-translation HIT， 每个articipating system<strong>等比例的贡献</strong>a（within each 100-translation HIT, the same proportion of translations are included from each participating system for that language pair.  ）这是为了确保每个参与的 系统含有近似的相同数量的评估。同时，这也从三个方面得到了公平性的评估：1）每有一个workers做一个HIT, 则就会为所有参与的系统增加human judgement。2）不会轻易受到worker个性差异的影响，因为每个worker都会给所有参与的系统进行评估。3）尽管DA判断是绝对的，但众所周知，判断者会根据观察到的总体翻译质量来“校准”他们使用量表的方式。 对于每个HIT（包括所有参与的系统），这种影响都是平均的。</p>
</li>
</ul>
<h4 id="Annotator-Agreement"><a href="#Annotator-Agreement" class="headerlink" title="Annotator Agreement"></a>Annotator Agreement</h4><ul>
<li><p><strong>【bad reference pairs】</strong> 由于 bad reference pairs 的质量应该是显著偏低的，通过查看人类在这类pairs 上的评分是否也是显著偏低。来过滤掉可信赖度低的human assessors。</p>
<p>set（A, bad reference） 与  set（A, translatin_B）这两个集合上的人类评估，计算一个p-value， 若p-value&gt;0.05 则说明该human assessor的可信度低。</p>
</li>
<li><p><strong>【repeat pairs】</strong> 对于 repeat pairs, 查看得到 repeat assessments的程度。</p>
</li>
</ul>
<h4 id="Producing-the-Human-Ranking"><a href="#Producing-the-Human-Ranking" class="headerlink" title="Producing the Human Ranking"></a>Producing the Human Ranking</h4><ul>
<li><p>Standardized </p>
<p>为了消除不同的人类评估者的评分策略的差异，首先根据每个人类评估者的总体平均得分和标准差得分对翻译的人类评估得分进行<strong>标准化</strong>。</p>
</li>
<li><p>system  score ……</p>
</li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Weakly-Supervised Spatio-Temporally Grounding Natural Sentence in Video</title>
    <url>/2019/12/02/Weakly-Supervised-Spatio-Temporally-Grounding-Natural-Sentence-in-Video/</url>
    <content><![CDATA[<ul>
<li><strong>ACL 2019</strong></li>
</ul>
<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><ul>
<li><p>image grounding取得了很大的进步，但是将该任务迁移到视频上，需要对视频中的每帧都标注region，这个工程量是巨大的。</p>
</li>
<li><p>为了避免这种标注工作的工程量，一些<strong>weakly-supervised</strong> video grouding工作【1】【2】被提出来，他们只提供了video-sentence pairs，没有提供 fine-grained regional annotations。在他们的 video grounding任务中，他们仅仅对名词和代词在 视频的静态帧进行grounding。</p>
</li>
<li><p>但是这种 grounding存在问题，比如sentence: A brown and white dog is lying on the grass and then it stands up. 但是帧中出现了多个狗，而我们给出的要搜索的对象仅仅是一个名词： ‘dog’，没有其他更多的信息，来进行更加具体地定位，那么就有可能定位错误。另外只对一张静态帧进行定位，也无法捕捉到object在时域上的动态变化。</p>
</li>
<li><p>基于上述的分析，本文提出了一个在video grounding上 weakly-supervised 的新任务：<strong>weakly-supervised spatio-temporally grounding sentence in video (WSSTG).</strong>    </p>
</li>
</ul>
<h3 id="Weakly-supervised-spatio-temporally-grounding-sentence-in-video"><a href="#Weakly-supervised-spatio-temporally-grounding-sentence-in-video" class="headerlink" title="Weakly-supervised spatio-temporally grounding sentence in video"></a>Weakly-supervised spatio-temporally grounding sentence in video</h3><ul>
<li>Specifically, given a natural sentence and a video, we aim to localize a spatio-temporal tube (i.e., a sequence of bounding boxes) ,（本文中作者将tube 称作 instance）</li>
<li>yaya: 相比于之前的video-grounding任务，同是 weakly-supervised，但是有两点不同：（1）是句子级别的描述，对要定位的对象的描述更加具体，而不是仅仅是个noun。（2）是要定位出一个 spatial-temporal tube，而不是仅在一张静态帧中定位出一个bbox。</li>
<li>这两点不同同时带来了优势和挑战</li>
<li>（1）细节性的描述可以消除歧义，但是如何捕捉句子中的语义并在video中定位出来是一个难题；（2）相比于在静态帧中定位一个bbox, 而是在video中定位一个tube,更能呈现出一个object在时域上的动态。但是，如何利用和建模tube的时空特性以及它们与句子的复杂关系提出了另一个挑战。</li>
<li>compared with 【2】: different from 【2】，whose text input consists of nouns/pronouns and output is a bounding box in a specific frame, we aim  to ground a natural sentence and output a spatio-temporal tube in the video. </li>
</ul>
<h3 id="Contributions"><a href="#Contributions" class="headerlink" title="Contributions"></a>Contributions</h3><ul>
<li>提出了一个新任务：weakly-supervised spatio-temporally grounding sentence in video</li>
<li>针对该任务提出了一个method：提出了一个Attentive interactor利用 tube(instance) 与 sentence之间的细粒度的关系来计算 匹配度；提出了一个diversity loss来加强 reliable instance-sentence pairs 并惩罚 unreliable ones。</li>
<li>在VID object detection dataset 数据集的基础上，对tube(instance) 增加了description</li>
</ul>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><h4 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h4><ul>
<li>该任务是 给出一个 a natural sentence query <strong>q</strong> and a video <strong>v</strong> 来定位一个spatial-temporal tube，作者也将这个tube 称作 instance。</li>
<li>由于是弱监督，因此仅仅只给出 video-sentence pair，细粒度的regional annotations不给出！</li>
<li>将该任务转为一个 Multiple instance learning problem。给定一个video，首先由instance generator【3】来生成一组instance proposals，然后再根据语义相似性来匹配 natural sentence query 和 instance。  </li>
</ul>
<h4 id="Instance-Extraction"><a href="#Instance-Extraction" class="headerlink" title="Instance Extraction"></a>Instance Extraction</h4><ul>
<li><strong>Instance Generation</strong> ：  先由faster rcnn提取object proposals，假设每帧提取N个proposal ， 然后根据【3】得到N个spatial-temporal tube</li>
<li><strong>Feature Representation</strong> ：I3D-RGB， I3D-Flow， frame-level RoI pooled feature   </li>
</ul>
<h4 id="Attentive-Interactor"><a href="#Attentive-Interactor" class="headerlink" title="Attentive Interactor"></a>Attentive Interactor</h4><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g9io2sodynj30i40hk0v9.jpg" alt="搜狗截图20191202204720.png"></p>
<ul>
<li>（1）分别对 sequential visual features 和 sequential textual features 经过LSTM进行编码，LSTM每个step输出的隐层状态作为新的representation，得到新的visual feature 和 sentence representation</li>
<li>（2）依次以visual feature中的每个隐状态作为查询，以 sentence 所有隐状态作为key 和 value，输入Attention中，则得到了<strong>visual guided sentence feature</strong>。（直观的理解：在给定某一个视觉特征，用attention去分析要关注哪一个word）  </li>
</ul>
<h4 id="Matching-Behavior-Characterization"><a href="#Matching-Behavior-Characterization" class="headerlink" title="Matching Behavior Characterization"></a>Matching Behavior Characterization</h4><ul>
<li>用余弦函数计算 <code>i-th</code> visual feature 和 visual guided sentence features 之间的 匹配度</li>
<li>对所有的step 加和，则得到instance proposal 与 sentence 之间的匹配度</li>
</ul>
<h3 id="Training-Loss"><a href="#Training-Loss" class="headerlink" title="Training Loss"></a>Training Loss</h3><ul>
<li><p>论文对这里介绍的比较详细，参见论文。</p>
</li>
<li><p><strong>ranking loss</strong>： aiming at distinguishing aligned video-sentence pairs from the unaligned ones.  这个损失是希望不匹配的video-sentence之间计算出来的匹配度差一些，比如给网络输入不与该视频对应的句子。</p>
</li>
<li><strong>novel diversity loss</strong> ：to strengthen the matching behaviors between reliable instance-sentence pairs and penalize the unreliable ones from the aligned video-sentence pair.  这个损失主要是希望对一个video，在计算tube 与 sentence之间的匹配度时，希望不同的 tube之间的差异性（diversity）大一些！</li>
</ul>
<h3 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h3><ul>
<li>一个video 给出了N个 tube proposal，当计算完匹配度之后，选取匹配度最大的那个proposal，然后计算与GT之间的 overlap【4】，若overlap 大于一个阈值，则任务预测正确。</li>
</ul>
<h3 id="Yaya-Analysis："><a href="#Yaya-Analysis：" class="headerlink" title="Yaya Analysis："></a>Yaya Analysis：</h3><ul>
<li><p><strong>此类任务可提升的point</strong></p>
</li>
<li><p>更好的 detector来获取 object proposal</p>
</li>
<li><p>更好的算法来获取 tube proposal</p>
</li>
<li><p>设计算法更好滴计算 sentence 与 tube proposal 匹配度！</p>
</li>
<li><p>对 rank loss 给予更多的约束，像此文：提出了一个novel  diversity loss</p>
</li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li>【1】De-An Huang, Shyamal Buch, Lucio Dery, Animesh Garg, Li Fei-Fei, and Juan Carlos Niebles. 2018. <strong>Finding “it”: Weakly-supervised reference-aware visual grounding in instructional videos</strong>. In CVPR. </li>
<li>【2】Luowei Zhou, Nathan Louis, and Jason J Corso. 2018. <strong>Weakly-supervised video object grounding from text by loss weighting and object interaction</strong>. BMVC. </li>
<li>【3】Georgia Gkioxari and Jitendra Malik. 2015. <strong>Finding action tubes</strong>. In CVPR, pages 759–768. </li>
<li>【4】Masataka Yamaguchi, Kuniaki Saito, Yoshitaka Ushiku, and Tatsuya Harada. 2017. <strong>Spatio-temporal person retrieval via natural language queries</strong>. In ICCV. </li>
</ul>
]]></content>
      <categories>
        <category>Visual Grounding</category>
      </categories>
      <tags>
        <tag>Viusal Grounding</tag>
      </tags>
  </entry>
  <entry>
    <title>automatic metric 总结</title>
    <url>/2020/07/23/automatic-metric-%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="automatic-metric-总结"><a href="#automatic-metric-总结" class="headerlink" title="automatic metric 总结"></a>automatic metric 总结</h1><p>转载：<code>肝了1W字！文本生成评价指标的进化与推翻</code></p>
<h2 id="基于词重叠率的方法"><a href="#基于词重叠率的方法" class="headerlink" title="基于词重叠率的方法"></a>基于词重叠率的方法</h2><h2 id="机器翻译-amp-摘要-常用指标"><a href="#机器翻译-amp-摘要-常用指标" class="headerlink" title="机器翻译 &amp; 摘要 常用指标"></a><strong>机器翻译 &amp; 摘要 常用指标</strong></h2><p>基于词重叠率的方法是指基于词汇的级别计算模型的生成文本和人工的参考文本之间的相似性，比较经典的代表有BLEU、METEOR和ROUGE，其中BLEU和METEOR常用于机器翻译任务，ROUGE常用于自动文本摘要。</p>
<h3 id="BLEU"><a href="#BLEU" class="headerlink" title="BLEU"></a><strong>BLEU</strong></h3><p>BLEU （Bilingual Evaluation Understudy，双语评估辅助工具）可以说是所有评价指标的鼻祖，它的核心思想是比较候选译文和参考译文里的 n-gram 的重合程度，重合程度越高就认为译文质量越高。unigram用于衡量单词翻译的准确性，高阶n-gram用于衡量句子翻译的流畅性。实践中，通常是取N=1~4，然后对进行加权平均。<img src="https://mmbiz.qpic.cn/mmbiz_jpg/5fknb41ib9qFEWM9OIZ9BADhs7bP0lrAg4GOn0EZAicLNZY3lw97TdibGCPyA09s0Ms9KZT1CpypiaZ0EwLuG5ZGrA/640?wx_fmt=jpeg" alt="img" style="zoom: 50%;"></p>
<ul>
<li>BLEU 需要计算译文 1-gram，2-gram，…，N-gram 的精确率，一般 N 设置为 4 即可，公式中的 <em>Pn 指 n-gram 的精确率</em>。</li>
<li>Wn 指 n-gram 的权重，一般设为均匀权重，即对于任意 n 都有 Wn = 1/N。</li>
<li>BP 是惩罚因子，如果译文的长度小于最短的参考译文，则 BP 小于 1。</li>
<li>BLEU 的 1-gram 精确率表示译文忠于原文的程度，而其他 n-gram 表示翻译的流畅程度。</li>
</ul>
<p>不过BLEU对词重复和短句有着非常不好的表现，所以改进的BLEU分别使用 <strong>改进的多元精度（n-gram precision）</strong> 和<strong>短句惩罚因子</strong>进行了优化。</p>
<h4 id="1-改进的多元精度（n-gram-precision）"><a href="#1-改进的多元精度（n-gram-precision）" class="headerlink" title="1. 改进的多元精度（n-gram precision）"></a>1. 改进的多元精度（n-gram precision）</h4><p>假设机器翻译的译文C和一个参考翻译S1如下：</p>
<blockquote>
<p>C: a cat is on the table<br>S1: there is a cat on the table</p>
</blockquote>
<p>则可以计算出 1-gram，2-gram，… 的精确率（参考文献里写的是准确率(accuracy),我理解是写错了，此处应该是精确率(precision)）</p>
<p>p1 计算 a cat is on the table 分别都在参考翻译S1中 所以 p1 = 1</p>
<p>p2  (a, cat)在, (cat is) 没在, (is on) 没在, (on the) 在, (the table)在 所以p2 = 3/5</p>
<p>p3  (a cat is)不在, (cat is on)不在, (is on the)不在, (on the table)在 所以 p3 = 1/4</p>
<p>依次类推(上面的在或者不在, 说的都是当前词组有没有在参考翻译中)。直接这样算, 会存在很大的问题. 例如:</p>
<blockquote>
<p>C: there there there there there S1: there is a cat on the table</p>
</blockquote>
<p>这时候机器翻译的结果明显是不正确的，但是其 1-gram 的 Precision 为1，因此 BLEU 一般会使用修正的方法。给定参考译文S1,S2, …,S<em>m</em>，可以计算C里面 n 元组的 Precision，计算公式如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5fknb41ib9qFEWM9OIZ9BADhs7bP0lrAgXmshfK57WrgarjibbBcy4ZdtxHS9Y3EtyDfTzjTNNl2GMxwJAIPmfbA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>针对上面的例子  p1 = 1/5  (因为there在C和S1中都出现了 我们按最少的次数来)</p>
<p><strong style="color:red;">yaya: 从公式中，可以看到，对于m个reference，取max 的方式，进行聚合</strong></p>
<h4 id="2-惩罚因子"><a href="#2-惩罚因子" class="headerlink" title="2. 惩罚因子"></a>2. 惩罚因子</h4><p>上面介绍了 BLEU 计算 n-gram 精确率的方法， 但是仍然存在一些问题，当机器翻译的长度比较短时，BLEU 得分也会比较高，但是这个翻译是会损失很多信息的，例如：</p>
<blockquote>
<p>C: a cat<br>S1: there is a cat on the table</p>
</blockquote>
<p>因此需要在 BLEU 分数乘上惩罚因子</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5fknb41ib9qFEWM9OIZ9BADhs7bP0lrAgaghJVhQZHwspVre1F1yyaAkZj4UnUwUDIurNHI8aPb8vlNP3GWg0Lw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h4 id="3-优点"><a href="#3-优点" class="headerlink" title="3. 优点"></a>3. 优点</h4><ul>
<li>它的易于计算且速度快，特别是与人工翻译模型的输出对比；</li>
<li>它应用范围广泛，这可以让你很轻松将模型与相同任务的基准作对比。</li>
</ul>
<h4 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4. 缺点"></a>4. 缺点</h4><ul>
<li>它不考虑语义，句子结构</li>
<li>不能很好地处理形态丰富的语句（BLEU原文建议大家配备4条翻译参考译文）</li>
<li>BLEU 指标偏向于较短的翻译结果（brevity penalty 没有想象中那么强）</li>
</ul>
<h3 id="ROUGE"><a href="#ROUGE" class="headerlink" title="ROUGE"></a><strong>ROUGE</strong></h3><p>英文全称Recall-Oriented Understudy for Gisting Evaluation，可以看做是BLEU 的改进版，专注于<strong>召回率而非精度</strong>。换句话说，它会查看有多少个参考译句中的 n 元词组出现在了输出之中。</p>
<p>ROUGE大致分为四种（常用的是前两种）：</p>
<ul>
<li>ROUGE-N （将BLEU的精确率优化为召回率）</li>
<li>ROUGE-L （将BLEU的n-gram优化为公共子序列）</li>
<li>ROUGE-W （将ROUGE-L的连续匹配给予更高的奖励）</li>
<li>ROUGE-S  （允许n-gram出现跳词(skip)）</li>
</ul>
<p>ROUGE 用作机器翻译评价指标的初衷是这样的：在 SMT（统计机器翻译）时代，机器翻译效果稀烂，需要同时评价翻译的准确度和流畅度；等到 NMT （神经网络机器翻译）出来以后，神经网络脑补能力极强，翻译出的结果都是通顺的，但是有时候容易瞎翻译。</p>
<p>ROUGE的出现很大程度上是为了解决NMT的漏翻问题（低召回率）。所以 ROUGE 只适合评价 NMT，而不适用于 SMT，因为它不管候选译文流不流畅</p>
<p>这里只介绍 ROUGE_L</p>
<h4 id="ROUGE-L"><a href="#ROUGE-L" class="headerlink" title="ROUGE-L"></a>ROUGE-L</h4><p>ROUGE-L 中的 L 指最长公共子序列 (longest common subsequence, LCS)，ROUGE-L 计算的时候使用了机器译文C和参考译文S的最长公共子序列，计算公式如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5fknb41ib9qFEWM9OIZ9BADhs7bP0lrAgfXBibHaKdNJDXNPgWhZ0L9FKG1b8LuabowzXZiaMhGXB3WQSepe0gYiaw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" style="zoom:33%;"></p>
<p>公式中的 RLCS 表示召回率，而 PLCS 表示精确率，FLCS 就是 ROUGE-L。一般 beta 会设置为很大的数，因此 FLCS 几乎只考虑了 RLCS (即召回率)。注意这里 beta 大，则 F 会更加关注 R，而不是 P，可以看下面的公式。如果 beta 很大，则 PLCS 那一项可以忽略不计。</p>
<p><strong style="color:red;">yaya: 对于含有多个reference的情况，先分别计算 R<sub>LCS</sub> 和 P<sub>LCS</sub>， 再分别取max，得到 max_R, max_P之后，再带入 F<sub>LCS</sub> 中。</strong></p>
<h3 id><a href="#" class="headerlink" title=" "></a> </h3><h3 id="METEOR"><a href="#METEOR" class="headerlink" title="METEOR"></a><strong>METEOR</strong></h3><p>和BLEU不同，METEOR同时考虑了基于整个语料库上的准确率和召回率，而最终得出测度。</p>
<p>METEOR也包括其他指标没有发现一些其他功能，如<strong>同义词匹配</strong>等。METEOR用 WordNet 等知识源扩充了一下同义词集，同时考虑了单词的词形（词干相同的词也认为是部分匹配的，也应该给予一定的奖励，比如说把 likes 翻译成了 like 总比翻译成别的乱七八糟的词要好吧？）</p>
<p><strong>在评价句子流畅性的时候，用了 chunk 的概念</strong>（候选译文和参考译文能够对齐的、空间排列上连续的单词形成一个 chunk，这个对齐算法是一个有点复杂的启发式 beam serach），chunk 的数目越少意味着每个 chunk 的平均长度越长，也就是说候选译文和参考译文的语序越一致。</p>
<p>最后，METEOR计算为对应最佳候选译文和参考译文之间的准确率和召回率的调和平均：</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ggzxernqjrj30pe0hut9u.jpg" style="zoom:33%;"></p>
<h4 id="1-理解"><a href="#1-理解" class="headerlink" title="1. 理解"></a>1. 理解</h4><p>看公式总是挺抽象的，下面我们还是看看来自维基百科的例子吧。计算的最基本单元是句子。算法首先从待评价字符串和参考字符串之间创建一个平面图如下：<img src="https://mmbiz.qpic.cn/mmbiz_jpg/5fknb41ib9qFEWM9OIZ9BADhs7bP0lrAgruCbgRHd3tQITE2N2mQsfJUficbIQav7TBGZA7wvUpnyiaoMlwfYYxrg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>所谓<strong>平面图</strong>，就是1元组之间的映射集。平面图有如下的一些限制：在待评价翻译中的每个1元组必须映射到参考翻译中的1个或0个一元组，然后根据这个定义创建平面图。<strong>如果有两个平面图的映射数量相同，那么选择映射交叉数目较少的那个。</strong> 也就是说，上面左侧平面图会被选择。状态会持续运行，在每个状态下只会向平面图加入那些在前一个状态中尚未匹配的1元组。<em>一旦最终的平面图计算完毕，就开始计算METEOR得分</em>：</p>
<p>1元组精度：</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ggzxernte4j307d04fmx0.jpg" style="zoom:33%;"></p>
<p>其中m是<em>在参考句子中同样存在的，**待评价句子中的一元组的数量</em>。wt是<em>待评价翻译中一元组的数量</em>。</p>
<p>1元组召回率：</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ggzxersvbuj307s04h745.jpg" style="zoom:33%;"></p>
<p>m同上，是参考翻译中一元组的数量。</p>
<p>然后使用调和平均来计算F-mean，且召回的权重是精度的9（上面说的超参数α）倍。</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ggzxerunotj30eo054jre.jpg" style="zoom:33%;"></p>
<p>到目前为止，这个方法只对单个单词的一致性进行了衡量，还没有用到为了评价流畅性的 <strong>chunk</strong> 。chunk 块的定义是在待评价语句和参考语句中毗邻的一元组集合。</p>
<p>在参考和待评价句子中的没有毗连的映射越多，惩罚就越高。为了计算惩罚，1元组被分组成最少可能的块（chunks）。<em>在待评价语句和参考语句之间的毗邻映射越长，块的数量就越少</em>。一个待评价翻译如果和参考翻译相同，那么就只有一个块。惩罚p的计算如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ggzxeruhhij30dj05pwei.jpg" style="zoom:33%;"></p>
<p>（假设参数都已经设置好了）其中c就是块的数量，Um是被映射的一元组的数量。p可以减少F-mean的值。最后：</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ggzxertdasj30fn02xjrb.jpg" style="zoom:33%;"></p>
<h4 id="2-优点"><a href="#2-优点" class="headerlink" title="2. 优点"></a>2. 优点</h4><ul>
<li>该方法基于一元组的精度和召回的调和平均，召回的权重比精度要高一点 ， 与人类判断相关性高</li>
<li><em>引入了外部知识，评价更加友好了。</em></li>
</ul>
<h4 id="3-缺点"><a href="#3-缺点" class="headerlink" title="3. 缺点"></a>3. 缺点</h4><ul>
<li>实现非常复杂，目前只有java版本</li>
<li>α、γ和θ 均为用于评价的默认参数。这些都是对着某个数据集调出来的（让算法的结果和人的主观评价尽可能一致，方法我记得是 grid search）。参数一多听起来就不靠谱（给个眼神体会一下）</li>
<li>需要有外部知识。如果很多词不在wordnet，那其实就没什么意义了</li>
</ul>
<h2 id="image-caption-常用指标"><a href="#image-caption-常用指标" class="headerlink" title="image caption 常用指标"></a><strong>image caption 常用指标</strong></h2><h3 id="CIDEr"><a href="#CIDEr" class="headerlink" title="CIDEr"></a><strong>CIDEr</strong></h3><p>CIDEr 是专门设计出来用于图像标注问题的。这个指标将每个句子都看作“文档”，将其表示成 Term Frequency Inverse Document Frequency（tf-idf）向量的形式，通过对每个n元组进行(TF-IDF) 权重计算，计算参考 caption 与模型生成的 caption 的余弦相似度，来衡量图像标注的一致性的。</p>
<ul>
<li>公式<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5fknb41ib9qFEWM9OIZ9BADhs7bP0lrAgicMuoIiabcIRSiaXj1tLEmgWU5ysVK6ZO4FlTJmfc5S3j3vS7tyzuibkEg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></li>
<li>举例<img src="https://mmbiz.qpic.cn/mmbiz_jpg/5fknb41ib9qFEWM9OIZ9BADhs7bP0lrAg6qxl9VK30SIG0T4LBfVOkbrqRlx4DyBcDK9tRk9vMrwCKfvZYC1ZBw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></li>
</ul>
<h4 id="1-好处"><a href="#1-好处" class="headerlink" title="1. 好处"></a>1. 好处</h4><p>是一种加权的评价指标，他更关注你是否说到了重点，而常见的词权重则没有那么高。在 Kaustav_slides image caption的综述里，也提到这个评价指标和人类的评价相关性更高一些</p>
<h3 id="SPICE"><a href="#SPICE" class="headerlink" title="SPICE"></a><strong>SPICE</strong></h3><p>SPICE 也是专门设计出来用于 image caption 问题的。全称是 Semantic Propositional Image Caption Evaluation。</p>
<p>我们考虑如下图片：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5fknb41ib9qFEWM9OIZ9BADhs7bP0lrAgl3KCxN5scYCpo7RnLCVOWpTmaG8scssC1iaibPwzaNCQNATuOsU7Dq3g/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>你很快会发现尽管生成的句子与参考句极为相似（只有basketball一词不一样），但我们仍认为这是一个糟糕的生成。原因在于考虑了语义的情况下，模型把网球场错误的识别成了篮球场。这个时候BLEU或者其他指标就不能很好的评价生成效果了。</p>
<p>SPICE 使用基于图的语义表示来编码 caption 中的 objects, attributes 和 relationships。它先将待评价 caption 和参考 captions 用 Probabilistic Context-Free Grammar (PCFG) dependency parser parse 成 syntactic dependencies trees，然后用基于规则的方法把 dependency tree 映射成 scene graphs。最后计算待评价的 caption 中 objects, attributes 和 relationships 的 F-score 值。</p>
<p>还是已上图为例，a young girl standing on top of a tennis court (参考句) 可以被SPICE做如下处理：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5fknb41ib9qFEWM9OIZ9BADhs7bP0lrAgRYbeW3NVtIAQDicktJATMl9o5KkyImngjsiaIdnX8SdvwFEibsxA59UyQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img">得到了若干个三元组之后，我们通过下面的公式来计算候选句c和参考句（或集合）S的得分：</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gh01gh6umpj313d0fx408.jpg" style="zoom:33%;"></p>
<p>这里有一个例子：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5fknb41ib9qFEWM9OIZ9BADhs7bP0lrAgwIdbmLATA8Zk5uKHZDAAGkyJlf0J0ZDHPicGUibNgAlUCdrPlT82javA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h4 id="1-好处-1"><a href="#1-好处-1" class="headerlink" title="1. 好处"></a>1. 好处</h4><ul>
<li>对目标，属性，关系有更多的考虑；</li>
<li>和基于n-gram的评价模式相比，有更高的和人类评价的相关性</li>
</ul>
<h4 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h4><ul>
<li>不考虑语法问题</li>
<li>依赖于semantic parsers ， 但是他不总是对的</li>
<li>每个目标，属性，关系的权重都是一样的（一幅画的物体显然有主次之分）</li>
</ul>
]]></content>
      <categories>
        <category>图像描述</category>
        <category>评价指标</category>
      </categories>
      <tags>
        <tag>评价指标</tag>
      </tags>
  </entry>
  <entry>
    <title>coco-detection</title>
    <url>/2019/03/02/coco-detection/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>correlation coefficient</title>
    <url>/2020/08/26/correlation-coefficient/</url>
    <content><![CDATA[<h1 id="correlation-coefficient"><a href="#correlation-coefficient" class="headerlink" title="correlation coefficient"></a>correlation coefficient</h1><ul>
<li>spearman 和 kendall 计算的都是对排序 之间的计算</li>
<li>pearson 计算的是直接的数值，协方差，标准差之间的计算</li>
</ul>
<h3 id="pearson"><a href="#pearson" class="headerlink" title="pearson"></a>pearson</h3><ul>
<li><p>代码实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以下两种方式都可以</span></span><br><span class="line">scipy.stats.pearsonr(array_1, array_2)</span><br><span class="line">np.corrcoef(array_1, array_2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算公式</p>
<p><img src="https://i.loli.net/2020/08/26/lXA4uMz9UkG2vFx.png" alt="image-20200826144001717" style="zoom: 33%;"></p>
</li>
<li><p>适用范围</p>
<p>当两个变量的标准差都不为零时，相关系数才有定义，皮尔逊相关系数适用于：</p>
<p>(1)、两个变量之间是线性关系，都是连续数据。</p>
<p>(2)、两个变量的总体是正态分布，或接近正态的单峰分布。</p>
<p>(3)、两个变量的观测值是成对的，每对观测值之间相互独立。</p>
</li>
<li><p>注意</p>
<p>公式的分母是变量的标准差，这就意味着计算pearson时，变量的标准差不能为0（分母不能为0），也就是说你的两个变量中任何一个的值不能都是相同的。如果没有变化，用pearson是没办法算出这个变量与另一个变量之间是不是有相关性的。</p>
<p>就好比我们想研究人跑步的速度与心脏跳动的相关性，如果你无论跑多快，心跳都不变（即心跳这个变量的标准差为0），或者你心跳忽快忽慢的，却一直保持一个速度在跑（即跑步速度这个变量的标准差为0），那我们都无法通过pearson的计算来判断心跳与跑步速度到底相不相关。</p>
</li>
<li><p>使用Pearson线性相关系数有2个局限：</p>
<ol>
<li>必须假设数据是成对地从正态分布中取得的。</li>
<li>数据至少在逻辑范围内是等距的。</li>
</ol>
</li>
</ul>
<h3 id="spearman"><a href="#spearman" class="headerlink" title="spearman"></a>spearman</h3><p><a href="https://statistics.laerd.com/statistical-guides/spearmans-rank-order-correlation-statistical-guide.php" target="_blank" rel="noopener">https://statistics.laerd.com/statistical-guides/spearmans-rank-order-correlation-statistical-guide.php</a></p>
<ul>
<li><p>代码实现</p>
<ul>
<li><p>对于一般情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result, _ = scipy.stats.spearmanr(array_1, array_2)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>对于离散整数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spearmanr</span><span class="params">(set_1, set_2)</span>:</span></span><br><span class="line"></span><br><span class="line">    ar = np.apply_along_axis(scipy.stats.rankdata, <span class="number">0</span>, set_1)</span><br><span class="line">    br = np.apply_along_axis(scipy.stats.rankdata, <span class="number">0</span>, set_2)</span><br><span class="line">    d = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ar)):</span><br><span class="line">        d.append(ar[i] - br[i])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    d_sq = [i ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> d]</span><br><span class="line">    sum_d_sq = sum(d_sq)</span><br><span class="line">    n_cu_min_n = len(set_1) ** <span class="number">3</span> - len(set_1)</span><br><span class="line">    r = <span class="number">1</span> - ((<span class="number">6.0</span> * sum_d_sq) / n_cu_min_n)</span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>计算公式</p>
<ul>
<li><p>存在 并列排序时：</p>
<p>先排序，对排序值 pair 计算 pearson 系数</p>
</li>
<li><p>不存在并列排序时，</p>
<p>先排序，计算d<sub>i</sub> 再按照下面第一个公式进行计算</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2020/08/26/ON5iLc2kl6EAM1p.png" alt="微信截图_20200826151113"></p>
<ul>
<li><p>另外一种说法</p>
<ul>
<li><p>一般情况：</p>
<p>先排序，对排序值 pair 计算 pearson 系数</p>
</li>
<li><p>对于数值为离散的整数时，</p>
<p>先排序，计算d<sub>i</sub> 再按照吐下的公式进行计算</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/08/26/z3iJWqUxRcBSegV.png" alt="微信截图_20200826151324"></p>
</li>
<li><p>适用范围</p>
<p>spearman 对数据条件的要求没有皮尔逊相关系数严格，只要两个变量的观测值是成对的等级评定资料，或者是由连续变量观测资料转化得到的等级资料，不论两个变量的总体分布形态、样本容量的大小如何，都可以用spearman 来进行研究</p>
</li>
</ul>
<h3 id="kendall"><a href="#kendall" class="headerlink" title="kendall"></a>kendall</h3><ul>
<li><p>代码实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scipy.stats.kendalltau(array_1, array_2)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Kendallta</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    Lens = len(a)</span><br><span class="line"></span><br><span class="line">    ties_onlyin_x = <span class="number">0</span></span><br><span class="line">    ties_onlyin_y = <span class="number">0</span></span><br><span class="line">    con_pair = <span class="number">0</span></span><br><span class="line">    dis_pair = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(Lens - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, Lens):</span><br><span class="line">            test_tying_x = np.sign(a[i] - a[j])</span><br><span class="line">            test_tying_y = np.sign(b[i] - b[j])</span><br><span class="line">            panduan = test_tying_x * test_tying_y</span><br><span class="line">            <span class="keyword">if</span> panduan == <span class="number">1</span>:</span><br><span class="line">                con_pair += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> panduan == <span class="number">-1</span>:</span><br><span class="line">                dis_pair += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> test_tying_y == <span class="number">0</span> <span class="keyword">and</span> test_tying_x != <span class="number">0</span>:</span><br><span class="line">                ties_onlyin_y += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> test_tying_x == <span class="number">0</span> <span class="keyword">and</span> test_tying_y != <span class="number">0</span>:</span><br><span class="line">                ties_onlyin_x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    result = (con_pair - dis_pair) / np.sqrt(</span><br><span class="line">        (con_pair + dis_pair + ties_onlyin_x) * (dis_pair + con_pair + ties_onlyin_y))</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算公式</p>
<p><a href="https://en.wikipedia.org/wiki/Kendall_rank_correlation_coefficient" target="_blank" rel="noopener">Kendall_rank_correlation_coefficient</a></p>
<p>有好几个计算公式</p>
</li>
<li><p>适用范围</p>
<p>kendall与spearman 对数据条件的要求相同，可参见<a href="http://blog.csdn.net/wsywl/archive/2010/09/02/5859751.aspx" target="_blank" rel="noopener">统计相关系数(2)—Spearman Rank(斯皮尔曼等级)相关系数及MATLAB实现</a>中介绍的spearman 对数据条件的要求。</p>
</li>
</ul>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul>
<li>这三种 相关系数，计算 array_1 与 array_2 之间的相关性，若array_1 或者 array_2 中的元素都相同（eg: array_1 = np.array([5,5,5,5,5])） 则会使得输出为NaN.</li>
</ul>
<p>三种方法的适用场合</p>
<h4 id="主要参数methods介绍"><a href="#主要参数methods介绍" class="headerlink" title="主要参数methods介绍:"></a>主要参数methods介绍:</h4><ol>
<li>pearson correlation coefficient（皮尔逊相关性系数）。<br> 常用的相关系数求法，采用协方差cov(X,Y)/标准差的乘积(σX, σY)。<br> 数据要求： 线性数据、连续且符合正态分布；数据间差异不能太大；变量准差不能为0，即两变量中任何一个值不能都是相同。</li>
<li>spearman correlation coefficient（斯皮尔曼秩相关性系数）。<br> 根据原始数据的排序位置进行计算。<br> 数据要求：用于解决称名数据和顺序数据相关的问题，适用于两列变量，而且具有等级变量性质具有线性关系的数据，能够很好处理序列中相同值和异常值。</li>
<li>kendall correlation coefficient（肯德尔相关性系数）。<br> 等级相关系数，适用于两个变量均为有序分类的情况<br> 数据要求：肯德尔相关性系数，它也是一种秩相关系数，不过它所计算的对象是分类变量。</li>
</ol>
<p>所以针对【连续、正态分布、线性】数据，采用pearson相关系数；针对【非线性的、非正态】数据，采用spearman相关系数；针对【分类变量、无序】数据，采用Kendall相关系数。一般来讲，线性数据采用pearson，否则选择spearman，如果是分类的则用kendall。</p>
<p>作者：王叽叽的小心情<br>链接：<a href="https://www.jianshu.com/p/f9304da68d98" target="_blank" rel="noopener">https://www.jianshu.com/p/f9304da68d98</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="相关系数和P-value-值"><a href="#相关系数和P-value-值" class="headerlink" title="相关系数和P-value 值"></a>相关系数和P-value 值</h3><p>看两者是否算相关要看两方面</p>
<p>显著水平以及相关系数</p>
<p>（1）显著水平,就是P值,这是首要的,因为如果不显著,相关系数再高也没用,可能只是因为偶然因素引起的,那么多少才算显著,一般p值小于0.05就是显著了；如果小于0.01就更显著；例如p值=0.001,就是很高的显著水平了,只要显著,就可以下结论说：拒绝原假设无关,两组数据显著相关也说两者间确实有明显关系.通常需要p值小于0.1,最好小于0.05甚至0.01,才可得出结论：两组数据有明显关系,如果p=0.5,远大于0.1,只能说明相关程度不明显甚至不相关.起码不是线性相关.</p>
<p>（2）相关系数,也就是pearson spearman等,通常也称为R值,在确认上面指标显著情况下,再来看这个指标,一般相关系数越高表明两者间关系越密切.R&gt;0 代表连个变量正相关,即一个变大另一个随之变大</p>
<h3 id="需要的数据量"><a href="#需要的数据量" class="headerlink" title="需要的数据量"></a>需要的数据量</h3><p><a href="https://bbs.pinggu.org/thread-3240378-1-1.html" target="_blank" rel="noopener">https://bbs.pinggu.org/thread-3240378-1-1.html</a></p>
]]></content>
      <tags>
        <tag>评价指标</tag>
      </tags>
  </entry>
  <entry>
    <title>faster r-cnn 解读</title>
    <url>/2019/03/24/faster-r-cnn-%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>来自<a href="https://mp.weixin.qq.com/s/M_i38L2brq69BYzmaPeJ9w" target="_blank" rel="noopener">机器之心</a><br>可能机器之心的那个链接无法转到，<a href="http://tech.ifeng.com/a/20180223/44884976_0.shtml" target="_blank" rel="noopener">看这个</a><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e0ltm2y7j30u0083wev.jpg"><br>by yaya:<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e10a6tguj31fj0mw0vw.jpg"></p>
<h2 id="RPN"><a href="#RPN" class="headerlink" title="RPN"></a>RPN</h2><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e0p68j95j30t80gaaar.jpg" style="zoom:60%"></p>
<p>anchor: 定义anchor的长: scale=[4,8,16], 长宽比: ratio=[0.5, 1, 1.5, 2]，则在each position of conv feature 将会有k=len(scale)×len(ratio)=12个anchor</p>
<p>(1)对于分类层，我们对每个锚点输出两个预测值：它是背景（不是目标）的分数，和它是前景（实际的目标）的分数.&lt;/br&gt;<br>则经过该1×1的卷积层，输出的shape=N×2k×H×W  &lt;/br&gt;</p>
<p>(2)对于回归或边框调整层，我们输出四个预测值(偏移值)：<font color="#0099ff" size="5" face="黑体">Δxcenter、Δycenter、Δwidth、Δheight</font>，我们将会把这些值用到锚点中来得到最终的建议：(x1, y1, x2, y2)分别为左下角和右上角的坐标，即area=(x2-x1)*(y2-y1).&lt;/br&gt;<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e0p66yxyj312w066t91.jpg"></p>
<p>(3) 补充，<font color="#0099ff" size="5" face="黑体">RoI Pooling</font>  得到 pooled feats，输入的是base feats, 得到的pred proposals 以及 <font color="#0099ff" size="5" face="黑体">1/scale</font><br>因为pred proposals得到的坐标是在<del>原始的image上的</del> 输入到网络中的image，而当前的base feats 是相对于原图有尺度变化的，为了对应.</p>
<h2 id="R-CNN"><a href="#R-CNN" class="headerlink" title="R-CNN"></a>R-CNN</h2><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e0p6ekybj30u00c175l.jpg"></p>
<p>有两个不同的目标：&lt;/br&gt;<br>(1) 将建议分到一个类中，加上一个背景类（用于删除不好的建议）。&lt;/br&gt;<br>(2) 根据预测的类别更好地调整建议的边框。&lt;/br&gt;<br>在最初的 Faster R-CNN 论文中，R-CNN 对每个建议采用特征图，将它平坦化并使用两个大小为 4096 的有 ReLU 激活函数的全连接层。然后，它对每个不同的目标使用两种不同的全连接层：&lt;/br&gt;<br>一个有 N+1 个单元的全连接层，其中 N 是类的总数，另外一个是背景类。&lt;/br&gt;<br>一个有 4N 个单元的全连接层。我们希望有一个回归预测，因此对 N 个类别中的每一个可能的类别，我们都需要 <font color="#0099ff" size="5" face="黑体">Δxcenter、Δycenter、Δwidth、Δheight</font>。&lt;/br&gt;<br>训练和目标&lt;/br&gt;<br>R-CNN 的目标与 RPN 的目标的计算方法几乎相同，但是考虑的是不同的可能类别。我们采用建议和真实边框，并计算它们之间的 IoU。&lt;/br&gt;</p>
<p>那些有任何真实边框的建议，只要其 IoU 大于 0.5，都被分配给那个真实数据。那些 IoU 在 0.1 和 0.5 之间的被标记为背景。与我们在为 RPN 分配目标时相反的是，我们忽略了没有任何交集的建议。这是因为在这个阶段，我们假设已经有好的建议并且我们对解决更困难的情况更有兴趣。当然，这些所有的值都是可以为了更好的拟合你想找的目标类型而做调整的超参数。&lt;/br&gt;</p>
<p>边框回归的目标是计算建议和与其对应的真实框之间的偏移量，仅针对那些基于 IoU 阈值分配了类别的建议。&lt;/br&gt;</p>
<p>我们随机抽样了一个尺寸为 64 的 balanced mini batch，其中我们有高达 25% 的前景建议（有类别）和 75% 的背景。&lt;/br&gt;</p>
<p>按照我们对 RPN 损失所做的相同处理方式，现在的分类损失是一个多类别的交叉熵损失，使用所有选定的建议和用于与真实框匹配的 25% 建议的 Smooth L1 loss。由于 R-CNN 边框回归的全连接网络的输出对于每个类都有一个预测，所以当我们得到这种损失时必须小心。在计算损失时，我们只需要考虑正确的类。&lt;/br&gt;<br>这里若假定类别可知，则每个类都有预测，若类别不可知，则仅有一个预测即可，代码如下：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e0p66uafj30nq03vt8o.jpg"></p>
]]></content>
      <categories>
        <category>目标检测</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>目标检测</tag>
      </tags>
  </entry>
  <entry>
    <title>faster_rcnn various box head</title>
    <url>/2019/07/22/faster-rcnn-various-box-head/</url>
    <content><![CDATA[<h4 id="Ground-video-description"><a href="#Ground-video-description" class="headerlink" title="Ground video description"></a>Ground video description</h4><ul>
<li>在阅读这篇论文的时候，由于作者提取了objects，说是提取的fc6的特征，但是不太懂是哪里，在issue中，他说是借鉴这里的代码，于是乎，我就来看了看<a href="https://github.com/facebookresearch/Detectron/blob/8170b25b425967f8f1c7d715bea3c5b8d9536cd8/detectron/modeling/fast_rcnn_heads.py" target="_blank" rel="noopener">box_head</a>，哈哈哈哈哈哈 </li>
<li>fc6 是 box_head里边的，box_head就是 类似于faster_rcnn中的_head_to_tail</li>
</ul>
<h4 id="那么box-head-是干嘛的？"><a href="#那么box-head-是干嘛的？" class="headerlink" title="那么box_head 是干嘛的？"></a>那么box_head 是干嘛的？</h4><ul>
<li>由于经过roi_pooling 之后得到的是 7*7的一个pooled_feats，还要 ==再进行池化或者拍平，或者再进行全连接层等== ，以便于后边的预测，分类任务。</li>
</ul>
<ul>
<li><p>faster_rcnn 中的box_head就是 resnet layer4</p>
</li>
<li><p>mmdetection 中的 faster_rcnn 现将7*7  排成49 ，再送入两个全连接层，可以将这两个全连接层命名为fc6, fc7.   完美!！!！</p>
</li>
<li><p>这里展示了各种各样的 box_head</p>
</li>
</ul>
]]></content>
      <categories>
        <category>目标检测</category>
      </categories>
      <tags>
        <tag>目标检测</tag>
      </tags>
  </entry>
  <entry>
    <title>GCN_LSTM  vs  SGAE</title>
    <url>/2019/07/30/gcn-on-captioning/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>(h-RNN)Video Paragraph Captioning Using Hierarchical Recurrent Neural Networks</title>
    <url>/2019/02/23/h-RNN-Video-Paragraph-Captioning-Using-Hierarchical-Recurrent-Neural-Networks/</url>
    <content><![CDATA[<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><ul>
<li>这篇文章主要针对于一个video 划分为多个interval，并分别对其进行caption这样的数据集。其中段落生成器的作用：可以捕捉句子之间的相互依赖关系，同时段落生成器的输出作为句子生成器的输入，可以使得<strong>下一个句子的生成是建立在当前句子的语境下生成的</strong>。</li>
<li>另外对于MSVD这种一个video直接由一个sentence来描述的数据集，段落生成器不起作用，只是在<strong>decoder的结构相较于其他的model有不同之处</strong>：video feature 不输入decoder 的 RNN，而是与RNN的hidden state 级联后输入Multimodal层，Multimodal( concatenate( hidden state，video feature ) )。</li>
</ul>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>提出了一个方法：<strong>利用分层RNN开解决视频描述</strong>。我们的分层框架包含一个句子生成器和一个段落生成器。<strong><em>句子生成器</em></strong>产生一个简短的句子，这个句子可以描述一个特定的短视频间隔。它利用时间和空间的注意力机制，有选择地将注意力集中在视觉元素上。<strong><em>段落生成器</em></strong>通过将句子生成器产生的句子嵌入与段落历史结合起来作为输入来捕获句子间的依赖关系，并段落生成器的parahraph state 将作为输出语句生成器的新初始状态，然后句子生成器再生成下一个句子，~ 循环</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul>
<li><strong>对当前方法的总结：</strong><br>当给出了从视频帧中提取的深度卷积特征序列(例如vggnet 和c3d)，则视频的特征可以用以下几种方法获取：<br>（1）平均池化[1, 2]<br>（2）加权平均池化（attention 机制）[3]<br>（3）RNN encoder 的最后一个输出[4, 5, 6]<br>当前基于序列学习的视频描述方法，只专注于为一个简短的视频剪辑生成一个句子。到目前为止，深层次学习方法还没有尝试为长视频生成多个句子或段落的问题。使用平均池化得到 video feature 的方法，只适用于 short video clips where there is only one major event，随后有了 recurrent encoder 和 attention model。<br>我们的方法也采用了attention 机制。但是我们的框架和他们的框架之间存在两个不同之处，1. 解释<strong>空间注意力</strong>：即对每个frames 提取object proposals 然后基于注意力机制对proposal features of one frames 进行加权求和来得到frames features。这对于数据集中 object 非常小且难定位的情况有很大的帮助。另外，也解释一下<strong>时域注意力</strong>：是指对features of frames 进行加权求和，从而得到 video feature。 <strong>本文的注意力机制</strong>：提取M帧，每帧K个object, 则对这M*K个 object 进行基于attention 系数的加权求和。2. 在加权视频特征和注意权重之后，我们不会在加权特征的基础上限制递归层的隐藏状态。 </li>
<li><strong>Motivation</strong><br>大多数视频描述的不仅仅是一个事件。只用一个简短的句子来描述一个语义丰富的视频通常会产生信息不多甚至无聊的结果。例如，一个video 应该描述成<strong>那个人把土豆切成片，把洋葱切成块，把洋葱和土豆放进锅里</strong>，但是只产生one sentence的方法可能会说<strong>这个人在做饭</strong>。</li>
<li><strong>Idea</strong><br>我们想要利用句子之间的时域依赖性，这样，在生成段落时，句子就不会独立地生成。相反，一个句子的生成可能会受到前几句所提供的语义上下文的影响。<br>我们的分层RNN结构包括两个生成器，一个句子生成器和一个段落生成器，这两个生成器都使用RNN layers<br>据我们所知，这是分层RNN在视频字幕任务中的首次应用。  </li>
</ul>
<h2 id="Hierarchical-RNN-for-Video-Captioning"><a href="#Hierarchical-RNN-for-Video-Captioning" class="headerlink" title="Hierarchical RNN for Video Captioning"></a>Hierarchical RNN for Video Captioning</h2><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0gmi1zayjj314o0h2n1f.jpg"><br><strong><em>designed by yaya:</em></strong><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0k7r1p5ygj316f0jyq47.jpg"><br>我们的方法：在句子生成器之上堆叠了一个段落生成器<br><strong>句子生成器</strong>：1) RNN 用来语言建模 2) 多模态层对多源信息进行聚合 3) 注意力模型</p>
<ul>
<li>RNN1：word embedding 作为RNN的输入，并更新 hidden state </li>
<li>Attention layer: RNN 的hidden state 作为attention layer 的输入，来计算weight:<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0gohii8woj30xx02saab.jpg" style="zoom:30%"><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0gom9zybsj30kg04mwes.jpg" style="zoom:45%"><br>假设视频中有M帧，每帧有K个objects，则features：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0go2kemkqj30bq01pt8m.jpg" style="zoom:50%"><br>若计算出了一组权重:<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0go382u2qj309m0250so.jpg" style="zoom:50%"><br>则 video feature：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0go5n8g7dj30if036mx8.jpg" style="zoom:30%"><br>得到的video feature是一个特征通道，完整的模型是两个特征通道，一个由 object appearance 生成，另一个由action 生成</li>
<li>Multimodal<br>输入：RNN 的hidden state <strong>concate</strong> 2个Attention 的输出（两个特征通道Ua  C3D，action feature；Uo aggregate object appearance）。既有语言，又有视觉，因此成为多模态。<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0gpaasqgmj30sb022dg0.jpg" style="zoom:50%"></li>
<li>Hidden layer<br>-输出维度512 与 word embdeding 的维度一致</li>
<li>Softmax layer<br>输出维度与vocabulary size 一致</li>
<li>Maxid layer<br>Maxid layer 在softmax layer 的输出中挑选了最大值所在的索引，该索引将会被作为predicted word 的id(对应到vocabulary 的 索引)</li>
<li>预测的单词将会作为句子生成器的下一个输入（test）；下一个输入单词总是由带注释的句子（ground truth/ reference）提供。</li>
</ul>
<p><strong>段落生成器</strong> : 另外一个RNN，来建模句子之间的相互依赖。输入：1.句子生成器的输出， 2. paragraph history  输出：该输出作为句子生成器的初始状态<br>使用的RNN为GRU</p>
<ul>
<li>Word Embedding<br>1) 对sentences中的所有单词的embedding 取平均，得到一个压缩embedding vector<br>2) 同时也接受RNN1 的最后一个hidden state 作为 压缩表达<br>将上面两个压缩表达concatenated </li>
<li>Sentences Embedding<br>将上面concatenated 的特征输入该层，得到512维度的输出</li>
<li>RNN2</li>
<li>Paragraph State layer<br>输入：结合RNN2的hidden state 和 sentence embedding<br>输出：作为RNN1下一个句子的初始状态，为句子生成器提供了段落历史是有必要的，以便在上下文语境中中生成下一句。<br>它实质上为句子生成器提供了段落历史，以便在上下文中生成下一句。</li>
</ul>
<h2 id="Training-and-Generation"><a href="#Training-and-Generation" class="headerlink" title="Training and Generation"></a>Training and Generation</h2><p><strong>整个网络的循环过程</strong></p>
<ul>
<li>当RNN1在每一时间步骤中不断更新其hidden state，RNN2只在处理完整句子时才更新其hidden state。</li>
<li>RNN1 由beam search 得到 J 个sequence cost 最低的句子，挑选出1个最低的，然后送入RNN2。RNN2又输出隐层状态，最为RNN1下一个句子的初始隐层状态。如此循环，直至， when the sentence received by the paragraph generator is the EOP (end-of-paragraph) which consists of only the BOS and the EOS。</li>
</ul>
<h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p><strong>数据集</strong><br>two benchmark datasets: YouTubeClips and TACoS-MultiLevel<br>YouTubeClips： 虽然每个video 有多个sentences进行描述，但是sentences是对这个video的整体描述，而不是分别对video进行分段描述。因此这个数据集作为我们方法的特例，paragraph length N=1.<br><strong>Encoder</strong></p>
<ul>
<li>由于YouTubeClips数据集中的object 十分显著，因此不进行提取object的操作，只对frame 提取特征，这样attention 只包括temporal attention ，而不包括 spatial attention。</li>
<li>对于TACoS-MultiLevel 数据集，首先使用光流大体的提取boundinig box，然后沿着bounding box 的边，提取220*220的image patches，保证相邻两个box 重合度为50%。使用VGG模型对每个patch提取特征，并使用attention的权重，对这些patches进行加权求和。此时，attention同时包括temporal 和 spatial。</li>
<li>C3D 提取 action/motion feature of video<br>C3D 模型：输入frames of video ，每16帧输出一个固定长度的特征向量。然后采用attention机制对C3D特征进行polling（加权求和）<br><strong>实验结果对比分析</strong></li>
<li>YouTubeClips<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0hdv8rde9j30i7099jtg.jpg"><br>相比于<strong>LSTM-E[2]</strong>（同样同时利用了VGG和C3D特征），我们的模型效果更好。<br>相比于<strong>SA[3]</strong>（同样利用了temporal attention）我们的方法更好，原因：RNN的输入不包括视频特征，换句话说， hidden state的更新不建立在video feature的基础上。video feature直接的输入到multimodal layer。</li>
<li>TACoS-MultiLevel<br>这里不做分析（可以自行参考论文）</li>
</ul>
<h2 id="Discussions-and-Limitations"><a href="#Discussions-and-Limitations" class="headerlink" title="Discussions and Limitations"></a>Discussions and Limitations</h2><ol>
<li>目前我们使用的目标检测方法很难处理small object，造成在生成句子时，极容易混淆，比如应该是orange ，却生成了mango</li>
<li>句子信息通过段落循环层单向流动，从段落开始到结尾，但也不是以相反的方式。如果第一个句子中含有错误信息，则会导致错误信息依次传递，目前使用双向RNN来生成句子，仍然是一个开放性的问题（yaya: sorry , i don’t kow what’s mean，可能是目前还不知道使用BiRNN来生成句子的效果是否好于单向RNN）。</li>
<li>与其他大多数图像/视频字幕方法一样，我们的方法存在一个已知的问题，即训练所使用的目标函数与生成方法所使用的目标函数之间存在差异。训练过程给定来自groundtruth的先前单词来预测下一个单词，而生成过程则对先前由其自身生成的单词进行预测。这个问题在我们的分层框架中更加放大，因为在训练时，段落生成器输入的是groundtruth，但是在测试阶段，输入的是句子生成器生成的句子。潜在的解决办法：</li>
</ol>
<ul>
<li>Scheduled Sampling<br>在训练过程中增加Scheduled Sampling，即随机的选择words of groundtruth或者由model生成的单词。</li>
<li>在训练的过程中直接优化metric(BLEU， CIDER, etc)</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <strong><em>Translating videos to natural language using deep recurrent neural networks</em></strong>. NACACL, 2015<br>[2] <strong><em>Jointly modeling embedding and translation to bridge video and language</em></strong>. CoRR,  2015<br>[3] <strong><em>Describing videos by exploiting temporal structure</em></strong>. ICCV, 2015<br>[4] <strong><em>Long-term recurrent convolutional networks for visual recognition and description</em></strong>. CVPR, 2015<br>[5] <strong><em>Sequence to sequence - video to text</em></strong>. ICCV, 2015<br>[6]  <strong><em>A multi-scale multiple instance video description network</em></strong>. CoRR, 2015</p>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>glob 之 **</title>
    <url>/2019/08/13/glob-%E4%B9%8B/</url>
    <content><![CDATA[<ul>
<li>该篇主要介绍glob的一些使用小技巧</li>
</ul>
<h3 id="想要获得某个文件目录下所有-指定文件格式-的所有文件"><a href="#想要获得某个文件目录下所有-指定文件格式-的所有文件" class="headerlink" title="想要获得某个文件目录下所有 指定文件格式 的所有文件"></a>想要获得某个文件目录下所有 <strong><em>指定文件格式</em></strong> 的所有文件</h3><ul>
<li><p>假设有一个文件环境如下图所示</p>
<p><img src="https://i.loli.net/2019/08/14/sjTANPfDuV6cord.png" alt="搜狗截图20190814100532.png"></p>
</li>
</ul>
<ul>
<li><p>比如想要获得<code>/userhome/dataset/MSVD/YouTubeClips/YouTubeClips</code> 下 <code>.avi</code>格式的所有文件</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">path</span> = <span class="string">'/userhome/dataset/MSVD/YouTubeClips/YouTubeClips/'</span></span><br><span class="line">glob.glob(<span class="built_in">path</span> + <span class="string">'*.avi'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>想要获得某目录下的所有子目录中的所有指定文件格式的所有文件</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">path</span> = <span class="string">'/userhome/dataset/MSVD/YouTubeClips/'</span></span><br><span class="line">glob.glob(<span class="built_in">path</span> + <span class="string">'**/'</span> + <span class="string">'*.avi'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">path</span> = <span class="string">'/userhome/dataset/MSVD/'</span></span><br><span class="line">glob.glob(<span class="built_in">path</span> + <span class="string">'**/'</span> + <span class="string">'**/'</span> + <span class="string">'*.avi'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/07/11/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>glob.glob vs os.listdir</title>
    <url>/2019/04/05/glob-glob-vs-os-listdir/</url>
    <content><![CDATA[<ul>
<li>现在想要得到某个文件夹下的一些图片，并按照顺序排列，如下图所示：  </li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1rl9d9xq9j30ia0cbjri.jpg">  </p>
<ul>
<li>第一种方法：（得到的frames_list是不包含路径的）<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frames_list = sorted(os.listdir(video_path))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1rlb8uq8aj309h0a8q2z.jpg"></p>
<ul>
<li>第二种方法：（得到的frames_list包含路径的）<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frames_list = sorted(glob.glob(os.path.join(video_path, <span class="string">'*.jpg'</span>)))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1rlbroiqmj30nt0b40u9.jpg"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>os.listdir 仅可以得到对当前路径下文件名称，但是不包含路径信息<br>glob.glob 可以得到对当前路径下文件名称，并包含路径信息</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>java</title>
    <url>/2019/03/26/java%20%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<h2 id="java-的编译与执行"><a href="#java-的编译与执行" class="headerlink" title="java 的编译与执行"></a>java 的编译与执行</h2><ol>
<li><p>用文本编辑器新建一个yumhtest.java文件，在其中输入以下代码并保存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">yumhtest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译：在shell终端执行命令 <strong>javac yumhtest.java</strong></p>
</li>
<li><p>运行：在shell终端执行命令 <strong>java yumhtest</strong><br>当shell下出现“hello world !”字样</p>
</li>
</ol>
<p>注意事项：类名应和文件名相同。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java 的编译与执行</title>
    <url>/2019/03/26/java/</url>
    <content><![CDATA[<h2 id="java-的编译与执行"><a href="#java-的编译与执行" class="headerlink" title="java 的编译与执行"></a>java 的编译与执行</h2><ol>
<li><p>用文本编辑器新建一个yumhtest.java文件，在其中输入以下代码并保存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">yumhtest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译：在shell终端执行命令 <strong>javac yumhtest.java</strong></p>
</li>
<li><p>运行：在shell终端执行命令 <strong>java yumhtest</strong><br>当shell下出现“hello world !”字样</p>
</li>
</ol>
<p>注意事项：类名应和文件名相同。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 文件名中有空格、括号 时如何操作</title>
    <url>/2019/08/14/linux-%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%AD%E6%9C%89%E7%A9%BA%E6%A0%BC%E3%80%81%E6%8B%AC%E5%8F%B7-%E6%97%B6%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="如何处理-cd-cp"><a href="#如何处理-cd-cp" class="headerlink" title="如何处理 cd cp"></a>如何处理 <code>cd</code> <code>cp</code></h3><ul>
<li><p>将文件名用<strong>双引号</strong> 包起来</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">cmd = 'cp -r <span class="string">"&#123;&#125;"</span> <span class="string">"&#123;&#125;"</span>'.format(source_path, target_path)</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-查看cpu状态</title>
    <url>/2019/03/13/linux-%E6%9F%A5%E7%9C%8Bcpu%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<ul>
<li>转载 “<a href="https://www.tianmaying.com/tutorial/cpu-top" target="_blank" rel="noopener">https://www.tianmaying.com/tutorial/cpu-top</a>“<br><code>top</code>命令是<code>Linux</code>下常用的性能分析工具，但本质上它提供了实时的对系统处理器的状态监视</li>
</ul>
<p>在命令行中输入<code>top</code>将输出一下信息：</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">top - 23:16:12 up  7:40, <span class="number"> 1 </span>user,  load average: 0.97, 0.98, 1.01</span><br><span class="line">Tasks:<span class="number"> 440 </span>total,  <span class="number"> 2 </span>running,<span class="number"> 438 </span>sleeping,  <span class="number"> 0 </span>stopped,  <span class="number"> 0 </span>zombie</span><br><span class="line">%Cpu(s):  1.3 us,  1.4 sy,  0.0 ni, 96.9 id,  0.0 wa,  0.0 hi,  0.4 si,  0.0 st</span><br><span class="line">KiB Mem : 13183891+total, 12378241+free, <span class="number"> 3884532 </span>used, <span class="number"> 4171956 </span>buff/cache</span><br><span class="line">KiB Swap:       <span class="number"> 0 </span>total,       <span class="number"> 0 </span>free,       <span class="number"> 0 </span>used. 12719112+avail Mem </span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                                               </span><br><span class="line">11746 jenkins  <span class="number"> 20 </span> <span class="number"> 0 </span><span class="number"> 159972 </span> <span class="number"> 4760 </span> <span class="number"> 1600 </span>R  99.7  0.0 362:41.65 root/2                                                                                                                </span><br><span class="line">  <span class="number"> 42 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   4.3  0.0  14:46.50 rcu_sched                                                                                                             </span><br><span class="line">  <span class="number"> 68 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   2.6  0.0   0:55.10 rcuos/25                                                                                                              </span><br><span class="line">11414 jenkins  <span class="number"> 20 </span> <span class="number"> 0 </span>42.134g 1.652g <span class="number"> 24516 </span>S   0.7  1.3   2:37.54 java                                                                                                                  </span><br><span class="line">  <span class="number"> 49 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.3  0.0   0:32.35 rcuos/6                                                                                                               </span><br><span class="line"><span class="number"> 6818 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.3  0.0   0:34.33 kworker/0:1                                                                                                           </span><br><span class="line">14702 root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.3  0.0   0:00.26 kworker/2:0                                                                                                           </span><br><span class="line">15491 txq      <span class="number"> 20 </span> <span class="number"> 0 </span><span class="number"> 158044 </span> <span class="number"> 2616 </span> <span class="number"> 1552 </span>R   0.3  0.0   0:00.13 top                                                                                                                   </span><br><span class="line">   <span class="number"> 1 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span> <span class="number"> 45892 </span> <span class="number"> 8580 </span> <span class="number"> 3908 </span>S   0.0  0.0   0:13.06 systemd                                                                                                               </span><br><span class="line">   <span class="number"> 2 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.06 kthreadd</span><br></pre></td></tr></table></figure>
<p>前五行是当前整个系统资源的统计信息。</p>
<p>第一行是任务队列，包括当前时间，系统运行的总时间，系统用户登陆的数量，以及1分钟，5分钟，15分钟系统的负载情况。</p>
<p>第二行是<code>Tasks</code>信息，显示当前系统总共的进程数为440，运行状态的进程有两个，438个处于休眠状态，0个停止，0个僵尸进程。</p>
<p>第三行是<code>CPU</code>信息，很多人可能会忽略这些信息，我之前就是，所以详细说一下。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">%<span class="selector-tag">Cpu</span>(<span class="selector-tag">s</span>):  1<span class="selector-class">.3</span> <span class="selector-tag">us</span>,  1<span class="selector-class">.4</span> <span class="selector-tag">sy</span>,  0<span class="selector-class">.0</span> <span class="selector-tag">ni</span>, 96<span class="selector-class">.9</span> <span class="selector-tag">id</span>,  0<span class="selector-class">.0</span> <span class="selector-tag">wa</span>,  0<span class="selector-class">.0</span> <span class="selector-tag">hi</span>,  0<span class="selector-class">.4</span> <span class="selector-tag">si</span>,  0<span class="selector-class">.0</span> <span class="selector-tag">st</span></span><br></pre></td></tr></table></figure>
<p><code>us</code> user CPU time ——用户空间占用<code>CPU</code>百分比</p>
<p><code>sy</code> system CPU time——内核空间占用<code>CPU</code>百分比</p>
<p><code>ni</code> nice CPU time——用户进程空间内改变过优先级的进程占用<code>CPU</code>百分比</p>
<p><code>id</code> idle——空闲<code>CPU</code>百分比</p>
<p><code>wa</code> iowait—— 等待输入输出的<code>CPU</code>时间百分比</p>
<p><code>hi</code> hardware irq——硬件中断</p>
<p><code>si</code> software irq——软件中断</p>
<p><code>st</code> steal time——实时</p>
<p>具体对应到第三行的详细信息，大家自己对照一下就行，或者在你命令行中试一下。</p>
<p>第四行<code>Memory</code>的状态信息，总共13183891+内存，空闲12378241+，使用3884532，缓存为4171956</p>
<p>第五行<code>Swap</code>交换分区信息，总共0，空闲0，使用0，缓存交换区总量12719112+</p>
<p>第六行是各个进程监视的项目列</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">PID   <span class="built_in"> USER </span>     PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+   COMMAND</span><br><span class="line">PID` — 进程`id</span><br></pre></td></tr></table></figure>
<p><code>USER</code> — 进程所有者</p>
<p><code>PR</code> — 进程优先级</p>
<p><code>NI</code> — nice值。负值表示高优先级，正值表示低优先级</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">VIRT` — 进程使用的虚拟内存总量。`VIRT=SWAP+RES</span><br><span class="line">RES` — 进程使用的、未被换出的物理内存大小。`RES=CODE+DATA</span><br></pre></td></tr></table></figure>
<p><code>SHR</code> — 共享内存大小</p>
<p><code>S</code>— 进程状态。<code>D</code>=不可中断的睡眠状态 <code>R</code>=运行 <code>S</code>=睡眠 <code>T</code>=跟踪/停止 <code>Z</code>=僵尸进程</p>
<p><code>%CPU</code> — 上次更新到现在的<code>CPU</code>时间占用百分比</p>
<p><code>%MEM</code> — 进程使用的物理内存百分比</p>
<p><code>TIME+</code> — 进程使用的<code>CPU</code>时间总计</p>
<p><code>COMMAND</code> — 进程名称（命令名/命令行）</p>
<p>对应的每个进程的信息，大家可以自己看一下。</p>
<p>如果你在命令行下再输入<code>1</code>，输出如下：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">top - <span class="number">23</span>:<span class="number">16</span>:<span class="number">12</span> <span class="keyword">up</span>  <span class="number">7</span>:<span class="number">40</span>,  <span class="number">1</span> user,  load average: <span class="number">0.97</span>, <span class="number">0.98</span>, <span class="number">1.01</span></span><br><span class="line">Task<span class="variable">s:</span> <span class="number">440</span> total,   <span class="number">2</span> running, <span class="number">438</span> sleeping,   <span class="number">0</span> stopped,   <span class="number">0</span> zombie</span><br><span class="line">%Cpu0  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu1  :  <span class="number">0.0</span> us,  <span class="number">0.3</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni, <span class="number">99.7</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu2  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu3  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu4  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu5  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu6  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu7  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu8  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu9  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu10 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu11 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu12 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu13 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu14 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu15 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu16 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu17 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu18 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu19 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu20 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu21 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu22 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu23 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu24 : <span class="number">44.2</span> us, <span class="number">43.9</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,  <span class="number">0.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>, <span class="number">12.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu25 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu26 :  <span class="number">0.3</span> us,  <span class="number">0.3</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni, <span class="number">99.3</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu27 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu28 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu29 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu30 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu31 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">KiB Mem : <span class="number">13183891</span>+total, <span class="number">12377862</span>+free,  <span class="number">3887628</span> used,  <span class="number">4172660</span> buff/cache</span><br><span class="line">KiB Swap:        <span class="number">0</span> total,        <span class="number">0</span> free,        <span class="number">0</span> used. <span class="number">12718814</span>+avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                                               </span><br><span class="line"><span class="number">11746</span> jenkins   <span class="number">20</span>   <span class="number">0</span>  <span class="number">159972</span>   <span class="number">4760</span>   <span class="number">1600</span> R <span class="number">100.0</span>  <span class="number">0.0</span> <span class="number">393</span>:<span class="number">16.94</span> root/<span class="number">2</span>                                                                                                                </span><br><span class="line">   <span class="number">42</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">2.7</span>  <span class="number">0.0</span>  <span class="number">15</span>:<span class="number">59.27</span> rcu_sched                                                                                                             </span><br><span class="line">   <span class="number">67</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">1.3</span>  <span class="number">0.0</span>   <span class="number">1</span>:<span class="number">03.60</span> rcuos/<span class="number">24</span></span><br></pre></td></tr></table></figure>
<p>输入<code>1</code>可以查看每个逻辑<code>CPU</code>的情况，如上总共有32个逻辑<code>CPU</code>；</p>
<p>其他命令：</p>
<p>输入<code>b</code>，显示高亮，<code>shift+&gt;</code>和<code>shift+&lt;</code>可以左右切换</p>
<p>输入<code>x</code>也是显示高亮，但没有<code>b</code>那么明显，同理<code>shift+&gt;</code>和<code>shift+&lt;</code>可以左右切换</p>
<p>直接输入<code>top -c</code>，会显示完整命令，输出如下：</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">top - 23:56:31 up  8:20, <span class="number"> 1 </span>user,  load average: 0.95, 0.97, 1.00</span><br><span class="line">Tasks:<span class="number"> 439 </span>total,  <span class="number"> 2 </span>running,<span class="number"> 437 </span>sleeping,  <span class="number"> 0 </span>stopped,  <span class="number"> 0 </span>zombie</span><br><span class="line">%Cpu(s):  1.4 us,  1.5 sy,  0.0 ni, 96.8 id,  0.0 wa,  0.0 hi,  0.4 si,  0.0 st</span><br><span class="line">KiB Mem : 13183891+total, 12377344+free, <span class="number"> 3892304 </span>used, <span class="number"> 4173168 </span>buff/cache</span><br><span class="line">KiB Swap:       <span class="number"> 0 </span>total,       <span class="number"> 0 </span>free,       <span class="number"> 0 </span>used. 12718340+avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                                               </span><br><span class="line">11746 jenkins  <span class="number"> 20 </span> <span class="number"> 0 </span><span class="number"> 159972 </span> <span class="number"> 4760 </span> <span class="number"> 1600 </span>R 100.0  0.0 402:57.42 root/2                                                                                                                </span><br><span class="line">  <span class="number"> 42 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   3.3  0.0  16:21.24 [rcu_sched]                                                                                                           </span><br><span class="line">  <span class="number"> 57 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.7  0.0   1:03.01 [rcuos/14]                                                                                                            </span><br><span class="line">  <span class="number"> 63 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.3  0.0   0:29.22 [rcuos/20]                                                                                                            </span><br><span class="line"><span class="number"> 7933 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.3  0.0   0:05.50 [kworker/20:0]                                                                                                        </span><br><span class="line">11414 jenkins  <span class="number"> 20 </span> <span class="number"> 0 </span>42.134g 1.661g <span class="number"> 24516 </span>S   0.3  1.3   2:47.29 /etc/alternatives/java -Dcom.sun.akuma.Daemon=daemonized -Djava.awt.headless=true -DJENKINS_HOME=/var/lib/jenkins -j+ </span><br><span class="line">14702 root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.3  0.0   0:01.48 [kworker/2:0]                                                                                                         </span><br><span class="line">15098 root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.3  0.0   0:01.37 [kworker/6:2]                                                                                                         </span><br><span class="line">18465 txq      <span class="number"> 20 </span> <span class="number"> 0 </span><span class="number"> 158088 </span> <span class="number"> 2720 </span> <span class="number"> 1640 </span>R   0.3  0.0   0:00.18 top -c                                                                                                                </span><br><span class="line">   <span class="number"> 1 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span> <span class="number"> 45892 </span> <span class="number"> 8580 </span> <span class="number"> 3908 </span>S   0.0  0.0   0:13.78 /usr/lib/systemd/systemd --switched-root --system --deserialize<span class="number"> 21 </span>                                                   </span><br><span class="line">   <span class="number"> 2 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.06 [kthreadd]                                                                                                            </span><br><span class="line">   <span class="number"> 3 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.34 [ksoftirqd/0]                                                                                                         </span><br><span class="line">   <span class="number"> 5 </span>root      <span class="number"> 0 </span>-20      <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.00 [kworker/0:0H]                                                                                                        </span><br><span class="line">   <span class="number"> 8 </span>root      rt  <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.35 [migration/0]                                                                                                         </span><br><span class="line">   <span class="number"> 9 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.00 [rcu_bh]                                                                                                              </span><br><span class="line">  <span class="number"> 10 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.00 [rcuob/0]                                                                                                             </span><br><span class="line">  <span class="number"> 11 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.00 [rcuob/1]</span><br></pre></td></tr></table></figure>
<p>输入<code>q</code>是退出，还有其他命令参数，用到的时候再说，今天先统计这几个。</p>
<p>版权声明</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>cpu</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-物理CPU和逻辑CPU</title>
    <url>/2019/03/13/linux-%E7%89%A9%E7%90%86CPU%E5%92%8C%E9%80%BB%E8%BE%91CPU/</url>
    <content><![CDATA[<p>通过cat /proc/cpuinfo 来查看CPU的信息</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/5262207-4e29a8e7da45169c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/837/format/webp" alt="img"></p>
<p>cpu.png</p>
<p>physical id 表示物理CPU的编号<br> CPU cores 表示每个物理CPU上的内核数<br> core id 表示每个内核的编号<br> processor 表示每个逻辑CPU的编号</p>
<p>逻辑CPU的总数=物理CPU的数量 <em> 每个物理CPU上的核数 </em> 超线程数<br> 如果 逻辑CPU的总数=物理CPU的数量 * 每个物理CPU上的核数 则表示超线程没开，否则表示超线程以开</p>
<p>作者：君子亮剑</p>
<p>链接：<a href="https://www.jianshu.com/p/ff8e8be262ac" target="_blank" rel="noopener">https://www.jianshu.com/p/ff8e8be262ac</a></p>
<p>来源：简书</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>mmdetection的configs中的各项参数具体解释</title>
    <url>/2019/07/21/mmdetection%E7%9A%84configs%E4%B8%AD%E7%9A%84%E5%90%84%E9%A1%B9%E5%8F%82%E6%95%B0%E5%85%B7%E4%BD%93%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<p>一、简介<br>在使用mmdetection对模型进行调优的过程中总会遇到很多参数的问题，不知道参数在代码中是什么作用，会对训练产生怎样的影响，这里我以faster_rcnn_r50_fpn_1x.py和cascade_rcnn_r50_fpn_1x.py为例，简单介绍一下mmdetection中的各项参数含义</p>
<p>二、faster_rcnn_r50_fpn_1x.py配置文件<br>首先介绍一下这个配置文件所描述的框架，它是基于resnet50的backbone，有着5个fpn特征层的faster-RCNN目标检测网络，训练迭代次数为标准的12次epoch，下面逐条解释其含义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># model settings</span></span><br><span class="line">model = dict(</span><br><span class="line">	type=<span class="string">'FasterRCNN'</span>,                         <span class="comment"># model类型</span></span><br><span class="line">    pretrained=<span class="string">'modelzoo://resnet50'</span>,          <span class="comment"># 预训练模型：imagenet-resnet50</span></span><br><span class="line">    backbone=dict(</span><br><span class="line">        type=<span class="string">'ResNet'</span>,                         <span class="comment"># backbone类型</span></span><br><span class="line">        depth=<span class="number">50</span>,                              <span class="comment"># 网络层数</span></span><br><span class="line">        num_stages=<span class="number">4</span>,                          <span class="comment"># resnet的stage数量</span></span><br><span class="line">        out_indices=(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),              <span class="comment"># 输出的stage的序号</span></span><br><span class="line">        frozen_stages=<span class="number">1</span>,                       <span class="comment"># 冻结的stage数量，即该stage不更新参数，-1表示所有的stage都更新参数</span></span><br><span class="line">        style=<span class="string">'pytorch'</span>),                      <span class="comment"># 网络风格：如果设置pytorch，则stride为2的层是conv3x3的卷积层；如果设置caffe，则stride为2的层是第一个conv1x1的卷积层</span></span><br><span class="line">    neck=dict(</span><br><span class="line">        type=<span class="string">'FPN'</span>,                            <span class="comment"># neck类型</span></span><br><span class="line">        in_channels=[<span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>, <span class="number">2048</span>],    <span class="comment"># 输入的各个stage的通道数</span></span><br><span class="line">        out_channels=<span class="number">256</span>,                      <span class="comment"># 输出的特征层的通道数</span></span><br><span class="line">        num_outs=<span class="number">5</span>),                           <span class="comment"># 输出的特征层的数量</span></span><br><span class="line">    rpn_head=dict(</span><br><span class="line">        type=<span class="string">'RPNHead'</span>,                        <span class="comment"># RPN网络类型</span></span><br><span class="line">        in_channels=<span class="number">256</span>,                       <span class="comment"># RPN网络的输入通道数</span></span><br><span class="line">        feat_channels=<span class="number">256</span>,                     <span class="comment"># 特征层的通道数</span></span><br><span class="line">        anchor_scales=[<span class="number">8</span>],                     <span class="comment"># 生成的anchor的baselen，baselen = sqrt(w*h)，w和h为anchor的宽和高</span></span><br><span class="line">        anchor_ratios=[<span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">2.0</span>],         <span class="comment"># anchor的宽高比</span></span><br><span class="line">        anchor_strides=[<span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>],     <span class="comment"># 在每个特征层上的anchor的步长（对应于原图）</span></span><br><span class="line">        target_means=[<span class="number">.0</span>, <span class="number">.0</span>, <span class="number">.0</span>, <span class="number">.0</span>],         <span class="comment"># 均值</span></span><br><span class="line">        target_stds=[<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>],      <span class="comment"># 方差</span></span><br><span class="line">        use_sigmoid_cls=<span class="literal">True</span>),                 <span class="comment"># 是否使用sigmoid来进行分类，如果False则使用softmax来分类</span></span><br><span class="line">    bbox_roi_extractor=dict(</span><br><span class="line">        type=<span class="string">'SingleRoIExtractor'</span>,                                   <span class="comment"># RoIExtractor类型</span></span><br><span class="line">        roi_layer=dict(type=<span class="string">'RoIAlign'</span>, out_size=<span class="number">7</span>, sample_num=<span class="number">2</span>),   <span class="comment"># ROI具体参数：ROI类型为ROIalign，输出尺寸为7，sample数为2</span></span><br><span class="line">        out_channels=<span class="number">256</span>,                                            <span class="comment"># 输出通道数</span></span><br><span class="line">        featmap_strides=[<span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>]),                             <span class="comment"># 特征图的步长</span></span><br><span class="line">    bbox_head=dict(</span><br><span class="line">        type=<span class="string">'SharedFCBBoxHead'</span>,                     <span class="comment"># 全连接层类型</span></span><br><span class="line">        num_fcs=<span class="number">2</span>,                                   <span class="comment"># 全连接层数量</span></span><br><span class="line">        in_channels=<span class="number">256</span>,                             <span class="comment"># 输入通道数</span></span><br><span class="line">        fc_out_channels=<span class="number">1024</span>,                        <span class="comment"># 输出通道数</span></span><br><span class="line">        roi_feat_size=<span class="number">7</span>,                             <span class="comment"># ROI特征层尺寸</span></span><br><span class="line">        num_classes=<span class="number">81</span>,                              <span class="comment"># 分类器的类别数量+1，+1是因为多了一个背景的类别</span></span><br><span class="line">        target_means=[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],               <span class="comment"># 均值</span></span><br><span class="line">        target_stds=[<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.2</span>],            <span class="comment"># 方差</span></span><br><span class="line">        reg_class_agnostic=<span class="literal">False</span>))                   <span class="comment"># 是否采用class_agnostic的方式来预测，class_agnostic表示输出bbox时只考虑其是否为前景，后续分类的时候再根据该bbox在网络中的类别得分来分类，也就是说一个框可以对应多个类别</span></span><br><span class="line"><span class="comment"># model training and testing settings</span></span><br><span class="line">train_cfg = dict(</span><br><span class="line">    rpn=dict(</span><br><span class="line">        assigner=dict(</span><br><span class="line">            type=<span class="string">'MaxIoUAssigner'</span>,            <span class="comment"># RPN网络的正负样本划分</span></span><br><span class="line">            pos_iou_thr=<span class="number">0.7</span>,                  <span class="comment"># 正样本的iou阈值</span></span><br><span class="line">            neg_iou_thr=<span class="number">0.3</span>,                  <span class="comment"># 负样本的iou阈值</span></span><br><span class="line">            min_pos_iou=<span class="number">0.3</span>,                  <span class="comment"># 正样本的iou最小值。如果assign给ground truth的anchors中最大的IOU低于0.3，则忽略所有的anchors，否则保留最大IOU的anchor</span></span><br><span class="line">            ignore_iof_thr=<span class="number">-1</span>),               <span class="comment"># 忽略bbox的阈值，当ground truth中包含需要忽略的bbox时使用，-1表示不忽略</span></span><br><span class="line">        sampler=dict(</span><br><span class="line">            type=<span class="string">'RandomSampler'</span>,             <span class="comment"># 正负样本提取器类型</span></span><br><span class="line">            num=<span class="number">256</span>,                          <span class="comment"># 需提取的正负样本数量</span></span><br><span class="line">            pos_fraction=<span class="number">0.5</span>,                 <span class="comment"># 正样本比例</span></span><br><span class="line">            neg_pos_ub=<span class="number">-1</span>,                    <span class="comment"># 最大负样本比例，大于该比例的负样本忽略，-1表示不忽略</span></span><br><span class="line">            add_gt_as_proposals=<span class="literal">False</span>),       <span class="comment"># 把ground truth加入proposal作为正样本</span></span><br><span class="line">        allowed_border=<span class="number">0</span>,                     <span class="comment"># 允许在bbox周围外扩一定的像素</span></span><br><span class="line">        pos_weight=<span class="number">-1</span>,                        <span class="comment"># 正样本权重，-1表示不改变原始的权重</span></span><br><span class="line">        smoothl1_beta=<span class="number">1</span> / <span class="number">9.0</span>,                <span class="comment"># 平滑L1系数</span></span><br><span class="line">        debug=<span class="literal">False</span>),                         <span class="comment"># debug模式</span></span><br><span class="line">    rcnn=dict(</span><br><span class="line">        assigner=dict(</span><br><span class="line">            type=<span class="string">'MaxIoUAssigner'</span>,            <span class="comment"># RCNN网络正负样本划分</span></span><br><span class="line">            pos_iou_thr=<span class="number">0.5</span>,                  <span class="comment"># 正样本的iou阈值</span></span><br><span class="line">            neg_iou_thr=<span class="number">0.5</span>,                  <span class="comment"># 负样本的iou阈值</span></span><br><span class="line">            min_pos_iou=<span class="number">0.5</span>,                  <span class="comment"># 正样本的iou最小值。如果assign给ground truth的anchors中最大的IOU低于0.3，则忽略所有的anchors，否则保留最大IOU的anchor</span></span><br><span class="line">            ignore_iof_thr=<span class="number">-1</span>),               <span class="comment"># 忽略bbox的阈值，当ground truth中包含需要忽略的bbox时使用，-1表示不忽略</span></span><br><span class="line">        sampler=dict(</span><br><span class="line">            type=<span class="string">'RandomSampler'</span>,             <span class="comment"># 正负样本提取器类型</span></span><br><span class="line">            num=<span class="number">512</span>,                          <span class="comment"># 需提取的正负样本数量</span></span><br><span class="line">            pos_fraction=<span class="number">0.25</span>,                <span class="comment"># 正样本比例</span></span><br><span class="line">            neg_pos_ub=<span class="number">-1</span>,                    <span class="comment"># 最大负样本比例，大于该比例的负样本忽略，-1表示不忽略</span></span><br><span class="line">            add_gt_as_proposals=<span class="literal">True</span>),        <span class="comment"># 把ground truth加入proposal作为正样本</span></span><br><span class="line">        pos_weight=<span class="number">-1</span>,                        <span class="comment"># 正样本权重，-1表示不改变原始的权重</span></span><br><span class="line">        debug=<span class="literal">False</span>))                         <span class="comment"># debug模式</span></span><br><span class="line">test_cfg = dict(</span><br><span class="line">    rpn=dict(                                 <span class="comment"># 推断时的RPN参数</span></span><br><span class="line">        nms_across_levels=<span class="literal">False</span>,              <span class="comment"># 在所有的fpn层内做nms</span></span><br><span class="line">        nms_pre=<span class="number">2000</span>,                         <span class="comment"># 在nms之前保留的的得分最高的proposal数量</span></span><br><span class="line">        nms_post=<span class="number">2000</span>,                        <span class="comment"># 在nms之后保留的的得分最高的proposal数量</span></span><br><span class="line">        max_num=<span class="number">2000</span>,                         <span class="comment"># 在后处理完成之后保留的proposal数量</span></span><br><span class="line">        nms_thr=<span class="number">0.7</span>,                          <span class="comment"># nms阈值</span></span><br><span class="line">        min_bbox_size=<span class="number">0</span>),                     <span class="comment"># 最小bbox尺寸</span></span><br><span class="line">    rcnn=dict(</span><br><span class="line">        score_thr=<span class="number">0.05</span>, nms=dict(type=<span class="string">'nms'</span>, iou_thr=<span class="number">0.5</span>), max_per_img=<span class="number">100</span>)   <span class="comment"># max_per_img表示最终输出的det bbox数量</span></span><br><span class="line">    <span class="comment"># soft-nms is also supported for rcnn testing</span></span><br><span class="line">    <span class="comment"># e.g., nms=dict(type='soft_nms', iou_thr=0.5, min_score=0.05)            # soft_nms参数</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># dataset settings</span></span><br><span class="line">dataset_type = <span class="string">'CocoDataset'</span>                <span class="comment"># 数据集类型</span></span><br><span class="line">data_root = <span class="string">'data/coco/'</span>                    <span class="comment"># 数据集根目录</span></span><br><span class="line">img_norm_cfg = dict(</span><br><span class="line">    mean=[<span class="number">123.675</span>, <span class="number">116.28</span>, <span class="number">103.53</span>], std=[<span class="number">58.395</span>, <span class="number">57.12</span>, <span class="number">57.375</span>], to_rgb=<span class="literal">True</span>)   <span class="comment"># 输入图像初始化，减去均值mean并处以方差std，to_rgb表示将bgr转为rgb</span></span><br><span class="line">data = dict(</span><br><span class="line">    imgs_per_gpu=<span class="number">2</span>,                <span class="comment"># 每个gpu计算的图像数量</span></span><br><span class="line">    workers_per_gpu=<span class="number">2</span>,             <span class="comment"># 每个gpu分配的线程数</span></span><br><span class="line">    train=dict(</span><br><span class="line">        type=dataset_type,                                                 <span class="comment"># 数据集类型</span></span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/instances_train2017.json'</span>,       <span class="comment"># 数据集annotation路径</span></span><br><span class="line">        img_prefix=data_root + <span class="string">'train2017/'</span>,                               <span class="comment"># 数据集的图片路径</span></span><br><span class="line">        img_scale=(<span class="number">1333</span>, <span class="number">800</span>),                                             <span class="comment"># 输入图像尺寸，最大边1333，最小边800</span></span><br><span class="line">        img_norm_cfg=img_norm_cfg,                                         <span class="comment"># 图像初始化参数</span></span><br><span class="line">        size_divisor=<span class="number">32</span>,                                                   <span class="comment"># 对图像进行resize时的最小单位，32表示所有的图像都会被resize成32的倍数</span></span><br><span class="line">        flip_ratio=<span class="number">0.5</span>,                                                    <span class="comment"># 图像的随机左右翻转的概率</span></span><br><span class="line">        with_mask=<span class="literal">False</span>,                                                   <span class="comment"># 训练时附带mask</span></span><br><span class="line">        with_crowd=<span class="literal">True</span>,                                                   <span class="comment"># 训练时附带difficult的样本</span></span><br><span class="line">        with_label=<span class="literal">True</span>),                                                  <span class="comment"># 训练时附带label</span></span><br><span class="line">    val=dict(</span><br><span class="line">        type=dataset_type,                                                 <span class="comment"># 同上</span></span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/instances_val2017.json'</span>,         <span class="comment"># 同上</span></span><br><span class="line">        img_prefix=data_root + <span class="string">'val2017/'</span>,                                 <span class="comment"># 同上</span></span><br><span class="line">        img_scale=(<span class="number">1333</span>, <span class="number">800</span>),                                             <span class="comment"># 同上</span></span><br><span class="line">        img_norm_cfg=img_norm_cfg,                                         <span class="comment"># 同上</span></span><br><span class="line">        size_divisor=<span class="number">32</span>,                                                   <span class="comment"># 同上</span></span><br><span class="line">        flip_ratio=<span class="number">0</span>,                                                      <span class="comment"># 同上</span></span><br><span class="line">        with_mask=<span class="literal">False</span>,                                                   <span class="comment"># 同上</span></span><br><span class="line">        with_crowd=<span class="literal">True</span>,                                                   <span class="comment"># 同上</span></span><br><span class="line">        with_label=<span class="literal">True</span>),                                                  <span class="comment"># 同上</span></span><br><span class="line">    test=dict(</span><br><span class="line">        type=dataset_type,                                                 <span class="comment"># 同上</span></span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/instances_val2017.json'</span>,         <span class="comment"># 同上</span></span><br><span class="line">        img_prefix=data_root + <span class="string">'val2017/'</span>,                                 <span class="comment"># 同上</span></span><br><span class="line">        img_scale=(<span class="number">1333</span>, <span class="number">800</span>),                                             <span class="comment"># 同上</span></span><br><span class="line">        img_norm_cfg=img_norm_cfg,                                         <span class="comment"># 同上</span></span><br><span class="line">        size_divisor=<span class="number">32</span>,                                                   <span class="comment"># 同上</span></span><br><span class="line">        flip_ratio=<span class="number">0</span>,                                                      <span class="comment"># 同上</span></span><br><span class="line">        with_mask=<span class="literal">False</span>,                                                   <span class="comment"># 同上</span></span><br><span class="line">        with_label=<span class="literal">False</span>,                                                  <span class="comment"># 同上</span></span><br><span class="line">        test_mode=<span class="literal">True</span>))                                                   <span class="comment"># 同上</span></span><br><span class="line"><span class="comment"># optimizer</span></span><br><span class="line">optimizer = dict(type=<span class="string">'SGD'</span>, lr=<span class="number">0.02</span>, momentum=<span class="number">0.9</span>, weight_decay=<span class="number">0.0001</span>)   <span class="comment"># 优化参数，lr为学习率，momentum为动量因子，weight_decay为权重衰减因子</span></span><br><span class="line">optimizer_config = dict(grad_clip=dict(max_norm=<span class="number">35</span>, norm_type=<span class="number">2</span>))          <span class="comment"># 梯度均衡参数</span></span><br><span class="line"><span class="comment"># learning policy</span></span><br><span class="line">lr_config = dict(</span><br><span class="line">    policy=<span class="string">'step'</span>,                        <span class="comment"># 优化策略</span></span><br><span class="line">    warmup=<span class="string">'linear'</span>,                      <span class="comment"># 初始的学习率增加的策略，linear为线性增加</span></span><br><span class="line">    warmup_iters=<span class="number">500</span>,                     <span class="comment"># 在初始的500次迭代中学习率逐渐增加</span></span><br><span class="line">    warmup_ratio=<span class="number">1.0</span> / <span class="number">3</span>,                 <span class="comment"># 起始的学习率</span></span><br><span class="line">    step=[<span class="number">8</span>, <span class="number">11</span>])                         <span class="comment"># 在第8和11个epoch时降低学习率</span></span><br><span class="line">checkpoint_config = dict(interval=<span class="number">1</span>)      <span class="comment"># 每1个epoch存储一次模型</span></span><br><span class="line"><span class="comment"># yapf:disable</span></span><br><span class="line">log_config = dict(</span><br><span class="line">    interval=<span class="number">50</span>,                          <span class="comment"># 每50个batch输出一次信息</span></span><br><span class="line">    hooks=[</span><br><span class="line">        dict(type=<span class="string">'TextLoggerHook'</span>),      <span class="comment"># 控制台输出信息的风格</span></span><br><span class="line">        <span class="comment"># dict(type='TensorboardLoggerHook')</span></span><br><span class="line">    ])</span><br><span class="line"><span class="comment"># yapf:enable</span></span><br><span class="line"><span class="comment"># runtime settings</span></span><br><span class="line">total_epochs = <span class="number">12</span>                               <span class="comment"># 最大epoch数</span></span><br><span class="line">dist_params = dict(backend=<span class="string">'nccl'</span>)              <span class="comment"># 分布式参数</span></span><br><span class="line">log_level = <span class="string">'INFO'</span>                              <span class="comment"># 输出信息的完整度级别</span></span><br><span class="line">work_dir = <span class="string">'./work_dirs/faster_rcnn_r50_fpn_1x'</span> <span class="comment"># log文件和模型文件存储路径</span></span><br><span class="line">load_from = <span class="literal">None</span>                                <span class="comment"># 加载模型的路径，None表示从预训练模型加载</span></span><br><span class="line">resume_from = <span class="literal">None</span>                              <span class="comment"># 恢复训练模型的路径</span></span><br><span class="line">workflow = [(<span class="string">'train'</span>, <span class="number">1</span>)]                       <span class="comment"># 当前工作区名称</span></span><br></pre></td></tr></table></figure>
<p> 三、cascade_rcnn_r50_fpn_1x.py配置文件<br>cascade-RCNN是cvpr2018的文章，相比于faster-RCNN的改进主要在于其RCNN有三个stage，这三个stage逐级refine检测的结果，使得结果达到更高的精度。下面逐条解释其config的含义，与faster-RCNN相同的部分就不再赘述。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># model settings</span></span><br><span class="line">model = dict(</span><br><span class="line">    type=<span class="string">'CascadeRCNN'</span>,</span><br><span class="line">    num_stages=<span class="number">3</span>,                     <span class="comment"># RCNN网络的stage数量，在faster-RCNN中为1</span></span><br><span class="line">    pretrained=<span class="string">'modelzoo://resnet50'</span>,</span><br><span class="line">    backbone=dict(</span><br><span class="line">        type=<span class="string">'ResNet'</span>,</span><br><span class="line">        depth=<span class="number">50</span>,</span><br><span class="line">        num_stages=<span class="number">4</span>,</span><br><span class="line">        out_indices=(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">        frozen_stages=<span class="number">1</span>,</span><br><span class="line">        style=<span class="string">'pytorch'</span>),</span><br><span class="line">    neck=dict(</span><br><span class="line">        type=<span class="string">'FPN'</span>,</span><br><span class="line">        in_channels=[<span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>, <span class="number">2048</span>],</span><br><span class="line">        out_channels=<span class="number">256</span>,</span><br><span class="line">        num_outs=<span class="number">5</span>),</span><br><span class="line">    rpn_head=dict(</span><br><span class="line">        type=<span class="string">'RPNHead'</span>,</span><br><span class="line">        in_channels=<span class="number">256</span>,</span><br><span class="line">        feat_channels=<span class="number">256</span>,</span><br><span class="line">        anchor_scales=[<span class="number">8</span>],</span><br><span class="line">        anchor_ratios=[<span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">2.0</span>],</span><br><span class="line">        anchor_strides=[<span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>],</span><br><span class="line">        target_means=[<span class="number">.0</span>, <span class="number">.0</span>, <span class="number">.0</span>, <span class="number">.0</span>],</span><br><span class="line">        target_stds=[<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>],</span><br><span class="line">        use_sigmoid_cls=<span class="literal">True</span>),</span><br><span class="line">    bbox_roi_extractor=dict(</span><br><span class="line">        type=<span class="string">'SingleRoIExtractor'</span>,</span><br><span class="line">        roi_layer=dict(type=<span class="string">'RoIAlign'</span>, out_size=<span class="number">7</span>, sample_num=<span class="number">2</span>),</span><br><span class="line">        out_channels=<span class="number">256</span>,</span><br><span class="line">        featmap_strides=[<span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>]),</span><br><span class="line">    bbox_head=[</span><br><span class="line">        dict(</span><br><span class="line">            type=<span class="string">'SharedFCBBoxHead'</span>,</span><br><span class="line">            num_fcs=<span class="number">2</span>,</span><br><span class="line">            in_channels=<span class="number">256</span>,</span><br><span class="line">            fc_out_channels=<span class="number">1024</span>,</span><br><span class="line">            roi_feat_size=<span class="number">7</span>,</span><br><span class="line">            num_classes=<span class="number">81</span>,</span><br><span class="line">            target_means=[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">            target_stds=[<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.2</span>],</span><br><span class="line">            reg_class_agnostic=<span class="literal">True</span>),</span><br><span class="line">        dict(</span><br><span class="line">            type=<span class="string">'SharedFCBBoxHead'</span>,</span><br><span class="line">            num_fcs=<span class="number">2</span>,</span><br><span class="line">            in_channels=<span class="number">256</span>,</span><br><span class="line">            fc_out_channels=<span class="number">1024</span>,</span><br><span class="line">            roi_feat_size=<span class="number">7</span>,</span><br><span class="line">            num_classes=<span class="number">81</span>,</span><br><span class="line">            target_means=[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">            target_stds=[<span class="number">0.05</span>, <span class="number">0.05</span>, <span class="number">0.1</span>, <span class="number">0.1</span>],</span><br><span class="line">            reg_class_agnostic=<span class="literal">True</span>),</span><br><span class="line">        dict(</span><br><span class="line">            type=<span class="string">'SharedFCBBoxHead'</span>,</span><br><span class="line">            num_fcs=<span class="number">2</span>,</span><br><span class="line">            in_channels=<span class="number">256</span>,</span><br><span class="line">            fc_out_channels=<span class="number">1024</span>,</span><br><span class="line">            roi_feat_size=<span class="number">7</span>,</span><br><span class="line">            num_classes=<span class="number">81</span>,</span><br><span class="line">            target_means=[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">            target_stds=[<span class="number">0.033</span>, <span class="number">0.033</span>, <span class="number">0.067</span>, <span class="number">0.067</span>],</span><br><span class="line">            reg_class_agnostic=<span class="literal">True</span>)</span><br><span class="line">    ])</span><br><span class="line"><span class="comment"># model training and testing settings</span></span><br><span class="line">train_cfg = dict(</span><br><span class="line">    rpn=dict(</span><br><span class="line">        assigner=dict(</span><br><span class="line">            type=<span class="string">'MaxIoUAssigner'</span>,</span><br><span class="line">            pos_iou_thr=<span class="number">0.7</span>,</span><br><span class="line">            neg_iou_thr=<span class="number">0.3</span>,</span><br><span class="line">            min_pos_iou=<span class="number">0.3</span>,</span><br><span class="line">            ignore_iof_thr=<span class="number">-1</span>),</span><br><span class="line">        sampler=dict(</span><br><span class="line">            type=<span class="string">'RandomSampler'</span>,</span><br><span class="line">            num=<span class="number">256</span>,</span><br><span class="line">            pos_fraction=<span class="number">0.5</span>,</span><br><span class="line">            neg_pos_ub=<span class="number">-1</span>,</span><br><span class="line">            add_gt_as_proposals=<span class="literal">False</span>),</span><br><span class="line">        allowed_border=<span class="number">0</span>,</span><br><span class="line">        pos_weight=<span class="number">-1</span>,</span><br><span class="line">        smoothl1_beta=<span class="number">1</span> / <span class="number">9.0</span>,</span><br><span class="line">        debug=<span class="literal">False</span>),</span><br><span class="line">    rcnn=[                    <span class="comment"># 注意，这里有3个RCNN的模块，对应开头的那个RCNN的stage数量</span></span><br><span class="line">        dict(</span><br><span class="line">            assigner=dict(</span><br><span class="line">                type=<span class="string">'MaxIoUAssigner'</span>,</span><br><span class="line">                pos_iou_thr=<span class="number">0.5</span>,</span><br><span class="line">                neg_iou_thr=<span class="number">0.5</span>,</span><br><span class="line">                min_pos_iou=<span class="number">0.5</span>,</span><br><span class="line">                ignore_iof_thr=<span class="number">-1</span>),</span><br><span class="line">            sampler=dict(</span><br><span class="line">                type=<span class="string">'RandomSampler'</span>,</span><br><span class="line">                num=<span class="number">512</span>,</span><br><span class="line">                pos_fraction=<span class="number">0.25</span>,</span><br><span class="line">                neg_pos_ub=<span class="number">-1</span>,</span><br><span class="line">                add_gt_as_proposals=<span class="literal">True</span>),</span><br><span class="line">            pos_weight=<span class="number">-1</span>,</span><br><span class="line">            debug=<span class="literal">False</span>),</span><br><span class="line">        dict(</span><br><span class="line">            assigner=dict(</span><br><span class="line">                type=<span class="string">'MaxIoUAssigner'</span>,</span><br><span class="line">                pos_iou_thr=<span class="number">0.6</span>,</span><br><span class="line">                neg_iou_thr=<span class="number">0.6</span>,</span><br><span class="line">                min_pos_iou=<span class="number">0.6</span>,</span><br><span class="line">                ignore_iof_thr=<span class="number">-1</span>),</span><br><span class="line">            sampler=dict(</span><br><span class="line">                type=<span class="string">'RandomSampler'</span>,</span><br><span class="line">                num=<span class="number">512</span>,</span><br><span class="line">                pos_fraction=<span class="number">0.25</span>,</span><br><span class="line">                neg_pos_ub=<span class="number">-1</span>,</span><br><span class="line">                add_gt_as_proposals=<span class="literal">True</span>),</span><br><span class="line">            pos_weight=<span class="number">-1</span>,</span><br><span class="line">            debug=<span class="literal">False</span>),</span><br><span class="line">        dict(</span><br><span class="line">            assigner=dict(</span><br><span class="line">                type=<span class="string">'MaxIoUAssigner'</span>,</span><br><span class="line">                pos_iou_thr=<span class="number">0.7</span>,</span><br><span class="line">                neg_iou_thr=<span class="number">0.7</span>,</span><br><span class="line">                min_pos_iou=<span class="number">0.7</span>,</span><br><span class="line">                ignore_iof_thr=<span class="number">-1</span>),</span><br><span class="line">            sampler=dict(</span><br><span class="line">                type=<span class="string">'RandomSampler'</span>,</span><br><span class="line">                num=<span class="number">512</span>,</span><br><span class="line">                pos_fraction=<span class="number">0.25</span>,</span><br><span class="line">                neg_pos_ub=<span class="number">-1</span>,</span><br><span class="line">                add_gt_as_proposals=<span class="literal">True</span>),</span><br><span class="line">            pos_weight=<span class="number">-1</span>,</span><br><span class="line">            debug=<span class="literal">False</span>)</span><br><span class="line">    ],</span><br><span class="line">    stage_loss_weights=[<span class="number">1</span>, <span class="number">0.5</span>, <span class="number">0.25</span>])     <span class="comment"># 3个RCNN的stage的loss权重</span></span><br><span class="line">test_cfg = dict(</span><br><span class="line">    rpn=dict(</span><br><span class="line">        nms_across_levels=<span class="literal">False</span>,</span><br><span class="line">        nms_pre=<span class="number">2000</span>,</span><br><span class="line">        nms_post=<span class="number">2000</span>,</span><br><span class="line">        max_num=<span class="number">2000</span>,</span><br><span class="line">        nms_thr=<span class="number">0.7</span>,</span><br><span class="line">        min_bbox_size=<span class="number">0</span>),</span><br><span class="line">    rcnn=dict(</span><br><span class="line">        score_thr=<span class="number">0.05</span>, nms=dict(type=<span class="string">'nms'</span>, iou_thr=<span class="number">0.5</span>), max_per_img=<span class="number">100</span>),</span><br><span class="line">    keep_all_stages=<span class="literal">False</span>)         <span class="comment"># 是否保留所有stage的结果</span></span><br><span class="line"><span class="comment"># dataset settings</span></span><br><span class="line">dataset_type = <span class="string">'CocoDataset'</span></span><br><span class="line">data_root = <span class="string">'data/coco/'</span></span><br><span class="line">img_norm_cfg = dict(</span><br><span class="line">    mean=[<span class="number">123.675</span>, <span class="number">116.28</span>, <span class="number">103.53</span>], std=[<span class="number">58.395</span>, <span class="number">57.12</span>, <span class="number">57.375</span>], to_rgb=<span class="literal">True</span>)</span><br><span class="line">data = dict(</span><br><span class="line">    imgs_per_gpu=<span class="number">2</span>,</span><br><span class="line">    workers_per_gpu=<span class="number">2</span>,</span><br><span class="line">    train=dict(</span><br><span class="line">        type=dataset_type,</span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/instances_train2017.json'</span>,</span><br><span class="line">        img_prefix=data_root + <span class="string">'train2017/'</span>,</span><br><span class="line">        img_scale=(<span class="number">1333</span>, <span class="number">800</span>),</span><br><span class="line">        img_norm_cfg=img_norm_cfg,</span><br><span class="line">        size_divisor=<span class="number">32</span>,</span><br><span class="line">        flip_ratio=<span class="number">0.5</span>,</span><br><span class="line">        with_mask=<span class="literal">False</span>,</span><br><span class="line">        with_crowd=<span class="literal">True</span>,</span><br><span class="line">        with_label=<span class="literal">True</span>),</span><br><span class="line">    val=dict(</span><br><span class="line">        type=dataset_type,</span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/instances_val2017.json'</span>,</span><br><span class="line">        img_prefix=data_root + <span class="string">'val2017/'</span>,</span><br><span class="line">        img_scale=(<span class="number">1333</span>, <span class="number">800</span>),</span><br><span class="line">        img_norm_cfg=img_norm_cfg,</span><br><span class="line">        size_divisor=<span class="number">32</span>,</span><br><span class="line">        flip_ratio=<span class="number">0</span>,</span><br><span class="line">        with_mask=<span class="literal">False</span>,</span><br><span class="line">        with_crowd=<span class="literal">True</span>,</span><br><span class="line">        with_label=<span class="literal">True</span>),</span><br><span class="line">    test=dict(</span><br><span class="line">        type=dataset_type,</span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/instances_val2017.json'</span>,</span><br><span class="line">        img_prefix=data_root + <span class="string">'val2017/'</span>,</span><br><span class="line">        img_scale=(<span class="number">1333</span>, <span class="number">800</span>),</span><br><span class="line">        img_norm_cfg=img_norm_cfg,</span><br><span class="line">        size_divisor=<span class="number">32</span>,</span><br><span class="line">        flip_ratio=<span class="number">0</span>,</span><br><span class="line">        with_mask=<span class="literal">False</span>,</span><br><span class="line">        with_label=<span class="literal">False</span>,</span><br><span class="line">        test_mode=<span class="literal">True</span>))</span><br><span class="line"><span class="comment"># optimizer</span></span><br><span class="line">optimizer = dict(type=<span class="string">'SGD'</span>, lr=<span class="number">0.02</span>, momentum=<span class="number">0.9</span>, weight_decay=<span class="number">0.0001</span>)</span><br><span class="line">optimizer_config = dict(grad_clip=dict(max_norm=<span class="number">35</span>, norm_type=<span class="number">2</span>))</span><br><span class="line"><span class="comment"># learning policy</span></span><br><span class="line">lr_config = dict(</span><br><span class="line">    policy=<span class="string">'step'</span>,</span><br><span class="line">    warmup=<span class="string">'linear'</span>,</span><br><span class="line">    warmup_iters=<span class="number">500</span>,</span><br><span class="line">    warmup_ratio=<span class="number">1.0</span> / <span class="number">3</span>,</span><br><span class="line">    step=[<span class="number">8</span>, <span class="number">11</span>])</span><br><span class="line">checkpoint_config = dict(interval=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># yapf:disable</span></span><br><span class="line">log_config = dict(</span><br><span class="line">    interval=<span class="number">50</span>,</span><br><span class="line">    hooks=[</span><br><span class="line">        dict(type=<span class="string">'TextLoggerHook'</span>),</span><br><span class="line">        <span class="comment"># dict(type='TensorboardLoggerHook')</span></span><br><span class="line">    ])</span><br><span class="line"><span class="comment"># yapf:enable</span></span><br><span class="line"><span class="comment"># runtime settings</span></span><br><span class="line">total_epochs = <span class="number">12</span></span><br><span class="line">dist_params = dict(backend=<span class="string">'nccl'</span>)</span><br><span class="line">log_level = <span class="string">'INFO'</span></span><br><span class="line">work_dir = <span class="string">'./work_dirs/cascade_rcnn_r50_fpn_1x'</span></span><br><span class="line">load_from = <span class="literal">None</span></span><br><span class="line">resume_from = <span class="literal">None</span></span><br><span class="line">workflow = [(<span class="string">'train'</span>, <span class="number">1</span>)]</span><br></pre></td></tr></table></figure>
<p>参考链接：</p>
<p><a href="https://www.jiqizhixin.com/articles/2018-10-17-10" target="_blank" rel="noopener">https://www.jiqizhixin.com/articles/2018-10-17-10</a></p>
]]></content>
      <categories>
        <category>目标检测</category>
      </categories>
      <tags>
        <tag>目标检测</tag>
      </tags>
  </entry>
  <entry>
    <title>nltk-tokenize</title>
    <url>/2019/02/28/nltk-tokenize/</url>
    <content><![CDATA[<p>转载：<a href="https://pythonprogramming.net/tokenizing-words-sentences-nltk-tutorial/" target="_blank" rel="noopener">https://pythonprogramming.net/tokenizing-words-sentences-nltk-tutorial/</a></p>
<p>Next, you’re going to need NLTK 3. The easiest method to installing the NLTK module is going to be with pip.</p>
<p>For all users, that is done by opening up cmd.exe, bash, or whatever shell you use and typing:<br><code>pip install nltk</code></p>
<p>These are the words you will most commonly hear upon entering the Natural Language Processing (NLP) space, but there are many more that we will be covering in time. With that, let’s show an example of how one might actually tokenize something into tokens with the NLTK module.</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">from nltk<span class="selector-class">.tokenize</span> import sent_tokenize, word_tokenize</span><br><span class="line"></span><br><span class="line">EXAMPLE_TEXT = <span class="string">"Hello Mr. Smith, how are you doing today? The weather is great, and Python is awesome. The sky is pinkish-blue. You shouldn't eat cardboard."</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(sent_tokenize(EXAMPLE_TEXT)</span></span>)</span><br></pre></td></tr></table></figure>
<p>At first, you may think tokenizing by things like words or sentences is a rather trivial enterprise. For many sentences it can be. The first step would be likely doing a simple .split(‘. ‘), or splitting by period followed by a space. Then maybe you would bring in some <a href="https://pythonprogramming.net/regular-expressions-regex-tutorial-python-3/" target="_blank" rel="noopener"><strong>regular expressions</strong></a> to split by period, space, and then a capital letter. The problem is that things like Mr. Smith would cause you trouble, and many other things. Splitting by word is also a challenge, especially when considering things like concatenations like we and are to we’re. NLTK is going to go ahead and just save you a ton of time with this seemingly simple, yet very complex, operation.</p>
<p>The above code will output the sentences, split up into a list of sentences, which you can do things like iterate through with a <a href="https://pythonprogramming.net/loop-python-3-basics-tutorial/" target="_blank" rel="noopener"><strong>for loop</strong></a>.<br><code>[&#39;Hello Mr. Smith, how are you doing today?&#39;, &#39;The weather is great, and Python is awesome.&#39;, &#39;The sky is pinkish-blue.&#39;, &quot;You shouldn&#39;t eat cardboard.&quot;]</code></p>
<p>So there, we have created tokens, which are sentences. Let’s tokenize by word instead this time:</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">print(<span class="name">word_tokenize</span>(<span class="name">EXAMPLE_TEXT</span>))</span><br></pre></td></tr></table></figure>
<p>Now our output is: <code>[&#39;Hello&#39;, &#39;Mr.&#39;, &#39;Smith&#39;, &#39;,&#39;, &#39;how&#39;, &#39;are&#39;, &#39;you&#39;, &#39;doing&#39;, &#39;today&#39;, &#39;?&#39;, &#39;The&#39;, &#39;weather&#39;, &#39;is&#39;, &#39;great&#39;, &#39;,&#39;, &#39;and&#39;, &#39;Python&#39;, &#39;is&#39;, &#39;awesome&#39;, &#39;.&#39;, &#39;The&#39;, &#39;sky&#39;, &#39;is&#39;, &#39;pinkish-blue&#39;, &#39;.&#39;, &#39;You&#39;, &#39;should&#39;, &quot;n&#39;t&quot;, &#39;eat&#39;, &#39;cardboard&#39;, &#39;.&#39;]</code></p>
<p>There are a few things to note here. First, notice that punctuation is treated as a separate token. Also, notice the separation of the word “shouldn’t” into “should” and “n’t.” Finally, notice that “pinkish-blue” is indeed treated like the “one word” it was meant to be turned into. Pretty cool!</p>
]]></content>
  </entry>
  <entry>
    <title>mmdetection的安装</title>
    <url>/2019/07/20/mmdetection%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul>
<li>选择镜像：py36-pytorch0.4.0-cu90-ctc （即，准备一个cuda9.0的环境）</li>
<li>note: 需要一个pytorch1.1.0（pytorch1.2测试不可以用，推荐使用1.1.0），后文有讲如何在anaconda下安装pytorch</li>
<li>进入容器，安装anaconda</li>
</ul>
<h3 id="按着Github-install的步骤进行安装如下："><a href="#按着Github-install的步骤进行安装如下：" class="headerlink" title="按着Github install的步骤进行安装如下："></a>按着<a href="https://github.com/open-mmlab/mmdetection/blob/master/INSTALL.md" target="_blank" rel="noopener">Github install</a>的步骤进行安装如下：</h3><ul>
<li>Create a conda virtual environment and activate it. Then install Cython.<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conda create -n open-mmlab python=<span class="number">3.7</span> -y</span><br><span class="line">source activate open-mmlab</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong> 以下的操作都是在进入open-mmlab环境之后进行的</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">conda <span class="keyword">install</span> cython</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 numpy</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> numpy</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>安装<a href="https://github.com/open-mmlab/mmcv" target="_blank" rel="noopener">mmcv</a> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install mmcv</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装pytorch<br>最好是离线下载，然后再安装，因为conda install 或者 pip install 可能连接不上（细节：pip install torch  就会出现下载链接，然后自己复制链接去网页下载即可），下载之后：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">pip</span> <span class="selector-tag">install</span> <span class="selector-tag">torch-1</span><span class="selector-class">.1</span><span class="selector-class">.0-cp37-cp37m-manylinux1_x86_64</span><span class="selector-class">.whl</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装opencv</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">conda <span class="keyword">install</span> -c menpo opencv</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>安装matplotlib<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> matplotlib</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>安装 terminaltables<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> terminaltables</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>安装 pip install pycocotools</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> pycocotools</span><br></pre></td></tr></table></figure>
</li>
<li><p>选择一个看的顺眼的位置：Clone the mmdetection repository.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/open-mmlab/mmdetection.git</span><br><span class="line">cd mmdetection</span><br></pre></td></tr></table></figure>
</li>
<li><p>Install mmdetection</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python setup.py develop</span><br></pre></td></tr></table></figure>
</li>
<li><p>大功告成</p>
</li>
</ul>
]]></content>
      <categories>
        <category>目标检测</category>
      </categories>
      <tags>
        <tag>目标检测</tag>
      </tags>
  </entry>
  <entry>
    <title>调研：non-autoregressive neural machine translation</title>
    <url>/2021/03/24/non-autoregressive-neural-machine-translation/</url>
    <content><![CDATA[<p>本篇对基于非自回归的机器翻译任务进行调研</p>
<h2 id="First-paper"><a href="#First-paper" class="headerlink" title="First paper"></a><strong style="color:blue;">First paper</strong></h2><p>Gu, J.; Bradbury, J.; Xiong, C.; Li, V. O.; and Socher, R. 2018. <strong>Non-autoregressive neural machine translation.</strong> In ICLR.</p>
<h2 id="Enhancing-the-decoder-inputs"><a href="#Enhancing-the-decoder-inputs" class="headerlink" title="Enhancing the decoder inputs"></a><strong style="color:blue;">Enhancing the decoder inputs</strong></h2><p>Bingzhen Wei, Mingxuan Wang, Hao Zhou, Junyang Lin, and Xu Sun. 2019. <strong>Imitation learning for nonautoregressive neural machine translation.</strong> In ACL.</p>
<p>Wang, Y.; Tian, F.; He, D.; Qin, T.; Zhai, C.; and Liu, T.-Y. 2019b. <strong>Non-autoregressive machine translation with auxiliary regularization.</strong> In AAAI.</p>
<p>Guo, J.; Tan, X.; He, D.; Qin, T.; Xu, L.; and Liu, T.-Y. 2019. <strong>Non-autoregressive neural machine translation with enhanced decoder input.</strong> In AAAI.</p>
<p>Lee, J.; Mansimov, E.; and Cho, K. 2018. <strong>Deterministic nonautoregressive neural sequence modeling by iterative refinement.</strong> In EMNLP.</p>
<h2 id="Modeling-the-dependencies-among-target-outputs"><a href="#Modeling-the-dependencies-among-target-outputs" class="headerlink" title="Modeling the dependencies among target outputs"></a><strong style="color:blue;">Modeling the dependencies among target outputs</strong></h2><p>Ghazvininejad, M.; Levy, O.; Liu, Y.; and Zettlemoyer, L. 2019. <strong>Mask-predict: Parallel decoding of conditional masked language models.</strong> In EMNLP-IJCNLP.</p>
<p>Lihua Qian, Hao Zhou, Yu Bao, Mingxuan Wang, Lin Qiu, Weinan Zhang, Yong Yu, and Lei Li. 2020. <strong>Glancing transformer for non-autoregressive neural machine translation.</strong> arXiv preprint arXiv:2008.07905.</p>
<p>Gu, J.;Wang, C.; and Zhao, J. 2019. <strong>Levenshtein transformer.</strong> In Advances in NIPS.</p>
<p>Mansimov, E.; Wang, A.; and Cho, K. 2019. <strong>A generalized framework of sequence generation with application to undirected sequence models.</strong> arXiv preprint arXiv:1905.12790 .</p>
<ul>
<li><p><strong style="color:blue;">model the target-side dependencies in the latent space</strong></p>
<p>Non-Autoregressive Translation by Learning Target Categorical Codes. NAACL-2021</p>
<p><a href="https://mp.weixin.qq.com/s/qDN1ROXjkVI6wdTHa18YlA" target="_blank" rel="noopener">NAACL2021论文：基于隐式类别建模的非自回归式翻译</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy 函数</title>
    <url>/2019/06/16/numpy-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="np-round"><a href="#np-round" class="headerlink" title="np.round "></a><font color="#0099ff" size="7" face="黑体">np.round </font></h2><h3 id="round函数概念："><a href="#round函数概念：" class="headerlink" title="round函数概念："></a>round函数概念：</h3><p>英文：圆，四舍五入<br>是python内置函数，它在哪都能用，对数字取四舍五入。<br>round(number[, ndigits])<br>round 对传入的数据进行四舍五入，如果ngigits不传，默认是0（就是说保留整数部分）.ngigits&lt;0 的时候是来对整数部分进行四舍五入，返回的结果是浮点数.</p>
<h3 id="round-负数"><a href="#round-负数" class="headerlink" title="round 负数"></a>round 负数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 四舍五入是围绕着0来计算的，  </span></span><br><span class="line">round(<span class="number">0.5</span>) <span class="comment"># 1.0  </span></span><br><span class="line">round(<span class="number">-0.5</span>) <span class="comment">#-1.0</span></span><br></pre></td></tr></table></figure>
<h3 id="round-的陷阱"><a href="#round-的陷阱" class="headerlink" title="round 的陷阱"></a>round 的陷阱</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">round(<span class="number">1.675</span>, <span class="number">2</span>) <span class="comment">#1.68  </span></span><br><span class="line">round(<span class="number">2.675</span>, <span class="number">2</span>) <span class="comment">#2.67</span></span><br></pre></td></tr></table></figure>
<h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">round(<span class="number">3.4</span>) <span class="comment"># 3.0  </span></span><br><span class="line">round(<span class="number">3.5</span>) <span class="comment"># 4.0  </span></span><br><span class="line">round(<span class="number">3.6</span>) <span class="comment"># 4.0  </span></span><br><span class="line">round(<span class="number">3.6</span>, <span class="number">0</span>) <span class="comment"># 4.0  </span></span><br><span class="line">round(<span class="number">1.95583</span>, <span class="number">2</span>) <span class="comment"># 1.96  </span></span><br><span class="line">round(<span class="number">1241757</span>, <span class="number">-3</span>) <span class="comment"># 1242000.0  </span></span><br><span class="line">round(<span class="number">5.045</span>, <span class="number">2</span>) <span class="comment"># 5.05  </span></span><br><span class="line">round(<span class="number">5.055</span>, <span class="number">2</span>) <span class="comment"># 5.06</span></span><br></pre></td></tr></table></figure>
<h2 id="np-clip"><a href="#np-clip" class="headerlink" title="np.clip"></a><font color="#0099ff" size="7" face="黑体">np.clip</font></h2><p>numpy.clip(a, a_min, a_max, out=None)[source]<br>其中a是一个数组，后面两个参数分别表示最小和最大值，怎么用呢，老规矩，我们看代码：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x=np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>])</span><br><span class="line">np.clip(x,<span class="number">3</span>,<span class="number">8</span>)</span><br><span class="line">Out[<span class="number">88</span>]:</span><br><span class="line">array([<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>])</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>pth: save in py2, but load in py3</title>
    <url>/2019/12/11/pth-save-in-py2-but-load-in-py3/</url>
    <content><![CDATA[<h3 id="在torch-load-pth-时出现的问题：UnicodeDecodeError-39-utf-8-39-codec-can-39-t-decode-byte-0xba-in-position-0-invalid-start-byte"><a href="#在torch-load-pth-时出现的问题：UnicodeDecodeError-39-utf-8-39-codec-can-39-t-decode-byte-0xba-in-position-0-invalid-start-byte" class="headerlink" title="在torch.load(*.pth) 时出现的问题：UnicodeDecodeError: &#39;utf-8&#39; codec can&#39;t decode byte 0xba in position 0: invalid start byte"></a>在torch.load(*.pth) 时出现的问题：<code>UnicodeDecodeError: &#39;utf-8&#39; codec can&#39;t decode byte 0xba in position 0: invalid start byte</code></h3><ul>
<li><p>经过网络查询，发现是由于该文件是在 python2 下保存的，但是现在却是在python3下读取，而导致的错误</p>
</li>
<li><p>有的人给出了下面的解决方案(但是对于我是无效的)：    </p>
<p>来自：<a href="https://github.com/CSAILVision/places365/issues/25" target="_blank" rel="noopener">https://github.com/CSAILVision/places365/issues/25</a></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools import partial</span><br><span class="line">import pickle</span><br><span class="line">pickle.load = partial(pickle.load, <span class="attribute">encoding</span>=<span class="string">"latin1"</span>)</span><br><span class="line">pickle.Unpickler = partial(pickle.Unpickler, <span class="attribute">encoding</span>=<span class="string">"latin1"</span>)</span><br><span class="line">model = torch.load(model_file, <span class="attribute">map_location</span>=lambda storage, loc: storage, <span class="attribute">pickle_module</span>=pickle)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>这里给出我的解决办法</strong>   </p>
<p>（1） 在python2 环境下读取该文件，然后用 pickle来保存   </p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">tmp_data = torch.<span class="built_in">load</span>(model_file)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'tmp.pickle'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> <span class="built_in">file</span>:</span><br><span class="line">    pickle.dump(tmp_data, <span class="built_in">file</span>, protocol=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>（2）换到python3环境下，再读取pickle文件，再用torch.load来保存（这一点或可以省略）</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'tmp.pickle'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> <span class="built_in">file</span>:</span><br><span class="line">    tmp_data = pickle.<span class="built_in">load</span>(<span class="built_in">file</span>, encoding=<span class="string">'latin1'</span>)</span><br><span class="line">    </span><br><span class="line">torch.save(tmp_data, tmp_model.pth)</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy广播</title>
    <url>/2019/04/09/numpy%E5%B9%BF%E6%92%AD/</url>
    <content><![CDATA[<ul>
<li>末尾有彩蛋</li>
</ul>
<h1 id="NumPy-广播-Broadcast"><a href="#NumPy-广播-Broadcast" class="headerlink" title="NumPy 广播(Broadcast)"></a>NumPy 广播(Broadcast)</h1><p>广播(Broadcast)是 numpy 对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。</p>
<p>如果两个数组 a 和 b 形状相同，即满足 <strong>a.shape == b.shape</strong>，那么 a*b 的结果就是 a 与 b 数组对应位相乘。这要求维数相同，且各维度的长度相同。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>import numpy as np    a = np.array([1,2,3,4])  b = np.array([10,20,30,40])  c = a * b  print (c)</p>
<p>输出结果为：<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">[ <span class="number">10</span>  <span class="number">40</span>  <span class="number">90</span> <span class="number">160</span>]</span><br></pre></td></tr></table></figure></p>
<p>当运算中的 2 个数组的形状不同时，numpy 将自动触发广播机制。如：</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np    </span><br><span class="line">a = np.array([[ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],            [<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>],            [<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>],            [<span class="number">30</span>,<span class="number">30</span>,<span class="number">30</span>]]) </span><br><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) print(a + b)</span><br></pre></td></tr></table></figure>
<p>输出结果为：<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">[[ <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [<span class="number">11</span> <span class="number">12</span> <span class="number">13</span>]</span><br><span class="line"> [<span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]</span><br><span class="line"> [<span class="number">31</span> <span class="number">32</span> <span class="number">33</span>]]</span><br></pre></td></tr></table></figure></p>
<p>下面的图片展示了数组 b 如何通过广播来与数组 a 兼容。</p>
<p><img src="http://www.runoob.com/wp-content/uploads/2018/10/image0020619.gif" alt="img"></p>
<p>4x3 的二维数组与长为 3 的一维数组相加，等效于把数组 b 在二维上重复 4 次再运算。</p>
<h2 id="yayay实例"><a href="#yayay实例" class="headerlink" title="yayay实例"></a>yayay实例</h2><p>在few-shot gnn任务中，想要计算邻接矩阵A，其公式为：<strong>a<sub>ij</sub> = fc(v<sub>i</sub>-v<sub>j</sub>)</strong><br>那么问题来了得到的邻接矩阵是N×N的，则计算的差值矩阵也应该是N×N的。那么该如何高效的计算出来这个差值矩阵。<br>```python<br>import numpy as np<br>N = 10<br>D = 7<br>X = np.ones((N,D))<br>X1 = np.expand_dims(X, axis=0)<br>X2 = np.expand_dims(X, axis=1)<br>X_abs = np.abs(X1-X2)<br>X_abs = np.reshape(X_abs, (N,N,D))<br>X_T = X_abs </p>
<p>?????????????????需要考虑一下这个转置问题</p>
]]></content>
      <categories>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>python 3.3.3 字面量,正则,反斜杠和原始字符串</title>
    <url>/2019/08/14/python-3-3-3-%E5%AD%97%E9%9D%A2%E9%87%8F-%E6%AD%A3%E5%88%99-%E5%8F%8D%E6%96%9C%E6%9D%A0%E5%92%8C%E5%8E%9F%E5%A7%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<ul>
<li>注明：转载 from <a href="https://www.cnblogs.com/xiangnan/p/3446904.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiangnan/p/3446904.html</a></li>
</ul>
<h1 id="两个不起眼但是比较重要的设定"><a href="#两个不起眼但是比较重要的设定" class="headerlink" title="两个不起眼但是比较重要的设定"></a>两个不起眼但是比较重要的设定</h1><ul>
<li>Python str类型的字面量解释器</li>
</ul>
<p>当反斜杠及其紧接字符无法构成一个具有特殊含义的序列(‘recognized escape sequences’)时,Python选择保留全部字符.直接看例子:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\c'</span></span><br><span class="line"><span class="string">'\\c'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\d'</span></span><br><span class="line"><span class="string">'\\d'</span></span><br></pre></td></tr></table></figure>
<p>官方管’\c’这种序列叫’unrecognized escape sequences’.官方文档相应部分:</p>
<p>Unlike Standard C, all unrecognized escape sequences are left in the string unchanged, i.e., <em>the backslash is left in the string</em>. (This behavior is useful when debugging: if an escape sequence is mistyped, the resulting output is more easily recognized as broken.) </p>
<p>按这段英文的意思,估计C语言里面,’c’和’\c’是等同的.Python是’\\c’和’\c’等同.这个等以后学C语言再确定.</p>
<p>与上面对应的是,如果紧接字符能够和反斜杠构成’recognized escape sequences’的<strong>全部</strong>或者<strong>起始部分</strong>,中文就叫’被承认的转义序列’吧.比如:</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\b'</span></span><br><span class="line"><span class="string">'\x08'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\n'</span></span><br><span class="line"><span class="string">'\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\x'</span></span><br><span class="line"><span class="symbol">SyntaxError:</span> (unicode error) <span class="string">'unicodeescape'</span> codec can<span class="string">'t decode bytes in position 0-1: truncated \xXX escape</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; '</span>\N<span class="string">'</span></span><br><span class="line"><span class="string">SyntaxError: (unicode error) '</span>unicodeescape<span class="string">' codec can'</span>t decode bytes <span class="keyword">in</span> position <span class="number">0</span>-<span class="number">1</span>: malformed \N character escape</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\U'</span></span><br><span class="line"><span class="symbol">SyntaxError:</span> (unicode error) <span class="string">'unicodeescape'</span> codec can<span class="string">'t decode bytes in position 0-1: truncated \UXXXXXXXX escape</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; '</span>\u<span class="string">'</span></span><br><span class="line"><span class="string">SyntaxError: (unicode error) '</span>unicodeescape<span class="string">' codec can'</span>t decode bytes <span class="keyword">in</span> position <span class="number">0</span>-<span class="number">1</span>: truncated \uXXXX escape</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<ul>
<li>Python re模块正则表达式解释器</li>
</ul>
<p>当反斜杠及其紧接字符无法构成一个具有特殊含义的序列(special sequences)时,re选择忽略反斜杠,例如:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\e'</span>,<span class="string">'eee'</span>)</span><br><span class="line">[<span class="string">'e'</span>, <span class="string">'e'</span>, <span class="string">'e'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'e'</span>,<span class="string">'eee'</span>)</span><br><span class="line">[<span class="string">'e'</span>, <span class="string">'e'</span>, <span class="string">'e'</span>]</span><br></pre></td></tr></table></figure>
<p>可见,’\e’和’e’起到了完全一样的效果.Python相关文档描述是:</p>
<p>If the ordinary character is not on the list, then the resulting RE will match the second character. For example, <code>\$</code> matches the character <code>&#39;$&#39;</code>.</p>
<p>与上面对应的是,如果能够构成special sequences,那么re会解释为相应含义.例如:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\w'</span>,<span class="string">'abcdefghijklmnopqrstuvwxyz'</span>)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span>, <span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'o'</span>, <span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>, <span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>, <span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]</span><br></pre></td></tr></table></figure>
<h1 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h1><p>字面量(Literals),是用于表示一些Python内建类型的常量的符号.最常见的字面量类型是str literals 和 bytes literals.</p>
<p>比如:</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'abc'</span></span><br><span class="line"><span class="string">'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"abc"</span></span><br><span class="line"><span class="string">'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'啊哦额'</span></span><br><span class="line"><span class="string">'啊哦额'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'abc'</span></span><br><span class="line"><span class="string">b'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">r'\n'</span></span><br><span class="line"><span class="string">'\\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'啊哦额'</span></span><br><span class="line">SyntaxError: bytes can only contain ASCII literal characters.</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p>反斜杠\的用途按紧接其后的字符种类可划分为3类:</p>
<p>1.将特殊字符转换为字面量.这特殊字符包括(单引号,双引号,反斜杠):’”\</p>
<p>2.将普通字符转换为特殊序列.包括:abfNnrtuUvx0123456789.</p>
<p>(注意,bytes字面量中,NuU这三个普通字符无法被转义成特殊序列)</p>
<p>3.将”新行”和自身忽略掉.这个比较抽象,举例说明:py文件中,某个字符串太长了,以至于需要分两行写,那么你可以插个反斜杠,紧接着换行,然后写剩余字符串.</p>
<p>下面是官方文档归纳的表:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Escape Sequence</th>
<th>Meaning</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\newline</code></td>
<td>Backslash and newline ignored</td>
<td></td>
</tr>
<tr>
<td><code>\\</code></td>
<td>Backslash (<code>\</code>)</td>
<td></td>
</tr>
<tr>
<td><code>\&#39;</code></td>
<td>Single quote (<code>&#39;</code>)</td>
<td></td>
</tr>
<tr>
<td><code>\&quot;</code></td>
<td>Double quote (<code>&quot;</code>)</td>
<td></td>
</tr>
<tr>
<td><code>\a</code></td>
<td>ASCII Bell (BEL)</td>
<td></td>
</tr>
<tr>
<td><code>\b</code></td>
<td>ASCII Backspace (BS)</td>
<td></td>
</tr>
<tr>
<td><code>\f</code></td>
<td>ASCII Formfeed (FF)</td>
<td></td>
</tr>
<tr>
<td><code>\n</code></td>
<td>ASCII Linefeed (LF)</td>
<td></td>
</tr>
<tr>
<td><code>\r</code></td>
<td>ASCII Carriage Return (CR)</td>
<td></td>
</tr>
<tr>
<td><code>\t</code></td>
<td>ASCII Horizontal Tab (TAB)</td>
<td></td>
</tr>
<tr>
<td><code>\v</code></td>
<td>ASCII Vertical Tab (VT)</td>
<td></td>
</tr>
<tr>
<td><code>\ooo</code></td>
<td>Character with octal value <em>ooo</em></td>
<td>(1,3)</td>
</tr>
<tr>
<td><code>\xhh</code></td>
<td>Character with hex value <em>hh</em></td>
<td>(2,3)</td>
</tr>
</tbody>
</table>
</div>
<p>Escape sequences only recognized in string literals are:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Escape Sequence</th>
<th>Meaning</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\N{name}</code></td>
<td>Character named <em>name</em> in the Unicode database</td>
<td>(4)</td>
</tr>
<tr>
<td><code>\uxxxx</code></td>
<td>Character with 16-bit hex value <em>xxxx</em></td>
<td>(5)</td>
</tr>
<tr>
<td><code>\Uxxxxxxxx</code></td>
<td>Character with 32-bit hex value <em>xxxxxxxx</em></td>
<td>(6)</td>
</tr>
</tbody>
</table>
</div>
<p>举例:</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\N&#123;END OF LINE&#125;'</span></span><br><span class="line"><span class="string">'\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\N&#123;HORIZONTAL TABULATION&#125;'</span></span><br><span class="line"><span class="string">'\t'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\u9f6a'</span>==<span class="string">'齪'</span></span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\1'</span>==<span class="string">'\01'</span></span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\1'</span>==<span class="string">'\001'</span></span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\1'</span>==<span class="string">'\0000001'</span></span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<h1 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h1><ul>
<li>正则表达式的反斜杠的作用</li>
</ul>
<p>一种是使紧跟在后面的元字符(special characters或metacharacters)失去特殊含义,变为字面量.这些元字符有14个:</p>
<p>.^$*+?{}<a href></a>|</p>
<p>另一种是使紧跟在后面的普通字符变得具有特殊含义.这些普通字符是:</p>
<p>AbBdDsSwWZ0123456789</p>
<p>以及在str字面量中能被反斜杠转义的字符:</p>
<p>\’”abfnrtuUvx0123456789</p>
<p>例如:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\"'</span>,<span class="string">'"'</span>)</span><br><span class="line">[<span class="string">'"'</span>]</span><br></pre></td></tr></table></figure>
<p>正则pattern的反斜杠的作用和Python字面量的反斜杠类似,这据说是带来”反斜杠灾难”的根源.最典型的莫过于你需要用正则’\\\\’才能匹配字面量反斜杠’\\’.</p>
<p>为方便说明,我们假设re.search(pattern,string)中,pattern表示正则表达式字符串,string表示待匹配的字符串.</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; re.search(<span class="string">'\\\\'</span>,<span class="string">'\\'</span>)</span><br><span class="line">&lt;_sre<span class="selector-class">.SRE_Match</span> <span class="selector-tag">object</span> at <span class="number">0</span>x02858528&gt;</span><br></pre></td></tr></table></figure>
<p>详细来说就是一个文本层级的反斜杠’\’(比如你在txt文件中看到的反斜杠),对应Python str 字面量的’\\’,对应正则pattern的’\\\\’.这个确实比较难以理解,实在不行就住这点就好:<strong>如果不是最简单的正则类型(比如’ab’),强烈推荐对pattern使用r前缀符</strong>.这样容易理解:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(<span class="string">r'\\'</span>,<span class="string">'\\'</span>)</span><br><span class="line">&lt;_sre.SRE_Match object at <span class="number">0x02858448</span>&gt;</span><br></pre></td></tr></table></figure>
<p>注意:</p>
<ul>
<li>1.多重含义的特殊序列处理机制</li>
</ul>
<p>b0123456789比较特殊,它们在Python字面量和re正则中都能和反斜杠构成作用不同的特殊序列.例如\b,在python 字面量中解释为”退格键”.re正则中解释为’单词边界’.<strong>python 字面量有优先解释权</strong>,如下可证:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\b'</span>,<span class="string">'\b'</span>)  <span class="comment">#'\b'被优先解释为退格键,而不是单词边界</span></span><br><span class="line">[<span class="string">'\x08'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\b'</span>,<span class="string">'\b'</span>)</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\b'</span>,<span class="string">'b'</span>) </span><br><span class="line">[<span class="string">''</span>, <span class="string">''</span>]</span><br></pre></td></tr></table></figure>
<p>再比如:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'(a)\1\1'</span>,<span class="string">'aaa'</span>) <span class="comment">#\1按字面量优先解释为八进制字符串,因此无匹配结果</span></span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'(a)\\1\\1'</span>,<span class="string">'aaa'</span>)  <span class="comment">#\\1按正则引擎层级的反斜杠解释为第一个匹配组提取到的字符,相当于'(a)aa'</span></span><br><span class="line">[<span class="string">'a'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'a\1\1'</span>,<span class="string">'a\1\1'</span>) <span class="comment">#\1按字面量优先解释为八进制字符串,所以有匹配结果</span></span><br><span class="line">[<span class="string">'a\x01\x01'</span>]</span><br></pre></td></tr></table></figure>
<p>了解这个设置有什么用?</p>
<p>1.当你想使用正则层级的特殊序列\1时,如果你没有使用r作为前缀,那么你必须使用\\1才能如愿.</p>
<p>2.当你想使用字面量层级的特殊序列\1时,则不能使用r作为pattern前缀.</p>
<p>想想,你有可能在一个r前缀的字符串中写出能够匹配值为1的八进制字符串的pattern吗?</p>
<p>也许我太较真了,因为实践中好像从没遇到过需要匹配值为1的八进制字符串的情况,但理论上就是这样的.</p>
<ul>
<li><strong>2.正则表达式中特殊序列的准确定义的猜想</strong></li>
</ul>
<p>官方文档下面的一句话值得推敲:</p>
<p>Note that <code>\b</code> is used to represent word boundaries, and means “backspace” only inside character classes</p>
<p>意思是说\b只有在[…]里面时才表示退格键,这显然是错的.比如下面这个例子,\b没有在[]之内,但它是按”退格键”解释的,并非”单词边界”:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\b'</span>,<span class="string">'\b'</span>)</span><br><span class="line">[<span class="string">'\x08'</span>]</span><br></pre></td></tr></table></figure>
<p>除非官方文档描述的\b是指文本层面的数据(比如你在txt文档里看到的\b).</p>
<p>由此引出了一个猜想,re的正则pattern中”反斜杠+普通字符”构成特殊序列或”反斜杠+特殊字符”构成字面量—这种描述中的反斜杠准确来说是指两个反斜杠!</p>
<p>仍然是举例说明:</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\b\w+\\b'</span>,<span class="string">'one two three'</span>)  <span class="comment">#必须用\\b才能表示单词边界</span></span><br><span class="line">[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\b\\w+\\b'</span>,<span class="string">'one two three'</span>)  <span class="comment">#想想,为什么\w和\\w都一样</span></span><br><span class="line">[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\d'</span>,<span class="string">'123'</span>)</span><br><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\d'</span>,<span class="string">'123'</span>)</span><br><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<ul>
<li>3.u和U只在str字面量中才能被转义,bytes字面量中是普通字符.</li>
</ul>
<p>以下是我猜测的正则表达式分析器和Python字面量分析器的传递规则表格:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Python string literal</th>
<th>values passed to regular expression</th>
<th>number of characters</th>
<th>what regular expression engine does</th>
<th>real meaning for regular expression</th>
</tr>
</thead>
<tbody>
<tr>
<td>\e</td>
<td>\e</td>
<td>2</td>
<td>ignore the backslash</td>
<td>e</td>
</tr>
<tr>
<td>\\e</td>
<td>\e</td>
<td>2</td>
<td>ignore the backslash</td>
<td>e</td>
</tr>
<tr>
<td>e</td>
<td>e</td>
<td>1</td>
<td>nothing spacial</td>
<td>e</td>
</tr>
<tr>
<td>\n</td>
<td>\n</td>
<td>1</td>
<td>nothing spacial</td>
<td>换行符</td>
</tr>
<tr>
<td>\\n</td>
<td>\n</td>
<td>2</td>
<td>\n is special</td>
<td>换行符</td>
</tr>
<tr>
<td>\b</td>
<td>\b</td>
<td>1</td>
<td>nothing spacial</td>
<td>退格键</td>
</tr>
<tr>
<td>\\b</td>
<td>\b</td>
<td>2</td>
<td>\b is special</td>
<td>word boundary</td>
</tr>
<tr>
<td>\s</td>
<td>\s</td>
<td>2</td>
<td>\s is special</td>
<td>Unicode whitespace characters</td>
</tr>
<tr>
<td>\\</td>
<td>\</td>
<td>1</td>
<td>must followed by a charcter</td>
<td>Can’t form any meaning</td>
</tr>
<tr>
<td>\\\\</td>
<td>\\</td>
<td>2</td>
<td>remove all special meanning of \</td>
<td>\</td>
</tr>
<tr>
<td>*</td>
<td>*</td>
<td>1</td>
<td>* is special</td>
<td>repeat the left characters 0 or more times</td>
</tr>
<tr>
<td>*</td>
<td>*</td>
<td>2</td>
<td>remove all special meanning of *</td>
<td>*</td>
</tr>
</tbody>
</table>
</div>
<p>最后是待探究的例子:</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\n'</span>,<span class="string">'\n\n'</span>)</span><br><span class="line">[<span class="string">'\n'</span>, <span class="string">'\n'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\n'</span>,<span class="string">'\n\n'</span>)</span><br><span class="line">[<span class="string">'\n'</span>, <span class="string">'\n'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\\n'</span>,<span class="string">'\n\n'</span>)</span><br><span class="line">[<span class="string">'\n'</span>, <span class="string">'\n'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\\\n'</span>,<span class="string">'\n\n'</span>)</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\b'</span>,<span class="string">'\b\b'</span>)</span><br><span class="line">[<span class="string">'\x08'</span>, <span class="string">'\x08'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\b'</span>,<span class="string">'\b\b'</span>)</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\\b'</span>,<span class="string">'\b\b'</span>)</span><br><span class="line">[<span class="string">'\x08'</span>, <span class="string">'\x08'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\\\b'</span>,<span class="string">'\b\b'</span>)</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\c'</span>,<span class="string">'\c\c'</span>)</span><br><span class="line">[<span class="string">'c'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\c'</span>,<span class="string">'\c\c'</span>)</span><br><span class="line">[<span class="string">'c'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\\c'</span>,<span class="string">'\c\c'</span>)</span><br><span class="line">[<span class="string">'\\c'</span>, <span class="string">'\\c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\\\c'</span>,<span class="string">'\c\c'</span>)</span><br><span class="line">[<span class="string">'\\c'</span>, <span class="string">'\\c'</span>]</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p>参考:</p>
<p>Python 3.3.3 官方文档</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>optical flow(光流)</title>
    <url>/2019/03/23/optical-flow-%E5%85%89%E6%B5%81/</url>
    <content><![CDATA[<p>参考：<a href="https://blog.csdn.net/zouxy09/article/details/8683859" target="_blank" rel="noopener">https://blog.csdn.net/zouxy09/article/details/8683859</a></p>
<h2 id="光流的定义"><a href="#光流的定义" class="headerlink" title="光流的定义"></a>光流的定义</h2><p>在人的眼睛在观察物体时，物体的景象在人的视网膜上形成一系列连续变化的图像，这一系列连续变化的信息不断“流过”视网膜，好像一种光的流，故称之为光流。<br>一般，光流是由于场景中前景目标本身的移动、相机的移动，或者两者的共同运动所产生的。<br>定义：它是空间运动物体在观察成像平面上的像素运动的瞬时速度，是利用图像序列中<strong>像素在时间域上的变化以及相邻帧之间的相关性</strong>来找到上一帧跟当前帧之间存在的<strong>对应关系</strong>，从而计算出<strong>相邻帧</strong>之间物体的运动信息的一种方法。</p>
<h2 id="如何计算光流"><a href="#如何计算光流" class="headerlink" title="如何计算光流"></a>如何计算光流</h2><ul>
<li>那通俗的讲就是通过一个图片序列，把每张图像中每个像素的运动速度和运动方向找出来就是光流场。那怎么找呢？咱们直观理解肯定是：第t帧的时候A点的位置是(x1, y1)，那么我们在第t+1帧的时候再找到A点，假如它的位置是(x2,y2)，那么我们就可以确定A点的运动了：(ux, vy) = (x2, y2) - (x1,y1)。</li>
<li>那怎么知道第t+1帧的时候A点的位置呢？ 这就存在很多的光流计算方法了。</li>
<li>1981年，Horn和Schunck创造性地将二维速度场与灰度相联系，引入光流约束方程，得到光流计算的基本算法。人们基于不同的理论基础提出各种光流计算方法，算法性能各有不同。Barron等人对多种光流计算技术进行了总结，按照理论基础与数学方法的区别把它们分成四种：<strong>基于梯度的方法、基于匹配的方法、基于能量的方法、基于相位的方法</strong>。近年来神经动力学方法也颇受学者重视。</li>
<li><p>yaya: 即光流法计算的是：相邻两帧之间的对应像素点之间的<strong>速度矢量</strong>，但是如何得到相邻帧对应的像素点是一个问题。<br>光流法主要依赖于三个假设：</p>
<p>  [亮度恒定] 图像中目标的像素强度在连续帧之间不会发生变化。<br>  [时间规律] 相邻帧之间的时间足够短，以至于在考虑运行变化时可以忽略它们之间的差异。该假设用于导出下面的核心方程。<br>  [空间一致性] 相邻像素具有相似的运动。  </p>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1cgxrjz19j30hi0h90uo.jpg">  </p>
<p>上式中，I<sub>x</sub>,  I<sub>y</sub>可以通过图像沿x方向和y方向的导数计算，I<sub>t</sub>可以通过I(x,y,t)−I(x,y,t−1)计算。未知数是(u,v)， 正是我们想要求解的每个像素在前后相邻两帧的位移。</p>
<p>这里只有一个方程，却有两个未知数（实际是NN个方程，2N2N个未知数，NN是图像中待估计的像素点的个数，但是我们通过矩阵表示，将它们写成了如上式所述的紧凑形式），所以是一个不定方程。我们需要找出其它的约束求解方程。</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1cgxrjo7dj30g00e6ta4.jpg"><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1cgxrhmkgj30gh05swej.jpg">  </p>
<p>如上图所示，H中的像素点(x,y)在I中的移动到了(x+u,y+v)的位置，偏移量为(u,v)。速度=位移在极短时间你内的位移量。  </p>
<p>参看：<a href="https://xmfbit.github.io/2017/05/03/cs131-opticalflow/" target="_blank" rel="noopener">https://xmfbit.github.io/2017/05/03/cs131-opticalflow/</a><br>参看：<a href="https://blog.csdn.net/carson2005/article/details/7581642" target="_blank" rel="noopener">https://blog.csdn.net/carson2005/article/details/7581642</a></p>
]]></content>
      <categories>
        <category>行为识别</category>
      </categories>
      <tags>
        <tag>行为识别</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>python-dict</title>
    <url>/2019/05/08/python-dict/</url>
    <content><![CDATA[<h1 id="dict-的get-函数"><a href="#dict-的get-函数" class="headerlink" title="dict 的get 函数"></a>dict 的get 函数</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Python 字典(Dictionary) get() 函数返回指定键的值，如果值不在字典中返回默认值。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>get()方法语法：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">dict.<span class="builtin-name">get</span>(key, <span class="attribute">default</span>=None)</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li>key — 字典中要查找的键。</li>
<li>default — 如果指定键的值不存在时，返回该默认值值。</li>
</ul>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>返回指定键的值，如果值不在字典中返回默认值None。</p>
<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><p>get函数的作用是返回指定key的值，若key不存在，则返回default值，default值，默认为None，也可以自己指定</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python: list vs tuple</title>
    <url>/2019/03/20/python-list-vs-tuple/</url>
    <content><![CDATA[<ul>
<li><p><a href="https://shiyaya.github.io/2019/03/12/python%E5%9F%BA%E7%A1%80%EF%BC%9A-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-python-%E4%B8%AD%E7%9A%84%E8%B5%8B%E5%80%BC%E3%80%81%E5%BC%95%E7%94%A8%E3%80%81%E6%8B%B7%E8%B4%9D%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/" target="_blank" rel="noopener">shiyaya.github.io-python基础： 深入理解 python 中的赋值、引用、拷贝、作用域</a></p>
</li>
<li><p><a href="https://data-flair.training/blogs/python-tuples-vs-lists/" target="_blank" rel="noopener">https://data-flair.training/blogs/python-tuples-vs-lists/</a>  </p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>list</th>
<th>tuple</th>
</tr>
</thead>
<tbody>
<tr>
<td>可变对象</td>
<td>不可变对象</td>
</tr>
<tr>
<td>参数传递是传递的是引用</td>
<td>参数传递是传递的是值</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>可以修改某个元素的值</td>
<td>不可以修改某个元素的值，即不可以按索引来修改元素值</td>
</tr>
<tr>
<td>a= [1,2,3]&lt;/br&gt;b=a&lt;/br&gt;b[0]=8&lt;/br&gt;print(a) #a=[8,2,3]</td>
<td>略</td>
</tr>
<tr>
<td>可以修改slice&lt;/br&gt;del a[0:2]</td>
<td>不可以修改slice&lt;/br&gt;del a[0:2]#会提示错误</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python 关于list的操作</title>
    <url>/2019/04/18/python-%E5%85%B3%E4%BA%8Elist%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="list-的置换"><a href="#list-的置换" class="headerlink" title="list 的置换"></a>list 的置换</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">nums[<span class="number">0</span>],nums[<span class="number">1</span>] = nums[<span class="number">1</span>],nums[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># nums = [2,1,3]</span></span><br></pre></td></tr></table></figure>
<h3 id="判断是否为空列表"><a href="#判断是否为空列表" class="headerlink" title="判断是否为空列表"></a>判断是否为空列表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = []</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> a:</span><br><span class="line">    print(<span class="string">"a is a null list"</span>)</span><br><span class="line"><span class="comment"># 输出：a is a null list</span></span><br></pre></td></tr></table></figure>
<h3 id="列表的连接"><a href="#列表的连接" class="headerlink" title="列表的连接"></a>列表的连接</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">c = a + b</span><br><span class="line">print(c)  <span class="comment"># [1, 2, 3, 6, 7, 8]</span></span><br><span class="line">d = a.extend(b)  <span class="comment"># extend()传入的参数需要是一个迭代对象 ：列表、元组、集合</span></span><br><span class="line">print(d) </span><br><span class="line"><span class="comment"># d 输出为None ,因为extend 无返回值，但是此时 a更改为[1, 2, 3, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>
<h3 id="列表的排序函数"><a href="#列表的排序函数" class="headerlink" title="列表的排序函数"></a>列表的排序函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = [2,4,6,5]</span><br><span class="line">b = a.sort()  # a = [2,4,5,6] , b = None</span><br><span class="line">a= [2,4,6,5]  </span><br><span class="line">b = sorted(a)  # a = [2, 4, 6, 5] , b = [2, 4, 5, 6]</span><br><span class="line"></span><br><span class="line">## sorted() 输出的是排序的结果，但是不更改传入的列表</span><br><span class="line">## sort() 直接对列表进行排序操作，并更改列表值</span><br></pre></td></tr></table></figure>
<h3 id="列表的置换顺序函数"><a href="#列表的置换顺序函数" class="headerlink" title="列表的置换顺序函数"></a>列表的置换顺序函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">b = a.reverse() <span class="comment"># a=[4,3,2,1] b = None</span></span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于列表 nums<br>凡是可以进行 nums.function()，这样的函数，一般是无返回值的，直接对列表本身进行操作。<br>比如<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">nums.extend([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])     <span class="comment"># [1, 2, 3, 4, 1, 2, 3]</span></span><br><span class="line">nums.append(<span class="number">2</span>)           <span class="comment"># [1, 2, 3, 4, 1, 2, 3, 2]</span></span><br><span class="line">nums.sort()              <span class="comment"># [1, 1, 2, 2, 2, 3, 3, 4]</span></span><br><span class="line">nums.reverse()           <span class="comment"># [4, 3, 3, 2, 2, 2, 1, 1]</span></span><br><span class="line">nums.insert(<span class="number">5</span>,<span class="number">100</span>)       <span class="comment"># [4, 3, 3, 2, 2, 100, 2, 1, 1]    在索引为5的位置插入元素100</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>注意<br>nums.index(100)          # <strong>有返回值5</strong>, 查找对应元素<strong>首次出现</strong>所在位置的索引</li>
</ul>
<h3 id="数字转为列表-123-gt-“1”-“2”-“3”"><a href="#数字转为列表-123-gt-“1”-“2”-“3”" class="headerlink" title="数字转为列表  123 -&gt; [“1”, “2”, “3”]"></a>数字转为列表  123 -&gt; [“1”, “2”, “3”]</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">123</span></span><br><span class="line">A = list(str(num))  <span class="comment"># A = ['1', '2', '3']</span></span><br><span class="line">B = int(<span class="string">""</span>.join(A))  <span class="comment"># B = 123</span></span><br></pre></td></tr></table></figure>
<h3 id="中括号-for循环生成列表，，并使用判断"><a href="#中括号-for循环生成列表，，并使用判断" class="headerlink" title="中括号 for循环生成列表，，并使用判断"></a>中括号 for循环生成列表，，并使用判断</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">-7</span>,<span class="number">0</span>,]</span><br><span class="line">a = [<span class="number">1</span> <span class="keyword">if</span> num &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> num <span class="keyword">in</span> nums]</span><br><span class="line">print(a)   <span class="comment"># [1, 1, 0, 0]</span></span><br></pre></td></tr></table></figure>
<h2 id="python内置函数的复杂度"><a href="#python内置函数的复杂度" class="headerlink" title="python内置函数的复杂度"></a>python内置函数的复杂度</h2><p><a href="https://wiki.python.org/moin/TimeComplexity" target="_blank" rel="noopener">https://wiki.python.org/moin/TimeComplexity</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python list sort方法</title>
    <url>/2019/04/04/python-list-sort%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><strong>sort()</strong> 函数用于对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>sort()方法语法：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">list.sort(<span class="attribute">cmp</span>=None, <span class="attribute">key</span>=None, <span class="attribute">reverse</span>=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li>cmp — 可选参数, 如果指定了该参数会使用该参数的方法进行排序。</li>
<li>key — 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</li>
<li>reverse — 排序规则，<strong>reverse = True</strong> 降序， <strong>reverse = False</strong> 升序（默认）。</li>
</ul>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>该方法没有返回值，但是会对列表的对象进行排序。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">video_sort_lambda = <span class="keyword">lambda</span> x: int(x[<span class="number">3</span>:<span class="number">-4</span>]) <span class="comment"># 定义一个函数对元素x进行操作，并得到一个整数Int</span></span><br><span class="line">video_root = <span class="string">"/userhome/dataset/MSVD/Video-Description-with-Spatial-Temporal-Attention/youtube"</span></span><br><span class="line">videos = sorted(os.listdir(video_root), key=video_sort_lambda) <span class="comment"># 按得到的整数，对list进行排序</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python 函数</title>
    <url>/2019/04/10/python-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>python  面试</title>
    <url>/2019/03/12/python-%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p><a href="https://juejin.im/post/5b6bc1d16fb9a04f9c43edc3" target="_blank" rel="noopener">https://juejin.im/post/5b6bc1d16fb9a04f9c43edc3</a></p>
<p><a href="https://juejin.im/post/5b8505b6e51d4538884d22bf" target="_blank" rel="noopener">https://juejin.im/post/5b8505b6e51d4538884d22bf</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础： 深入理解 python 中的赋值、引用、拷贝、作用域</title>
    <url>/2019/03/12/python%E5%9F%BA%E7%A1%80%EF%BC%9A-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-python-%E4%B8%AD%E7%9A%84%E8%B5%8B%E5%80%BC%E3%80%81%E5%BC%95%E7%94%A8%E3%80%81%E6%8B%B7%E8%B4%9D%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h3 id="浅复制："><a href="#浅复制：" class="headerlink" title="浅复制："></a>浅复制：</h3><ul>
<li>仅复制对象的引用，而不开辟内存，即，改变复制后的对象时，其实是在改变原对象内存中的内容。</li>
<li>b = a[ : ]<h3 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a>深复制</h3>将开辟新的内存，把原对象内存中的内容复制到新的内存中来，如果改变复制后的对象，将改变原对象的内容。即，这两个对象在完成复制之后，已经是两个独立的对象了</li>
</ul>
<p><strong>- 转载： <a href="https://draapho.github.io/2016/11/21/1618-python-variable/" target="_blank" rel="noopener">https://draapho.github.io/2016/11/21/1618-python-variable/</a></strong></p>
<h3 id="可变对象：list-dict-set-（引用传递）"><a href="#可变对象：list-dict-set-（引用传递）" class="headerlink" title="可变对象：list dict set  （引用传递）"></a>可变对象：list dict set  （引用传递）</h3><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">   <span class="meta"># list</span></span><br><span class="line">a= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">9</span></span><br><span class="line"><span class="keyword">print</span>(b) <span class="meta"># [9, 2, 3]</span></span><br><span class="line"><span class="keyword">print</span>(a) <span class="meta"># [9, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># dict</span></span><br><span class="line">a = &#123;&#125;</span><br><span class="line">a['key1'] = <span class="number">1</span></span><br><span class="line">b = a</span><br><span class="line">b['key1'] = <span class="number">9</span></span><br><span class="line"><span class="keyword">print</span>(b) <span class="meta"># &#123;'key1': 9&#125;</span></span><br><span class="line"><span class="keyword">print</span>(a) <span class="meta"># &#123;'key1': 9&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]  </span><br><span class="line">values[<span class="number">1</span>] = values  </span><br><span class="line">values  </span><br><span class="line">[<span class="number">0</span>, [...], <span class="number">2</span>] # 实际结果, 为何要赋值无限次?  </span><br><span class="line">[<span class="number">0</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="number">2</span>] # 预想结果</span><br></pre></td></tr></table></figure>
<p>   Python 没有赋值，只有引用。你这样相当于创建了一个引用自身的结构，所以导致了无限循环</p>
<h3 id="不可变对象：tuple-string-int-float-bool-（值传递）"><a href="#不可变对象：tuple-string-int-float-bool-（值传递）" class="headerlink" title="不可变对象：tuple string int float bool （值传递）"></a>不可变对象：<strong><em>tuple</em></strong> string int float bool （值传递）</h3><p>对于可变对象，对象的操作不会重建对象，而对于不可变对象，每一次操作就重建新的对象。</p>
<pre><code>def func_int(a):
    a += 4

def func_list(a_list):
    a_list[0] = 4

t = 0
func_int(t)
print t
# output: 0

t_list = [1, 2, 3]
func_list(t_list)
print t_list
# output: [4, 2, 3]
</code></pre><h3 id="Dictionary-与-List-与-Tuple的区别"><a href="#Dictionary-与-List-与-Tuple的区别" class="headerlink" title="Dictionary 与 List 与 Tuple的区别"></a>Dictionary 与 List 与 Tuple的区别</h3><p>元组和列表在结构上没有什么区别，唯一的差异在于元组是只读的，不能修改。</p>
<p><strong>Dictionary</strong> </p>
<ol>
<li>Dictionary 是 Python 的内置数据类型之一, 它定义了键和值之间一对一的关系。</li>
<li>每一个元素都是一个 key-value 对, 整个元素集合用大括号括起来</li>
<li>您可以通过 key 来引用其值, 但是不能通过值获取 key</li>
<li>在一个 dictionary 中不能有重复的 key。给一个存在的 key 赋值会覆盖原有的值。 <a href="file:///home/echo/.chmsee/bookshelf/4791a2294b7b1d4cf68b0e1df606181d/native_data_types/index.html#odbchelper.dict.2.2" target="_blank" rel="noopener"><img src="file:///home/echo/.chmsee/bookshelf/4791a2294b7b1d4cf68b0e1df606181d/images/callouts/2.png" alt="2"></a> 在任何时候都可以加入新的 key-value 对。这种语法同修改存在的值是一样的。</li>
<li>当使用 dictionary 时, 您需要知道: dictionary 的 key 是大小写敏感的</li>
<li>Dictionary 不只是用于存储字符串。Dictionary 的值可以是任意数据类型, 包括字符串, 整数, 对象, 甚至其它的 dictionary。在单个 dictionary 里, dictionary 的值并不需要全都是同一数据类型, 可以根据需要混用和匹配。 Dictionary 的 key 要严格多了, 但是它们可以是字符串, 整数和几种其它的类型 (后面还会谈到这一点) 。也可以在一个 dictionary 中混用和配匹 key 的数据类型</li>
<li><code>del</code> 允许您使用 key 从一个 dictionary 中删除独立的元素。</li>
<li><code>clear</code> 从一个 dictionary 中清除所有元素。注意空的大括号集合表示一个没有元素的 dictionary。</li>
</ol>
<hr>
<p><strong>List</strong> </p>
<ol>
<li>list是一个使用方括号括起来的有序元素集合。</li>
<li>List 可以作为以 0 下标开始的数组。任何一个非空 list 的第一个元素总是 <code>li[0]</code></li>
<li><code>负数索引从 list 的尾部开始向前计数来存取元素。任何一个非空的 list 最后一个元素总是</code> li[-1]。 <a href="file:///home/echo/.chmsee/bookshelf/4791a2294b7b1d4cf68b0e1df606181d/native_data_types/lists.html#odbchelper.list.2.2" target="_blank" rel="noopener"><img src="file:///home/echo/.chmsee/bookshelf/4791a2294b7b1d4cf68b0e1df606181d/images/callouts/2.png" alt="2"></a>如果负数索引使您感到糊涂, 可以这样理解: <code>li[-n] == li[len(li) - n]</code>。 所以在这个 list 里, <code>li[-3] == li[5 - 3] == li[2]</code>。</li>
<li><code>您可以通过指定 2 个索引得到 list 的子集, 叫做一个 “slice” 。返回值是一个新的 list, 它包含了 list 中按顺序从第一个 slice 索引 (这里为</code> li[1]) 开始, 直到但是不包括第二个 slice 索引 (这里为<code>li[3]</code>) 的所有元素。</li>
<li><code>如果将两个分片索引全部省略, 这将包括 list 的所有元素。但是与原始的名为</code> li 的 list 不同, 它是一个新 list, 恰好拥有与 <code>li</code> 一样的全部元素。<code>li[:]</code> 是生成一个 list 完全拷贝的一个简写。</li>
<li><code>``append</code> 向 list 的末尾追加单个元素。</li>
<li><code>insert</code> 将单个元素插入到 list 中。数值参数是插入点的索引。请注意, list 中的元素不必唯一, 有有两个独立的元素具有 <code>&#39;new&#39;</code> 这个相同的值<code>。</code></li>
<li><code>extend</code> 用来连接 list。请注意不要使用多个参数来调用 <code>extend</code>, 要使用一个 list 参数进行调用。</li>
<li>Lists 的两个方法 <code>extend</code> 和 <code>append</code> 看起来类似, 但实际上完全不同。 <code>extend</code> 接受一个参数, 这个参数总是一个 list, 并且添加这个 list 中的每个元素到原 list 中</li>
<li>另一方面, <code>append</code> 接受一个参数, 这个参数可以是任何数据类型, 并且简单地追加到 list 的尾部。 在这里使用一个含有 3 个元素的 list 参数调用 <code>append</code> 方法。</li>
<li><code>index</code> 在 list 中查找一个值的首次出现并返回索引值。</li>
<li>要测试一个值是否在 list 内, 使用 <code>in</code>, 如果值存在, 它返回 <code>True</code>, 否则返为 <code>False</code> 。</li>
<li><code>remove</code> 从 list 中删除一个值的首次出现。</li>
<li><code>pop</code> 是一个有趣的东西。它会做两件事: 删除 list 的最后一个元素, 然后返回删除元素的值。请注意, 这与 <code>li[-1]</code> 不同, 后者返回一个值但不改变 list 本身。也不同于 <code>li.remove(*value*)</code>, 后者改变 list 但并不返回值。</li>
<li>Lists 也可以用 <code>+</code> 运算符连接起来。 <code>*list* = *list* + *otherlist*</code> 相当于 <code>*list*.extend(*otherlist*)</code>。 但 <code>+</code>运算符把一个新 (连接后) 的 list 作为值返回, 而 <code>extend</code> 只修改存在的 list。 也就是说, 对于大型 list 来说, <code>extend</code> 的执行速度要快一些。</li>
<li>Python 支持 <code>+=</code> 运算符。 <code>li += [&#39;two&#39;]</code> 等同于 <code>li.extend([&#39;two&#39;])</code>。 <code>+=</code> 运算符可用于 list, 字符串和整数, 并且它也可以被重载用于用户自定义的类中。</li>
<li><code>*</code> 运算符可以作为一个重复器作用于 list。 <code>li = [1, 2] * 3</code> 等同于 <code>li = [1, 2] + [1, 2] + [1, 2]</code>, 即将三个 list 连接成一个。</li>
</ol>
<hr>
<p><strong>Tuple</strong></p>
<ol>
<li>​    Tuple是不可变的list.一是创建了一个tuple就不能以任何方式改变它.</li>
<li>​    定义tuple与定义list的方式相同,除了整个元素集是用小括号包围的而不是方括号.</li>
<li>　 Tuple的元素与list一样按定义的次序进行排序.Tuples的索引与list一样从0开始,所以一个非空的tuple的第一个元素总是t[0].</li>
<li>​    负数索引与 list 一样从 tuple 的尾部开始计数。</li>
<li>​    与 list 一样分片 (slice) 也可以使用。注意当分割一个 list 时, 会得到一个新的 list ；当分割一个 tuple 时, 会得到一个新的 tuple。</li>
<li>​    Tuple 没有方法：没有 <code>append</code> 或 <code>extend</code> 方法、没有 <code>remove</code> 或 <code>pop</code> 方法、没有 <code>index</code> 方法、可以使用 <code>in</code> 来查看一个元素是否存在于 tuple 中。</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础知识-try与except处理异常语句</title>
    <url>/2019/03/19/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-try%E4%B8%8Eexcept%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h2 id="try-except介绍"><a href="#try-except介绍" class="headerlink" title="try/except介绍"></a>try/except介绍</h2><blockquote>
<p>与其他语言相同，在python中，try/except语句主要是用于处理程序正常执行过程中出现的一些异常情况，如语法错（python作为脚本语言没有编译的环节，在执行过程中对语法进行检测，出错后发出异常消息）、数据除零错误、从未定义的变量上取值等；而try/finally语句则主要用于在无论是否发生异常情况，都需要执行一些清理工作的场合，如在通信过程中，无论通信是否发生错误，都需要在通信完成或者发生错误时关闭网络连接。尽管<strong>try/except和**</strong>try/finally**的作用不同，但是在编程实践中通常可以把它们组合在一起使用try/except/else/finally的形式来实现稳定性和灵活性更好的设计。</p>
<p>默认情况下，在程序段的执行过程中，如果没有提供try/except的处理，脚本文件执行过程中所产生的异常消息会自动发送给程序调用端，如python shell，而python shell对异常消息的默认处理则是终止程序的执行并打印具体的出错信息。这也是在python shell中执行程序错误后所出现的出错打印信息的由来。</p>
</blockquote>
<h2 id="try-except格式"><a href="#try-except格式" class="headerlink" title="try/except格式"></a>try/except格式</h2><blockquote>
<p>python中try/except/else/finally语句的完整格式如下所示：</p>
<p>try:</p>
<p>​     Normal execution block</p>
<p>except A:</p>
<p>​     Exception A handle</p>
<p>except B:</p>
<p>​     Exception B handle</p>
<p>except:</p>
<p>​     Other exception handle</p>
<p>else:</p>
<p>​     if no exception,get here</p>
<p>finally:</p>
<p>​     print(“finally”)   </p>
<p>说明：</p>
<p>正常执行的程序在try下面的Normal execution block执行块中执行，在执行过程中如果发生了异常，则<strong>中断当前在Normal execution block中的执行</strong>，跳转到对应的异常处理块中开始执行；</p>
<p>python<strong>从第一个except X处开始查找</strong>，如果找到了对应的exception类型则进入其提供的exception handle中进行处理，如果没有找到则直接进入except块处进行处理。except块是可选项，如果没有提供，该exception将会被提交给python进行默认处理，处理方式则是<strong>终止应用程序并打印提示信息</strong>；</p>
<p>如果在Normal execution block执行块中执行过程中没有发生任何异常，则在执行完Normal execution block后会进入else执行块中（如果存在的话）执行。</p>
<p>无论是否发生了异常，只要提供了finally语句，以上try/except/else/finally代码块执行的最后一步总是执行finally所对应的代码块。</p>
<p>需要注意的是：</p>
<p>1.在上面所示的完整语句中try/except/else/finally所出现的顺序必须是try—&gt;except X—&gt;except—&gt;else—&gt;finally，即所有的<strong>except必须在else和finally之前</strong>，<strong>else（如果有的话）必须在finally之前</strong>，而<strong>except X必须在except之前</strong>。否则会出现语法错误。</p>
<p>2.对于上面所展示的try/except完整格式而言，else和finally都是可选的，而不是必须的，但是如果存在的话e<strong>lse必须在finally之前</strong>，<strong>finally</strong>（如果存在的话）<strong>必须在整个语句的最后位置</strong>。</p>
<p>3.在上面的完整语句中，else语句的存在必须以except X或者except语句为前提，<strong>如果在没有except语句的try block中使用else语句会引发语法错误</strong>。也就是说<strong>else不能与try/finally配合使用</strong>。</p>
</blockquote>
<p>4.except的使用要非常小心，慎用。</p>
<p>class AError(Exception):<br>     “””AError—-exception”””<br>     print(‘AError’)</p>
<blockquote>
<p>try:</p>
<p>​     #raise AError</p>
<p>​     asdas(‘123’)</p>
<p>except AError:</p>
<p>​     print(“Get AError”)</p>
<p>except:</p>
<p>​     print(“exception”)     </p>
<p>else:</p>
<p>​     print(“else”)</p>
<p>finally:</p>
<p>​     print(“finally”)     </p>
<p>print(“hello wolrd”)</p>
<p>在上面的代码中，Normal execution block中出现了语法错误，但是由于使用了except语句，该语法错误就被掩盖掉了。因此在使用try/except是最好还是要非常清楚的知道Normal execution block中有可能出现的异常类型以进行针对性的处理。</p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python类的继承</title>
    <url>/2019/04/08/python%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<ul>
<li>参考：<a href="https://www.cnblogs.com/bigberg/p/7182741.html" target="_blank" rel="noopener">https://www.cnblogs.com/bigberg/p/7182741.html</a>  </li>
</ul>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><h3 id="1-继承的定义"><a href="#1-继承的定义" class="headerlink" title="1. 继承的定义"></a>1. 继承的定义</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span>   <span class="comment"># 定义一个父类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span>    <span class="comment"># 父类中的方法</span></span><br><span class="line">        print(<span class="string">"person is talking...."</span>)  </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span><span class="params">(Person)</span>:</span>    <span class="comment"># 定义一个子类， 继承Person类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">walk</span><span class="params">(self)</span>:</span>      <span class="comment"># 在子类中定义其自身的方法</span></span><br><span class="line">        print(<span class="string">'is walking...'</span>)</span><br><span class="line"> </span><br><span class="line">c = Chinese()</span><br><span class="line">c.talk()      <span class="comment"># 调用继承的Person类的方法</span></span><br><span class="line">c.walk()     <span class="comment"># 调用本身的方法</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<blockquote>
<p>person is talking….<br>is walking…</p>
<h2 id="2-构造函数的继承"><a href="#2-构造函数的继承" class="headerlink" title="2. 构造函数的继承"></a>2. 构造函数的继承</h2><p>如果我们要给实例 c 传参，我们就要使用到构造函数，那么构造函数该如何继承，同时子类中又如何定义自己的属性？</p>
</blockquote>
<p>继承类的构造方法：<br>1.经典类的写法： 父类名称.<strong>init</strong>(self,参数1，参数2，…)  </p>
<ol>
<li><font color="#0059ff" size="5" face="黑体"> 新式类的写法：super(子类，self).__init__(参数1，参数2，....)</font>

</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span>  </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span>  </span><br><span class="line">        self.name = name  </span><br><span class="line">        self.age = age  </span><br><span class="line">        self.weight = <span class="string">'weight'</span>  </span><br><span class="line">  </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        print(<span class="string">"person is talking...."</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span><span class="params">(Person)</span>:</span>  </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, language)</span>:</span>  <span class="comment"># 先继承，在重构  </span></span><br><span class="line">		Person.__init__(self, name, age)  </span><br><span class="line">		<span class="comment"># 继承父类的构造方法，也可以写成：</span></span><br><span class="line">		<span class="comment"># super(Chinese,self).__init__(name,age)  </span></span><br><span class="line">        self.language = language  <span class="comment"># 定义类的本身属性  </span></span><br><span class="line">  </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">walk</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        print(<span class="string">'is walking...'</span>)  </span><br><span class="line">        </span><br><span class="line">c = Chinese(<span class="string">'bigberg'</span>, <span class="number">22</span>, <span class="string">'Chinese'</span>)  </span><br><span class="line">print(c.name)  </span><br><span class="line">print(c.language)</span><br><span class="line">c.talk()</span><br></pre></td></tr></table></figure>
<p>输出</p>
<blockquote>
<p>bigberg<br>Chinese<br>person is talking….</p>
</blockquote>
<h3 id="3-子类对父类方法的重写"><a href="#3-子类对父类方法的重写" class="headerlink" title="3.子类对父类方法的重写"></a>3.子类对父类方法的重写</h3><p>如果我们对基类/父类的方法需要修改，可以在子类中重构该方法。如下的talk()方法<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span>  </span><br><span class="line">        self.name = name  </span><br><span class="line">        self.age = age  </span><br><span class="line">        self.weight = <span class="string">'weight'</span>  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        print(<span class="string">"person is talking...."</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span><span class="params">(Person)</span>:</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, language)</span>:</span>  </span><br><span class="line">        Person.__init__(self, name, age)  </span><br><span class="line">        self.language = language  </span><br><span class="line">        print(self.name, self.age, self.weight, self.language)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span>  <span class="comment"># 子类 重构方法  </span></span><br><span class="line">  print(<span class="string">'%s is speaking chinese'</span> % self.name)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">walk</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        print(<span class="string">'is walking...'</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">c = Chinese(<span class="string">'bigberg'</span>, <span class="number">22</span>, <span class="string">'Chinese'</span>)  </span><br><span class="line">c.talk()</span><br></pre></td></tr></table></figure></p>
<p>输出</p>
<blockquote>
<p>bigberg 22 weight Chinese<br>bigberg is speaking chinese</p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch-Multi-Gpus</title>
    <url>/2019/03/02/pytorch-Multi-Gpus/</url>
    <content><![CDATA[<ul>
<li>源为pytorch的官方文档</li>
<li><a href="https://pytorch.org/tutorials/beginner/blitz/data_parallel_tutorial.html" target="_blank" rel="noopener">website</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset, DataLoader</span><br><span class="line"></span><br><span class="line"><span class="comment"># Parameters and DataLoaders</span></span><br><span class="line">input_size = <span class="number">5</span></span><br><span class="line">output_size = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">30</span></span><br><span class="line">data_size = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="comment"># Our model</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_size, output_size)</span>:</span></span><br><span class="line">        super(Model, self).__init__()</span><br><span class="line">        self.fc = nn.Linear(input_size, output_size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, input)</span>:</span></span><br><span class="line">        output = self.fc(input)</span><br><span class="line">        print(<span class="string">"\tIn Model: input size"</span>, input.size(),</span><br><span class="line">              <span class="string">"output size"</span>, output.size())</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomDataset</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, size, length)</span>:</span></span><br><span class="line">        self.len = length</span><br><span class="line">        self.data = torch.randn(length, size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.data[index]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.len</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rand_loader = DataLoader(dataset=RandomDataset(input_size, data_size), batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">model = Model(input_size, output_size)</span><br><span class="line"><span class="keyword">if</span> torch.cuda.device_count() &gt; <span class="number">1</span>:</span><br><span class="line">    print(<span class="string">"Let's use"</span>, torch.cuda.device_count(), <span class="string">"GPUs!"</span>)</span><br><span class="line">    <span class="comment"># dim = 0 [30, xxx] -&gt; [10, ...], [10, ...], [10, ...] on 3 GPUs</span></span><br><span class="line">    model = nn.DataParallel(model)</span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">"cuda:0"</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line">model.to(device)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> rand_loader:</span><br><span class="line">    input = data.to(device)</span><br><span class="line">    output = model(input)</span><br><span class="line">    print(<span class="string">"Outside: input size"</span>, input.size(),</span><br><span class="line">          <span class="string">"output_size"</span>, output.size())</span><br></pre></td></tr></table></figure>
<h2 id="转载：-PyTorch-论文pytorch复现中遇到的BUG"><a href="#转载：-PyTorch-论文pytorch复现中遇到的BUG" class="headerlink" title="转载：[PyTorch]论文pytorch复现中遇到的BUG]"></a>转载：<a href="https://www.cnblogs.com/kk17/p/10139884.html" target="_blank" rel="noopener">[PyTorch]论文pytorch复现中遇到的BUG]</a></h2><ul>
<li>我在Multi-GPUs时，也遇到了第一个问题</li>
</ul>
<p>目录</p>
<ul>
<li><a href="https://www.cnblogs.com/kk17/p/10139884.html#zip-argument-1-must-support-iteration" target="_blank" rel="noopener">1. zip argument #1 must support iteration</a></li>
<li><a href="https://www.cnblogs.com/kk17/p/10139884.html#torch.nn.dataparallel" target="_blank" rel="noopener">2. torch.nn.DataParallel</a></li>
<li><a href="https://www.cnblogs.com/kk17/p/10139884.html#model.state_dict" target="_blank" rel="noopener">3. model.state_dict()</a></li>
</ul>
<h1 id="1-zip-argument-1-must-support-iteration"><a href="#1-zip-argument-1-must-support-iteration" class="headerlink" title="1. zip argument #1 must support iteration"></a>1. zip argument #1 must support iteration</h1><p>在多gpu训练的时候，自动把你的batch_size分成n_gpu份，每个gpu跑一些数据， 最后再合起来。我之所以出现这个bug是因为返回的时候 返回了一个常量。。</p>
<h1 id="2-torch-nn-DataParallel"><a href="#2-torch-nn-DataParallel" class="headerlink" title="2. torch.nn.DataParallel"></a>2. torch.nn.DataParallel</h1><p>在使用torch.nn.DataParallel时候，要先把模型放在gpu上，再进行parallel。</p>
<h1 id="3-model-state-dict"><a href="#3-model-state-dict" class="headerlink" title="3. model.state_dict()"></a>3. model.state_dict()</h1><p>一般在现有的网络加载预训练模型通常是找到预训练模型在现有的model里面的参数，然后model进行更新，遇到一个bug， 发现加载预训练模型的时候， 效果很差，跟参数没有更新一样，找了一大顿bug，最后才发现，之前是单gpu进行的预训练，现在的模型使用的是多gpu， 打印现在模型的参数你会发现他所有的参数前面都加了一个module. 所以向以前一样更新，没有一个参数会被更新，因此写了一个万能模型参数加载函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pretrained_dict = checkpoint[<span class="string">'state_dict'</span>]</span><br><span class="line">model_dict = self.model.state_dict()</span><br><span class="line"><span class="keyword">if</span> checkpoint[<span class="string">'config'</span>][<span class="string">'n_gpu'</span>] &gt; <span class="number">1</span> <span class="keyword">and</span> self.config[<span class="string">'n_gpu'</span>] == <span class="number">1</span>:</span><br><span class="line">    new_dict = OrderedDict()</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> pretrained_dict.items():</span><br><span class="line">        name = k[<span class="number">7</span>:]</span><br><span class="line">        new_dict[name] = v</span><br><span class="line">    pretrained_dict = new_dict</span><br><span class="line"><span class="keyword">elif</span> checkpoint[<span class="string">'config'</span>][<span class="string">'n_gpu'</span>] == <span class="number">1</span> <span class="keyword">and</span> self.config[<span class="string">'n_gpu'</span>] &gt; <span class="number">1</span>:</span><br><span class="line">    new_dict = OrderedDict()</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> pretrained_dict.items():</span><br><span class="line">        name = <span class="string">"module."</span>+k</span><br><span class="line">        new_dict[name] = v</span><br><span class="line">    pretrained_dict = new_dict</span><br><span class="line">print(<span class="string">"The pretrained model's para is following"</span>)</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> pretrained_dict.items():</span><br><span class="line">    print(k)</span><br><span class="line">pretrained_dict = &#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> pretrained_dict.items() <span class="keyword">if</span> k <span class="keyword">in</span> model_dict&#125;</span><br><span class="line">model_dict.update(pretrained_dict)</span><br><span class="line">self.model.load_state_dict(model_dict)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch 减小显存消耗，优化显存使用，避免out of memory</title>
    <url>/2019/04/03/pytorch-%E5%87%8F%E5%B0%8F%E6%98%BE%E5%AD%98%E6%B6%88%E8%80%97%EF%BC%8C%E4%BC%98%E5%8C%96%E6%98%BE%E5%AD%98%E4%BD%BF%E7%94%A8%EF%BC%8C%E9%81%BF%E5%85%8Dout-of-memory/</url>
    <content><![CDATA[<h3 id="本文是整理了大神的两篇博客："><a href="#本文是整理了大神的两篇博客：" class="headerlink" title="本文是整理了大神的两篇博客："></a>本文是整理了大神的两篇博客：</h3><ul>
<li><p>如何计算模型以及中间变量的显存占用大小：<br><a href="https://oldpan.me/archives/how-to-calculate-gpu-memory" target="_blank" rel="noopener">https://oldpan.me/archives/how-to-calculate-gpu-memory</a></p>
</li>
<li><p>如何在Pytorch中精细化利用显存：<br><a href="https://oldpan.me/archives/how-to-use-memory-pytorch" target="_blank" rel="noopener">https://oldpan.me/archives/how-to-use-memory-pytorch</a></p>
</li>
<li><p>还有知乎中大神的解答：<br><a href="https://zhuanlan.zhihu.com/p/31558973" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31558973</a></p>
</li>
<li><p>ppt<br><a href="https://www.zhihu.com/question/67209417" target="_blank" rel="noopener">https://www.zhihu.com/question/67209417</a></p>
</li>
<li><p>在说之前先推荐一个实时监控内存显存使用的小工具：</p>
</li>
</ul>
<blockquote>
<p>sudo apt-get install htop</p>
</blockquote>
<ul>
<li>监控内存（-d为更新频率，下为每0.1s更新一次）：</li>
</ul>
<blockquote>
<p>htop -d=0.1</p>
</blockquote>
<ul>
<li>监控显存（-n为更新频率，下为每0.1s更新一次）：</li>
</ul>
<blockquote>
<p>watch -n 0.1 nvidia-smi</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title> pytorch clone() vs copy_()</title>
    <url>/2019/08/06/pytorch-clone-vs-copy/</url>
    <content><![CDATA[<p><code>clone</code>() → Tensor</p>
<ul>
<li>反向传播时，将会返回到原来的变量上<br>Returns a copy of the <code>self</code> tensor. The copy has the same size and data type as <code>self</code>.</li>
<li>NOTE</li>
<li>Unlike copy_(), this function is recorded in the computation graph. Gradients propagating to the cloned tensor will propagate to the original tensor.</li>
</ul>
<hr>
<p><code>copy_</code>(<em>src</em>, <em>non_blocking=False</em>) → Tensor</p>
<ul>
<li><p>只是值得复制<br>Copies the elements from <code>src</code> into <code>self</code> tensor and returns <code>self</code>.</p>
</li>
<li><p>The <code>src</code> tensor must be <a href="https://pytorch.org/docs/stable/notes/broadcasting.html#broadcasting-semantics" target="_blank" rel="noopener">broadcastable</a> with the <code>self</code> tensor. It may be of a different data type or reside on a different device.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch-gather</title>
    <url>/2019/07/12/pytorch-gather/</url>
    <content><![CDATA[<p>函数<code>torch.gather(input, dim, index, out=None) → Tensor</code><br> 沿给定轴 dim ,将输入索引张量 index 指定位置的值进行聚合.<br> 对一个 3 维张量,输出可以定义为:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">out[<span class="string">i</span>][<span class="symbol">j</span>][<span class="string">k</span>] = input[<span class="string">index[i</span>][<span class="symbol">j</span>][<span class="string">k</span>]][<span class="string">j</span>][<span class="symbol">k</span>]  # if dim == 0</span><br><span class="line">out[<span class="string">i</span>][<span class="symbol">j</span>][<span class="string">k</span>] = input[<span class="string">i</span>][<span class="symbol">index[i</span>][<span class="string">j</span>][<span class="symbol">k</span>]][<span class="symbol">k</span>]  # if dim == 1</span><br><span class="line">out[<span class="string">i</span>][<span class="symbol">j</span>][<span class="string">k</span>] = input[<span class="string">i</span>][<span class="symbol">j</span>][<span class="string">index[i</span>][<span class="symbol">j</span>][<span class="string">k</span>]]  # if dim == 2</span><br></pre></td></tr></table></figure>
<p>Parameters:</p>
<ul>
<li>input (Tensor) – 源张量</li>
<li>dim (int) – 索引的轴</li>
<li>index (LongTensor) – 聚合元素的下标(index需要是torch.longTensor类型)</li>
<li>out (Tensor, optional) – 目标张量</li>
</ul>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch 索引 切片</title>
    <url>/2019/10/10/pytorch-%E7%B4%A2%E5%BC%95-%E5%88%87%E7%89%87/</url>
    <content><![CDATA[<h2 id="给出：四维张量，三维的索引。根据索引得到张量中对应的数据"><a href="#给出：四维张量，三维的索引。根据索引得到张量中对应的数据" class="headerlink" title="给出：四维张量，三维的索引。根据索引得到张量中对应的数据"></a>给出：四维张量，三维的索引。根据索引得到张量中对应的数据</h2><ul>
<li><p>四维张量，object_feats.shape = [bs, 28, 5, 1024]。一个video中截取 28帧，每帧提取5个object, 其特征向量维度为1024</p>
</li>
<li><p>三维索引，traj_idx.shape = [bs, 28, 5]。以第一帧 frame上的 5个object 作为anchor，找到以该anchor 作为开头的轨迹（即，在其余帧上的对应的objects的索引），</p>
</li>
<li><p>目标：由索引，提取对应的 object feature</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">traj_feats = object_feats.gather(<span class="number">2</span>, traj_idx.unsqueeze(<span class="number">3</span>).expand_as(object_feats))</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch0.4.0学习</title>
    <url>/2019/04/18/pytorch0-4-0%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="不会的"><a href="#不会的" class="headerlink" title="不会的"></a>不会的</h2><ol>
<li>SGD 、 Adam中 的weight_decay 是干嘛的</li>
<li>SGD 中的 momentum是干嘛的，一般设置为多大</li>
<li>pytorch 中的初始化函数 </li>
<li>y = y.permute(0, 2, 1).contiguous()<br>这是干嘛的</li>
</ol>
<h3 id="学会的"><a href="#学会的" class="headerlink" title="学会的"></a>学会的</h3><ul>
<li>累加loss<br>以前（0.3.0）了累加loss(为了看loss的大小)一般是用total_loss+=loss.data[0] , 比较诡异的是, 为啥是.data[0]? 这是因为, 这是因为loss是一个Variable,<br>所以以后累加loss, 用loss.item().这个是必须的, 如果直接加, 那么随着训练的进行, 会导致后来的loss具有非常大的graph, 可能会超内存.<br>然而total_loss只是用来看的, 所以没必要进行维持这个graph!</li>
</ul>
<h3 id="pytorch-中-对tensor的一些函数"><a href="#pytorch-中-对tensor的一些函数" class="headerlink" title="pytorch 中 对tensor的一些函数"></a>pytorch 中 对tensor的一些函数</h3><ul>
<li><p>生成正态分布的随机张量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.randn(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)  <span class="comment"># 正态分布的随机张量</span></span><br><span class="line">a.sum()                 <span class="comment"># 对a中的元素求和</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对tensor 求最大值</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="keyword">a</span> = torch.randn(<span class="number">10</span>,<span class="number">8</span>)</span><br><span class="line">max_value, max_index = <span class="keyword">a</span>.<span class="built_in">max</span>(<span class="number">1</span>)   </span><br><span class="line"><span class="comment"># 按照维度对a求最大值 ，此处为1，即得到（10,1）的张量，</span></span><br><span class="line"><span class="comment"># 有两个返回值，第一个返回值为具体的最大值为多少，第二个返回值为该最大值所在的索引</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>判断两数有多少个元素相等</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">a = torch.tensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">b = torch.tensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>])</span><br><span class="line">a.eq(b)   # 输出 tensor([ <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">0</span>], dtype=torch.uint8)</span><br></pre></td></tr></table></figure>
</li>
<li><p>批矩阵相乘</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"># 批矩阵相乘 pytorch <span class="number">0.3</span><span class="number">.0</span></span><br><span class="line">output = torch.bmm(W, x)</span><br><span class="line"></span><br><span class="line"># 批矩阵相乘 pytorch <span class="number">0.4</span><span class="number">.0</span></span><br><span class="line">a = torch.randn(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">b = torch.rand(<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">c = torch.matmul(a, b)</span><br><span class="line">print(c.shape)  # torch.Size([<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line"># 在pytorch <span class="number">0.4</span><span class="number">.0</span>中使用torch.matmul 输入的参数是两个<span class="number">3</span>d的tensor ,tensor的首个维度是batch_size</span><br></pre></td></tr></table></figure>
</li>
<li><p>tensor 两个维度转置</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"># tensor 两个维度转置</span><br><span class="line">x = torch.randn(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">x = x.permute(<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">print(x.shape)  # torch.Size([<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>chunk  cat </p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">torch.cat(inputs, <span class="attribute">dimension</span>=0) → Tensor</span><br><span class="line"><span class="comment"># cat 是将多个tensor按照指定的维度拼接起来</span></span><br><span class="line">torch.chunk(tensor, chunks, <span class="attribute">dim</span>=0)</span><br><span class="line"><span class="comment"># chunk是将某个tensor按照指定的维度进行拆分成指定的块数</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="初始化函数"><a href="#初始化函数" class="headerlink" title="初始化函数"></a>初始化函数</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">import torch.nn as nn</span><br><span class="line">self.W = nn.Conv2d(in_channels=<span class="number">512</span>, out_channels=<span class="number">1024</span>, kernel_size=(<span class="number">3</span>,<span class="number">3</span>), \</span><br><span class="line">                   padding=(<span class="number">1</span>,<span class="number">1</span>), stride=(<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">nn.init.kaiming.normal(self.W.weight)</span><br><span class="line">nn.init.kaiming.uniform(self.W.weight)</span><br><span class="line">nn.init.constant(self.W.bias, <span class="number">0</span>)</span><br><span class="line"># 输出 tensor([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>self.training in pytorch</title>
    <url>/2019/04/07/self-training-in-pytorch/</url>
    <content><![CDATA[<ul>
<li>代码来源于：<a href="https://zhuanlan.zhihu.com/p/26893755" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26893755</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable, Function</span><br><span class="line"></span><br><span class="line">x_train = np.array([[<span class="number">3.3</span>], [<span class="number">4.4</span>], [<span class="number">5.5</span>], [<span class="number">6.71</span>], [<span class="number">6.93</span>], [<span class="number">4.168</span>],</span><br><span class="line">                    [<span class="number">9.779</span>], [<span class="number">6.182</span>], [<span class="number">7.59</span>], [<span class="number">2.167</span>], [<span class="number">7.042</span>],</span><br><span class="line">                    [<span class="number">10.791</span>], [<span class="number">5.313</span>], [<span class="number">7.997</span>], [<span class="number">3.1</span>]], dtype=np.float32)</span><br><span class="line"></span><br><span class="line">y_train = np.array([[<span class="number">1.7</span>], [<span class="number">2.76</span>], [<span class="number">2.09</span>], [<span class="number">3.19</span>], [<span class="number">1.694</span>], [<span class="number">1.573</span>],</span><br><span class="line">                    [<span class="number">3.366</span>], [<span class="number">2.596</span>], [<span class="number">2.53</span>], [<span class="number">1.221</span>], [<span class="number">2.827</span>],</span><br><span class="line">                    [<span class="number">3.465</span>], [<span class="number">1.65</span>], [<span class="number">2.904</span>], [<span class="number">1.3</span>]], dtype=np.float32)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x_train = torch.from_numpy(x_train)</span><br><span class="line">y_train = torch.from_numpy(y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"---------------------------------------"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearRegression</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(LinearRegression, self).__init__()</span><br><span class="line">        self.linear = nn.Linear(<span class="number">1</span>, <span class="number">1</span>)  <span class="comment"># input and output is 1 dimension</span></span><br><span class="line">        print(<span class="string">"self.training: "</span> + str(self.training))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        out = self.linear(x)</span><br><span class="line">        print(<span class="string">"self.training；"</span> + str(self.training))</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">print(<span class="string">"initialize"</span>)</span><br><span class="line">model = LinearRegression()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"---------------------------------------"</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"model.eval()"</span>)</span><br><span class="line">model.eval()</span><br><span class="line">inputs = Variable(x_train)</span><br><span class="line">target = Variable(y_train)</span><br><span class="line"><span class="comment"># forward</span></span><br><span class="line">out = model(inputs) <span class="comment"># 前向传播</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"---------------------------------------"</span>)</span><br><span class="line">print(<span class="string">"model.train()"</span>)</span><br><span class="line">model.train()</span><br><span class="line">inputs = Variable(x_train)</span><br><span class="line">target = Variable(y_train)</span><br><span class="line"><span class="comment"># forward</span></span><br><span class="line">out = model(inputs) <span class="comment"># 前向传播</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>range xrange np.arange np.linspace</title>
    <url>/2019/04/05/range-xrange-np-arange-np-linspace/</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1rmpadk75j309a07saa2.jpg"></p>
<p>python</p>
<ul>
<li>xrange 得到一个迭代器，（仅可以在python2中使用）</li>
<li>range 得到一个列表，（python2/python3均可）</li>
</ul>
<p>numpy</p>
<ul>
<li>numpy.arange 得到一份数组</li>
<li>numpy.linspace <strong>得到固定数量的等间隔数组，注意包含指定的尾部</strong></li>
</ul>
]]></content>
      <categories>
        <category>python</category>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>self-attention</title>
    <url>/2019/06/16/self-attention/</url>
    <content><![CDATA[<ul>
<li>一篇解读：<a href="https://kexue.fm/archives/4765" target="_blank" rel="noopener">https://kexue.fm/archives/4765</a></li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>shiyaya-Instruction-Final-bilibili</title>
    <url>/2020/09/17/shiyaya-Instruction-Final-bilibili/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>tensorboard_logger</title>
    <url>/2019/04/06/tensorboard-logger/</url>
    <content><![CDATA[<p>使用tensorboard_logger记录训练过程中的数据<br>（1）首先需要安装tensorflow</p>
<ul>
<li>可参考<a href="https://blog.csdn.net/love666666shen/article/details/77099843" target="_blank" rel="noopener">https://blog.csdn.net/love666666shen/article/details/77099843</a></li>
<li>不需要单独设置一个tensorflow的环境，直接pip install 一个CPU 版本的即可</li>
<li>pip install —ignore-installed —upgrade <a href="https://storage.googleapis.com/tensorflow/windows/cpu/tensorflow-1.1.0-cp35-cp35m-win_amd64.whl" target="_blank" rel="noopener">https://storage.googleapis.com/tensorflow/windows/cpu/tensorflow-1.1.0-cp35-cp35m-win_amd64.whl</a></li>
</ul>
<p>（2）安装tensorboard</p>
<ul>
<li>pip install tensorboard</li>
</ul>
<p>（3）No scalar data was found的解决<br>只需将cmd目录cd进入日志文件存放的目录，再加载日志文件便可解决：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">e:</span><br><span class="line">cd logdir</span><br><span class="line">tensorboard <span class="attribute">--logdir</span>=E:\logdir <span class="attribute">--host</span>=127.0.0.1</span><br></pre></td></tr></table></figure></p>
<p><img src="https://i.loli.net/2019/09/05/7YODLiJAZ6aUTG4.png" alt="搜狗截图20190905112015.png"></p>
]]></content>
      <tags>
        <tag>tensorboard</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu 安装 Stanford CoreNLP</title>
    <url>/2019/03/26/ubuntu-%E5%AE%89%E8%A3%85-Stanford-CoreNLP/</url>
    <content><![CDATA[<h3 id="安装java-jdk"><a href="#安装java-jdk" class="headerlink" title="安装java jdk"></a>安装java jdk</h3><ul>
<li><p>更新软件包列表：</p>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line">apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装openjdk-8-jdk：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">apt-<span class="builtin-name">get</span> install openjdk-8-jdk</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看java版本：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">java -<span class="built_in">version</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="下载并解压Stanford-coreNLP-包："><a href="#下载并解压Stanford-coreNLP-包：" class="headerlink" title="下载并解压Stanford coreNLP 包："></a>下载并解压Stanford coreNLP 包：</h3><ul>
<li>从这里下载<br><a href="https://stanfordnlp.github.io/CoreNLP/download.html" target="_blank" rel="noopener">https://stanfordnlp.github.io/CoreNLP/download.html</a><br>或者以命令行方式下载<blockquote>
<p>wget <a href="http://nlp.stanford.edu/software/stanford-corenlp-full-2018-02-27.zip" target="_blank" rel="noopener">http://nlp.stanford.edu/software/stanford-corenlp-full-2018-02-27.zip</a>  </p>
</blockquote>
</li>
</ul>
<ul>
<li><p>解压</p>
<blockquote>
<p>unzip stanford-corenlp-full-2018-02-27.zip</p>
</blockquote>
</li>
<li><p>转到文件目录</p>
</li>
</ul>
<blockquote>
<p>cd stanford-corenlp-full-2018-02-27/</p>
</blockquote>
<h3 id="配置环境变量："><a href="#配置环境变量：" class="headerlink" title="配置环境变量："></a>配置环境变量：</h3><p>把下列这行代码加到你的.bashrc里面(vim .bashrc)</p>
<blockquote>
<p> cd ~<br>vim .bashrc<br>export CLASSPATH=/path/to/stanford-corenlp-full-2018-02-27/stanford-corenlp-3.9.1.jar<br>source ~/.bashrc  ## 使之生效<br>把/path/to/替换为你保存stanford-corenlp-full-2016-10-31的地方的路径</p>
</blockquote>
<h3 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h3><blockquote>
<p>pip install stanfordcorenlp</p>
</blockquote>
<p>处理中文还需要下载中文的模型jar文件，然后放到stanford-corenlp-full-2018-02-27根目录下即可</p>
<p>wget <a href="http://nlp.stanford.edu/software/stanford-chinese-corenlp-2018-02-27-models.jar" target="_blank" rel="noopener">http://nlp.stanford.edu/software/stanford-chinese-corenlp-2018-02-27-models.jar</a></p>
<h3 id="检查自己是否装好了stanfordcorenlp"><a href="#检查自己是否装好了stanfordcorenlp" class="headerlink" title="检查自己是否装好了stanfordcorenlp"></a>检查自己是否装好了stanfordcorenlp</h3><p>进入python2或者python3</p>
<p>命令行下输入：</p>
<blockquote>
<p>python<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> stanfordcorenlp <span class="keyword">import</span> StanfordCoreNLP</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>能成功导入不报错，就是安装成功了。</p>
]]></content>
  </entry>
  <entry>
    <title>torch.no_grad</title>
    <url>/2019/07/17/torch-no-grad/</url>
    <content><![CDATA[<ul>
<li><a href="https://discuss.pytorch.org/t/model-eval-vs-with-torch-no-grad/19615/21" target="_blank" rel="noopener">https://discuss.pytorch.org/t/model-eval-vs-with-torch-no-grad/19615/21</a></li>
<li>with torch.no_grad()</li>
<li>可以减少内存，加快运行速度，同时可以使得batch_size 增大</li>
<li>但不是说非得必要</li>
</ul>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>torch.backends.cudnn.benchmark = true 使用情形</title>
    <url>/2019/04/03/torch-backends-cudnn-benchmark-true-%E4%BD%BF%E7%94%A8%E6%83%85%E5%BD%A2/</url>
    <content><![CDATA[<p><a href="https://www.pytorchtutorial.com/when-should-we-set-cudnn-benchmark-to-true/" target="_blank" rel="noopener">pytorch-torch.backends.cudnn.benchmark文档</a></p>
<ul>
<li>torch.backends.cudnn.benchmark<br>设置这个 flag 可以让内置的 cuDNN 的 auto-tuner 自动寻找最适合当前配置的高效算法，来达到优化运行效率的问题。</li>
</ul>
<p>应该遵循以下准则：</p>
<ul>
<li>如果网络的输入数据维度或类型上变化不大，设置  torch.backends.cudnn.benchmark = true  可以增加运行效率；</li>
<li>如果网络的输入数据在每次 iteration 都变化的话，会导致 cnDNN 每次都会去寻找一遍最优配置，这样反而会降低运行效率。</li>
<li>在程序刚开始加这条语句可以提升一点训练速度，没什么额外开销。</li>
<li>有时候可能是因为每次迭代都会引入点临时变量，会导致训练速度越来越慢，基本呈线性增长。<br>开发人员还不清楚原因，但如果周期性的使用torch.cuda.empty_cache()的话就可以解决这个问题。这个命令是清除没用的临时变量的。</li>
</ul>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>vatex_challenge_solutions</title>
    <url>/2019/10/20/vatex-challenge-solutions/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>video-caption-dataset</title>
    <url>/2019/02/22/video-caption-dataset/</url>
    <content><![CDATA[<h2 id="Youtube2Text-（MSVD）-1"><a href="#Youtube2Text-（MSVD）-1" class="headerlink" title="Youtube2Text （MSVD）[1]"></a>Youtube2Text （MSVD）[1]</h2><ul>
<li>这个数据集包含 1967个短视频，10-25s，平均时长为9s，视频包含不同的人，动物，动作，场景等。</li>
<li>每个视频由不同的人标注了多个句子，大约41 annotated sentences per clip，共有 80839 个sentences，平均每个句子有8个words，这些所有的句子中共包含近16000个 unique words。</li>
<li>caption中包括多国的语言进行描述，部分论文中采取只选用laguage = english 的caption 进行训练和测试[3][4]</li>
<li>采用的split根据 [2] ： 1,200 videos for training, 100 for validation and 670 for testing.<br><a href="https://github.com/ShiYaya/video_captioning/tree/master/MSVD" target="_blank" rel="noopener">我的整理</a></li>
</ul>
<ul>
<li>数据的下载：</li>
<li><a href="https://www.microsoft.com/en-us/download/details.aspx?spm=a2c4e.11153940.blogcont209612.6.42ba7e9eAA1K2o&amp;id=52422&amp;from=http%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fdownloads%2F38cf15fd-b8df-477e-a4e4-a4680caa75af%2Fdefault.aspx" target="_blank" rel="noopener">[website]</a></li>
<li>原数据：只给出了video_id,以及strart and end time , 若需要video数据，则需要自己通过url下载</li>
<li>某篇对于视频分析的总结，给出了<a href="https://github.com/sinyeratlantis/sinyeratlantis.github.io/blob/master/content/dl/%E8%A7%86%E9%A2%91%E5%88%86%E6%9E%90%E6%96%87%E7%8C%AE%E8%B0%83%E7%A0%94.md" target="_blank" rel="noopener">MSVD的下载链接</a>，可用，推荐(下载速度快，且video命名相对较好)☀☀&lt;/br&gt;<br><a href="http://www.cs.utexas.edu/users/ml/clamp/videoDescription/YouTubeClips.tar" target="_blank" rel="noopener">直接的下载链接</a><strong>[推荐]</strong></li>
<li>某篇github 含有MSVD(Youtube2Text)的<a href="https://github.com/yaoli/arctic-capgen-vid" target="_blank" rel="noopener">[preproceed dataset]</a>&lt;/br&gt;<br><a href="http://lisaweb.iro.umontreal.ca/transfert/lisa/users/yaoli/youtube2text_iccv15.zip" target="_blank" rel="noopener">直接的下载链接</a>(下载速度慢)</li>
<li>该篇github上含有<a href="https://github.com/ShiYaya/Video-Description-with-Spatial-Temporal-Attention#video-datas-and-pre-extracted-features-on-msvd-dataset" target="_blank" rel="noopener">MSVD数据集下载链接</a>&lt;/br&gt;<br><a href="https://www.multcloud.com/share/050e69cd-cab9-4ba3-a671-ed459341ab41" target="_blank" rel="noopener">直接的下载链接</a></li>
<li>对caption 常用的预处理: 1) verting all text to lower case, 2) tokenizing the sentences, 3) removing punctuation.</li>
</ul>
<h2 id="MSR-VTT-dataset"><a href="#MSR-VTT-dataset" class="headerlink" title="MSR-VTT dataset"></a>MSR-VTT dataset</h2><p> 共10000个video, 每个video有20个sentences, 共20万 video/sentence pair，10-30s居多</p>
<ul>
<li>split:  train:6513, val:497, test：2990</li>
<li>MSR-VTT dataset v2 , just video url: <a href="http://ms-multimedia-challenge.com/2017/dataset" target="_blank" rel="noopener">http://ms-multimedia-challenge.com/2017/dataset</a></li>
<li>author split train test val by himself and provied video data :<a href="https://github.com/xiadingZ/video-caption.pytorch" target="_blank" rel="noopener">https://github.com/xiadingZ/video-caption.pytorch</a>  &lt;/br&gt;<br><strong>下载这个数据集即可使用，但是还需要再找split!</strong>&lt;/br&gt;</li>
<li>MSR VTT 采用的split 是2016年提供的，<strong>目前科研广泛使用的都是2016年的</strong>。</li>
<li><a href="https://github.com/adi-dhal/In_Depth_Video_Analysis/tree/master/msr-vtt/2016" target="_blank" rel="noopener">[split]</a><br>MSR-VTT. Test video doesn’t have captions, so I spilit train-viedo to train/val/test. Extract and put them in <code>./data/</code> directory</li>
</ul>
<p>train-video: <a href="https://drive.google.com/file/d/1Qi6Gn_l93SzrvmKQQu-drI90L-x8B0ly/view?usp=sharing" target="_blank" rel="noopener">download link</a> &lt;/br&gt;<br>test-video: <a href="https://drive.google.com/file/d/10fPbEhD-ENVQihrRvKFvxcMzkDlhvf4Q/view?usp=sharing" target="_blank" rel="noopener">download link</a> &lt;/br&gt;<br>json info of train-video: <a href="https://drive.google.com/file/d/1LcTtsAvfnHhUfHMiI4YkDgN7lF1-_-m7/view?usp=sharing" target="_blank" rel="noopener">download link</a> &lt;/br&gt;<br>json info of test-video: <a href="https://drive.google.com/file/d/1Kgra0uMKDQssclNZXRLfbj9UQgBv-1YE/view?usp=sharing" target="_blank" rel="noopener">download link</a> &lt;/br&gt;</p>
<ul>
<li><p>download.py 可以下载MSR-VTT数据集(step by video)：<a href="https://github.com/OSUPCVLab/VideoToTextDNN" target="_blank" rel="noopener">[链接]</a></p>
</li>
<li><p>msr-vtt 2017 vs 2016<br>In the 2nd MSR Video to Language Challenge, we have combined the training set, validation set, and testing data in the 1st MSR Video to Language Challenge as the new training data. An additional test set of around 3K video clips will be released on June 1st as the final evaluation set. As such, we have 10K video clips for training and 3K video clips for testing this year. Each video is annotated with 20 natural sentences.&lt;/br&gt;<br>总结：就仅仅是将2016的train val and test 综合到一起，组成了2017： 一个大的含10000个video的train 数据集，并另外提供了2000个test video。&lt;/br&gt;<br>科研上普遍使用2016的分割方案，</p>
</li>
</ul>
<ul>
<li>In MSR-VTT dataset, we provide the category information for each video clip and the video clip contains audio information as well.</li>
</ul>
<h2 id="VATEX数据集"><a href="#VATEX数据集" class="headerlink" title="VATEX数据集"></a>VATEX数据集</h2><ul>
<li>一个新的数据集，41269个video， 时长大约10s, 每个video有10个中文，10个英文，同时这10个之中，中英文之间有5个是两两配对的</li>
<li>提出了两个新的任务：（1）一个encoder-decoder模型，在两种语言之间共享参数，即希望一个模型，可以得到两种语言的描述。（2）提出了一种新的机器翻译任务，即当进行中英文的机器翻译任务时，可以添加视频的视觉特征作为辅助信息</li>
<li><p>数据集的来源：来自于kinetics的validation dataset, 然后它们找人进行了caption的标注。它们将这41269个video 分成了4部分，train, validation, public test, secret test(不公开，用于比赛)</p>
</li>
<li><p>具体我的介绍见这篇博文</p>
</li>
</ul>
<h2 id="三个数据集的caption-length-的长度的统计情况"><a href="#三个数据集的caption-length-的长度的统计情况" class="headerlink" title="三个数据集的caption length 的长度的统计情况"></a>三个数据集的caption length 的长度的统计情况</h2><ul>
<li>eg, 句长为10 的captions 在当前这个数据集中所占比例   </li>
<li>msvd : 主要是len=6 为中心的居多<br><img src="https://i.loli.net/2019/09/07/jJ7ztsQb9MUR15X.png" alt="msvd_cap_length_.png"></li>
<li>msr-vtt：以len=9 为中心的居多<br><img src="https://i.loli.net/2019/09/07/SNYoIqHxPLWmU9D.png" alt="msr-vtt_cap_length_.png"></li>
<li>vatex：以len=15为中心的居多<br><img src="https://i.loli.net/2019/09/07/he7KYqMt8xj5pUs.png" alt="vatex_cap_length_.png"></li>
</ul>
<p>[1] Youtube2text: Recognizing and describing arbitrary activities using semantic hierarchies and zero-shot recognition. In ICCV 2013</p>
<p>[2] Translating videos to natural language using deep recurrent neural networks. NAACL, 2015.<br>[3] (ICCV 2015)Sequence to Sequence – Video to Text<br>[4] Jointly Modeling Embedding and Translation to Bridge Video and Language</p>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>word2vec</title>
    <url>/2019/08/02/word2vec-1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>vision to language 大牛</title>
    <url>/2019/07/26/vision-to-language-%E5%A4%A7%E7%89%9B/</url>
    <content><![CDATA[<h3 id="王鑫"><a href="#王鑫" class="headerlink" title="王鑫"></a>王鑫</h3><p>Papers can be found at <a href="https://sites.cs.ucsb.edu/~xwang" target="_blank" rel="noopener">https://sites.cs.ucsb.edu/~xwang</a><br>Email: xwang@cs.ucsb.edu</p>
<h4 id="video-captioning-via-hierarchical-reinforcement-learning"><a href="#video-captioning-via-hierarchical-reinforcement-learning" class="headerlink" title="video captioning via hierarchical  reinforcement learning"></a>video captioning via hierarchical  reinforcement learning</h4><ol>
<li>强化学习</li>
<li>加入音频信号</li>
</ol>
<h4 id="zero-shot-video-captioning"><a href="#zero-shot-video-captioning" class="headerlink" title="zero-shot video captioning"></a>zero-shot video captioning</h4><ul>
<li>Topic-Aware Mixture of Experts (TAMoE)  <h4 id="evaluation"><a href="#evaluation" class="headerlink" title="evaluation"></a>evaluation</h4></li>
</ul>
<ol>
<li><p>如何去评判，本身就是一个问题，当前的评价指标并不是那么合理</p>
</li>
<li><p>human evaluation是一个必要的评测方法，尤其是对于生成story的</p>
</li>
</ol>
<h4 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h4><ul>
<li>利用强化学习直接对指标进行优化，很可能会造成，指标上去了，但是生成的句子语义并不好。所以提出了下篇论文</li>
</ul>
<ol>
<li>Adversarial REward Learning (AREL)</li>
</ol>
<h4 id="Connecting-Language-and-Vision-to-Actions"><a href="#Connecting-Language-and-Vision-to-Actions" class="headerlink" title="Connecting Language and Vision to Actions"></a>Connecting Language and Vision to Actions</h4><ul>
<li>Look Before You Leap: Model-based RL</li>
<li>Reinforced Cross-Modal Matching (RCM)</li>
</ul>
<h3 id="吴琦"><a href="#吴琦" class="headerlink" title="吴琦"></a>吴琦</h3><h4 id="从-Vision-到-Language-再到-Action，万字漫谈三年跨域信息融合研究"><a href="#从-Vision-到-Language-再到-Action，万字漫谈三年跨域信息融合研究" class="headerlink" title="从 Vision 到 Language 再到 Action，万字漫谈三年跨域信息融合研究"></a><a href="https://mp.weixin.qq.com/s/lnoL1TpKY8HQqCMaBqWA5Q" target="_blank" rel="noopener">从 Vision 到 Language 再到 Action，万字漫谈三年跨域信息融合研究</a></h4><h4 id="一文纵览-Vision-and-Language-领域最新研究与进展"><a href="#一文纵览-Vision-and-Language-领域最新研究与进展" class="headerlink" title="一文纵览 Vision-and-Language 领域最新研究与进展"></a><a href="https://mp.weixin.qq.com/s/dyY64QrvPWbjGvJw5H51OA" target="_blank" rel="noopener">一文纵览 Vision-and-Language 领域最新研究与进展</a></h4>]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>video captioning 任务的难点？</title>
    <url>/2019/09/07/video-captioning-%E4%BB%BB%E5%8A%A1%E7%9A%84%E9%9A%BE%E7%82%B9%EF%BC%9F/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>word2vec</title>
    <url>/2019/08/01/word2vec/</url>
    <content><![CDATA[<h3 id="使用one-hot-来作为词向量"><a href="#使用one-hot-来作为词向量" class="headerlink" title="使用one-hot 来作为词向量"></a>使用one-hot 来作为词向量</h3><ul>
<li>存在一个缺点，即，两个单词之间的余弦相似度为0，因为one-hot是两两正交的形式。</li>
<li>但是相似度为0，显然是不对的</li>
</ul>
<h3 id="word2vet"><a href="#word2vet" class="headerlink" title="word2vet"></a>word2vet</h3><ul>
<li>跳字模型：中心词生成背景词</li>
<li>连续词袋模型：背景词生成中心词</li>
<li><p>这两个模型存在的问题：在softmax中，由于分母是对整个vocab进行求和，导致反向传播的计算量非常大</p>
</li>
<li><p><a href="https://www.bilibili.com/video/av18512944/" target="_blank" rel="noopener">相关教程</a></p>
</li>
</ul>
<p>预训练模型</p>
<ul>
<li>glove</li>
<li>fasttext</li>
<li><a href="https://www.bilibili.com/video/av18795160/?spm_id_from=333.788.videocard.0" target="_blank" rel="noopener">相关教程</a></li>
<li>spacy</li>
<li><a href="https://shiyaya.github.io/2019/07/16/Spacy工具包/" target="_blank" rel="noopener">https://shiyaya.github.io/2019/07/16/Spacy%E5%B7%A5%E5%85%B7%E5%8C%85/</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>从bagging到dropout</title>
    <url>/2019/03/22/%E4%BB%8Ebagging%E5%88%B0dropout/</url>
    <content><![CDATA[<ul>
<li>转载 from: <a href="https://blog.csdn.net/m0_37477175/article/details/77145459" target="_blank" rel="noopener">https://blog.csdn.net/m0_37477175/article/details/77145459</a></li>
</ul>
<p>dropout的思想继承自bagging方法，学习dropout先了解一下bagging方法。</p>
<h2 id="bagging"><a href="#bagging" class="headerlink" title="bagging"></a>bagging</h2><ul>
<li>bagging是一种集成方法（ensemble methods）,可以通过集成来减小泛化误差（generalization error）。 </li>
<li>bagging的<strong>最基本的思想</strong>是通过分别训练几个不同分类器，最后对测试的样本，每个分类器对其进行投票。在机器学习上这种策略叫model averaging。 </li>
<li>model averaging 之所以有效，是因为并非所有的分类器都会产生相同的误差，只要有不同的分类器产生的误差不同就会对减小泛化误差非常有效。 </li>
<li>对于bagging方法，允许采用相同的分类器，相同的训练算法，相同的目标函数。但是在<strong>数据集方面</strong>，<a href="https://www.baidu.com/s?wd=%E6%96%B0%E6%95%B0%E6%8D%AE&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">新数据</a>集与原始数据集的大小是相等的。每个数据集都是通过在原始数据集中随机选择一个样本进行替换而得到的。意味着，每个新数据集中会<strong>存在重复</strong>的样本。 </li>
<li>在数据集建好之后，用<strong>相同的学习算法</strong>分别作用于每个数据集就得到了几个分类器。 </li>
<li>下面这幅图片很好的解释了bagging的工作方式：我们想实现一个对数字8进行分类的分类器。此时构造了两个数据集，使用相同的学习算法，第一个分类器学习到的是8的上面那部分而第二个分类器学习的是8的下面那个部分。当我们把两个分类器集合起来的时候，此时的分类才是比较好的。 </li>
<li>Each of these individual classification ruls is brittle, but if we average there output then the detector is robust.<br><img src="https://img-blog.csdn.net/20170813153102572?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbTBfMzc0NzcxNzU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></li>
</ul>
<h2 id="dropout"><a href="#dropout" class="headerlink" title="dropout"></a>dropout</h2><ul>
<li>我们可以把dropout类比成将许多大的神经网络进行集成的一种bagging方法。 </li>
<li>但是每一个神经网络的训练是非常耗时和占用很多内存的，训练很多的神经网络进行集合分类就显得太不实际了。 </li>
<li>但是，dropout可以训练所有子网络的集合，这些子网络通过去除整个网络中的一些<a href="https://www.baidu.com/s?wd=%E7%A5%9E%E7%BB%8F%E5%85%83&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">神经元</a>来获得。 </li>
<li><p>如下图所示：<br><img src="https://img-blog.csdn.net/20170813154717429?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbTBfMzc0NzcxNzU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
</li>
<li><p>可能有些人会问上图的有些子网络，从输入到不了最终的输出，怎么办？其实对于比较宽的层（wider layers）从输入到输出都切断的概率是非常小的，多以影响不是很大。</p>
</li>
<li><p>如何移除一个神经元呢，我们通过仿射和非线性变换，试神经元的输出乘以0。</p>
</li>
<li><p>每次我们加载一个样本到minibatch，然后随机的采样一个不同的二进制掩膜作用在所有的输出，输入，隐藏节点上。每个节点的掩膜都是独立采样的。采样一个掩膜值为1的概率是固定的超参数。</p>
</li>
</ul>
<h2 id="bagging与dropout训练的对比"><a href="#bagging与dropout训练的对比" class="headerlink" title="bagging与dropout训练的对比"></a>bagging与dropout训练的对比</h2><ul>
<li>在bagging中，所有的分类器都是独立的，而在dropout中，所有的模型都是共享参数的。</li>
<li>在bagging中，所有的分类器都是在特定的数据集下训练至收敛，而在dropout中没有明确的模型训练过程。网络都是在一步中训练一次（输入一个样本，随机训练一个子网络）</li>
<li>（相同点）对于训练集来说，每一个子网络的训练数据是通过原始数据的替代采样得到的子集。<strong>？？？</strong>（自己的理解：每一个输入一个样本初始化某一个子网络）</li>
</ul>
<h2 id="dropout的优势"><a href="#dropout的优势" class="headerlink" title="dropout的优势"></a>dropout的优势</h2><ul>
<li>very computationally cheap在dropout训练阶段，每一个样本每一次更新只需要O(n)<br>，同时要生成n个二进制数字与每个状态相乘。除此之外，还需要O(n)的额外空间存储这些二进制数字，直到反向传播阶段。</li>
<li>没有很显著的限制模型的大小和训练的过程。</li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>优先级队列式分支限界法---最小重量机器设计问题--python实现</title>
    <url>/2019/05/22/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%BC%8F%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95-%E6%9C%80%E5%B0%8F%E9%87%8D%E9%87%8F%E6%9C%BA%E5%99%A8%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98-python%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>这里给出两个解决方案：</p>
<p>1）不使用优先级，简单使用队列式分支限界法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 普通的FIFO 队列式分支限界法</span></span><br><span class="line"><span class="comment">## 当 不满足总价格不超过d的要求时，则剪枝</span></span><br><span class="line"><span class="comment">## 当搜索到深度n时，即搜索到了叶节点，不再进行扩展节点的操作，而是针对于叶节点所对应的最小值，</span></span><br><span class="line"><span class="comment"># 反向求得该节点所对应的的路径</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># coding : utf-8</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = <span class="number">3</span></span><br><span class="line">m = <span class="number">3</span></span><br><span class="line">d = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">price = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line">weight = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到当前扩展节点所在的Level</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getlevel</span><span class="params">(m, currrent)</span>:</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    level = <span class="number">0</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> currrent == <span class="number">0</span>:</span><br><span class="line">        level = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> level</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">        level = level+<span class="number">1</span></span><br><span class="line">        sum = m**level + sum  <span class="comment"># sum=m</span></span><br><span class="line">        <span class="keyword">if</span> sum-m**level &lt; currrent &lt;= sum:  <span class="comment"># m-m^0 = m-1</span></span><br><span class="line">            <span class="keyword">return</span> level</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到当前扩展节点，所对应的首个子节点所在的索引</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_idx</span><span class="params">(m, current)</span>:</span></span><br><span class="line">    level = getlevel(m, current)</span><br><span class="line">    <span class="comment"># 求current 在该level中的相对索引，即 相对于该level第一个元素的位置</span></span><br><span class="line">    current_level_idx = current - sum([m**i <span class="keyword">for</span> i <span class="keyword">in</span> range(level)])</span><br><span class="line">    <span class="comment"># 子节点所在层的开始绝对索引</span></span><br><span class="line">    start_idx  = sum([m**i <span class="keyword">for</span> i <span class="keyword">in</span> range(level+<span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> start_idx + current_level_idx*m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到最优解之后，反向查找其路径</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_path</span><span class="params">(m, current)</span>:</span></span><br><span class="line">    path = []</span><br><span class="line">    path.append(current%m)  <span class="comment"># from 1, not from 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        level = getlevel(m, current)</span><br><span class="line">        <span class="keyword">if</span> level == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> path[::<span class="number">-1</span>]</span><br><span class="line">        current_level_idx = current - sum([m ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(level)])  <span class="comment"># # 求current 在该level中的相对索引，即 相对于该level第一个元素的位置</span></span><br><span class="line">        path.append(current_level_idx // m + <span class="number">1</span>)  <span class="comment"># 得到上一级的索引位置</span></span><br><span class="line">        current = sum([m ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(level<span class="number">-1</span>)]) + current_level_idx // m  <span class="comment">#得到上一级的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MinWighet</span><span class="params">(n,m,d,price,weight)</span>:</span></span><br><span class="line">    minweight = float(<span class="string">"inf"</span>)</span><br><span class="line">    <span class="comment"># 子集树中的节点数</span></span><br><span class="line">    vec_len = sum([m ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>)]) + <span class="number">1</span></span><br><span class="line">    que = queue.Queue()</span><br><span class="line">    que.put(<span class="number">0</span>)</span><br><span class="line">    vec_price = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(vec_len)]</span><br><span class="line">    vec_weight = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(vec_len)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">not</span> que.empty()):</span><br><span class="line">        current = que.get()  <span class="comment"># 得到当前扩展节点（索引号）</span></span><br><span class="line">        level = getlevel(m, current)  <span class="comment"># 当前 扩展节点所在的level</span></span><br><span class="line"></span><br><span class="line">        idx = get_idx(m, current)   <span class="comment"># 得到当前扩展节点，所对应的首个子节点所在的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 若搜索完了整棵树</span></span><br><span class="line">        <span class="keyword">if</span> getlevel(m, current) == getlevel(m, vec_len)<span class="number">-1</span>:</span><br><span class="line">            minweight = vec_price[current]</span><br><span class="line">            min_at_idx = current</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">not</span> que.empty()):</span><br><span class="line">                <span class="comment"># minweight = min(minweight, vec_price[que.get()])</span></span><br><span class="line">                tmp = que.get()</span><br><span class="line">                <span class="keyword">if</span> minweight &gt; vec_price[tmp]:</span><br><span class="line">                    minweight = vec_price[tmp]</span><br><span class="line">                    min_at_idx = tmp</span><br><span class="line">            path = get_path(m, min_at_idx)</span><br><span class="line">            <span class="keyword">return</span> minweight, path</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断当前的扩展结点下的所有子节点是否可以加入活结点队列中</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            vec_price[idx] = int(vec_price[current] + price[level][i])</span><br><span class="line">            <span class="keyword">if</span> vec_price[idx] &lt;= d:</span><br><span class="line">                vec_weight[idx] = int(vec_weight[current] + weight[level][i])</span><br><span class="line">                que.put(idx)</span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(MinWighet(n,m,d,price,weight))</span><br></pre></td></tr></table></figure>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>2） 优先级队列式分支限界法</p>
<p>解空间：子集树，每个分支节点的分支数为m<br>解向量：x[1:n]  n为部件数量， x[i] 表示第i个部件使用哪个供应商。</p>
<p>算法：采用优先队列式分支限界法。<br>类似于单源最短路径，使用当前节点所确定下的采购方案对应的机器重量和最为优先级。<br>由于wij不是负值，当前节点所对应的当前机器重量和是解空间中以该节点为根的子树的中所有节点所对应的重量和的下界。</p>
<p>算法代码实现：</p>
<p>1）使用列表来代表队列，通过对列表中的活结点按照其当前重量和进行从小到大排序（实现了最小堆的维护）<br>2）定义一个节点类，属性有：节点所在的索引，以及节点当前的重量和<br>3）取出一个扩展节点：由于对活结点表进行了某种规则的排序，则直接取出列表的第一个元素即可<br>4）加入活结点表：将满足条件的子节点加入到活结点表中</p>
<p>失活当前扩展节点：删掉列表中的第一个元素即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 普通的FIFO 队列式分支限界法</span></span><br><span class="line"><span class="comment">## 当 不满足总价格不超过d的要求时，则剪枝</span></span><br><span class="line"><span class="comment">## 当搜索到深度n时，即搜索到了叶节点，不再进行扩展节点的操作，而是针对于叶节点所对应的最小值，</span></span><br><span class="line"><span class="comment"># 反向求得该节点所对应的的路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入优先级--使用当前节点的重量作为优先级，重量小优先级高</span></span><br><span class="line"><span class="comment"># 将队列改成列表，以append的方式加入到列表中，再以排序的方式维护当前列表的首个元素为最小权值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># coding : utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到当前扩展节点所在的Level</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getlevel</span><span class="params">(m, currrent)</span>:</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    level = <span class="number">0</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> currrent == <span class="number">0</span>:</span><br><span class="line">        level = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> level</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">        level = level+<span class="number">1</span></span><br><span class="line">        sum = m**level + sum  <span class="comment"># sum=m</span></span><br><span class="line">        <span class="keyword">if</span> sum-m**level &lt; currrent &lt;= sum:  <span class="comment"># m-m^0 = m-1</span></span><br><span class="line">            <span class="keyword">return</span> level</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到当前扩展节点，所对应的首个子节点所在的索引</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_idx</span><span class="params">(m, current)</span>:</span></span><br><span class="line">    level = getlevel(m, current)</span><br><span class="line">    <span class="comment"># 求current 在该level中的相对索引，即 相对于该level第一个元素的位置</span></span><br><span class="line">    current_level_idx = current - sum([m**i <span class="keyword">for</span> i <span class="keyword">in</span> range(level)])</span><br><span class="line">    <span class="comment"># 子节点所在层的开始绝对索引</span></span><br><span class="line">    start_idx  = sum([m**i <span class="keyword">for</span> i <span class="keyword">in</span> range(level+<span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> start_idx + current_level_idx*m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到最优解之后，反向查找其路径</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_path</span><span class="params">(m, current)</span>:</span></span><br><span class="line">    path = []</span><br><span class="line">    path.append(current%m)  <span class="comment"># from 1, not from 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        level = getlevel(m, current)</span><br><span class="line">        <span class="keyword">if</span> level == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> path[::<span class="number">-1</span>]</span><br><span class="line">        current_level_idx = current - sum([m ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(level)])  <span class="comment"># # 求current 在该level中的相对索引，即 相对于该level第一个元素的位置</span></span><br><span class="line">        path.append(current_level_idx // m + <span class="number">1</span>)  <span class="comment"># 得到上一级的索引位置</span></span><br><span class="line">        current = sum([m ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(level<span class="number">-1</span>)]) + current_level_idx // m  <span class="comment">#得到上一级的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为活结点表中的节点 定义了一个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, idx, weight)</span>:</span></span><br><span class="line">        self.idx = idx</span><br><span class="line">        self.weight = weight</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MinWighet</span><span class="params">(n,m,d,price,weight)</span>:</span></span><br><span class="line">    <span class="comment"># 子集树中的节点数</span></span><br><span class="line">    vec_len = sum([m ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>)]) + <span class="number">1</span></span><br><span class="line">    que = []</span><br><span class="line">    que.append(Node(<span class="number">0</span>,<span class="number">0</span>))  <span class="comment"># 在活结点表中加入根节点</span></span><br><span class="line">    <span class="comment"># vec_price = [0 for _ in range(vec_len)]</span></span><br><span class="line">    <span class="comment"># vec_weight = [0 for _ in range(vec_len)]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(que):  <span class="comment"># 当活结点表非空时</span></span><br><span class="line">        que = sorted(que, key=<span class="keyword">lambda</span> node: node.weight)  <span class="comment"># 类似于最小堆的维护</span></span><br><span class="line">        current = que[<span class="number">0</span>]  <span class="comment"># 得到当前扩展节点（索引号）</span></span><br><span class="line">        level = getlevel(m, current.idx)  <span class="comment"># 当前 扩展节点所在的level</span></span><br><span class="line"></span><br><span class="line">        new_node_idx = get_idx(m, current.idx)   <span class="comment"># 得到当前扩展节点，所对应的首个子节点所在的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 若搜索完了整棵树</span></span><br><span class="line">        <span class="keyword">if</span> getlevel(m, current.idx) == getlevel(m, vec_len)<span class="number">-1</span>:</span><br><span class="line">            minweight = current.weight</span><br><span class="line">            min_at_idx = current.idx</span><br><span class="line"></span><br><span class="line">            path = get_path(m, min_at_idx)</span><br><span class="line">            <span class="keyword">return</span> minweight, path</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断当前的扩展结点下的所有子节点是否可以加入活结点队列中</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> int(current.weight + price[level][i]) &lt;= d:</span><br><span class="line">                new_node = Node(new_node_idx, int(current.weight + weight[level][i]))</span><br><span class="line">                que.append(new_node)</span><br><span class="line">            new_node_idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将当前的扩展节点失活</span></span><br><span class="line">        <span class="keyword">del</span> que[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    n = <span class="number">3</span></span><br><span class="line">    m = <span class="number">3</span></span><br><span class="line">    d = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    price = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]]</span><br><span class="line">    weight = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]]</span><br><span class="line">    result = MinWighet(n,m,d,price,weight)</span><br><span class="line">    print(MinWighet(n,m,d,price,weight))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 objects position 作为特征的论文</title>
    <url>/2019/10/10/%E4%BD%BF%E7%94%A8-objects-position-%E4%BD%9C%E4%B8%BA%E7%89%B9%E5%BE%81%E7%9A%84%E8%AE%BA%E6%96%87/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>到底ResNet在解决一个什么问题呢</title>
    <url>/2019/08/17/%E5%88%B0%E5%BA%95ResNet%E5%9C%A8%E8%A7%A3%E5%86%B3%E4%B8%80%E4%B8%AA%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%91%A2/</url>
    <content><![CDATA[<p>对知乎上回答的简单总结</p>
<hr>
<p><strong>一、引言：为什么会有ResNet？Why ResNet？</strong></p>
<ul>
<li>过拟合？<br>  不是！因为深层网络表现为训练误差和测试误差都比较高，所以不是过拟合</li>
<li><p>梯度消失？梯度爆炸？<br>  不是！因为已经使用了 batch normalization ，在很大程度上解决了梯度消失、爆炸的问题，（yaya：我个人认为对梯度消失问题有一定的帮助，毕竟梯度值为1）</p>
</li>
<li><p>深层网络退化的原因？</p>
<p>  由于非线性激活函数的存在，使得信息被丢失，而不能完整保留，所以，应该在网络中加入恒等映射</p>
</li>
</ul>
<p><strong>二、关于resnet网络结构 【没看懂为什么要有两层】  </strong></p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g62hrnrs6nj30h9048aax.jpg" alt></p>
<ul>
<li>yaya 分析：<br>一层：  relu(x +  w1 x)<br>两层：  relu(x +w2 relu(w1 x))</li>
</ul>
<p>​       既然非线性激活函数会把信息丢失，为什么不这样：relu(wx) + x ，因为这样是错误的，本身relu是需要放在输出后面，起到非线性的作用，但是这样，就不算作对输出的非线</p>
<p><strong>三、更多的理解    </strong></p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g62hpvudvxj30iu0cc3zi.jpg" alt></p>
<hr>
<p>yaya 的总结/理解</p>
<ol>
<li>resnet 解决的不是过拟合的问题，因为过拟合的现象是，train loss 小，但是val loss大，但是当前深层网络的问题是train loss大，val loss也大</li>
<li>resnet 提供了一个梯度为1的反向传播，在一定程度上解决了梯度消失的问题</li>
<li>FPN中指出，不同深度的网络的结合可以结合不同的分辨率，但是当前resnet 只跨越了一种分辨率，因此，没能很好地利用这一特点，因此desnet便被提出来</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>动态规划(dynamic programming)</title>
    <url>/2019/04/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dynamic-programming/</url>
    <content><![CDATA[<h3 id="从起始点，走到终点"><a href="#从起始点，走到终点" class="headerlink" title="从起始点，走到终点"></a>从起始点，走到终点</h3><p>（1）共有多少路径<br>（2）哪条路径最短<br>对于grid 走路，只有两种走走法，这类问题，需要：   </p>
<ul>
<li>分析最后终点的结果，是怎么得来的：是由左邻和上邻的结果，进行某种运算得来的   </li>
<li>先将第一行、第一列进行初始化（结合具体问题）   </li>
<li>分析，递推公式，并采用自底向上的方式，因此，需要先高度的想，最后终点的递推公式，在结合这个公式，分析，在初始化之后，接下来的点，如何根据初始化的值，以及递推公式来计算得到。   </li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>分治递归： 一步一步的化解为小问题，最终由小问题再反向计算各大问题。自上而下   </li>
<li>动态规划：也需要得到递推公式，但是需要先将小问题的值写出来（初始化阶段），再根据递推公式，写for循环   </li>
</ul>
<h3 id="对于求解任意两个节点之间的值，并求全局最优解的问题，还需要再总结"><a href="#对于求解任意两个节点之间的值，并求全局最优解的问题，还需要再总结" class="headerlink" title="对于求解任意两个节点之间的值，并求全局最优解的问题，还需要再总结"></a>对于求解任意两个节点之间的值，并求全局最优解的问题，还需要再总结</h3><ul>
<li><a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-subarray/</a>  </li>
<li><a href="https://leetcode.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-product-subarray/</a>  </li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针(two pointers)</title>
    <url>/2019/04/18/%E5%8F%8C%E6%8C%87%E9%92%88-two-pointers/</url>
    <content><![CDATA[<ul>
<li>荷兰分区问题<br>可参考 <a href="https://blog.csdn.net/sylar_d/article/details/52742598" target="_blank" rel="noopener">https://blog.csdn.net/sylar_d/article/details/52742598</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>史雅雅的收藏夹</title>
    <url>/2019/04/04/%E5%8F%B2%E9%9B%85%E9%9B%85%E7%9A%84%E6%94%B6%E8%97%8F%E5%A4%B9/</url>
    <content><![CDATA[<p><a href="http://pygments.org/" target="_blank" rel="noopener">http://pygments.org/</a></p>
<p><a href="https://202.38.95.226:7443/view.html" target="_blank" rel="noopener">https://202.38.95.226:7443/view.html</a></p>
<p><a href="https://aideadlin.es/?sub=ML,RO,CV,SP,NLP,DM" target="_blank" rel="noopener">https://aideadlin.es/?sub=ML,RO,CV,SP,NLP,DM</a></p>
<p><a href="https://yjs.ustc.edu.cn/" target="_blank" rel="noopener">https://yjs.ustc.edu.cn/</a></p>
<p><a href="https://www.json.cn/" target="_blank" rel="noopener">https://www.json.cn/</a></p>
<p><a href="https://kevinj-huang.github.io/" target="_blank" rel="noopener">https://kevinj-huang.github.io/</a></p>
<p><a href="https://shiyaya.github.io/" target="_blank" rel="noopener">https://shiyaya.github.io/</a></p>
<p><a href="https://stackedit.io/app#" target="_blank" rel="noopener">https://stackedit.io/app#</a></p>
<p><a href="http://jsonviewer.stack.hu/" target="_blank" rel="noopener">http://jsonviewer.stack.hu/</a></p>
<p><a href="http://www.nlpjob.com/" target="_blank" rel="noopener">http://www.nlpjob.com/</a></p>
<p><a href="https://nlp.stanford.edu/software/scenegraph-parser.shtml#Usage" target="_blank" rel="noopener">https://nlp.stanford.edu/software/scenegraph-parser.shtml#Usage</a></p>
<p><a href="https://paperswithcode.com/sota" target="_blank" rel="noopener">https://paperswithcode.com/sota</a></p>
<p><a href="https://sm.ms/" target="_blank" rel="noopener">https://sm.ms/</a></p>
<p><a href="http://www.arxiv-sanity.com/" target="_blank" rel="noopener">http://www.arxiv-sanity.com/</a></p>
<p><a href="http://www.cvpapers.com/" target="_blank" rel="noopener">http://www.cvpapers.com/</a></p>
<h3 id="论文搜索"><a href="#论文搜索" class="headerlink" title="论文搜索"></a>论文搜索</h3><ul>
<li><p><a href="https://dblp.uni-trier.de/db/" target="_blank" rel="noopener">https://dblp.uni-trier.de/db/</a></p>
<ul>
<li>（可以进行筛选，eg:nips, iccv, cvpr）; (也可以对某些作者进行查询)</li>
</ul>
</li>
<li><p><a href="http://openaccess.thecvf.com/menu.py" target="_blank" rel="noopener">http://openaccess.thecvf.com/menu.py</a></p>
</li>
<li><a href="http://actionrecognition.net/files/paper.php" target="_blank" rel="noopener">http://actionrecognition.net/files/paper.php</a></li>
<li><a href="http://www.aaai.org/Library/AAAI/aaai19contents.php" target="_blank" rel="noopener">http://www.aaai.org/Library/AAAI/aaai19contents.php</a></li>
<li><a href="https://dl.acm.org/results.cfm?within=owners.owner%3DHOSTED&amp;srt=_score&amp;query=&amp;Go.x=26&amp;Go.y=1" target="_blank" rel="noopener">https://dl.acm.org/results.cfm?within=owners.owner%3DHOSTED&amp;srt=_score&amp;query=&amp;Go.x=26&amp;Go.y=1</a></li>
</ul>
<h3 id="翻墙"><a href="#翻墙" class="headerlink" title="翻墙"></a>翻墙</h3><ul>
<li><p><a href="https://github.com/vpncn/vpncn.github.io" target="_blank" rel="noopener">https://github.com/vpncn/vpncn.github.io</a></p>
</li>
<li><p><a href="https://flyzyblog.com/install-ss-ssr-bbr-in-one-command/#ss" target="_blank" rel="noopener">https://flyzyblog.com/install-ss-ssr-bbr-in-one-command/#ss</a></p>
</li>
<li><p><a href="https://www.banpie.info/shadowsocks-pac-gfw/" target="_blank" rel="noopener">https://www.banpie.info/shadowsocks-pac-gfw/</a></p>
</li>
<li><p>Vultr搭建SS</p>
</li>
<li><p><a href="https://github.com/sirzdy/shadowsocks/wiki/Vultr搭建SS（VPS搭建SS）" target="_blank" rel="noopener">http://wuzhangyang.com/2019/03/06/vultr-ss/</a></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">wget https:<span class="comment">//raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</span></span><br><span class="line"></span><br><span class="line">chmod +x shadowsocks.sh</span><br><span class="line"></span><br><span class="line">./shadowsocks<span class="selector-class">.sh</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>搬瓦工</p>
</li>
<li><p>推荐：<a href="https://www.bandwagonhost.net/1967.html" target="_blank" rel="noopener">https://www.bandwagonhost.net/1967.html</a></p>
</li>
</ul>
<h2 id="会议搜索"><a href="#会议搜索" class="headerlink" title="会议搜索"></a>会议搜索</h2><ul>
<li><a href="http://www.searchconf.net/conf/searchresule/" target="_blank" rel="noopener">http://www.searchconf.net/conf/searchresule/</a></li>
</ul>
<h3 id="iccv-2019-challenge"><a href="#iccv-2019-challenge" class="headerlink" title="iccv 2019 challenge"></a>iccv 2019 challenge</h3><ul>
<li><a href="https://sites.google.com/site/iccv19clvllsmdc/home" target="_blank" rel="noopener">https://sites.google.com/site/iccv19clvllsmdc/home</a></li>
</ul>
<h3 id="GCN"><a href="#GCN" class="headerlink" title="GCN"></a>GCN</h3><ul>
<li><a href="https://github.com/rusty1s/pytorch_geometric" target="_blank" rel="noopener">https://github.com/rusty1s/pytorch_geometric</a></li>
</ul>
<p>深度学习课程</p>
<ul>
<li><a href="https://discuss.gluon.ai/c/5-category" target="_blank" rel="noopener">https://discuss.gluon.ai/c/5-category</a></li>
<li><a href="http://zh.d2l.ai/chapter_preface/preface.html" target="_blank" rel="noopener">http://zh.d2l.ai/chapter_preface/preface.html</a></li>
</ul>
<h3 id="tensorboard-可视化"><a href="#tensorboard-可视化" class="headerlink" title="tensorboard 可视化"></a>tensorboard 可视化</h3><ul>
<li><a href="https://www.aiuai.cn/aifarm646.html" target="_blank" rel="noopener">https://www.aiuai.cn/aifarm646.html</a></li>
</ul>
]]></content>
      <categories>
        <category>杂类</category>
      </categories>
      <tags>
        <tag>杂类</tag>
      </tags>
  </entry>
  <entry>
    <title>图像描述-评价指标-中用到的数据集汇总</title>
    <url>/2020/06/04/%E5%9B%BE%E5%83%8F%E6%8F%8F%E8%BF%B0-%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87-%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>为了评估 提出的metric 与 human judgement的相关性，提出了一些数据集。这些数据集，包含image-text-human_score, 通过利用统计学分析 metric_evaluation 与 human_score 的相关性，来验证提出评价指标的合理性。</p>
<h1 id="Caption-level-Correlation"><a href="#Caption-level-Correlation" class="headerlink" title="Caption-level Correlation"></a>Caption-level Correlation</h1><h2 id="Flickr-8k-Dataset"><a href="#Flickr-8k-Dataset" class="headerlink" title="Flickr 8k Dataset"></a>Flickr 8k Dataset</h2><ul>
<li>website: <a href="http://academictorrents.com/details/9dea07ba660a722ae1008c4c8afdd303b6f6e53b" target="_blank" rel="noopener">http://academictorrents.com/details/9dea07ba660a722ae1008c4c8afdd303b6f6e53b</a></li>
<li>论文: Framing Image Description as a Ranking Task: Data, Models and Evaluation Metrics   </li>
</ul>
<font size="2"> **数据集介绍** </font>

<ul>
<li><p>Cite: Framing image description as a ranking task: Data, models and evaluation metrics.  </p>
</li>
<li><p>对于图像描述任务：该数据集包含8092张image。训练集6000张，验证集1000张，测试集1000张，，很奇怪。。数据加起来对不上。。每张image 都对应有人类标注的5个句子。</p>
</li>
<li><p>对于图像描述评价指标任务： </p>
<p><strong>测试集1000张</strong>，<font color="blue"><strong>通过image-text retrieval 算法</strong></font> 检索candidate caption，为每张图片从整个测试集的语料库上进行检索（检索的数量没有固定，像是根据检索结果阈值截取的）。由于是在整个测试集的预料库上进行检索，则，也有可能检索到自身image对应的groundtruth。This dataset also includes 5822 testing captions for 1000 images。  </p>
<p>得到这些新的image-text pair，对于每个pair，再由<strong>三个人工</strong>去标注image与text的匹配程度( give a score from 1 (not related to the image content) to 4 (very related))。</p>
<p>则，构建了一个可以衡量metric 与 human judgement 相关性的一个数据集。</p>
</li>
</ul>
<font size="2"> **使用 Note** </font>

<ul>
<li>在TIGER [1] : <strong>Because 158 candidates are actual references of target images, we excluded these for further analysis。</strong> <font color="red">在TIGER 的实验设置中：若Flickr 8k数据集中检索到了本image对应的reference，则去掉该条检索。</font>去掉了 158条，则剩余 5822-158=5664条</li>
</ul>
<font size="2"> **评估方式**</font>

<p><code>Kendall</code> and <code>Spearman</code> rank correlations reflect the similarity of the pairwise rankings whereas <code>Pearson’s</code> p captures the linear association between data points.</p>
<h2 id="Composite-Dataset"><a href="#Composite-Dataset" class="headerlink" title="Composite Dataset"></a>Composite Dataset</h2><p>论文：From Images to Sentences through Scene Description Graphs using Commonsense Reasoning and Knowledge  </p>
<font size="2"> **数据集介绍** </font>

<p>这个数据集是由三个数据集组成的。包括：testing captions for 2007 MS-COCO images, 997 Flickr 8k pictures, and 991 Flickr 30k images.  </p>
<p>每张图片对应3个candidate captions，包括1个human written reference和 2个machine generated。</p>
<p>这里总计有11,985 candidates, 标注与image 之间的相关性，from 1 (not relevant) to 5 (very relevant)。</p>
<font size="2"> **评估方式**</font>

<p><code>Kendall</code> and <code>Spearman</code> rank correlations reflect the similarity of the pairwise rankings whereas <code>Pearson’s</code> p captures the linear association between data points.</p>
<h2 id="Pascal-50s-Dataset"><a href="#Pascal-50s-Dataset" class="headerlink" title="Pascal 50s Dataset"></a>Pascal 50s Dataset</h2><ul>
<li>website: <a href="http://vrama91.github.io/cider/" target="_blank" rel="noopener">http://vrama91.github.io/cider/</a></li>
</ul>
<font size="2"> **数据集介绍** </font>

<p>Cite: <code>CIDEr: Consensus-based Image Description Evaluation</code></p>
<p>从 UIUC PASCAL Sentence Dataset中提取1000张image，原数据集中，每个image配有5个human written sentence。</p>
<p>对于图像描述评价指标任务： </p>
<p>在以上基础上每个image 又由 AMT workers标注了50个captions。以此构成了pascal 50s 数据集。</p>
<p>不同于以上的两个数据集评估image-text 之间的匹配，该数据集考量candidate 与 reference之间的匹配。具体地：对于一个image，（1）使用48 of 50 human written caption as <strong>reference</strong>。（2）剩下的两个human written caption as <strong>candidate</strong>，同时也使用 machine generated caption as <strong>candidate</strong>，另外other image 的 human written caption通过检索的方式也可以当 这样candidate可以当做<strong>candidate</strong>。</p>
<p>基于此，构建三元组：（A, (B, C)）—(reference, (candidate_1, candidate_2)) 根据(B, C) 组合方式的不同，分为四类：HC，HI，HM，MM。（1）human–human correct pairs (HC), where we pick two human sentences describing the same image. （2） human–human incorrect pairs (HI), where one of the sentences is a human description for the image and the other is also a human sentence but describing some other image from the dataset picked at random. （3）human–machine (HM) pairs formed by pairing a human sentence describing an image with a machine generated sentence describing the same image. （4）machine–machine (MM) pairs, where we compare two machine generated sentences describing the same image</p>
<p>则，可以得到 1000image × 48reference(A) × 4(B,C) = 192000个三元组</p>
<p><strong>human judgement 的标注</strong> 对于任意给出的一个三元组(A, B, C)。A 是一个reference sentence, (B, C) 是两个candidate captions pair. 标注者被要求从B和C中选择一个与A最相似的句子。这样就可以收集到一个human judgements for each triplet. 如果B的投票对于C则认为B is winner.</p>
<font size="2"> **使用 Note** </font>

<ul>
<li>解读如下的表格的acuracy是如何计算的吧！首先在PASCAL-50s数据集里含有4种模式：HC、HI、HM、MM， 即对于（A,(B, C)）中的pair（B, C）含有四种模式。当前AMT workers对pair(B, C)已经有了排序，当proposed metric也对这些B，C sentences进行评分的时候，自然也会有一个对B，C的排序，即score高的sentence, 排序就在前。基于人类已经给了人工的标注排序，即获得了GT，那么就可以去评判 proposed metric 对该pair的评分是否正确。进而可以得到对该类HC/HI/HM/MM的准确率。其实也可以在整个数据集上进行测试得到一个准确率。</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gcdc0x4s91j30ex04uaas.jpg" alt="搜狗截图20200229160306.png"></p>
<font size="2"> **评估方式**</font>

<p>Pairwise Classification Accuracy</p>
<h1 id="System-Level-Correlation"><a href="#System-Level-Correlation" class="headerlink" title="System-Level Correlation"></a>System-Level Correlation</h1><h2 id="the-2015-COCO-Captioning-Challenge-for-12-teams"><a href="#the-2015-COCO-Captioning-Challenge-for-12-teams" class="headerlink" title="the 2015 COCO Captioning Challenge for 12 teams"></a>the 2015 COCO Captioning Challenge for 12 teams</h2><font size="2"> **数据集介绍** </font>

<ul>
<li><p>Cite: The coco 2015 captioning challenge. <a href="http://mscoco.org/dataset/#captions-challenge2015" target="_blank" rel="noopener">http://mscoco.org/dataset/#captions-challenge2015</a>.  </p>
</li>
<li><p><a href="https://panderson.me/spice/" target="_blank" rel="noopener">spice website</a> 提供的链接：<a href="https://cocodataset.org/#captions-leaderboard" target="_blank" rel="noopener">https://cocodataset.org/#captions-leaderboard</a></p>
</li>
<li><p>use human judgements collected in the 2015 COCO Captioning Challenge for 12 teams who participated in this captioning challenge.</p>
</li>
<li><p>We report</p>
<ul>
<li><p>M1: Percentage of captions that are evaluated as better or equal to human caption,</p>
</li>
<li><p>M2: Percentage of captions that pass the Turing Test,</p>
</li>
<li><p>M3: Average correctness of the captions on a scale of 1-5 (incorrect - correct),</p>
</li>
<li><p>M4: Average amount of detail of the captions on a scale of 1-5 (lack of details - very detailed) and</p>
</li>
<li><p>M5: Percentage of captions that are similar to human description.</p>
</li>
<li><p>While M1 and M2 were used to rank the captioning models in the COCO challenge.   </p>
<p>M3, M4 and M5  are not used to rank image captioning models , but are intended for an ablation study to understand the various aspects of caption quality.  </p>
</li>
</ul>
</li>
</ul>
<font size="2">**使用 Note** </font>

<p>计算system-level correlation, （1）需要为每个 caption model 来计算一个metric score, 这个分数聚合了由该model 生成的所有的caption 的 metric socre。（2） 然后，该captio model 的aggregate metric score 与 system-level human assessments之间的相关性被计算。</p>
<font size="2"> **评估方式**</font>

<ul>
<li>Compare proposed metric with others on the <strong>Pearson’s ρ correlation</strong> between all common metrics and human judgments collected in the 2015 COCO Captioning Challenge. </li>
</ul>
<h1 id="论文引用情况"><a href="#论文引用情况" class="headerlink" title="论文引用情况"></a>论文引用情况</h1><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Caption-level Correlation</th>
<th></th>
<th></th>
<th>System-Level Correlation</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>Flickr 8k</td>
<td>Composite</td>
<td>pascal-50s</td>
<td>2015 COCO Captioning Challenge</td>
</tr>
<tr>
<td>CIDEr</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>SPICE</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>(CVPR 2018) Learning to Evaluate Image Captioning</td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>(EMNLP-IJCNLP 2019) REO-Relevance, Extraness, Omission A Fine-grained Evaluation for Image Captioning</td>
<td></td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>(ACL 2019) VIFIDEL Evaluating the visual fidelity of image descriptions</td>
<td></td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>(EMNLP2019) TIGEr Text-to-Image Grounding for Image Caption Evaluation</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>(IJCV)Learning-based Composite Metrics for Improved Caption Evaluation</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>图像描述</category>
        <category>评价指标</category>
      </categories>
      <tags>
        <tag>评价指标</tag>
      </tags>
  </entry>
  <entry>
    <title>图像描述任务的实际应用</title>
    <url>/2020/12/24/%E5%9B%BE%E5%83%8F%E6%8F%8F%E8%BF%B0%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h3 id="CaptionBot"><a href="#CaptionBot" class="headerlink" title="CaptionBot"></a>CaptionBot</h3><p>from: <a href="https://www.theguardian.com/technology/2016/apr/14/captionbot-microsoft-latest-ai-experiment-it-isnt-racist" target="_blank" rel="noopener">https://www.theguardian.com/technology/2016/apr/14/captionbot-microsoft-latest-ai-experiment-it-isnt-racist</a></p>
<p>简介：用户上传一张图片到CaptionBot Service，该系统针对该图片自动的生成一个caption。用户可以评分生成的caption 是否准确。</p>
<blockquote>
<p>The idea is that you upload a photo to the service, and it tries to automatically generate a caption that describes what the algorithm sees. You are then able to rate how accurately it has detected what was on display. It learns from the rating, and in theory, the captions get better.</p>
</blockquote>
<p>The bot, from <a href="http://go.theguardian.com/?id=114047X1572903&amp;url=https%3A%2F%2Fwww.microsoft.com%2Fcognitive-services&amp;sref=https://www.theguardian.com/technology/2016/apr/14/captionbot-microsoft-latest-ai-experiment-it-isnt-racist" target="_blank" rel="noopener">Microsoft’s Cognitive Services team</a>, is the result of <a href="http://go.theguardian.com/?id=114047X1572903&amp;url=http%3A%2F%2Fresearch.microsoft.com%2Fpubs%2F264408%2FImageCaptionInWild.pdf&amp;sref=https://www.theguardian.com/technology/2016/apr/14/captionbot-microsoft-latest-ai-experiment-it-isnt-racist" target="_blank" rel="noopener">some hefty research</a> into how to model objects in photographs so that a computer can understand them. They claim that their system can recognise “a broad range of visual concepts” and also performs entity extraction so that it can recognise celebrities. </p>
<p><img src="https://i.loli.net/2020/12/24/kJ31yRYX5dKH64g.jpg" alt="Taylor Swift and Kanye West both identified in Microsoft’s CaptionBot app"></p>
<h3 id="Seeing-AI-项目"><a href="#Seeing-AI-项目" class="headerlink" title="Seeing AI 项目"></a><strong>Seeing AI</strong> 项目</h3><p>微软研究院的研究员们不仅在寻找识别图像的方法，还在为图像进行描述。这项研究结合了图像识别技术与自然语言处理技术，能帮助视障人士获得对图像的准确描述，还可能帮助那些需要图像信息却无法直接看到图像的人——比如正在开车的司机。</p>
<p>Seeing AI项目组中的Margaret Mitchell是一名专攻自然语言处理的研究员，也是图像描述领域顶尖的研究者之一。她说，她和同事们正在寻找方法，让计算机可以用更加人性化的方式来描述图像。例如，计算机可以将一个场景准确地描述为“一群人坐在一起”，但真人可能会将这一场景描述为“一群人坐在一起享受美好时光。”<strong>目前的挑战就是让这项技术懂得一张图像中哪些是对人们最重要、最值得描述的内容。</strong>“<strong>一张图像中有什么，和我们如何谈论一张图像可是完全不同的两回事</strong>，”Mitchell说。</p>
<p>微软的另一些研究员们正在努力让最新的图像识别工具提供更深入的图片解释。例如，与单纯地将图片描述为“一个男人和一个女人坐在一起”相比，对人们更有帮助的描述可能是：“奥巴马和希拉里·克林顿正在摆pose拍照”。今天人们在网上搜索图片时，绝大多数情况下搜索引擎会根据与图片相关的文字内容，从而得到美国名媛金·卡戴珊或“霉霉”泰勒·斯威夫特的照片，这些搜索结果主要依据文本内容。而微软的资深研究员张磊及郭彦东等研究员正在开发一套借助机器学习识别名人、政治家和公众人物的系统，这套系统会根据图像本身的元素，而非与图像相关的文字内容来进行图像识别。</p>
]]></content>
      <categories>
        <category>图像描述</category>
      </categories>
      <tags>
        <tag>图像描述</tag>
      </tags>
  </entry>
  <entry>
    <title>多模态人工智能</title>
    <url>/2021/03/12/%E5%A4%9A%E6%A8%A1%E6%80%81%E4%BA%A4%E4%BA%92%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</url>
    <content><![CDATA[<p>多模态：视觉，语音，自然语言</p>
<p><img src="https://i.loli.net/2021/03/12/8ObjKzRVd4UXgS3.png" alt="image-20210312202150477"></p>
<p><img src="https://i.loli.net/2021/03/12/IqFHGuL6ZYOKwXb.png" alt="image-20210312202209438"></p>
<p><img src="https://i.loli.net/2021/03/12/CsF8TR3m9UlS54N.png" alt="image-20210312202229192"></p>
<p><img src="https://i.loli.net/2021/03/12/HbPD8yaB3GU7IAk.png" alt="image-20210312202108780"></p>
]]></content>
      <categories>
        <category>cross-modal</category>
      </categories>
      <tags>
        <tag>cross-modal</tag>
      </tags>
  </entry>
  <entry>
    <title>安装pytorch_geometricc</title>
    <url>/2019/07/30/%E5%AE%89%E8%A3%85pytorch-geometricc/</url>
    <content><![CDATA[<ul>
<li><p><a href="https://pytorch-geometric.readthedocs.io/en/latest/notes/installation.html#frequently-asked-questions" target="_blank" rel="noopener">官方链接</a></p>
</li>
<li><p>下面是截取自官方</p>
</li>
</ul>
<h2 id="Directly-Installation"><a href="#Directly-Installation" class="headerlink" title="Directly Installation"></a>Directly Installation</h2><p>We have outsourced a lot of functionality of PyTorch Geometric to other packages, which needs to be installed in advance. These packages come with their own CPU and GPU kernel implementations based on the newly introduced <a href="https://github.com/pytorch/extension-cpp/" target="_blank" rel="noopener">C++/CUDA extensions</a> in PyTorch 0.4.0.</p>
<p>Note</p>
<p>We do not recommend installation as root user on your system python. Please setup an <a href="https://conda.io/docs/user-guide/install/index.html/" target="_blank" rel="noopener">Anaconda/Miniconda</a> environment or create a <a href="https://www.docker.com/" target="_blank" rel="noopener">Docker image</a>.</p>
<p>Please follow the steps below for a successful installation:</p>
<ol>
<li><p>Added  by yaya:</p>
<ul>
<li><p>may be you can select a conda environments, will be more fine</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">bash Anaconda3<span class="number">-5.0</span><span class="number">.0</span>-Linux-x86_64.sh</span><br><span class="line">conda create -n pytorch_geometric python=<span class="number">3.7</span> -y</span><br><span class="line">source activate pytorch_geometric</span><br></pre></td></tr></table></figure>
</li>
<li><p>after into env: pytorch_geometric</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">pip</span> <span class="selector-tag">install</span> <span class="selector-tag">torch-1</span><span class="selector-class">.1</span><span class="selector-class">.0-cp37-cp37m-manylinux1_x86_64</span><span class="selector-class">.whl</span>  # <span class="selector-tag">download</span> <span class="selector-tag">at</span> <span class="selector-tag">first</span></span><br><span class="line"><span class="selector-tag">pip</span> <span class="selector-tag">installl</span> <span class="selector-tag">numpy-1</span><span class="selector-class">.17</span><span class="selector-class">.0-cp37-cp37m-manylinux1_x86_64</span><span class="selector-class">.whl</span>  # <span class="selector-tag">download</span> <span class="selector-tag">at</span> <span class="selector-tag">first</span></span><br><span class="line"><span class="selector-tag">pip</span> <span class="selector-tag">install</span> <span class="selector-tag">scipy-1</span><span class="selector-class">.3</span><span class="selector-class">.0-cp37-cp37m-manylinux1_x86_64</span><span class="selector-class">.whl</span>  # <span class="selector-tag">download</span> <span class="selector-tag">at</span> <span class="selector-tag">first</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ol>
<li><p>Ensure that at least PyTorch 1.1.0 is installed:</p>
<blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt; $ python -c <span class="string">"import torch; print(torch.__version__)"</span></span><br><span class="line">&gt; <span class="meta">&gt;&gt;&gt; </span><span class="number">1.1</span>.<span class="number">0</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>Ensure CUDA is setup correctly (optional):</p>
<blockquote>
<ol>
<li><p>Check if PyTorch is installed with CUDA support:</p>
<blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;    &gt; $ python -c <span class="string">"import torch; print(torch.cuda.is_available())"</span></span><br><span class="line">&gt;    &gt; <span class="meta">&gt;&gt;&gt; </span>True</span><br><span class="line">&gt;    &gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>Add CUDA to <code>$PATH</code> and <code>$CPATH</code> (note that your actual CUDA path may vary from <code>/usr/local/cuda</code>):</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; $ <span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/cuda/bin:<span class="variable">$PATH</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; $ <span class="built_in">echo</span> <span class="variable">$PATH</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; &gt;&gt;&gt; /usr/<span class="built_in">local</span>/cuda/bin:...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; $ <span class="built_in">export</span> CPATH=/usr/<span class="built_in">local</span>/cuda/include:<span class="variable">$CPATH</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; $ <span class="built_in">echo</span> <span class="variable">$CPATH</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; &gt;&gt;&gt; /usr/<span class="built_in">local</span>/cuda/include:...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>Add CUDA to <code>$LD_LIBRARY_PATH</code> on Linux and to <code>$DYLD_LIBRARY_PATH</code> on macOS (note that your actual CUDA path may vary from <code>/usr/local/cuda</code>):</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; $ <span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/cuda/lib64:<span class="variable">$LD_LIBRARY_PATH</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; $ <span class="built_in">echo</span> <span class="variable">$LD_LIBRARY_PATH</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; &gt;&gt;&gt; /usr/<span class="built_in">local</span>/cuda/lib64:...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; $ <span class="built_in">export</span> DYLD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/cuda/lib:<span class="variable">$DYLD_LIBRARY_PATH</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; $ <span class="built_in">echo</span> <span class="variable">$DYLD_LIBRARY_PATH</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; &gt;&gt;&gt; /usr/<span class="built_in">local</span>/cuda/lib:...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>Verify that <code>nvcc</code> is accessible from terminal:</p>
<blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt;    &gt; $ nvcc --version</span></span><br><span class="line"><span class="quote">&gt;    &gt; &gt;&gt;&gt; 10.0</span></span><br><span class="line"><span class="quote">&gt;    &gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>Ensure that PyTorch and system CUDA versions match:</p>
<blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;    &gt; $ python -c <span class="string">"import torch; print(torch.version.cuda)"</span></span><br><span class="line">&gt;    &gt; <span class="meta">&gt;&gt;&gt; </span><span class="number">10.0</span></span><br><span class="line">&gt;    &gt; </span><br><span class="line">&gt;    &gt; $ nvcc --version</span><br><span class="line">&gt;    &gt; <span class="meta">&gt;&gt;&gt; </span><span class="number">10.0</span></span><br><span class="line">&gt;    &gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
</blockquote>
</li>
<li><p>Install all needed packages:</p>
<blockquote>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">&gt; <span class="symbol">$</span> you can see <span class="number">4.</span> first (optional)</span><br><span class="line">&gt; <span class="symbol">$</span> pip install --verbose --<span class="keyword">no</span>-cache-dir torch-scatter</span><br><span class="line">&gt; <span class="symbol">$</span> pip install --verbose --<span class="keyword">no</span>-cache-dir torch-sparse</span><br><span class="line">&gt; <span class="symbol">$</span> pip install --verbose --<span class="keyword">no</span>-cache-dir torch-cluster</span><br><span class="line">&gt; <span class="symbol">$</span> pip install --verbose --<span class="keyword">no</span>-cache-dir torch-spline-conv (optional)</span><br><span class="line">&gt; <span class="symbol">$</span> pip install torch-geometric</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>added by yaya:<br>may be you can pip install scipy at first ,because above need it.</p>
</li>
</ol>
<h2 id="Docker-install"><a href="#Docker-install" class="headerlink" title="Docker install"></a>Docker install</h2><ul>
<li><a href="https://github.com/rusty1s/pytorch_geometric/tree/master/docker" target="_blank" rel="noopener">https://github.com/rusty1s/pytorch_geometric/tree/master/docker</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>多标签图像分类任务的评价方法-mAP</title>
    <url>/2019/08/31/%E5%A4%9A%E6%A0%87%E7%AD%BE%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%AF%84%E4%BB%B7%E6%96%B9%E6%B3%95-mAP/</url>
    <content><![CDATA[<p>转载 from: <a href="http://blog.sina.com.cn/s/blog_9db078090102whzw.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_9db078090102whzw.html</a></p>
<p>多标签图像分类（Multi-label   Image  Classification）任务中图片的标签不止一个，因此评价不能用普通单标签图像分类的标准，即mean  accuracy，该任务采用的是和信息检索中类似的方法—mAP（mean  Average  Precision）。mAP虽然字面意思和mean  accuracy看起来差不多，但是计算方法要繁琐得多，以下是mAP的计算方法：</p>
<p>首先用训练好的模型得到所有测试样本的confidence  score，每一类（如car）的confidence   score保存到一个文件中（如comp1_cls_test_car.txt）。假设共有20个测试样本，每个的id，confidence  score和ground  truth  label如下：</p>
<p><a href="http://blog.photo.sina.com.cn/showpic.html#url=http://album.sina.com.cn/pic/002T2ChPgy6XQd58yJ15f" target="_blank" rel="noopener"><img src="http://s16.sinaimg.cn/mw690/002T2ChPgy6XQd58yJ15f" alt="img"></a> </p>
<p>接下来对confidence  score排序，得到：</p>
<p><a href="http://blog.photo.sina.com.cn/showpic.html#url=http://album.sina.com.cn/pic/002T2ChPgy6XQd86isc4c" target="_blank" rel="noopener"><img src="http://s13.sinaimg.cn/mw690/002T2ChPgy6XQd86isc4c" alt="img"></a><em>这张表很重要，接下来的precision和recall都是依照这个表计算的</em>﻿</p>
<p>然后计算precision和recall，这两个标准的定义如下：</p>
<p><a href="http://blog.photo.sina.com.cn/showpic.html#url=http://album.sina.com.cn/pic/002T2ChPgy6XQdjij4Ae8" target="_blank" rel="noopener"><img src="http://s9.sinaimg.cn/mw690/002T2ChPgy6XQdjij4Ae8" alt="img"></a></p>
<p>上图比较直观，圆圈内（true   positives + false  positives）是我们选出的元素,它对应于分类任务中我们取出的结果，比如对测试样本在训练好的car模型上分类，我们想得到top-5的结果，即：</p>
<p><a href="http://blog.photo.sina.com.cn/showpic.html#url=http://album.sina.com.cn/pic/002T2ChPgy6XQdbTpla5c" target="_blank" rel="noopener"><img src="http://s13.sinaimg.cn/mw690/002T2ChPgy6XQdbTpla5c" alt="img"></a></p>
<p>在这个例子中，true   positives就是指第4和第2张图片，false   positives就是指第13，19，6张图片。方框内圆圈外的元素（false   negatives和true  negatives）是相对于方框内的元素而言，在这个例子中，是指confidence   score排在top-5之外的元素，即：</p>
<p><a href="http://blog.photo.sina.com.cn/showpic.html#url=http://album.sina.com.cn/pic/002T2ChPgy6XQdcMwKCea" target="_blank" rel="noopener"><img src="http://s11.sinaimg.cn/mw690/002T2ChPgy6XQdcMwKCea" alt="img"></a> </p>
<p>其中，false   negatives是指第9，16，7，20张图片，true   negatives是指第1,18,5,15,10,17,12,14,8,11,3张图片。</p>
<p>那么，这个例子中Precision=2/5=40%，意思是对于car这一类别，我们选定了5个样本，其中正确的有2个，即准确率为40%；Recall=2/6=30%，意思是在所有测试样本中，共有6个car，但是因为我们只召回了2个，所以召回率为30%。</p>
<p>实际多类别分类任务中，我们通常不满足只通过top-5来衡量一个模型的好坏，而是需要知道从top-1到top-N（N是所有测试样本个数，本文中为20）对应的precision和recall。显然随着我们选定的样本越来也多，recall一定会越来越高，而precision整体上会呈下降趋势。把recall当成横坐标，precision当成纵坐标，即可得到常用的precision-recall曲线。这个例子的precision-recall曲线如下：</p>
<p><a href="http://blog.photo.sina.com.cn/showpic.html#url=http://album.sina.com.cn/pic/002T2ChPgy6XQddBz7ze9" target="_blank" rel="noopener"><img src="http://s10.sinaimg.cn/mw690/002T2ChPgy6XQddBz7ze9" alt="img"></a></p>
<p>接下来说说AP的计算，此处参考的是PASCAL  VOC  CHALLENGE的计算方法。首先设定一组阈值，[0, 0.1, 0.2, …, 1]。然后对于recall大于每一个阈值（比如recall&gt;0.3），我们都会得到一个对应的最大precision。这样，我们就计算出了11个precision。AP即为这11个precision的平均值。这种方法英文叫做11-point interpolated average precision。</p>
<p>当然PASCAL VOC CHALLENGE自2010年后就换了另一种计算方法。新的计算方法假设这N个样本中有M个正例，那么我们会得到M个recall值（1/M, 2/M, …, M/M）,对于每个recall值r，我们可以计算出对应（r’ &gt; r）的最大precision，然后对这M个precision值取平均即得到最后的AP值。计算方法如下：</p>
<p><a href="http://blog.photo.sina.com.cn/showpic.html#url=http://album.sina.com.cn/pic/002T2ChPzy76AuWjHOp29" target="_blank" rel="noopener"><img src="http://s10.sinaimg.cn/mw690/002T2ChPzy76AuWjHOp29" alt="img"></a></p>
<p>相应的Precision-Recall曲线（这条曲线是单调递减的）如下：</p>
<p><a href="http://blog.photo.sina.com.cn/showpic.html#url=http://album.sina.com.cn/pic/002T2ChPzy76AuH9Z6010" target="_blank" rel="noopener"><img src="http://s1.sinaimg.cn/mw690/002T2ChPzy76AuH9Z6010" alt="img"></a></p>
<p>AP衡量的是学出来的模型在每个类别上的好坏，mAP衡量的是学出的模型在所有类别上的好坏，得到AP后mAP的计算就变得很简单了，就是取所有AP的平均值。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>图像描述评价指标的论文总结</title>
    <url>/2020/07/02/%E5%9B%BE%E5%83%8F%E6%8F%8F%E8%BF%B0%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87%E7%9A%84%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h3><p><strong style="color:blue;">(AAAI 2020) Going Beneath the Surface Evaluating Image Captioning for Grammaticality</strong></p>
<ul>
<li><p>语法正确性</p>
</li>
<li><p>准确性</p>
<blockquote>
<p>we investigate is truthfulness, that is, whether a candidate caption is compatible with the content of the image it is supposed to describe.  </p>
</blockquote>
</li>
<li><p>多样性</p>
</li>
</ul>
<p><strong style="color:blue;">(ACL 2019) VIFIDEL Evaluating the visual fidelity of image descriptions</strong></p>
<ul>
<li><p>准确性</p>
<blockquote>
<p> We focus on one such criterion, visual fidelity. </p>
<p>This criterion aims to measure how faithful a description is with respect to what is depicted in the image (i.e. systems should be rewarded for describing elements depicted in the image and penalised for describing things that are not depicted). </p>
</blockquote>
</li>
</ul>
<p><strong style="color:blue;">(EMNLP2019) TIGEr Text-to-Image Grounding for Image Caption Evaluation</strong></p>
<ul>
<li>没有针对，就是使用 image conten 作为 GT，设计了一个评价指标</li>
</ul>
<p><strong style="color:blue;">(EMNLP-IJCNLP 2019) REO-Relevance, Extraness, Omission A Fine-grained Evaluation for Image Captioning</strong></p>
<ul>
<li><p>相关度  Relevance</p>
<blockquote>
<p>relevant information of a candidate caption with respect to the ground truth  </p>
</blockquote>
</li>
<li><p>多余  Extraness</p>
<blockquote>
<p>extra information of a  candidate caption beyond ground truth data  </p>
</blockquote>
</li>
<li><p>缺少  Omission</p>
<blockquote>
<p>missing information that a candidate fails to describe from an image and humangenerated reference captions.  </p>
</blockquote>
</li>
</ul>
<p><strong style="color:blue;">(ICLR 2020 workshop)Egoshots, an ego-vision life-logging dataset and semantic fidelity metric to evaluate diversity in image captioning models</strong></p>
<ul>
<li>多样性？？</li>
</ul>
]]></content>
      <categories>
        <category>图像描述</category>
        <category>评价指标</category>
      </categories>
  </entry>
  <entry>
    <title>完整性-pair</title>
    <url>/2020/07/11/%E5%AE%8C%E6%95%B4%E6%80%A7-pair/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>实验中遇到的问题及解决</title>
    <url>/2019/08/05/%E5%AE%9E%E9%AA%8C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题 1"></a>问题 1</h3><ul>
<li>问题描述：首先表现为：在pycharm debug下和在running模式下的实验结果不一致，&lt;/br&gt;<br>后来，在训练阶段将预训练的模型保存下来，载入evaluate.py 文件中再次进行评估，得到的分数与在训练阶段评估的分数不一致</li>
<li>解决思路：由于第二个现象，更加容易解决，因此先解决他，师兄提出一个办法，将保存的模型再次载入，这样就可以有两个网络，然后比较两个网络的数据是在哪里出现差异的，这样可以找到问题。</li>
<li>解决办法：</li>
</ul>
<ol>
<li>在训练一个epoch 后，将模型保存了下来，然后用两个网络，一个时train.py中重新加载这个网络，一个是在evaluate.py中加载这个网络，将得到的结果，进行比较，（看输出的结果是否一致），然后发现，在一些video 输出的结果是一样的，在一些video是不一样的。&lt;/br&gt;</li>
<li>找到那些video对应的结果不一样的所对应的iteration，在该iteration打印出了网络中的部分变量的数据，发现，在dataloader的数据就是不一样的.&lt;/br&gt;</li>
<li>那么问题就是出现在数据加载上。通过对数据加载部分的代码进行调试，发现，仅在num_workers=0时，两个dataloader的数据才一样，而采用多线程的话，两个dataloader的数据不完全一样。而又在其他的代码上测试，多线程不会影响数据加载，那么问题就是出现在，自己设计的dataset上，&lt;/br&gt;</li>
<li>又发现在加载h5py文件时，没有取切片，而self.critical pytorch代码时加上了的，通过加上切片 <code>[:]</code> 发现在多线程时，是正常的。</li>
</ol>
]]></content>
      <categories>
        <category>问题总结</category>
      </categories>
      <tags>
        <tag>问题总结</tag>
      </tags>
  </entry>
  <entry>
    <title>对分类损失的优化</title>
    <url>/2019/09/23/%E5%AF%B9%E5%88%86%E7%B1%BB%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>少样本学习(few-shot learning)</title>
    <url>/2019/04/09/%E5%B0%91%E6%A0%B7%E6%9C%AC%E5%AD%A6%E4%B9%A0-few-shot-learning/</url>
    <content><![CDATA[<h2 id="小样本学习的概念"><a href="#小样本学习的概念" class="headerlink" title="小样本学习的概念"></a>小样本学习的概念</h2><ul>
<li>少样本学习(few-shot learning)的目标是在<strong>已知类别(Seen Class)训练一个分类模型，使它能够在只有少量数据的未知类别(Unseen Class)上面具有很好的泛化性能</strong>。</li>
<li>少样本学习面临两个重要的问题：<br>（1）已知类别和未知类别之间没有交集，导致它们的数据分布差别很大，不能直接通过训练分类器和微调(finetune)的方式得到很好的性能；<br>（2）未知类别只有极少量数据(每个类别1或者5个训练样本)，导致分类器学习不可靠。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>完整性分析</title>
    <url>/2020/07/03/%E5%AE%8C%E6%95%B4%E6%80%A7%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>Class: flying kite Video: 8iPflOxQaao_000018_000028</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1Xf4y1y7AP&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] An announcer is talking while a kid is showing how to wind a power flyer and let it go into the air.<br>[2] A boy winds a powered kite engine then launches the kite, which flies then is displayed on a table.<br>[3] A boy is outside winding up a toy plane,then throws it in the air to fly.<br>[4] An announcer is talking while a kid is showing how to wind a power flyer and let it go into the air.<br>[5] A boy winds a powered kite engine then launches the kite, which flies then is displayed on a table.<br><strong>Prediction:</strong><br>[baseline]: a young boy in a red shirt is holding a baseball bat .<br>[graph_kl]: a little girl is standing in a field and is holding a kite .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A boy is jumping on a trampoline and doing some flips.<br>A boy is jumping on a trampoline, doing various jumps and flips.<br>A boy is jumping on a trampoline and does a flip.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A little boy is flying a kite and some person is helping him to fly<br>A woman is trying to help a young boy fly a kite.<br>A little boy is flying a kite and his mother helps him.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>Someone is flying a kite up in the sky and trying to reel it in.<br>A sky with clouds and a break of sun fades to black, before a woman riding a kite sail is on the water.</p>
<hr>
<p>Class: carving ice Video: UArdunmwEdA_000049_000059</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1mt4y1X7fE&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A man chiseling and picking at a large block of ice.<br>[2] A man shaves ice off a large block and talks to a worker.<br>[3] A man shaves ice off a large block and talks to a worker.<br>[4] one person carving an ice block with a tool and another person holding a ice carving machine<br>[5] An ice sculptor shows how he begins a typical project.<br><strong>Prediction:</strong><br>[baseline]: a man is using a chainsaw to carve a block of ice .<br>[graph_kl]: a man is using a tool to carve a block of ice .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A man makes an ice sculpture using a carving saw.<br>A man uses a tool to carve an ice sculpture while a class of people watch him.<br>A man showing his skills in an outdoor ice carving competition.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A person is carving an ice sculpture from a block of ice with a chainsaw.<br>A man makes an ice sculpture using a carving saw.<br>A man uses a tool to carve an ice sculpture while a class of people watch him.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A person is creating an ice sculpture as viewers take it all in.<br>A person is making an ice sculpture and it appears to be a seahorse.</p>
<hr>
<p>Class: tobogganing Video: vTSO26j_g3E_000006_000016</p>
<iframe src="//player.bilibili.com/player.html?aid=286089586&bvid=BV1Rf4y1y7nN&cid=203899418&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A man and a baby sled down a snow covered hill in the winter.<br>[2] A man and a small child ride a sled down a snowy hill.<br>[3] A man and a small child ride a sled down a snowy hill.<br>[4] An adult is sliding down a snowy hill on a sunny day.<br>[5] A man and a child are sledding down a hill.<br><strong>Prediction:</strong><br>[baseline]: a person is sledding down a snowy hill on a sled .<br>[graph_kl]: a person is riding a sled down a snowy hill .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A little boy gets a on a sled and goes down a snowy hill.<br>An adult and a child share a sled ride down a snowy hill.<br>A man and a child are sliding down a mountain on a sled with other people around them.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A woman and child are sledding down a snowy hill together.<br>An adult and child are together sledding down a snowy slope.<br>An adult and a child share a sled ride down a snowy hill.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A woman and a young child are sliding on a sled in the snow.<br>A little boy gets a on a sled and goes down a snowy hill.</p>
<hr>
<p>Class: jogging Video: gf37sAjEfRc_000013_000023</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1Bz4y1Q7Ai&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] Two boys are running in slow motion towards playground equipment.<br>[2] a group of people running together in a park as they pass by each other having fun<br>[3] Two young men are racing a course outside and going in slow motion as they pass a woman<br>[4] Two young men are racing a course outside and going in slow motion as they pass a woman<br>[5] A woman high fiving people who are  running past her in the park.<br><strong>Prediction:</strong><br>[baseline]: a group of people are standing in a field and one of them is holding a ball .<br>[graph_kl]: a man is teaching a young boy how to do a karate kick .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>Two young boys are chasing each other playfully around a park<br>A young boy runs down the street in order to catch a ball.<br>Two boys playing around in a park and running around.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A group of people are playing basketball on an outdoor court.<br>A group of boys are playing a game of soccer outside.<br>Two young girls are dancing to music at a restaurant.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A group of adults and children a grouped together outside as a small group is lowering a object into the ground.<br>A bunch of kids outside playing a game of socceer together on the field</p>
<hr>
<p>Class: throwing ball (not baseball or American football) Video: GXO1eYu4kr8_000000_000010</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1JT4y1J7R6&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] a man sitting on a gym floor throwing a black ball<br>[2] A man seated is throwing a ball to a man standing indoors.<br>[3] A man sitting on a gym floor with legs spread passes a ball to another man who is standing.<br>[4] A man sitting on a gymnasium floor throws a large ball to a standing man.<br>[5] A man, seated on the floor with his back against the wall and legs spread apart, throws a ball to a standing man in a gymnasium.<br><strong>Prediction:</strong><br>[baseline]: a young boy is practicing his basketball skills in a gym .<br>[graph_kl]: a man is standing in the middle of a gym and throws a ball .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>Grown men in the gymnasium play dodgeball, one blocks a ball with another ball that his friend catches and then two men get hit with balls.<br>Men are in a gymnasium playing dodge ball with their hands<br>A group of men throwing several balls to children indoors.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A man throws a football to someone in an indoor gym<br>A young man is kicking a soccer ball to somebody else on the gymnasium floor.<br>A man in a gym steps back and throws a football.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>a person in a gym by themselves throwing a football to the other side of the gym<br>A man in a gym kicks a white ball back and forth.</p>
<hr>
<p>Class: sipping cup Video: saXahlRV7s4_000022_000032</p>
<iframe src="//player.bilibili.com/player.html?aid=286068284&bvid=BV1df4y1y7oD&cid=203899246&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A little boy holding a sippy cup of juice smiling and giggling.<br>[2] A little boy is sucking juice out of a cup while a man is talking to him.<br>[3] A baby drinks juice from a sippy cup and smiles while a person hold the bottom of the cup them pokes his belly.<br>[4] A baby is sipping a juice in a bottle and a man speaks to him<br>[5] A little boy holding a sippy cup of juice smiling and giggling.<br><strong>Prediction:</strong><br>[baseline]: a baby is drinking from a sippy cup while a woman talks to him .<br>[graph_kl]: a baby is sitting on a couch and drinking from a sippy cup .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A baby sips liquid out of a sippy cup with great gusto.<br>A little boy holding a sippy-cup begins to mumble and then takes a sip from the cup.<br>A young child drinks out of straw in a sippy type cup.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A toddler drinks from a sippy cup while talking to a woman.<br>A man holds a baby while she drinks from a sippy cup.<br>A man holds a young child while they drink from a sippy cup.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A baby is holding onto a pink sippy cup with two hands and drinking from it.<br>A toddler drinks from a sippy cup while talking to a woman.</p>
<hr>
<p>Class: welding Video: Hgo7xkutPno_000059_000069</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1Ez411e7QD&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] The man used a welding tool while covering his face with a protective mask.<br>[2] A man is welding metal together while wearing protective gear.<br>[3] Someone is welding while there is rock music playing in the background.<br>[4] A person with a mask works welding under an overhead light.<br>[5] A person wearing a welders helmet, using a welding torch on an object.<br><strong>Prediction:</strong><br>[baseline]: a group of people are welding a piece of metal .<br>[graph_kl]: a person is using a torch to blow a piece of wood .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>a person using a tool to do some welding wearing protective gear<br>A man in proper protective gear is welding metal together.<br>A man in a mask welding pieces of metal together.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A man with a welding mask on is speaking while welding an object.<br>The man is wearing a face mask while welding pipes together.<br>A man in proper protective gear is welding metal together.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A person welds metal creating sparks and bright flashes of light.<br>Someone uses a welding tool to weld something together, it creates a very bright light.</p>
<hr>
<p>Class: cutting pineapple Video: NRC5oMoNHn0_000003_000013</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV12t4y1X7tM&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A man is teaching how to cut a pineapple by cutting off top and bottom.<br>[2] In a kitchen, a chef instructs and demonstrates how to cut a pineapple.<br>[3] A chef chops a pineapple on the counter; removing the top first and then the rest.<br>[4] A man is teaching how to cut a pineapple by cutting off top and bottom.<br>[5] In a kitchen, a chef instructs and demonstrates how to cut a pineapple.<br><strong>Prediction:</strong><br>[baseline]: a man is demonstrating how to cut a pineapple with a knife .<br>[graph_kl]: a man is demonstrating how to cut a pineapple with a knife .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A person is demonstrating how to cut up a pineapple in a kitchen.<br>A person shows how to cut a pineapple in order to get to the core of the fruit.<br>A man is cutting a pineapple with a small knife.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A person is demonstrating how to cut up a pineapple in a kitchen.<br>A woman is demonstrating how to cut an orange with a knife.<br>A man demonstrates how to cut into an orange using a knife.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A man is cutting a pineapple with a small knife.<br>A person uses a knife to demonstrate how to cut the ends and skin off of a pineapple.</p>
<hr>
<p>Class: making paper aeroplanes Video: IbDcOoO9m6g_000139_000149</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1ni4y1x7xP&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A kid is demonstrating some origami and is folding the paper into a triangle.<br>[2] A person folds a piece of paper over a decorative dark board.<br>[3] A person shows how to fold the napkin to decorate the hotel tables<br>[4] A person shows how to fold the napkin to decorate the hotel tables<br>[5] A person shows how to fold the napkin to decorate the hotel tables<br><strong>Prediction:</strong><br>[baseline]: a person is folding a piece of paper into a triangle .<br>[graph_kl]: a person is demonstrating how to fold a piece of paper .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A person shows how to fold a piece of paper folding in the different corners and then the top.<br>A young boy is showing a technique to fold a piece of paper into a paper airplane.<br>A little boy demonstrates how to fold a paper plane using paper.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A man demonstrates folding a piece of green paper into origami.<br>A young boy is showing a technique to fold a piece of paper into a paper airplane.<br>Someone is demonstrating how to fold a piece of paper to make an airplane.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A woman folds a napkin in half to form a triangle, then folds the points towards the center.<br>a woman is showing how to fold a napkin in order to create something</p>
<hr>
<p>Class: trimming shrubs Video: tGiBJQ5RhZQ_000077_000087</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1cV411k7yR&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A man is standing and using clippers to trim a bush.<br>[2] A man is standing and using clippers to trim a bush.<br>[3] A man uses a gardening tool to cut shrubbery as he details the process.<br>[4] A man cutting plants it lengthy branches and give instruction to other.<br>[5] a gardener is showing how to trim parts of a hedge<br><strong>Prediction:</strong><br>[baseline]: a man is using a chainsaw to trim a tree .<br>[graph_kl]: a man is using a chainsaw to cut a piece of wood .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A man with garden shears describing how to trim bushes<br>A man using pruning shears is explaining and demonstrating how to trim an evergreen tree.<br>A guy stands outside as he snips away at the branches in a bush.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A man using pruning shears is explaining and demonstrating how to trim an evergreen tree.<br>A man with garden shears describing how to trim bushes<br>A guy stands outside as he snips away at the branches in a bush.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A guy stands outside as he snips away at the branches in a bush.<br>A man in an orange shirt trims trees while standing high up in the branches.</p>
<hr>
<p>Class: using circular saw Video: _YWpv2_K8Pk_000054_000064</p>
<iframe src="//player.bilibili.com/player.html?aid=456121030&bvid=BV1D5411W7zB&cid=203800090&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] Someone is cutting down wood on a saw carefully with another piece pushing it.<br>[2] A man is cutting a block of wood with a table saw and pushing it along with another piece of wood.<br>[3] A person is feeding a piece of wood into a table or bench saw to cut it.<br>[4] A person cutting a wooden board on a flat table saw<br>[5] A guy is running a wood board through a saw a few times.<br><strong>Prediction:</strong><br>[baseline]: a man is using a tool to cut a piece of wood .<br>[graph_kl]: a man is using a tool to cut a piece of wood .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>a man is cutting construction wood using a table saw<br>A man had a wood on his lap while carving it with a knife<br>A person is using a skill saw to cut through a piece of wood.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>The man uses a circular saw to cut a piece of lumber.<br>A person with a circular saw is cutting a piece of wood.<br>A person uses an electric saw to cut through a piece of wood.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A person is rolling dough on a table with a roller.<br>a man measures a long piece of wood next to a machine</p>
<hr>
<p>Class: walking the dog Video: KvVRY61JS7A_000023_000033</p>
<iframe src="//player.bilibili.com/player.html?aid=841065180&bvid=BV1U54y1B7ga&cid=204027776&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] Two people are walking two dogs down their street together.<br>[2] A man and a boy walking their 2 dogs on the street but the boy fell down and cried.<br>[3] A man and a toddler are walking two dogs down the street.<br>[4] Two people are walking two dogs down their street together.<br>[5] A baby bumps into a dog and cries while walking down road.<br><strong>Prediction:</strong><br>[baseline]: a woman is walking on a sidewalk with a dog on her back .<br>[graph_kl]: a person is walking down the street and a man is walking .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A boy is walking a dog on a leash on a street.<br>A little boy is walking his tiny dog on the streets.<br>A boy is skateboarding and walking his dog at the same time.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A woman and a child are walking down the sidewalk.<br>A woman and her young child are walking down the sidewalk.<br>A little boy is walking his tiny dog on the streets.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A person uses a power washer to remove paint from an asphalt surface.<br>A kid in a white shirt hits his head against a wall and falls to the ground.</p>
<hr>
<p>Class: blowing leaves Video: VNXpHy5Tb_U_000064_000074</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1if4y1y71S&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A little boy runs a leaf blower for a short minute then cuts it off.<br>[2] A small boy is blowing the leaves with a leaf blower and the blower stops.<br>[3] A boy using an electric leaf blower on debris outdoors suddenly stops working and walks away.<br>[4] a person in front of different leaves trying to blow them away with a  machine<br>[5] A young boy using a leaf blower moves leaves in a yard then shuts off the leaf blower and talks to someone else.<br><strong>Prediction:</strong><br>[baseline]: a man is using a chainsaw to cut a pile of wood .<br>[graph_kl]: a man is using a leaf blower to blow leaves in a yard .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A man is blowing off leaves using a leaf blower off of the pavement<br>Man rides lawn mower with leaf-blower attachment over cleared grass and blows fallen leaves under trees.<br>An individual uses a leaf blower to get rid of several leaves.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A man is blowing off leaves using a leaf blower off of the pavement<br>An individual uses a leaf blower to get rid of several leaves.<br>A person uses a leaf blower to blow leaves from a house gutter.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A man picked up a stick with a mound of mud at the base<br>A boy is stick in a muddy ditch trying to get out of it.</p>
<hr>
<p>Class: ice swimming Video: dC2Ih_JFoOM_000000_000010</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1cD4y1Q7BX&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] Two men in underwear step into a pond and one of the men dips under the water very quickly and immediately heads to get out of the pond.<br>[2] Two men wade into the water and one dunks under the water.<br>[3] Two men wade into the water and one dunks under the water.<br>[4] Two men wade into the water and one dunks under the water.<br>[5] two men are walking into the water in a cold day<br><strong>Prediction:</strong><br>[baseline]: a group of people are in a pool and one of them jumps into the water .<br>[graph_kl]: a group of people are in a pool and one of them jumps into the water .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A man wearing swimming trunks goes for a swim in freezing cold water.<br>A man in orange swim trunks and a white beanie walked into a pool of cold winter water.<br>A man was swimming in icy water and then came out<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A man walked into a cold pool of water and walked back out while talking to another person.<br>A man is walking into a wide body of water.<br>A man is wading into a body of lake water.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>Two men are wading in water and one tries to catch something with a strange tool.<br>A man is wading into a body of lake water.</p>
<hr>
<p>Class: opening door Video: lcUJjVgqXp4_000000_000010</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV19V411r7FF&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A person is showing how to unlock a locked door using a folded playing card.<br>[2] A person dhowing to take a playing card and unlock a door to get it.<br>[3] A man used a folded card to open the lock of a door<br>[4] A person dhowing to take a playing card and unlock a door to get it.<br>[5] A man is showing how to open a door using a folded playing card.<br><strong>Prediction:</strong><br>[baseline]: a person is using a machine to open a door .<br>[graph_kl]: a person opens a door and opens the door and opens the door .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A man is demonstrating how to pick a lock on a door.<br>A very close up angle shows a guy picking the lock to a door.<br>A person demonstrates using lockpicks to open a standard lock.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A man is demonstrating how to pick a lock on a door.<br>A boy is opening a door lock using a pin.<br>A man attempts to unlock a door using some simple tools.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A man in a mask power cleans a portable machine.<br>A man is withdrawing some money and a receipt out of an ATM machine</p>
<hr>
<p>Class: scrapbooking Video: uh50grtCQSA_000026_000036</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1ma4y1Y7HQ&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] a person writes something on a colorful canvass that they have in front of them<br>[2] A little girl is explaining her notebook and how she likes it as she flips the pages.<br>[3] A young girl writes a note on her scrapbook, then flips through it.<br>[4] A girl is showing the only thing she has done in her scrapbook.<br>[5] A child is showing and describing what she did with her scrapbook.<br><strong>Prediction:</strong><br>[baseline]: a person is folding a piece of paper on a table .<br>[graph_kl]: a person is showing how to fold a piece of paper .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A girl colors in a hand-drawn map of the countries of the world.<br>A woman quietly looks through the pages of a homemade scrapbook.<br>A person is showing designs on different pages in a scrapbook.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A woman quietly looks through the pages of a homemade scrapbook.<br>A person is showing designs on different pages in a scrapbook.<br>A person is showing how they draw in a sketch book.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A person folds a cloth into a triangle then folds the corner in again.<br>A person is using cardboard to properly fold a shirt.</p>
<hr>
<p>Class: waxing chest Video: cb3RvnukQVs_000159_000169</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1vk4y1z7GR&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A guy laying flat on his back as a woman attempts to wax his chest and stomach.<br>[2] A woman looks at a man’s bare chest and removes excess wax with a paper towel.<br>[3] A man is laying down on his back shirtless while a woman uses wax strips to help remove the hair.<br>[4] A woman cleans up hair of a man’s belly after he was waxed.<br>[5] A woman cleans up hair of a man’s belly after he was waxed.<br><strong>Prediction:</strong><br>[baseline]: a man is getting his chest waxed by a woman .<br>[graph_kl]: a man is laying on his stomach while another person is waxing his chest .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A man lays face down as a woman waxes his back.<br>A woman is waxing a man’s chest hair.<br>A woman applying hair removal wax strips to a man’s chest<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A woman is waxing a man’s chest hair.<br>A man is laying on the table getting his chest hair waxed.<br>A man is having his back waxed by a woman<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A person is removing strips of wax from another persons back to remove the hair.<br>A man covered in wax and a person pulling the wax off of his back.</p>
<hr>
<p>Class: diving cliff Video: 5D4HjS92zSQ_000126_000136</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV17i4y1G7rb&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A boy does a backflip off a precipice into a body of water<br>[2] A person does a backflip off a cliff into water while others are already in the water.<br>[3] On a high cliff boys jump into a water quarry.<br>[4] A man does a back-flip off of a cliff, while his friend watches from the water below.<br>[5] A person is doing a flip off of a cliff into a lake.<br><strong>Prediction:</strong><br>[baseline]: a man jumps off of a cliff into a body of water .<br>[graph_kl]: a man jumps off a cliff into a body of water .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A man does various flips while jumping off of a cliff into the water.<br>A man does a front flip off of a cliff into a body of water, then a backflip.<br>One of the men from the top of the cliff jumped off and landed in the water<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A man does various flips while jumping off of a cliff into the water.<br>A man does a front flip off of a cliff into a body of water, then a backflip.<br>A boy jumps off a cliff into a pool of water.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A person jumps off a cliff into a large body of water.<br>A boy jumps from a cliff into some water and another boy is climbing out of the water</p>
<hr>
<p>Class: giving or receiving award Video: kRdxCmOsY2Y_000003_000013</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV15A411i7Cg&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A man stands on a stage in front of an audience as he hands an award to another man walking on the stage.<br>[2] Four people are called up onto a stage, and one accepts an award.<br>[3] A man is presenting a prize to a group of four.<br>[4] A man stands on a stage in front of an audience as he hands an award to another man walking on the stage.<br>[5] A man presents a group of young adults with an award.<br><strong>Prediction:</strong><br>[baseline]: a man is standing in front of a crowd and singing a song .<br>[graph_kl]: a group of people are on a stage in front of an audience .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>An older gentleman is standing at a podium accepting an award when another gentleman walks across the stage and shakes his hand.<br>People are cheering as a man is welcomed on stage.<br>A man is on a stage introducing himself to an audience.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>An older gentleman is standing at a podium accepting an award when another gentleman walks across the stage and shakes his hand.<br>A man is standing on a stage and speaking to a crowd.<br>A man is on a stage introducing himself to an audience.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>Three people are on stage performing a play and one of them is singing.<br>Two men and a woman are performing a play on a stage.</p>
<hr>
<p>Class: fly tying Video: _PdB7OGolCo_000191_000201</p>
<iframe src="//player.bilibili.com/player.html?aid=838500851&bvid=BV1Eg4y1q7fp&cid=203798508&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A spool of thread is wrapped around a small hook several times.<br>[2] A man uses an object to wrap string around another object.<br>[3] A person ties very fine string around a small hook.<br>[4] A spool of thread is wrapped around a small hook several times.<br>[5] Someone shows how to wrap a fish hook with thread using a tool to hold it.<br><strong>Prediction:</strong><br>[baseline]: a man is demonstrating how to make a fly fishing lure .<br>[graph_kl]: a man is demonstrating how to make a fishing lure .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>a person using their fingers to wrap string around a hook<br>A person holds a piece of string with a loop at the end, they place the loop over a hook and tighten the loop.<br>A man is carefully wrapping the hook with some thread.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A man is demonstrating how to wrap a hook with string.<br>A person is demonstrating how to tie a fishing string to a hook.<br>A man is demonstrating how to secure wire to a hook.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A man describes how to create snags using a line and a hook.<br>A person holds a hook and connects material to create a fly hook.</p>
<hr>
<p>Class: bottling Video: 38Jn4r_pcpg_000167_000177</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1Xt4y1X7L1&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A man is making beer and pours some of his beer into another container to even them out.<br>[2] A man is in a kitchen and pulls out bottles from a pot that is sitting on the counter.<br>[3] A man is in a kitchen and pulls out bottles from a pot that is sitting on the counter.<br>[4] A guy has two bottles in his hands and is pouring liquid from one bottle to the other.<br>[5] A man picks up to amber beer type bottles and pours fluid from one into the other.<br><strong>Prediction:</strong><br>[baseline]: a man is demonstrating how to make a recipe in a kitchen .<br>[graph_kl]: a man is demonstrating how to use a machine to make a meal .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>a man is pouring a bottle of beer into a large glass.<br>A man pours a bottle of beer into a large beer glass.<br>A man standing in a kitchen holds a bottle and a cup then pours whats in the bottle into the cup.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>a man is pouring a bottle of beer into a large glass.<br>A man pours a bottle of beer into a large beer glass.<br>A man picks up a brewing pot and pours water into a cup.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A man picks up a brewing pot and pours water into a cup.<br>A male is in the kitchen showing how he pours water out quickly out the pot.</p>
<hr>
<p>Class: dancing gangnam style Video: 53Ia-BtpM5A_000002_000012</p>
<iframe src="//player.bilibili.com/player.html?aid=841116130&bvid=BV1X54y1B7pu&cid=203898322&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A toddler girl dances across the floor while listening to music.<br>[2] A little girls is dancing to music next to her toy scooter.<br>[3] A toddler dressed in pink is dancing while music is playing.<br>[4] A toddler girl dances across the floor while listening to music.<br>[5] A little girl is dancing to the popular Korean song ‘Gangnam Style.’<br><strong>Prediction:</strong><br>[baseline]: a little girl is sitting on the floor and is dancing to music .<br>[graph_kl]: a little girl is sitting on the floor and dancing to music .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A little girl on a small table dances along to a video playing on tv.<br>A young girl is giving a tap dancing performance while music plays in the background.<br>A group of young people are shown while a girl is shown dancing to music.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>Two young girls are dancing to music at a restaurant.<br>a young boy is in his room listening to music and dancing<br>A young man dances on a kitchen floor as music plays.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>a small girl riding her small pink bike while a bell clinks<br>This little girl is dancing on her toes like a ballerina.</p>
<hr>
<p>Class: falling off bike Video: 7QyQVBclhT4_000000_000010</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV18a4y1Y7Bn&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A kid rides a bike down a hill going too fast and has a wipe out.<br>[2] A young kid riding a bike across sand and crashing it<br>[3] Uncontrolled bicycle, careening down a desert hill, leaves boy with multiple sand abrasions.<br>[4] A kid rides a bike down a hill going too fast and has a wipe out.<br>[5] A boy is speeding down a sand hill on a bicycle which wobbles and throws him off.<br><strong>Prediction:</strong><br>[baseline]: a man is riding a bike on a beach and then falls over .<br>[graph_kl]: a man is riding a bike on a dirt road .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A guy on a bike goes down a steep hill and wrecks, tumbling down the hill.<br>A boy tips forward and falls on his face while trying to do a bicycle trick.<br>Slow motion action of young man jumping with bicycle doen a hillside and tumbling to the bottom.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A man rides his bike in the snow and wipes out.<br>A man on a bike goes down a hill then falls off from his bike.<br>A person rides a dirtbike up a steep hill then falls.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A person rides a bicycle down a hill and over a dirt berm<br>A man rode a dirt bike over a very steep dirt hill</p>
<hr>
<p>Class: long jump Video: QyMTEHd-VCc_000004_000014</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1v54y1B7X4&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A person is running and then performs a long jump into a sand box.<br>[2] A woman is practicing her long jumps while her friend records.<br>[3] A woman runs then does a high jump to create distance.<br>[4] A woman runs then does a high jump to create distance.<br>[5] A person is running and then performs a long jump into a sand box.<br><strong>Prediction:</strong><br>[baseline]: a man is running down a track and jumps into a pit of sand .<br>[graph_kl]: a man runs down a track and jumps into a sand pit .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A person running and then leaping to perform a long jump<br>An athlete runs down the track and performs a long jump.<br>People watch as a woman runs down a track, then jumps into the air for a long jump.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>An athlete runs down the track and performs a long jump.<br>A man is running and doing a long jump, while people are watching.<br>A young woman runs down an asphalt track then performs a long jump.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A competitor is taking a running start and then successfully performs a high jump.<br>A person is outside and they are jumping over a vault for some type of track event.</p>
<hr>
<p>Class: knitting Video: t-COcCPV-T4_000020_000030</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1ff4y1y7xc&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] Someone is showing how to crochet through some sort of material.<br>[2] A gir lis trying to stitching up the black and white knitting kit with a knitting needle<br>[3] A young girl shows how to crochet and encourages her own type of technique.<br>[4] A gir lis trying to stitching up the black and white knitting kit with a knitting needle<br>[5] Someone is showing how to crochet through some sort of material.<br><strong>Prediction:</strong><br>[baseline]: a person is demonstrating how to fix a bicycle .<br>[graph_kl]: a person is using a needle to sew a piece of fabric .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A woman holds needle and yarn and she demonstrates how to knit.<br>A woman demonstrates how to knit using needles and yarn.<br>A tutorial with a women demonstrating knitting techniques using yarn.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A woman is demonstrating how to work with a piece of fabric.<br>A woman demonstrates how to knit using needles and yarn.<br>A person is demonstrating how to weave a small basket.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A person is using cloth to design an image of a frog.<br>A person with glasses works on the tubing of a bicycle tire.</p>
<hr>
<p>Class: historical reenactment Video: oGpVHf4xooM_000160_000170</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1Bp4y1D7NJ&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] People are watching as men in uniforms are shooting each other.<br>[2] People are watching as men in uniforms are shooting each other.<br>[3] A group of people in uniforms fire guns while a crowd watches.<br>[4] A group of people watch a reenact-ion of a fight from the American revolution from behind a fence.<br>[5] People are moving across a green field and firing rifles, while spectators look on.<br><strong>Prediction:</strong><br>[baseline]: a large group of people are gathered around a large group of people .<br>[graph_kl]: a group of people are standing in a field and a man is talking .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A group of people are watching a war reenactment and walking around.<br>Civil war reenactors are shooting at each other as someone is recording them.<br>A group of people are in a field re-enacting a battle scene with guns.<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A group of people are watching a war reenactment and walking around.<br>A group of men in a field are doing an reenactment of a battle and firing guns.<br>Several people are in a field doing a war re-enactment.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A group of people are outside, they are dressed up and recreating the civil war.<br>People are sitting outside talking as some other people are standing up.</p>
<hr>
<p>Class: home roasting coffee Video: WU5KZsG_mQk_000483_000493</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1XC4y1a7Cf&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><strong>Two reference sentences corresponding to this video:</strong><br>[1] A man is pouring hot coffee beans from a roaster onto a flat surface.<br>[2] A person illustrates and demonstrates how to brew several types of cocoa beans for coffee making.<br>[3] A man is pouring hot coffee beans from a roaster onto a flat surface.<br>[4] A person is removing a set of beans on a table that  are being prepped for dinner.<br>[5] A person illustrates and demonstrates how to brew several types of cocoa beans for coffee making.<br><strong>Prediction:</strong><br>[baseline]: a man is using a power tool to cut a piece of metal .<br>[graph_kl]: a person is using a machine to heat a piece of metal .<br><strong>[STS] Top 3 most similar sentences in all val corpus:</strong><br>A man using a roasting machine to roast coffee beans.<br>A person lifts up a switch which drops coffee beans into a machine that stirs them.<br>A man is stiring some coffee beans in a strainer with a wooden spoon<br><strong>[bertscore_idf] Top 3 most similar sentences in all val corpus:</strong><br>A man using a roasting machine to roast coffee beans.<br>The lady is doing a demonstration on the equipment to roast coffee beans.<br>A person is roasting coffee beans in a wok and then puts them in a cup.<br><strong>[video_text_retrieval] Top 3 most similar sentences in all val corpus:</strong><br>A man wearing protective headwear uses a soldering  iron to solder two piece of metal together.<br>A man has put coffee beans into a metal strainer and using a wooden spoon is grinding the beans so they will be ready to be used to make a special coffee.</p>
<hr>
]]></content>
  </entry>
  <entry>
    <title>指数加权平均</title>
    <url>/2019/04/09/%E6%8C%87%E6%95%B0%E5%8A%A0%E6%9D%83%E5%B9%B3%E5%9D%87/</url>
    <content><![CDATA[<p>参考：<a href="https://zhuanlan.zhihu.com/p/29895933" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29895933</a><br><a href="https://www.jianshu.com/p/41218cb5e099" target="_blank" rel="noopener">https://www.jianshu.com/p/41218cb5e099</a></p>
<h2 id="指数加权平均"><a href="#指数加权平均" class="headerlink" title="指数加权平均"></a>指数加权平均</h2><p><strong>v<sub>t</sub></strong> 是要代替  θ_t  的估计值，代表第t天的指数平均温度值<br><strong>θ<sub>t</sub></strong> 代表第t天的实际温度值<br><strong>β</strong> 代表可调节的超参数值  </p>
<p>则第t天的指数平均温度，可用如下公式表示<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1wnugwmkrj30ne0ggjsp.jpg" width="50%" height="50%">    </p>
<p>将<strong>v<sub>100</sub></strong> 展开可得:<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1wonisescj30j201o0sr.jpg"><br>v<sub>t</sub> 是对每天温度的加权平均，之所以称之为指数加权，是因为加权系数是随着时间以指数形式递减的，<strong>时间越靠近，权重越大</strong>，越靠前，权重越小。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1667471-485da343fbd96353.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/665/format/webp" alt><br>再来看下面三种情况：</p>
<p>当 β = 0.9 时，指数加权平均最后的结果如图<strong>红色线</strong>所示，代表的是最近 10 天的平均温度值；<br>当 β = 0.98 时，指结果如图<strong>绿色线</strong>所示，代表的是最近 50 天的平均温度值；<br>当 β = 0.5 时，结果如下图<strong>黄色线</strong>所示，代表的是最近 2 天的平均温度值；</p>
<p><img src="//upload-images.jianshu.io/upload_images/1667471-7d82e7b89e860299.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/473/format/webp" alt></p>
<p><img src="//upload-images.jianshu.io/upload_images/1667471-6fd989467bcb6121.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/475/format/webp" alt></p>
<p><strong>β 越小，噪音越多</strong>，虽然能够很快的适应温度的变化，但是更容易出现奇异值。</p>
<p><strong>β 越大，得到的曲线越平坦</strong>，因为多平均了几天的温度，这个曲线的波动更小。<br>但有个缺点是，因为只有 0.02 的权重给了当天的值，而之前的数值权重占了 0.98 ，<br>曲线进一步右移，在温度变化时就会适应地更缓慢一些，会出现一定延迟。</p>
<p>通过上面的内容可知，β 也是一个很重要的超参数，不同的值有不同的效果，需要调节来达到最佳效果，<strong>一般 0.9 的效果就很好</strong>。</p>
<p>作者：不会停的蜗牛<br>链接：<a href="https://www.jianshu.com/p/41218cb5e099" target="_blank" rel="noopener">https://www.jianshu.com/p/41218cb5e099</a><br>来源：简书  </p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>我们可以看到指数加权平均的求解过程实际上是一个递推的过程，那么这样就会有一个非常大的好处，每当我要求从0到某一时刻（n）的平均值的时候，我并不需要像普通求解平均值的作为，保留所有的时刻值，类和然后除以n。</p>
<p>而是只需要保留0-(n-1)时刻的平均值和n时刻的温度值即可。也就是每次只需要保留常数值，然后进行运算即可，这对于深度学习中的海量数据来说，是一个很好的减少内存和空间的做法。</p>
<h2 id="为什么在优化算法中使用指数加权平均"><a href="#为什么在优化算法中使用指数加权平均" class="headerlink" title="为什么在优化算法中使用指数加权平均"></a>为什么在优化算法中使用指数加权平均</h2><p>上面提到了一些 指数加权平均 的应用，这里我们着重看一下在优化算法中的作用。</p>
<p>以 Momentum 梯度下降法为例，</p>
<p><strong>Momentum 梯度下降法</strong>，就是计算了梯度的指数加权平均数，并以此来更新权重，它的运行<strong>速度几乎总是快于标准的梯度下降算法</strong>。</p>
<p><strong>这是为什么呢？</strong></p>
<p>让我们来看一下这个图，</p>
<p><img src="//upload-images.jianshu.io/upload_images/1667471-07d825d3e2624537.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/745/format/webp" alt></p>
<p>例如这就是我们要优化的成本函数的形状，图中红点就代表我们要达到的最小值的位置，<br>假设我们<strong>从左下角这里出发开始用梯度下降法</strong>，那么蓝色曲线就是一步一步迭代，一步一步向最小值靠近的轨迹。</p>
<p>可以看出<strong>这种上下波动，减慢了梯度下降法的速度</strong>，而且无法使用更大的学习率，因为如果用较大的学习率，可能会偏离函数的范围。</p>
<p>如果有一种方法，可以使得在纵轴上，学习得慢一点，减少这些摆动，但是在横轴上，学习得快一些，快速地从左向右移移向红点最小值，那么训练的速度就可以加快很多。</p>
<p>这个方法就是动量 Momentum 梯度下降法，它<strong>在每次计算梯度的迭代中，对 dw 和 db 使用了指数加权平均法的思想</strong>，</p>
<p><img src="//upload-images.jianshu.io/upload_images/1667471-eedf9342a4bce813.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/272/format/webp" alt></p>
<p>这样我们就可以得到如图红色线的轨迹：</p>
<p><img src="//upload-images.jianshu.io/upload_images/1667471-f9e70b57daae0359.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/718/format/webp" alt></p>
<p>可以看到：<br><strong>纵轴方向</strong>，平均过程中正负摆动相互抵消，平均值接近于零，摆动变小，学习放慢。<br><strong>横轴方向</strong>，因为所有的微分都指向横轴方向，因此平均值仍然较大，向最小值运动更快了。<br>在抵达最小值的路上减少了摆动，加快了训练速度。</p>
<p>作者：不会停的蜗牛<br>链接：<a href="https://www.jianshu.com/p/41218cb5e099" target="_blank" rel="noopener">https://www.jianshu.com/p/41218cb5e099</a><br>来源：简书  </p>
]]></content>
  </entry>
  <entry>
    <title>数据集收集过程--各论文汇总</title>
    <url>/2020/06/06/%E6%95%B0%E6%8D%AE%E9%9B%86%E6%94%B6%E9%9B%86%E8%BF%87%E7%A8%8B-%E5%90%84%E8%AE%BA%E6%96%87%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h3 id="Stanford-Natural-Language-Inference"><a href="#Stanford-Natural-Language-Inference" class="headerlink" title=" Stanford Natural Language Inference "></a><font color="red"> Stanford Natural Language Inference </font></h3><blockquote>
<p>A large annotated corpus for learning natural language inference</p>
</blockquote>
<h4 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a><strong>数据收集</strong></h4><p>从Flickr 上的human written captions 作为 <strong>premises</strong> 。</p>
<p>（1）AMT workers 手工写 与 premises 相对应label下的句子：（不提供图像的前提下）Asked AMT workers to supply hypotheses for each of our three labels entailment, neutral, and contradiction. 即得到<strong>hypotheses</strong> 。 (这种label, 称为 author label)</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gfhjx642jrj30k90pk441.jpg" style="zoom:50%"></p>
<p>（2）基于得到的premises-hypotheses pair，再由4个 AMT workers进行评估，从三种类别中【entailment, neutral, and contradiction  】中，选择一个label，基于此，则对于每个premises-hypotheses pair，有5个label，基于共识，为该pair选择一个最终的label（称为 gold label.）</p>
<blockquote>
<p>5个label: </p>
<p>(1) original author 算一个，因为他是首先在给定promise 和 label 的情况下，写出的hypotheses</p>
<p>(2) 根据 给出的 promise 和 hypotheses， 来给标签，【entailment, neutral, and contradiction】</p>
<p>共识：如果有&gt;=3个人给出同一个标签，则赋予为该标签</p>
<p>但是，若没有这种共识（2% of cases），则分配一个占位符。（但是，这种数据没有什么用，无法应用于NLI任务）</p>
</blockquote>
<h4 id="Data-validation"><a href="#Data-validation" class="headerlink" title="Data validation  "></a><strong>Data validation  </strong></h4><p><strong>为了评估，基于上述的数据标注，得到的数据是否可靠</strong>。又从整个标注的数据中取了5%，再次由AMT workers做如（2）中的标注工作。看看前后两次标注的结果是否相关。这次AMT workers 选择的label 称为 Individual label 。得到如下的统计结果。可以看出Individual label 与之前的 gold label/ author’s label 有较高的一致性，即，之前的标注工作是可靠的。</p>
<ul>
<li><font color="red"><strong>yaya</strong> </font>个人觉得，这是一种马后炮的行为，没什么用，因为之前的标注，已经完成了，钱也花了。这种验证，即便是验证结果不好，那也没有什么修正措施。</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gfhl3kdkdtj30gj0na42d.jpg" style="zoom:50%"></p>
<p>表格中还使用 Fleiss 来计算human annotator 之间的一致性</p>
<blockquote>
<p>Fleiss : <a href="https://www.jianshu.com/p/f9c383b39859" target="_blank" rel="noopener">简书</a><br><a href="shiyaya.github.io/2020/08/06/评价者之间的一致性-Kappas/">yaya blog</a></p>
</blockquote>
<h3 id="Visual-Entailment-Dataset"><a href="#Visual-Entailment-Dataset" class="headerlink" title=" Visual Entailment Dataset  "></a><font color="red"> Visual Entailment Dataset  </font></h3><h4 id="数据收集-1"><a href="#数据收集-1" class="headerlink" title="数据收集"></a>数据收集</h4><p>该数据集是在 Flickr 和 SNLI dataset 的一个简单集成。</p>
<p>任务是，给出一个image-text pair，希望model 预测该pair 的匹配程度[Entailment, Contradiction, Neutral]。</p>
<p>数据的收集：在 SNLI dataset 就是基于 Flickr30k image captions 构建的，</p>
<ul>
<li><strong>Entailment</strong> holds if there is enough evidence in image to conclude that text is true.</li>
<li><strong>Contradiction</strong> holds if there is enough evidence in image to conclude that text is false.</li>
<li><strong>Neutral</strong>, implying the evidence in image is insufficient to draw a conclusion about text.  </li>
</ul>
<h4 id="该文提出了几个构建数据集的准则"><a href="#该文提出了几个构建数据集的准则" class="headerlink" title="该文提出了几个构建数据集的准则"></a><strong>该文提出了几个构建数据集的准则</strong></h4><p>基于在SNLI, VQA-v1.0, VQA-v2.0, and CLEVR, 这个几个数据集上的经验， 这里提出了四个准则来开发一个新的数据集:</p>
<ul>
<li><strong>Structured set of real-world images.</strong> The dataset should be based on real-world images and the same image can be paired with different hypotheses to form different labels. </li>
<li><strong>Fine-grained.</strong> The dataset should enforce fine-grained reasoning about subtle changes in hypotheses that could lead to distinct labels. </li>
<li><strong>Sanitization.</strong> No instance overlapping across different dataset partitions. One image can only exist in a single partition.  </li>
<li><strong>Account for any bias.</strong> Measure the dataset bias and  provide baselines to serve as the performance lower bound for potential future evaluations.  该文中提出了一些单纯仅仅使用</li>
</ul>
<h3 id="WMT-Shared-Task"><a href="#WMT-Shared-Task" class="headerlink" title="WMT Shared Task  "></a><font color="red">WMT Shared Task  </font></h3><h4 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h4><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gfijyrn8qsj30zw0gvwl7.jpg" style="zoom:50%"></p>
<h4 id="Human-judgement-quality-control"><a href="#Human-judgement-quality-control" class="headerlink" title="Human judgement quality control"></a>Human judgement quality control</h4><ul>
<li><p>每个标注者，每次HIT任务：给定100个 （reference+ candidate）pair, 针对给定的reference, 评估生成的candidate的好坏。</p>
</li>
<li><p>100个pair中有60个用于quality control，40个由participating systems 生成的翻译组成。</p>
<p>（1）这60个pair，是官方设计出来的，包括三类，repeat pairs (expecting a similar judgment), damage MT outputs/ bad reference (expecting significantly worse scores) and use references instead of MT outputs (expecting high scores). 因此仅仅会有20%的资源消耗：bad reference; good reference</p>
<p>Specifically，先从正常的MT system 中 得到30个 （reference, MT output）pair，如 table 5 中的 original system output， 然后1)对1-10对，进行重复，得到10对。2）对11-20对，将MT output搞破坏。或者是对reference caption搞破坏，得到10对。3）对21-30对，取corresponding reference—&gt; (reference_1, reference_2)，得到10对。</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gepxhtqcpgj311h052abz.jpg"></p>
<p>（2）within each 100-translation HIT， 每个articipating system<strong>等比例的贡献</strong>a（within each 100-translation HIT, the same proportion of translations are included from each participating system for that language pair.  ）这是为了确保每个参与的 系统含有近似的相同数量的评估。同时，这也从三个方面得到了公平性的评估：1）每有一个workers做一个HIT, 则就会为所有参与的系统增加human judgement。2）不会轻易受到worker个性差异的影响，因为每个worker都会给所有参与的系统进行评估。3）尽管DA判断是绝对的，但众所周知，判断者会根据观察到的总体翻译质量来“校准”他们使用量表的方式。 对于每个HIT（包括所有参与的系统），这种影响都是平均的。</p>
</li>
</ul>
<h4 id="Annotator-Agreement"><a href="#Annotator-Agreement" class="headerlink" title="Annotator Agreement"></a>Annotator Agreement</h4><p>（1）由于 bad reference pairs 的质量应该是显著偏低的，通过查看人类在这类pairs 上的评分是否也是显著偏低。来过滤掉可信赖度低的human assessors。</p>
<p>set（A, bad reference） 与  set（A, translatin_B）这两个集合上的人类评估，计算一个p-value， 若p-value&gt;0.05 则说明该human assessor的可信度低。</p>
<p>（2）对于 repeat pairs, 查看得到 repeat assessments的程度。</p>
<h4 id="Producing-the-Human-Ranking"><a href="#Producing-the-Human-Ranking" class="headerlink" title="Producing the Human Ranking"></a>Producing the Human Ranking</h4><ul>
<li><p>Standardized </p>
<p>为了消除不同的人类评估者的评分策略的差异，首先根据每个人类评估者的总体平均得分和标准差得分对翻译的人类评估得分进行<strong>标准化</strong>。</p>
</li>
</ul>
<h3 id="VIOLIN-Video-and-Language-Inference"><a href="#VIOLIN-Video-and-Language-Inference" class="headerlink" title="[VIOLIN] Video-and-Language Inference "></a><font color="red">[VIOLIN] Video-and-Language Inference </font></h3><p>yaya blog: <a href="https://shiyaya.github.io/2020/03/28/VIOLIN-A-Large-Scale-Dataset-for-Video-and-Language-Inference/" target="_blank" rel="noopener">https://shiyaya.github.io/2020/03/28/VIOLIN-A-Large-Scale-Dataset-for-Video-and-Language-Inference/</a></p>
<h4 id="数据集收集简介"><a href="#数据集收集简介" class="headerlink" title="数据集收集简介"></a>数据集收集简介</h4><p> 该任务是在给定 Subtitles  和 video 的情况下，推断一个statement 是否与 video 相符合[entailed (label 1) ，contradicts (label 0) ]。</p>
<p><strong>positive statements 的收集</strong>：给出 subtitles + video，然后annotators 写出与其想对应的 statements。</p>
<p><strong>negative statements 的收集</strong>：（1）要求annotators通过只更改positive statements 的几个单词或短语来编写negative statements。（2）进行<strong>对抗匹配</strong>：对于每个视频，从其他视频的陈述库中选择具有挑战性和令人困惑的陈述作为否定陈述。具体地，对于video_i/j 已经分别有其相对应的 positive statement H_i/j , 则通过查找与H_i 最相近的H_j 作为 negative statements。 对抗匹配的方式可以消除 human bias的影响。</p>
<h4 id="数据收集-Instruction"><a href="#数据收集-Instruction" class="headerlink" title="数据收集 Instruction"></a>数据收集 Instruction</h4><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gfil6timz7j31c60van7q.jpg"><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gfil6tix9ij313e150na4.jpg"><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gfil6tj9shj30ts14mtl2.jpg"></p>
<h4 id="用户界面-1"><a href="#用户界面-1" class="headerlink" title="用户界面"></a>用户界面</h4><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gfilt0g35qj316o128n4z.jpg" style="zoom:50%"></p>
<h3 id="VCR"><a href="#VCR" class="headerlink" title="VCR"></a><font color="red">VCR</font></h3><p>yaya blog: <a href="https://shiyaya.github.io/2020/05/16/From-Recognition-to-Cognition-Visual-Commonsense-Reasoning/" target="_blank" rel="noopener">https://shiyaya.github.io/2020/05/16/From-Recognition-to-Cognition-Visual-Commonsense-Reasoning/</a></p>
<h4 id="用户界面-2"><a href="#用户界面-2" class="headerlink" title="用户界面"></a>用户界面</h4><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gfioadgc3qj30r20pbn3e.jpg"></p>
<h4 id="Crowdsourcing-quality-data"><a href="#Crowdsourcing-quality-data" class="headerlink" title="Crowdsourcing quality data"></a>Crowdsourcing quality data</h4><p><strong>Automated quality checks</strong></p>
<p>在众包UI中加入了一些<strong>自动</strong>的检测，比如，workers 在写 question、answer、rationale 时，有单词数量的限制且必须要指定一个detection</p>
<p><strong>Instructions  </strong></p>
<p>鼓励workers，编写的question，是比较high-level的（需要一定的推理步骤），同时不要编写一些general questions, 即不针对image 本身的那些问题。</p>
<p>同时为workers 提供了一些例子展示。</p>
<p><strong>Qualification exam  </strong></p>
<p>再进行正式的标注之前，先做一个测试，验证该worker 具有标注VCR数据的能努力。</p>
<p>The qualification test included a mix of multiple-choice graded answers as well as a short written section, which was to provide a single question, answer, and rationale for an image.  </p>
<p>在完成这个质量测试之后，由发布该任务的requester(即VCR论文作者)来手工看，这个worker是否具有资格。</p>
<p><strong>Work verification</strong>  </p>
<p>查看 workers 编写的 question、answer、rationales是否符合要求。由于这项检查工作，工作量也很大，因此，将这种检查工作也当做另外一种 HIT 当做任务进行发布，由那些outstanding workers in previous annotation work 来完成这项检查工作, 每为 一位another worker完成了检查工作，将得到 $0.4</p>
<h3 id="Composite-dataset"><a href="#Composite-dataset" class="headerlink" title="Composite dataset"></a><font color="red">Composite dataset</font></h3><p>From: <code>From Images to Sentences through Scene Description Graphs using Commonsense Reasoning and Knowledge</code></p>
<h4 id="数据集介绍"><a href="#数据集介绍" class="headerlink" title="数据集介绍"></a>数据集介绍</h4><p>该篇文章是做 image captioning 任务，为了更好的评估该captioning model 的性能，将模型生成的预测上传到AMT，让人类去评估。（为了对比，除了评估our_captioning_model 的预测，本文还评估了gold-standard description 和 the output from a state-of-the-art image captioning system.  ）</p>
<p>该文中从两个方面进行评估：相关性和全面性:  <strong>how much the description conveys the image content</strong> (relevance) and <strong>how much of the image content is conveyed by the description</strong> (thoroughness)。</p>
<h4 id="Instruction"><a href="#Instruction" class="headerlink" title="Instruction"></a>Instruction</h4><ul>
<li>很简单的 Instruction，也没有给范例。</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gfiysqscgfj316r0e943t.jpg"><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gfiysr0uf8j317i0g2an3.jpg"></p>
<ul>
<li>没有说在数据标注过程中，加入一些监督workers的操作。（这主要是本篇的目的不是为了进行数据收集，而只是简单的去评估 captioning model）</li>
</ul>
<h3 id="Reinforcement-Learning-in-Image-QE"><a href="#Reinforcement-Learning-in-Image-QE" class="headerlink" title="Reinforcement Learning in Image QE"></a>Reinforcement Learning in Image QE</h3><p>From: Reinforcing an Image Caption Generator Using Off-Line Human Feedback  </p>
<p>该文是引入强化学习，以及human judgement score, 来做 image captioning 任务</p>
<p>为了评估提出的captioning model 的性能，将其在数据集上的预测结果，提交到众包平台，让人类进行打分。提出了两种评估方式：Single-caption evaluation  和 Side-by-side caption evaluation  </p>
<p><strong>Single-caption evaluation</strong></p>
<p>给出image-captioning pair,然后，让6个不同的raters进行打分[good, bad], 然后对这6个评分取平均，或者是取majority voting，作为该pair 的最终得分</p>
<p><strong>Side-by-side caption evaluation</strong>  </p>
<p>给出 (image, our_model_prediction, baseline_model_prediction) 这个三元组，然后让raters, 选一个更贴合image的sentence。<strong>并且，从三个方面进行评估，信息性、正确性、流畅性</strong></p>
]]></content>
  </entry>
  <entry>
    <title>排序(sort)</title>
    <url>/2019/04/18/%E6%8E%92%E5%BA%8F-sort/</url>
    <content><![CDATA[<ul>
<li>快速排序与冒泡排序均是进行交换操作，使用的空间复杂度为O(1)，而插入排序的空间复杂度为O(n)</li>
<li>快速排序的平均时间复杂度为O(nlogn)，最坏情况复杂度为O(n^2)</li>
<li>冒泡排序的时间复杂度为O(n^2)</li>
<li>插入排序的时间复杂度为O(n^2)</li>
</ul>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><blockquote>
<p>待补充</p>
</blockquote>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(nums, left, right)</span>:</span></span><br><span class="line">    tmp = left</span><br><span class="line">    reference = nums[left]  <span class="comment"># 以最左端的nums[left] 作为中位数</span></span><br><span class="line">    left = left</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] &lt;= reference:</span><br><span class="line">            left = left + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] &gt; reference:</span><br><span class="line">            right = right - <span class="number">1</span></span><br><span class="line">        nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">    <span class="keyword">if</span> nums[left] &lt; reference:</span><br><span class="line">        nums[left], nums[tmp] = nums[tmp], nums[left]</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        nums[left<span class="number">-1</span>], nums[tmp] = nums[tmp], nums[left<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> left<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">QuickSort</span><span class="params">(nums , left, right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; right:</span><br><span class="line">        index = partition(nums, left, right)</span><br><span class="line">        QuickSort(nums, left, index<span class="number">-1</span>)</span><br><span class="line">        QuickSort(nums, index+<span class="number">1</span>, right)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment"># nums = [1,2,3,4]</span></span><br><span class="line"><span class="comment"># nums = [3,2,5,6,4,4,4,5,6]</span></span><br><span class="line">left = <span class="number">0</span></span><br><span class="line">right = len(nums)<span class="number">-1</span></span><br><span class="line">QuickSort(nums, left, right)</span><br><span class="line">print(nums)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>梯度消失与梯度爆炸的原因以及解决方案</title>
    <url>/2019/03/22/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E4%B8%8E%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>转载from: <a href="https://blog.csdn.net/raojunyang/article/details/79962665" target="_blank" rel="noopener">https://blog.csdn.net/raojunyang/article/details/79962665</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要深入介绍深度学习中的梯度消失和梯度爆炸的问题以及解决方案。本文分为三部分，第一部分主要直观的介绍深度学习中为什么使用梯度更新，第二部分主要介绍深度学习中梯度消失及爆炸的原因，第三部分对提出梯度消失及爆炸的解决方案。有基础的同鞋可以跳着阅读。<br>其中，梯度消失爆炸的解决方案主要包括以下几个部分。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>预训练加微调</span><br><span class="line"><span class="bullet">- </span>梯度剪切、权重正则（针对梯度爆炸）</span><br><span class="line"><span class="bullet">- </span>使用不同的激活函数</span><br><span class="line"><span class="bullet">- </span>使用batchnorm</span><br><span class="line"><span class="bullet">- </span>使用残差结构</span><br><span class="line"><span class="bullet">- </span>使用LSTM网络</span><br></pre></td></tr></table></figure>
<h1 id="第一部分：为什么要使用梯度更新规则"><a href="#第一部分：为什么要使用梯度更新规则" class="headerlink" title="第一部分：为什么要使用梯度更新规则"></a>第一部分：为什么要使用梯度更新规则</h1><hr>
<ul>
<li><p>在介绍梯度消失以及爆炸之前，先简单说一说梯度消失的根源—–深度神经网络和反向传播。目前深度学习方法中，深度神经网络的发展造就了我们可以构建更深层的网络完成更复杂的任务，深层网络比如深度卷积网络，LSTM等等，而且最终结果表明，在处理复杂任务上，深度网络比浅层的网络具有更好的效果。但是，目前优化神经网络的方法都是基于反向传播的思想，即根据损失函数计算的误差通过梯度反向传播的方式，指导深度网络权值的更新优化。这样做是有一定原因的，首先，深层网络由许多非线性层堆叠而来，每一层非线性层都可以视为是一个非线性函数 (非线性来自于非线性激活函数），因此整个深度网络可以视为是一个复合的非线性多元函数 </p>
</li>
<li><p>我们最终的目的是希望这个多元函数可以很好的完成输入到输出之间的映射，那么，优化深度网络就是为了寻找到合适的权值，满足取得极小值点，比如最简单的损失函数 </p>
</li>
<li>假设损失函数的数据空间是下图这样的，我们最优的权值就是为了寻找下图中的最小值点，对于这种数学寻找最小值问题，采用梯度下降的方法再适合不过了。 </li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1baz0q65tj30e809edj1.jpg"></p>
<h1 id="第二部分：梯度消失、爆炸"><a href="#第二部分：梯度消失、爆炸" class="headerlink" title="第二部分：梯度消失、爆炸"></a>第二部分：梯度消失、爆炸</h1><p>梯度消失与梯度爆炸其实是一种情况，看接下来的文章就知道了。两种情况下梯度消失经常出现，一是在<strong>深层网络</strong>中，二是采用了<strong>不合适的损失函数</strong>，比如sigmoid。梯度爆炸一般出现在深层网络和<strong>权值初始化值太大</strong>的情况下，下面分别从这两个角度分析梯度消失和爆炸的原因。</p>
<h3 id="1-深层网络角度"><a href="#1-深层网络角度" class="headerlink" title="1.深层网络角度"></a>1.深层网络角度</h3><p>比较简单的深层网络如下：<br><img src="https://img-blog.csdn.net/20171219215626301?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图中是一个四层的全连接网络，假设每一层网络激活后的输出为,其中为第层, 代表第层的输入，也就是第层的输出，是激活函数，那么，得出，简单记为。<br>BP算法基于梯度下降策略，以目标的负梯度方向对参数进行调整，参数的更新为，给定学习率，得出。如果要更新第二隐藏层的权值信息，根据链式求导法则，更新梯度信息：<br>，很容易看出来，即第二隐藏层的输入。<br>所以说，就是对激活函数进行求导，如果此部分大于1，那么层数增多的时候，最终的求出的梯度更新将以指数形式增加，即发生<strong>梯度爆炸</strong>，如果此部分小于1，那么随着层数增多，求出的梯度更新信息将会以指数形式衰减，即发生了<strong>梯度消失</strong>。如果说从数学上看不够直观的话，下面几个图可以很直观的说明深层网络的梯度问题（图片内容来自参考文献1）：</p>
<p>注：下图中的隐层标号和第一张全连接图隐层标号刚好相反。<br>图中的曲线表示权值更新的速度，对于下图两个隐层的网络来说，已经可以发现隐藏层2的权值更新速度要比隐藏层1更新的速度慢</p>
<p><img src="https://img-blog.csdn.net/20171220110058983?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">那么对于四个隐层的网络来说，就更明显了，第四隐藏层比第一隐藏层的更新速度慢了两个数量级：</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdn.net/20171220110732927?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><strong>总结：</strong>从深层网络角度来讲，不同的层学习的速度差异很大，表现为网络中靠近输出的层学习的情况很好，靠近输入的层学习的很慢，有时甚至训练了很久，前几层的权值和刚开始随机初始化的值差不多。因此，梯度消失、爆炸，其<strong>根本原因</strong>在于反向传播训练法则，属于<a href="https://www.baidu.com/s?wd=%E5%85%88%E5%A4%A9%E4%B8%8D%E8%B6%B3&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">先天不足</a>，另外多说一句，Hinton提出capsule的原因就是为了彻底抛弃反向传播，如果真能大范围普及，那真是一个革命。</p>
<h3 id="2-激活函数角度"><a href="#2-激活函数角度" class="headerlink" title="2.激活函数角度"></a>2.激活函数角度</h3><p>其实也注意到了，上文中提到计算权值更新信息的时候需要计算前层偏导信息，因此如果激活函数选择不合适，比如使用sigmoid，梯度消失就会很明显了，原因看下图，左图是sigmoid的损失函数图，右边是其倒数的图像，如果使用sigmoid作为损失函数，其梯度是不可能超过0.25的，这样经过链式求导之后，很容易发生梯度消失，sigmoid函数数学表达式为：<br><img src="https://img-blog.csdn.net/20171220113129230?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="sigmoid函数"><img src="https://img-blog.csdn.net/20171220113422675?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="sigmoid函数导数"></p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">同理，<span class="built-in">tanh</span>作为损失函数，它的导数图如下，可以看出，<span class="built-in">tanh</span>比<span class="built-in">sigmoid</span>要好一些，但是它的倒数仍然是小于<span class="number">1</span>的。<span class="built-in">tanh</span>数学表达为：</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdn.net/20171220114016270?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="第三部分：梯度消失、爆炸的解决方案"><a href="#第三部分：梯度消失、爆炸的解决方案" class="headerlink" title="第三部分：梯度消失、爆炸的解决方案"></a>第三部分：梯度消失、爆炸的解决方案</h1><hr>
<h3 id="2-1-方案1-预训练加微调"><a href="#2-1-方案1-预训练加微调" class="headerlink" title="2.1 方案1-预训练加微调"></a>2.1 方案1-预训练加微调</h3><p>此方法来自Hinton在2006年发表的一篇论文，Hinton为了解决梯度的问题，提出采取无监督逐层训练方法，其基本思想是每次训练一层隐节点，训练时将上一层隐节点的输出作为输入，而本层隐节点的输出作为下一层隐节点的输入，此过程就是逐层“预训练”（pre-training）；在预训练完成后，再对整个网络进行“微调”（fine-tunning）。Hinton在训练深度信念网络（Deep Belief Networks中，使用了这个方法，在各层预训练完成后，再利用BP算法对整个网络进行训练。此思想相当于是先寻找局部最优，然后整合起来寻找全局最优，此方法有一定的好处，但是目前应用的不是很多了。</p>
<h3 id="2-2-方案2-梯度剪切、正则"><a href="#2-2-方案2-梯度剪切、正则" class="headerlink" title="2.2 方案2-梯度剪切、正则"></a>2.2 方案2-梯度剪切、正则</h3><p><strong>梯度剪切</strong>这个方案主要是针对梯度爆炸提出的，其思想是设置一个梯度剪切阈值，然后更新梯度的时候，如果梯度超过这个阈值，那么就将其强制限制在这个范围之内。这可以防止梯度爆炸。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注：在WGAN中也有梯度剪切限制操作，但是和这个是不一样的，WGAN限制梯度更新信息是为了保证lipchitz条件。</span><br></pre></td></tr></table></figure>
<p>另外一种解决梯度爆炸的手段是采用<strong>权重正则化</strong>（weithts regularization）比较常见的是正则，和正则，在各个深度框架中都有相应的API可以使用正则化，比如在中，若搭建网络的时候已经设置了正则化参数，则调用以下代码可以直接计算出正则损失：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">regularization_loss = tf.add_n(tf<span class="selector-class">.losses</span><span class="selector-class">.get_regularization_losses</span>(scope=<span class="string">'my_resnet_50'</span>))</span><br></pre></td></tr></table></figure>
<p>如果没有设置初始化参数，也可以使用以下代码计算正则损失：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">l2_loss = tf.add_n([tf<span class="selector-class">.nn</span><span class="selector-class">.l2_loss</span>(var) <span class="keyword">for</span> <span class="selector-tag">var</span> <span class="keyword">in</span> tf.trainable_variables() <span class="keyword">if</span> <span class="string">'weights'</span> <span class="keyword">in</span> <span class="selector-tag">var</span>.name])</span><br></pre></td></tr></table></figure>
<p>正则化是通过对网络权重做正则限制过拟合，仔细看正则项在损失函数的形式： </p>
<p>其中，是指正则项系数，因此，如果发生梯度爆炸，权值的范数就会变的非常大，通过正则化项，可以部分限制梯度爆炸的发生。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注：事实上，在深度神经网络中，往往是梯度消失出现的更多一些。</span><br></pre></td></tr></table></figure>
<h3 id="2-3-方案3-relu、leakrelu、elu等激活函数"><a href="#2-3-方案3-relu、leakrelu、elu等激活函数" class="headerlink" title="2.3 方案3-relu、leakrelu、elu等激活函数"></a>2.3 方案3-relu、leakrelu、elu等激活函数</h3><p><strong>Relu:</strong>思想也很简单，如果激活函数的导数为1，那么就不存在梯度消失爆炸的问题了，每层的网络都可以得到相同的更新速度，relu就这样应运而生。先看一下relu的数学表达式：</p>
<p><img src="https://img-blog.csdn.net/20171220115642365?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>其函数图像：</p>
<p><img src="https://img-blog.csdn.net/20171220115719332?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>从上图中，我们可以很容易看出，relu函数的导数在正数部分是恒等于1的，因此在深层网络中使用relu激活函数就不会导致梯度消失和爆炸的问题。</p>
<p><strong>relu</strong>的主要贡献在于：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 解决了梯度消失、爆炸的问题</span></span><br><span class="line"><span class="comment">-- 计算方便，计算速度快</span></span><br><span class="line"><span class="comment">-- 加速了网络的训练</span></span><br></pre></td></tr></table></figure>
<p>同时也存在一些<strong>缺点</strong>：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 由于负数部分恒为0，会导致一些神经元无法激活（可通过设置小学习率部分解决）</span></span><br><span class="line"> <span class="comment">-- 输出不是以0为中心的</span></span><br></pre></td></tr></table></figure>
<p>尽管relu也有缺点，但是仍然是目前使用最多的激活函数</p>
<p><strong>leakrelu</strong><br>leakrelu就是为了解决relu的0区间带来的影响，其数学表达为：其中k是leak系数，一般选择0.01或者0.02，或者通过学习而来</p>
<p><img src="https://img-blog.csdn.net/20170702211001517?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FpY2FpYXRuYnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>leakrelu解决了0区间带来的影响，而且包含了relu的所有优点<br><strong>elu</strong><br>elu激活函数也是为了解决relu的0区间带来的影响，其数学表达为：<img src="https://img-blog.csdn.net/20171220134603079?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>其函数及其导数数学形式为：</p>
<p><img src="https://img-blog.csdn.net/20171220134614121?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>但是elu相对于leakrelu来说，计算要更耗时间一些</p>
<h3 id="2-4-解决方案4-batchnorm"><a href="#2-4-解决方案4-batchnorm" class="headerlink" title="2.4 解决方案4-batchnorm"></a>2.4 解决方案4-batchnorm</h3><p><strong>Batchnorm</strong>是深度学习发展以来提出的最重要的成果之一了，目前已经被广泛的应用到了各大网络中，具有加速网络收敛速度，提升训练稳定性的效果，Batchnorm本质上是解决反向传播过程中的梯度问题。batchnorm全名是batch normalization，简称BN，即批规范化，通过规范化操作将输出信号x规范化到均值为0，方差为1保证网络的稳定性。<br>具体的batchnorm原理非常复杂，在这里不做详细展开，此部分大概讲一下batchnorm解决梯度的问题上。具体来说就是反向传播中，经过每一层的梯度会乘以该层的权重，举个简单例子：<br>正向传播中，那么反向传播中，，反向传播式子中有的存在，所以的大小影响了梯度的消失和爆炸，batchnorm就是通过对每一层的输出规范为均值和方差一致的方法，消除了带来的放大缩小的影响，进而解决梯度消失和爆炸的问题。<br>有关batch norm详细的内容可以参考我的另一篇博客：<br><a href="http://blog.csdn.net/qq_25737169/article/details/79048516" target="_blank" rel="noopener">http://blog.csdn.net/qq_25737169/article/details/79048516</a></p>
<h3 id="2-5-解决方案5-残差结构"><a href="#2-5-解决方案5-残差结构" class="headerlink" title="2.5 解决方案5-残差结构"></a>2.5 解决方案5-残差结构</h3><p><strong>残差结构</strong>说起残差的话，不得不提这篇论文了：Deep Residual Learning for Image Recognition，关于这篇论文的解读，可以参考知乎链接：<a href="https://zhuanlan.zhihu.com/p/31852747" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31852747</a>这里只简单介绍残差如何解决梯度的问题。<br>事实上，就是残差网络的出现导致了image net比赛的终结，自从残差提出后，几乎所有的深度网络都离不开残差的身影，相比较之前的几层，几十层的深度网络，在残差网络面前都不值一提，残差可以很轻松的构建几百层，一千多层的网络而不用担心梯度消失过快的问题，原因就在于残差的捷径（shortcut）部分，其中残差单元如下图所示：<br><img src="https://img-blog.csdn.net/20171220144105760?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>相比较于以前网络的直来直去结构，残差中有很多这样的跨层连接结构，这样的结构在反向传播中具有很大的好处，见下式：<br><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial%20loss%7D%7B%5Cpartial%20%7B%7Bx%7D_%7Bl%7D%7D%7D=%5Cfrac%7B%5Cpartial%20loss%7D%7B%5Cpartial%20%7B%7Bx%7D_%7BL%7D%7D%7D%5Ccdot%20%5Cfrac%7B%5Cpartial%20%7B%7Bx%7D_%7BL%7D%7D%7D%7B%5Cpartial%20%7B%7Bx%7D_%7Bl%7D%7D%7D=%5Cfrac%7B%5Cpartial%20loss%7D%7B%5Cpartial%20%7B%7Bx%7D_%7BL%7D%7D%7D%5Ccdot%20%5Cleft%28%201%2B%5Cfrac%7B%5Cpartial%20%7D%7B%5Cpartial%20%7B%7Bx%7D_%7BL%7D%7D%7D%5Csum%5Climits_%7Bi=l%7D%5E%7BL-1%7D%7BF%28%7B%7Bx%7D_%7Bi%7D%7D,%7B%7BW%7D_%7Bi%7D%7D%29%7D%20%5Cright%29" alt="这里写图片描述"><br>式子的第一个因子  表示的损失函数到达 L 的梯度，小括号中的1表明短路机制可以无损地传播梯度，而另外一项残差梯度则需要经过带有weights的层，梯度不是直接传递过来的。残差梯度不会那么巧全为-1，而且就算其比较小，有1的存在也不会导致梯度消失。所以残差学习会更容易。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注：上面的推导并不是严格的证明。</span><br></pre></td></tr></table></figure>
<h3 id="2-6-解决方案6-LSTM"><a href="#2-6-解决方案6-LSTM" class="headerlink" title="2.6 解决方案6-LSTM"></a>2.6 解决方案6-LSTM</h3><p><strong>LSTM</strong>全称是长短期记忆网络（long-short term memory networks），是不那么容易发生梯度消失的，主要原因在于LSTM内部复杂的“门”(gates)，如下图，LSTM通过它内部的“门”可以接下来更新的时候“记住”前几次训练的”残留记忆“，因此，经常用于生成文本中。目前也有基于CNN的LSTM，感兴趣的可以尝试一下。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/42741-b9a16a53d58ca2b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="这里写图片描述"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h2><p>1.《Neural networks and deep learning》<br>2.<a href="https://www.baidu.com/s?wd=%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">《机器学习》</a>周志华 </p>
<ol>
<li><p><a href="https://www.cnblogs.com/willnote/p/6912798.html&gt;" target="_blank" rel="noopener">https://www.cnblogs.com/willnote/p/6912798.html&gt;</a> </p>
</li>
<li><p><a href="https://www.zhihu.com/question/38102762" target="_blank" rel="noopener">https://www.zhihu.com/question/38102762</a> </p>
<ol>
<li><a href="http://www.jianshu.com/p/9dc9f41f0b29" target="_blank" rel="noopener">http://www.jianshu.com/p/9dc9f41f0b29</a></li>
</ol>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>池化层的反向传播</title>
    <url>/2019/04/21/%E6%B1%A0%E5%8C%96%E5%B1%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/</url>
    <content><![CDATA[<ul>
<li>参考： <a href="https://blog.csdn.net/qq_21190081/article/details/72871704" target="_blank" rel="noopener">https://blog.csdn.net/qq_21190081/article/details/72871704</a></li>
<li>总结，<br>（1）对于平均池化层，比如2×2-&gt;1， 梯度的反向传递，是1-&gt;2×2，若梯度为x, 则，反向传播的梯度为4个 1/4<br>（1）对于最大池化层，比如2×2-&gt;1， 梯度的反向传递，是1-&gt;2×2，若梯度为x, 则，反向传播只赋值给最大值所在的元素，其余三个元素的梯度为0</li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习知识点</title>
    <url>/2019/03/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<ul>
<li><p>讲一下正则化，L1和L2正则化各自的特点和适用场景。<br>答：L1用来获得稀疏化特征；L2用来防止过拟合。L1让一部分特征的系数缩小到0，从而间接实现特征选择，用于特征间有关联的场合；L2让所有的特征系数都减小，但不会减为0，会使优化求解稳定快速。</p>
</li>
<li><p>防止过拟合的方法：<br>（1）早停，使用验证集，当验证集的损失下降，但是训练集的损失仍在上升时，则停止训练<br>（2）加入正则化项，L1、L2</p>
</li>
<li><p>分类问题有哪些评价指标？每种的适用场景<br>Precision  精确率，在所有预测为正样本的样本(TP+FP)中预测正确(TP)的比例，也就是：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1asfgshjuj307c01d3yb.jpg"><br>适用于：检索出的信息有多少是用户感兴趣的<br>Recall  召回率，在所有正样本(TP+FN)中，预测正确(TP)的比例，也就是：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1asfv7ikpj306d019t8i.jpg"><br>适用于：用户感兴趣的信息有多少被检索出来了<br>Accuracy  准确率，正确分类的样本占所有样本的比例，不适于数据极度不平衡的场景如广告点击率一般在千分之几。<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1asg2ggqgj30ab01eglg.jpg"><br>适用于多分类问题<br>F1-measure  F1分数，是综合考虑Precision和Recall得到的一个指标，一般在需要PR都要保证的场景使用，针对一个值的优化更加直观容易衡量<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1asgb0qo9j304701dwe9.jpg"></p>
</li>
<li><p>逻辑回归可以处理非线性问题吗<br>只用原始特征不能；对特征做非线性变换，比如kernel，当然可以。 但那就不是lr了 或者一个神经网络 最后一层看成是lr 前面看成是提特征<br>lr的应用场景主要是特征很多的情况下 比如特征是上亿维的一些场景</p>
</li>
<li><p>讲一下pooling的作用， 为什么max pooling要更常用？哪些情况下，average pooling比max pooling更合适？<br>（1）保证特征的位置与旋转不变性。对于图像处理这种特性是很好的，但是对于NLP来说特征出现的位置是很重要的。比如主语一般出现在句子头等等<br>maxpooling提供了一定position的invariance，当图像某些区域像素变化时，maxpooling得到的output并不会变<br>（2）减少模型参数数量，减少过拟合问题。2D或1D的数组转化为单一数值，对于后续的convolution层或者全连接隐层来说，减少了单个Filter参数或隐层神经元个数<br>（3）可以把变长的输入x整理成固定长度的输入。CNN往往最后连接全连接层，神经元个数需要固定好，但是cnn输入x长度不确定，通过pooling操作，每个filter固定取一个值。有多少个Filter，Pooling就有多少个神经元，这样就可以把全连接层神经元固定住<br>（4）yaya: pooling 一般是对缩小image size，从而可以减小后续步骤中的参数量<br>max-pooling还提供了非线性, 这是max-pooling效果更好的一个重要原因.<br><strong>average pooling比max pooling更合适：</strong>有的时候在模型接近分类器的末端使用全局平均池化还可以代替Flatten操作，使输入数据变成一位向量。</p>
</li>
<li><p>1x1的卷积核有什么作用？<br>1*1的卷积核在NIN、Googlenet中被广泛使用，作用：<br>（1）实现跨通道的交互和信息整合<br>（2）进行卷积核通道数的降维和升维<br>（3）对于单通道feature map 用单核卷积即为乘以一个参数，而一般情况都是多核卷积多通道，实现多个feature map的线性组合</p>
</li>
<li><p>梯度消失和梯度爆炸的原因是什么？ 有哪些解决方法？<br>转载：<a href="https://blog.csdn.net/raojunyang/article/details/79962665（解释的很清楚）" target="_blank" rel="noopener">https://blog.csdn.net/raojunyang/article/details/79962665（解释的很清楚）</a><br>梯度消失更容易发生，当网络较深或者使用了不合适的激活函数时，会发生梯度消失；当为深层网络且权值初始化值太大时，容易发生梯度爆炸<br>yaya: 由于深层网络，在底层的网络权重的更新，需要高层网络权重的连乘，因此，当高层网络权重较小时，使得发生梯度消失，相反，当权重较大时，则发生梯度爆炸。<br>那么什么时候高层网络权重小—-当使用sigmoid/tanh这样的激活函数时，因为sigmoid的导数最大为1/2；什么时候高层网络权重大—当初始化的权重较大时<br>如何解决梯度消失与爆炸：（1）使用正确的非线性激活函数（2）对于梯度爆炸问题使用梯度剪切（3）使用batch normalization（4）使用残差结构</p>
</li>
<li>CNN和RNN的梯度消失是一样的吗？  </li>
<li>有哪些防止过拟合的方法？<br>早停；添加正则化项：L1、L2；使用dropout</li>
<li>讲一下激活函数sigmoid，tanh，relu. Leaky ReLU各自的优点和适用场景？<br>sigmoid，tanh 有梯度消失的问题<br>relu 部分解决梯度消失问题（x&gt;0）<br>leaky relu </li>
<li>relu的负半轴导数都是0，这部分产生的梯度消失怎么办？  </li>
<li>batch size对收敛速度的影响。  </li>
<li>讲一下batch normalization<br>对输入的数据进行mini batch 的归一化</li>
<li>讲一下你怎么理解dropout，分别从bagging和正则化的角度<br><a href="https://blog.csdn.net/m0_37477175/article/details/77145459" target="_blank" rel="noopener">https://blog.csdn.net/m0_37477175/article/details/77145459</a><br>bagging 都是使用集成学习的思想，但是</li>
<li>data augmentation有哪些技巧？  </li>
<li>讲一下你了解的优化方法，sgd, momentum, rmsprop, adam的区别和联系  </li>
<li>如果训练的神经网络不收敛，可能有哪些原因？<br>可以参见此博文，具体来说，可以简述为以下几点：<br>（1）<strong>没有对数据进行归一化</strong>，即对数据减均值，并除以方差。而大部分神经网络的输入输出都是在0附近的分布。因此无法收敛。<br>（2）<strong>学习率不正确</strong><br>（3）<strong>在输出层使用错误的激活函数</strong>：在最后一层使用激活函数时，无法产生所需全部范围的值。假使你使用Relu这类限制范围的函数，神经网络便只会训练得到正值<br>（4）<strong>没有正确初始化权重</strong></li>
</ul>
<p>（1）代码题（leetcode类型），主要考察数据结构和基础算法，以及代码基本功<br>虽然这部分跟机器学习，深度学习关系不大，但也是面试的重中之重。基本每家公司的面试都问了大量的算法题和代码题，即使是商汤、face++这样的深度学习公司，考察这部分的时间也占到了我很多轮面试的60%甚至70%以上。我去face++面试的时候，面试官是residual net，shuffle net的作者；但他们的面试中，写代码题依旧是主要的部分。<br>大部分题目都不难，基本是leetcode medium的难度。但是要求在现场白板编程，思路要流畅，能做到一次性Bug-free. 并且，一般都是要给出时间复杂度和空间复杂度最优的做法。对于少数难度很大的题，也不要慌张。一般也不会一点思路也没有，尽力给面试官展现自己的思考过程。面试官也会引导你，给一点小提示，沿着提示把题目慢慢做出来也是可以通过面试的。<br>以下是我所遇到的一些需要当场写出完整代码的题目：  </p>
<p><1> 二分查找。分别实现C++中的lower_bound和upper_bound.  </1></p>
<p><2> 排序。 手写快速排序，归并排序，堆排序都被问到过。  </2></p>
<p><3> 给你一个数组，求这个数组的最大子段积<br>时间复杂度可以到O(n)  </3></p>
<p><4> 给你一个数组，在这个数组中找出不重合的两段，让这两段的字段和的差的绝对值最小。<br>时间复杂度可以到O(n)  </4></p>
<p><5> 给你一个数组，求一个k值，使得前k个数的方差 + 后面n-k个数的方差最小<br>时间复杂度可以到O(n)  </5></p>
<p><6> 给你一个只由0和1组成的字符串，找一个最长的子串，要求这个子串里面0和1的数目相等。<br>时间复杂度可以到O(n)  </6></p>
<p><7> 给你一个数组以及一个数K， 从这个数组里面选择三个数，使得三个数的和小于等于K， 问有多少种选择的方法？<br>时间复杂度可以到O(n^2)  </7></p>
<p><8> 给你一个只由0和1组成的矩阵，找出一个最大的子矩阵，要求这个子矩阵是方阵，并且这个子矩阵的所有元素为1<br>时间复杂度可以到O(n^2)  </8></p>
<p><9> 求一个字符串的最长回文子串<br>时间复杂度可以到O(n) (Manacher算法)  </9></p>
<p><10> 在一个数轴上移动，初始在0点，现在要到给定的某一个x点， 每一步有三种选择，坐标加1，坐标减1，坐标乘以2，请问最少需要多少步从0点到x点。  </10></p>
<p><11> 给你一个集合，输出这个集合的所有子集。  </11></p>
<p><12> 给你一个长度为n的数组，以及一个k值（k &lt; n) 求出这个数组中每k个相邻元素里面的最大值。其实也就是一个一维的max pooling<br>时间复杂度可以到O(n)  </12></p>
<p><13> 写一个程序，在单位球面上随机取点，也就是说保证随机取到的点是均匀的。  </13></p>
<p><14> 给你一个长度为n的字符串s，以及m个短串（每个短串的长度小于10）， 每个字符串都是基因序列，也就是说只含有A,T,C,G这四个字母。在字符串中找出所有可以和任何一个短串模糊匹配的子串。模糊匹配的定义，两个字符串长度相等，并且至多有两个字符不一样，那么我们就可以说这两个字符串是模糊匹配的。  </14></p>
<p><15> 其它一些描述很复杂的题这里就不列了。</15></p>
<p>（2）数学题或者”智力”题。<br>不会涉及特别高深的数学知识，一般就是工科数学（微积分，概率论，线性代数）和一些组合数学的问题。<br>下面是我在面试中被问到过的问题：  </p>
<p><1> 如果一个女生说她集齐了十二个星座的前男友，她前男友数量的期望是多少？<br>ps：这道题在知乎上有广泛的讨论，作为知乎重度用户我也看到过。如果一个女生说，她集齐了十二个星座的前男友，我们应该如何估计她前男友的数量？  </1></p>
<p><2> 两个人玩游戏。有n堆石头，每堆分别有a1, a2, a3…. an个石头，每次一个游戏者可以从任意一堆石头里拿走至少一个石头，也可以整堆拿走，但不能从多堆石头里面拿。无法拿石头的游戏者输，请问这个游戏是否有先手必胜或者后手必胜的策略？ 如果有，请说出这个策略，并证明这个策略能保证必胜。  </2></p>
<p><3> 一个一维数轴，起始点在原点。每次向左或者向右走一步，概率都是0.5. 请问回到原点的步数期望是多少？  </3></p>
<p><4> 一条长度为1的线段，随机剪两刀，求有一根大于0.5的概率。  </4></p>
<p><5> 讲一下你理解的矩阵的秩。低秩矩阵有什么特点？ 在图像处理领域，这些特点有什么应用？  </5></p>
<p><6> 讲一下你理解的特征值和特征向量。  </6></p>
<p><7> 为什么负梯度方向是使函数值下降最快的方向？简单数学推导一下</7></p>
<p>（3）机器学习基础<br>这部分建议参考周志华老师的《机器学习》。<br>下面是我在面试中被问到过的问题：  </p>
<p><1> 逻辑回归和线性回归对比有什么优点？  </1></p>
<p><2> 逻辑回归可以处理非线性问题吗？  </2></p>
<p><3> 分类问题有哪些评价指标？每种的适用场景。  </3></p>
<p><4> 讲一下正则化，L1和L2正则化各自的特点和适用场景。  </4></p>
<p><5> 讲一下常用的损失函数以及各自的适用场景。  </5></p>
<p><6> 讲一下决策树和随机森林  </6></p>
<p><7> 讲一下GBDT的细节，写出GBDT的目标函数。 GBDT和Adaboost的区别与联系  </7></p>
<p><8> 手推softmax loss公式  </8></p>
<p><9> 讲一下SVM, SVM与LR有什么联系。  </9></p>
<p><10>讲一下PCA的步骤。PCA和SVD的区别和联系  </10></p>
<p><11> 讲一下ensemble  </11></p>
<p><12> 偏差和方差的区别。ensemble的方法中哪些是降低偏差，哪些是降低方差？<br>…… 这部分问得太琐碎了，我能记起来的问题就这么多了。我的感觉，这部分问题大多数不是问得很深，所以不至于被问得哑口无言，总有得扯；但是要想给出一个特别深刻的回答，还是需要对机器学习的基础算法了解比较透彻。</12></p>
<p>（4）深度学习基础<br>这部分的准备，我推荐花书（Bengio的Deep learning）和 @魏秀参 学长的《解析卷积神经网络-深度学习实践手册》<br>下面是我在面试中被问到过的问题：  </p>
<p><1> 手推BP  </1></p>
<p><2> 手推RNN和LSTM结构  </2></p>
<p><3> LSTM中每个gate的作用是什么，为什么跟RNN比起来，LSTM可以防止梯度消失  </3></p>
<p><4> 讲一下pooling的作用， 为什么max pooling要更常用？哪些情况下，average pooling比max pooling更合适？  </4></p>
<p><5> 梯度消失和梯度爆炸的原因是什么？ 有哪些解决方法？  </5></p>
<p><6> CNN和RNN的梯度消失是一样的吗？  </6></p>
<p><6> 有哪些防止过拟合的方法？  </6></p>
<p><7> 讲一下激活函数sigmoid，tanh，relu. 各自的优点和适用场景？  </7></p>
<p><8> relu的负半轴导数都是0，这部分产生的梯度消失怎么办？  </8></p>
<p><9> batch size对收敛速度的影响。  </9></p>
<p><10> 讲一下batch normalization  </10></p>
<p><11> CNN做卷积运算的复杂度。如果一个CNN网络的输入channel数目和卷积核数目都减半，总的计算量变为原来的多少？  </11></p>
<p><12> 讲一下AlexNet的具体结构，每层的作用  </12></p>
<p><13> 讲一下你怎么理解dropout，分别从bagging和正则化的角度  </13></p>
<p><14> data augmentation有哪些技巧？  </14></p>
<p><15> 讲一下你了解的优化方法，sgd, momentum, rmsprop, adam的区别和联系  </15></p>
<p><16> 如果训练的神经网络不收敛，可能有哪些原因？  </16></p>
<p><17> 说一下你理解的卷积核， 1x1的卷积核有什么作用？<br>……..<br>同上，这部分的很多问题也是每个人都或多或少能回答一点，但要答得很好还是需要功底的。</17></p>
<p>（5）科研上的开放性问题<br>这部分的问题没有固定答案，也没法很好地针对性准备。功在平时，多读paper多思考，注意培养自己的insight和intuition<br>下面是我在面试中被问到过的问题：  </p>
<p><1> 选一个计算机视觉、深度学习、机器学习的子领域，讲一下这个领域的发展脉络，重点讲出各种新方法提出时的motivation，以及谈谈这个领域以后会怎么发展。  </1></p>
<p><2> 讲一下你最近看的印象比较深的paper  </2></p>
<p><3> 讲一下经典的几种网络结构， AlexNet， VGG，GoogleNet， Residual Net等等，它们各自最重要的contribution  </3></p>
<p><4> 你看过最近很火的XXX paper吗? 你对这个有什么看法？<br>……<br>（6） 编程语言、操作系统等方面的一些问题。<br>C++， Python， 操作系统，Linux命令等等。这部分问得比较少，但还是有的，不具体列了<br>（7）针对简历里项目/论文 / 实习的一些问题。<br>这部分因人而异，我个人的对大家也没参考价值，也不列了。</4></p>
<p>作者：wendy_要努力努力再努力<br>链接：<a href="https://www.jianshu.com/p/d40fc51874c8" target="_blank" rel="noopener">https://www.jianshu.com/p/d40fc51874c8</a><br>来源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>模型剪枝 Model Pruning</title>
    <url>/2019/04/09/%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D-Model-Pruning/</url>
    <content><![CDATA[<p>参考：<a href="https://xmfbit.github.io/2018/10/03/paper-summary-model-pruning/" target="_blank" rel="noopener">https://xmfbit.github.io/2018/10/03/paper-summary-model-pruning/</a><br>L1正则化项，加入损失函数中，可以对特征进行选择。<br>L1也可以应用到模型压缩任务中，选择某个filter是否有存在的必要，从而决定是否要剪掉。</p>
]]></content>
      <categories>
        <category>杂类</category>
      </categories>
      <tags>
        <tag>杂类</tag>
      </tags>
  </entry>
  <entry>
    <title>深度层次化图卷积神经网络</title>
    <url>/2019/07/25/%E6%B7%B1%E5%BA%A6%E5%B1%82%E6%AC%A1%E5%8C%96%E5%9B%BE%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h3 id="池化-可以扩大感受野"><a href="#池化-可以扩大感受野" class="headerlink" title="池化 可以扩大感受野"></a>池化 可以扩大感受野</h3><h3 id="GCN（两层）-node-classification"><a href="#GCN（两层）-node-classification" class="headerlink" title="GCN（两层）( node classification )"></a>GCN（两层）( node classification )</h3><ul>
<li>基于邻域聚合的</li>
<li><code>H= AXW</code><h3 id="deeper-insight-into-graph-convolutional-networks-for-semi-supervised-learning"><a href="#deeper-insight-into-graph-convolutional-networks-for-semi-supervised-learning" class="headerlink" title="deeper insight into graph convolutional networks for semi-supervised learning"></a>deeper insight into graph convolutional networks for semi-supervised learning</h3></li>
<li>GCN层数多效果不好：特征之间过于平滑<h3 id="GAT-（两层）-GraphSAGE"><a href="#GAT-（两层）-GraphSAGE" class="headerlink" title="GAT （两层）  GraphSAGE"></a>GAT （两层）  GraphSAGE</h3></li>
<li>两层，感受野小，2-hop</li>
</ul>
<h3 id="Hierarchical-Graph-Representation-Learning-with-Differentiable-Pooling-（graph-classification）"><a href="#Hierarchical-Graph-Representation-Learning-with-Differentiable-Pooling-（graph-classification）" class="headerlink" title="Hierarchical Graph Representation Learning with Differentiable Pooling （graph classification）"></a>Hierarchical Graph Representation Learning with Differentiable Pooling （graph classification）</h3><ol>
<li>优点</li>
</ol>
<ul>
<li>简单的两层GCN 的感受野只有2-hop</li>
<li>但是如果GCN- clusterpooling，把相同的节点聚类在一起，再进行GCN，那么感受野就会扩大，</li>
<li>捕捉到了graph 中的Hierarchical  structure</li>
</ul>
<ol>
<li>缺点</li>
</ol>
<ul>
<li>但是由于他自身网络设计的，一次池化，就需要一个全连接层，使得想要设计一个很深的网络，就需要很多的参数，容易过拟合</li>
<li>很难去训练pooling matrix，这是由于不能保证，经过这一个池化层，就可以把相似的objects聚类到一起。本文作者在每层都增加了两个正则项</li>
</ul>
<h3 id="Hierarchical-Graph-Convolutional-Networks-for-Semi-supervised-Node-Classification-9层-IJCAI-2019"><a href="#Hierarchical-Graph-Convolutional-Networks-for-Semi-supervised-Node-Classification-9层-IJCAI-2019" class="headerlink" title="Hierarchical Graph Convolutional Networks for Semi-supervised Node Classification ( 9层 ) ( IJCAI 2019)"></a>Hierarchical Graph Convolutional Networks for Semi-supervised Node Classification ( 9层 ) ( IJCAI 2019)</h3><ul>
<li>粗化 coarsening</li>
<li>结构一致粗化</li>
<li>结构相似粗化</li>
</ul>
]]></content>
      <categories>
        <category>图卷积网络</category>
      </categories>
      <tags>
        <tag>图卷积网络</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Batch Normalization批标准化</title>
    <url>/2019/08/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Batch-Normalization%E6%89%B9%E6%A0%87%E5%87%86%E5%8C%96/</url>
    <content><![CDATA[<ul>
<li>转载 from：<a href="https://www.cnblogs.com/guoyaohua/p/8724433.html" target="_blank" rel="noopener">https://www.cnblogs.com/guoyaohua/p/8724433.html</a></li>
</ul>
<blockquote>
<p>这几天面试经常被问到BN层的原理，虽然回答上来了，但还是感觉答得不是很好，今天仔细研究了一下Batch Normalization的原理，以下为参考网上几篇文章总结得出。</p>
</blockquote>
<p>　　Batch Normalization作为最近一年来DL的重要成果，已经广泛被证明其有效性和重要性。虽然有些细节处理还解释不清其理论原因，但是实践证明好用才是真的好，别忘了DL从Hinton对深层网络做Pre-Train开始就是一个<strong>经验领先于理论分析</strong>的偏经验的一门学问。本文是对论文《Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift》的导读。</p>
<p>　　机器学习领域有个很重要的假设：<strong>IID独立同分布假设</strong>，就是假设训练数据和测试数据是满足相同分布的，这是通过训练数据获得的模型能够在测试集获得好的效果的一个基本保障。那BatchNorm的作用是什么呢？<strong>BatchNorm就是在深度神经网络训练过程中使得每一层神经网络的输入保持相同分布的。</strong></p>
<p>　　接下来一步一步的理解什么是BN。</p>
<p>　　为什么深度神经网络<strong>随着网络深度加深，训练起来越困难，收敛越来越慢？</strong>这是个在DL领域很接近本质的好问题。很多论文都是解决这个问题的，比如ReLU激活函数，再比如Residual Network，BN本质上也是解释并从某个不同的角度来解决这个问题的。</p>
<h2 id="一、“Internal-Covariate-Shift”问题"><a href="#一、“Internal-Covariate-Shift”问题" class="headerlink" title="一、“Internal Covariate Shift”问题"></a>一、“Internal Covariate Shift”问题</h2><p>　　从论文名字可以看出，BN是用来解决“Internal Covariate Shift”问题的，那么首先得理解什么是“Internal Covariate Shift”？</p>
<p>　　论文首先说明Mini-Batch SGD相对于One Example SGD的两个优势：梯度更新方向更准确；并行计算速度快；（为什么要说这些？因为BatchNorm是基于Mini-Batch SGD的，所以先夸下Mini-Batch SGD，当然也是大实话）；然后吐槽下SGD训练的缺点：超参数调起来很麻烦。（作者隐含意思是用BN就能解决很多SGD的缺点）</p>
<p>　　接着引入<strong>covariate shift的概念</strong>：<strong>如果ML系统实例集合<x,y>中的输入值X的分布老是变，这不符合IID假设</x,y></strong>，网络模型很难<strong>稳定的学规律</strong>，这不得引入迁移学习才能搞定吗，我们的ML系统还得去学习怎么迎合这种分布变化啊。对于深度学习这种包含很多隐层的网络结构，在训练过程中，因为各层参数不停在变化，所以每个隐层都会面临covariate shift的问题，也就是<strong>在训练过程中，隐层的输入分布老是变来变去，这就是所谓的“Internal Covariate Shift”，Internal指的是深层网络的隐层，是发生在网络内部的事情，而不是covariate shift问题只发生在输入层。</strong></p>
<p>　　然后提出了BatchNorm的基本思想：能不能<strong>让每个隐层节点的激活输入分布固定下来呢</strong>？这样就避免了“Internal Covariate Shift”问题了。</p>
<p>　　BN不是凭空拍脑袋拍出来的好点子，它是有启发来源的：之前的研究表明如果在图像处理中对输入图像进行白化（Whiten）操作的话——所谓<strong>白化</strong>，<strong>就是对输入数据分布变换到0均值，单位方差的正态分布</strong>——那么神经网络会较快收敛，那么BN作者就开始推论了：图像是深度神经网络的输入层，做白化能加快收敛，那么其实对于深度网络来说，其中某个隐层的神经元是下一层的输入，意思是其实深度神经网络的每一个隐层都是输入层，不过是相对下一层来说而已，那么能不能对每个隐层都做白化呢？这就是启发BN产生的原初想法，而BN也确实就是这么做的，<strong>可以理解为对深层神经网络每个隐层神经元的激活值做简化版本的白化操作。</strong></p>
<h2 id="二、BatchNorm的本质思想"><a href="#二、BatchNorm的本质思想" class="headerlink" title="二、BatchNorm的本质思想"></a><strong>二、</strong>BatchNorm的本质思想</h2><p>　　BN的基本思想其实相当直观：因为深层神经网络在做非线性变换前的<strong>激活输入值</strong>（就是那个x=WU+B，U是输入）<strong>随着网络深度加深或者在训练过程中，其分布逐渐发生偏移或者变动，之所以训练收敛慢，一般是整体分布逐渐往非线性函数的取值区间的上下限两端靠近</strong>（对于Sigmoid函数来说，意味着激活输入值WU+B是大的负值或正值），所以这<strong>导致反向传播时低层神经网络的梯度消失</strong>，这是训练深层神经网络收敛越来越慢的<strong>本质原因</strong>，<strong>而BN就是通过一定的规范化手段，把每层神经网络任意神经元这个输入值的分布强行拉回到均值为0方差为1的标准正态分布</strong>，其实就是把越来越偏的分布强制拉回比较标准的分布，这样使得激活输入值落在非线性函数对输入比较敏感的区域，这样输入的小变化就会导致损失函数较大的变化，意思是<strong>这样让梯度变大，避免梯度消失问题产生，而且梯度变大意味着学习收敛速度快，能大大加快训练速度。</strong></p>
<p>　　THAT’S IT。其实一句话就是：<strong>对于每个隐层神经元，把逐渐向非线性函数映射后向取值区间极限饱和区靠拢的输入分布强制拉回到均值为0方差为1的比较标准的正态分布，使得非线性变换函数的输入值落入对输入比较敏感的区域，以此避免梯度消失问题。</strong>因为梯度一直都能保持比较大的状态，所以很明显对神经网络的参数调整效率比较高，就是变动大，就是说向损失函数最优值迈动的步子大，也就是说收敛地快。BN说到底就是这么个机制，方法很简单，道理很深刻。</p>
<p>　　上面说得还是显得抽象，下面更形象地表达下这种调整到底代表什么含义。</p>
<p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180405225246905-37854887.png" alt="img"></p>
<p>  图1  几个正态分布</p>
<p>　　假设某个隐层神经元原先的激活输入x取值符合正态分布，正态分布均值是-2，方差是0.5，对应上图中最左端的浅蓝色曲线，通过BN后转换为均值为0，方差是1的正态分布（对应上图中的深蓝色图形），意味着什么，意味着输入x的取值正态分布整体右移2（均值的变化），图形曲线更平缓了（方差增大的变化）。这个图的意思是，BN其实就是把每个隐层神经元的激活输入分布从偏离均值为0方差为1的正态分布通过平移均值压缩或者扩大曲线尖锐程度，调整为均值为0方差为1的正态分布。</p>
<p>　　那么把激活输入x调整到这个正态分布有什么用？首先我们看下均值为0，方差为1的标准正态分布代表什么含义：</p>
<p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180405225314624-527885612.png" alt="img"></p>
<p>图2  均值为0方差为1的标准正态分布图</p>
<p>　　这意味着在一个标准差范围内，也就是说64%的概率x其值落在[-1,1]的范围内，在两个标准差范围内，也就是说95%的概率x其值落在了[-2,2]的范围内。那么这又意味着什么？我们知道，激活值x=WU+B,U是真正的输入，x是某个神经元的激活值，假设非线性函数是sigmoid，那么看下sigmoid(x)其图形：</p>
<p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180407143109455-1460017374.png" alt="img"></p>
<p>图3. Sigmoid(x)</p>
<p>及sigmoid(x)的导数为：G’=f(x)*(1-f(x))，因为f(x)=sigmoid(x)在0到1之间，所以G’在0到0.25之间，其对应的图如下：</p>
<p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180407142351924-124461667.png" alt="img"></p>
<p>图4  Sigmoid(x)导数图</p>
<p>　　假设没有经过BN调整前x的原先正态分布均值是-6，方差是1，那么意味着95%的值落在了[-8,-4]之间，那么对应的Sigmoid（x）函数的值明显接近于0，这是典型的梯度饱和区，在这个区域里梯度变化很慢，为什么是梯度饱和区？请看下sigmoid(x)如果取值接近0或者接近于1的时候对应导数函数取值，接近于0，意味着梯度变化很小甚至消失。而假设经过BN后，均值是0，方差是1，那么意味着95%的x值落在了[-2,2]区间内，很明显这一段是sigmoid(x)函数接近于线性变换的区域，意味着x的小变化会导致非线性函数值较大的变化，也即是梯度变化较大，对应导数函数图中明显大于0的区域，就是梯度非饱和区。</p>
<p>　　从上面几个图应该看出来BN在干什么了吧？其实就是把隐层神经元激活输入x=WU+B从变化不拘一格的正态分布通过BN操作拉回到了均值为0，方差为1的正态分布，即原始正态分布中心左移或者右移到以0为均值，拉伸或者缩减形态形成以1为方差的图形。什么意思？就是说<strong>经过BN后，目前大部分Activation的值落入非线性函数的线性区内，其对应的导数远离导数饱和区，这样来加速训练收敛过程。</strong></p>
<p>　　但是很明显，看到这里，稍微了解神经网络的读者一般会提出一个疑问：如果都通过BN，那么不就跟把非线性函数替换成线性函数效果相同了？这意味着什么？我们知道，如果是多层的线性函数变换其实这个深层是没有意义的，因为多层线性网络跟一层线性网络是等价的。这意味着网络的<strong>表达能力</strong>下降了，这也意味着深度的意义就没有了。<strong>所以BN为了保证非线性的获得，对变换后的满足均值为0方差为1的x又进行了scale加上shift操作(y=scale*x+shift)</strong>，每个神经元增加了两个参数scale和shift参数，这两个参数是通过训练学习到的，意思是通过scale和shift把这个值从标准正态分布左移或者右移一点并长胖一点或者变瘦一点，每个实例挪动的程度不一样，这样等价于非线性函数的值从正中心周围的线性区往非线性区动了动。核心思想应该是想找到一个线性和非线性的较好平衡点，既能享受非线性的较强表达能力的好处，又避免太靠非线性区两头使得网络收敛速度太慢。当然，这是我的理解，论文作者并未明确这样说。但是很明显这里的scale和shift操作是会有争议的，因为按照论文作者论文里写的理想状态，就会又通过scale和shift操作把变换后的x调整回未变换的状态，那不是饶了一圈又绕回去原始的“Internal Covariate Shift”问题里去了吗，感觉论文作者并未能够清楚地解释scale和shift操作的理论原因。</p>
<h2 id="三、训练阶段如何做BatchNorm"><a href="#三、训练阶段如何做BatchNorm" class="headerlink" title="三、训练阶段如何做BatchNorm"></a>三、训练阶段如何做BatchNorm</h2><p>　　上面是对BN的抽象分析和解释，具体在Mini-Batch SGD下做BN怎么做？其实论文里面这块写得很清楚也容易理解。为了保证这篇文章完整性，这里简单说明下。</p>
<p>　　假设对于一个深层神经网络来说，其中两层结构如下：</p>
<p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180405213859690-1933561230.png" alt="img"></p>
<p>  图5  DNN其中两层</p>
<p>　　要对每个隐层神经元的激活值做BN，可以想象成每个隐层又加上了一层BN操作层，它位于X=WU+B激活值获得之后，非线性函数变换之前，其图示如下：</p>
<p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180405213955224-1791925244.png" alt="img"></p>
<p>  图6. BN操作</p>
<p>　　对于Mini-Batch SGD来说，一次训练过程里面包含m个训练实例，其具体BN操作就是对于隐层内每个神经元的激活值来说，进行如下变换：</p>
<p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180407142802238-1209499294.png" alt="img"></p>
<p>　　要注意，这里t层某个神经元的x(k)不是指原始输入，就是说不是t-1层每个神经元的输出，而是t层这个神经元的线性激活x=WU+B，这里的U才是t-1层神经元的输出。变换的意思是：某个神经元对应的原始的激活x通过减去mini-Batch内m个实例获得的m个激活x求得的均值E(x)并除以求得的方差Var(x)来进行转换。</p>
<p>　　上文说过经过这个<strong>变换后某个神经元的激活x形成了均值为0，方差为1的正态分布，目的是把值往后续要进行的非线性变换的线性区拉动，增大导数值，增强反向传播信息流动性，加快训练收敛速度。**</strong>但是这样会导致网络表达能力下降，为了防止这一点，每个神经元增加两个调节参数（scale和shift），这两个参数是通过训练来学习到的，用来对变换后的激活反变换，使得网络表达能力增强，即对变换后的激活进行如下的scale和shift操作，这其实是变换的反操作：**</p>
<p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180407142923190-79595046.png" alt="img"></p>
<p>　　BN其具体操作流程，如论文中描述的一样：</p>
<p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180407142956288-903484055.png" alt="img"></p>
<p>　　过程非常清楚，就是上述公式的流程化描述，这里不解释了，直接应该能看懂。</p>
<h2 id="四、BatchNorm的推理-Inference-过程"><a href="#四、BatchNorm的推理-Inference-过程" class="headerlink" title="四、BatchNorm的推理(Inference)过程"></a>四、BatchNorm的推理(Inference)过程</h2><p>　　BN在训练的时候可以根据Mini-Batch里的若干训练实例进行激活数值调整，但是在推理（inference）的过程中，很明显输入就只有一个实例，看不到Mini-Batch其它实例，那么这时候怎么对输入做BN呢？因为很明显一个实例是没法算实例集合求出的均值和方差的。这可如何是好？</p>
<p>　　既然没有从Mini-Batch数据里可以得到的统计量，那就想其它办法来获得这个统计量，就是均值和方差。可以用从所有训练实例中获得的统计量来代替Mini-Batch里面m个训练实例获得的均值和方差统计量，因为本来就打算用全局的统计量，只是因为计算量等太大所以才会用Mini-Batch这种简化方式的，那么在推理的时候直接用全局统计量即可。</p>
<p>　　决定了获得统计量的数据范围，那么接下来的问题是如何获得均值和方差的问题。很简单，因为每次做Mini-Batch训练时，都会有那个Mini-Batch里m个训练实例获得的均值和方差，现在要全局统计量，只要把每个Mini-Batch的均值和方差统计量记住，然后对这些均值和方差求其对应的数学期望即可得出全局统计量，即：</p>
<p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180407143405654-1995556833.png" alt="img"></p>
<p>　　有了均值和方差，每个隐层神经元也已经有对应训练好的Scaling参数和Shift参数，就可以在推导的时候对每个神经元的激活数据计算NB进行变换了，在推理过程中进行BN采取如下方式：</p>
<p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180407143658338-63450857.png" alt="img"></p>
<p>　　这个公式其实和训练时</p>
<p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180407143807788-1841864822.png" alt="img"></p>
<p>　　是等价的，通过简单的合并计算推导就可以得出这个结论。那么为啥要写成这个变换形式呢？我猜作者这么写的意思是：在实际运行的时候，按照这种变体形式可以减少计算量，为啥呢？因为对于每个隐层节点来说：</p>
<p>　　　　　　　　<img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180407144519480-1024698421.png" alt="img">　　<img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180407144549010-487189588.png" alt="img"></p>
<p>　　都是固定值，这样这两个值可以事先算好存起来，在推理的时候直接用就行了，这样比原始的公式每一步骤都现算少了除法的运算过程，乍一看也没少多少计算量，但是如果隐层节点个数多的话节省的计算量就比较多了。</p>
<h2 id="五、BatchNorm的好处"><a href="#五、BatchNorm的好处" class="headerlink" title="五、BatchNorm的好处"></a>五、BatchNorm的好处</h2><p>　　BatchNorm为什么NB呢，关键还是效果好。<strong>①**</strong>不仅仅极大提升了训练速度，收敛过程大大加快；②还能增加分类效果，一种解释是这是类似于Dropout的一种防止过拟合的正则化表达方式，所以不用Dropout也能达到相当的效果；③另外调参过程也简单多了，对于初始化要求没那么高，而且可以使用大的学习率等。**总而言之，经过这么简单的变换，带来的好处多得很，这也是为何现在BN这么快流行起来的原因。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>目标检测模型中的性能评估——MAP(Mean Average Precision))</title>
    <url>/2019/08/31/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E2%80%94%E2%80%94MAP-Mean-Average-Precision/</url>
    <content><![CDATA[<p>参考：<a href="https://blog.csdn.net/katherine_hsr/article/details/79266880" target="_blank" rel="noopener">https://blog.csdn.net/katherine_hsr/article/details/79266880</a></p>
]]></content>
      <categories>
        <category>目标检测</category>
      </categories>
      <tags>
        <tag>目标检测</tag>
      </tags>
  </entry>
  <entry>
    <title>视频分类总结</title>
    <url>/2019/04/09/%E8%A7%86%E9%A2%91%E5%88%86%E7%B1%BB%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="Two-Stream"><a href="#Two-Stream" class="headerlink" title="Two-Stream"></a>Two-Stream</h3><ul>
<li>训练<br>（1）spatial net：每个video中随机提取1帧：224<em>224</em>3，进行训练，<br>（2）temporal net：每个video中选取L=10帧光流，224<em>224</em>2L，进行训练<br>由于含有x,y 方向，因此10帧光流，对应的5帧图像，该5帧是连续的</li>
<li>测试：每个video中平均采25帧，并通过crop and flip等操作扩增10倍，整个video的得分，是这250帧的平均得分。</li>
</ul>
<h3 id="TSN"><a href="#TSN" class="headerlink" title="TSN"></a>TSN</h3><ul>
<li>训练，将video分段，默认为3段<br>（1）spatial net：每个video分成N段，每段随机提取1帧，则得到N帧，这N帧共享参数，一起训练，N帧分别得到的score进行平均，作为video的分数，并反向传播，训练。<br>（2）temporal net ,同理，每个video分成N段，每段随机提取L=10帧，这N段共享参数，一起训练，N段分别得到的score进行平均，作为video的分数，并反向传播，训练。</li>
<li>测试，将video分段，默认为25段</li>
<li>同训练过程</li>
</ul>
<h3 id="C3D"><a href="#C3D" class="headerlink" title="C3D"></a>C3D</h3><ul>
<li>在Sports-1M上进行训练，训练完成之后便得到一个video feature extractor </li>
<li>训练：在每个video中随机剪切5个2s长的clip，对clip进行训练 </li>
<li>测试：对于一个video，含有N帧，则将这N帧分成16帧的clips，每相邻的两个clips重叠8帧，然后将这些clips得到的fc6 activations 进行<strong>平均得到video feature</strong>，进而送入分类层得到video class label</li>
</ul>
<h3 id="I3D"><a href="#I3D" class="headerlink" title="I3D"></a>I3D</h3><ul>
<li>video 以25帧/秒的帧率来提取关键帧</li>
<li>训练：以64帧组成的snippets进行训练。</li>
<li>测试：同样以64帧组成的snippets进行测试，但是对于该video上的所有的snippet的<strong>预测结果进行取平均</strong>作为该video的预测结果</li>
</ul>
]]></content>
      <categories>
        <category>行为识别</category>
      </categories>
      <tags>
        <tag>行为识别</tag>
      </tags>
  </entry>
  <entry>
    <title>算法</title>
    <url>/2019/04/18/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<ul>
<li><p><a href="https://blog.csdn.net/v_JULY_v/article/details/19131887" target="_blank" rel="noopener">别人的博客</a></p>
</li>
<li><p><a href="https://shiyaya.github.io/2019/04/18/%E5%8F%8C%E6%8C%87%E9%92%88-two-pointers/" target="_blank" rel="noopener">双指针</a></p>
</li>
<li><p><a href="https://shiyaya.github.io/2019/04/18/%E6%8E%92%E5%BA%8F-sort/" target="_blank" rel="noopener">排序</a></p>
</li>
<li><p><a href="https://shiyaya.github.io/2019/04/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dynamic-programming/" target="_blank" rel="noopener">动态规划</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>视频描述任务中用到objects的论文总结</title>
    <url>/2019/09/01/%E8%A7%86%E9%A2%91%E6%8F%8F%E8%BF%B0%E4%BB%BB%E5%8A%A1%E4%B8%AD%E7%94%A8%E5%88%B0objects%E7%9A%84%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ul>
<li><p>CVPR 2018</p>
<ol>
<li>Fine-grained Video Captioning for Sports Narrative</li>
</ol>
</li>
<li><p>CVPR 2019</p>
<ol>
<li>Grounded Video Description</li>
<li>Object-aware Aggregation with Bidirectional Temporal Graph for Video Captioning</li>
<li>Spatio-Temporal Dynamics and Semantic Attribute Enriched Visual Encoding for Video Captioning 【再去读一遍】</li>
<li>Adversarial Inference for Multi-Sentence Video Description</li>
</ol>
</li>
<li><p>ACM 2019</p>
<ol>
<li>Hierarchical Global-Local Temporal Modeling for Video Captioning</li>
</ol>
</li>
</ul>
<h3 id="Grounded-Video-Description"><a href="#Grounded-Video-Description" class="headerlink" title="Grounded Video Description"></a>Grounded Video Description</h3><p><img src="https://i.loli.net/2019/09/02/Hvtk4BJVNQ2WwdM.png" alt="搜狗截图20190902104324.png"></p>
<ol>
<li><p>如何使用region feature？</p>
<p> 仅在language lstm 用到了 region featrue, attention 加权求和之后 与 cat[ fc, motion] features 对应元素相加（cat[fc, motion]也是在经过attention加权求和之后的）</p>
<p> 但我个人认为对应元素相加，并没有道理，相当于在 cat[ fc, motion] 的基础上增加了一个 bias，没有什么道理</p>
</li>
<li><p>region feature 的构成？</p>
<p>R：是 object detector  在 fc6 输出的 feature</p>
<p>Ms(R)：是 object detector 在 fc7 输出的feature (这里有一些细节的修改，具体见论文)</p>
<p>Ml： 是 position embedding</p>
</li>
</ol>
<p><img src="https://i.loli.net/2019/09/02/y4JkxlmLQpqaj5c.png" alt="搜狗截图20190902105022.png"></p>
<h3 id="Object-aware-Aggregation-with-Bidirectional-Temporal-Graph-for-Video-Captioning"><a href="#Object-aware-Aggregation-with-Bidirectional-Temporal-Graph-for-Video-Captioning" class="headerlink" title="Object-aware Aggregation with Bidirectional Temporal Graph for Video Captioning"></a>Object-aware Aggregation with Bidirectional Temporal Graph for Video Captioning</h3><p><img src="https://i.loli.net/2019/09/02/TIP7Ww3FnLNKzvu.png" alt="搜狗截图20190902144125.png"></p>
<ol>
<li><p>简要介绍本文的结构</p>
<p> 在encoder 部分，使用 object feature 和 frame feature，分别经过设计的VALD 得到更新的特征向量</p>
<p> 在 decoder 部分，对object feature 使用两层的attention, 先对 <strong>一个轨迹</strong>上的objects 进行attention 的加权求和，再对N different objects instances进行 attention 的加权求和，这样就可以得到对所有objects 的聚合表达</p>
<p> 轨迹：对于第一帧的ojects, 根据相似性分别去找其他帧与其对应的objects，而构成的时域轨迹。</p>
<p>  这里采用了前向轨迹，和后向轨迹两种，在decoder 输出预测的单词之后，进行融合。</p>
</li>
<li><p>如何使用region feature？<br> 仅有一个lstm ，在输入lstm前对objects features进行两层attention 加权求和后，与同样经过attention的frames feature进行加和（sum）。<br> 本文没有使用 motion feeture</p>
</li>
<li><p>region feature 的构成？<br> 非常简单，只有 appearance feature，但是经过了 obejct VLAD module！</p>
</li>
<li><font color="#0099ff" size="5" face="黑体">object feature 的 hierarchical attention 值得借鉴呢！<br>计算object 相似性的部分也不错</font>



</li>
</ol>
<h3 id="Spatio-Temporal-Dynamics-and-Semantic-Attribute-Enriched-Visual-Encoding-for-Video-Captioning"><a href="#Spatio-Temporal-Dynamics-and-Semantic-Attribute-Enriched-Visual-Encoding-for-Video-Captioning" class="headerlink" title="Spatio-Temporal Dynamics and Semantic Attribute Enriched Visual Encoding for Video Captioning"></a>Spatio-Temporal Dynamics and Semantic Attribute Enriched Visual Encoding for Video Captioning</h3><p><img src="https://i.loli.net/2019/09/02/T5AzpW8DHkVL2Oy.png" alt="搜狗截图20190902152617.png"></p>
<ul>
<li>此文没有太看懂</li>
</ul>
<ol>
<li><p>如何使用region feature？</p>
<p> 得到 obejcts sematics embeddding 一起其他三个信息，经过聚合之后得到特征向量v，再经过一个线性变换得到v，再送入decoder中</p>
</li>
<li><p>region feature 的构成？</p>
<p> 由 object detector 输出的特征，以及其他输出（objetcs 存现的频率、概率），来构建semantics</p>
</li>
</ol>
<h3 id="Hierarchical-Global-Local-Temporal-Modeling-for-Video-Captioning"><a href="#Hierarchical-Global-Local-Temporal-Modeling-for-Video-Captioning" class="headerlink" title="Hierarchical Global-Local Temporal Modeling for Video Captioning"></a>Hierarchical Global-Local Temporal Modeling for Video Captioning</h3><p><img src="https://i.loli.net/2019/09/02/m5xLQnzCJGsjWVc.png" alt="搜狗截图20190902161552.png"></p>
<ol>
<li><p>如何使用region features ?</p>
<p> encoder 部分由两层LSTM，第一层LSTM 构建 frames features 和 c3d features的 隐层状态，并送入第二层LSTM，</p>
<p>在第二层LSTM 的每一个step, 都对该step 对应帧上的 objetcs进行attention 加权求和，并送入LSTM中，得到该帧的objects 的聚合特征的隐层状态   </p>
<p> <img src="https://i.loli.net/2019/09/02/q6XNP8iSVzekyCE.png" alt="搜狗截图20190902165813.png"></p>
</li>
<li><p>region feature 的构成？</p>
<p>   每帧 objects features 的加权求和，再经过LSTM得到隐层状态</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>当前基于 objects feature 的论文，decoder 部分没有太大的新颖（一般都是Top-Down或者是 Soft-Attention），主要的新颖的地方是在 encoder 部分</li>
<li>encoder部分有的使用LSTM 以及attention 来更新 objects features；有的使用VLAD 来构建 行为特征，使用 objects 的时域轨迹和两层attention 来聚合特征；使用objetcs 的其他信息，比如 position 以及 label 等信息</li>
</ul>
]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>视频描述评价指标的分析</title>
    <url>/2019/09/21/%E8%A7%86%E9%A2%91%E6%8F%8F%E8%BF%B0%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87%E7%9A%84%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />
    <label for="pass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>视频描述</category>
      </categories>
      <tags>
        <tag>视频描述</tag>
      </tags>
  </entry>
  <entry>
    <title>视频解码</title>
    <url>/2019/04/09/%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81/</url>
    <content><![CDATA[<ul>
<li>opencv提取关键帧（banet）</li>
<li><p>ffmpeg提取关键帧 （video to text）</p>
</li>
<li><p>i帧、P帧、B帧</p>
</li>
<li>参考：<a href="https://blog.csdn.net/huangblog/article/details/8739876" target="_blank" rel="noopener">https://blog.csdn.net/huangblog/article/details/8739876</a><br>I帧，Intra-coded frame：是一张完整的图片<br>P帧，predictive frame: 记录了与之前真的差别，在解码P帧之前需要参考之前的图片帧<br>B帧，Bi-Predictive frame: 不仅需要参考之前的图片帧，还需要参考之后的图片帧，才能完整解码。<br>因此解码P帧、B帧的速度相对较慢，直接解码I帧可以获得更快的速度。<br><strong>简单地讲，I帧是一个完整的画面，而P帧和B帧记录的是相对于I帧的变化。没有I帧，P帧和B帧就无法解码</strong>  </li>
</ul>
<h3 id="GOP"><a href="#GOP" class="headerlink" title="GOP"></a>GOP</h3><p>所谓GOP，意思是画面组，一个GOP就是一组连续的画面。从一个I帧到下一个I帧之间的所有帧的组合称为一个GOP。</p>
<ul>
<li><strong>I帧</strong><br>I帧是参考帧，一个GOP中必须含有I帧，它是一个全帧压缩编码帧。它将全帧图像信息进行JPEG压缩编码及传输。</li>
<li><strong>P帧的预测与重构:</strong><br>P帧是以I帧为参考帧,在I帧中找出P帧“某点”的预测值和运动矢量,取预测差值和运动矢量一起传送。在接收端根据运动矢量从I帧中找出P帧“某点”的预测值并与差值相加以得到P帧“某点”样值,从而可得到完整的P帧。</li>
<li><p><strong>B帧的预测与重构：</strong><br>B帧以前面的I或P帧和后面的P帧为参考帧,“找出”B帧“某点”的预测值和两个运动矢量,并取预测差值和运动矢量传送。接收端根据运动矢量在两个参考帧中“找出(算出)”预测值并与差值求和,得到B帧“某点”样值,从而可得到完整的B帧。</p>
</li>
<li><p><strong>用下图中的1234567帧来表达</strong><br>首先由1：I帧，<br>再由1、4帧得到第4帧所在位置处的图像信息<br>最后由1、4、2得到第2帧所在位置处的图像信息，由1、4、3得到第3帧所在位置处的图像信息</p>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1w7ki6x02j30ra0ge0st.jpg">  </p>
<ul>
<li>另外一张图  </li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1w7ki8pfvj30nm0fk77r.jpg"></p>
<hr>
<h3 id="视频压缩：I帧、P帧、B帧"><a href="#视频压缩：I帧、P帧、B帧" class="headerlink" title="视频压缩：I帧、P帧、B帧"></a>视频压缩：I帧、P帧、B帧</h3><ul>
<li>来源： <a href="https://blog.csdn.net/huangblog/article/details/8739876" target="_blank" rel="noopener">https://blog.csdn.net/huangblog/article/details/8739876</a></li>
</ul>
<p>视频压缩中，每帧代表一幅静止的图像。而在实际压缩时，会采取各种算法减少数据的容量，其中IPB就是最常见的。</p>
<pre><code>简单地说，I帧是关键帧，属于帧内压缩。就是和AVI的压缩是一样的。
P是向前搜索的意思。B是双向搜索。他们都是基于I帧来压缩数据。
</code></pre><p>   I帧表示关键帧，你可以理解为这一帧画面的完整保留；解码时只需要本帧数据就可以完成（因为包含完整画面）</p>
<p>   P帧表示的是这一帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是差别帧，P帧没有完整画面数据，只有与前一帧的画面差别的数据）</p>
<p>   B帧是双向差别帧，也就是B帧记录的是本帧与前后帧的差别（具体比较复杂，有4种情况），换言之，要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时CPU会比较累~。</p>
<pre><code>采用的压缩方法: 分组:把几帧图像分为一组(GOP),为防止运动变化,帧数不宜取多。

    1.定义帧:将每组内各帧图像定义为三种类型,即I帧、B帧和P帧;

    2.预测帧:以I帧做为基础帧,以I帧预测P帧,再由I帧和P帧预测B帧;

    3.数据传输:最后将I帧数据与预测的差值信息进行存储和传输。
</code></pre><p>一、I帧  </p>
<pre><code>I图像（帧）是靠尽可能去除图像空间冗余信息来压缩传输数据量的帧内编码图像。

I帧又称为内部画面 (intra picture)，I 帧通常是每个 GOP（MPEG 所使用的一种视频压缩技术）的第一个帧，经过适度地压缩（做为随机访问的参考点）可以当成图象。在MPEG编码的过程中部分视频帧序列压缩成为I帧，部分压缩成P帧，还有部分压缩成B帧。I帧法是帧内压缩法（P、B为帧间），也称为“关键帧”压缩法。I帧法是基于离散余弦变换DCT（Discrete Cosine Transform）的压缩技术，这种算法与JPEG压缩算法类似。采用I帧压缩可达到1/6的压缩比而无明显的压缩痕迹。

I帧特点：

    1.它是一个全帧压缩编码帧。它将全帧图像信息进行JPEG压缩编码及传输;

    2.解码时仅用I帧的数据就可重构完整图像;

    3.I帧描述了图像背景和运动主体的详情;

    4.I帧不需要参考其他画面而生成;

    5.I帧是P帧和B帧的参考帧(其质量直接影响到同组中以后各帧的质量);

    6.I帧是帧组GOP的基础帧(第一帧),在一组中只有一个I帧;

    7.I帧不需要考虑运动矢量;

    8.I帧所占数据的信息量比较大。

I帧编码流程：

    (1)进行帧内预测，决定所采用的帧内预测模式。

    (2)像素值减去预测值，得到残差。

    (3)对残差进行变换和量化。

    (4)变长编码和算术编码。

    (5)重构图像并滤波，得到的图像作为其它帧的参考帧。
</code></pre><p>二、P帧</p>
<pre><code> P图像（帧）是通过充分降低于图像序列中前面已编码帧的时间冗余信息来压缩传输数据量的编码图像，也叫预测帧。

在针对连续动态图像编码时，将连续若干幅图像分成P,B,I三种类型，P帧由在它前面的P帧或者I帧预测而来，它比较与它前面的P帧或者I帧之间的相同信息或数据，也即考虑运动的特性进行帧间压缩。P帧法是根据本帧与相邻的前一帧（I帧或P帧）的不同点来压缩本帧数据。采取P帧和I帧联合压缩的方法可达到更高的压缩且无明显的压缩痕迹。

P帧的预测与重构:

    P帧是以I帧为参考帧,在I帧中找出P帧“某点”的预测值和运动矢量,取预测差值和运动矢量一起传送。在接收端根据运动矢量从I帧中找出P帧“某点”的预测值并与差值相加以得到P帧“某点”样值,从而可得到完整的P帧。

P帧特点：

    ①P帧是I帧后面相隔1-2帧的编码帧。  

    ②P帧采用运动补偿的方法传送它与前面的I或P帧的差值及运动矢量（预测误差）。  

    ③解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧图像。  

    ④P帧属于前向预测的帧间编码。它只参考前面最靠近它的I帧或P帧。  

    ⑤P帧可以是其后面P帧的参考帧，也可以是其前后的B帧的参考帧。

    ⑥由于P帧是参考帧，它可能造成解码错误的扩散。 

    ⑦由于是差值传送，P帧的压缩比较高。
</code></pre><p>三、B帧</p>
<pre><code>B图像（帧）是既考虑与源图像序列前面已编码帧，也顾及源图像序列后面已编码帧之间的时间冗余信息来压缩传输数据量的编码图像，也叫双向预测帧。   

B帧法是双向预测的帧间压缩算法。当把一帧压缩成B帧时，它根据相邻的前一帧、本帧以及后一帧数据的不同点来压缩本帧，也即仅记录本帧与前后帧的差值。只有采用B帧压缩才能达到200：1的高压缩。一般地，I帧压缩效率最低，P帧较高，B帧最高。

B帧的预测与重构：

    B帧以前面的I或P帧和后面的P帧为参考帧,“找出”B帧“某点”的预测值和两个运动矢量,并取预测差值和运动矢量传送。接收端根据运动矢量在两个参考帧中“找出(算出)”预测值并与差值求和,得到B帧“某点”样值,从而可得到完整的B帧。

B帧特点：

    1.B帧是由前面的I或P帧和后面的P帧来进行预测的;

    2.B帧传送的是它与前面的I或P帧和后面的P帧之间的预测误差及运动矢量;

    3.B帧是双向预测编码帧;

    4.B帧压缩比最高,因为它只反映2参考帧间运动主体的变化情况,预测比较准确;

    5.B帧不是参考帧,不会造成解码错误的扩散。 

P 帧和 B 帧编码的基本流程为：

    (1)进行运动估计，计算采用帧间编码模式的率失真函数(节)值。P 帧 只参考前面的帧，B 帧可参考后面的帧。

    (2)进行帧内预测，选取率失真函数值最小的帧内模式与帧间模式比较，确定采用哪种编码模式。

    (3)计算实际值和预测值的差值。

    (4)对残差进行变换和量化。

    (5)若编码，如果是帧间编码模式，编码运动矢量。

注:I、B、P各帧是根据压缩算法的需要,是人为定义的,它们都是实实在在的物理帧,至于图像中的哪一帧是I帧,是随机的,一但确定了I帧,以后的各帧就严格按规定顺序排列。 
</code></pre><p>四、实际应用</p>
<pre><code>从上面的解释看，我们知道I和P的解码算法比较简单，资源占用也比较少，I只要自己完成就行了，P呢，也只需要解码器把前一个画面缓存一下，遇到P时就使用之前缓存的画面就好了，如果视频流只有I和P，解码器可以不管后面的数据，边读边解码，线性前进，大家很舒服。

但网络上的电影很多都采用了B帧，因为B帧记录的是前后帧的差别，比P帧能节约更多的空间，但这样一来，文件小了，解码器就麻烦了，因为在解码时，不仅要用之前缓存的画面，还要知道下一个I或者P的画面（也就是说要预读预解码），而且，B帧不能简单地丢掉，因为B帧其实也包含了画面信息，如果简单丢掉，并用之前的画面简单重复，就会造成画面卡（其实就是丢帧了），并且由于网络上的电影为了节约空间，往往使用相当多的B帧，B帧用的多，对不支持B帧的播放器就造成更大的困扰，画面也就越卡。

一般平均来说，I的压缩率是7（跟JPG差不多），P是20，B可以达到50，可见使用B帧能节省大量空间，节省出来的空间可以用来保存多一些I帧，这样在相同码率下，可以提供更好的画质。
</code></pre>]]></content>
  </entry>
  <entry>
    <title>设置随机种子</title>
    <url>/2019/07/21/%E8%AE%BE%E7%BD%AE%E9%9A%8F%E6%9C%BA%E7%A7%8D%E5%AD%90/</url>
    <content><![CDATA[<p>def set_random_seed(seed):<br>    random.seed(seed)<br>    np.random.seed(seed)<br>    torch.manual_seed(seed)<br>    torch.cuda.manual_seed_all(seed)</p>
]]></content>
  </entry>
  <entry>
    <title>计算机视觉学术会议</title>
    <url>/2019/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE/</url>
    <content><![CDATA[<h3 id="A类"><a href="#A类" class="headerlink" title="A类"></a>A类</h3><ul>
<li>(AAAI)   Conference on Artificial Intelligence  </li>
</ul>
<p>截稿日期：2019-8-30</p>
<ul>
<li>CVPR 2019: IEEE Conference on Computer Vision and Pattern Recognition    </li>
</ul>
<p><a href="http://cvpr2019.thecvf.com/" target="_blank" rel="noopener">http://cvpr2019.thecvf.com/</a> </p>
<p>截稿日期：2018-11-16<br>通知日期：2019-03-02<br>会议日期：2019-06-15</p>
<ul>
<li>IJCAI 2019: International Joint Conference on Artificial Intelligence</li>
</ul>
<p><a href="http://www.ijcai19.org" target="_blank" rel="noopener">http://www.ijcai19.org</a></p>
<p>截稿日期：2019-02-05<br>会议日期：Aug 10 - Aug 16, 2019</p>
<ul>
<li>ICCV2019: International Conference on Computer Vision</li>
</ul>
<p><a href="http://iccv2019.thecvf.com" target="_blank" rel="noopener">http://iccv2019.thecvf.com</a></p>
<p>截稿日期：2019-05-01<br>会议日期：Oct 27 - Nov 3, 2019</p>
<ul>
<li>ECCV</li>
</ul>
<p>截稿时间：3 月 14 日<br>会议时间：9 月 8-14 日</p>
<ul>
<li>ACM International Conference on Multimedia (ACM MM) </li>
</ul>
<p><a href="https://www.acmmm.org/2019/" target="_blank" rel="noopener">https://www.acmmm.org/2019/</a></p>
<p>截稿日期：2019.4.1</p>
<h3 id="B类"><a href="#B类" class="headerlink" title="B类"></a>B类</h3><ul>
<li>ICME 2019: International Conference on Multimedia and Expo</li>
</ul>
<p><a href="http://www.icme2019.org" target="_blank" rel="noopener">http://www.icme2019.org</a> </p>
<p>截稿日期：2018-12-03<br>通知日期：2019-03-11<br>会议日期：2019-07-08</p>
<h3 id="C类"><a href="#C类" class="headerlink" title="C类"></a>C类</h3><ul>
<li>BMVC</li>
</ul>
<p><a href="http://bmvc2018.org" target="_blank" rel="noopener">http://bmvc2018.org</a></p>
<p>截稿时间：4 月 30 日</p>
<ul>
<li>ICIP</li>
</ul>
<p>截稿时间：3 月 2 日</p>
]]></content>
      <categories>
        <category>杂类</category>
      </categories>
      <tags>
        <tag>杂类</tag>
      </tags>
  </entry>
  <entry>
    <title>评价者之间的一致性-Kappas</title>
    <url>/2020/08/06/%E8%AF%84%E4%BB%B7%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7-Kappas/</url>
    <content><![CDATA[<h3 id="评价者之间的一致性—Kappas-Inter-rater-agreement-Kappas"><a href="#评价者之间的一致性—Kappas-Inter-rater-agreement-Kappas" class="headerlink" title="评价者之间的一致性—Kappas Inter-rater agreement Kappas"></a>评价者之间的一致性—Kappas Inter-rater agreement Kappas</h3><p>inter-rater reliability == inter-rater agreement == concordance</p>
<p>评价者之间的一致性的Kappa分数代表着在打分判断中，他们有多少共识，有多一致。</p>
<p>Kappa分数处于0-1之间，具体地：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">K</th>
<th style="text-align:center">Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&lt;0</td>
<td style="text-align:center">Poor agreement 不一致</td>
</tr>
<tr>
<td style="text-align:center">0.0-0.20</td>
<td style="text-align:center">Slight agreement</td>
</tr>
<tr>
<td style="text-align:center">0.21-0.40</td>
<td style="text-align:center">Fair agreement</td>
</tr>
<tr>
<td style="text-align:center">0.41-0.60</td>
<td style="text-align:center">Moderate agreement</td>
</tr>
<tr>
<td style="text-align:center">0.61-0.80</td>
<td style="text-align:center">Substantial agreement</td>
</tr>
<tr>
<td style="text-align:center">0.81-1.0</td>
<td style="text-align:center">Almost perfect agreement</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Cohen’s-Kappa"><a href="#Cohen’s-Kappa" class="headerlink" title="Cohen’s Kappa"></a>Cohen’s Kappa</h3><p>Cohen’s Kappa 计算了评分者之间的一致性。当评分者对同一项任务给出了相同的判断或分数，那么他们的一致性得到了体现。</p>
<p>Cohen’s Kappa 只能在以下的条件下使用：</p>
<ul>
<li>两个评价者分别对每个样本进行评分</li>
<li>一个评价者对每个样本进行两次评分</li>
</ul>
<p><strong>Cohen’s Kappa 计算</strong></p>
<p>要注意的是，一般情况下，Cohen’s Kappa 的计算背景是：有<strong>两个</strong>评分者对每个样本进行<strong>二分类</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">postive (rater A)</th>
<th style="text-align:center">negative (rater A)</th>
<th style="text-align:center">Total</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>postive (rater B)</strong></td>
<td style="text-align:center"><img src="https://math.jianshu.com/math?formula=n_%7B11%7D" alt="n_{11}"></td>
<td style="text-align:center"><img src="https://math.jianshu.com/math?formula=n_%7B12%7D" alt="n_{12}"></td>
<td style="text-align:center"><img src="https://math.jianshu.com/math?formula=n_%7B1.%7D" alt="n_{1.}"></td>
</tr>
<tr>
<td style="text-align:center"><strong>negative (rater B)</strong></td>
<td style="text-align:center"><img src="https://math.jianshu.com/math?formula=n_%7B21%7D" alt="n_{21}"></td>
<td style="text-align:center"><img src="https://math.jianshu.com/math?formula=n_%7B22%7D" alt="n_{22}"></td>
<td style="text-align:center"><img src="https://math.jianshu.com/math?formula=n_%7B2.%7D" alt="n_{2.}"></td>
</tr>
<tr>
<td style="text-align:center"><strong>Total</strong></td>
<td style="text-align:center"><img src="https://math.jianshu.com/math?formula=n_%7B.1%7D" alt="n_{.1}"></td>
<td style="text-align:center"><img src="https://math.jianshu.com/math?formula=n_%7B.2%7D" alt="n_{.2}"></td>
<td style="text-align:center"><img src="https://math.jianshu.com/math?formula=n_%7B11%7D%2Bn_%7B12%7D%2Bn_%7B21%7D%2Bn_%7B22%7D" alt="n_{11}+n_{12}+n_{21}+n_{22}"></td>
</tr>
</tbody>
</table>
</div>
<p>计算公式为：<br> <img src="https://math.jianshu.com/math?formula=k%20%3D%20%5Cfrac%7Bp_o-p_e%7D%7B1-p_e%7D%20%3D%201-%5Cfrac%7B1-p_o%7D%7B1-p_e%7D" alt="k = \frac{p_o-p_e}{1-p_e} = 1-\frac{1-p_o}{1-p_e}"><br> 其中，<img src="https://math.jianshu.com/math?formula=p_o" alt="p_o"> 代表评价者之间的相对观察一致性（the relative <strong>observed agreement</strong> among raters）<br> <img src="https://math.jianshu.com/math?formula=p_o%3D%5Cfrac%7Bn_%7B11%7D%2Bn_%7B22%7D%7D%7Bn_%7B11%7D%2Bn_%7B12%7D%2Bn_%7B21%7D%2Bn_%7B22%7D%7D" alt="p_o=\frac{n_{11}+n_{22}}{n_{11}+n_{12}+n_{21}+n_{22}}"><br> <img src="https://math.jianshu.com/math?formula=p_e" alt="p_e"> 代表偶然一致性的假设概率（the hypothetical probability of <strong>chance agreemnet</strong>）<br> <img src="https://math.jianshu.com/math?formula=p_e%3D%5Cfrac%7Bn_%7B.1%7D*n_%7B1.%7D%7D%7B(n_%7B11%7D%2Bn_%7B12%7D%2Bn_%7B21%7D%2Bn_%7B22%7D" alt="p_e=\frac{n_{.1}*n_{1.}}{(n_{11}+n_{12}+n_{21}+n_{22})^2}+\frac{n_{.2}*n_{2.}}{(n_{11}+n_{12}+n_{21}+n_{22})^2}=\frac{n_{.1}*n_{1.}+n_{.2}*n_{2.}}{(n_{11}+n_{12}+n_{21}+n_{22})^2}">%5E2%7D%2B%5Cfrac%7Bn_%7B.2%7D<em>n_%7B2.%7D%7D%7B(n_%7B11%7D%2Bn_%7B12%7D%2Bn_%7B21%7D%2Bn_%7B22%7D)%5E2%7D%3D%5Cfrac%7Bn_%7B.1%7D</em>n_%7B1.%7D%2Bn_%7B.2%7D<em>n_%7B2.%7D%7D%7B(n_%7B11%7D%2Bn_%7B12%7D%2Bn_%7B21%7D%2Bn_%7B22%7D)%5E2%7D)<br> <em>*例子</em></em></p>
<p>rater A和rater B对50张图片进行分类，正类和负类。结果为：</p>
<ul>
<li>20张图片两个评价者都认为是正类</li>
<li>15张图片两个评价者都认为是负类</li>
<li>rater A认为25张图片是正类，25张图片是负类</li>
<li>rater B 认为30张图片是正类，20张图片是负类</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">postive (rater A)</th>
<th style="text-align:center">negative (rater A)</th>
<th style="text-align:center">Total</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>postive (rater B)</strong></td>
<td style="text-align:center">20</td>
<td style="text-align:center">10</td>
<td style="text-align:center">30</td>
</tr>
<tr>
<td style="text-align:center"><strong>negative (rater B)</strong></td>
<td style="text-align:center">5</td>
<td style="text-align:center">15</td>
<td style="text-align:center">20</td>
</tr>
<tr>
<td style="text-align:center"><strong>Total</strong></td>
<td style="text-align:center">25</td>
<td style="text-align:center">25</td>
<td style="text-align:center">50</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Step1</strong> ：计算<img src="https://math.jianshu.com/math?formula=p_o" alt="p_o"><br> <img src="https://math.jianshu.com/math?formula=p_o%3Dnumber%5C%20in%5C%20agreement%2F%5C%20total%3D(20%2B15" alt="p_o=number\ in\ agreement/\ total=(20+15)/50=0.70">%2F50%3D0.70)</p>
<p><strong>Step2</strong> ：计算<img src="https://math.jianshu.com/math?formula=p_e" alt="p_e"><br> <img src="https://math.jianshu.com/math?formula=p_e%3DThe%5C%20total%5C%20probability%5C%20the%5C%20raters%5C%20both%5C%20saying%5C%20postive%20%5C%5Cand%5C%20negative%20%5C%20randomly%20%3D(25%2F50" alt="p_e=The\ total\ probability\ the\ raters\ both\ saying\ postive \\and\ negative \ randomly =(25/50)*(30/50)+(25/50)*(20/50)=0.50"><em>(30%2F50)%2B(25%2F50)</em>(20%2F50)%3D0.50)<br> <strong>Step3</strong> ：计算<img src="https://math.jianshu.com/math?formula=k" alt="k"><br> <img src="https://math.jianshu.com/math?formula=k%3D%5Cfrac%7Bp_o-p_e%7D%7B1-p_e%7D%3D%5Cfrac%7B0.70-0.50%7D%7B1-0.50%7D%3D0.40" alt="k=\frac{p_o-p_e}{1-p_e}=\frac{0.70-0.50}{1-0.50}=0.40"><br> <img src="https://math.jianshu.com/math?formula=k%3D0.40" alt="k=0.40"> 代表<strong>fair agreement</strong></p>
<h3 id="Fleiss’s-Kappa"><a href="#Fleiss’s-Kappa" class="headerlink" title="Fleiss’s Kappa"></a>Fleiss’s Kappa</h3><p>Fleiss’s Kappa 是对 Cohen‘s Kappa 的扩展：</p>
<ul>
<li>衡量<strong>三个或更多</strong>评分者的一致性</li>
<li>不同的评价者可以对不同的项目进行评分，而不用像Cohen’s 两个评价者需要对相同的项目进行评分</li>
<li>Cohen’s Kappa 的评价者是精心选择和固定的，而Fleiss’s Kappa 的评价者是从较大的人群中随机选择的</li>
</ul>
<p>举一个例子对 Fleiss’s Kappa 的计算进行说明：14个评价者对10个项目进行1-5的评分，<img src="https://math.jianshu.com/math?formula=N%3D10%2Cn%3D14%2Ck%3D5" alt="N=10,n=14,k=5"></p>
<blockquote>
<p>关于这  “10个项目” 的理解：比如在 NLI 数据标注中，需要为很多 promise-hypotheses pair 进行打分，这每一个pair就是一个pair.</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://math.jianshu.com/math?formula=n_%7Bij%7D" alt="n_{ij}"></th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center"><img src="https://math.jianshu.com/math?formula=P_i" alt="P_i"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">14</td>
<td style="text-align:center">1.000</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">6</td>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0.253</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">0.308</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">9</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0.440</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">8</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0.330</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
<td style="text-align:center">7</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0.462</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">6</td>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0.242</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">2</td>
<td style="text-align:center">5</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0.176</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">6</td>
<td style="text-align:center">5</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0.286</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">7</td>
<td style="text-align:center">0.286</td>
</tr>
<tr>
<td style="text-align:center">Total</td>
<td style="text-align:center">20</td>
<td style="text-align:center">28</td>
<td style="text-align:center">39</td>
<td style="text-align:center">21</td>
<td style="text-align:center">32</td>
<td style="text-align:center">140</td>
</tr>
<tr>
<td style="text-align:center"><img src="https://math.jianshu.com/math?formula=p_j" alt="p_j"></td>
<td style="text-align:center">0.143</td>
<td style="text-align:center">0.200</td>
<td style="text-align:center">0.279</td>
<td style="text-align:center">0.150</td>
<td style="text-align:center">0.229</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Step1</strong> ：计算<img src="https://math.jianshu.com/math?formula=p_j" alt="p_j"> ，以<img src="https://math.jianshu.com/math?formula=p_1" alt="p_1">为例，评价者随机打1分的概率<br> <img src="https://math.jianshu.com/math?formula=p_1%3Dthe%5C%20total%5C%20number%5C%20of%5C%20the%5C%20column%2F%5C%20the%5C%20total%5C%20number%5C%20of%20%5C%20tasks%20%3D%2020%2F14*10%3D0.143" alt="p_1=the\ total\ number\ of\ the\ column/\ the\ total\ number\ of \ tasks = 20/14*10=0.143"><br> <strong>Step2</strong> ：计算<img src="https://math.jianshu.com/math?formula=P_i" alt="P_i"> ，以<img src="https://math.jianshu.com/math?formula=P_2" alt="P_2">为例,14个评价者对第2个任务达成共识的程度<br> <img src="https://math.jianshu.com/math?formula=P_2%3D%5Cfrac%7Bthe%5C%20sum%5C%20of%5C%20suqare%20%5C%20of%5C%20the%5C%20row%7D%7Bn*(n-1" alt="P_2=\frac{the\ sum\ of\ suqare \ of\ the\ row}{n*(n-1)}=\frac{0^2+2^2+6^2+4^2-14}{14*(14-1)}=0.253">%7D%3D%5Cfrac%7B0%5E2%2B2%5E2%2B6%5E2%2B4%5E2-14%7D%7B14<em>(14-1)%7D%3D0.253)<br> <strong>Step3</strong> ：计算<img src="https://math.jianshu.com/math?formula=P_e%2CP_o" alt="P_e,P_o"><br> ![P_o=\frac{1}{N}\sum_{i=1}^{N}P_i=\frac{1}{10}</em>3.78=0.378](<a href="https://math.jianshu.com/math?formula=P_o%3D%5Cfrac%7B1%7D%7BN%7D%5Csum_%7Bi%3D1%7D%5E%7BN%7DP_i%3D%5Cfrac%7B1%7D%7B10%7D*3.78%3D0.378" target="_blank" rel="noopener">https://math.jianshu.com/math?formula=P_o%3D%5Cfrac%7B1%7D%7BN%7D%5Csum_%7Bi%3D1%7D%5E%7BN%7DP_i%3D%5Cfrac%7B1%7D%7B10%7D*3.78%3D0.378</a>)</p>
<p><img src="https://math.jianshu.com/math?formula=P_e%3D%5Csum_%7Bj%3D1%7D%5E%7Bk%7Dp_j%5E2%3D0.143%5E2%2B0.200%5E2%2B0.279%5E2%2B0.150%5E2%2B0.229%5E2%3D0.213" alt="P_e=\sum_{j=1}^{k}p_j^2=0.143^2+0.200^2+0.279^2+0.150^2+0.229^2=0.213"></p>
<p><img src="https://math.jianshu.com/math?formula=k%3D%5Cfrac%7BP_o-P_e%7D%7B1-P_e%7D%3D%5Cfrac%7B0.378-0.213%7D%7B1-0.213%7D%3D0.210" alt="k=\frac{P_o-P_e}{1-P_e}=\frac{0.378-0.213}{1-0.213}=0.210"></p>
<p><img src="https://math.jianshu.com/math?formula=k%3D0.210" alt="k=0.210"> 代表<strong>fair agreement</strong></p>
<blockquote>
<p>[1] Landis JR, Koch GG. The measurement of observer agreement for categorical data. Biometrics.     1977;33(1):159–74</p>
<p>[2] <a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.pmean.com%2Fdefinitions%2Fkappa.htm" target="_blank" rel="noopener">http://www.pmean.com/definitions/kappa.htm</a></p>
<p>[3] <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.statisticshowto.datasciencecentral.com%2Fcohens-kappa-statistic%2F" target="_blank" rel="noopener">https://www.statisticshowto.datasciencecentral.com/cohens-kappa-statistic/</a></p>
<p>[4] <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.statisticshowto.datasciencecentral.com%2Ffleiss-kappa%2F" target="_blank" rel="noopener">https://www.statisticshowto.datasciencecentral.com/fleiss-kappa/</a></p>
<p>[5]  <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Famirziai%2Flearning%2Fblob%2Fmaster%2Fstatistics%2FInter-rater%20agreement%20kappas.ipynb%5D(https%3A%2F%2Fgithub.com%2Famirziai%2Flearning%2Fblob%2Fmaster%2Fstatistics%2FInter-rater" target="_blank" rel="noopener">[https://github.com/amirziai/learning/blob/master/statistics/Inter-rater%20agreement%20kappas.ipynb](https://github.com/amirziai/learning/blob/master/statistics/Inter-rater</a> agreement kappas.ipynb)</p>
<p>[6] <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fqq_31113079%2Farticle%2Fdetails%2F76216611" target="_blank" rel="noopener">https://blog.csdn.net/qq_31113079/article/details/76216611</a></p>
</blockquote>
<p>作者：Luuuuuua<br>链接：<a href="https://www.jianshu.com/p/f9c383b39859" target="_blank" rel="noopener">https://www.jianshu.com/p/f9c383b39859</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
  </entry>
  <entry>
    <title>谱聚类</title>
    <url>/2019/04/08/%E8%B0%B1%E8%81%9A%E7%B1%BB/</url>
    <content><![CDATA[<ul>
<li>先占位置</li>
<li><a href="https://www.cnblogs.com/pinard/p/6221564.html" target="_blank" rel="noopener">参考某博客</a>  </li>
<li><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.SpectralClustering.html#sklearn.cluster.SpectralClustering" target="_blank" rel="noopener">sklearn.cluster.SpectralClustering</a></p>
<ul>
<li>References<br>Normalized cuts and image segmentation, 2000 Jianbo Shi, Jitendra Malik <a href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.160.2324" target="_blank" rel="noopener">http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.160.2324</a><br>A Tutorial on Spectral Clustering, 2007 Ulrike von Luxburg <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.165.9323" target="_blank" rel="noopener">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.165.9323</a><br>Multiclass spectral clustering, 2003 Stella X. Yu, Jianbo Shi <a href="http://www1.icsi.berkeley.edu/~stellayu/publication/doc/2003kwayICCV.pdf" target="_blank" rel="noopener">http://www1.icsi.berkeley.edu/~stellayu/publication/doc/2003kwayICCV.pdf</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>图卷积网络</category>
      </categories>
      <tags>
        <tag>图卷积网络</tag>
      </tags>
  </entry>
  <entry>
    <title>非极大值抑制(NMS)</title>
    <url>/2019/03/20/%E9%9D%9E%E6%9E%81%E5%A4%A7%E5%80%BC%E6%8A%91%E5%88%B6-NMS/</url>
    <content><![CDATA[<p>非极大值抑制（Non-maximum suppression，NMS）是一种去除非极大值的算法，常用于计算机视觉中的边缘检测、物体识别等。</p>
<h2 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h2><p>给出一张图片和上面许多物体检测的候选框（即每个框可能都代表某种物体），但是这些框很可能有互相重叠的部分，我们要做的就是只保留最优的框。假设有N个框，每个框被分类器计算得到的分数为Si, 1&lt;=i&lt;=N。</p>
<p>0、建造一个存放待处理候选框的集合H，初始化为包含全部N个框；</p>
<p>建造一个存放最优框的集合M，初始化为空集。</p>
<p>1、将所有集合 H 中的框进行排序，选出分数最高的框 m，从集合 H 移到集合 M；</p>
<p>2、遍历集合 H 中的框，分别与框 m 计算交并比（Interection-over-union，IoU），如果高于某个阈值（一般为0~0.5），则认为此框与 m 重叠，将此框从集合 H 中去除。</p>
<p>3、回到第1步进行迭代，直到集合 H 为空。集合 M 中的框为我们所需。</p>
<h2 id="需要优化的参数："><a href="#需要优化的参数：" class="headerlink" title="需要优化的参数："></a>需要优化的参数：</h2><p>IoU 的阈值是一个可优化的参数，一般范围为0~0.5，可以使用交叉验证来选择最优的参数。<br>比如人脸识别的一个例子：</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g19dbcocjfj30gw07kdmg.jpg"></p>
<p>已经识别出了 5 个候选框，但是我们只需要最后保留两个人脸。</p>
<p>首先选出分数最大的框（0.98），然后遍历剩余框，计算 IoU，会发现露丝脸上的两个绿框都和 0.98 的框重叠率很大，都要去除。</p>
<p>然后只剩下杰克脸上两个框，选出最大框（0.81），然后遍历剩余框（只剩下0.67这一个了），发现0.67这个框与 0.81 的 IoU 也很大，去除。</p>
<p>至此所有框处理完毕，算法结果：</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g19dbr3kk4j30gw07kdmi.jpg"></p>
<p>（图片来自<a href="https://blog.csdn.net/shuzfan/article/details/52711706）" target="_blank" rel="noopener">https://blog.csdn.net/shuzfan/article/details/52711706）</a></p>
<h2 id="添加-by-yaya"><a href="#添加-by-yaya" class="headerlink" title="添加 by yaya:"></a>添加 by yaya:</h2><ul>
<li>在faster r-cnn中，得到了pred_boxes以及cls_boxes 之后，分别对每个类的objects进行NMS。（这里多说一句：使用了class_agnostic=false，即对每个bbox都有N个类别的得分）</li>
<li>首先得到得分最高的一个object bbox，之后，进行IOU分析，若IoU大于阈值，则剔除，否则保留。</li>
<li>对这一个得分最高的bbox分析完之后，再分析下一个次高得分的，并剔除所有与它IoU值大于阈值的object。一直这样分析，直到剩下的object之间的IoU值两两之间均小于阈值。</li>
<li>即可得到该类对应的bbox，且不交叠。</li>
<li>下一循环分析下一个类<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, imdb.num_classes):</span><br><span class="line">    inds = torch.nonzero(scores[:,j]&gt;thresh).view(<span class="number">-1</span>) </span><br><span class="line">    <span class="comment"># thresh = 0   inds.shape = torch.Size([300])</span></span><br><span class="line">    <span class="comment"># if there is det</span></span><br><span class="line">    <span class="keyword">if</span> inds.numel() &gt; <span class="number">0</span>:</span><br><span class="line">      cls_scores = scores[:,j][inds] <span class="comment"># 某个类在300个object上的得分</span></span><br><span class="line">      _, order = torch.sort(cls_scores, <span class="number">0</span>, <span class="literal">True</span>) <span class="comment"># 某个类在这300个object上的得分的高低排序</span></span><br><span class="line">      <span class="keyword">if</span> args.class_agnostic:</span><br><span class="line">        cls_boxes = pred_boxes[inds, :]</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        cls_boxes = pred_boxes[inds][:, j * <span class="number">4</span>:(j + <span class="number">1</span>) * <span class="number">4</span>]  <span class="comment"># 某个类对应的predict bbox</span></span><br><span class="line">      </span><br><span class="line">      cls_dets = torch.cat((cls_boxes, cls_scores.unsqueeze(<span class="number">1</span>)), <span class="number">1</span>)  <span class="comment"># torch.Size([300, 5])</span></span><br><span class="line">      <span class="comment"># cls_dets = torch.cat((cls_boxes, cls_scores), 1)</span></span><br><span class="line">      cls_dets = cls_dets[order]  <span class="comment"># torch.Size([300, 5]) 排了序之后的cat</span></span><br><span class="line">      keep = nms(cls_dets, cfg.TEST.NMS)  <span class="comment"># torch.Size([91, 1])</span></span><br><span class="line">      cls_dets = cls_dets[keep.view(<span class="number">-1</span>).long()]  <span class="comment"># torch.Size([91, 5])</span></span><br><span class="line">      <span class="keyword">if</span> vis:</span><br><span class="line">        im2show = vis_detections(im2show, imdb.classes[j], cls_dets.cpu().numpy(), <span class="number">0.3</span>)</span><br><span class="line">      all_boxes[j][i] = cls_dets.cpu().numpy()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      all_boxes[j][i] = empty_array</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>作者：HappyRocking<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/HappyRocking/article/details/79970627" target="_blank" rel="noopener">https://blog.csdn.net/HappyRocking/article/details/79970627</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>
]]></content>
      <categories>
        <category>目标检测</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>目标检测</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读论文 tips</title>
    <url>/2020/05/29/%E9%98%85%E8%AF%BB%E8%AE%BA%E6%96%87-tips/</url>
    <content><![CDATA[<p>[TOC]</p>
<h4 id="快速阅读：划分结构层次"><a href="#快速阅读：划分结构层次" class="headerlink" title="快速阅读：划分结构层次"></a>快速阅读：划分结构层次</h4><p>对于快速阅读，一个小的技巧是图文浏览。因为一些好的论文必然是图文并茂，所以只要弄清楚论文中表格和图片的标题和注释，就能够获得这篇论文八、九成的信息。</p>
<p>读者在读论文的时候也应该要有逻辑，首先要清楚论文中的表达是否是我想要学习到的；其次，我能从论文中学到多少呢；最后，这篇论文的背景是什么——是什么样的背景让这篇论文变得重要和有趣。</p>
<h4 id="仔细阅读：批判思维"><a href="#仔细阅读：批判思维" class="headerlink" title="仔细阅读：批判思维"></a>仔细阅读：批判思维</h4><p>以评判性阅读开始，带着质疑的心态问问题。如果作者论文中声称解决了一个问题，那么你就要在心里问自己：<strong>论文是否正确、真正地解决了问题？</strong> <strong>作者论文中所用方法是否有局限性</strong>？如果<strong>所读的论文没有解决问题，那么我能解决么</strong>？我能采用<strong>比论文中更简单的方法解决么</strong>？所以，一旦进入仔细阅读的状态，要在读论文之前对自己说：这篇论文可能有问题，我要找出来。</p>
<h4 id="创造性阅读：积极思考"><a href="#创造性阅读：积极思考" class="headerlink" title="创造性阅读：积极思考"></a>创造性阅读：积极思考</h4><p>问自己：在我所读的论文中，作者有<strong>哪些点还没有想到</strong>？如果我现在做这项研究，我<strong>能做的新事情是什么</strong>？创造性的阅读需要<strong>把你所读的论文和其他相关的论文建立联系，从而产生一些新的想法</strong>，这些想法可以支撑你进行三个月到五个月的研究。</p>
<p>如果你真正想理解你所读的论文，那么就写一个摘要吧，最好做一个口头展示，这样你会发现，只有把东西写下来或者说出来才能真正深刻理解。如果你能做一个报告，那就更好了，因为做报告的时候，别人可以问你问题，这会强迫你理解所读的论文。</p>
<p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1gf9in4p85tj30f8088t92.jpg"></p>
<p>在做这个演讲之前，我曾经向我的同事、学生询问了关于论文阅读有哪些问题可以“问自己”，上面这张图片是一个总结，图片的上半部分是比较客观的问题，包括论文的核心观点是什么？主要的局限性是什么？代码和数据是不是可得的？论文的贡献是否有意义？论文中的实验是否足够好？</p>
<p>图片的下半部分是比较主观的问题，包括我错过了什么相关论文么？这对我的工作有何帮助么？这是一篇值得关注的论文么？这个研究领域的领头人是谁呢？其他的人对这篇论文有何看法呢？如果有机会见到作者，我应该问作者什么问题？</p>
<p>当你在阅读论文的时候如果能回答出上面列出的问题，我相信你会对你所读论文有非常深刻的理解。</p>
]]></content>
      <categories>
        <category>杂类</category>
      </categories>
      <tags>
        <tag>杂类</tag>
      </tags>
  </entry>
</search>
