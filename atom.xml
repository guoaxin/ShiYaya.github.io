<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ShiYaya</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-08-03T08:02:10.876Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ShiYaya</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大规模多模态因果预训练</title>
    <link href="http://yoursite.com/2021/08/03/%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%A4%9A%E6%A8%A1%E6%80%81%E5%9B%A0%E6%9E%9C%E9%A2%84%E8%AE%AD%E7%BB%83/"/>
    <id>http://yoursite.com/2021/08/03/大规模多模态因果预训练/</id>
    <published>2021-08-03T07:43:25.000Z</published>
    <updated>2021-08-03T08:02:10.876Z</updated>
    
    <content type="html"><![CDATA[<p>转载： <a href="https://mp.weixin.qq.com/s/U2h-hgBZ9HhbHOBaoN0zfA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/U2h-hgBZ9HhbHOBaoN0zfA</a></p><p><strong>张圣宇：</strong>浙江大学计算机科学与技术学院博士生三年级，导师为吴飞老师。研究方向为稳定学习，多模态理解，和推荐系统。在KDD，ACM MM，WWW，SIGIR等会议上发表了多篇长文论文。</p><p>个人主页：<a href="https://shengyuzhang.github.io/" target="_blank" rel="noopener">https://shengyuzhang.github.io/</a></p><p>论文标题： DeVLBert: Learning Deconfounded Visio-Linguistic Representations</p><p>论文链接：<a href="https://dl.acm.org/doi/10.1145/3394171.3413518" target="_blank" rel="noopener">https://dl.acm.org/doi/10.1145/3394171.3413518</a></p><h2 id="1-主要内容"><a href="#1-主要内容" class="headerlink" title="1. 主要内容"></a>1. <strong>主要内容</strong></h2><p>大规模预训练旨在可轻易大量获得的无标注（或单一标注）数据上学习到与具体下游任务无关的通用表征，以迁移到只有少量标注的具体下游任务上，实现“微调即可用”（如图1）。大规模预训练可追溯到在大型数据集（例如ImageNet[2]）上对AlexNet[1]，VGG[4]和ResNet[3]等主干模型进行预训练，然后将知识迁移到众多下游计算机视觉任务。自此，预训练开始成为深度学习成功的标志。</p><p>最近，在自然语言处理研究领域，基于Transformer和Bert的预训练模型[5,6,7,8,9]的研究工作激增，并且在各类自然语言处理任务中都达到了最佳性能。</p><p><img src="https://i.loli.net/2021/08/03/24rKdbfSH7QCLlo.png" alt="图片" style="zoom:67%;"></p><center> 图1 预训练链路框架图 </center><p>视觉或语言单一模态的理解对于视觉或语言任务是必不可少的，不同模态间的相互关系也同样重要，例如，如果下游的多模态模型无法将相关的视觉对象和语言单词在表征上进行联系，则预训练好的单一模态的特征在许多任务无法实现“微调即可用”的能力。因此，在大规模无标注的多模态数据上学习 到有利于下游任务关联、理解和推理的特征是非常重要的研究任务[10]。</p><p><img src="https://i.loli.net/2021/08/03/iJ7xQFmWtvBYHoX.png" alt="图片" style="zoom:67%;"></p><center>图2 超大规模跨模态数据集Conceptual Caption中存在的虚假关联问题</center><p>相比于直接在下游任务上从零开始进行训练，预训练的特征或模型在带来知识的同时也引入了预训练数据集中的偏差（Biases）[11]。预训练数据集偏差可能对域内（In-domain）数据测试有用，但可能会损害域外（Out-of-domain）数据测试[12]，其原因在于虚假关联的产生[13]。例如，如图2所示，在Conceptual Caption数据集中，我们观察到在给定“Instrument”（语言词）的情况下，出现”shirt”（视觉对象）的条件概率很大，即 $p( shirt | instrument )=5.98 \%$</p><p>但是这两者之间没有因果关系。没有因果关联的两个事物在数据集中却被频繁观测到，这看似很奇怪，但在因果理论中可以被有效形式化。如图3所示，我们观测到两个事务X和Y具有很强的关联性（有很多相关的数据都含有<x, y>数据对），是否就可以判断X到Y具有因果效应，从而让模型放心大胆的学习这种效应呢？答案是否定的，从因果的角度，我们观测到X和Y频繁出现，可能是由于X和Y有共同的共因Z。换句话说，有观测到Z的时候，我们通常也会观测到X（Z→X），和Y（Z→Y），而仅观测到X的时候（没有Z），却很少出现Y（X!→Y），即Z构成了X和Y之间的混淆因子。</x,></p><p><img src="https://i.loli.net/2021/08/03/CFIzwiM4SL9uJBy.png" alt="图片"></p><center>图3 没有因果效应的关联原因在于混淆因子Z</center><p>我们可能无法责怪预训练数据集本身，因为我们不能保证数据收集的过程是绝对公平的。通过扩充预训练数据可以通过防止数据样本分布稀缺从而缓解此类问题[11]，但是这种策略在数据收集和计算方面都是昂贵的。</p><p>在本次研究中，我们将从因果推理研究中汲取灵感，并借鉴后门调整（也称为协变量调整或统计调整）[14]的思想缓解预训练中的偏差问题。通过后门调节（去混杂），可以将 $p( shirt | do(instrument) )$ 降低到3.10％（更多的案例请参见图3）。后门调整的实质是在评估给定条件(instrument)的效果时，控制条件（instrument）不受其他潜在混杂因素(Confounder)的影响。通过这种方式，我们旨在减轻数据中可能存在的虚假相关，并提出基于干预的预训练,学习可以很好地迁移到具有未知数据分布的下游任务的通用无偏差的视觉语言表示形式，实现基于大规模多模态因果预训练的泛内容理解。</p><p><img src="https://i.loli.net/2021/08/03/FoPVxA6EuNUlHIy.png" alt="图片"></p> <center> 图2 干预前（红色）后（蓝色）视觉物体和语言单词之间的条件概率 </center><p>因果和预训练的结合主要需要解决以下几个问题：</p><p>1）明确是什么样的模型结构和预训练目标产生了上述的虚假关联。</p><p>2）哪些因素是导致虚假关联的潜在混淆因子，它们是否是可观测到的，是否可以隐式表征从而建模。</p><p>3）如何在模态内部进行干预消除模态内混淆。</p><p>4）如何在模态间进行干预消除模态间混淆。</p><p>本文拟针对大规模多模态预训练中存在的数据偏差问题，利用因果理论分析Bert预训练的目标函数，并建模可能导致数据偏差的因素。在Bert结构基础上提出多个可能的基于干预的去偏差条件预测模块，以替代或增强MLM目标。通过多个下游任务实验测试多个模块的泛化能力，可视化因果干预带来的可解释作用。</p><p>目前大规模多模态预训练的常用模型框架是Bert（Bidirectional Encoder Representation Transformer）。以自然语言预训练为例，Bert的MLM（Masked Language Modeling）预训练任务会随机遮掩一个语言单词Y，其他的某一个（或所有）语言单词表示为X，Bert建模了P(Y/X)。从因果的分析视角，在该条件预测中可能会有混淆因子Z同时影响X和Y，如果在预测X对Y的影响时不控制Z的影响，则可能会得出关于X和Y之间的一些错误结论，因为部分或全部影响可能来自X。</p><p>根据贝叶斯公式，可以得到：</p><p>$P(Y X)=\sum_{z} P(Y, z \mid X)=\sum_{z} P(Y \mid X, z) P(z \mid X)$</p><p>我们的目标是在评估X对Y的影响时利用do算子（do-calculus）消除任何对受干预变量X的影响，可以得到：</p><p>$P(Y \mid d o(X))=\sum_{z} P(Y, z / d o(X))=\sum_{z} P(Y \mid d o(X), z) P(z \mid X)=\sum_{Z} P(Y \mid X, z) p(z)$</p><p>该式和上式的区别在于消除了在评估X对Y影响时z和X之间的影响。然而由于需要对每一个z都需要单独讨论，对每一个z都单独建立一个模型是不可行的，因此我们利用Normalized Weighted Geometric Mean方法，当模型最后预测结果为softmax分类时，可以近似得到：</p><p>$\begin{aligned} P(Y d o(X))=&amp; E_{z}[P(Y X, z)]=E_{z}\left[\operatorname{softmax}\left(f_{c}(\mathrm{x}, \mathrm{z})\right)\right] \\ &amp; \approx \operatorname{softmax}\left(E_{z}\left[f_{c}(\mathrm{x}, \mathrm{z})\right]\right) \end{aligned}$</p><p>到了这一步，建模P(Y|do(X))只需要合适的选取潜在的混淆因子z，并使用Bert有效建模 $E_{z}\left[f_{c}(\mathrm{x}, \mathrm{z})\right]$</p><p>对于混淆因子的选取和去混淆，我们考虑如下三种方式：</p><p>1） 视觉去混淆</p><p>我们将每种视觉物体视作潜在的混淆因子，比如猫和衬衫。为了得到每种混淆因子的表征，我们首先使用预训练得到的物体检测器抽取每张图片中的物体表征，然后将同物体类别在不同图的表征进行平均得到该物体类别的表征。这样，我们构成了视觉混淆因子字典。</p><p>2） 语言去混淆</p><p>在自然语言中，直觉上可以将每一个词视作潜在的混淆因子，但是这样会造成混淆因子字典数目较大，影响训练效率。因此，我们提炼自然语言中的名词作为潜在的混淆因子，名词具有和视觉物体类似的含义，可以与视觉混淆因子保持语义上的接近。为了得到每种混淆因子的表征，和视觉做法类似，我们使用预训练的Bert得到相同名词在不同文本中的上下文表征，然后将这些表征进行平均得到该名词的表征。这样，我们构成了自然语言混淆因子字典。</p><p>3） 跨模态去混淆</p><p>在扩模态预训练中，建模视觉/文本特征时也会用到文本/视觉的信息作为上下文，因此，视觉-文本跨模态之间也会产生混淆，我们在建模视觉/文本特征时也会考虑文本/视觉的混淆因子字典，进行跨模态去混淆。</p><p>为了有效建模该式中的 $E_{z}\left[f_{c}(\mathbf{x}, \mathbf{z})\right]$​ 并和Bert结构结合，本研究提出了四种结构和方法，如图3所示。</p><p><img src="https://i.loli.net/2021/08/03/5VGifS4gmYqnDl1.png" alt="image-20210803160200523"></p><center> 图3 四种基于干预的Bert风格因果预训练模型结构示意图 </center><p>1） 模型A</p><p>我们首先探索如何通过干预来增强掩码语言模型（MLM），这是因为1）MLM是最常用的预训练代理任务之一。2）MLM仅基于似然估计，这可能会引入虚假关联。我们以自然语言预训练为例进行说明。Wt对于一个被屏蔽的单词Wt，由于Wt不包含来自单词本身（单词本身被掩盖）的信息，因此可以最终表示Wt视为Xt。但是，要在单个推理中找到包含单词Wt信息的Yt并不容易。我们选择进行另外一次推断（在该推断中没有任何词被掩盖）。因此在第二次推断中，单词Wt的最终表示可以视为y。在图3的A子图描绘了该实现。</p><p>2） 模型B</p><p>图3B所示为增强MLM的另外一种实现。在MLM的框架下，Bert搜集上下文中与被掩盖的Wt相关的信息并进行汇总，以预测Wt的标签。从这个角度来看，被掩盖的单词Wt的最终表示可以看作是Yt，而每一个未被掩盖的单词的最终表示可以被看作x。这种设计比模型A更为高效，因为不需要额外的推理过程。</p><p>3） 模型C</p><p>模型C是模型A的一个变种，其将每一个未被掩盖的单词的最终表示看作x和模型A不同的是，模型C并没有影响MLM目标，而是在MLM之上增加了新的训练目标。</p><p>4） 模型D</p><p>模型D将每一个未被掩盖的单词视作和其对应的x和y的融合特征，它不需要像模型A和模型C一样的二次推断过程，同时和C一样不影响MLM目标，因此是一种非侵入式的设计。</p><p>我们在超大规模多模态数据集Conceptual Caption数据集上进行了因果预训练，并在多个与Conceptual Caption数据分布不同的数据集上进行了下游任务的训练和测试，这样可以更好的评估我们的方法是否能在数据分布迁移中实现更好的性能。我们在图片检索，零样本图片建模和视觉问答三个下游任务上进行了测试，对比了SCAN和BUTD两个特定领域的SOTA模型，和只使用下游任务数据的VisualBert、只使用和下游任务数据无关数据的ViLBERT（Out-of-domain Pretraining），和同时使用下游任务数据和领域无关数据的InterBert。</p><p><img src="https://i.loli.net/2021/08/03/m54gpz8dkOZRsaq.png" alt="图片"></p><center>表1 多预训练模型对比模型在多下游任务上的对比</center><p>可以看到，我们的因果预训练模型DeVLBert相对于特定领域SOTA模型，和ViLBERT、VisualBert都取得了显著的提升。相对于同时使用下游任务数据集的InterBert，我们在图片检索任务上取得了接近的性能，并在视觉问答任务上取得了提升。这些结果验证了我们模型的有效性。</p><p>为了从人的视角直观展示因果预训练的优势，我们可视化了DeVLBert（每个案例的左侧）和 ViLBERT（右侧）中最后一个跨模态注意力层的注意力权重最大的视觉物体（红、绿框）和文本单词对（以及对应的注意权重）。我们从下游任务的测试/验证集中采样案例，考虑图像检索（上半部分）和 视觉问答（下半部分）两个下游任务。</p><p>可以看到，以第三行第一个案例为例，VilBert容易受文本“clouds”和视觉物体“Sky”虚假关联影响，关注到错误视觉区域，并给出了错误的回答。相对应的，DeVLBert通过减弱虚假关联， 关注到正确的视觉物体区域 “clouds”，给出正解。同时，以第三行第4个案例为例，VilBert受文本“sitting”和视觉物 体“table”虚假关联影响，关注到 错误视觉区域。相反，DeVLBert通过减弱虚假关联，注意到 更少共现 但正确的区域 “cutting board”，给出统计意义上更少出现的正解</p><p>$(P($ cutting board $\mid$ sitting $)=0.25 \%&lt;P($ table $\mid$ sitting $)=2.67 \%)$</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] Krizhevsky, Alex, Ilya Sutskever, and Geoffrey E. Hinton. 2012. “ImageNet Classification with Deep Convolutional Neural Networks.” In Advances in Neural Information Processing Systems, Lake Tahoe, Nevada, United States.</p><p>[2] Deng, Jia, Wei Dong, Richard Socher, Li-Jia Li, Kai Li, and Fei-Fei Li. 2009. “ImageNet: A Large-Scale Hierarchical Image Database.” In IEEE Computer Society Conference on Computer Vision and Pattern Recognition.</p><p>[3] He, Kaiming, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. 2016. “Deep Residual Learning for Image Recognition.” In IEEE Conference on Computer Vision and Pattern Recognition.</p><p>[4] Simonyan, Karen, and Andrew Zisserman. 2015. “Very Deep Convolutional Networks for Large-Scale Image Recognition.” In 3rd International Conference on Learning Representations.</p><p>[5] Conneau, Alexis, and Guillaume Lample. 2019. “Cross-Lingual Language Model Pretraining.” In Advances in Neural Information Processing Systems.</p><p>[6] Devlin, Jacob, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. 2019. “BERT: Pre-Training of Deep Bidirectional Transformers for Language Understanding.” In Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies.</p><p>[7] Dong, Li, Nan Yang, Wenhui Wang, Furu Wei, Xiaodong Liu, Yu Wang, Jianfeng Gao, Ming Zhou, and Hsiao-Wuen Hon. 2019. “Unified Language Model Pre-Training for Natural Language Understanding and Generation.” In Advances in Neural Information Processing Systems.</p><p>[8] Liu, Yinhan, Myle Ott, Naman Goyal, Jingfei Du, Mandar Joshi, Danqi Chen, Omer Levy, Mike Lewis, Luke Zettlemoyer, and Veselin Stoyanov. 2019. “RoBERTa: A Robustly Optimized BERT Pretraining Approach.” CoRR abs/1907.11692.</p><p>[9] Song, Kaitao, Xu Tan, Tao Qin, Jianfeng Lu, and Tie-Yan Liu. 2019. “MASS: Masked Sequence to Sequence Pre-Training for Language Generation.” In Proceedings of the 36th International Conference on Machine Learning.</p><p>[10] Lu, Jiasen, Dhruv Batra, Devi Parikh, and Stefan Lee. 2019. “ViLBERT: Pretraining Task-Agnostic Visiolinguistic Representations for Vision-and-Language Tasks.” In Advances in Neural Information Processing Systems.</p><p>[11] Yang, Xu, Hanwang Zhang, and Jianfei Cai. 2020. “Deconfounded Image Captioning: A Causal Retrospect.” CoRR abs/2003.03923.</p><p>[12] Kuang, Kun, Peng Cui, Susan Athey, Ruoxuan Xiong, and Bo Li. 2018. “Stable Prediction across Unknown Environments.” In Proceedings of the 24th ACM SIGKDD International Conference on Knowledge Discovery &amp; Data Mining.</p><p>[13] Pearl, Judea, Madelyn Glymour, and Nicholas P Jewell. 2016. Causal Inference in Statistics: A Primer. John Wiley &amp; Sons.</p><p>[14] Shanmugam, Ram. 2001. “Causality: Models, Reasoning, and Inference : Judea Pearl; Cambridge University Press, Cambridge, UK, 2000, Pp 384, ISBN 0-521-77362-8.” Neurocomputing 41 (1–4): 189–90.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载： &lt;a href=&quot;https://mp.weixin.qq.com/s/U2h-hgBZ9HhbHOBaoN0zfA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/U2h-hgBZ9HhbHOB
      
    
    </summary>
    
      <category term="cross-modal" scheme="http://yoursite.com/categories/cross-modal/"/>
    
    
      <category term="cross-modal" scheme="http://yoursite.com/tags/cross-modal/"/>
    
  </entry>
  
  <entry>
    <title>Align before Fuse: Vision and Language Representation Learning with Momentum Distillation</title>
    <link href="http://yoursite.com/2021/08/03/Align-before-Fuse-Vision-and-Language-Representation-Learning-with-Momentum-Distillation-1/"/>
    <id>http://yoursite.com/2021/08/03/Align-before-Fuse-Vision-and-Language-Representation-Learning-with-Momentum-Distillation-1/</id>
    <published>2021-08-03T07:29:35.000Z</published>
    <updated>2021-08-03T07:29:35.475Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Pre-train, Prompt, and Predict: A Systematic Survey of Prompting Methods in Natural Language Processing</title>
    <link href="http://yoursite.com/2021/08/03/Pre-train-Prompt-and-Predict-A-Systematic-Survey-of-Prompting-Methods-in-Natural-Language-Processing/"/>
    <id>http://yoursite.com/2021/08/03/Pre-train-Prompt-and-Predict-A-Systematic-Survey-of-Prompting-Methods-in-Natural-Language-Processing/</id>
    <published>2021-08-03T03:50:07.000Z</published>
    <updated>2021-08-03T04:20:05.775Z</updated>
    
    <content type="html"><![CDATA[<p><strong>论文链接：</strong></p><p><a href="https://arxiv.org/abs/2107.13586" target="_blank" rel="noopener">https://arxiv.org/abs/2107.13586</a></p><p><strong>网站</strong></p><p><a href="http://pretrain.nlpedia.ai/" target="_blank" rel="noopener">http://pretrain.nlpedia.ai/</a></p><h2 id="1-概要"><a href="#1-概要" class="headerlink" title="1. 概要"></a>1. 概要</h2><p><strong>本文针对自然语言处理的新范式——我们称之为“prompt-based 学习”，进行了综述与组织。</strong></p><p>区别于传统的监督学习中训练模型接受输入 x 并将输出 y 预测为 P(y|x)，Prompt-based 学习基于直接对文本概率进行建模的语言模型。为了使用这些模型执行预测任务，使用模板将原始输入 x 修改为具有一些未填充槽的文本字符串 prompt  x’，然后使用语言模型对未填充信息进行概率填充以获得最终字符串 x ，从中可以导出最终输出 y。</p><p>这个框架强大且有吸引力的原因有很多：它允许语言模型在大量原始文本上进行预训练，并且通过定义一个新的 prompting 函数，模型能够执行少样本甚至零样本学习，可以适应很少或没有标记数据的新场景。</p><p>在本文中，我们介绍了这种有发展前途的范式的基础知识，描述了一组统一的数学符号，可以涵盖现有的很多工作；并沿多个维度组织现有工作，例如预训练模型的选择、prompt 和调整策略。为了让感兴趣的初学者更容易接触到该领域，我们不仅对现有工作以及基于 prompt 的概念的高度结构化类型进行了系统综述和，还发布了其他资源，在这个网站中包含了持续更新的综述以及论文列表：</p><p><a href="http://pretrain.nlpedia.ai/" target="_blank" rel="noopener">http://pretrain.nlpedia.ai/</a> </p><h2 id="2-引言"><a href="#2-引言" class="headerlink" title="2. 引言"></a>2. 引言</h2><p>第一次巨变是“pre-train and fine-tune” 范式，第二次巨变则是目前的 “pre-train, prompt, and predict”。如图，是 NLP 中的四种范式。</p><p><img src="https://i.loli.net/2021/08/03/lfiOhGqW3j1569m.png" alt="image-20210803115431247"></p><h2 id="3-Prompting-的正式描述"><a href="#3-Prompting-的正式描述" class="headerlink" title="3. Prompting 的正式描述"></a>3. Prompting 的正式描述</h2><p>在传统的 NLP 监督学习系统中，我们采用输入 x（通常是文本），并基于模型 $P(y|x;\theta)$ 预测输出 y。y 可以是标签、文本或其他各种输出。为了学习这个模型的参数 ，我们使用一个包含输入和输出对的数据集，并训练一个模型来预测这个条件概率。</p><p><font color="red">监督学习的主要问题是，为了训练模型$P(y|x;\theta)$​  ，必须有任务的监督数据，而对于许多任务来说，这些数据是无法大量获取的。</font> Prompt-based 学习方法试图通过学习一个语言模型（LM）来规避这个问题，该 LM 对文本 x 本身的概率 $P(x;\theta)$ 进行建模，并使用该概率来预测 y，从而减少或消除了对于大型监督数据集的需求。</p><p>在本节中，我们对最基本的提示形式进行了数学描述，其中包含许多有关 prompt 的工作，并且可以扩展以涵盖其他内容。具体来说，基本 prompt 分三步预测得分最高的 $\hat{y}$ 。分别为：</p><ul><li>prompt 添加：通过 $f_{prompt}(x)$将输入文本转化为一个 prompt</li><li>回答搜索：找到能将 LM 分数最大化的得分最高的文本 $\hat{z}$</li><li>回答mapping：通过得分最高的回答 $\hat{z}$​，得到得分最高的输出 $\hat{y}$</li></ul><p>如图所示，是 Prompt 方法的一些术语和符号表示。</p><p><img src="https://i.loli.net/2021/08/03/V1ktlPNzWHKbSwd.png" alt="image-20210803121153745"></p><h2 id="4-Prompting-设计过程中的注意事项"><a href="#4-Prompting-设计过程中的注意事项" class="headerlink" title="4. Prompting 设计过程中的注意事项"></a>4. Prompting 设计过程中的注意事项</h2><p>有了基本的数学公式后，还需要了解一些基本设计注意事项：</p><ul><li>预训练模型选择：有多种预训练 LM 可用于计算 $P(y|x;\theta)$。对于 Prompt 方法在效用维度存在差异。</li><li>Prompt 工程：鉴于 prompt 指定了任务，选择合适的 prompt 不仅对准确性有很大影响，而且对模型首先执行的任务也有很大影响；</li><li>回答工程：根据任务的不同，我们可能希望设计不同的 Z，可能与映射函数一起设计；</li><li>扩展范式：如上所述，上述等式仅代表已被提议用于执行此类 prompt 的各种基础框架中最简单的。还有一些扩展这种基本范式以进一步提高结果或适用性的方法；</li><li>基于 prompt 的训练策略：有训练参数的方法，包括 prompt 和 LM。</li></ul><h2 id="5-Prompt-方法分类"><a href="#5-Prompt-方法分类" class="headerlink" title="5. Prompt 方法分类"></a>5. Prompt 方法分类</h2><p><img src="https://i.loli.net/2021/08/03/Vic9PNBJg85zZXS.png" alt="640"></p><p><img src="https://i.loli.net/2021/08/03/2LQxD1MP6zqy9hj.png" alt="641"></p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>在本文中，作者总结并分析了统计自然语言处理技术发展中的几个范式，并认为 Prompt-based 学习是一种很有前途的新范式，它可能代表着我们看待 NLP 方式的另一个重大变化。 </p><p>作者在原文中列出了详细的表格、实例甚至 timeline 以帮助读者更加直观地了解这一新范式，非常值得阅读原文。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;论文链接：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/2107.13586&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://arxiv.org/abs/2107.13586&lt;
      
    
    </summary>
    
      <category term="NLP" scheme="http://yoursite.com/categories/NLP/"/>
    
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>Multi-stage Pre-training over Simplified Multimodal Pre-training Models</title>
    <link href="http://yoursite.com/2021/08/03/Multi-stage-Pre-training-over-Simplified-Multimodal-Pre-training-Models/"/>
    <id>http://yoursite.com/2021/08/03/Multi-stage-Pre-training-over-Simplified-Multimodal-Pre-training-Models/</id>
    <published>2021-08-03T02:09:50.000Z</published>
    <updated>2021-08-03T02:09:50.445Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Towards General Purpose Vision Systems</title>
    <link href="http://yoursite.com/2021/08/03/Towards-General-Purpose-Vision-Systems/"/>
    <id>http://yoursite.com/2021/08/03/Towards-General-Purpose-Vision-Systems/</id>
    <published>2021-08-03T01:54:33.000Z</published>
    <updated>2021-08-03T01:58:04.520Z</updated>
    
    <content type="html"><![CDATA[<p>CODE: <a href="https://github.com/allenai/gpv-1" target="_blank" rel="noopener">https://github.com/allenai/gpv-1</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CODE: &lt;a href=&quot;https://github.com/allenai/gpv-1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/allenai/gpv-1&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="cross-modal" scheme="http://yoursite.com/categories/cross-modal/"/>
    
    
      <category term="cross-modal" scheme="http://yoursite.com/tags/cross-modal/"/>
    
  </entry>
  
  <entry>
    <title>Informative Image Captioning with External Sources of Information</title>
    <link href="http://yoursite.com/2021/07/22/Informative-Image-Captioning-with-External-Sources-of-Information/"/>
    <id>http://yoursite.com/2021/07/22/Informative-Image-Captioning-with-External-Sources-of-Information/</id>
    <published>2021-07-22T09:08:59.000Z</published>
    <updated>2021-07-22T11:01:55.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-当前存在的问题"><a href="#1-当前存在的问题" class="headerlink" title="1. 当前存在的问题"></a>1. 当前存在的问题</h2><p>一个图像caption应该流畅地呈现出给定图像中的重要信息，包括信息丰富的、细粒度的实体和这些实体的互动方式。 然而，目前的caption模型通常被训练成生成的caption只包含常见物体名称，因此在 “信息量 “这个维度上有所欠缺。 </p><h2 id="2-本文方法简介"><a href="#2-本文方法简介" class="headerlink" title="2. 本文方法简介"></a>2. 本文方法简介</h2><p>我们提出了一种机制，将图像信息与细粒度的标签（假定由一些上游模型生成）整合到caption中，从而以一种流畅和信息丰富的方式描述图像。 我们介绍了一个基于Transformer的多模态、多编码器模型，它同时摄取了图像特征和实体标签的多个来源。 我们证明，我们可以学习控制这些实体标签在输出caption中的出现，从而产生既流畅又有信息的caption。</p><ol><li>一个多编码器模型结构，并与一个多门 (multi gate) 解码器配对，将基于图像的信息与细粒度的实体信息结合起来，使我们能够生成实体丰富的标题 </li><li>一个覆盖率控制机制，使我们能够学习如何在生成的标题中控制细粒度实体的出现。</li></ol><h2 id="3-新颖性"><a href="#3-新颖性" class="headerlink" title="3. 新颖性"></a>3. 新颖性</h2><p>在数据准备和模型方面都是新颖的。 对于数据，我们在网络规模层面进行操作，使用 Conceptual Captions（330万张图片）的细粒度注释。 对于模型，我们设计了一个框架，它扩展了Transformer网络并允许对多种多模态输入信号进行原则性的整合。 </p><h2 id="4-Data-Preparation"><a href="#4-Data-Preparation" class="headerlink" title="4. Data Preparation"></a>4. Data Preparation</h2><p>这一阶段的目标是获得标注数据，其中包含（i）实体信息丰富的caption（ii）使用细粒度的标签检测器对每张图片的相关实体进行检测。 本文在 Conceptual Captions数据集上进行构造。</p><p>在<strong>原始的</strong> Conceptual Captions 数据集中，将Alt-text中细粒度的实体替换为相应的超关键词（例如，”Los Angeles “被替换为 “city”）来获得 GT caption。 虽然这使得caption更容易被学习，但却导致了严重的信息损失。 </p><p>为了实现上述目标（i），我们重新处理了 Conceptual Captions 中的URLs，并将混合词重新映射到其相应的细粒度实体（例如，将 “城市 “映射到 “洛杉矶”），使用周围的文本作为锚。</p><h3 id="4-1-Fine-grained-Image-Labels"><a href="#4-1-Fine-grained-Image-Labels" class="headerlink" title="4.1 Fine-grained Image Labels"></a>4.1 Fine-grained Image Labels</h3><p>为了实现上述目标(ii)，我们采用预训练的模型从输入图像中提取 (1)<strong>物体检测标签</strong>和 (2)使用谷歌云视觉API获取<strong>网络实体标签</strong>。</p><p>物体标签指的是细粒度的普通物体（例如，”桉树 “和 “轿车”）。 另一方面，网络实体标签是指细粒度的命名实体（例如，”洛杉矶 “和 “丰田”）。 除了图像像素外，这些标签也是输入，在训练过程中，模型需要学习这些标签和GT caption 中相应的细粒度实体之间的映射。</p><h3 id="4-2-Selective-Hypernym-Substitution"><a href="#4-2-Selective-Hypernym-Substitution" class="headerlink" title="4.2 Selective Hypernym Substitution"></a>4.2 Selective Hypernym Substitution</h3><p>blabla， 看原文吧，其实即便不看，也不是很影响对论文的理解。</p><h2 id="5-Model"><a href="#5-Model" class="headerlink" title="5. Model"></a>5. Model</h2><h3 id="5-1-Multi-Encoder-Transformer"><a href="#5-1-Multi-Encoder-Transformer" class="headerlink" title="5.1 Multi-Encoder Transformer"></a>5.1 Multi-Encoder Transformer</h3><p>我们引入了一个 multi-encoder extension to Transformer Networks，用于处理我们的多模态输入。 图像特征、对象标签和网络实体标签 (下图). Transformer编码器中的自我注意层有助于在其他标签的文本中学习标签表征。</p><p><img src="https://i.loli.net/2021/07/22/6p4sm2GLocdYjDV.png" alt="image-20210722183719980" style="zoom: 67%;"></p><p>网络结构中，分别为 image, object label, Web Entity Label, 使用 transformer 作为encoder.</p><h3 id="5-2-Multi-gated-Transformer-Decoder"><a href="#5-2-Multi-gated-Transformer-Decoder" class="headerlink" title="5.2 Multi-gated Transformer Decoder"></a>5.2 Multi-gated Transformer Decoder</h3><p>为了适应输入端的 multi-encoder 架构，我们提出了对Transformer decoder 的多门 (multi-gated) 扩展。 像往常一样，这个解码器是一个由K个相同层组成的堆栈，其中每个层有3个子层。 一个自我注意层，一个编码器注意层，和一个全连接前馈层。 在3个子层中，我们通过引入一种机制，将来自不同编码器的信息结合起来，对编码器-注意力子层进行修改。</p><p>yaya: 没啥，就是设计了一个 gate, 来分配给每个输入源的权重。</p><h3 id="5-3-Label-Coverage-Control"><a href="#5-3-Label-Coverage-Control" class="headerlink" title="5.3 Label Coverage Control"></a>5.3 Label Coverage Control</h3><p>由于图像输入和标签输入之间的不对称性，我们引入了一个机制来控制所提供的物体标签和网络实体标签在生成的caption中的覆盖率。 该机制由两部分组成。 (i) 两个回归器模型，学习将输入标签（一个用于object，一个用于网络实体）与输出内容相关联的覆盖分数，以及(ii) 两个控制 “旋钮”，允许我们在推理时指定所需的覆盖分数。 这种覆盖率控制机制受到 Label-Fine Tuning 模型 的启发，尽管它在这里被用来实现不同的目标。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-当前存在的问题&quot;&gt;&lt;a href=&quot;#1-当前存在的问题&quot; class=&quot;headerlink&quot; title=&quot;1. 当前存在的问题&quot;&gt;&lt;/a&gt;1. 当前存在的问题&lt;/h2&gt;&lt;p&gt;一个图像caption应该流畅地呈现出给定图像中的重要信息，包括信息丰富的、细粒
      
    
    </summary>
    
      <category term="图像描述" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E6%8F%8F%E8%BF%B0/"/>
    
    
      <category term="图像描述" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E6%8F%8F%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>Show, Edit and Tell : A Framework for Editing Image Captions</title>
    <link href="http://yoursite.com/2021/07/22/Show-Edit-and-Tell-A-Framework-for-Editing-Image-Captions/"/>
    <id>http://yoursite.com/2021/07/22/Show-Edit-and-Tell-A-Framework-for-Editing-Image-Captions/</id>
    <published>2021-07-22T02:29:15.000Z</published>
    <updated>2021-07-22T08:59:46.311Z</updated>
    
    <content type="html"><![CDATA[<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><ul><li><p>本文的范式与以往的captioning model 是不同的，以往的结构通常是输入image representation，然后转化为中间向量，进而生成预测的句子。但是本文是输入 image 和一个 existing caption, 然后根据图像信息对该existing caption 进行编辑（在每一步对caption 中的单词分配权重，然后选择权重最大的那一个，然后根据一个gate,来选择是直接复制，还是根据图片信息进行生成）。</p></li><li><p>那么问题来了，这个 existing caption是从哪里来的？？文章中说是，使用一个训练好的captioning  model( AoANet) 来生成的。其实它是基于一个base captioning model的。</p></li></ul><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>大多数图像字幕框架直接从图像生成字幕，学习从视觉特征到自然语言的映射。但是，编辑现有字幕可能比从头开始生成新字幕更容易。直观地说，当编辑字幕时，模型不需要学习已经存在于字幕中的信息(即句子结构)，从而使其能够专注于固定细节(例如，替换重复的单词)。我们提出了一种基于对现有字幕的迭代适应性改进而不是从头开始生成字幕的新的图像字幕方法。具体地说，我们的字幕编辑模型由两个子模块组成：(1)EditNet，具有自适应复制机制(Copy-LSTM)和选择性复制记忆注意机制(SCMA)的语言模块；(2)DCNet，基于LSTM的去噪自动编码器。这些组件使我们的模型能够直接复制和修改现有字幕。实验表明，无论有无序列级训练，我们的新方法在MS Coco数据集上都取得了最好的性能。</p><h2 id="2-本文的模型如何编辑现有的图像标题？"><a href="#2-本文的模型如何编辑现有的图像标题？" class="headerlink" title="2. 本文的模型如何编辑现有的图像标题？"></a>2. 本文的模型如何编辑现有的图像标题？</h2><p>在字幕编辑过程的每个解码步骤中，都会从正在编辑的字幕中选择一个词，并将其相应的内存状态复制到LSTM的内部结构中（Copy-LSTM）。 这个Copy-LSTM包括一个单独的 selective copy attention mechanism (SCMA)，使它能够进一步编辑或复制现有的词到最终输出的caption。 </p><p><img src="https://i.loli.net/2021/07/22/RxUYkEIDNiwgzAu.png" alt="image-20210722103740692"></p><p>我们的字幕编辑模型由两个子模块组成：(1)EditNet， (2)DCNet.</p><h3 id="2-1-EditNet"><a href="#2-1-EditNet" class="headerlink" title="2.1 EditNet"></a>2.1 EditNet</h3><p>EditNet 存在两个模块，(1) a Selective Memory Attention Mechanism (SCMA) and (2) a Copy- LSTM decoder.</p><p>在每个解码步骤中，都会生成注意权重（图中的 $\alpha_{p}$​），这些权重对应于现有标题中每个单词的重要性。采用选择性复制记忆注意(SCMA)机制，我们选择概率最高的单词，并直接将其相应的LSTM内存状态复制到我们的语言Copy-LSTM中。也就是说，我们不是学习直接从输入标题中复制单词，而是学习是否复制与这些单词对应的记忆状态（图中Caption Encoder的 $c^{e}_{t}$）。</p><p>EditNet及其解码器（中间）表示，现有的标题首先使用单向LSTM编码，其中每个LSTM单元输出一个单词表示（h代表隐藏状态，c代表内存状态）。隐藏状态用于计算注意力权重，然后将其与内存状态一起传递给SCMA机制。SCMA选择单个内存状态并直接将其复制到Copy-LSTM中。<br>文本注意向量被门控删除不正确的词，然后作为输入传递到copy-LSTM以及视觉注意向量， EditNet配备了一个基于LSTM的降噪自动编码器，将现有字幕作为输入，并将其编码为压缩后的表示形式，然后将压缩的表示形式解码为其预期的输出。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;yaya&quot;&gt;&lt;a href=&quot;#yaya&quot; class=&quot;headerlink&quot; title=&quot;yaya&quot;&gt;&lt;/a&gt;yaya&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;本文的范式与以往的captioning model 是不同的，以往的结构通常是输入image repres
      
    
    </summary>
    
      <category term="图像描述" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E6%8F%8F%E8%BF%B0/"/>
    
    
      <category term="图像描述" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E6%8F%8F%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>Align before Fuse Vision and Language Representation Learning with Momentum Distillation</title>
    <link href="http://yoursite.com/2021/07/20/Align-before-Fuse-Vision-and-Language-Representation-Learning-with-Momentum-Distillation/"/>
    <id>http://yoursite.com/2021/07/20/Align-before-Fuse-Vision-and-Language-Representation-Learning-with-Momentum-Distillation/</id>
    <published>2021-07-20T11:51:49.000Z</published>
    <updated>2021-07-20T11:52:26.853Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="cross-modal" scheme="http://yoursite.com/categories/cross-modal/"/>
    
    
      <category term="cross-modal" scheme="http://yoursite.com/tags/cross-modal/"/>
    
  </entry>
  
  <entry>
    <title>Learning Semantic Concepts and Temporal Alignment for Narrated Video Procedural Captioning</title>
    <link href="http://yoursite.com/2021/07/19/Learning-Semantic-Concepts-and-Temporal-Alignment-for-Narrated-Video-Procedural-Captioning/"/>
    <id>http://yoursite.com/2021/07/19/Learning-Semantic-Concepts-and-Temporal-Alignment-for-Narrated-Video-Procedural-Captioning/</id>
    <published>2021-07-19T09:11:55.000Z</published>
    <updated>2021-07-19T09:40:53.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>以前的工作采用端到端网络从 low-level 视觉特征中学习并生成描述性的caption，这<font color="red">很难识别细粒度的物体</font>font&gt;，也<font color="red">缺乏对关键语义概念的理解</font>。 根据DPC[1]，这些概念一般出现在教学视频的narrative transcripts 中， 结合narrative transcripts和视频可以提高字幕的性能。 然而，DPC直接将 transcripts的嵌入与视频特征 concatenate 起来，这无法有效融合语言和视觉特征，并导致 transcripts和视频之间的时间错位。 这促使我们：1）显式地学习语义概念；2）设计一个时间对齐机制，以更好地对齐视频和 transcripts。 </p><h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><p><img src="https://i.loli.net/2021/07/19/BoXxSdegc2AmzRG.png" alt="image-20210719172021471" style="zoom:67%;"></p><p>首先，我们设计了一个 semantic concept prediction module，作为一个多任务，以监督的方式训练 encoder。 </p><p>然后，我们开发了一种基于注意力的跨模态时间对齐方法，该方法结合了连续的视频帧和 transcripts 句子。 </p><p>最后，我们采用了一个拷贝机制，使 decoder 能够直接从 transcripts 中拷贝重要概念。</p><h2 id="Semantic-Concept-Prediction"><a href="#Semantic-Concept-Prediction" class="headerlink" title="Semantic Concept Prediction"></a>Semantic Concept Prediction</h2><p>本文显式地学习一个语义概念预测期，通过从 GT captions 中提取到的语义概念作为监督信号。</p><p>通过迫使模型准确地生成目标语义概念，来训练更好的 encoder 。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] Botian et al. 2019. Dense Procedure Captioning in Narrated Instructional Videos. In ACL. 6382–6391.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;存在的问题&quot;&gt;&lt;a href=&quot;#存在的问题&quot; class=&quot;headerlink&quot; title=&quot;存在的问题&quot;&gt;&lt;/a&gt;存在的问题&lt;/h2&gt;&lt;p&gt;以前的工作采用端到端网络从 low-level 视觉特征中学习并生成描述性的caption，这&lt;font color
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Bridging the Gap between Vision and Language Domains for Improved Image Captioning</title>
    <link href="http://yoursite.com/2021/07/18/Bridging-the-Gap-between-Vision-and-Language-Domains-for-Improved-Image-Captioning/"/>
    <id>http://yoursite.com/2021/07/18/Bridging-the-Gap-between-Vision-and-Language-Domains-for-Improved-Image-Captioning/</id>
    <published>2021-07-18T11:34:19.000Z</published>
    <updated>2021-07-19T06:54:35.519Z</updated>
    
    <content type="html"><![CDATA[<p>本文认为视频描述模型分两步：</p><p> 1) first link the image modality to the text modality.</p><p>2) generate a semantically and grammatically correct descriptive sentence based on such textual guided visual information.</p><p>但是 目前的captioning models将这两步都融合在一个模块中，即decoder。由于视觉和语言领域之间的巨大差异，这类模型中的解码器必须将其大部分能力用于执行步骤1），从而分散注意力，无法高质量地完成步骤2）。</p><p>因此，本文conduct the step 1) in the encoder by enriching image features with textual concepts. Specifically, we provide complete semantics information for the image features. In implementations, our approach consists of a Textual Distilling Module (TDM) and a Textual Association Module (TAM).</p><p>The TDM focuses on distilling textual concepts to the corresponding visual objects. Since the textual concepts are single words and only represent a fraction of a semantics, we further introduce the TAM to group related concepts to form a complete semantics. For instance, we group three separated concepts “woman”, “tennis” and “playing” into a phrase “woman playing tennis”. </p><blockquote><p>yaya: 所以<font color="blue"><strong>其实TAM的提出完全是因为TDM存在不足</strong></font>。这恰恰也是本文的缺陷。因为即便TAM把相关的概念组合到一起，也存在失误的问题，毕竟没有显式的监督。</p></blockquote><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p><img src="https://i.loli.net/2021/07/19/MygTjfGBRxeCt9W.png" alt="image-20210719123527662"></p><h4 id="Image-Encoder-and-Concept-Extractor"><a href="#Image-Encoder-and-Concept-Extractor" class="headerlink" title="Image Encoder and Concept Extractor"></a>Image Encoder and Concept Extractor</h4><p>对于图像特征，使用在VIsual-Genome上预训练的 Region-CNN model （Bottom-Up and Top-Down）.</p><p>对于 textual concepts, 使用 弱监督多示例学习方法： From Captions to Visual Concepts and Back。具体而言，是在MS-COCO caption 数据集上的1000个视觉概念上训练的。提取的视觉概念包括 objects, attributes, 和 relationships。对于每张图片，提取20个文本概念， 集合 $T=\left\{w_{1}, w_{2}, \ldots, w_{m}\right\} \in \mathbb{R}^{m \times e}$ where $w_{i} \in \mathbb{R}^{e}$ refers to the embedding of the $i^{t h}$ concept.</p><h3 id="Textual-Distilling-Module"><a href="#Textual-Distilling-Module" class="headerlink" title="Textual Distilling Module"></a>Textual Distilling Module</h3><p>使用注意力机制来选择与图像最相关的 top-K 文本概念。</p><blockquote><p>yaya: 其实没有必要，毕竟上一步提取到的textual concepts 就是与该图像最相关的内容。而且说是叫蒸馏，也没有任何蒸馏的操作!!!</p></blockquote><h3 id><a href="#" class="headerlink" title=" "></a> </h3><h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><p>整体比较水，但是写作水平比较好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文认为视频描述模型分两步：&lt;/p&gt;
&lt;p&gt; 1) first link the image modality to the text modality.&lt;/p&gt;
&lt;p&gt;2) generate a semantically and grammatically correct
      
    
    </summary>
    
      <category term="视频描述" scheme="http://yoursite.com/categories/%E8%A7%86%E9%A2%91%E6%8F%8F%E8%BF%B0/"/>
    
    
      <category term="视频描述" scheme="http://yoursite.com/tags/%E8%A7%86%E9%A2%91%E6%8F%8F%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>Show, Control and Tell: A Framework for Generating Controllable and Grounded Captions</title>
    <link href="http://yoursite.com/2021/07/16/Show-Control-and-Tell-A-Framework-for-Generating-Controllable-and-Grounded-Captions/"/>
    <id>http://yoursite.com/2021/07/16/Show-Control-and-Tell-A-Framework-for-Generating-Controllable-and-Grounded-Captions/</id>
    <published>2021-07-16T02:07:16.000Z</published>
    <updated>2021-07-16T04:18:57.475Z</updated>
    
    <content type="html"><![CDATA[<p>来源：<a href="https://zhuanlan.zhihu.com/p/150667499" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/150667499</a></p><p>这是一篇收录于CVPR2019的图像描述生成文章，该文章提出了一种可以通过外部信号（图像区域）进行控制的图像描述生成模型，并且在可控描述质量与多样性两方面达到了Flickr30k Entities与COCO Entities数据集上的SOTA。作者声称，这是他们所知道的第一个可以基于图像区域进行控制的图像描述生成模型。</p><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>在对一张图像进行描述时，<strong>由于描述者的目标不同、关注的区域不同，进行描述的方式与角度也不尽相同</strong>。在对复杂的场景进行描述时，常常需要对模型进行控制，使模型更加关注于使用者感兴趣的区域，而现有的模型在生成图像描述时通常处于黑箱的状态，缺乏可控性与可解释性。</p><p>这篇文章提出了一种可控的图片描述生成模型，可以通过外界的控制信号操控模型生成多样化的描述。具体地，<strong>模型将图像中的一组区域作为控制信号</strong>，并生成基于这些区域的图像描述。如下图所示：</p><p><img src="https://i.loli.net/2021/07/16/aJeySqRXlhZCBNr.png" alt="image-20210716101209297" style="zoom:80%;"></p><p>上图中的（a）表示原始的图像描述生成模型，该模型将整张图像的特征作为输入，并得到基于图像整体的描述；（b）表示Up-Down模型生成描述的过程，该模型通过Faster R-CNN检测出一些目标区域，并综合这些目标区域的特征生成描述；（c）表示本文模型生成描述的过程，<strong>给定一个区域序列（或集合），模型会基于这些<font color="red">区域的特征</font>与<font color="red">顺序</font>生成描述，而忽略其他区域的特征，从而实现可控的图像描述</strong>。</p><p><img src="https://i.loli.net/2021/07/16/ANkfqLd3vpGQTRX.png" alt="image-20210716101331736" style="zoom: 67%;"></p><p>上图是将无序的区域集合作为控制信号时，模型的描述效果，图中的方框表示作为控制信号的区域。可以看到，控制信号中的物体都准确地出现在了描述中，而不在控制信号中的物体则没有出现。</p><p><img src="https://i.loli.net/2021/07/16/63CENAQTO5w9vhg.png" alt="image-20210716101547116"></p><p>上图是将有序的集合序列作为控制信号时模型的效果，可以看到描述中的名词块顺序与控制信号中的顺序一致。</p><h2 id="二、方法"><a href="#二、方法" class="headerlink" title="二、方法"></a>二、方法</h2><p><img src="https://i.loli.net/2021/07/16/4a6jA7cxRDlqo8k.png" alt="image-20210716101714728" style="zoom:67%;"></p><p>我们可以将图像描述中的单词分为两种：第一种是视觉词（visual words），表示对应于图中某个视觉实体的单词，如图中的boy、cap、shirt等；第二种是文本词（textual words），表示在图中没有对应实体的单词，如图中的a、with、on等。</p><p>进一步地，句中的每个名词可以与它的修饰语组成一个“名词块”（noun chunk），比如上文中的“a young boy”、“gray sweat jacket”等。这些名词块类似视觉词，通常与图像中的特定区域相对应，某些情况下，一个名词块也可能会与多个图像区域相对应。</p><p>每条描述由一系列的名词块连接而成，因此也对应着图像中的一组区域。只要改变生成描述时所考虑的图像区域或描述区域的顺序，便可以生成不同的图像描述。</p><p>基于上述假设，本文将图像中的一组区域作为控制信号输入模型中，使模型根据控制信号逐个生成名词块，并将名词块拼接成完整的句子，从而生成可控的、多样的图像描述。</p><p><img src="https://i.loli.net/2021/07/16/fCqmM3vZonAdbOu.png" alt="image-20210716101935615"></p><p>具体模型如上图所示，该模型的主要结构有：</p><p>1.Language model，由两层LSTM组成的语言模型，在每个时间点基于当前区域的特征与当前状态生成下一时刻的单词；</p><p>2.Chunk shifting gate，用于决定何时切换到下一个图像区域；</p><p>3.Adaptive attention，用于决定将要生成的单词是视觉词（基于视觉信息生成）还是文本词（基于当前的语句信息生成）；</p><p>4.Sorting network，在输入的控制信号为区域集合（无序）时，使用sorting network对控制信号进行排序。</p><p><strong>Language Model</strong></p><p><img src="https://i.loli.net/2021/07/16/vGzUDmCHS4qZt2f.png" alt="image-20210716102126047" style="zoom:50%;"></p><p>本文使用了双层LSTM结合attention作为语言模型。</p><p>第一层LSTM主要用于计算attention，给定上一时刻输出的单词向量 $y_{t-1}$ 、图像的总体特 征 $I$ 、上一时刻第二层LSTM的隐藏状态 $h_{t-1}^{2}$ 作为输入，第一层LSTM的输出结果用于计 算Adaptive Attention以及Chunk Shifting Gate, 决定下一步生成视觉词还是文本词, 以 及决定是否切换到下一个图像区域;<br>第二层LSTM主要作为language model，接受第一层的隐藏状态 $h_{t}^{1}$ 以及经过Adaptive Attention的上下文特征 $c_{t}$ 作为输入，预测下一个单词。<br>注意，本文通过对控制信号中所有区域的特征向量进行mean-pooling，将得到的结果作为 图像的总体特征 $I$ 。</p><p><strong>Chunk Shifting Gate</strong></p><p>Chunk Shifting Gate是一个布尔类型的门控变量，使用它更新当前区域的规则如下：</p><p>$\boldsymbol{r}_{t+1} \leftarrow \boldsymbol{R}[i], \quad$ where $i=\min \left(\sum_{k=1}^{t} g_{k}, N\right), g_{k} \in\{0,1\}$</p><p>上式中R表示由图像区域组成的有序序列，需要注意的是，由于每个名词块可能是基于多个 图像区域产生的，因此R中的每个元素都是一个区域集合，集合中通常只有一个区域，在集 合中包含多个区域的情况下，名词块便会综合这些区域的信息而产生。<br>上式中的 $r_{t+1}$ 表示在t+1时刻所考虑的区域集合, $\mathrm{N}$ 表示R中的区域集合数量。对于每个区 域, 作者使用Resnet-101提取区域中的特征, 并使用特征向量表示这个区域，因此控制信号 也可以视作由一组区域的特征向量组成。<br>可以看到，在每个时刻，如果该时刻的门控变量 $g_{t}$ 为 1, 则将 $r_{t+1}$ 更新为R中的下一个区 域集合，否则不更新。<br>门控变量 $g_{t}$ 的具体计算方法如下。在每个时间点，基于第一层LSTM的状态设立一个chunk sentinel, 记作 $s_{c}^{t}$, chunk sentinel可以表示在每个chunk结尾处LSTM的状态。</p><script type="math/tex; mode=display">\begin{aligned}&l_{t}^{c}=\sigma\left(\boldsymbol{W}_{i g} \boldsymbol{x}_{t}+\boldsymbol{W}_{h g} \boldsymbol{h}_{t-1}\right) \\&\boldsymbol{s}_{t}^{c}=l_{t}^{c} \odot \tanh \left(\boldsymbol{m}_{t}\right)\end{aligned}</script><p>其中 $m_{t}$ 表示LSTM的cel|状态, $h_{t-1}$ 表示上一时刻 $\mathrm{STM}$ 的隐藏状态。随后, 模型基于 $s_{c}^{t}$ 与区域特征 $r_{t} ，$ 计算 $g_{t}$ 的概率分布:</p><script type="math/tex; mode=display">\begin{gathered}z_{t}^{c}=\boldsymbol{w}_{h}^{T} \tanh \left(\boldsymbol{W}_{s g} \boldsymbol{s}_{t}^{c}+\boldsymbol{W}_{g} \boldsymbol{h}_{t}\right) \\\boldsymbol{z}_{t}^{r}=\boldsymbol{w}_{h}^{T} \tanh \left(\boldsymbol{W}_{s r} \boldsymbol{r}_{t}+\left(\boldsymbol{W}_{g} \boldsymbol{h}_{t}\right) \mathbb{1}^{T}\right)\end{gathered}</script><script type="math/tex; mode=display">p\left(g_{t}=1 \mid \boldsymbol{R}\right)=\frac{\exp z_{t}^{c}}{\exp z_{t}^{c}+\sum_{i=1}^{n} \exp z_{t i}^{r}}</script><p>计算过程类似于计算 $h_{t}$ 与 [ $\left.s_{t}^{c} ; r_{t}\right]$ 的attention，当模型更加注意 $s_{t}^{c}$ 时, $g_{t}=1$ 的概率 更大， 因此模型有更大的概率切换到下一个区域; 当模型更加注意 $r_{t}$ 时，模型则更有可能 停留在当前的区域。借助Chunk Shifting Gate，模型便可以决定何时切换关注的区域, 并 按照顺序生成这些区域对应的名词块。</p><p><strong>Adaptive Attention</strong></p><p>在生成单词时，为了判断当前单词究竟是基于视觉信息的视觉词还是基于当前语句信息的文本词，本文引入了Adaptive Attention机制。Adaptive Attention的计算方式如下，首先设立一个visual sentinel（类似上文的chunk sentinel）：</p><script type="math/tex; mode=display">\begin{aligned}l_{t}^{v} &=\sigma\left(\boldsymbol{W}_{i s} \boldsymbol{x}_{t}+\boldsymbol{W}_{h s} \boldsymbol{h}_{t-1}\right) \\\boldsymbol{s}_{t}^{v} &=\boldsymbol{l}_{t}^{v} \odot \tanh \left(\boldsymbol{m}_{t}\right)\end{aligned}</script><p>随后, 计算 $h_{t}$ 对 $\left[r_{t} ; s_{t}^{v}\right.$ ]的attention:</p><script type="math/tex; mode=display">\begin{gathered}\boldsymbol{z}_{t}^{r}=\boldsymbol{w}_{h}^{T} \tanh \left(\boldsymbol{W}_{s r} \boldsymbol{r}_{t}+\left(\boldsymbol{W}_{g} \boldsymbol{h}_{t}\right) \mathbb{1}^{T}\right) \\\boldsymbol{\alpha}_{t}=\operatorname{softmax}\left(\left[\boldsymbol{z}_{t}^{r} ; \boldsymbol{w}_{h}^{T} \tanh \left(\boldsymbol{W}_{s s} \boldsymbol{s}_{t}^{v}+\boldsymbol{W}_{g} \boldsymbol{h}_{t}\right)\right]\right)\end{gathered}</script><p>基于attention的结果, 可以计算出当前时刻模型正在关注的上下文特征 $c_{t}:$</p><script type="math/tex; mode=display">\boldsymbol{c}_{t}=\sum_{i=1}^{n+1} \boldsymbol{\alpha}_{t i}\left[\boldsymbol{r}_{t} ; \boldsymbol{s}_{t}^{v}\right]</script><p>在大多数时候, 模型只会关注 $s_{t}^{v}$ 或 $r_{t}$ 所包含的区域中的一个，如果模型更加关注visual sentinel, 便会生成textual word; 反之, 便会生成基于 $r_{t}$ 中某个区域的的visual word.</p><p><strong>Sorting Network</strong></p><p>上述讨论的前提是控制信号R是一组有序的图像区域序列，模型可以按照区域在R中的顺序生成相应的文本。如果给定的控制信号是无序的，如何使模型按照合适的顺序生成文本？本文使用了一种sorting network对无序的控制信号进行排序，实现方法如下。</p><p>假设无序的集合R中包含N个区域集，首先使用全连接层将每个区域集的特征映射为N维向量，随后将所有特征向量拼接，得到N*N的特征矩阵；随后使用Sinkhorn算子迭代地处理特征矩阵，经过该算子可以得到一个类似置换矩阵的“软”置换矩阵，它与置换矩阵的主要区别在于置换矩阵是离散的，而它是连续的。</p><p>在训练时，作者通过最小化该置换与真实结果之间的均方误差来训练网络；在测试时，则使用匈牙利算法进行匹配，将“软”置换矩阵转化为最终的置换，以此来对R进行排序。</p><h2 id="三、训练"><a href="#三、训练" class="headerlink" title="三、训练"></a>三、训练</h2><p>由于模型需要同时预测两个分布, $-$ 个是 $p\left(y_{t} \mid R\right) ，$ 表示寺刻生成单词的概率分布; 另一 个是 $p\left(g_{t} \mid R\right) ，$ 表示t时刻chunk shifting gate的概率分布。为了同时训练两个分布, 模型 训练时的loss function如下:</p><script type="math/tex; mode=display">\begin{aligned}L(\theta) &=-\sum_{t=1}^{T}(\log \overbrace{p\left(y_{t}^{*} \mid \boldsymbol{r}_{1: t}^{*}, \boldsymbol{y}_{1: t-1}^{*}\right)}^{\text {Word-level probability }}+\\&+g_{t}^{*} \log p\left(g_{t}=1 \mid \boldsymbol{r}_{1: t}^{*}, \boldsymbol{y}_{1: t-1}^{*}\right)+\\&+\left(1-g_{t}^{*}\right)(1-\log \underbrace{p\left(g_{t}=1 \mid \boldsymbol{r}_{1: t}^{*}, \boldsymbol{y}_{1: t-1}^{*}\right)}_{\text {Chunk-level probability }})\end{aligned}</script><p>其中 $y_{1: t}^{<em>}, g_{1: t}^{</em>} \quad r_{1: t}^{*}$ 为ground truth。除了使用cross entropy作为损失函数，本文 还使用了强化学习对模型进行优化，并使用如下表达式计算损失函数的梯度：</p><script type="math/tex; mode=display">\nabla_{\theta} L(\theta)=-\left(r\left(\boldsymbol{w}^{s}\right)-b\right)\left(\nabla_{\theta} \log p\left(\boldsymbol{w}^{s}\right)+\nabla_{\theta} \log p\left(\boldsymbol{g}^{s}\right)\right)</script><p>其中 $w^{s}$ 与 $g^{s}$ 表示模型预测得到的句子与chunk shifting gate序列, $r\left(w^{s}\right)$ 表示对于 $w^{s}$ 的奖励, 而b表示奖励的baseline, 只有超过baseline才能获得奖励。此处b $=r\left(w^{\prime}\right)$, $w^{\prime}$ 表示模型使用贪心策略生成的句子。<br>除了提高描述的质量，本文模型还需要保证描述的可控性，因此除了衡量描述质量的指标 CIDEr, 本文还提出了另一种指标NW，用于衡量模型生成的语句与控制信号的对齐程度，并 将CIDEr与NW同时作为强化学习时的奖励。NW的计算方式如下。<br>对于模型生成的句子y与数据集中与之对应的句子 $\mathrm{y}^{\star}$, 首先将所有名词从两个句子中提取出 来，随后将这些名词对齐。 对于相匹配的两个名词，将它们的embedding向量夹角的cos值 作为匹配分数; 如果存在未匹配的名词，则将匹配分数记作-1。将所有匹配分数加和后，使 用两个句子中较多的名次数对分数做归一化, 公式如下:</p><script type="math/tex; mode=display">\mathrm{NW}\left(\boldsymbol{y}, \boldsymbol{y}^{*}\right)=\frac{a l\left(\boldsymbol{y}, \boldsymbol{y}^{*}\right)}{\max \left(\# \boldsymbol{y}, \# \boldsymbol{y}^{*}\right)}</script><p>在所有的名词对齐中，挑选最高的NW分数作为最终的NW分数。</p><h2 id="四、评估"><a href="#四、评估" class="headerlink" title="四、评估"></a>四、评估</h2><h3 id="4-1-数据集"><a href="#4-1-数据集" class="headerlink" title="4.1 数据集"></a>4.1 <strong>数据集</strong></h3><p>本文在两个数据集上进行评估，分别是Flickr30k Entities与COCO Entities。其中，Flickr30k是图像描述生成工作中常用的数据集，Flickr30k Entities是它的扩展数据集。对于每条描述，Flickr30k Entities挑选出其中的所有名词块，并使用bounding box标注出图像中的对应物体。如下图所示：</p><p><img src="https://i.loli.net/2021/07/16/6KAp8l9vDuWnMba.jpg" alt="img"></p><p>MSCOCO是图像描述生成工作的常用数据集，COCO Entities是MSCOCO数据集的扩展，由本文作者提出。对于MSCOCO中的每条描述，作者将其中的每个名词与5个相似度最高的物体类别关联到一起（使用词向量的相似度）；随后使用目标检测器检测图片中的目标，如果检测到的目标类别与名词类别匹配，便将名词与目标区域相关联；最后，人工检查每个关联是否正确。下图是COCO Entities数据集中的一个例子：</p><p><img src="https://i.loli.net/2021/07/16/HukQ4vXIm291sWS.jpg" alt="img"></p><h3 id="4-2-评估指标"><a href="#4-2-评估指标" class="headerlink" title="4.2 评估指标"></a>4.2 <strong>评估指标</strong></h3><p>文章的评估方法与常规的image captioning评估有所区别。在评估时，除了将图像作为输入外，作者还将图像中的一系列区域作为控制信号输入；相应地，在评估生成描述的质量时，在数据集中只有控制信号与其相同的句子会作为衡量标准。</p><p>关于评估指标的选取，除了常用的BLUE-4、METEOR、ROUGE、CIDEr、SPICE外，在使用区域序列作为控制信号时，作者还使用了上文提到的NW分数来评估生成描述中的名词块与控制信号的对齐效果；而在使用区域集合作为控制信号时，为了评估生成的描述对控制信号的覆盖效果，作者还提出了一种类似交并比(IoU)的评测指标：</p><script type="math/tex; mode=display">\operatorname{IoU}\left(\boldsymbol{y}, \boldsymbol{y}^{*}\right)=\frac{\mathrm{I}\left(\boldsymbol{y}, \boldsymbol{y}^{*}\right)}{\# \boldsymbol{y}+\# \boldsymbol{y}^{*}-\mathrm{I}\left(\boldsymbol{y}, \boldsymbol{y}^{*}\right)}</script><p>其中, $I\left(y, y^{*}\right)$ 表示将两个句子中的名词对齐后，相应名词的词向量cos相似度之和。 $10 \mathrm{U}$ 越高, 两个句子中名词的重合率便越高。</p><h3 id="4-3-Baselines"><a href="#4-3-Baselines" class="headerlink" title="4.3 Baselines"></a>4.3 <strong>Baselines</strong></h3><p><strong>1.Controllable LSTM</strong></p><p>在Controllable LSTM中，作者使用一个没有attention的、单层的LSTM作为语言模型。随后，作者将控制信号序列R中的特征输入到另一个LSTM中，并提取这个LSTM最终的隐藏状态，将该隐藏状态与图像特征进行拼接，输入到LSTM语言模型中，以此实现控制效果。</p><p><strong>2.Controllable Up-Down</strong></p><p>Up-Down模型是一种比较具有代表性的图像描述生成模型，它通过目标检测器检测出图像中的物体，并基于这些物体所在的图像区域生成描述。作者实现Controllable Up-Down的方式比较简单，将控制信号R中的区域输入到Up-Down模型中，并忽略图像中的其他区域即可。当然，由于Up-Down模型中对于不同区域的关注是无序的，因此Controllable Up-Down并不能按照给定的区域顺序生成描述。</p><p><strong>3.Ours without visual sentinel</strong></p><p>为了验证visual sentinel的重要性，作者提出了没有visual sentinel的模型，此时模型缺乏识别visual word与textual word的能力。</p><p><strong>4.Ours with single sentinel</strong></p><p>本文中visual sentinel与chunk sentinel的计算方式比较相似，为了验证它们的重要性，作者提出了将visual sentinel与chunk sentinel融合的模型，此时将有一个单独的sentinel同时充当二者的功能。</p><p><strong>5.Others</strong></p><p>本文还使用了几种不可控的模型作为对比，分别是FC-2K、Up-Down、Neural Baby Talk。需要注意的是，由于这几种模型无法接收控制信号所带来的额外信息，因此将本文模型与它们直接做对比是不公平的。</p><h3 id="4-4-定量评估"><a href="#4-4-定量评估" class="headerlink" title="4.4 定量评估"></a>4.4 <strong>定量评估</strong></h3><p>作者从三个角度评估模型的效果，分别是在有序控制信号下的效果、无序控制信号下的效果以及描述生成的多样性。</p><p><img src="https://i.loli.net/2021/07/16/FWhJRBAcynQiafC.png" alt="image-20210716105025286"></p><center>在COCO Entities上的评估结果（有序控制信号）</center><p><img src="https://i.loli.net/2021/07/16/kONCgj7Z9iMpwJE.png" alt="image-20210716105151176" style="zoom:50%;"></p><center>在Flickr30k Entities上的评测结果（有序控制信号）</center><p>作者首先使用COCO Entities与Flickr30k Entities评估模型在有序控制信号下的效果。可以看到，本文的模型在所有指标上都达到了最好的效果，不过由于FC-2K、Up-Down、Neural Baby Talk模型本身是不可控的，而Controllable Up-Down模型虽然可控，但无法按照控制信号的顺序生成描述，因此<font color="red">本文模型与它们的比较并不公平</font>&gt;</p><p><img src="https://i.loli.net/2021/07/16/TgZWAOdFJzwexGc.png" alt="image-20210716105307222" style="zoom:50%;"></p><center>在COCO Entities上的评估结果（无序控制信号）</center><p><img src="https://i.loli.net/2021/07/16/tajQBzJMN1GViLW.png" alt="image-20210716105318174" style="zoom:50%;"></p><center>Flickr30k Entities上的评测结果（无序控制信号）</center><p>随后，作者又在两个数据集上评估了模型在无序控制信号下的效果，此时本文模型与Controllable Up-Down模型的对比是有意义的。可以发现，本文模型在绝大多数指标上都优于Controllable Up-Down。</p><p><img src="https://i.loli.net/2021/07/16/x5qd7ConpzR6haJ.png" alt="image-20210716105441980" style="zoom: 50%;"></p><center>在COCO Entities数据集上的多样性评估结果</center><p>作者在COCO Entities数据集上评测了模型生成描述的多样性，并与另外两个专注于提高描述多样性的模型作对比。在评估多样性时，作者将所有可行的区域都作为控制信号输入到模型中，以此保证生成多样的描述；在计算评估指标时，作者首先使用每个模型各自生成20条描述，对于数据集中的每条描述，将选择模型生成的描述中得分最高的一条进行评估，并对每个评估指标都进行如上操作。</p><p>经过上述操作，可以得到每个模型的20条描述对于每个指标的最高分，并将其作为最终的评估分数。模型能得到的最高分越高，说明模型有能力生成效果更好的描述，这也意味着模型的多样性更好。从评估结果中可以看到，在大多数指标中，本文的模型要明显好于其他两种模型。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>这篇文章提出了一种可控的图像描述生成模型。这种可控性体现在两方面：第一，给定图像中的一些区域，模型会基于这些区域生成描述，忽视其他的区域；第二，给定这些区域的顺序，模型会按照顺序生成描述。</p><p>在COCO Entities与Flickr30k Entities数据集上，作者评估了模型的可控描述生成质量，并在与其他模型的对比中得到了最佳效果（<font color="red"><strong>个人认为只有在无序控制信号时，与Controllable Up-Down模型的对比比较有意义</strong></font>）；此外，作者还评估了模型的多样性，并在与其他模型的对比中得到了较好的效果，说明该模型有能力生成更高质量的描述。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来源：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/150667499&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/150667499&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是一篇
      
    
    </summary>
    
      <category term="图像描述" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E6%8F%8F%E8%BF%B0/"/>
    
    
      <category term="图像描述" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E6%8F%8F%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>Multimodal Few-Shot Learning with Frozen Language Models</title>
    <link href="http://yoursite.com/2021/07/09/Multimodal-Few-Shot-Learning-with-Frozen-Language-Models/"/>
    <id>http://yoursite.com/2021/07/09/Multimodal-Few-Shot-Learning-with-Frozen-Language-Models/</id>
    <published>2021-07-09T04:06:20.000Z</published>
    <updated>2021-07-09T09:16:19.430Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>GTP-3, T5 给出的一些启发，在大规模数据上，以自回归的方式训练的语言模型和 prefix tunning 展示出了在<strong>小样本</strong>上学习<strong>新任务</strong>的能力。</p><p><strong><font color="red">本文中，我们展示出一个简单且有效的方法来迁移这种小样本学习能力到多模态的设置中（vision and language）。</font></strong> 本文中使用 image 替换纯语言模型中的前缀 prefix。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在这里，我们提出了Frozen，一种让预先训练好的语言模型获得视觉信息的方法，这种方法可以将它的小样本学习能力扩展到多模态环境中，而不改变其权重。 Frozen由一个经过训练的 <font color="red"><strong>神经网络 $\phi$​</strong> </font> 组成，将图像编码到一个<strong><font color="red">大型预训练语言模型 $\theta$ </font></strong>的单词嵌入空间中，这样语言模型就能为这些图像生成caption。 <strong>语言模型的权重保持不变</strong>，但梯度通过它进行反向传播, 从头开始训练图像编码器。</p><p><img src="https://i.loli.net/2021/07/09/oq9fuFkBjVCgm34.png" alt="image-20210709144031286" style="zoom:50%;"></p><font color="green">yaya: 由于预训练语言模型的预训练任务是自回归的生成式任务，因此，这里将其迁移到多模态任务时，也采用了image captioning 这种生成式任务。</font><p><img src="https://i.loli.net/2021/07/09/nDqWZCSiNExyjlk.png" alt="image-20210709144211177" style="zoom:50%;"></p><p>尽管Frozen是在单一的图像-文字对上训练的，但一旦训练好了，它就能对多个图像和文字的有序集合作出有效反应。 这使用户能够，例如 在评估其表现之前，用几个新的多模态任务的例子来 “提示 “它，或者在立即询问一个新的视觉类别之前 “教 “它这个类别的名称。</p><p>我们开发Frozen的目的不是为了在任何特定的任务上实现最大的性能，而且在许多情况下，它远远不是最先进的。 尽管如此，在没有看到这些基准所提供的少数训练实例的情况下，它在广泛的任务中的表现远远高于琐碎的基线。</p><p>总的来说，我们的贡献如下。 1. 我们提出了Frozen，一种模块化、可扩展和高效的方法，用于训练大型语言模型的视觉前端。 由此产生的组合模型保留了大型语言模型的所有能力，但也能以任意的顺序处理文本和图像输入。 2. 我们表明，这种模型将其快速适应任务的能力、百科全书式的知识和快速的概念结合从单纯的语言环境转移到了多模态环境中，并验证了用视觉和语言信息提示他们，严格来说比单纯用语言信息提示更有效。 3. 我们在一系列现有的和新的基准上对这些能力进行量化，为今后分析这些能力铺平道路。</p><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>使用 Conceptual Captions dataset 来训练。仅仅微调$\phi$, 不微调 $\theta$。因为我们可用的图文对相比于预训练 $\theta$ 时用到的数据是相当少的。</p><h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><p>没怎么看完，实验上，好像没有做image captioning 任务，比较奇怪。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Motivation&quot;&gt;&lt;a href=&quot;#Motivation&quot; class=&quot;headerlink&quot; title=&quot;Motivation&quot;&gt;&lt;/a&gt;Motivation&lt;/h2&gt;&lt;p&gt;GTP-3, T5 给出的一些启发，在大规模数据上，以自回归的方式训练的语言
      
    
    </summary>
    
      <category term="cross-modal" scheme="http://yoursite.com/categories/cross-modal/"/>
    
    
      <category term="cross-modal" scheme="http://yoursite.com/tags/cross-modal/"/>
    
  </entry>
  
  <entry>
    <title>LM-MLC 一种基于完型填空的多标签分类算法</title>
    <link href="http://yoursite.com/2021/07/08/LM-MLC-%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E5%AE%8C%E5%9E%8B%E5%A1%AB%E7%A9%BA%E7%9A%84%E5%A4%9A%E6%A0%87%E7%AD%BE%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2021/07/08/LM-MLC-一种基于完型填空的多标签分类算法/</id>
    <published>2021-07-08T08:07:41.000Z</published>
    <updated>2021-07-08T08:15:13.768Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<a href="https://mp.weixin.qq.com/s/1VnR1zQ4LWnUDl6USdxVhQ#" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/1VnR1zQ4LWnUDl6USdxVhQ#</a></p><p>同样一篇基于 PET， 模板的方式来做NLP任务的论文</p><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a><strong>1 前言</strong></h2><p>本文主要介绍本人在全球人工智能技术创新大赛【赛道一】设计的一种基于完型填空(模板)的多标签分类算法：LM-MLC，该算法拟合能力很强能感知标签关联性，在多个数据集上测试表明该算法与主流算法无显著性差异，在该比赛数据集上的dev效果很好，但是由于比赛期间事情多，没有好好在test集做测试。</p><p>个人认为该算法根正苗红，理论上可以获得更好的效果，因此做个开源，抛砖引玉，希望有人能提出更为有效的改进。本次开源的代码可读性较强，也有较高的扩展性，本人把LM-MLC可做的修改均写成超参形式，方便各位做测试。</p><p>Github：<a href="https://github.com/DunZhang/LM-MLC" target="_blank" rel="noopener">https://github.com/DunZhang/LM-MLC</a></p><h2 id="2-多标签分类任务"><a href="#2-多标签分类任务" class="headerlink" title="2 多标签分类任务"></a><strong>2 多标签分类任务</strong></h2><p>NLP里的多标签分类任务，输入多为一段文本，输出该文本的的标签。比如在新闻类型分类中，一篇新闻可以同时有”军事”、”政治”和”历史”三个标签，再举个例子，疾病分类中，一位患者可以既感冒又咳嗽。</p><p>多标签分类任务依据数据特点又可以划分为多种类型。</p><h3 id="2-1-文本长度"><a href="#2-1-文本长度" class="headerlink" title="2.1 文本长度"></a>2.1 文本长度</h3><p>文本长度会直接影响到算法的选择，长度过长对算法语义理解要求会变高，如果长度超过512个字符，就不好直接使用BERT，需要分段编码或使用其他算法(LSTM、XLNET等)。文本过长也使得训练时间变长，着实影响到了穷逼的炼丹进度。</p><h3 id="2-2-内容是否加密"><a href="#2-2-内容是否加密" class="headerlink" title="2.2 内容是否加密"></a>2.2 内容是否加密</h3><p>大部分数据集是未加密的，直接可以看到原文。少部分数据集做了脱敏处理，原字词会被替换为数字或其他符号。虽说保护了隐私，但是对算法要求变高了，因为无法使用预训练模型，也没有办法做错误分析。为了达到更好的效果，需要对此类数据集继续做预训练，然后基于该预训练模型微调多标签分类任务。上文中我说的比赛就是做了加密处理。</p><h3 id="2-3-标签数量"><a href="#2-3-标签数量" class="headerlink" title="2.3 标签数量"></a>2.3 标签数量</h3><p>多标签分类数据集标签数量有多有少，少则几个多达上千(比如知乎看山杯数据集)，标签数量多少也会影响到算法的选择，标签数量过多时，多标签分类任务也可以考虑转化为搜索任务，此外标签数量过多时，往往会有严重的类不平衡问题，这在设计算法时也是需要考虑的。</p><h3 id="2-4-标签关联性"><a href="#2-4-标签关联性" class="headerlink" title="2.4 标签关联性"></a>2.4 标签关联性</h3><p>有些数据集的标签之间会存在相关性，比如新闻分类中，关于军事的新闻可能也会和政治有关系，疾病分类中，如果得了高血压，就有可能影响到视网膜。所以对于有关联的标签，算法如能考虑到标签的关联性，那么理论上效果是可以提升的，LM-MLC算法里就认真探索了标签关联性。</p><h2 id="3-自然语言处理中的完型填空"><a href="#3-自然语言处理中的完型填空" class="headerlink" title="3 自然语言处理中的完型填空"></a><strong>3 自然语言处理中的完型填空</strong></h2><p>先说一说完型填空，即一段文本，挖掉几个词，让模型去猜挖掉的词是什么，其实这就是遮挡语言模型。我们可以借助完型填空完成一些自然处理任务，关于这块的介绍，苏建林的两篇博客：博客1，博客2介绍的细致、精彩，因此我就不再过多叙述。</p><p>为了便于理解，我举个完型填空做新闻分类的例子，待分类文本是：美国攻打伊拉克，是因为萨达姆偷了布什家的高压锅 ，我们在该段文本后(或前面)加上如下一段话：这是关于[MASK]的新闻，这样完整的进入BERT的输入就是：[CLS]美国攻打伊拉克，是因为萨达姆偷了布什家的高压锅，这是关于[MASK]的新闻[SEP], 我们只要让模型判断掩掉的词是什么即可，如预测词是军事，那么分类结果就是军事，通常情况下候选词是全体标签。</p><p><img src="https://i.loli.net/2021/07/08/Eybwgr72T4D6tQz.png" alt="640" style="zoom:50%;"></p><h2 id="4-LM-MLC-把完型填空用在多标签分类数据集上"><a href="#4-LM-MLC-把完型填空用在多标签分类数据集上" class="headerlink" title="4 LM-MLC:把完型填空用在多标签分类数据集上"></a><strong>4 LM-MLC:把完型填空用在多标签分类数据集上</strong></h2><p>说了那么多背景知识，下面开始正式介绍LM-MLC算法。</p><h3 id="4-1-模板构建"><a href="#4-1-模板构建" class="headerlink" title="4.1 模板构建"></a><strong>4.1 模板构建</strong></h3><p>上文举得例子是关于分类的，那么对于多标签分类任务要如何构建模板呢，很自然的可以加入如下模板：”有标签1：[MASK],有标签2：[MASK],有标签3：[MASK]”, 该[MASK]预测的词就是：YES或NO。一图胜千言，我们假设是在新闻多标签分类任务，共有三个标签分别是”军事”,”政治”和”历史”，假设文本是：美国攻打伊拉克，那么输入就是：</p><p><img src="https://i.loli.net/2021/07/08/BXYNRLdHau9jC7l.png" alt="640" style="zoom:50%;"></p><p>人工构建模板是一个困难的事情，模板选取很关键，模板是很不稳定的，因此本算法使用了P-tuning的做法，把模板变为[unused*]或者自己在bert的vocab中新建一些词汇，总之就是让模型自己去寻找最佳模板，所以上图输入可以进一步修改为如下形式：</p><p><img src="https://i.loli.net/2021/07/08/abroHAk3t7B12sY.png" alt="640"></p><p>至于[MASK]前后放多少未使用字符，模板位置，不同标签是否使用不同[MASK]等就是各种微小改动，具体可以看开源代码，均以超参形式存于代码中，可以一次试个够。</p><h3 id="4-2-模型架构"><a href="#4-2-模型架构" class="headerlink" title="4.2 模型架构"></a><strong>4.2 模型架构</strong></h3><p>本次博客主要还是抛砖引玉，想把方法公开了和各位讨论，本次所用模型都是极为简单的，没有使用任何比赛的trick，主要提供思想。</p><h4 id="4-2-1-Baseline模型架构"><a href="#4-2-1-Baseline模型架构" class="headerlink" title="4.2.1 Baseline模型架构"></a><strong>4.2.1 Baseline模型架构</strong></h4><p>本模型的Baseline模型就是基于BERT的，模型架构极为简单，CLS向量后接全连接层，然后过Sigmoid层作为每个tag的分数。损失函数可以选用最基础的BCELoss。多提一句，也可以当成分类任务做，用交叉熵优化，但其实看公式，其实是差不多的，本人就懒得折腾了。</p><h4 id="4-2-2-LM-MLC模型架构"><a href="#4-2-2-LM-MLC模型架构" class="headerlink" title="4.2.2 LM-MLC模型架构"></a><strong>4.2.2 LM-MLC模型架构</strong></h4><p>模型架构图前面已经有了，再用文字描述下：基础部分还是BERT，获取TokenEmbedding后使用gather方法提取[MASK]的embedding，然后通过Sigmoid获取每个标签的分数，同样使用BCELoss损失函数。</p><h3 id="4-3-如何训练"><a href="#4-3-如何训练" class="headerlink" title="4.3 如何训练"></a><strong>4.3 如何训练</strong></h3><p>最简单的训练方式就是一次掩盖掉所有的标签然后全部预测，此类方法适合标签没有关联性的数据集。如果标签之间存在关联性，肯定要通过一部分标签值来预测余下的标签值，这也是LM-MLC算法的核心，很多方法都是围绕这个点设计的。</p><p>如何判断标签之间有无关联性呢，方法很简单，取训练集的标签值购置01向量，然后计算统计相关系数即可，根据系数值和下表判断相关性：</p><p><img src="https://i.loli.net/2021/07/08/gbGJ4LmNfHtYKch.png" alt="图片"></p><p>在训练过程中，要把一部分[MASK]改为YES或NO，这种方式让模型在对[MASK]标签做预测时不仅能感知到哪些标签值是0哪些标签值是1以及哪些标签是待预测的。在本算法中使用了[MASK]的真实值，相当于teacher-force-learning，同时为了提升模型的鲁棒性，会以1%的概率故意给错标签，实测这个trick还是挺关键的。</p><p>想要完整实现该思想时，要考虑好多细节，本人想了3种实现策略，但是也没找到最优解，我把思路和逻辑一一罗列出来供大家参考讨论。</p><p>思路一，全随机 在训练时随机掩盖一部分标签，让模型进行预测并计算损失损失。</p><p>思路二，固定掩盖顺序 假设有四个标签，掩盖顺序为1-&gt;2-&gt;3-&gt;4，那么可能的掩盖顺序是：1，12，123，1234，这种方法在预测时也要使用相同的方式去预测，掩盖顺序目前没有发现最优解。</p><p>思路三，UniLM 把标签作为生成任务，通过修改AttentionMask的方式来实现，即以UniLM的形式去训练，这个我没有尝试，因为这种方式已经不再是完型填空的范畴了，欢迎大家尝试。</p><p>本人比较推荐思路一，在实验中思路一的效果也是不错的</p><h3 id="4-4-如何预测"><a href="#4-4-如何预测" class="headerlink" title="4.4 如何预测"></a><strong>4.4 如何预测</strong></h3><p>预测时的基本思想是先预测一个标签，然后在该标签预测结果的基础上继续预测其他标签。那么最重要的问题就是如何确定预测顺序，有如下几种预测方法：</p><p>方法1：随机，即随机确定一个顺序，不足在于不同顺序会影响性能上下浮动约2个百分点</p><p>方法2：固定顺序，即按照固定顺序预测，难点在于顺序难以确定 </p><p>方法3：Top-P,每一次选取模型置信度最高的标签作为首先预测的标签，效果尚可 </p><p>方法4：搜索算法，使用遗传算法等搜索算法选取一个在dev上效果最号的预测顺序作为最终顺序，也可以不用搜索算法，直接random几百次找个最好的也行</p><p>方法3效果还行，方法4可提升逼格发论文。</p><h3 id="4-5-如何进一步提升效果"><a href="#4-5-如何进一步提升效果" class="headerlink" title="4.5 如何进一步提升效果"></a><strong>4.5 如何进一步提升效果</strong></h3><p>在当前预训练+微调的框架下，有一个简单有效的方法那就是不要停止预训练，即把预训练模型在微调数据集上继续做预训练，然后再做微调，该方法以获得ACL2020最佳论文荣誉提名，具体参见Don’t Stop Pretraining:Adapt Language Models to Domains and Tasks。</p><p>为什么我说LM-MLC是根正苗红呢，因为完形填空他完美契合mlm预训练任务，都是预测[MASK], 我总结两个使用该思想的方法：</p><p>常规做法：先继续预训练，然后微调</p><p>联合训练：同时做Word Mask(mlm 任务)和Label Mask(完形填空任务)，然后把loss加一起，可以适当提高Label Mask的权重</p><p>本人是使用第二种，因为这两个任务实在是太契合了，通常我是微调25轮，其中前15轮联合训练，后10轮task-specific的训练，不能所有轮数都联合训练，那不然预测和训练的数据又会不一致。</p><h3 id="4-6-小结"><a href="#4-6-小结" class="headerlink" title="4.6 小结"></a><strong>4.6 小结</strong></h3><p>LM-MLC算法最大的缺点是不支持标签数量过多，假设有100个标签，模板长度为2，再加上自身MASK，那么光标签模板就占了300的长度，而BERT的输入长度限制为512，所以数据集标签多了是无法使用该方法的。</p><p>此外，由于时间精力有限，几乎没有找到合适的存在标签关联的数据集，所以对于标签关联性的一些构想还是缺少验证的，这种数据集怕是要手工构建了，绝大多数数据集都是标签无关，因此直接全部掩盖掉，全部预测就行了。</p><h2 id="5-简单实验"><a href="#5-简单实验" class="headerlink" title="5 简单实验"></a><strong>5 简单实验</strong></h2><p><strong>数据集介绍</strong></p><p>全球人工智能技术创新大赛【赛道一】比赛数据集，是关于医疗影像描述文本的，输出为哪些部位有异常，初赛是17分类，复赛在17分类的基础上又多了12标签分类，本人把复赛初赛复赛数据集合并到一起，当成17多标签分类任务来做。数据集不太方便提供下载。</p><p><strong>AAPD数据集</strong>，这是开源的数据集，我分析AAPD数据集并没有较强的标签关联性，搞不懂为啥SGM多标签分类算法要用这个训练集。。。</p><p><strong>Stackoverflow数据集</strong>，Stackoverflow的帖子都是带有tag的，截图如下，但是该数据集不能直接获得，需要去该网站（<a href="https://archive.org/details/stackexchange）下载，可能需要梯子，然后手工清洗后作为训练集，清洗代码可以见我另外一个开源库DomainSpecificThesaurus。或者先用我清洗的10W数据集，下载链接请往后看。" target="_blank" rel="noopener">https://archive.org/details/stackexchange）下载，可能需要梯子，然后手工清洗后作为训练集，清洗代码可以见我另外一个开源库DomainSpecificThesaurus。或者先用我清洗的10W数据集，下载链接请往后看。</a></p><p><strong>RCV1-V2数据集</strong>，也是开源数据集，标签间也没啥关联性，而且看着文本总感觉很奇怪。</p><p>我提供了AAPD数据集、清洗后的Stackoverflow数据集和RCv1-v2数据集，下载地址：</p><p><a href="https://drive.google.com/file/d/1qNOfb4WX7TpTSPuhGIAAvzAbOc1MbHCO/view" target="_blank" rel="noopener">https://drive.google.com/file/d/1qNOfb4WX7TpTSPuhGIAAvzAbOc1MbHCO/view</a></p><p><strong>实验结果</strong></p><p>因为硬件资源有限，本人工作也较忙，没有做太多的实验，这里把有记录的比赛数据集结果和AAPD数据集测试结果贴出来。</p><p>全球人工智能技术创新大赛【赛道一】的测试结果：</p><p><img src="https://i.loli.net/2021/07/08/mqOFiescWHYvM3J.png" alt="图片"></p><p>AAPD数据集的测试结果：</p><p><img src="https://i.loli.net/2021/07/08/DmXbY1r7us8UFoc.png" alt="图片"></p><p>简单解释下四个方法的含义：</p><p>Baseline: BERT+FC, 详情见上文或源码</p><p>Baseline+mlm: 与mlm联合训练，即mlm_loss+bce_loss</p><p>LM-MLC: 基于完形填空的多标签分类算法，就本人所设计算法</p><p>LM-MLC: 与mlm联合预训练，详情见上文或源码</p><p>前前后后做了很多实验，客观来说，实验结果不太符合预期，效果在其他数据集上没有显著性提升，还是挺郁闷的，抛砖引玉，希望读者能提出的改进意见。不过该方法也没有明显差于其他方法，在以后比赛中作为一种融合模型还是可以滴。</p><h2 id="6-代码介绍"><a href="#6-代码介绍" class="headerlink" title="6 代码介绍"></a><strong>6 代码介绍</strong></h2><p>Github开源地址：<a href="https://github.com/DunZhang/LM-MLC代码做了好多修改，力求简洁易用，同时具有较强的可读性和可扩展性，文中提到的好多点都做成了超参形式，欢迎试水" target="_blank" rel="noopener">https://github.com/DunZhang/LM-MLC代码做了好多修改，力求简洁易用，同时具有较强的可读性和可扩展性，文中提到的好多点都做成了超参形式，欢迎试水</a></p><p><img src="https://i.loli.net/2021/07/08/HEIkqPGivCL5r7y.png" alt="图片"></p><p>目录结构及文件名含义如下：</p><p><img src="https://i.loli.net/2021/07/08/UT5K6DJNX12fIeb.png" alt="图片"></p><h2 id="7-TODOList"><a href="#7-TODOList" class="headerlink" title="7 TODOList"></a><strong>7 TODOList</strong></h2><p>数据集，多标签分类数据集实在是太少了，需要多搞点数据集尤其是中文数据集和标签相关的数据集</p><p>UnilM，可以考虑试一试，文本部分全部交互，标签逐个生成</p><p>考虑标签本身的语义信息，比如经济标签，经济二字本身就是有语义信息的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：&lt;a href=&quot;https://mp.weixin.qq.com/s/1VnR1zQ4LWnUDl6USdxVhQ#&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/1VnR1zQ4LWnUDl6
      
    
    </summary>
    
      <category term="NLP" scheme="http://yoursite.com/categories/NLP/"/>
    
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>MDETR - Modulated Detection for End-to-End Multi-Modal Understanding</title>
    <link href="http://yoursite.com/2021/07/07/MDETR-Modulated-Detection-for-End-to-End-Multi-Modal-Understanding/"/>
    <id>http://yoursite.com/2021/07/07/MDETR-Modulated-Detection-for-End-to-End-Multi-Modal-Understanding/</id>
    <published>2021-07-07T08:43:47.000Z</published>
    <updated>2021-07-07T09:06:32.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="研究内容"><a href="#研究内容" class="headerlink" title="研究内容"></a>研究内容</h2><p>将目标检测与下游任务结合起来，端到端的训练</p><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p><code>物体检测</code>构成了大多数最先进的<code>多模式理解系统</code>的一个组成部分，通常作为一个黑箱来检测图像中的<code>固定概念词汇</code>。 这种流行的使用目标检测的方法没有考虑到下游的多模态理解任务，而且往往是性能的瓶颈。</p><p>此外，目标检测模型通常被冻结。这不仅阻碍了模型感知能力的进一步完善，而且还限制了它只能接触到检测到的物体，而不是整个图像。 这种 “流水线 “式的方法限制了与其他作为上下文的模态的共同训练。 在视觉语言设置中，它意味着 resulting system 的词汇限制在检测器的类别和属性上。 因此，这样的系统不能识别可以用自由格式文本表达的新概念组合。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;研究内容&quot;&gt;&lt;a href=&quot;#研究内容&quot; class=&quot;headerlink&quot; title=&quot;研究内容&quot;&gt;&lt;/a&gt;研究内容&lt;/h2&gt;&lt;p&gt;将目标检测与下游任务结合起来，端到端的训练&lt;/p&gt;
&lt;h2 id=&quot;存在的问题&quot;&gt;&lt;a href=&quot;#存在的问题&quot; clas
      
    
    </summary>
    
      <category term="cross-modal" scheme="http://yoursite.com/categories/cross-modal/"/>
    
    
      <category term="cross-modal" scheme="http://yoursite.com/tags/cross-modal/"/>
    
  </entry>
  
  <entry>
    <title>Seq2Seq中Exposure Bias现象的浅析与对策</title>
    <link href="http://yoursite.com/2021/07/05/Seq2Seq%E4%B8%ADExposure-Bias%E7%8E%B0%E8%B1%A1%E7%9A%84%E6%B5%85%E6%9E%90%E4%B8%8E%E5%AF%B9%E7%AD%96/"/>
    <id>http://yoursite.com/2021/07/05/Seq2Seq中Exposure-Bias现象的浅析与对策/</id>
    <published>2021-07-05T03:53:43.000Z</published>
    <updated>2021-07-05T04:25:42.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Seq2Seq中Exposure-Bias现象的浅析与对策"><a href="#Seq2Seq中Exposure-Bias现象的浅析与对策" class="headerlink" title="Seq2Seq中Exposure Bias现象的浅析与对策"></a>Seq2Seq中Exposure Bias现象的浅析与对策</h2><p>前些天笔者写了<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&amp;mid=2247503481&amp;idx=1&amp;sn=f998484d31148762630e2fdc16af01aa&amp;chksm=96ea11f9a19d98ef4a4c29e7fd86c01a278888374bc5a5ae9bd208de41cdfe6e53b67a09e967&amp;token=748748465&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">CRF用过了，不妨再了解下更快的MEMM？</a>，里边提到了 MEMM 的局部归一化和 CRF 的全局归一化的优劣。</p><p>同时，笔者联想到了 Seq2Seq 模型，因为 Seq2Seq 模型的典型训练方案 Teacher Forcing 就是一个局部归一化模型，所以它也存在着局部归一化所带来的毛病——也就是我们经常说的“Exposure Bias”。</p><p>带着这个想法，笔者继续思考了一翻，将最后的思考结果记录在此文。</p><p><img src="https://i.loli.net/2021/07/05/3zdSt9gLwn41GZa.png" alt="image-20210705121610582" style="zoom:50%;"></p><p>▲ 经典的 Seq2Seq 模型图示</p><p>本文算是一篇进阶文章，适合对Seq2Seq模型已经有一定的了解、希望进一步提升模型的理解或表现的读者。关于Seq2Seq的入门文章，可以阅读旧作<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&amp;mid=2247491314&amp;idx=1&amp;sn=3e22d4a6d732b0877fdc567d2bce1076&amp;chksm=96e9c172a19e48646005da05e143751aa9012c141dd1cf9846a2b418cbf854c7d343013105a1&amp;token=748748465&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">玩转Keras之seq2seq自动生成标题</a>和<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&amp;mid=2247499793&amp;idx=1&amp;sn=685c54d27186a89dcf32d91ce0927274&amp;chksm=96ea1f91a19d9687af5dbe751accc9c1ddd7392f6cf4294dc8a024751a64053cbcb8c60ef8f8&amp;token=748748465&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">从语言模型到Seq2Seq：Transformer如戏，全靠Mask。</a></p><p>本文的内容大致为：</p><ol><li>Exposure Bias 的成因分析及例子；</li><li>简单可行的缓解 Exposure Bias 问题的策略。</li></ol><h2 id="1-Softmax"><a href="#1-Softmax" class="headerlink" title="1. Softmax"></a>1. Softmax</h2><p>首先，我们来回顾 Softmax 相关内容。大家都知道，对于向量 $\left(x_{1}, x_{2}, \ldots, x_{n}\right)$, 它的 Softmax 为:<br>$<br>\left(p_{1}, p_{2}, \ldots, p_{n}\right)=\frac{1}{\sum_{i=1}^{n} e^{x_{i}}}\left(e^{x_{1}}, e^{x_{2}}, \ldots, e^{x_{n}}\right)<br>$<br>由于 $e^{t}$ 是关于 $t$ 的严格单调递增函数，所以如果 $x_{k}$ 是 $x_{1}, x_{2}, \ldots, x_{n}$ 中的最大者， 那么 $p_{k}$也是 $p_{1}, p_{2}, \ldots, p_{n}$ 中的最大者。<br>对于分类问题，我们所用的 Ioss 一般是交叉嫡，也就是：<br>$<br>-\log p_{t}=\log \left(\sum_{i=1}^{n} e^{x_{i}}\right)-x_{t}(2)<br>$<br>其中 $t$ 是目标类。如文章 《寻求一个光滑的最大值函数》[1] 所述，上式第一项实际上是$\max \left(x_{1}, x_{2}, \ldots, x_{n}\right)$ 的光滑近似，所以为了形象理解交叉嫡, 我们可以写出:<br>$<br>-\log p_{t} \approx \max \left(x_{1}, x_{2}, \ldots, x_{n}\right)-x_{t}<br>$<br>也就是说，交叉商实际上在缩小目标类得分 $x_{t}$ 与全局最大值的差距，显然这个差距最小只能为 0 ，并且此时目标类得分就是最大值者。所以， Softmax 加交叉嫡的效果就是“希望目标类的得分成为最大值”。</p><h2 id="2-Teacher-Forcing"><a href="#2-Teacher-Forcing" class="headerlink" title="2. Teacher Forcing"></a>2. Teacher Forcing</h2><p>现在，我们来看 Seq2Seq，它通过条件分解来建模联合概率分布：</p><p>$\begin{aligned} p(\boldsymbol{y} \mid \boldsymbol{x}) &amp;=p\left(y_{1}, y_{2}, \ldots, y_{n} \mid \boldsymbol{x}\right) \\ &amp;=p\left(y_{1} \mid \boldsymbol{x}\right) p\left(y_{2} \mid \boldsymbol{x}, y_{1}\right) \ldots p\left(y_{n} \mid \boldsymbol{x}, y_{1}, \ldots, y_{n-1}\right) \end{aligned}$</p><p>每一项自然也就用 Softmax 来建模的，即：</p><p>$p\left(y_{1} \mid \boldsymbol{x}\right)=\frac{e^{f\left(y_{1} ; \boldsymbol{x}\right)}}{\sum_{y_{1}} e^{f\left(y_{1} ; \boldsymbol{x}\right)}}$,<br>$p\left(y_{2} \mid \boldsymbol{x}, y_{1}\right)=\frac{e^{f\left(y_{1}, y_{2} ; \boldsymbol{x}\right)}}{\sum_{y_{2}} e^{f\left(y_{1}, y_{2} ; \boldsymbol{x}\right)}}$,<br>$\ldots$,<br>$p\left(y_{n} \mid \boldsymbol{x}, y_{1}, \ldots, y_{n-1}\right)=\frac{e^{f\left(y_{1}, y_{2}, \ldots, y_{n} ; \boldsymbol{x}\right)}}{\sum_{y_{n}} e^{f\left(y_{1}, y_{2}, \ldots, y_{n} ; \boldsymbol{x}\right)}}$</p><p>乘起来就是：<br>$<br>p(\boldsymbol{y} \mid \boldsymbol{x})=\frac{e^{f\left(y_{1} ; \boldsymbol{x}\right)}}{\left(\sum_{y_{1}} e^{f\left(y_{1} ; \boldsymbol{x}\right)}\right)\left(\sum_{y} e^{f\left(y_{1}, y_{2} ; \boldsymbol{x}\right)}\right) \ldots\left(\sum_{y_{n}} e^{f\left(y_{1}, y_{2}, \ldots, y_{n} ; \boldsymbol{x}\right)}\right)}<br>$<br>而训练目标就是：<br>$-\log p(\boldsymbol{y} \mid \boldsymbol{x})=-\log p\left(y_{1} \mid \boldsymbol{x}\right)-\log p\left(y_{2} \mid \boldsymbol{x}, y_{1}\right)-\cdots-\log p\left(y_{n} \mid \boldsymbol{x}, y_{1}, \ldots, y_{n-1}\right)$这个直接的训练目标就叫做 Teacher Forcing, 因为在算 $-\log p\left(y_{2} \mid \boldsymbol{x}, y_{1}\right)$ 的时候我们要知道真实的 $y_{1}$, 在算 $-\log p\left(y_{3} \mid \boldsymbol{x}, y_{1}, y_{2}\right)$ 我们需要知道真实的 $y_{1}, y_{2}$, 依此类推， 这就好像有一个经验丰富的老师预先给我们铺好了大部分的路，让我们只需要求下一步即可。</p><p>这个直接的训练目标就叫做 Teacher Forcing，因为在算 的时候我们要知道真实的 ，在算 我们需要知道真实的 ，依此类推，这就好像有一个经验丰富的老师预先给我们铺好了大部分的路，让我们只需要求下一步即可。</p><p>这种方法训练起来简单，而且结合 CNN 或 Transformer 那样的模型就可以实现并行的训练，但它可能会带来 Exposure Bias 问题。</p><h2 id="3-Exposure-Bias"><a href="#3-Exposure-Bias" class="headerlink" title="3. Exposure Bias"></a>3. Exposure Bias</h2><p>其实 Teacher Forcing 这个名称本身就意味着它本身会存在 Exposure Bias 问题。回想一下老师教学生解题的过程，一般的步骤为：</p><ul><li>第一步应该怎么思考；</li><li>第一步想出来后，第二步我们有哪些选择；</li><li>确定了第二步后，第三步我们可以怎么做；</li><li>…</li><li>有了这 n-1 步后，最后一步就不难想到了。</li></ul><p>这个过程其实跟 Seq2Seq 的 Teacher Forcing 方案的假设是一样的。有过教学经验的读者就知道，通常来说学生们都能听得频频点头，感觉全都懂了，然后让学生课后自己做题，多数还是一脸懵比。</p><p>为什么会这样呢？其中一个原因就是 Exposure Bias。说白了，问题就在于，老师总是假设学生能想到前面若干步后，然后教学生下一步，但如果前面有一步想错了或者想不出来呢？这时候这个过程就无法进行下去了，也就是没法得到正确答案了，这就是 Exposure Bias 问题。</p><h2 id="4-Beam-Search"><a href="#4-Beam-Search" class="headerlink" title="4. Beam Search"></a>4. Beam Search</h2><p>事实上，我们真正做题的时候并不总是这样子，假如我们卡在某步无法确定时，我们就遍历几种选择，然后继续推下去，看后面的结果反过来辅助我们确定前面无法确定的那步。对应到 Seq2Seq 来说，这其实就相当于基于 Beam Search 的解码过程。</p><p>对于 Beam Search，我们应该能发现，beam size 并不是越大越好，有些情况甚至是 beam size 等于 1 时最好，这看起来有点不合理，因为 beam size 越大，理论上找到的序列就越接近最优序列，所以应该越有可能正确才对。事实上这也算是 Exposure Bias 的现象之一。</p><p>从式（6）我们可以看出，Seq2Seq 对目标序列 的打分函数为：</p><p>$f\left(y_{1} ; \boldsymbol{x}\right)+f\left(y_{1}, y_{2} ; \boldsymbol{x}\right)+\cdots+f\left(y_{1}, y_{2}, \ldots, y_{n} ; \boldsymbol{x}\right)$</p><p>正常来说，我们希望目标序列是所有候选序列之中分数最高的，根据本文开头介绍的 Softmax 方法，我们建立的概率分布应该是：</p><p>$p(\boldsymbol{y} \mid \boldsymbol{x})=\frac{e^{f\left(y_{1} ; \boldsymbol{x}\right)+f\left(y_{1}, y_{2} ; \boldsymbol{x}\right)+\cdots+f\left(y_{1}, y_{2}, \ldots, y_{n} ; \boldsymbol{x}\right)}}{\sum_{y_{1}, y_{2}, \ldots, y_{n}} e^{f\left(y_{1} ; \boldsymbol{x}\right)+f\left(y_{1}, y_{2} ; \boldsymbol{x}\right)+\cdots+f\left(y_{1}, y_{2}, \ldots, y_{n} ; \boldsymbol{x}\right)}}$</p><p>但上式的分母需要遍历所有路径求和，难以实现，而式（6）就作为一种折衷的选择得到了广泛应用。但式（6）跟式（9）并不等价，因此哪怕模型已经成功优化，也可能出现“最优序列并不是目标序列”的现象。</p><h2 id="5-简单例子"><a href="#5-简单例子" class="headerlink" title="5. 简单例子"></a>5. 简单例子</h2><p>我们来举一个简单例子。设序列长度只有 2，候选序列是 $(a, b)$ 和 $(c, d)$, 而目标序列是<br>$(a, b)$, 训练完成后，模型的概率分布情况为：</p><p><img src="https://i.loli.net/2021/07/05/l5dg34prCf8vzbB.png" alt="image-20210705122243485" style="zoom:50%;"></p><p>如果 beam size 为 1, 那么因为 $p(a)&gt;p(c)$, 所以第一步只能输出 $a$, 接着因为$p(b \mid a)&gt;p(d \mid a)$, 所以第二步只能输出 $b$, 成功输出了正确序列 $(a, b)$ 。但如果 beam size 为 2，那么第一步输出 $(a, 0.6),(c, 0.4)$, 而第二步遍历所有组合，我们得到：</p><p><img src="https://i.loli.net/2021/07/05/9SyY3m6nARxGofN.png" alt="image-20210705122317192" style="zoom:50%;"></p><p>所以输出了错误的序列 $(c,d)$。</p><p>那是因为模型没训练好吗？并不是，前面说过 Softmax 加交叉商的目的就是让目标的得分最大，对于第一步我们有 $p(a)&gt;p(c)$, 所以第一步的训练目标已经达到了，而第二步在 $a$ 已经预先知道的前提下我们有 $p(b \mid a)&gt;p(d \mid a)$ ，这说明第二步的训练目标也达到了。</p><p>因此，模型已经算是训练好了，只不过可能因为模型表达能力限制等原因，得分并没有特别高，但“让目标的得分最大”这个目标已经完成了。</p><h2 id="6-思考对策"><a href="#6-思考对策" class="headerlink" title="6. 思考对策"></a>6. 思考对策</h2><p>从上述例子中读者或许可以看出问题所在了：主要是 $p(d \mid c)$ 太高了，而 $p(d \mid c)$ 是没有经过训练的，没有任何显式的机制去抑制 $p(d \mid c)$ 变大，因此就出现了“最优序列并不是目标序列”的现象。</p><p>看到这里，读者可能就能想到一个朴素的对策了：添加额外的优化目标，降低那些Beam Search出来的非目标序列不就行了？</p><p>事实上，这的确是一个有效的解决方法，相关结果发表在 2016 年的论文 <strong><em>Sequence-to-Sequence Learning as Beam-Search Optimization</em></strong> [2]。但这样一来几乎要求每步训练前的每个样本都要进行一次 Beam Search，计算成本太大。</p><p>还有一些更新的结果，比如 ACL 2019 的最佳长论文 <strong><em>Bridging the Gap between Training and Inference for Neural Machine Translation\</em></strong> [3] 就是聚焦于解决 Exposure Bias 问题。此外，通过强化学习直接优化 BLEU 等方法，也能一定程度上缓解 Exposure Bias。</p><p>然而，据笔者所了解，这些致力于解决 Exposure Bias 的方法，大部分都是大刀阔斧地改动了训练过程，甚至会牺牲原来模型的训练并行性（需要递归地采样负样本，如果模型本身是 RNN 那倒无妨，但如果本身是 CNN 或 Transformer，那伤害就很大了），成本的提升幅度比效果的提升幅度大得多。</p><h2 id="7-构建负样本"><a href="#7-构建负样本" class="headerlink" title="7. 构建负样本"></a>7. 构建负样本</h2><p>纵观大部分解决 Exposure Bias 的论文，以及结合我们前面的例子和体会，不难想到，其主要思想就是构造有代表性的负样本，然后在训练过程中降低这些负样本的概率，所以问题就是如何构造“有代表性”的负样本了。</p><p>这里给出笔者构思的一种简单策略，实验证明它能一定程度上缓解 Exposure Bias，提升文本生成的表现，重要的是，这种策略比较简单，基本能做到即插即用，几乎不损失训练性能。</p><p>方法很简单，就是随机替换一下 Decoder 的输入词（Decoder 的输入词有个专门的名字，叫做 oracle words），如下图所示：</p><p><img src="https://i.loli.net/2021/07/05/KblSQv4UzCkoVW5.png" alt="image-20210705121402164" style="zoom:50%;"></p><p>▲ 一种缓解Exposure Bias的简单策略：直接将Decoder的部分输入词随机替换为别的词</p><p>其中紫色的 [R] 代表被随机替换的词。其实不少 Exposure Bias 的论文也是这个思路，只不过随机选词的方案不一样。笔者提出的方案很简单：</p><ol><li><p>50% 的概率不做改变；</p></li><li><p>50% 的概率把输入序列中 30% 的词替换掉，替换对象为原目标序列的任意一个词。</p></li></ol><p>也就是说，随机替换发生概率是 50%&gt;&gt;随机替换的比例是 30%，随机抽取空间就是目标序列的词集。</p><p>这个策略的灵感在于：尽管 Seq2Seq 不一定能完全生成目标序列，但它通常能生成大部分目标序列的词（但顺序可能不对，或者重复出现同一些词），因此这样替换后的输入序列通常可以作为有代表性的负样本。对了，说明一下，50% 和 30% 这两个比例纯粹是拍脑袋的，没仔细调参，因为生成模型调一次实在是太累了。</p><p>效果如何呢？笔者做了两个标题（摘要）生成的实验（就是 CLGE [4] 的前两个），其中 baseline 是 task_seq2seq_autotitle_csl.py [5]，代码开源于：</p><p><a href="https://github.com/bojone/exposure_bias" target="_blank" rel="noopener">https://github.com/bojone/exposure_bias</a></p><p>结果如下表：</p><p><img src="https://i.loli.net/2021/07/05/ae1MA82g9zBV6Lr.png" alt="image-20210705121333189" style="zoom:50%;"></p><p><img src="https://i.loli.net/2021/07/05/WlX9DUvHn1iYA62.png" alt="image-20210705121322078" style="zoom:50%;"></p><p>可以发现，在 CSL 任务中，基于随机替换的策略稳定提升了文本生成的所有指标，而 LCSTS 任务的各个指标则各有优劣，考虑到 LCSTS 本身比较难，各项指标本来就低，所以应该说 CSL 的结果更有说服力一些。</p><p>这表明，笔者提出的上述策略确实是一种值得尝试的方案（注：所有实验都重复了两次然后取平均，所以实验结果应该是比较可靠的了）。</p><h2 id="8-对抗训练"><a href="#8-对抗训练" class="headerlink" title="8. 对抗训练"></a>8. 对抗训练</h2><p>思考到这里，我们不妨再“天马行空”一下：既然解决 Exposure Bias 的思路之一就是要构造有代表性的负样本输入，说白了就是让模型在扰动下依然能预测正确，而前些天我们不是才讨论了一种生成扰动样本的方法吗？</p><p>不错，那就是<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&amp;mid=2247504686&amp;idx=2&amp;sn=087dc7e98ede7960b3baacb20d55ce40&amp;chksm=96ea0caea19d85b8dccc52f07763b82f4aaffda6dd4cbdd784e682f13de6a11c6ced5b8df96f&amp;token=748748465&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">对抗训练</a>。如果直接往 baseline 模型里边加入对抗训练，能不能提升模型的性能呢？简单起见，笔者做了往 baseline 模型里边梯度惩罚（也算是对抗训练的一种）的实验，结果对比如下：</p><p><img src="https://i.loli.net/2021/07/05/ZOhswW8mGaSxIYc.png" alt="image-20210705121226535" style="zoom:50%;"></p><p><img src="https://i.loli.net/2021/07/05/J1pAQX28GScMPIB.png" alt="image-20210705121209230" style="zoom:50%;"></p><p>可以看到，对抗训练（梯度惩罚）进一步提升了 CSL 生成的所有指标，而 LCSTS 上则同样比较“随缘”。因此，对抗训练也可以列入“提升文本生成模型的潜力技巧”名单之中。</p><h2 id="9-本文小结"><a href="#9-本文小结" class="headerlink" title="9. 本文小结"></a>9. 本文小结</h2><p>本文讨论了 Seq2Seq 中的 Exposure Bias 现象，尝试从直观上和理论上分析 Exposure Bias 的原因，并给出了简单可行的缓解 Exposure Bias 问题的对策。</p><p>其中包括笔者构思的一种随机替换策略，以及基于对抗训练的策略，这两种策略的好处是它们几乎是即插即用的，并且实验表明它们能一定程度上提升文本生成的各个指标。</p><p><strong>相关链接</strong></p><p>[1] <a href="https://kexue.fm/archives/3290" target="_blank" rel="noopener">https://kexue.fm/archives/3290</a></p><p>[2] <a href="https://arxiv.org/abs/1606.02960" target="_blank" rel="noopener">https://arxiv.org/abs/1606.02960</a></p><p>[3] <a href="https://arxiv.org/abs/1906.02448" target="_blank" rel="noopener">https://arxiv.org/abs/1906.02448</a></p><p>[4] <a href="https://github.com/CLUEbenchmark/CLGE" target="_blank" rel="noopener">https://github.com/CLUEbenchmark/CLGE</a></p><p>[5] <a href="https://github.com/bojone/bert4keras/blob/master/examples/task_seq2seq_autotitle_csl.py" target="_blank" rel="noopener">https://github.com/bojone/bert4keras/blob/master/examples/task_seq2seq_autotitle_csl.py</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Seq2Seq中Exposure-Bias现象的浅析与对策&quot;&gt;&lt;a href=&quot;#Seq2Seq中Exposure-Bias现象的浅析与对策&quot; class=&quot;headerlink&quot; title=&quot;Seq2Seq中Exposure Bias现象的浅析与对策&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>R-Drop: Regularized Dropout for Neural Networks</title>
    <link href="http://yoursite.com/2021/07/05/R-Drop-Regularized-Dropout-for-Neural-Networks/"/>
    <id>http://yoursite.com/2021/07/05/R-Drop-Regularized-Dropout-for-Neural-Networks/</id>
    <published>2021-07-05T03:14:14.000Z</published>
    <updated>2021-07-07T02:51:35.584Z</updated>
    
    <content type="html"><![CDATA[<p>来源：<a href="https://mp.weixin.qq.com/s/IvhGbFEMotpKJIUPExUklg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/IvhGbFEMotpKJIUPExUklg</a></p><p>关注 NLP 新进展的读者，想必对四月份发布的 SimCSE [1] 印象颇深，它通过简单的“Dropout 两次”来构造正样本进行对比学习，达到了无监督语义相似度任务的全面 SOTA。无独有偶，最近的论文《R-Drop: Regularized Dropout for Neural Networks》提出了 R-Drop，它将“Dropout两次”的思想用到了有监督任务中，每个实验结果几乎都取得了明显的提升。此外，笔者在自己的实验还发现，它在半监督任务上也能有不俗的表现。</p><p>小小的“Dropout两次”，居然跑出了“五项全能”的感觉，不得不令人惊讶。本文来介绍一下 R-Drop，并分享一下笔者对它背后原理的思考。</p><p><img src="https://i.loli.net/2021/07/05/fCjDeTwZyztI3s6.png" alt="image-20210705111612040" style="zoom:50%;"></p><p><strong>论文标题：</strong>R-Drop: Regularized Dropout for Neural Networks</p><p><strong>论文链接：</strong><a href="https://arxiv.org/abs/2106.14448" target="_blank" rel="noopener">https://arxiv.org/abs/2106.14448</a></p><p><strong>代码链接：</strong><a href="https://github.com/dropreg/R-Drop" target="_blank" rel="noopener">https://github.com/dropreg/R-Drop</a></p><h2 id="1-SimCSE"><a href="#1-SimCSE" class="headerlink" title="1. SimCSE"></a>1. SimCSE</h2><p>《中文任务还是 SOTA 吗？我们给 SimCSE 补充了一些实验》[1] 中，我们已经对 SimCSE 进行了介绍。简单来说，SimCSE 是 NLP 的一种对比学习方案，对比学习的标准流程是同一个样本通过不同的数据扩增手段得到的结果视为正样本对，而 batch 内的所有其他样本视为负样本，然后就是通过 loss 来缩小正样本的距离、拉大负样本的距离了。</p><p>所以难度主要集中在数据扩增手段上。对于 NLP 来说，我们很难人工构建保证语义不变的数据扩增，所以 SimCSE 干脆不人工进行数据扩增，而是通过“Dropout 两次”的方式来得到同一个输入的不同特征向量，并将它们视为正样本对。奇怪的是，这个简单的“Dropout 两次”构造正样本，看上去是一种“无可奈何”的妥协选择，但消融实验却发现它几乎优于所有其他数据扩增方法，令人惊讶之余又让人感叹“大道至简”。</p><p><img src="https://i.loli.net/2021/07/05/Z8UKsXLWCAyp3dO.png" alt="image-20210705112154737" style="zoom:50%;"></p><p>在实现上，SimCSE 也相当简单，所谓“Dropout 两次”，只需要将样本重复地输入到模型，然后计算相应的 loss 就行了，如上图所示。由于 Dropout 本身的随机性，每个样本的 Dropout 模式都是不一样的，所以只要单纯地重复样本，就可以实现“Dropout 两次”的效果。</p><h2 id="2-R-Drop"><a href="#2-R-Drop" class="headerlink" title="2. R-Drop"></a>2. R-Drop</h2><p>从结果上来看，SimCSE 就是希望 Dropout对模型结果不会有太大影响，也就是模型输出对 Dropout 是鲁棒的。所以很明显，“Dropout 两次”这种思想是可以推广到一般任务的，这就是 R-Drop（Regularized Dropout）。</p><h3 id="2-1-分类问题"><a href="#2-1-分类问题" class="headerlink" title="2.1 分类问题"></a>2.1 分类问题</h3><p>在笔者看来，R-Drop 跟 SimCSE 是高度相关的，甚至 R-Drop 应该是受到了 SimCSE 启发的，不过 R-Drop 论文并没有引用 SimCSE，所以这就比较迷了。</p><p><img src="https://i.loli.net/2021/07/05/PkRl8QUn2uC1W5j.png" alt="image-20210705112225164" style="zoom: 80%;"></p><p>具体来说，以分类问题为例，训练数据为 ，模型为 ，每个样本的 loss 一般是交叉熵：</p><p>$\mathcal{L}_{i}=-\log P_{\theta}\left(y_{i} \mid x_{i}\right)$</p><p>在“Dropout 两次”的情况下，其实我们可以认为样本已经通过了两个略有不同的模型，我们分别记为 和 。这时候 R-Drop 的 loss 分为两部分，一部分是常规的交叉熵：</p><p>$\mathcal{L}_{i}^{(C E)}=-\log P_{\theta}^{(1)}\left(y_{i} \mid x_{i}\right)-\log P_{\theta}^{(2)}\left(y_{i} \mid x_{i}\right)$</p><p>另一部分则是两个模型之间的对称 KL 散度，它希望不同 Dropout 的模型输出尽可能一致：</p><p>$\mathcal{L}_{i}^{(K L)}=\frac{1}{2}\left[K L\left(P_{\theta}^{(2)}\left(y \mid x_{i}\right) | P_{\theta}^{(1)}\left(y \mid x_{i}\right)\right)+K L\left(P_{\theta}^{(1)}\left(y \mid x_{i}\right) | P_{\theta}^{(2)}\left(y \mid x_{i}\right)\right)\right]$</p><p>最终 loss 就是两个 loss 的加权和：</p><p>$\mathcal{L}_{i}=\mathcal{L}_{i}^{(C E)}+\alpha \mathcal{L}_{i}^{(K L)}$</p><p>也就是说，它在常规交叉熵的基础上，加了一项强化模型鲁棒性正则项。</p><h3 id="2-2-一般形式"><a href="#2-2-一般形式" class="headerlink" title="2.2 一般形式"></a>2.2 一般形式</h3><p>可能有些读者会问非分类问题应该将 KL 项替换为什么，事实上原论文并没有在非分类问题上进行实验，不过这里可以补充一下。我们可以留意到：</p><p>$-\log P_{\theta}\left(y_{i} \mid x_{i}\right)=K L\left(\right.$ one_hot $\left.\left(y_{i}\right) | P_{\theta}\left(y \mid x_{i}\right)\right)$</p><p>所以，上述 只不过是 KL 散度的反复使用，它的一般形式是：</p><p>$\mathcal{L}_{i}=\mathcal{D}\left(y_{i}, f_{\theta}^{(1)}\left(x_{i}\right)\right)+\mathcal{D}\left(y_{i}, f_{\theta}^{(2)}\left(x_{i}\right)\right)+\frac{\alpha}{2}\left[\mathcal{D}\left(f_{\theta}^{(2)}\left(x_{i}\right), f_{\theta}^{(1)}\left(x_{i}\right)\right)+\mathcal{D}\left(f_{\theta}^{(1)}\left(x_{i}\right), f_{\theta}^{(2)}\left(x_{i}\right)\right)\right]$</p><p>因此对于非分类问题，我们将 换成适当的度量（而不是 KL 散度）即可。</p><h2 id="3-实验效果"><a href="#3-实验效果" class="headerlink" title="3. 实验效果"></a>3. 实验效果</h2><p>我们先来看看 R-Drop 的实验结果。</p><p>R-Drop 的主要超参有三个：batch_size, $\alpha$ 和 Dropout 概率。batch_size 一 般取决于我们的算力，对个人来说调整空间不大; 原论文的 $\alpha$ 从 $1 \sim 5$ 都有，笔者自己的实验中，则取了 $\alpha=4$, 也没细调。至于 Dropout的概率，跟笔者在《中文任务还是 SOTA 吗？ 我们给 $\operatorname{SimCSE}$ 补充了一些实验》 [1] 所选的一样，设为 $0.3$ 效果比较好。</p><h3 id="3-1-论文报告"><a href="#3-1-论文报告" class="headerlink" title="3.1 论文报告"></a>3.1 论文报告</h3><p>说实话，原论文所报告的 R-Drop 的效果是相当让人惊艳的，这也是笔者不得不要介绍一波 R-Drop 的主要原因。原论文在 NLU、NLG、CV 的分类等多种任务上都对 R-Drop 做了对比实验，大部分实验效果都称得上“明显提升”。</p><p>官方实现：<a href="https://github.com/dropreg/R-Drop" target="_blank" rel="noopener">https://github.com/dropreg/R-Drop</a></p><p>下面截图一部分实验结果：</p><p><img src="https://i.loli.net/2021/07/05/Ff3U5wNhAv9kEjz.png" alt="image-20210705112718166" style="zoom:50%;"></p><p>▲ R-Drop在机器翻译任务上的效果</p><p><img src="https://i.loli.net/2021/07/05/tVo7znGCKvUDN5m.png" alt="image-20210705112750407" style="zoom: 50%;"></p><p>▲ R-Drop在GLUE任务上的效果</p><p>特别地，在机器翻译任务上，简单的“Transformer + R-Drop”超过了其他更加复杂方法的效果：</p><p><img src="https://i.loli.net/2021/07/05/gm1UzqLS9pB5KIy.png" alt="image-20210705112819739" style="zoom: 50%;"></p><p>▲ 机器翻译任务上不同方法的对比</p><p>论文还包括自动摘要、语言模型、图像分类等实验，以及关于超参数的一些消融实验，大家仔细看原论文就好。总的来说，R-Drop 的这份“成绩单”，确实足以让人为之点赞了。</p><h3 id="3-2-个人尝试"><a href="#3-2-个人尝试" class="headerlink" title="3.2 个人尝试"></a>3.2 个人尝试</h3><p>当然，笔者坚持的观点是“没有在中文测试过的模型是没有灵魂的”，一般情况下笔者都是在中文任务上亲自尝试过之后，才会写作分享。</p><p>个人实现：<a href="https://github.com/bojone/r-drop" target="_blank" rel="noopener">https://github.com/bojone/r-drop</a></p><p>有中文监督任务上，笔者实验了两个文本分类任务（CLUE 榜单的 IFLYTEK 和 TNEWS）。</p><p><img src="https://i.loli.net/2021/07/05/6WdlENPmujJQh8y.png" alt="image-20210705112907796" style="zoom:50%;"></p><p>和一个文本生成任务（CSL 标题生成，参考 <a href="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&amp;mid=2247504805&amp;idx=2&amp;sn=e0e149112e3318bf65d309e32db356b2&amp;chksm=96ea0c25a19d8533ec3d623547b415a58072b353037ac4cd95c68d9dc67f6eb48370684dc6dd&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Seq2Seq 中 Exposure Bias 现象的浅析与对策</a>）：</p><p><img src="https://i.loli.net/2021/07/05/epuUgz8yJSC6jxY.png" alt="image-20210705112924382" style="zoom:50%;"></p><p>可以看到，R-Drop 的结果足以 PK 在<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&amp;mid=2247504686&amp;idx=2&amp;sn=087dc7e98ede7960b3baacb20d55ce40&amp;chksm=96ea0caea19d85b8dccc52f07763b82f4aaffda6dd4cbdd784e682f13de6a11c6ced5b8df96f&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">对抗训练浅谈：意义、方法和思考（附Keras 实现</a>）中介绍的著名正则化手段“对抗训练”和“梯度惩罚”了。</p><h3 id="3-3-实现要点"><a href="#3-3-实现要点" class="headerlink" title="3.3 实现要点"></a>3.3 实现要点</h3><p>相比于对抗学习等复杂正则化方法，R-Drop 的实现难度可谓是相当低了，这里以 bert4keras 为例，简单介绍一下如何将一个普通的训练脚本改为带 Dropout 的模式。</p><p>首先，是数据生成部分，改动如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">data_generator</span><span class="params">(DataGenerator)</span>:</span></span><br><span class="line">    <span class="string">"""数据生成器</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self, random=False)</span>:</span></span><br><span class="line">        batch_token_ids, batch_segment_ids, batch_labels = [], [], []</span><br><span class="line">        <span class="keyword">for</span> is_end, (text, label) <span class="keyword">in</span> self.sample(random):</span><br><span class="line">            token_ids, segment_ids = tokenizer.encode(text, maxlen=maxlen)</span><br><span class="line">            <span class="comment"># batch_token_ids.append(token_ids)</span></span><br><span class="line">            <span class="comment"># batch_segment_ids.append(segment_ids)</span></span><br><span class="line">            <span class="comment"># batch_labels.append([label])</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">                batch_token_ids.append(token_ids)</span><br><span class="line">                batch_segment_ids.append(segment_ids)</span><br><span class="line">                batch_labels.append([label])</span><br><span class="line">            <span class="comment"># if len(batch_token_ids) == self.batch_size or is_end:</span></span><br><span class="line">            <span class="keyword">if</span> len(batch_token_ids) == self.batch_size * <span class="number">2</span> <span class="keyword">or</span> is_end:</span><br><span class="line">                batch_token_ids = sequence_padding(batch_token_ids)</span><br><span class="line">                batch_segment_ids = sequence_padding(batch_segment_ids)</span><br><span class="line">                batch_labels = sequence_padding(batch_labels)</span><br><span class="line">                <span class="keyword">yield</span> [batch_token_ids, batch_segment_ids], batch_labels</span><br><span class="line">                batch_token_ids, batch_segment_ids, batch_labels = [], [], []</span><br></pre></td></tr></table></figure><p>然后，自定义一个新 loss：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.losses <span class="keyword">import</span> kullback_leibler_divergence <span class="keyword">as</span> kld</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">categorical_crossentropy_with_rdrop</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    <span class="string">"""配合上述生成器的R-Drop Loss</span></span><br><span class="line"><span class="string">    其实loss_kl的除以4，是为了在数量上对齐公式描述结果。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    loss_ce = K.categorical_crossentropy(y_true, y_pred)  <span class="comment"># 原来的loss</span></span><br><span class="line">    loss_kl = kld(y_pred[::<span class="number">2</span>], y_pred[<span class="number">1</span>::<span class="number">2</span>]) + kld(y_pred[<span class="number">1</span>::<span class="number">2</span>], y_pred[::<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">return</span> K.mean(loss_ce) + K.mean(loss_kl) / <span class="number">4</span> * alpha</span><br></pre></td></tr></table></figure><p>最后把模型的 Dropout 打开，并用这个 data_generator 和 categorical_crossentropy_with_rdrop 来训练模型就行了。</p><h2 id="4-个人理解"><a href="#4-个人理解" class="headerlink" title="4. 个人理解"></a>4. 个人理解</h2><p>看完了让人赏心悦目的实验结果后，我们来啃一下理论。原论文提供了对 R-Drop 的一个理论分析，大致意思是 R-Drop 会促进参数的同化，从而起到正则化作用。不过个人感觉这个解释并不直观，而且还不够本质。下面笔者试图提供 R-Drop 的另外几个角度的理解。</p><h3 id="4-1-一致性"><a href="#4-1-一致性" class="headerlink" title="4.1 一致性"></a>4.1 一致性</h3><p>R-Dropout 可以看成是 Dropout 的改进，那 Dropout 有什么问题呢? 其实 Dropout 是典型的训练和预测不一致的方法。具体来说， Dropout 在训练阶段往 $\left(\right.$ 某些层的) 输入加上了乘性噪声，使得模型从 $f_{\theta}(x)$ 变成了 $f_{\theta}(x, \varepsilon)$, 其中 $\varepsilon$ 的每个元素有 $\mathrm{p}$的概率为 0 ，剩下 1-p 的概率为 $1 /(1-\mathrm{p})$ ，训练目标就是：</p><p>$\mathbb{E}_{(x, y) \sim \mathcal{D}} \mathbb{E}_{\varepsilon}\left[l\left(y, f_{\theta}(x, \varepsilon)\right)\right]$</p><p>这样训练之后，我们应该用哪个模型预测最好呢？不确定，但如果损失函数是 $l_{2}$距离的话，那么我们可以推出最佳预测模型应该是：</p><p>$\mathbb{E}_{\varepsilon}\left[f_{\theta}(x, \varepsilon)\right]$</p><p><strong>推导：</strong>如果用$l_{2}$ 损失，此时单个样本的损失是：</p><p>$\mathbb{E}_{\varepsilon}\left[\left|y-f_{\theta}(x, \varepsilon)\right|^{2}\right]=|y|^{2}-2\left\langle y, \mathbb{E}_{\varepsilon}\left[f_{\theta}(x, \varepsilon)\right]\right\rangle+\mathbb{E}_{\varepsilon}\left[\left|f_{\theta}(x, \varepsilon)\right|^{2}\right]$</p><p>注意，现在我们的问题是“模型训练完后应该用什么函数来预测”，所以 $f_{\theta}(x, \varepsilon)$ 是常数， $\mathrm{y}$ 才是要优化的变量，这只不过是一个 二次函数的最小值问题，容易解得 $y=\mathbb{E}_{\varepsilon}\left[f_{\theta}(x, \varepsilon)\right]$ 时损失函数最小。</p><p>我们假定这个结果能泛化到一般情况。上式告诉我们，带 Dropout 的模型的正确步骤是“模型融合”：</p><p>对同一个输入多次传入模型中（模型不关闭 Dropout），然后把多次的预测结果平均值作为最终的预测结果。</p><p>但我们一般情况下的预测方式显然不是这样的，而是直接关闭 Dropout 进行确定性的预测，这等价于预测模型由“模型平均”变成了“权重平均”：</p><p>$f_{\theta}\left(x, \mathbb{E}_{\varepsilon}[\varepsilon]\right)=f_{\theta}(x, 1)=f_{\theta}(x)$</p><p>这里的 1 指的是全 1 向量。所以，我们训练的是不同 Dropout 的融合模型，预测的时候用的是关闭 Dropout 的单模型，两者未必等价，这就是 Dropout 的训练预测不一致问题。</p><p>现在，我们就不难理解 R-Drop 了，它通过增加一个正则项，来强化模型对 Dropout 的鲁棒性，使得不同的 Dropout 下模型的输出基本一致，因此能降低这种不一致性，促进“模型平均”与“权重平均”的相似性，从而使得简单关闭 Dropout 的效果等价于多 Dropout 模型融合的结果，提升模型最终性能。</p><h3 id="4-2-连续性"><a href="#4-2-连续性" class="headerlink" title="4.2 连续性"></a>4.2 连续性</h3><p>本文开头就提到 R-Drop 与 SimCSE 的相似性，事实上它还跟另外一个方法相当相似，那便是“虚拟对抗训练（Virtual Adversarial Training，VAT）”。（不过 R-Drop 也没引 VAT，难道就只有笔者觉得像吗？？）</p><p>关于 VAT 的介绍，大家可以参考笔者之前的文章<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&amp;mid=2247507771&amp;idx=1&amp;sn=b92559c624c7c58e77a11c89bec5e99a&amp;chksm=96ea00bba19d89adb05dd98193e7371d43f090fcaf6be401e01c0109beee7920e84cb13274c9&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">泛化性乱弹：从随机噪声、梯度惩罚到虚拟对抗训练</a>。简单来说，VAT 也是通过一个正则项，使得模型对扰动更加鲁棒，增强模型本身的连续性（小的变化不至于对结果产生大的影响）。它们不同的地方在于加扰动的方式，VAT 只把扰动加入到输入中，并且通过对抗的思想提升扰动的针对性；R-Drop 的扰动则可以施加到模型的每一层中，并且扰动是随机的。</p><p>有读者可能想到了，VAT 可是主打半监督训练的，那是不是意味着 R-Drop 也可以做半监督训练？这部分原论文并没有实验，是笔者自己做的实验，答案是确实可以，跟 VAT 类似，R-Drop 新增的 KL 散度项是不需要标签的，因此可以无监督训练，混合起来就是半监督了，效果也还不错。下面是笔者的实验结果：</p><p><img src="https://i.loli.net/2021/07/05/UT8bI3qG54D19wt.png" alt="image-20210705113103693" style="zoom:50%;"></p><p>可以看到，R-Drop 的半监督效果完全不逊色于 VAT，而且它实现比 VAT 简单，速度也比 VAT 快！看来 VAT 有望退休了～ 直觉上来看，虽然 R-Drop 的扰动是随机的，但是 R-Drop 的扰动更多，所以它造成的扰动也会放大，也可能比得上 VAT 经过对抗优化的扰动，所以 R-Drop 能够不逊色于 VAT。</p><h3 id="4-3-非目标类"><a href="#4-3-非目标类" class="headerlink" title="4.3 非目标类"></a>4.3 非目标类</h3><p>一个比较直接的疑问是，如果我的模型够复杂，单靠交叉熵这一项，不能使得模型对 Dropout 鲁棒吗？KL 散度那一项造成了什么直接的区别？</p><p>事实上，还真的不能。要注意的是，交叉熵的训练目标主要是：让目标类的得分大于非目标类的得分，这样模型就能正确地把目标类预测出来了（参考<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&amp;mid=2247505145&amp;idx=1&amp;sn=42467a5475b64d3031a46594261600d2&amp;chksm=96ea0b79a19d826fb7e040968bbe928daf528d38e63d916b05cbc60a5d350755e619abc2aff8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">将“softmax+交叉熵”推广到多标签分类问题</a>）。也就是说，如果只有交叉熵这一项，模型的训练结果顶多是：</p><blockquote><p>不同的 Dropout 下，目标类的得分都大于非目标类的得分。</p></blockquote><p>而不能做到：</p><blockquote><p>不同的 Dropout 下，每个类的得分一致。</p></blockquote><p>所以也就没有解决训练预测不一致的问题。从公式上来看，交叉熵（2）只跟目标类别有关，不关心非目标类的分布，假如目标类为第一个类别，那么预测结果是 [0.5, 0.2, 0.3] 或 [0.5, 0.3, 0.2]，对它来说都没区别。但对于 KL 散度项（3）来说就不一样了，每个类的得分都要参与计算，[0.5, 0.2, 0.3] 或 [0.5, 0.3, 0.2] 是有非零损失的。</p><h2 id="5-本文小结"><a href="#5-本文小结" class="headerlink" title="5. 本文小结"></a>5. 本文小结</h2><p>本文介绍了 R-Drop，它将“Dropout 两次”的思想用到了有监督任务中，每个实验结果几乎都取得了明显的提升。此外，笔者在自己的实验还发现，它在半监督任务上也能有不俗的表现。最后，分享了笔者对 R-Drop 的三个角度的思考。</p><h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h2><p>[1] <a href="https://kexue.fm/archives/8348" target="_blank" rel="noopener">https://kexue.fm/archives/8348</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来源：&lt;a href=&quot;https://mp.weixin.qq.com/s/IvhGbFEMotpKJIUPExUklg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/IvhGbFEMotpKJIUP
      
    
    </summary>
    
      <category term="NLP, ML" scheme="http://yoursite.com/categories/NLP-ML/"/>
    
    
      <category term="NLP, ML" scheme="http://yoursite.com/tags/NLP-ML/"/>
    
  </entry>
  
  <entry>
    <title>Unifying Vision-and-Language Tasks via Text Generation</title>
    <link href="http://yoursite.com/2021/07/03/Unifying-Vision-and-Language-Tasks-via-Text-Generation/"/>
    <id>http://yoursite.com/2021/07/03/Unifying-Vision-and-Language-Tasks-via-Text-Generation/</id>
    <published>2021-07-03T10:16:18.000Z</published>
    <updated>2021-07-08T13:26:28.927Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/j-min/VL-T5" target="_blank" rel="noopener">code</a></p><h2 id="当前跨模态预训练模型存在的问题"><a href="#当前跨模态预训练模型存在的问题" class="headerlink" title="当前跨模态预训练模型存在的问题"></a>当前跨模态预训练模型存在的问题</h2><ul><li>当前跨模态预训练模型在做下游任务时，通常都是根据特定任务设计相应的 head 和 objective。例如，a multi-label answer classifier for visual question answering, a region scorer for referring expression comprehension, and a language decoder for image captioning.</li></ul><h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><p>为了避免复杂的设计，本文提出了一个联合框架，可以在同一个结构中学习不同的任务。<strong style="color:red;">具体地，本文将判别式任务和生成式任务都转化为 Text  Generation task。</strong>本文的这种方法达到了近似SOTA的效果。</p><p>同时本文提出的框架可以在<strong>同一个参数</strong>下进行多任务训练，这种设置下，可以实现与单独训练特定任务达到相似的性能。(yaya解释，意思是说，这个模型在多任务的设置下训练之后，可以直接拿来去做各种任务，与单独训练特定任务的效果近似)</p><p>这种范式的好处：</p><ul><li>不需要为特定任务设计特定的head</li><li>对于一个新的任务，通过对input and output 进行 text rewrite即可，而不需要增加额外的参数或者是设计新的结构和训练目标。</li><li>由于预训练任务是生成式任务，因此相比于MLM这种理解型任务，文本生成能力更强。比如，当我们回答需要非简单答案的开放式问题时，这一点尤其有帮助，在这种情况下，判别性方法只能从<strong>预定义的频繁候选者集合中</strong>回答，而我们的模型可以生成开放式的自然语言答案。</li></ul><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>整体上，模型基于NLP的 T5 和 BART的 backbone 来设计。下图中以T5为例。</p><p>类似于T5，针对特定的任务，在输入文本的前面追加了关于任务的描述（task description）, 如下图中的 visual grounding.</p><p>模型设计上的一个比较特殊的点：we use the text embeddings of visual sentinel tokens as region id embeddings in Sec. 3.1. The embedding sharing enables our model to build the correspondence among query text, label text, and objects, which are useful in the grounding tasks。</p><p><img src="https://i.loli.net/2021/07/08/Yr5dLpGUzo6Rtl2.png" alt="image-20210708203404311"></p><h2 id="推理"><a href="#推理" class="headerlink" title="推理"></a>推理</h2><p>与T5类似，无论是判别式任务或是生成式任务，都会以自回归的生成式方式来解决。</p><p>如下图(a) 和 图(b) 以前的跨模态预训练模型需要为特定的任务设计特定的head, 但是，本文的方法，图(c) 和 图(d)  都以language modeling 生成式的方式来做。</p><p>we <font color="red"> <strong>formulate the task labels to corresponding text</strong></font>, and we learn these dif- ferent tasks by predicting label text with the same language modeling objective</p><p><img src="https://i.loli.net/2021/07/08/xFwyLG16aPCNMir.png" alt="image-20210708204113897"></p><h2 id="预训练任务"><a href="#预训练任务" class="headerlink" title="预训练任务"></a>预训练任务</h2><p>下图给出了预训练任务和下游任务的输入数据的格式</p><p>预训练任务中图文匹配任务也转化为生成 true/false。</p><p>预训练任务中 caption region 这个倒是挺新颖的</p><p>下游任务中，对于VQA and GQA 这两个任务，以前的方式都是多项选择的方式，但是本文中采用的是生成的方式。</p><p><img src="https://i.loli.net/2021/07/08/6z5B19PCcUJQbxT.png" alt="image-20210708204838585"></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>实验一，预训练后的模型在各个下游任务上分别微调</p><p><img src="https://i.loli.net/2021/07/08/oKvQEH2TeXAz8LO.png" alt="image-20210708212303877"></p><p>实验二，微调下游任务时，采取多任务一起微调的方式</p><p>多任务一起微调效果也很不错，实现了一个模型参数可以处理多个任务，且不需要特定的head!!!</p><p><img src="C:\Users\shiyaya\AppData\Roaming\Typora\typora-user-images\image-20210708212215025.png" alt="image-20210708212215025"></p><h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><ul><li>存在的缺陷：不是端到端的，需要预先使用 faster r-cnn 提取 proposals; 虽然 ViLT是端到端的，但是ViLT 不方便做 visual grounding task。</li><li><font color="green">预训练任务中，有一个visual grounding task, 但是，region description 是如何得到的？？论文中有讲，但是没有看懂</font></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/j-min/VL-T5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;code&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;当前跨模态预训练模型存在的问题&quot;&gt;&lt;a href=&quot;#当前跨模态预训练模型存在的问题&quot; 
      
    
    </summary>
    
      <category term="croos-moal" scheme="http://yoursite.com/categories/croos-moal/"/>
    
    
      <category term="cross-modal" scheme="http://yoursite.com/tags/cross-modal/"/>
    
  </entry>
  
  <entry>
    <title>Zero-Shot Detection via Vision and Language Knowledge Distillation</title>
    <link href="http://yoursite.com/2021/06/25/Zero-Shot-Detection-via-Vision-and-Language-Knowledge-Distillation/"/>
    <id>http://yoursite.com/2021/06/25/Zero-Shot-Detection-via-Vision-and-Language-Knowledge-Distillation/</id>
    <published>2021-06-25T09:28:47.000Z</published>
    <updated>2021-07-19T03:36:39.594Z</updated>
    
    <content type="html"><![CDATA[<p>来源：<a href="https://zhuanlan.zhihu.com/p/369153230" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/369153230</a></p><p>今年年初刚出的CLIP可以说是震惊了NLP和CV界，它让大白话搜图不再是梦想，就像这样：</p><p><img src="https://i.loli.net/2021/07/19/sXp4lcNJHfdTg6a.png" alt="image-20210719102532427" style="zoom:67%;"></p><p>以上是一个老哥用CLIP在unsplash数据集上做的大白话搜图引擎，有兴趣的同学们可以去感受一下：</p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/haltakov/natural-language-image-search" target="_blank" rel="noopener">natural-language-image-searchgithub.com</a></p><p>其实CLIP做的事情很简单，简单说来就是<strong>学习出了一个图像和文本的共同空间</strong>，给定任意图像和文本都可以映射到这个空间中，然后这些图像和文本就可以<strong>直接计算相似度</strong>，于是就可以做到用大白话来搜图。换句话说，CLIP找到了一个方式<strong>填平了文本和视觉的gap</strong>。</p><p>那既然如此，可不可以进一步拓展，利用CLIP来做检测，比如我随便说一句话就可以检测出图像里面对应的物体，不管我这句话里面的物体属于任意类别呢？当然可以！而且谷歌已经做出来了，就在前天挂上了arXiv，不得不感叹他们真的太快了（CLIP才出了3个月啊）</p><p>这篇文章的名字就叫<strong>Zero-Shot Detection via Vision and Language Knowledge Distillation。</strong>zero-shot顾名思义，就是对于一个新类别，一张训练图像都不给的情况下训练出能检测这个类别物体的检测器；而knowledge distillation呢，指的就是从CLIP中蒸馏出知识来训练检测器（毕竟CLIP用了4亿个文本-图像对训练，肯定得好好利用啊）。</p><p>这个方法的名字叫做ViLD（Vision and Language knowledge Distillation），首先感受一下它的效果：</p><p><img src="https://i.loli.net/2021/07/19/QcueiMgxDAGhk2H.png" alt="image-20210719102620483"></p><p>这些玩具都是训练集里没有出现过的类别哦。</p><p>那么ViLD是怎么做的呢？框架图先贴出来：</p><p><img src="https://i.loli.net/2021/07/19/5g479jOJ2PB6ikQ.png" alt="image-20210719102700196"></p><p>定位网络用的是Mask R-CNN，BackBone提特征图，RPN提proposal，然后RoiAlign提proposal的特征就不用多说了。</p><p>训练时，重点在图像会用proposal进行裁剪，裁剪下来的图像会送入预训练好的CLIP中得到在其<strong>共同空间</strong>中的特征，训练的目标就是<strong>拉近proposal特征和CLIP得到的裁剪图像特征的距离</strong>，这个训练可以认为是一种蒸馏，把CLIP中的知识传递给了训练的模型。这样训练好的模型提取出的proposal特征也可以认为已经在CLIP的共同空间中了。这一部分对应于图中上半部分的Training<strong>。</strong></p><p>测试时，先把需要分类的文本标签通过其在CLIP共同空间的特征。然后图像中的proposal特征就可以<strong>直接与这些文本标签特征进行相似度计算</strong>（因为它们可以假设都位于CLIP的共同空间中），完成分类。</p><p>具体来看训练时候是怎么做的：</p><p><img src="https://i.loli.net/2021/07/19/WnESNvxVQCYmKRg.png" alt="image-20210719102730131"></p><p>直接看（b）部分，其中的ViLD-text部分就是在文本模态进行训练，比如当前的proposal对应的类别为“猫”，那么相应的，这个proposal特征应该和CLIP对“猫”这个文本生成的在共同空间中的特征相近。</p><p>ViLD-image则是在视觉模态进行训练，即proposal特征应该和根据这个proposal裁剪下来的图像在CLIP的共同空间的特征相近。</p><p>总结一下，就是在两个模态上对CLIP进行知识蒸馏，目的是将proposal特征映射到CLIP的共同空间中，其中文本模态由类别标签得到，视觉模态由裁剪的图像得到。</p><p>说下自己的感受吧，这个idea本来我刚刚想到，结果现在看到这篇文章，心里还是暗喜还好没开始做hhhhh。更多还是感叹大厂的速度是真的快，仅仅三个月就整出来了完成度和创新度都很不错的一篇文章。另外利用CLIP做跨模态肯定是以后的趋势了，毕竟用了4亿图像-文本对训练出来的模型填平了视觉和文本的gap，绝对大有搞头。</p><h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><p>本文使用了两个损失，一个是L1 loss,用于知识蒸馏，而cross entropy loss 则是为了使用CLIP预测的范式（使用匹配的方式来做分类预测）。</p><p>这两个损失是缺一不可的，仅使用L1 loss 来知识蒸馏是没有任何用的，因为这里并不是想获取更好的视觉特征，而是使用clip的预测范式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来源：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/369153230&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/369153230&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今年年初
      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
    
      <category term="目标检测" scheme="http://yoursite.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>理解对比学习和 SimCSE</title>
    <link href="http://yoursite.com/2021/06/22/%E7%90%86%E8%A7%A3%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0%E5%92%8C-SimCSE/"/>
    <id>http://yoursite.com/2021/06/22/理解对比学习和-SimCSE/</id>
    <published>2021-06-22T13:03:55.000Z</published>
    <updated>2021-06-22T13:19:19.187Z</updated>
    
    <content type="html"><![CDATA[<p>来源：<a href="https://mp.weixin.qq.com/s/12UvfXnaB4NTy54wWIFZdQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/12UvfXnaB4NTy54wWIFZdQ</a></p><p>2020 年的 Moco 和 SimCLR 等，掀起了对比学习在 CV 领域的热潮，2021 年的 SimCSE，则让 NLP 也乘上了对比学习的东风。下面就尝试用 QA 的形式挖掘其中一些细节知识点，去更好地理解对比学习和 SimCSE。</p><ul><li><p>如何去理解对比学习，它和度量学习的差别是什么？</p></li><li><p>对比学习中一般选择一个 batch 中的所有其他样本作为负例，那如果负例中有很相似的样本怎么办？</p></li><li><p>infoNCE loss 如何去理解，和 CE loss有什么区别？</p></li><li><p>对比学习的 infoNCE loss 中的温度常数的作用是什么？</p></li><li><p>SimCSE 中的 dropout mask 指的是什么，dropout rate 的大小影响的是什么？</p></li><li><p>SimCSE 无监督模式下的具体实现流程是怎样的，标签生成和 loss 计算如何实现？</p></li></ul><h2 id="1-如何去理解对比学习，它和度量学习的差别是什么？"><a href="#1-如何去理解对比学习，它和度量学习的差别是什么？" class="headerlink" title="1. 如何去理解对比学习，它和度量学习的差别是什么？"></a><strong>1. 如何去理解对比学习，它和度量学习的差别是什么？</strong></h2><p>对比学习的思想是去拉近相似的样本，推开不相似的样本，而目标是要从样本中学习到一个好的语义表示空间。</p><p>论文 [1] 给出的 “Alignment and Uniformity on the Hypersphere”，就是一个非常好的去理解对比学习的角度。</p><p>好的对比学习系统应该具备两个属性：Alignment和Uniformity（参考上图）。</p><p>所谓“Alignment”，指的是相似的例子，也就是正例，映射到单位超球面后，应该有接近的特征，也即是说，在超球面上距离比较近；</p><p>所谓“Uniformity”，指的是系统应该倾向在特征里保留尽可能多的信息，这等价于使得映射到单位超球面的特征，尽可能均匀地分布在球面上，分布得越均匀，意味着保留的信息越充分。分布均匀意味着两两有差异，也意味着各自保有独有信息，这代表信息保留充分（参考自 [2]）。</p><p>度量学习和对比学习的思想是一样的，都是去拉近相似的样本，推开不相似的样本。但是对比学习是无监督或者自监督学习方法，而度量学习一般为有监督学习方法。而且对比学习在 loss 设计时，为单正例多负例的形式，因为是无监督，数据是充足的，也就可以找到无穷的负例，但<font color="red">如何构造有效正例才是重点。</font></p><p>而度量学习多为二元组或三元组的形式，如常见的 Triplet 形式（anchor，positive，negative），Hard Negative 的挖掘对最终效果有较大的影响。</p><h2 id="2-对比学习中一般选择一个-batch-中的所有其他样本作为负例，那如果负例中有很相似的样本怎么办？"><a href="#2-对比学习中一般选择一个-batch-中的所有其他样本作为负例，那如果负例中有很相似的样本怎么办？" class="headerlink" title="2. 对比学习中一般选择一个 batch 中的所有其他样本作为负例，那如果负例中有很相似的样本怎么办？"></a>2. <strong>对比学习中一般选择一个 batch 中的所有其他样本作为负例，那如果负例中有很相似的样本怎么办？</strong></h2><p>在无监督无标注的情况下，这样的伪负例，其实是不可避免的，首先可以想到的方式是去扩大语料库，去加大 batch size，以降低 batch 训练中采样到伪负例的概率，减少它的影响。</p><p>另外，神经网络是有一定容错能力的，像伪标签方法就是一个很好的印证，但前提是错误标签数据或伪负例占较小的比例。</p><p>PS：也确有人考虑研究过这个问题，可以参考论文 [3] [4]</p><h2 id="3-infoNCE-loss-如何去理解，和-CE-loss-有什么区别？"><a href="#3-infoNCE-loss-如何去理解，和-CE-loss-有什么区别？" class="headerlink" title="3. infoNCE loss 如何去理解，和 CE loss 有什么区别？"></a>3. <strong>infoNCE loss 如何去理解，和 CE loss 有什么区别？</strong></h2><p><strong>infoNCE loss</strong> 全称 info Noise Contrastive Estimation loss，对于一个 batch 中的样本 i，它的 loss 为：</p><p><img src="https://i.loli.net/2021/06/22/Omj8YCPkqeWwyp4.png" alt="image-20210622211019708" style="zoom:50%;"></p><p>要注意的是，<font color="red">log 里面的分母叠加项是<strong>包括了分子项</strong>的。</font> 分子是正例对的相似度，分母是正例对+所有负例对的相似度，最小化 infoNCE loss，就是去最大化分子的同时最小化分母，也就是最大化正例对的相似度，最小化负例对的相似度。</p><p>上面公式直接看可能没那么清晰，可以把负号放进去，分子分母倒过来化简一下就会很明了了。</p><p><strong>CE loss</strong>，Cross Entropy loss，在输入 p 是 softmax 的输出时：</p><p><img src="https://i.loli.net/2021/06/22/YFIfqETp1S7Kg83.png" alt="image-20210622211041814" style="zoom:50%;"></p><p>在分类场景下，真实标签 y 一般为 one-hot 的形式，因此，CE loss 可以简化成（i 位置对应标签 1）：</p><p><img src="https://i.loli.net/2021/06/22/saTEDlBWg1uUNAp.png" alt="image-20210622211108963" style="zoom:50%;"></p><p>看的出来，info NCE loss 和在一定条件下简化后的 CE loss 是非常相似的，但有一个区别要注意的是：</p><p>infoNCE loss 中的 K 是 batch 的大小，是可变的，是第 i 个样本要和 batch 中的每个样本计算相似度，而 batch 里的每一个样本都会如此计算，因此上面公式只是样本 i 的 loss。</p><p>CE loss 中的 K 是分类类别数的大小，任务确定时是不变的，i 位置对应标签为 1 的位置。不过实际上，infoNCE loss 就是直接可以用 CE loss 去计算的。</p><p>注：1）info NCE loss 不同的实现方式下，它的计算方式和 K 的含义可能会有差异；2）info NCE loss 是基于 NCE loss 的，对公式推导感兴趣的可以参考 [5]。</p><h2 id="4-对比学习的-infoNCE-loss-中的温度常数-t-的作用是什么？"><a href="#4-对比学习的-infoNCE-loss-中的温度常数-t-的作用是什么？" class="headerlink" title="4. 对比学习的 infoNCE loss 中的温度常数 t 的作用是什么？"></a>4. <strong>对比学习的 infoNCE loss 中的温度常数 t 的作用是什么？</strong></h2><p>论文 [6] 给出了非常细致的分析，知乎博客 [7] 则对论文 [6] 做了细致的解读，这里摘录它的要点部分：</p><p>温度系数的作用是调节对困难样本的关注程度：<strong>越小的温度系数越关注于将本样本和最相似的困难样本分开</strong>，去得到更均匀的表示。然而困难样本往往是与本样本相似程度较高的，很多困难负样本其实是潜在的正样本，过分强迫与困难样本分开会破坏学到的潜在语义结构，因此，温度系数不能过小。</p><p>考虑两个极端情况，温度系数趋向于 0 时，对比损失退化为只关注最困难的负样本的损失函数；当温度系数趋向于无穷大时，对比损失对所有负样本都一视同仁，失去了困难样本关注的特性。</p><p>还有一个角度：</p><p>可以把不同的负样本想像成同极点电荷在不同距离处的受力情况，距离越近的点电荷受到的库伦斥力更大，而距离越远的点电荷受到的斥力越小。</p><p>对比损失中，越近的负例受到的斥力越大，具体的表现就是对应的负梯度值越大 [4]。这种性质更有利于形成在超球面均匀分布的特征。</p><p>对照着公式去理解：</p><p><img src="https://i.loli.net/2021/06/22/QTPnuCLMc6Ug1sb.png" alt="image-20210622211420543" style="zoom:33%;"></p><p>温度系数很小时，越相似也即越困难的负例，对应的 就会越大，在分母叠加项中所占的比重就会越大，对整体 loss 的影响就会越大，具体的表现就是对应的负梯度值越大 [7]。</p><p>当然，这仅仅是提供了一种定性的认识，定量的认识和推导可以参见博客 [7]。</p><h2 id="5-SimCSE-中的-dropout-mask-指的是什么，dropout-rate-的大小影响的是什么？"><a href="#5-SimCSE-中的-dropout-mask-指的是什么，dropout-rate-的大小影响的是什么？" class="headerlink" title="5. SimCSE 中的 dropout mask 指的是什么，dropout rate 的大小影响的是什么？"></a>5. <strong>SimCSE 中的 dropout mask 指的是什么，dropout rate 的大小影响的是什么？</strong></h2><p>一般而言的 mask 是对 token 级别的 mask，比如说 BERT MLM 中的 mask，batch 训练时对 padding 位的 mask 等。</p><p>SimCSE 中的 dropout mask，对于 BERT 模型本身，是一种网络模型的随机，是对网络参数 W 的 mask，起到防止过拟合的作用。</p><p>而 SimCSE 巧妙的把它作为了一种 noise，起到数据增强的作用，因为同一句话，经过带 dropout 的模型两次，得到的句向量是不一样的，但是因为是相同的句子输入，最后句向量的语义期望是相同的，因此作为正例对，让模型去拉近它们之间的距离。</p><p>在实现上，因为一个 batch 中的任意两个样本，经历的 dropout mask 都是不一样的，因此，一个句子过两次 dropout，SimCSE 源码中实际上是在一个 batch 中实现的，即 [a,a,b,b…] 作为一个 batch 去输入。</p><p>dropout rate 大小的影响，可以理解为，这个概率会对应有 dropout 的句向量相对无 dropout 句向量，在整个单位超球体中偏移的程度，因为 BERT 是多层的结构，每一层都会有 dropout，这些 noise 的累积，会让句向量在每个维度上都会有偏移的，只是 p 较小的情况下，两个向量在空间中仍较为接近，如论文所说，“keeps a steady alignment”，保证了一个稳定的对齐性。</p><h2 id="6-SimCSE-无监督模式下的具体实现流程是怎样的，标签生成和-loss-计算如何实现？"><a href="#6-SimCSE-无监督模式下的具体实现流程是怎样的，标签生成和-loss-计算如何实现？" class="headerlink" title="6. SimCSE 无监督模式下的具体实现流程是怎样的，标签生成和 loss 计算如何实现？"></a>6. <strong>SimCSE 无监督模式下的具体实现流程是怎样的，标签生成和 loss 计算如何实现？</strong></h2><p>这里用一个简单的例子和 Pytorch 代码来说明：</p><p><strong>前向句子 embedding 计算：</strong></p><p>假设初始输入一个句子集 sents = [a,b]，每一句要过两次 BERT，因此复制成 sents = [a,a,b,b]。</p><p>sents 以 batch 的形式过 BERT 等语言模型得到句向量：batch_emb = [a1,a2,b1,b2]。</p><p><strong>batch 标签生成：</strong>标签为 1 的地方是相同句子不同 embedding 对应的位置。</p><p><img src="https://i.loli.net/2021/06/22/bE15TPnoGCRvFZk.png" alt="image-20210622211637062" style="zoom: 33%;"></p><p>pytorch 中的 CE_loss，要使用一维的数字标签，上面的 one-hot 标签可转换成：[1,0,3,2]。</p><p>可以把 label 拆成两个部分：奇数部分 [1,3…] 和偶数部分 [0,2…]，交替的每个奇数在偶数前面。因此实际生成的时候，可以分别生成两个部分再 concat 并 reshape 成一维。</p><p>pytorch 中 label 的生成代码如下：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构造标签</span></span><br><span class="line"><span class="keyword">batch</span>_size = <span class="keyword">batch</span>_emb.size<span class="params">(0)</span></span><br><span class="line">y_<span class="literal">true</span> = torch.cat<span class="params">([torch.arange(1,batch_size,<span class="attr">step</span>=2,<span class="attr">dtype</span>=torch.long)</span><span class="string">.unsqueeze</span><span class="params">(1)</span>,</span><br><span class="line">                    torch.arange<span class="params">(0,batch_size,<span class="attr">step</span>=2,<span class="attr">dtype</span>=torch.long)</span><span class="string">.unsqueeze</span><span class="params">(1)</span>],</span><br><span class="line">                    dim=1)<span class="string">.reshape</span><span class="params">([batch_size,])</span></span><br></pre></td></tr></table></figure><p><strong>score 和 loss计算：</strong></p><p>batch_emb 会先 norm，再计算任意两个向量之间的点积，得到向量间的余弦相似度，维度是：[batch_size, batch_size]。</p><p>但是对角线的位置，也就是自身的余弦相似度，需要 mask 掉，因为它肯定是 1，是不产生 loss 的。</p><p>然后，要除以温度系数，再进行 loss 的计算，loss_func 采用 CE loss，注意 CE loss 中是自带 softmax 计算的。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算score和loss</span></span><br><span class="line"><span class="attr">norm_emb</span> = F.normalize(batch_emb, dim=<span class="number">1</span>, p=<span class="number">2</span>)</span><br><span class="line"><span class="attr">sim_score</span> = torch.matmul(norm_emb, norm_emb.transpose(<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="attr">sim_score</span> = sim_score - torch.eye(batch_size) * <span class="number">1</span>e12</span><br><span class="line"><span class="attr">sim_score</span> = sim_score * <span class="number">20</span>        <span class="comment"># 温度系数为 0.05，也就是乘以20</span></span><br><span class="line"><span class="attr">loss</span> = loss_func(sim_score, y_<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">loss_func</span> = nn.CrossEntropyLoss()</span><br><span class="line">def simcse_loss(batch_emb):</span><br><span class="line">    <span class="string">""</span><span class="string">"用于无监督SimCSE训练的loss</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    <span class="comment"># 构造标签</span></span><br><span class="line">    <span class="attr">batch_size</span> = batch_emb.size(<span class="number">0</span>)</span><br><span class="line">    <span class="attr">y_true</span> = torch.cat([torch.arange(<span class="number">1</span>, batch_size, <span class="attr">step=2,</span> <span class="attr">dtype=torch.long).unsqueeze(1),</span></span><br><span class="line">                        torch.arange(<span class="number">0</span>, batch_size, <span class="attr">step=2,</span> <span class="attr">dtype=torch.long).unsqueeze(1)],</span></span><br><span class="line">                       <span class="attr">dim=1).reshape([batch_size,])</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算score和loss</span></span><br><span class="line">    <span class="attr">norm_emb</span> = F.normalize(batch_emb, <span class="attr">dim=1,</span> <span class="attr">p=2)</span></span><br><span class="line">    <span class="attr">sim_score</span> = torch.matmul(norm_emb, norm_emb.transpose(<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">    <span class="attr">sim_score</span> = sim_score - torch.eye(batch_size) * <span class="number">1</span>e12</span><br><span class="line">    <span class="attr">sim_score</span> = sim_score * <span class="number">20</span></span><br><span class="line">    <span class="attr">loss</span> = loss_func(sim_score, y_true)</span><br><span class="line">    return loss</span><br></pre></td></tr></table></figure><p>注：看过论文源码 [8] 的同学可能会发现，这个和论文源码中的实现方式不一样，论文源码是为了兼容无监督 SimCSE 和有监督 SimCSE，并兼容有 hard negative 的三句输入设计的，因此实现上有差异。</p><p>看过苏神源码 [9] 的同学也会发现，构造标签的地方不一样，那是因为 keras 的 CE loss 用的是 one-hot 标签，pytorch 用的是数字标签，但本质一样。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] Understanding Contrastive Representation Learning through Alignment and Uniformity on the Hypersphere</p><p>[2] <a href="https://zhuanlan.zhihu.com/p/367290573" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/367290573</a></p><p>[3] Debiased Contrastive Learning</p><p>[4] ADACLR: Adaptive Contrastive Learning Of Representation By Nearest Positive Expansion</p><p>[5] <a href="https://zhuanlan.zhihu.com/p/334772391" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/334772391</a></p><p>[6] Understanding the Behaviour of Contrastive Loss</p><p>[7] <a href="https://zhuanlan.zhihu.com/p/357071960" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/357071960</a></p><p>[8] <a href="https://github.com/princeton-nlp/SimCSE" target="_blank" rel="noopener">https://github.com/princeton-nlp/SimCSE</a></p><p>[9] <a href="https://github.com/bojone/SimCSE" target="_blank" rel="noopener">https://github.com/bojone/SimCSE</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来源：&lt;a href=&quot;https://mp.weixin.qq.com/s/12UvfXnaB4NTy54wWIFZdQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/12UvfXnaB4NTy54w
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GEM: A General Evaluation Benchmark for Multimodal Tasks</title>
    <link href="http://yoursite.com/2021/06/22/GEM-A-General-Evaluation-Benchmark-for-Multimodal-Tasks/"/>
    <id>http://yoursite.com/2021/06/22/GEM-A-General-Evaluation-Benchmark-for-Multimodal-Tasks/</id>
    <published>2021-06-22T00:53:34.000Z</published>
    <updated>2021-06-22T01:54:52.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><ul><li><p>类似于 GLUE，SuperGLUE 这种 language evaluation benchmark 可以评估纯语言预训练模型的能力，但是多模态方向上，多模态预训练模型的能力还没有相关的benchmark，本文提出了 <font color="red">多模态任务上 evaluation benchmark：<strong>GEM</strong>。</font></p></li><li><p>本文的多模态任务，包括 image-text <strong>GEM-I</strong>; video-text <strong>GEM-V</strong>。同时相比于当前存在的多模态数据集（例如 MSCOCO，Flickr30K，YouCook2, MSR-VTT）， <font color="red"><strong>GEM</strong> 规模上更大，且涵盖多种语言。</font></p></li><li><p>本文提供了两个多模态多语言预训练模型, <a href="https://arxiv.org/abs/2006.02635" target="_blank" rel="noopener">M3P</a> and <a href="https://arxiv.org/abs/2002.06353" target="_blank" rel="noopener">m-UniVL</a> 作为 GEM 的baseline. M3P是一个现成的多语言， image-text 预训练模型，m-UniVL是 本文对video-text预训练模型 UniVL 做的扩展</p></li></ul><h2 id="相关论文"><a href="#相关论文" class="headerlink" title="相关论文"></a>相关论文</h2><p>总结一下多模态预训练模型中，<strong>包含多语言</strong>的一些模型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;本文的点&quot;&gt;&lt;a href=&quot;#本文的点&quot; class=&quot;headerlink&quot; title=&quot;本文的点&quot;&gt;&lt;/a&gt;本文的点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;类似于 GLUE，SuperGLUE 这种 language evaluation benchmark 可
      
    
    </summary>
    
      <category term="cross-modal" scheme="http://yoursite.com/categories/cross-modal/"/>
    
    
      <category term="cross-modal" scheme="http://yoursite.com/tags/cross-modal/"/>
    
  </entry>
  
</feed>
