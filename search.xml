<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mmdetection的安装</title>
      <link href="/2019/07/20/mmdetection%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2019/07/20/mmdetection%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li><p>选择镜像（cuda9.0）：py36-pytorch0.4.0-cu90-ctc </p></li><li><p>进入容器，安装anaconda</p></li></ul><h3 id="按着Github-install的步骤进行安装如下："><a href="#按着Github-install的步骤进行安装如下：" class="headerlink" title="按着Github install的步骤进行安装如下："></a>按着<a href="https://github.com/open-mmlab/mmdetection/blob/master/INSTALL.md" target="_blank" rel="noopener">Github install</a>的步骤进行安装如下：</h3><ul><li><p>Create a conda virtual environment and activate it. Then install Cython.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conda create -n open-mmlab python=<span class="number">3.7</span> -y</span><br><span class="line">conda activate open-mmlab</span><br><span class="line"></span><br><span class="line">conda install cython</span><br></pre></td></tr></table></figure></li><li><p>安装<a href="https://github.com/open-mmlab/mmcv" target="_blank" rel="noopener">mmcv</a> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install mmcv</span><br></pre></td></tr></table></figure></li><li><p>安装pytorch<br>最好是离线下载，然后再安装，因为conda install 或者 pip install 可能连接不上（细节：pip install torch  就会出现下载链接，然后自己复制链接去网页下载即可），下载之后：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">pip</span> <span class="selector-tag">install</span> <span class="selector-tag">torch-1</span><span class="selector-class">.1</span><span class="selector-class">.0-cp37-cp37m-manylinux1_x86_64</span><span class="selector-class">.whl</span></span><br></pre></td></tr></table></figure></li><li><p>安装opencv</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="keyword">install</span> -c menpo opencv</span><br></pre></td></tr></table></figure></li><li><p>Clone the mmdetection repository.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/open-mmlab/mmdetection.git</span><br><span class="line">cd mmdetection</span><br></pre></td></tr></table></figure></li><li><p>Install mmdetection</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py develop</span><br></pre></td></tr></table></figure></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 目标检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>torch.no_grad</title>
      <link href="/2019/07/17/torch-no-grad/"/>
      <url>/2019/07/17/torch-no-grad/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://discuss.pytorch.org/t/model-eval-vs-with-torch-no-grad/19615/21" target="_blank" rel="noopener">https://discuss.pytorch.org/t/model-eval-vs-with-torch-no-grad/19615/21</a></li><li>with torch.no_grad()</li><li>可以减少内存，加快运行速度，同时可以使得batch_size 增大</li><li>但不是说非得必要</li></ul>]]></content>
      
      
      <categories>
          
          <category> pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spacy工具包</title>
      <link href="/2019/07/16/Spacy%E5%B7%A5%E5%85%B7%E5%8C%85/"/>
      <url>/2019/07/16/Spacy%E5%B7%A5%E5%85%B7%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="spaCy的主要操作："><a href="#spaCy的主要操作：" class="headerlink" title="spaCy的主要操作："></a>spaCy的主要操作：</h2><h3 id="1、分词断句"><a href="#1、分词断句" class="headerlink" title="1、分词断句"></a>1、分词断句</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import spacy</span><br><span class="line">nlp = spacy.<span class="built_in">load</span>(<span class="string">'en'</span>)</span><br><span class="line">doc = nlp(<span class="string">'Hello World! My name is HanXiaoyang'</span>)</span><br><span class="line"><span class="comment"># 分词</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">token</span> <span class="keyword">in</span> doc:</span><br><span class="line">    print(<span class="string">'"'</span> + <span class="keyword">token</span>.<span class="keyword">text</span> + <span class="string">'"'</span>)</span><br><span class="line"><span class="comment"># 断句</span></span><br><span class="line"><span class="keyword">for</span> sent <span class="keyword">in</span> doc.sents:</span><br><span class="line">    print(sent)</span><br></pre></td></tr></table></figure><p>每个token对象有着非常丰富的属性，如下的方式可以取出其中的部分属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">doc</span> <span class="string">=</span> <span class="string">nlp("Next</span> <span class="string">week</span> <span class="string">I'll</span>   <span class="string">be</span> <span class="string">in</span> <span class="string">Shanghai.")</span></span><br><span class="line"><span class="string">for</span> <span class="string">token</span> <span class="string">in</span> <span class="attr">doc:</span></span><br><span class="line">    <span class="string">print("&#123;0&#125;\t&#123;1&#125;\t&#123;2&#125;\t&#123;3&#125;\t&#123;4&#125;\t&#123;5&#125;\t&#123;6&#125;\t&#123;7&#125;".format(</span></span><br><span class="line">        <span class="string">token.text,</span></span><br><span class="line">        <span class="string">token.idx,</span></span><br><span class="line">        <span class="string">token.lemma_,</span></span><br><span class="line">        <span class="string">token.is_punct,</span></span><br><span class="line">        <span class="string">token.is_space,</span></span><br><span class="line">        <span class="string">token.shape_,</span></span><br><span class="line">        <span class="string">token.pos_,</span></span><br><span class="line">        <span class="string">token.tag_</span></span><br><span class="line">    <span class="string">))</span></span><br><span class="line"><span class="string">输出结果如下：</span></span><br><span class="line"><span class="string">Next</span>    <span class="number">0</span>   <span class="string">next</span>    <span class="literal">False</span>   <span class="literal">False</span>   <span class="string">Xxxx</span>    <span class="string">ADJ</span> <span class="string">JJ</span></span><br><span class="line"><span class="string">week</span>    <span class="number">5</span>   <span class="string">week</span>    <span class="literal">False</span>   <span class="literal">False</span>   <span class="string">xxxx</span>    <span class="string">NOUN</span>    <span class="string">NN</span></span><br><span class="line"><span class="string">I</span>   <span class="number">10</span>  <span class="bullet">-PRON-</span>  <span class="literal">False</span>   <span class="literal">False</span>   <span class="string">X</span>   <span class="string">PRON</span>    <span class="string">PRP</span></span><br><span class="line"><span class="string">'ll 11  will    False   False   '</span><span class="string">xx</span> <span class="string">VERB</span>    <span class="string">MD</span></span><br><span class="line">    <span class="number">15</span>      <span class="literal">False</span>   <span class="literal">True</span>        <span class="string">SPACE</span>   <span class="string">_SP</span></span><br><span class="line"><span class="string">be</span>  <span class="number">17</span>  <span class="string">be</span>  <span class="literal">False</span>   <span class="literal">False</span>   <span class="string">xx</span>  <span class="string">VERB</span>    <span class="string">VB</span></span><br><span class="line"><span class="string">in</span>  <span class="number">20</span>  <span class="string">in</span>  <span class="literal">False</span>   <span class="literal">False</span>   <span class="string">xx</span>  <span class="string">ADP</span> <span class="string">IN</span></span><br><span class="line"><span class="string">Shanghai</span>    <span class="number">23</span>  <span class="string">shanghai</span>    <span class="literal">False</span>   <span class="literal">False</span>   <span class="string">Xxxxx</span>   <span class="string">PROPN</span>   <span class="string">NNP</span></span><br><span class="line"><span class="string">.</span>   <span class="number">31</span>  <span class="string">.</span>   <span class="literal">True</span>    <span class="literal">False</span>   <span class="string">.</span>   <span class="string">PUNCT</span>   <span class="string">.</span></span><br></pre></td></tr></table></figure><h3 id="2、词性标注"><a href="#2、词性标注" class="headerlink" title="2、词性标注"></a>2、词性标注</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 词性标注</span></span><br><span class="line">doc = nlp(<span class="string">"Next week I'll be in Shanghai."</span>)</span><br><span class="line">print([(<span class="keyword">token</span>.<span class="keyword">text</span>, <span class="keyword">token</span>.tag_) <span class="keyword">for</span> <span class="keyword">token</span> <span class="keyword">in</span> doc])</span><br></pre></td></tr></table></figure><p>[(‘Next’, ‘JJ’), (‘week’, ‘NN’), (‘I’, ‘PRP’), (“‘ll”, ‘MD’), (‘be’, ‘VB’), (‘in’, ‘IN’), (‘Shanghai’, ‘NNP’), (‘.’, ‘.’)]</p><h3 id="3、组块分析"><a href="#3、组块分析" class="headerlink" title="3、组块分析"></a>3、组块分析</h3><p>spaCy可以自动检测名词短语，并输出根(root)词，比如下面的”Journal”,”piece”,”currencies”</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doc = nlp(<span class="string">"Wall Street Journal just published an interesting piece on crypto currencies"</span>)</span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> doc<span class="selector-class">.noun_chunks</span>:</span><br><span class="line">    print(chunk<span class="selector-class">.text</span>, chunk<span class="selector-class">.label_</span>, chunk<span class="selector-class">.root</span><span class="selector-class">.text</span>)</span><br></pre></td></tr></table></figure><p>输出结果：<br>Wall Street Journal NP Journal<br>an interesting piece NP piece<br>crypto currencies NP currencies</p><h3 id="4、命名实体识别"><a href="#4、命名实体识别" class="headerlink" title="4、命名实体识别"></a>4、命名实体识别</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doc = nlp(<span class="string">"Two years ago, I lived in my Beijing."</span>)</span><br><span class="line"><span class="keyword">for</span> ent <span class="keyword">in</span> doc<span class="selector-class">.ents</span>:</span><br><span class="line">    print(ent<span class="selector-class">.text</span>, ent.label_)</span><br></pre></td></tr></table></figure><p>输出结果：<br>Two years ago DATE<br>BeijingGPE</p><p>还可以用非常漂亮的可视化做显示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> spacy import displacy</span><br><span class="line">displacy.render(doc, <span class="attribute">style</span>=<span class="string">'ent'</span>, <span class="attribute">jupyter</span>=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="//upload-images.jianshu.io/upload_images/11681023-77f9837fa7e661dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/454/format/webp" alt></p><p>输出结果.png</p><h3 id="5、句法依存解析"><a href="#5、句法依存解析" class="headerlink" title="5、句法依存解析"></a>5、句法依存解析</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">doc = nlp(<span class="string">'Wall Street Journal just published an interesting piece on crypto currencies'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> doc:</span><br><span class="line">    print(<span class="string">"&#123;0&#125;/&#123;1&#125; &lt;--&#123;2&#125;-- &#123;3&#125;/&#123;4&#125;"</span>.format(</span><br><span class="line">        token<span class="selector-class">.text</span>, token<span class="selector-class">.tag_</span>, token<span class="selector-class">.dep_</span>, token<span class="selector-class">.head</span><span class="selector-class">.text</span>, token<span class="selector-class">.head</span><span class="selector-class">.tag_</span>))</span><br></pre></td></tr></table></figure><p>输出结果：<br>Wall/NNP &lt;–compound– Street/NNP<br>Street/NNP &lt;–compound– Journal/NNP<br>Journal/NNP &lt;–nsubj– published/VBD<br>just/RB &lt;–advmod– published/VBD<br>published/VBD &lt;–ROOT– published/VBD<br>an/DT &lt;–det– piece/NN<br>interesting/JJ &lt;–amod– piece/NN<br>piece/NN &lt;–dobj– published/VBD<br>on/IN &lt;–prep– piece/NN<br>crypto/JJ &lt;–compound– currencies/NNS<br>currencies/NNS &lt;–pobj– on/IN</p><h3 id="6、-词向量"><a href="#6、-词向量" class="headerlink" title="6、==词向量=="></a>6、==词向量==</h3><p>NLP中有一个非常强大的文本表示学习方法叫做==word2vec==，通过词的上下文学习到词语的稠密向量化表示，同时在这个表示形态下，语义相关的词在向量空间中会比较接近。也有类似v(爷爷)-v(奶奶) ≈ v(男人)-v(女人)的关系。<br>在spaCy中，要使用英文的词向量，需先下载预先训练好的结果。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">python3</span> -m spacy download en_core_web_lg</span><br></pre></td></tr></table></figure><p>词向量的应用：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">nlp = spacy.<span class="built_in">load</span>(<span class="string">'en_core_web_lg'</span>)</span><br><span class="line"><span class="built_in">from</span> scipy import spatial</span><br><span class="line"></span><br><span class="line"><span class="comment"># 余弦相似度计算</span></span><br><span class="line">cosine_similarity = lambda x, y: <span class="number">1</span> - spatial.distance.cosine(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 男人、女人、国王、女王 的词向量</span></span><br><span class="line">man = nlp.vocab[<span class="string">'man'</span>].vector</span><br><span class="line">woman = nlp.vocab[<span class="string">'woman'</span>].vector</span><br><span class="line">queen = nlp.vocab[<span class="string">'queen'</span>].vector</span><br><span class="line">king = nlp.vocab[<span class="string">'king'</span>].vector</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 我们对向量做一个简单的计算，"man" - "woman" + "queen"</span></span><br><span class="line">maybe_king = man - woman + queen</span><br><span class="line">computed_similarities = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 扫描整个词库的词向量做比对，召回最接近的词向量</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">word</span> <span class="keyword">in</span> nlp.vocab:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">word</span>.has_vector:</span><br><span class="line">        continue</span><br><span class="line"> </span><br><span class="line">    similarity = cosine_similarity(maybe_king, <span class="built_in">word</span>.vector)</span><br><span class="line">    computed_similarities.append((<span class="built_in">word</span>, similarity))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序与最接近结果展示</span></span><br><span class="line">computed_similarities = sorted(computed_similarities, key=lambda <span class="keyword">item</span>: -<span class="keyword">item</span>[<span class="number">1</span>])</span><br><span class="line">print([w[<span class="number">0</span>].<span class="keyword">text</span> <span class="keyword">for</span> w <span class="keyword">in</span> computed_similarities[:<span class="number">10</span>]])</span><br></pre></td></tr></table></figure><p>输出结果：<br>[‘Queen’, ‘QUEEN’, ‘queen’, ‘King’, ‘KING’, ‘king’, ‘KIng’, ‘Kings’, ‘KINGS’, ‘kings’]</p><h3 id="6、词汇与文本相似度"><a href="#6、词汇与文本相似度" class="headerlink" title="6、词汇与文本相似度"></a>6、词汇与文本相似度</h3><p>在词向量的基础上，spaCy提供了从词到文档的相似度计算的方法，下面的例子是它的使用方法。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 词汇语义相似度(关联性)</span></span><br><span class="line">banana = nlp.vocab['banana']</span><br><span class="line">dog = nlp.vocab['dog']</span><br><span class="line">fruit = nlp.vocab['fruit']</span><br><span class="line">animal = nlp.vocab['animal']</span><br><span class="line"> </span><br><span class="line">print(dog.similarity(animal), dog.similarity(fruit)) <span class="comment"># 0.6618534 0.23552845</span></span><br><span class="line">print(banana.similarity(fruit), banana.similarity(animal)) <span class="comment"># 0.67148364 0.2427285</span></span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文本语义相似度(关联性)</span></span><br><span class="line">target = nlp(<span class="string">"Cats are beautiful animals."</span>)</span><br><span class="line"> </span><br><span class="line">doc1 = nlp(<span class="string">"Dogs are awesome."</span>)</span><br><span class="line">doc2 = nlp(<span class="string">"Some gorgeous creatures are felines."</span>)</span><br><span class="line">doc3 = nlp(<span class="string">"Dolphins are swimming mammals."</span>)</span><br><span class="line"> </span><br><span class="line">print(target.similarity(doc1))  <span class="comment"># 0.8901765218466683</span></span><br><span class="line">print(target.similarity(doc2))  <span class="comment"># 0.9115828449161616</span></span><br><span class="line">print(target.similarity(doc3))  <span class="comment"># 0.7822956752876101</span></span><br></pre></td></tr></table></figure><p>作者：还是那个没头脑<br>链接：<a href="https://www.jianshu.com/p/74e6c5376bc0" target="_blank" rel="noopener">https://www.jianshu.com/p/74e6c5376bc0</a><br>来源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 自然语言理解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自然语言理解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytorch-gather</title>
      <link href="/2019/07/12/pytorch-gather/"/>
      <url>/2019/07/12/pytorch-gather/</url>
      
        <content type="html"><![CDATA[<p>函数<code>torch.gather(input, dim, index, out=None) → Tensor</code><br> 沿给定轴 dim ,将输入索引张量 index 指定位置的值进行聚合.<br> 对一个 3 维张量,输出可以定义为:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">out[<span class="string">i</span>][<span class="symbol">j</span>][<span class="string">k</span>] = input[<span class="string">index[i</span>][<span class="symbol">j</span>][<span class="string">k</span>]][<span class="string">j</span>][<span class="symbol">k</span>]  # if dim == 0</span><br><span class="line">out[<span class="string">i</span>][<span class="symbol">j</span>][<span class="string">k</span>] = input[<span class="string">i</span>][<span class="symbol">index[i</span>][<span class="string">j</span>][<span class="symbol">k</span>]][<span class="symbol">k</span>]  # if dim == 1</span><br><span class="line">out[<span class="string">i</span>][<span class="symbol">j</span>][<span class="string">k</span>] = input[<span class="string">i</span>][<span class="symbol">j</span>][<span class="string">index[i</span>][<span class="symbol">j</span>][<span class="string">k</span>]]  # if dim == 2</span><br></pre></td></tr></table></figure><p>Parameters:</p><ul><li>input (Tensor) – 源张量</li><li>dim (int) – 索引的轴</li><li>index (LongTensor) – 聚合元素的下标(index需要是torch.longTensor类型)</li><li>out (Tensor, optional) – 目标张量</li></ul>]]></content>
      
      
      <categories>
          
          <category> pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/07/11/hello-world/"/>
      <url>/2019/07/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>numpy 函数</title>
      <link href="/2019/06/16/numpy-%E5%87%BD%E6%95%B0/"/>
      <url>/2019/06/16/numpy-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="np-round"><a href="#np-round" class="headerlink" title="np.round "></a><font color="#0099ff" size="7" face="黑体">np.round </font></h2><h3 id="round函数概念："><a href="#round函数概念：" class="headerlink" title="round函数概念："></a>round函数概念：</h3><p>英文：圆，四舍五入<br>是python内置函数，它在哪都能用，对数字取四舍五入。<br>round(number[, ndigits])<br>round 对传入的数据进行四舍五入，如果ngigits不传，默认是0（就是说保留整数部分）.ngigits&lt;0 的时候是来对整数部分进行四舍五入，返回的结果是浮点数.</p><h3 id="round-负数"><a href="#round-负数" class="headerlink" title="round 负数"></a>round 负数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 四舍五入是围绕着0来计算的，  </span></span><br><span class="line">round(<span class="number">0.5</span>) <span class="comment"># 1.0  </span></span><br><span class="line">round(<span class="number">-0.5</span>) <span class="comment">#-1.0</span></span><br></pre></td></tr></table></figure><h3 id="round-的陷阱"><a href="#round-的陷阱" class="headerlink" title="round 的陷阱"></a>round 的陷阱</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">round(<span class="number">1.675</span>, <span class="number">2</span>) <span class="comment">#1.68  </span></span><br><span class="line">round(<span class="number">2.675</span>, <span class="number">2</span>) <span class="comment">#2.67</span></span><br></pre></td></tr></table></figure><h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">round(<span class="number">3.4</span>) <span class="comment"># 3.0  </span></span><br><span class="line">round(<span class="number">3.5</span>) <span class="comment"># 4.0  </span></span><br><span class="line">round(<span class="number">3.6</span>) <span class="comment"># 4.0  </span></span><br><span class="line">round(<span class="number">3.6</span>, <span class="number">0</span>) <span class="comment"># 4.0  </span></span><br><span class="line">round(<span class="number">1.95583</span>, <span class="number">2</span>) <span class="comment"># 1.96  </span></span><br><span class="line">round(<span class="number">1241757</span>, <span class="number">-3</span>) <span class="comment"># 1242000.0  </span></span><br><span class="line">round(<span class="number">5.045</span>, <span class="number">2</span>) <span class="comment"># 5.05  </span></span><br><span class="line">round(<span class="number">5.055</span>, <span class="number">2</span>) <span class="comment"># 5.06</span></span><br></pre></td></tr></table></figure><h2 id="np-clip"><a href="#np-clip" class="headerlink" title="np.clip"></a><font color="#0099ff" size="7" face="黑体">np.clip</font></h2><p>numpy.clip(a, a_min, a_max, out=None)[source]<br>其中a是一个数组，后面两个参数分别表示最小和最大值，怎么用呢，老规矩，我们看代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x=np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>])</span><br><span class="line">np.clip(x,<span class="number">3</span>,<span class="number">8</span>)</span><br><span class="line">Out[<span class="number">88</span>]:</span><br><span class="line">array([<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>self-attention</title>
      <link href="/2019/06/16/self-attention/"/>
      <url>/2019/06/16/self-attention/</url>
      
        <content type="html"><![CDATA[<ul><li>一篇解读：<a href="https://kexue.fm/archives/4765" target="_blank" rel="noopener">https://kexue.fm/archives/4765</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 自然语言理解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自然语言理解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优先级队列式分支限界法---最小重量机器设计问题--python实现</title>
      <link href="/2019/05/22/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%BC%8F%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95-%E6%9C%80%E5%B0%8F%E9%87%8D%E9%87%8F%E6%9C%BA%E5%99%A8%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98-python%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/05/22/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%BC%8F%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95-%E6%9C%80%E5%B0%8F%E9%87%8D%E9%87%8F%E6%9C%BA%E5%99%A8%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98-python%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>这里给出两个解决方案：</p><p>1）不使用优先级，简单使用队列式分支限界法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 普通的FIFO 队列式分支限界法</span></span><br><span class="line"><span class="comment">## 当 不满足总价格不超过d的要求时，则剪枝</span></span><br><span class="line"><span class="comment">## 当搜索到深度n时，即搜索到了叶节点，不再进行扩展节点的操作，而是针对于叶节点所对应的最小值，</span></span><br><span class="line"><span class="comment"># 反向求得该节点所对应的的路径</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># coding : utf-8</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = <span class="number">3</span></span><br><span class="line">m = <span class="number">3</span></span><br><span class="line">d = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">price = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line">weight = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到当前扩展节点所在的Level</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getlevel</span><span class="params">(m, currrent)</span>:</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    level = <span class="number">0</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> currrent == <span class="number">0</span>:</span><br><span class="line">        level = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> level</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">        level = level+<span class="number">1</span></span><br><span class="line">        sum = m**level + sum  <span class="comment"># sum=m</span></span><br><span class="line">        <span class="keyword">if</span> sum-m**level &lt; currrent &lt;= sum:  <span class="comment"># m-m^0 = m-1</span></span><br><span class="line">            <span class="keyword">return</span> level</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到当前扩展节点，所对应的首个子节点所在的索引</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_idx</span><span class="params">(m, current)</span>:</span></span><br><span class="line">    level = getlevel(m, current)</span><br><span class="line">    <span class="comment"># 求current 在该level中的相对索引，即 相对于该level第一个元素的位置</span></span><br><span class="line">    current_level_idx = current - sum([m**i <span class="keyword">for</span> i <span class="keyword">in</span> range(level)])</span><br><span class="line">    <span class="comment"># 子节点所在层的开始绝对索引</span></span><br><span class="line">    start_idx  = sum([m**i <span class="keyword">for</span> i <span class="keyword">in</span> range(level+<span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> start_idx + current_level_idx*m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到最优解之后，反向查找其路径</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_path</span><span class="params">(m, current)</span>:</span></span><br><span class="line">    path = []</span><br><span class="line">    path.append(current%m)  <span class="comment"># from 1, not from 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        level = getlevel(m, current)</span><br><span class="line">        <span class="keyword">if</span> level == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> path[::<span class="number">-1</span>]</span><br><span class="line">        current_level_idx = current - sum([m ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(level)])  <span class="comment"># # 求current 在该level中的相对索引，即 相对于该level第一个元素的位置</span></span><br><span class="line">        path.append(current_level_idx // m + <span class="number">1</span>)  <span class="comment"># 得到上一级的索引位置</span></span><br><span class="line">        current = sum([m ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(level<span class="number">-1</span>)]) + current_level_idx // m  <span class="comment">#得到上一级的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MinWighet</span><span class="params">(n,m,d,price,weight)</span>:</span></span><br><span class="line">    minweight = float(<span class="string">"inf"</span>)</span><br><span class="line">    <span class="comment"># 子集树中的节点数</span></span><br><span class="line">    vec_len = sum([m ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>)]) + <span class="number">1</span></span><br><span class="line">    que = queue.Queue()</span><br><span class="line">    que.put(<span class="number">0</span>)</span><br><span class="line">    vec_price = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(vec_len)]</span><br><span class="line">    vec_weight = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(vec_len)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">not</span> que.empty()):</span><br><span class="line">        current = que.get()  <span class="comment"># 得到当前扩展节点（索引号）</span></span><br><span class="line">        level = getlevel(m, current)  <span class="comment"># 当前 扩展节点所在的level</span></span><br><span class="line"></span><br><span class="line">        idx = get_idx(m, current)   <span class="comment"># 得到当前扩展节点，所对应的首个子节点所在的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 若搜索完了整棵树</span></span><br><span class="line">        <span class="keyword">if</span> getlevel(m, current) == getlevel(m, vec_len)<span class="number">-1</span>:</span><br><span class="line">            minweight = vec_price[current]</span><br><span class="line">            min_at_idx = current</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">not</span> que.empty()):</span><br><span class="line">                <span class="comment"># minweight = min(minweight, vec_price[que.get()])</span></span><br><span class="line">                tmp = que.get()</span><br><span class="line">                <span class="keyword">if</span> minweight &gt; vec_price[tmp]:</span><br><span class="line">                    minweight = vec_price[tmp]</span><br><span class="line">                    min_at_idx = tmp</span><br><span class="line">            path = get_path(m, min_at_idx)</span><br><span class="line">            <span class="keyword">return</span> minweight, path</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断当前的扩展结点下的所有子节点是否可以加入活结点队列中</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            vec_price[idx] = int(vec_price[current] + price[level][i])</span><br><span class="line">            <span class="keyword">if</span> vec_price[idx] &lt;= d:</span><br><span class="line">                vec_weight[idx] = int(vec_weight[current] + weight[level][i])</span><br><span class="line">                que.put(idx)</span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(MinWighet(n,m,d,price,weight))</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>2） 优先级队列式分支限界法</p><p>解空间：子集树，每个分支节点的分支数为m<br>解向量：x[1:n]  n为部件数量， x[i] 表示第i个部件使用哪个供应商。</p><p>算法：采用优先队列式分支限界法。<br>类似于单源最短路径，使用当前节点所确定下的采购方案对应的机器重量和最为优先级。<br>由于wij不是负值，当前节点所对应的当前机器重量和是解空间中以该节点为根的子树的中所有节点所对应的重量和的下界。</p><p>算法代码实现：</p><p>1）使用列表来代表队列，通过对列表中的活结点按照其当前重量和进行从小到大排序（实现了最小堆的维护）<br>2）定义一个节点类，属性有：节点所在的索引，以及节点当前的重量和<br>3）取出一个扩展节点：由于对活结点表进行了某种规则的排序，则直接取出列表的第一个元素即可<br>4）加入活结点表：将满足条件的子节点加入到活结点表中</p><p>失活当前扩展节点：删掉列表中的第一个元素即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 普通的FIFO 队列式分支限界法</span></span><br><span class="line"><span class="comment">## 当 不满足总价格不超过d的要求时，则剪枝</span></span><br><span class="line"><span class="comment">## 当搜索到深度n时，即搜索到了叶节点，不再进行扩展节点的操作，而是针对于叶节点所对应的最小值，</span></span><br><span class="line"><span class="comment"># 反向求得该节点所对应的的路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入优先级--使用当前节点的重量作为优先级，重量小优先级高</span></span><br><span class="line"><span class="comment"># 将队列改成列表，以append的方式加入到列表中，再以排序的方式维护当前列表的首个元素为最小权值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># coding : utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到当前扩展节点所在的Level</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getlevel</span><span class="params">(m, currrent)</span>:</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    level = <span class="number">0</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> currrent == <span class="number">0</span>:</span><br><span class="line">        level = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> level</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">        level = level+<span class="number">1</span></span><br><span class="line">        sum = m**level + sum  <span class="comment"># sum=m</span></span><br><span class="line">        <span class="keyword">if</span> sum-m**level &lt; currrent &lt;= sum:  <span class="comment"># m-m^0 = m-1</span></span><br><span class="line">            <span class="keyword">return</span> level</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到当前扩展节点，所对应的首个子节点所在的索引</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_idx</span><span class="params">(m, current)</span>:</span></span><br><span class="line">    level = getlevel(m, current)</span><br><span class="line">    <span class="comment"># 求current 在该level中的相对索引，即 相对于该level第一个元素的位置</span></span><br><span class="line">    current_level_idx = current - sum([m**i <span class="keyword">for</span> i <span class="keyword">in</span> range(level)])</span><br><span class="line">    <span class="comment"># 子节点所在层的开始绝对索引</span></span><br><span class="line">    start_idx  = sum([m**i <span class="keyword">for</span> i <span class="keyword">in</span> range(level+<span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> start_idx + current_level_idx*m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到最优解之后，反向查找其路径</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_path</span><span class="params">(m, current)</span>:</span></span><br><span class="line">    path = []</span><br><span class="line">    path.append(current%m)  <span class="comment"># from 1, not from 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        level = getlevel(m, current)</span><br><span class="line">        <span class="keyword">if</span> level == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> path[::<span class="number">-1</span>]</span><br><span class="line">        current_level_idx = current - sum([m ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(level)])  <span class="comment"># # 求current 在该level中的相对索引，即 相对于该level第一个元素的位置</span></span><br><span class="line">        path.append(current_level_idx // m + <span class="number">1</span>)  <span class="comment"># 得到上一级的索引位置</span></span><br><span class="line">        current = sum([m ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(level<span class="number">-1</span>)]) + current_level_idx // m  <span class="comment">#得到上一级的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为活结点表中的节点 定义了一个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, idx, weight)</span>:</span></span><br><span class="line">        self.idx = idx</span><br><span class="line">        self.weight = weight</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MinWighet</span><span class="params">(n,m,d,price,weight)</span>:</span></span><br><span class="line">    <span class="comment"># 子集树中的节点数</span></span><br><span class="line">    vec_len = sum([m ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>)]) + <span class="number">1</span></span><br><span class="line">    que = []</span><br><span class="line">    que.append(Node(<span class="number">0</span>,<span class="number">0</span>))  <span class="comment"># 在活结点表中加入根节点</span></span><br><span class="line">    <span class="comment"># vec_price = [0 for _ in range(vec_len)]</span></span><br><span class="line">    <span class="comment"># vec_weight = [0 for _ in range(vec_len)]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(que):  <span class="comment"># 当活结点表非空时</span></span><br><span class="line">        que = sorted(que, key=<span class="keyword">lambda</span> node: node.weight)  <span class="comment"># 类似于最小堆的维护</span></span><br><span class="line">        current = que[<span class="number">0</span>]  <span class="comment"># 得到当前扩展节点（索引号）</span></span><br><span class="line">        level = getlevel(m, current.idx)  <span class="comment"># 当前 扩展节点所在的level</span></span><br><span class="line"></span><br><span class="line">        new_node_idx = get_idx(m, current.idx)   <span class="comment"># 得到当前扩展节点，所对应的首个子节点所在的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 若搜索完了整棵树</span></span><br><span class="line">        <span class="keyword">if</span> getlevel(m, current.idx) == getlevel(m, vec_len)<span class="number">-1</span>:</span><br><span class="line">            minweight = current.weight</span><br><span class="line">            min_at_idx = current.idx</span><br><span class="line"></span><br><span class="line">            path = get_path(m, min_at_idx)</span><br><span class="line">            <span class="keyword">return</span> minweight, path</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断当前的扩展结点下的所有子节点是否可以加入活结点队列中</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> int(current.weight + price[level][i]) &lt;= d:</span><br><span class="line">                new_node = Node(new_node_idx, int(current.weight + weight[level][i]))</span><br><span class="line">                que.append(new_node)</span><br><span class="line">            new_node_idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将当前的扩展节点失活</span></span><br><span class="line">        <span class="keyword">del</span> que[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    n = <span class="number">3</span></span><br><span class="line">    m = <span class="number">3</span></span><br><span class="line">    d = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    price = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]]</span><br><span class="line">    weight = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]]</span><br><span class="line">    result = MinWighet(n,m,d,price,weight)</span><br><span class="line">    print(MinWighet(n,m,d,price,weight))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Grounded Video Description</title>
      <link href="/2019/05/10/Grounded-Video-Description/"/>
      <url>/2019/05/10/Grounded-Video-Description/</url>
      
        <content type="html"><![CDATA[<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><ul><li>这是CVPR 2019 做视频描述的一篇文章，该文的主要贡献是对已有的ActivityNet dense caption数据集进行加强—对其中的帧进行了object bbox的标注，这就为视频描述任务增加了非常有用的信息。</li><li>总的来说，<font color="#dd00dd">该文的出发点是：1. 利用object 信息来生成句子. 2. 希望生成的句子中的名词，在video中可以找到相对应的证据(object)。</font><br></li><li>grounded-based video description model ：联合生成的单词，并微调在description中生成的object。可以探索这种显式的监督对视频描述带来的益处，并与无监督（可能利用region feature，但是没有 penalize grounding）的方法进行对比。</li></ul><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><ul><li>video输出的句子中提到的object，并没有在该video中实际存在。那么为什么有这种现象，是因为前的视频描述模型是基于先验知识，在之前的训练过程中，存在一个视频与该视频有 similar contexts，从而使得输出的单词中涵盖了训练video中的obejct，而不是该video本身的object，导致了该现象。</li><li>因此本文的工作： 将句子中的名词与视频中的object一 一对应起来，这样就可以建立sentence 与 evidence of video 之间的联系。<br>这样可以<font color="#0099ff" size="5">在视频描述模型中使用这些object 信息</font>，同时，<font color="#0099ff" size="5">还可以评估模型</font>（“teaching models to explicitly rely on the corresponding evidence in the video frame  when generating words and evaluating how well models   are doing in grounding individual words or phrases they  generated.”）。<br>如：该模型生成的句子中的名词与已经标注的object是否是一 一对应的（即便一个模型说出争取的sentence，比如一个男孩正在玩耍，但是如果video中有多个个男孩，那么该sentence输出的一个男孩是指向哪一个呢？）。</li></ul><h2 id="标注bbox时的细节"><a href="#标注bbox时的细节" class="headerlink" title="标注bbox时的细节"></a>标注bbox时的细节</h2><ul><li>“we collect ActivityNet-Entities (short as ANet-Entities) which  grounds or links noun phrases in sentences with bounding  boxes in the video frames.”<br>“we only  annotate a single frame of the video for each noun phrase” 。<br>即， 是对照着已有的sentence中的名词对其进行加框(bbox)，而不是对该video中的所有示例进行标注。对于sentence中的一个名词只在一帧上进行标注（稀疏标注） </li></ul><h2 id="调研工作"><a href="#调研工作" class="headerlink" title="调研工作"></a>调研工作</h2><h3 id="1-结合object-feature-做captioning任务"><a href="#1-结合object-feature-做captioning任务" class="headerlink" title="1. 结合object feature 做captioning任务"></a>1. 结合object feature 做captioning任务</h3><ul><li><strong>当前的方法</strong>，主要是两步：（1）使用off-the-shelf 或者是fine-tuned 的 object detector 来得到 object proposals （2）对object features采用动态attention，或者是对region进行分类，然后送入 decoder中。</li><li><strong>存在的问题</strong>，使用现成的object detector 将会使得到的object proposals 更偏向于 source dataset , 而不是偏向于当前的视频描述target dataset。一种解决方案是针对于target dataset 来fine-tune object detector。但是这种那个方案需要大量的标注，尤其是对于video，数据量会更大，</li><li>因此提出了<font color="#0099ff" size="5" face="黑体">本文的方法(给出了fine-tune obejct detector的改进方案)</font>：“Instead of  fine-tuning a general detector, we transfer the object classification knowledge from off-the-shelf object detectors to  our model and then fine-tune this representation as part of  our generation model with sparse box annotations. ”。</li><li>在文章中的4.4节开头给出了具体的实现：已经得到了bbox，现在的目的是想要得到the class probability distribution for each region. 将在visual genome上预训练的detector迁移到我们的<strong>object classifier</strong> 任务上，另外关于classes集合，假定我们已经有了K个类别，则我们在Visual Genome中根据最近距离找到与其对应的classes。  定义一个softmax( Wx+b )的分类层，W 和 b 的初始化是预训练的detector的最后一个线性层（分类层）的参数值（W应该是根据找出的K个类别按照索引抽出的一个矩阵）。<h3 id="2-object-attention"><a href="#2-object-attention" class="headerlink" title="2. object attention"></a>2. object attention</h3></li><li>某些作者指出，attention model关注的region和人类的关注点并不一致，增加attention supervision几乎不能提高性能。另一方面，在feature map attention 上增加监督，是有益处的。</li><li>在该文作者的实验中，region attention with supervision 并不能带来性能的提升，作者分析，这可能是由于缺少object context 信息，因此<font color="#0099ff" size="5" face="黑体">该文作者在attention model中引入了基于context encoding 的self-attention</font>，这将会使得信息能够在被采样的视频帧中的regions 传递(我理解的是，region feature 不仅仅是单纯的从fc层中提取到的信息，同时也结合了其余信息来得到 grounding-aware region encoding， 在文章的4.3 以及 4.4节有关于<strong>R<sup>~</sup></strong> 的定义)。 </li></ul><h2 id="Description-with-Grounding-Supervision"><a href="#Description-with-Grounding-Supervision" class="headerlink" title="Description with Grounding Supervision"></a>Description with Grounding Supervision</h2><ul><li>这个框架包括三个模块: <strong>grounding</strong>, <strong>region attention</strong> and <strong>language generation</strong>.<br>grounding： 对于生成的word， 从video中检测到对应的visual clue。<br>region attention: 动态的将visual clue 形成一个high-level的视觉内容的表达，并将其送入decoder。   </li><li>这里包括三种方式来结合object-level supervision: <strong>region classification</strong>,  <strong>object grounding (localization)</strong>, and <strong>supervised attention</strong>.  </li><li><strong>（我的理解，supervised attention直接针对attention中的系数，查看与真实的对应关系，设计的这个loss对于视频描述生成由益处；object grounding 涉及到了region attention中的系数，因此与描述生成有一定的关联，反向传播可能是有益处的；region classification中设计的loss： 它的反向传播会更新M<sub>s</sub>( R ), 进一步作用于region encoding, 进一步作用于region attention 和 language generate；）</strong></li></ul><h3 id="Language-Generation-Module"><a href="#Language-Generation-Module" class="headerlink" title="Language Generation Module"></a>Language Generation Module</h3><ul><li>本文的decoder 部分采用 [1] 中提到的decoder，与bottom up[3] 的结构大致近似，但是<strong>在[1]中</strong>第二层 language lstm的输入部分，不仅包括attention of region feature， 还包括attention of 最后一个卷积层k girds的特征。对应到本文的视频描述任务上，第二层language lstm的输入，不仅包括attention of region features ，还包括 attention of frames features。即region attention 和 temporal attention</li><li>需要注意的是该文中使用的<font color="#0099ff" size="5" face="黑体">temporal attention</font>是[2]中提到的self-attention context encoder with Bidirectional GRU (Bi-GRU)，而不是[1]中使用的attention机制。</li><li><font color="#0099ff" size="5" face="黑体">region attention</font>采用的就是bottom up 中的attention结构</li><li>下面将[1] 中的原图贴一下：   <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2x5hlq801j30l20ezq4v.jpg">   </li></ul><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><h3 id="Region-proposal-and-features"><a href="#Region-proposal-and-features" class="headerlink" title="Region proposal and features"></a>Region proposal and features</h3><p>For each frame, we use a Faster  R-CNN detector [24] with ResNeXt-101 backbone [30] for  region proposal and feature extraction (fc6). The detector is  pretrained on Visual Genome。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] Neural baby talk. In CVPR 2018.<br>[2] End-to-end dense video captioning with masked transformer. In CVPR 2018.<br>[3] Bottom-up and top-down attention for image captioning and  visual question answering. In CVPR 2018.</p>]]></content>
      
      
      <categories>
          
          <category> 视频描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spatio-Temporal Dynamics and Semantic Attribute Enriched Visual Encoding for Video Captioning（CVPR2019）</title>
      <link href="/2019/05/10/Spatio-Temporal-Dynamics-and-Semantic-Attribute-Enriched-Visual-Encoding-for-Video-Captioning-1/"/>
      <url>/2019/05/10/Spatio-Temporal-Dynamics-and-Semantic-Attribute-Enriched-Visual-Encoding-for-Video-Captioning-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul><li>我们的方法丰富视觉特征的<strong>时域动态temporal dynamics</strong>，通过在整个video上分层对CNN特征应用短的fourier 变换</li><li>从object detector 中提取高层语义，来丰富被检测object 的<strong>空间动态 spatial dynamics</strong></li><li>最终的表达映射到一个压缩的空间</li></ul><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul><li>object detector YOLO[1]</li><li>目标检测和C3D的输出层被用来得到高层语义属性，</li><li>提出的视觉特征包含检测的目标属性、目标发生的频率</li></ul><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>现有的video captioning model 一种使用平均池化得到特征，一种使用attention得到high level特征，但是这些视觉特征都是直接的被使用，则，这些方法没有充分利用CNN在视频字幕框架中的最新特性。我们的模型丰富了视觉特征，实验结果证明，该视觉特征与任意一个简单的语言模型相结合，可以提高其性能。</p><h2 id="Visual-Representation"><a href="#Visual-Representation" class="headerlink" title="Visual Representation"></a>Visual Representation</h2><ul><li>the visual representation of a  video V as v = [α; β; γ; η]</li><li>α; β; γ; η 是四个列向量，下面具体介绍如何得到这四个列向量<h3 id="Encoding-temporal-dynamics"><a href="#Encoding-temporal-dynamics" class="headerlink" title="Encoding temporal dynamics"></a>Encoding temporal dynamics</h3></li><li>首先已经有 f 帧 对应的CNN[2]特征向量，和c个clip对应的C3D[3]得到的特征向量</li><li>对某个video而言，其所有帧再某一个维度的神经元，组成了一个特征向量a，利用<strong>傅里叶变换</strong>得到一个p维度的特征向量，将a分成两半，分别进行傅里叶变换，得到一个p维度的特征向量，再次进行分半，等等一系列操作，可以得到 p×7的矩阵。则对于所有的神经元m 则得到m×p×7的张量。至此得到<strong>α</strong></li><li><strong>β</strong>同理，只是对clips对应的C3D特征进行处理</li><li>目前已经有将傅里叶变换应用在行为识别上的文章吗，但是本文是第一篇将傅里叶变换应用在视频描述上的文章。</li><li><font color="#0099ff" size="4" face="黑体">但是需要注意的是，该文并没有说明使用傅里叶变换的动机（rich temporal dynamics?），但是为什么使用傅里叶变换可以丰富？？</font></li></ul><h3 id="Encoding-Semantics-and-Spatial-Evolution"><a href="#Encoding-Semantics-and-Spatial-Evolution" class="headerlink" title="Encoding Semantics and Spatial Evolution"></a>Encoding Semantics and Spatial Evolution</h3><ul><li>比较复杂，利用object detector YOLO 来提取Object 以及C3D来加强语义信息，具体看论文吧</li></ul><h2 id="Experimental-Results-on-MSVD"><a href="#Experimental-Results-on-MSVD" class="headerlink" title="Experimental Results on MSVD"></a>Experimental Results on MSVD</h2><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2wd8q6kegj30dh0ig0wc.jpg">    <ul><li>GRU-MP - (C3D) 与 使用了傅里叶变换的GRU-EVEhft - (C3D)  相比，可知，使用傅里叶变换是有小鬼的</li><li>GRU-EVEhft - (CI) 与GRU-EVEhft+sem - (CI)相比，可得增加的senmatic 效果是不显著的。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] Yolo9000: better, faster, stronger.  In IEEE CVPR, 2017<br>[2] Inception-v4, inception-resnet and the impact of residual  connections on learning. In AAAI, volume 4, page 12, 2017.<br>[3] Learning spatiotemporal features with 3d convolutional networks. In Proceedings of the IEEE international conference  on computer vision, pages 4489–4497, 2015.</p>]]></content>
      
      
      <categories>
          
          <category> 视频描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-dict</title>
      <link href="/2019/05/08/python-dict/"/>
      <url>/2019/05/08/python-dict/</url>
      
        <content type="html"><![CDATA[<h1 id="dict-的get-函数"><a href="#dict-的get-函数" class="headerlink" title="dict 的get 函数"></a>dict 的get 函数</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Python 字典(Dictionary) get() 函数返回指定键的值，如果值不在字典中返回默认值。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>get()方法语法：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict.<span class="builtin-name">get</span>(key, <span class="attribute">default</span>=None)</span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li>key – 字典中要查找的键。</li><li>default – 如果指定键的值不存在时，返回该默认值值。</li></ul><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>返回指定键的值，如果值不在字典中返回默认值None。</p><h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><p>get函数的作用是返回指定key的值，若key不存在，则返回default值，default值，默认为None，也可以自己指定</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Show, Attend and Tell: Neural Image Caption Generation with Visual Attention</title>
      <link href="/2019/05/06/Show-Attend-and-Tell-Neural-Image-Caption-Generation-with-Visual-Attention/"/>
      <url>/2019/05/06/Show-Attend-and-Tell-Neural-Image-Caption-Generation-with-Visual-Attention/</url>
      
        <content type="html"><![CDATA[<ul><li>encoder  attention<br>本文的出发点是利用低层次的特征，并结合了attention 机制<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2re7nfbn3j30q70430sx.jpg"></li></ul><p>参考链接：<a href="https://blog.csdn.net/shenxiaolu1984/article/details/51493673" target="_blank" rel="noopener">https://blog.csdn.net/shenxiaolu1984/article/details/51493673</a></p>]]></content>
      
      
      <categories>
          
          <category> 图像描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>池化层的反向传播</title>
      <link href="/2019/04/21/%E6%B1%A0%E5%8C%96%E5%B1%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/"/>
      <url>/2019/04/21/%E6%B1%A0%E5%8C%96%E5%B1%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/</url>
      
        <content type="html"><![CDATA[<ul><li>参考： <a href="https://blog.csdn.net/qq_21190081/article/details/72871704" target="_blank" rel="noopener">https://blog.csdn.net/qq_21190081/article/details/72871704</a></li><li>总结，<br>（1）对于平均池化层，比如2×2-&gt;1， 梯度的反向传递，是1-&gt;2×2，若梯度为x, 则，反向传播的梯度为4个 1/4<br>（1）对于最大池化层，比如2×2-&gt;1， 梯度的反向传递，是1-&gt;2×2，若梯度为x, 则，反向传播只赋值给最大值所在的元素，其余三个元素的梯度为0</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>An End-to-End Baseline for Video Captioning</title>
      <link href="/2019/04/20/An-End-to-End-Baseline-for-Video-Captioning/"/>
      <url>/2019/04/20/An-End-to-End-Baseline-for-Video-Captioning/</url>
      
        <content type="html"><![CDATA[<h3 id="积累梯度那里没有看明白-–-解决内存占用多的问题"><a href="#积累梯度那里没有看明白-–-解决内存占用多的问题" class="headerlink" title="积累梯度那里没有看明白 – 解决内存占用多的问题"></a>积累梯度那里没有看明白 – 解决内存占用多的问题</h3><p>我认为可能是积累 loss, 直到达到某一个batch size才进行反向传播<br>说是为了解决内存占用多的问题，可是这样，就解决了吗？？？</p><h3 id="灵魂反问"><a href="#灵魂反问" class="headerlink" title="灵魂反问"></a>灵魂反问</h3><p>为什么要是end-to-end，我最终需要的是一个效果比较好的模型，但是为了只得到这样的一点提升，反而会需要很多的GPU计算资源。这个end-to-end fine-tune 是否有必要。</p><h3 id="目前方法存在的问题"><a href="#目前方法存在的问题" class="headerlink" title="目前方法存在的问题"></a>目前方法存在的问题</h3><p>encoder：比如 CNN， 一般是在不同任务上的其他数据集上进行预训练的，之后，在训练video captioning任务时，得到的video/image feature就不再fine tune。这样得到的结果是次优的。<br>目前改进这一缺陷的文章有：[1][2][3]，他们尝试捕捉不同帧之间的动态时域，但是，他们没有从根本上改变一个事实：视频描述任务需要一个与该任务相关的特征。</p><h4 id="当前没有人去fine-tune-encoder的原因"><a href="#当前没有人去fine-tune-encoder的原因" class="headerlink" title="当前没有人去fine-tune encoder的原因"></a>当前没有人去fine-tune encoder的原因</h4><p>（1）because of the amount of memory required to process  video data for each batch。是因为每个批次都要处理视频数据，所需要的存储空间会很大。<br>（2）batch sizes for video captioning can become very high (e.g. 512), making training  prohibitive on a small number of GPUs。同时，视频描述的批次一般都比较大，使得所需要的GPU数量会很多。</p><h4 id="本文提取出的解决方案—-即训练过程"><a href="#本文提取出的解决方案—-即训练过程" class="headerlink" title="本文提取出的解决方案—-即训练过程"></a>本文提取出的解决方案—-即训练过程</h4><p>In this paper we address this issue by accumulating gradients over multiple steps, to update parameters only after  the required effective batch size is achieved.<br>在多步积累梯度，并只在达到有效的批次大小之后(当神经网络训练完512个examples)，才进行梯度更新。<br>这种训练方案相比于分别训练两部分收敛速度会慢，因为所需的迭代次数增加了。但是这里采用了一个加速训练过程的方案，先分别训练encoder和decoder，然后再end-to-end进行fine-tune。</p><h4 id="主要的贡献"><a href="#主要的贡献" class="headerlink" title="主要的贡献"></a>主要的贡献</h4><ol><li>可以得到与具体任务（视频描述）相关的特征</li><li>积累梯度来限制GOU存储消耗，因此可以处理大批次，这是基于RNN的decoders所需的。</li><li>使用了两阶段的训练来加速训练</li><li>为未来的工作，创建了一个简单的baseline</li></ol><h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><ol><li>先预训练encoder，例如利用图像识别、行为识别等</li><li>冻结encoder的参数，在视频描述任务上训练decoder，直到在验证数据集上表现出比较好的效果</li><li>整个网络，端到端的训练，冻结Inception-ResNet-v2中的BN层，由于该过程中占用的内存较多，作者采用了一种方法：accumulating gradients over multiple steps, to update parameters only after  the required effective batch size is achieved. </li></ol><ul><li>需要注意的是，在2. 3. 阶段的训练过程中，SA-LSTM都是使用target words(ground truth)作为输入，而不是使用之前的预测。</li></ul><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p> Inception-ResNet-v2[5] as an encoder，and a modified version of  Soft-Attention LSTM as a decoder.<br> <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2ad637ykjj30hy0h677d.jpg">    </p><ul><li>decoder<ul><li>输入LSTM的input: <strong>x<sup>t</sup></strong> ：<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2aeagi7o3j30a30280sl.jpg">    - 该step 生成的word：<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2aeiriwanj30jd014mx7.jpg"></li></ul></li></ul><p>soft-attention这里，原文是采用attention机制进行加权求和 ，这里与原soft-attention[2] 略有不同。</p><ul><li><p>原soft-attention论文：</p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2aeagheogj308o03ct8l.jpg">     </li><li><p>现修改为：（增加了β<sub>t</sub>）</p></li></ul><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2aeagka0rj30h504dq37.jpg">   <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2aeaggzpdj309302xdfq.jpg">   <ul><li><font color="#0099ff" size="5" face="黑体">这里与Figure2 图中显示的结构并不一致，这里是全权求和，但是在图中却是concatenate !</font></li></ul><ul><li>还有一些其他的修改<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2aes6w62rj30il09xwgp.jpg"></li></ul><h3 id="实验效果"><a href="#实验效果" class="headerlink" title="实验效果"></a>实验效果</h3><ul><li>step1 : encoder先训练，然后固定encoder的参数，训练decoder的参数，不进行联合训练</li><li>step2：在step1的基础上，联合训练encoder-decoder。</li><li>MSR-VTT的实验结果<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2ajqfodpkj30kl0b9acc.jpg">  </li><li>MSVD的实验结果<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2ajqfqhbjj30ks0icn0q.jpg"></li></ul><h4 id="yaya：-本文step1训练效果比较好的原因（相较于soft-attention-lstm-原论文）"><a href="#yaya：-本文step1训练效果比较好的原因（相较于soft-attention-lstm-原论文）" class="headerlink" title=" yaya： 本文step1训练效果比较好的原因（相较于soft-attention lstm 原论文）"></a><font color="#0099ff" size="5" face="黑体"> yaya： 本文step1训练效果比较好的原因（相较于soft-attention lstm 原论文）</font></h4><p>这里step1的意思是：encoder、decoder 分开训练，并不进行联合训练</p><ol><li>该文使用的 Inception-ResNet-v2作为encoder来提取特征。会比其他论文中使用的encoder更复杂。</li><li>初始化的细节<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2ak8as8u4j309703pglo.jpg"></li><li>对SA-LSTM[2]而言，进行了一些修改：<br>（1）frame features 转为一个特征向量，使用的注意力机制，但是该文在soft-attention的基础上，还增加了一个系数β<sub>t</sub><br>（2）LSTM的内部结构的计算公式增加了一项，如下图<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2ajg7vn8rj31fi0ci427.jpg">（3）在生成word时，主要差别就是E[y<sub>t-1</sub>]前边是否有权重的问题 - soft-attention 使用的公式：<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2aeiriwanj30jd014mx7.jpg"> - 但是在本文中使用的公式为：<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2ajjxtsplj30d103v74i.jpg">- 但是就该文3.3.2节中说：These changes are inspired by  the original code repository by Yao et al [2]，也就是有可能人家的源代码和在论文中提到的不一致。</li></ol><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1] Video captioning with  transferred semantic attributes. CVPR, 2017<br>[2] Describing videos by exploiting temporal  structure. ICCV, 2015.<br>[3] Task-driven dynamic fusion: Reducing ambiguity in video description. CVPR, 2017.<br>[4] Show and  tell: Lessons learned from the 2015 mscoco image captioning challenge. TPAMI, 2016.<br>[5] Inception-v4, inception-resnet and the impact of residual  connections on learning. AAAI, 2017</p>]]></content>
      
      
      <categories>
          
          <category> 视频描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 关于list的操作</title>
      <link href="/2019/04/18/python-%E5%85%B3%E4%BA%8Elist%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/04/18/python-%E5%85%B3%E4%BA%8Elist%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="list-的置换"><a href="#list-的置换" class="headerlink" title="list 的置换"></a>list 的置换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">nums[<span class="number">0</span>],nums[<span class="number">1</span>] = nums[<span class="number">1</span>],nums[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># nums = [2,1,3]</span></span><br></pre></td></tr></table></figure><h3 id="判断是否为空列表"><a href="#判断是否为空列表" class="headerlink" title="判断是否为空列表"></a>判断是否为空列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> a:</span><br><span class="line">    print(<span class="string">"a is a null list"</span>)</span><br><span class="line"><span class="comment"># 输出：a is a null list</span></span><br></pre></td></tr></table></figure><h3 id="列表的连接"><a href="#列表的连接" class="headerlink" title="列表的连接"></a>列表的连接</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">c = a + b</span><br><span class="line">print(c)  <span class="comment"># [1, 2, 3, 6, 7, 8]</span></span><br><span class="line">d = a.extend(b)  <span class="comment"># extend()传入的参数需要是一个迭代对象 ：列表、元组、集合</span></span><br><span class="line">print(d) </span><br><span class="line"><span class="comment"># d 输出为None ,因为extend 无返回值，但是此时 a更改为[1, 2, 3, 6, 7, 8]</span></span><br></pre></td></tr></table></figure><h3 id="列表的排序函数"><a href="#列表的排序函数" class="headerlink" title="列表的排序函数"></a>列表的排序函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [2,4,6,5]</span><br><span class="line">b = a.sort()  # a = [2,4,5,6] , b = None</span><br><span class="line">a= [2,4,6,5]  </span><br><span class="line">b = sorted(a)  # a = [2, 4, 6, 5] , b = [2, 4, 5, 6]</span><br><span class="line"></span><br><span class="line">## sorted() 输出的是排序的结果，但是不更改传入的列表</span><br><span class="line">## sort() 直接对列表进行排序操作，并更改列表值</span><br></pre></td></tr></table></figure><h3 id="列表的置换顺序函数"><a href="#列表的置换顺序函数" class="headerlink" title="列表的置换顺序函数"></a>列表的置换顺序函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">b = a.reverse() <span class="comment"># a=[4,3,2,1] b = None</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于列表 nums<br>凡是可以进行 nums.function()，这样的函数，一般是无返回值的，直接对列表本身进行操作。<br>比如 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">nums.extend([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])     <span class="comment"># [1, 2, 3, 4, 1, 2, 3]</span></span><br><span class="line">nums.append(<span class="number">2</span>)           <span class="comment"># [1, 2, 3, 4, 1, 2, 3, 2]</span></span><br><span class="line">nums.sort()              <span class="comment"># [1, 1, 2, 2, 2, 3, 3, 4]</span></span><br><span class="line">nums.reverse()           <span class="comment"># [4, 3, 3, 2, 2, 2, 1, 1]</span></span><br><span class="line">nums.insert(<span class="number">5</span>,<span class="number">100</span>)       <span class="comment"># [4, 3, 3, 2, 2, 100, 2, 1, 1]    在索引为5的位置插入元素100</span></span><br></pre></td></tr></table></figure><ul><li>注意<br>nums.index(100)          # <strong>有返回值5</strong>, 查找对应元素<strong>首次出现</strong>所在位置的索引</li></ul><h3 id="数字转为列表-123-gt-“1”-“2”-“3”"><a href="#数字转为列表-123-gt-“1”-“2”-“3”" class="headerlink" title="数字转为列表  123 -&gt; [“1”, “2”, “3”]"></a>数字转为列表  123 -&gt; [“1”, “2”, “3”]</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">123</span></span><br><span class="line">A = list(str(num))  <span class="comment"># A = ['1', '2', '3']</span></span><br><span class="line">B = int(<span class="string">""</span>.join(A))  <span class="comment"># B = 123</span></span><br></pre></td></tr></table></figure><h3 id="中括号-for循环生成列表，，并使用判断"><a href="#中括号-for循环生成列表，，并使用判断" class="headerlink" title="中括号 for循环生成列表，，并使用判断"></a>中括号 for循环生成列表，，并使用判断</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">-7</span>,<span class="number">0</span>,]</span><br><span class="line">a = [<span class="number">1</span> <span class="keyword">if</span> num &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> num <span class="keyword">in</span> nums]</span><br><span class="line">print(a)   <span class="comment"># [1, 1, 0, 0]</span></span><br></pre></td></tr></table></figure><h2 id="python内置函数的复杂度"><a href="#python内置函数的复杂度" class="headerlink" title="python内置函数的复杂度"></a>python内置函数的复杂度</h2><p><a href="https://wiki.python.org/moin/TimeComplexity" target="_blank" rel="noopener">https://wiki.python.org/moin/TimeComplexity</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针(two pointers)</title>
      <link href="/2019/04/18/%E5%8F%8C%E6%8C%87%E9%92%88-two-pointers/"/>
      <url>/2019/04/18/%E5%8F%8C%E6%8C%87%E9%92%88-two-pointers/</url>
      
        <content type="html"><![CDATA[<ul><li>荷兰分区问题<br>可参考 <a href="https://blog.csdn.net/sylar_d/article/details/52742598" target="_blank" rel="noopener">https://blog.csdn.net/sylar_d/article/details/52742598</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pytorch0.4.0学习</title>
      <link href="/2019/04/18/pytorch0-4-0%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/04/18/pytorch0-4-0%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="不会的"><a href="#不会的" class="headerlink" title="不会的"></a>不会的</h2><ol><li>SGD 、 Adam中 的weight_decay 是干嘛的</li><li>SGD 中的 momentum是干嘛的，一般设置为多大</li><li>pytorch 中的初始化函数 </li><li>y = y.permute(0, 2, 1).contiguous()<br>这是干嘛的</li></ol><h3 id="学会的"><a href="#学会的" class="headerlink" title="学会的"></a>学会的</h3><ul><li>累加loss<br>以前（0.3.0）了累加loss(为了看loss的大小)一般是用total_loss+=loss.data[0] , 比较诡异的是, 为啥是.data[0]? 这是因为, 这是因为loss是一个Variable,<br>所以以后累加loss, 用loss.item().这个是必须的, 如果直接加, 那么随着训练的进行, 会导致后来的loss具有非常大的graph, 可能会超内存.<br>然而total_loss只是用来看的, 所以没必要进行维持这个graph!</li></ul><h3 id="pytorch-中-对tensor的一些函数"><a href="#pytorch-中-对tensor的一些函数" class="headerlink" title="pytorch 中 对tensor的一些函数"></a>pytorch 中 对tensor的一些函数</h3><ul><li><p>生成正态分布的随机张量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = torch.randn(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)  <span class="comment"># 正态分布的随机张量</span></span><br><span class="line">a.sum()                 <span class="comment"># 对a中的元素求和</span></span><br></pre></td></tr></table></figure></li><li><p>对tensor 求最大值</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">a</span> = torch.randn(<span class="number">10</span>,<span class="number">8</span>)</span><br><span class="line">max_value, max_index = <span class="keyword">a</span>.<span class="built_in">max</span>(<span class="number">1</span>)   </span><br><span class="line"><span class="comment"># 按照维度对a求最大值 ，此处为1，即得到（10,1）的张量，</span></span><br><span class="line"><span class="comment"># 有两个返回值，第一个返回值为具体的最大值为多少，第二个返回值为该最大值所在的索引</span></span><br></pre></td></tr></table></figure></li><li><p>判断两数有多少个元素相等</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = torch.tensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">b = torch.tensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>])</span><br><span class="line">a.eq(b)   # 输出 tensor([ <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">0</span>], dtype=torch.uint8)</span><br></pre></td></tr></table></figure></li><li><p>批矩阵相乘</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 批矩阵相乘 pytorch <span class="number">0.3</span><span class="number">.0</span></span><br><span class="line">output = torch.bmm(W, x)</span><br><span class="line"></span><br><span class="line"># 批矩阵相乘 pytorch <span class="number">0.4</span><span class="number">.0</span></span><br><span class="line">a = torch.randn(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">b = torch.rand(<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">c = torch.matmul(a, b)</span><br><span class="line">print(c.shape)  # torch.Size([<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line"># 在pytorch <span class="number">0.4</span><span class="number">.0</span>中使用torch.matmul 输入的参数是两个<span class="number">3</span>d的tensor ,tensor的首个维度是batch_size</span><br></pre></td></tr></table></figure></li><li><p>tensor 两个维度转置</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># tensor 两个维度转置</span><br><span class="line">x = torch.randn(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">x = x.permute(<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">print(x.shape)  # torch.Size([<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure></li><li><p>chunk  cat </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">torch.cat(inputs, <span class="attribute">dimension</span>=0) → Tensor</span><br><span class="line"><span class="comment"># cat 是将多个tensor按照指定的维度拼接起来</span></span><br><span class="line">torch.chunk(tensor, chunks, <span class="attribute">dim</span>=0)</span><br><span class="line"><span class="comment"># chunk是将某个tensor按照指定的维度进行拆分成指定的块数</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="初始化函数"><a href="#初始化函数" class="headerlink" title="初始化函数"></a>初始化函数</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import torch.nn as nn</span><br><span class="line">self.W = nn.Conv2d(in_channels=<span class="number">512</span>, out_channels=<span class="number">1024</span>, kernel_size=(<span class="number">3</span>,<span class="number">3</span>), \</span><br><span class="line">                   padding=(<span class="number">1</span>,<span class="number">1</span>), stride=(<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">nn.init.kaiming.normal(self.W.weight)</span><br><span class="line">nn.init.kaiming.uniform(self.W.weight)</span><br><span class="line">nn.init.constant(self.W.bias, <span class="number">0</span>)</span><br><span class="line"># 输出 tensor([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划(dynamic programming)</title>
      <link href="/2019/04/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dynamic-programming/"/>
      <url>/2019/04/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dynamic-programming/</url>
      
        <content type="html"><![CDATA[<h3 id="从起始点，走到终点"><a href="#从起始点，走到终点" class="headerlink" title="从起始点，走到终点"></a>从起始点，走到终点</h3><p>（1）共有多少路径<br>（2）哪条路径最短<br>对于grid 走路，只有两种走走法，这类问题，需要：   </p><ul><li>分析最后终点的结果，是怎么得来的：是由左邻和上邻的结果，进行某种运算得来的   </li><li>先将第一行、第一列进行初始化（结合具体问题）   </li><li>分析，递推公式，并采用自底向上的方式，因此，需要先高度的想，最后终点的递推公式，在结合这个公式，分析，在初始化之后，接下来的点，如何根据初始化的值，以及递推公式来计算得到。   </li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>分治递归： 一步一步的化解为小问题，最终由小问题再反向计算各大问题。自上而下   </li><li>动态规划：也需要得到递推公式，但是需要先将小问题的值写出来（初始化阶段），再根据递推公式，写for循环   </li></ul><h3 id="对于求解任意两个节点之间的值，并求全局最优解的问题，还需要再总结"><a href="#对于求解任意两个节点之间的值，并求全局最优解的问题，还需要再总结" class="headerlink" title="对于求解任意两个节点之间的值，并求全局最优解的问题，还需要再总结"></a>对于求解任意两个节点之间的值，并求全局最优解的问题，还需要再总结</h3><ul><li><a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-subarray/</a>  </li><li><a href="https://leetcode.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-product-subarray/</a>  </li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序(sort)</title>
      <link href="/2019/04/18/%E6%8E%92%E5%BA%8F-sort/"/>
      <url>/2019/04/18/%E6%8E%92%E5%BA%8F-sort/</url>
      
        <content type="html"><![CDATA[<ul><li>快速排序与冒泡排序均是进行交换操作，使用的空间复杂度为O(1)，而插入排序的空间复杂度为O(n)</li><li>快速排序的平均时间复杂度为O(nlogn)，最坏情况复杂度为O(n^2)</li><li>冒泡排序的时间复杂度为O(n^2)</li><li>插入排序的时间复杂度为O(n^2)</li></ul><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><blockquote><p>待补充</p></blockquote><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(nums, left, right)</span>:</span></span><br><span class="line">    tmp = left</span><br><span class="line">    reference = nums[left]  <span class="comment"># 以最左端的nums[left] 作为中位数</span></span><br><span class="line">    left = left</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] &lt;= reference:</span><br><span class="line">            left = left + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] &gt; reference:</span><br><span class="line">            right = right - <span class="number">1</span></span><br><span class="line">        nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">    <span class="keyword">if</span> nums[left] &lt; reference:</span><br><span class="line">        nums[left], nums[tmp] = nums[tmp], nums[left]</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        nums[left<span class="number">-1</span>], nums[tmp] = nums[tmp], nums[left<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> left<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">QuickSort</span><span class="params">(nums , left, right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; right:</span><br><span class="line">        index = partition(nums, left, right)</span><br><span class="line">        QuickSort(nums, left, index<span class="number">-1</span>)</span><br><span class="line">        QuickSort(nums, index+<span class="number">1</span>, right)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment"># nums = [1,2,3,4]</span></span><br><span class="line"><span class="comment"># nums = [3,2,5,6,4,4,4,5,6]</span></span><br><span class="line">left = <span class="number">0</span></span><br><span class="line">right = len(nums)<span class="number">-1</span></span><br><span class="line">QuickSort(nums, left, right)</span><br><span class="line">print(nums)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2019/04/18/%E7%AE%97%E6%B3%95/"/>
      <url>/2019/04/18/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ul><li><p><a href="https://blog.csdn.net/v_JULY_v/article/details/19131887" target="_blank" rel="noopener">别人的博客</a></p></li><li><p><a href="https://shiyaya.github.io/2019/04/18/%E5%8F%8C%E6%8C%87%E9%92%88-two-pointers/" target="_blank" rel="noopener">双指针</a></p></li><li><p><a href="https://shiyaya.github.io/2019/04/18/%E6%8E%92%E5%BA%8F-sort/" target="_blank" rel="noopener">排序</a></p></li><li><p><a href="https://shiyaya.github.io/2019/04/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dynamic-programming/" target="_blank" rel="noopener">动态规划</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 函数</title>
      <link href="/2019/04/10/python-%E5%87%BD%E6%95%B0/"/>
      <url>/2019/04/10/python-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>numpy广播</title>
      <link href="/2019/04/09/numpy%E5%B9%BF%E6%92%AD/"/>
      <url>/2019/04/09/numpy%E5%B9%BF%E6%92%AD/</url>
      
        <content type="html"><![CDATA[<ul><li>末尾有彩蛋</li></ul><h1 id="NumPy-广播-Broadcast"><a href="#NumPy-广播-Broadcast" class="headerlink" title="NumPy 广播(Broadcast)"></a>NumPy 广播(Broadcast)</h1><p>广播(Broadcast)是 numpy 对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。</p><p>如果两个数组 a 和 b 形状相同，即满足 <strong>a.shape == b.shape</strong>，那么 a*b 的结果就是 a 与 b 数组对应位相乘。这要求维数相同，且各维度的长度相同。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>import numpy as np    a = np.array([1,2,3,4])  b = np.array([10,20,30,40])  c = a * b  print (c)</p><p>输出结果为：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="number">10</span>  <span class="number">40</span>  <span class="number">90</span> <span class="number">160</span>]</span><br></pre></td></tr></table></figure><p>当运算中的 2 个数组的形状不同时，numpy 将自动触发广播机制。如：</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np    </span><br><span class="line">a = np.array([[ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],            [<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>],            [<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>],            [<span class="number">30</span>,<span class="number">30</span>,<span class="number">30</span>]]) </span><br><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) print(a + b)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[ <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [<span class="number">11</span> <span class="number">12</span> <span class="number">13</span>]</span><br><span class="line"> [<span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]</span><br><span class="line"> [<span class="number">31</span> <span class="number">32</span> <span class="number">33</span>]]</span><br></pre></td></tr></table></figure><p>下面的图片展示了数组 b 如何通过广播来与数组 a 兼容。</p><p><img src="http://www.runoob.com/wp-content/uploads/2018/10/image0020619.gif" alt="img"></p><p>4x3 的二维数组与长为 3 的一维数组相加，等效于把数组 b 在二维上重复 4 次再运算。</p><h2 id="yayay实例"><a href="#yayay实例" class="headerlink" title="yayay实例"></a>yayay实例</h2><p>在few-shot gnn任务中，想要计算邻接矩阵A，其公式为：<strong>a<sub>ij</sub> = fc(v<sub>i</sub>-v<sub>j</sub>)</strong><br>那么问题来了得到的邻接矩阵是N×N的，则计算的差值矩阵也应该是N×N的。那么该如何高效的计算出来这个差值矩阵。</p><pre><code class="python"><span class="keyword">import</span> numpy <span class="keyword">as</span> npN = <span class="number">10</span>D = <span class="number">7</span>X = np.ones((N,D))X1 = np.expand_dims(X, axis=<span class="number">0</span>)X2 = np.expand_dims(X, axis=<span class="number">1</span>)X_abs = np.abs(X1-X2)X_abs = np.reshape(X_abs, (N,N,D))X_T = X_abs ?????????????????需要考虑一下这个转置问题</code></pre>]]></content>
      
      
      <categories>
          
          <category> numpy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>少样本学习(few-shot learning)</title>
      <link href="/2019/04/09/%E5%B0%91%E6%A0%B7%E6%9C%AC%E5%AD%A6%E4%B9%A0-few-shot-learning/"/>
      <url>/2019/04/09/%E5%B0%91%E6%A0%B7%E6%9C%AC%E5%AD%A6%E4%B9%A0-few-shot-learning/</url>
      
        <content type="html"><![CDATA[<h2 id="小样本学习的概念"><a href="#小样本学习的概念" class="headerlink" title="小样本学习的概念"></a>小样本学习的概念</h2><ul><li>少样本学习(few-shot learning)的目标是在<strong>已知类别(Seen Class)训练一个分类模型，使它能够在只有少量数据的未知类别(Unseen Class)上面具有很好的泛化性能</strong>。</li><li>少样本学习面临两个重要的问题：<br>（1）已知类别和未知类别之间没有交集，导致它们的数据分布差别很大，不能直接通过训练分类器和微调(finetune)的方式得到很好的性能；<br>（2）未知类别只有极少量数据(每个类别1或者5个训练样本)，导致分类器学习不可靠。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>指数加权平均</title>
      <link href="/2019/04/09/%E6%8C%87%E6%95%B0%E5%8A%A0%E6%9D%83%E5%B9%B3%E5%9D%87/"/>
      <url>/2019/04/09/%E6%8C%87%E6%95%B0%E5%8A%A0%E6%9D%83%E5%B9%B3%E5%9D%87/</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="https://zhuanlan.zhihu.com/p/29895933" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29895933</a><br><a href="https://www.jianshu.com/p/41218cb5e099" target="_blank" rel="noopener">https://www.jianshu.com/p/41218cb5e099</a></p><h2 id="指数加权平均"><a href="#指数加权平均" class="headerlink" title="指数加权平均"></a>指数加权平均</h2><p><strong>v<sub>t</sub></strong> 是要代替  θ_t  的估计值，代表第t天的指数平均温度值<br><strong>θ<sub>t</sub></strong> 代表第t天的实际温度值<br><strong>β</strong> 代表可调节的超参数值  </p><p>则第t天的指数平均温度，可用如下公式表示<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1wnugwmkrj30ne0ggjsp.jpg" width="50%" height="50%">    </p><p>将<strong>v<sub>100</sub></strong> 展开可得:<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1wonisescj30j201o0sr.jpg"><br>v<sub>t</sub> 是对每天温度的加权平均，之所以称之为指数加权，是因为加权系数是随着时间以指数形式递减的，<strong>时间越靠近，权重越大</strong>，越靠前，权重越小。</p><p><img src="https://upload-images.jianshu.io/upload_images/1667471-485da343fbd96353.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/665/format/webp" alt><br>再来看下面三种情况：</p><p>当 β = 0.9 时，指数加权平均最后的结果如图<strong>红色线</strong>所示，代表的是最近 10 天的平均温度值；<br>当 β = 0.98 时，指结果如图<strong>绿色线</strong>所示，代表的是最近 50 天的平均温度值；<br>当 β = 0.5 时，结果如下图<strong>黄色线</strong>所示，代表的是最近 2 天的平均温度值；</p><p><img src="//upload-images.jianshu.io/upload_images/1667471-7d82e7b89e860299.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/473/format/webp" alt></p><p><img src="//upload-images.jianshu.io/upload_images/1667471-6fd989467bcb6121.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/475/format/webp" alt></p><p><strong>β 越小，噪音越多</strong>，虽然能够很快的适应温度的变化，但是更容易出现奇异值。</p><p><strong>β 越大，得到的曲线越平坦</strong>，因为多平均了几天的温度，这个曲线的波动更小。<br>但有个缺点是，因为只有 0.02 的权重给了当天的值，而之前的数值权重占了 0.98 ，<br>曲线进一步右移，在温度变化时就会适应地更缓慢一些，会出现一定延迟。</p><p>通过上面的内容可知，β 也是一个很重要的超参数，不同的值有不同的效果，需要调节来达到最佳效果，<strong>一般 0.9 的效果就很好</strong>。</p><p>作者：不会停的蜗牛<br>链接：<a href="https://www.jianshu.com/p/41218cb5e099" target="_blank" rel="noopener">https://www.jianshu.com/p/41218cb5e099</a><br>来源：简书  </p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>我们可以看到指数加权平均的求解过程实际上是一个递推的过程，那么这样就会有一个非常大的好处，每当我要求从0到某一时刻（n）的平均值的时候，我并不需要像普通求解平均值的作为，保留所有的时刻值，类和然后除以n。</p><p>而是只需要保留0-(n-1)时刻的平均值和n时刻的温度值即可。也就是每次只需要保留常数值，然后进行运算即可，这对于深度学习中的海量数据来说，是一个很好的减少内存和空间的做法。</p><h2 id="为什么在优化算法中使用指数加权平均"><a href="#为什么在优化算法中使用指数加权平均" class="headerlink" title="为什么在优化算法中使用指数加权平均"></a>为什么在优化算法中使用指数加权平均</h2><p>上面提到了一些 指数加权平均 的应用，这里我们着重看一下在优化算法中的作用。</p><p>以 Momentum 梯度下降法为例，</p><p><strong>Momentum 梯度下降法</strong>，就是计算了梯度的指数加权平均数，并以此来更新权重，它的运行<strong>速度几乎总是快于标准的梯度下降算法</strong>。</p><p><strong>这是为什么呢？</strong></p><p>让我们来看一下这个图，</p><p><img src="//upload-images.jianshu.io/upload_images/1667471-07d825d3e2624537.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/745/format/webp" alt></p><p>例如这就是我们要优化的成本函数的形状，图中红点就代表我们要达到的最小值的位置，<br>假设我们<strong>从左下角这里出发开始用梯度下降法</strong>，那么蓝色曲线就是一步一步迭代，一步一步向最小值靠近的轨迹。</p><p>可以看出<strong>这种上下波动，减慢了梯度下降法的速度</strong>，而且无法使用更大的学习率，因为如果用较大的学习率，可能会偏离函数的范围。</p><p>如果有一种方法，可以使得在纵轴上，学习得慢一点，减少这些摆动，但是在横轴上，学习得快一些，快速地从左向右移移向红点最小值，那么训练的速度就可以加快很多。</p><p>这个方法就是动量 Momentum 梯度下降法，它<strong>在每次计算梯度的迭代中，对 dw 和 db 使用了指数加权平均法的思想</strong>，</p><p><img src="//upload-images.jianshu.io/upload_images/1667471-eedf9342a4bce813.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/272/format/webp" alt></p><p>这样我们就可以得到如图红色线的轨迹：</p><p><img src="//upload-images.jianshu.io/upload_images/1667471-f9e70b57daae0359.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/718/format/webp" alt></p><p>可以看到：<br><strong>纵轴方向</strong>，平均过程中正负摆动相互抵消，平均值接近于零，摆动变小，学习放慢。<br><strong>横轴方向</strong>，因为所有的微分都指向横轴方向，因此平均值仍然较大，向最小值运动更快了。<br>在抵达最小值的路上减少了摆动，加快了训练速度。</p><p>作者：不会停的蜗牛<br>链接：<a href="https://www.jianshu.com/p/41218cb5e099" target="_blank" rel="noopener">https://www.jianshu.com/p/41218cb5e099</a><br>来源：简书  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>模型剪枝 Model Pruning</title>
      <link href="/2019/04/09/%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D-Model-Pruning/"/>
      <url>/2019/04/09/%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D-Model-Pruning/</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="https://xmfbit.github.io/2018/10/03/paper-summary-model-pruning/" target="_blank" rel="noopener">https://xmfbit.github.io/2018/10/03/paper-summary-model-pruning/</a><br>L1正则化项，加入损失函数中，可以对特征进行选择。<br>L1也可以应用到模型压缩任务中，选择某个filter是否有存在的必要，从而决定是否要剪掉。</p>]]></content>
      
      
      <categories>
          
          <category> 模型压缩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模型压缩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频分类总结</title>
      <link href="/2019/04/09/%E8%A7%86%E9%A2%91%E5%88%86%E7%B1%BB%E6%80%BB%E7%BB%93/"/>
      <url>/2019/04/09/%E8%A7%86%E9%A2%91%E5%88%86%E7%B1%BB%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="Two-Stream"><a href="#Two-Stream" class="headerlink" title="Two-Stream"></a>Two-Stream</h3><ul><li>训练<br>（1）spatial net：每个video中随机提取1帧：224<em>224</em>3，进行训练，<br>（2）temporal net：每个video中选取L=10帧光流，224<em>224</em>2L，进行训练<br>由于含有x,y 方向，因此10帧光流，对应的5帧图像，该5帧是连续的</li><li>测试：每个video中平均采25帧，并通过crop and flip等操作扩增10倍，整个video的得分，是这250帧的平均得分。</li></ul><h3 id="TSN"><a href="#TSN" class="headerlink" title="TSN"></a>TSN</h3><ul><li>训练，将video分段，默认为3段<br>（1）spatial net：每个video分成N段，每段随机提取1帧，则得到N帧，这N帧共享参数，一起训练，N帧分别得到的score进行平均，作为video的分数，并反向传播，训练。<br>（2）temporal net ,同理，每个video分成N段，每段随机提取L=10帧，这N段共享参数，一起训练，N段分别得到的score进行平均，作为video的分数，并反向传播，训练。</li><li>测试，将video分段，默认为25段</li><li>同训练过程</li></ul><h3 id="C3D"><a href="#C3D" class="headerlink" title="C3D"></a>C3D</h3><ul><li>在Sports-1M上进行训练，训练完成之后便得到一个video feature extractor </li><li>训练：在每个video中随机剪切5个2s长的clip，对clip进行训练 </li><li>测试：对于一个video，含有N帧，则将这N帧分成16帧的clips，每相邻的两个clips重叠8帧，然后将这些clips得到的fc6 activations 进行<strong>平均得到video feature</strong>，进而送入分类层得到video class label</li></ul><h3 id="I3D"><a href="#I3D" class="headerlink" title="I3D"></a>I3D</h3><ul><li>video 以25帧/秒的帧率来提取关键帧</li><li>训练：以64帧组成的snippets进行训练。</li><li>测试：同样以64帧组成的snippets进行测试，但是对于该video上的所有的snippet的<strong>预测结果进行取平均</strong>作为该video的预测结果</li></ul>]]></content>
      
      
      <categories>
          
          <category> 行为识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I3D</title>
      <link href="/2019/04/09/I3D/"/>
      <url>/2019/04/09/I3D/</url>
      
        <content type="html"><![CDATA[<ul><li>参考:<a href="https://zhuanlan.zhihu.com/p/34919655" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34919655</a></li></ul><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1wgkib11aj310b0ew77m.jpg">  <h3 id="训练和预测"><a href="#训练和预测" class="headerlink" title="训练和预测"></a>训练和预测</h3><ul><li>写在前面，方便看，哈哈哈哈</li><li>video 以25帧/秒的帧率来提取关键帧</li><li>在训练时，以64帧组成的snippets进行训练。</li><li>在测试时，同样以64帧组成的snippets进行测试，但是对于该video上的所有的snippet的预测结果进行取平均作为该video的预测结果</li></ul><h3 id="方法1：ConvNet-LSTM"><a href="#方法1：ConvNet-LSTM" class="headerlink" title="方法1：ConvNet+LSTM"></a><strong>方法1：ConvNet+LSTM</strong></h3><ul><li>该方案主要考虑到cnn在图像分类领域的成功以及LSTM对于序列建模的能力，很自然提出将两者结合起来的方案。如果只是用cnn的话，需要对每一帧都提取特征，然后将视频的所有帧特征进行总汇，以此来表达对视频的表示，显然这样做忽略的时间结构特征。而LSTM可以处理长时间依赖的问题，可以对视频从第一帧开始建模直到最后一帧，使用cnn网络对每帧提取特征，然后将特征送入LSTM来捕捉时间特征，最后一帧的输出用来对视频特征表示。<br>  LSTM往往依赖cnn的最后一层特征最为输入，因此不能够捕捉到<code>low-level motion</code>的特征，而且对于遍历整个视频也很难去训练。<h3 id="方法2：3D-ConvNets"><a href="#方法2：3D-ConvNets" class="headerlink" title="方法2：3D ConvNets"></a><strong>方法2：3D ConvNets</strong></h3></li><li><code>3D ConvNets</code>是对视频建模最自然的方式，和标准cnn区别在于由<code>2d conv</code>变为<code>3d conv</code>，来捕捉<code>spatio-temporal feature</code>。想法很好，但目前遇到一些问题，问题一：<code>3D ConvNets</code>的<code>3d conv</code>多了一个维度，参数量有较大增加，这将会很难去训练。问题二：没有利用那些Imagenet上成功的预训练模型来迁移学习，往往使用层数少的cnn在小数据集上从头训练。简要说就是要利用已有预训练模型，要减少参数或增大数据集。<br>  论文中实现了C3D（与原版略有差异）有8 conv layer、5 pooling layer 和 2 fc layer，并在所有圈卷积层和fc层加bn。输入是16×112×112（通过crop方法），将第一个pooling layer对时间的stride由1变成2，为了可以减少memory和允许更大batch。<h3 id="方法3：Two-Stream-Networks"><a href="#方法3：Two-Stream-Networks" class="headerlink" title="方法3：Two-Stream Networks"></a><strong>方法3：Two-Stream Networks</strong></h3></li><li>该方案利用短的视频段来建模，用每个clip的预测分数平均的方式（其实C3D也是类似），但不同的是输入，包括一张RGB和10张<code>optical flow</code>(其实是5张，x/y两个方向，运动特征)。模型能使用<code>two-branch</code>方式，利用预训练的imagenet模型，最后将预测结果平均下（最原始的，或者在最后softmax做融合），这样建模的模型比较好训练，同时也能获得更高的分数。  </li><li>模型的两个输入流也可以在后面的cnn层来进行融合，以提升相同，同时可以<code>end-to-end</code>训练。论文实现一个类似的two-stream方案，在最后一层用<code>3d conv</code>将spatial和flow特征进行融合。<h3 id="方法4：Two-Stream-Inflated-3D-ConvNets"><a href="#方法4：Two-Stream-Inflated-3D-ConvNets" class="headerlink" title="方法4：Two-Stream Inflated 3D ConvNets"></a><strong>方法4：Two-Stream Inflated 3D ConvNets</strong></h3></li><li>该方案是论文提出的，出发点是要利用imagenet的预训练模型，同时利用<code>3d conv</code>来提取<code>RGB stream</code>的<code>temporal feature</code>，最后再利用<code>optical-flow stream</code>提升网络性能，也就大融合的方案（把有效的技巧都用上）。  </li><li>通过对预训练的<code>2D conv</code>增加temporal维度，把N×N的filter变为N×N×N。简单的办法就是对N×N的filter重复复制N遍，并归一化，这样多的出发点是短期内时间不变性的假设，姑且把这当成<code>3D filter</code>初始化的一种策略吧。  </li><li>池化操作怎么膨胀？stride怎么选？主要依赖感受野尺寸，如果图像水平方向和竖直方向相等，那么stride也相等，而且越深的特征感受野越大。但是考虑到时间因素，对称感受野不是必须的，这主要还是依赖帧率和图片大小。时间相对于空间变化过快，将合并不同object的边信息，过慢将不能捕捉场景变化。  </li><li>虽然3D conv能够捕捉motion信息，但是与光流优化的方式和效果还是不一样，因此使用<code>two-stream</code>的方式构建，并分开训练两个网络。</li></ul><p><img src="https://pic2.zhimg.com/80/v2-34f1d3ac14884d5c9114d4e9383c2e89_hd.jpg" alt></p><hr><ul><li><p>数据集不同，评测结果也不同。flow在UCF-101上效果比HMDB-51、kinetics上好（有更多camera运动的原因）。<br><img src="https://pic2.zhimg.com/80/v2-e719a0a3a022e348838d4b6a5c0b8a55_hd.jpg" alt></p></li><li><p>在imagenet上训练后迁移到kinetics和直接在kinetics上的对比，迁移后的效果好，说明RGB流起的作用大。整体上I3D模型参数更少，更深，训练输入在时间和空间维度上都比C3D大。<br><img src="https://pic3.zhimg.com/80/v2-b358535638c000de801577fc84296252_hd.jpg" alt></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 行为识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C3D</title>
      <link href="/2019/04/09/C3D/"/>
      <url>/2019/04/09/C3D/</url>
      
        <content type="html"><![CDATA[<p>pytorch 中</p><h3 id="Conv2d"><a href="#Conv2d" class="headerlink" title="Conv2d"></a>Conv2d</h3><p><a href="https://pytorch.org/docs/stable/nn.html#conv2d" target="_blank" rel="noopener">https://pytorch.org/docs/stable/nn.html#conv2d</a><br>the shape of input:  <font size="5," color="#0099ff">batch×channel×height×width</font></p><h3 id="Conv3d"><a href="#Conv3d" class="headerlink" title="Conv3d"></a>Conv3d</h3><p><a href="https://pytorch.org/docs/stable/nn.html#conv3d" target="_blank" rel="noopener">https://pytorch.org/docs/stable/nn.html#conv3d</a><br>the shape of input: <font size="5," color="#0099ff">batch×channel×depth×height×width</font></p><h3 id="C3D-用于行为识别-1-2"><a href="#C3D-用于行为识别-1-2" class="headerlink" title="C3D 用于行为识别[1][2]"></a>C3D 用于行为识别[1][2]</h3><p>[1] C3D 的网络结构</p><ul><li>输入： bs×3×<font size="5," color="#0099ff">16</font>×H×W，即输入一个长为16的视频序列clip</li><li>输出： bs×feature_size</li></ul><p>对于一个video，含有N帧，则将这N帧分成16帧的clips，每相邻的两个clips重叠8帧，然后将这些clips得到的fc6 activations 进行平均得到video feature，进而送入分类层得到video class label</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1] Learning spatiotemporal features with 3d convolutional networks.  CVPR 2015<br>[2] Can Spatiotemporal 3D CNNs Retrace the History of 2D CNNs and ImageNet?  CVPR 2018</p>]]></content>
      
      
      <categories>
          
          <category> 行为识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频格式</title>
      <link href="/2019/04/09/%E8%A7%86%E9%A2%91%E6%A0%BC%E5%BC%8F/"/>
      <url>/2019/04/09/%E8%A7%86%E9%A2%91%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[ <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1w907erjdj30800ffq31.jpg">  <h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><ul><li>为了更好的对视频进行传输，需要对视频进行压缩编码</li><li>当前的对video中<strong>图像</strong>的压缩方法有两大阵营，MPEG系列和H.26x系列，</li><li>得到压缩后的图像和音频之后，需要组合封装起来，这时就需要一个容器，可以使用AVI、MPEG等进行封装</li><li>最后为了将该video用系统上的某个视频播放器来开，还需要给其添加个后缀名，一般采用了某个封装格式就会有相应的后缀名，但是若我们更改某个video的文件名，也不会改变video的实质。</li><li>如在上图中视频流压缩采用的是H.26系列，但是文件类型却是mp4，即容器采用的是MPEG封装格式</li></ul><h2 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h2><p>作者：袁园<br>链接：<a href="https://www.zhihu.com/question/20997688/answer/30720197" target="_blank" rel="noopener">https://www.zhihu.com/question/20997688/answer/30720197</a><br>来源：知乎<br>在生活语境里所说的“视频格式”，在学术上有两个概念与之对应：Container format (封装格式)和Codec (暂且译为“编解码格式”)。</p><h3 id="1-Container-format-封装格式"><a href="#1-Container-format-封装格式" class="headerlink" title="1. Container format (封装格式)"></a><strong>1. Container format (封装格式)</strong></h3><p>Container format 描述了视频文件的结构。正如它的字面含义所说，它是对一个“容器”的规范。一个视频文件往往会包含图像和音频，还有一些配置信息(如图像和音频的关联，如何解码它们等)：这些内容需要按照一定的规则组织、存储起来，Container format就是这些规则。<br>如果一个视频文件是以某个Container format封装起来的，那么它的后缀名一般会体现出来。所以，后缀名只是形式，只是为了便于识别(例如，windows系统会根据文件的后缀名决定以什么程序打开它)，无决定性的意义。</p><h3 id="2-Codec-编解码格式"><a href="#2-Codec-编解码格式" class="headerlink" title="2. Codec (编解码格式)"></a><strong>2. Codec (编解码格式)</strong></h3><p>Codec是一种压缩标准。而文件的压缩/还原是通过编/解码实现的，所以Codec也可理解成编/解码标准。要知道，未经过处理的原始视频和音频文件十分巨大，不好存储、传输。为了节省磁盘空间和网络带宽，原始的视频和音频文件都会通过编码压缩体积，然后需要播放时再通过逆向过程解码还原。Codec就是规定编/解码实现细节(数字存储空间、帧速率、比特率、分辨率等)的标准，不同的标准对于压缩的质量和效率有影响。<br>世界上有两大制定这套标准的阵营：ITU-T VCEG(Visual Coding Experts Group，国际电联旗下的标准化组织)和MPEG(Moving Picture Experts Group, ISO旗下的组织)。MPEG系列标准是MPEG制定的，H.26x系列标准是ITU-T制定的。</p><h3 id="3-Container-format-封装格式-和Codec-编解码格式-有关系吗？"><a href="#3-Container-format-封装格式-和Codec-编解码格式-有关系吗？" class="headerlink" title="3. Container format (封装格式)**和Codec** (编解码格式)**有关系吗？**"></a><strong>3. Container format</strong> <strong>(封装格式)**</strong>和Codec** <strong>(编解码格式)**</strong>有关系吗？**</h3><p>不妨将视频文件看作容器(Container)，那么这个容器里盛放的就是遵循某种Codec的内容(Content)。一个容器里应该能放下视频、音频、数据信息，即使它们遵循的Codec不相同。例如，QuickTime File Format (.MOV)支持几乎所有的Codec，MPEG(.MP4)也支持相当广的Codec。所以，单从视频文件的格式是无法获知它的质量细节的，这些细节取决与采用的Codec。比较专业的说法是，“给我一个H.264 Quicktime文件(.mov)”。</p><h3 id="4-为何还是有点迷糊？"><a href="#4-为何还是有点迷糊？" class="headerlink" title="4. 为何还是有点迷糊？"></a><strong>4. 为何还是有点迷糊？</strong></h3><p>以上的解释是从学术角度出发的，在学术上区分它们没有一点障碍。但现实生活中人们不会一丝不苟地区分“Container format ”“Codec”，往往只会说“这是一个mov格式的文件”。这是将日常用语与学术术语混为一谈导致的理解混乱。</p><p>另外，Container format和Codec的命名法有点奇葩，明白人有时也会晕。例如，“MPEG-4”既是“Container format ”，也是“Codec”，这确实够烦的。</p>]]></content>
      
      
      <categories>
          
          <category> 视频处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频解码</title>
      <link href="/2019/04/09/%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81/"/>
      <url>/2019/04/09/%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<ul><li><p>opencv提取关键帧（banet）</p></li><li><p>ffmpeg提取关键帧 （video to text）</p></li><li><p>i帧、P帧、B帧</p></li><li><p>参考：<a href="https://blog.csdn.net/huangblog/article/details/8739876" target="_blank" rel="noopener">https://blog.csdn.net/huangblog/article/details/8739876</a><br>I帧，Intra-coded frame：是一张完整的图片<br>P帧，predictive frame: 记录了与之前真的差别，在解码P帧之前需要参考之前的图片帧<br>B帧，Bi-Predictive frame: 不仅需要参考之前的图片帧，还需要参考之后的图片帧，才能完整解码。<br>因此解码P帧、B帧的速度相对较慢，直接解码I帧可以获得更快的速度。</p></li></ul><p><strong>简单地讲，I帧是一个完整的画面，而P帧和B帧记录的是相对于I帧的变化。没有I帧，P帧和B帧就无法解码</strong>  </p><h3 id="GOP"><a href="#GOP" class="headerlink" title="GOP"></a>GOP</h3><p>所谓GOP，意思是画面组，一个GOP就是一组连续的画面。从一个I帧到下一个I帧之间的所有帧的组合称为一个GOP。</p><ul><li><p><strong>I帧</strong><br>I帧是参考帧，一个GOP中必须含有I帧，它是一个全帧压缩编码帧。它将全帧图像信息进行JPEG压缩编码及传输。</p></li><li><p><strong>P帧的预测与重构:</strong><br>P帧是以I帧为参考帧,在I帧中找出P帧“某点”的预测值和运动矢量,取预测差值和运动矢量一起传送。在接收端根据运动矢量从I帧中找出P帧“某点”的预测值并与差值相加以得到P帧“某点”样值,从而可得到完整的P帧。</p></li><li><p><strong>B帧的预测与重构：</strong><br>B帧以前面的I或P帧和后面的P帧为参考帧,“找出”B帧“某点”的预测值和两个运动矢量,并取预测差值和运动矢量传送。接收端根据运动矢量在两个参考帧中“找出(算出)”预测值并与差值求和,得到B帧“某点”样值,从而可得到完整的B帧。</p></li><li><p><strong>用下图中的1234567帧来表达</strong><br>首先由1：I帧，<br>再由1、4帧得到第4帧所在位置处的图像信息<br>最后由1、4、2得到第2帧所在位置处的图像信息，由1、4、3得到第3帧所在位置处的图像信息</p></li></ul><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1w7ki6x02j30ra0ge0st.jpg">  <ul><li>另外一张图  </li></ul><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1w7ki8pfvj30nm0fk77r.jpg"><hr><h3 id="视频压缩：I帧、P帧、B帧"><a href="#视频压缩：I帧、P帧、B帧" class="headerlink" title="视频压缩：I帧、P帧、B帧"></a>视频压缩：I帧、P帧、B帧</h3><ul><li>来源： <a href="https://blog.csdn.net/huangblog/article/details/8739876" target="_blank" rel="noopener">https://blog.csdn.net/huangblog/article/details/8739876</a></li></ul><p>视频压缩中，每帧代表一幅静止的图像。而在实际压缩时，会采取各种算法减少数据的容量，其中IPB就是最常见的。</p><pre><code>简单地说，I帧是关键帧，属于帧内压缩。就是和AVI的压缩是一样的。P是向前搜索的意思。B是双向搜索。他们都是基于I帧来压缩数据。</code></pre><p>   I帧表示关键帧，你可以理解为这一帧画面的完整保留；解码时只需要本帧数据就可以完成（因为包含完整画面）</p><p>   P帧表示的是这一帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是差别帧，P帧没有完整画面数据，只有与前一帧的画面差别的数据）</p><p>   B帧是双向差别帧，也就是B帧记录的是本帧与前后帧的差别（具体比较复杂，有4种情况），换言之，要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时CPU会比较累~。</p><pre><code>采用的压缩方法: 分组:把几帧图像分为一组(GOP),为防止运动变化,帧数不宜取多。    1.定义帧:将每组内各帧图像定义为三种类型,即I帧、B帧和P帧;    2.预测帧:以I帧做为基础帧,以I帧预测P帧,再由I帧和P帧预测B帧;    3.数据传输:最后将I帧数据与预测的差值信息进行存储和传输。</code></pre><p>一、I帧  </p><pre><code>I图像（帧）是靠尽可能去除图像空间冗余信息来压缩传输数据量的帧内编码图像。I帧又称为内部画面 (intra picture)，I 帧通常是每个 GOP（MPEG 所使用的一种视频压缩技术）的第一个帧，经过适度地压缩（做为随机访问的参考点）可以当成图象。在MPEG编码的过程中部分视频帧序列压缩成为I帧，部分压缩成P帧，还有部分压缩成B帧。I帧法是帧内压缩法（P、B为帧间），也称为“关键帧”压缩法。I帧法是基于离散余弦变换DCT（Discrete Cosine Transform）的压缩技术，这种算法与JPEG压缩算法类似。采用I帧压缩可达到1/6的压缩比而无明显的压缩痕迹。I帧特点：    1.它是一个全帧压缩编码帧。它将全帧图像信息进行JPEG压缩编码及传输;    2.解码时仅用I帧的数据就可重构完整图像;    3.I帧描述了图像背景和运动主体的详情;    4.I帧不需要参考其他画面而生成;    5.I帧是P帧和B帧的参考帧(其质量直接影响到同组中以后各帧的质量);    6.I帧是帧组GOP的基础帧(第一帧),在一组中只有一个I帧;    7.I帧不需要考虑运动矢量;    8.I帧所占数据的信息量比较大。I帧编码流程：    (1)进行帧内预测，决定所采用的帧内预测模式。    (2)像素值减去预测值，得到残差。    (3)对残差进行变换和量化。    (4)变长编码和算术编码。    (5)重构图像并滤波，得到的图像作为其它帧的参考帧。</code></pre><p>二、P帧</p><pre><code> P图像（帧）是通过充分降低于图像序列中前面已编码帧的时间冗余信息来压缩传输数据量的编码图像，也叫预测帧。在针对连续动态图像编码时，将连续若干幅图像分成P,B,I三种类型，P帧由在它前面的P帧或者I帧预测而来，它比较与它前面的P帧或者I帧之间的相同信息或数据，也即考虑运动的特性进行帧间压缩。P帧法是根据本帧与相邻的前一帧（I帧或P帧）的不同点来压缩本帧数据。采取P帧和I帧联合压缩的方法可达到更高的压缩且无明显的压缩痕迹。P帧的预测与重构:    P帧是以I帧为参考帧,在I帧中找出P帧“某点”的预测值和运动矢量,取预测差值和运动矢量一起传送。在接收端根据运动矢量从I帧中找出P帧“某点”的预测值并与差值相加以得到P帧“某点”样值,从而可得到完整的P帧。P帧特点：    ①P帧是I帧后面相隔1-2帧的编码帧。      ②P帧采用运动补偿的方法传送它与前面的I或P帧的差值及运动矢量（预测误差）。      ③解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧图像。      ④P帧属于前向预测的帧间编码。它只参考前面最靠近它的I帧或P帧。      ⑤P帧可以是其后面P帧的参考帧，也可以是其前后的B帧的参考帧。    ⑥由于P帧是参考帧，它可能造成解码错误的扩散。     ⑦由于是差值传送，P帧的压缩比较高。</code></pre><p>三、B帧</p><pre><code>B图像（帧）是既考虑与源图像序列前面已编码帧，也顾及源图像序列后面已编码帧之间的时间冗余信息来压缩传输数据量的编码图像，也叫双向预测帧。   B帧法是双向预测的帧间压缩算法。当把一帧压缩成B帧时，它根据相邻的前一帧、本帧以及后一帧数据的不同点来压缩本帧，也即仅记录本帧与前后帧的差值。只有采用B帧压缩才能达到200：1的高压缩。一般地，I帧压缩效率最低，P帧较高，B帧最高。B帧的预测与重构：    B帧以前面的I或P帧和后面的P帧为参考帧,“找出”B帧“某点”的预测值和两个运动矢量,并取预测差值和运动矢量传送。接收端根据运动矢量在两个参考帧中“找出(算出)”预测值并与差值求和,得到B帧“某点”样值,从而可得到完整的B帧。B帧特点：    1.B帧是由前面的I或P帧和后面的P帧来进行预测的;    2.B帧传送的是它与前面的I或P帧和后面的P帧之间的预测误差及运动矢量;    3.B帧是双向预测编码帧;    4.B帧压缩比最高,因为它只反映2参考帧间运动主体的变化情况,预测比较准确;    5.B帧不是参考帧,不会造成解码错误的扩散。 P 帧和 B 帧编码的基本流程为：    (1)进行运动估计，计算采用帧间编码模式的率失真函数(节)值。P 帧 只参考前面的帧，B 帧可参考后面的帧。    (2)进行帧内预测，选取率失真函数值最小的帧内模式与帧间模式比较，确定采用哪种编码模式。    (3)计算实际值和预测值的差值。    (4)对残差进行变换和量化。    (5)若编码，如果是帧间编码模式，编码运动矢量。注:I、B、P各帧是根据压缩算法的需要,是人为定义的,它们都是实实在在的物理帧,至于图像中的哪一帧是I帧,是随机的,一但确定了I帧,以后的各帧就严格按规定顺序排列。 </code></pre><p>四、实际应用</p><pre><code>从上面的解释看，我们知道I和P的解码算法比较简单，资源占用也比较少，I只要自己完成就行了，P呢，也只需要解码器把前一个画面缓存一下，遇到P时就使用之前缓存的画面就好了，如果视频流只有I和P，解码器可以不管后面的数据，边读边解码，线性前进，大家很舒服。但网络上的电影很多都采用了B帧，因为B帧记录的是前后帧的差别，比P帧能节约更多的空间，但这样一来，文件小了，解码器就麻烦了，因为在解码时，不仅要用之前缓存的画面，还要知道下一个I或者P的画面（也就是说要预读预解码），而且，B帧不能简单地丢掉，因为B帧其实也包含了画面信息，如果简单丢掉，并用之前的画面简单重复，就会造成画面卡（其实就是丢帧了），并且由于网络上的电影为了节约空间，往往使用相当多的B帧，B帧用的多，对不支持B帧的播放器就造成更大的困扰，画面也就越卡。一般平均来说，I的压缩率是7（跟JPG差不多），P是20，B可以达到50，可见使用B帧能节省大量空间，节省出来的空间可以用来保存多一些I帧，这样在相同码率下，可以提供更好的画质。</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python类的继承</title>
      <link href="/2019/04/08/python%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
      <url>/2019/04/08/python%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<ul><li>参考：<a href="https://www.cnblogs.com/bigberg/p/7182741.html" target="_blank" rel="noopener">https://www.cnblogs.com/bigberg/p/7182741.html</a>  </li></ul><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><h3 id="1-继承的定义"><a href="#1-继承的定义" class="headerlink" title="1. 继承的定义"></a>1. 继承的定义</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span>   <span class="comment"># 定义一个父类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span>    <span class="comment"># 父类中的方法</span></span><br><span class="line">        print(<span class="string">"person is talking...."</span>)  </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span><span class="params">(Person)</span>:</span>    <span class="comment"># 定义一个子类， 继承Person类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">walk</span><span class="params">(self)</span>:</span>      <span class="comment"># 在子类中定义其自身的方法</span></span><br><span class="line">        print(<span class="string">'is walking...'</span>)</span><br><span class="line"> </span><br><span class="line">c = Chinese()</span><br><span class="line">c.talk()      <span class="comment"># 调用继承的Person类的方法</span></span><br><span class="line">c.walk()     <span class="comment"># 调用本身的方法</span></span><br></pre></td></tr></table></figure><p>输出</p><blockquote><p>person is talking….<br>is walking…</p></blockquote><h2 id="2-构造函数的继承"><a href="#2-构造函数的继承" class="headerlink" title="2. 构造函数的继承"></a>2. 构造函数的继承</h2><p>如果我们要给实例 c 传参，我们就要使用到构造函数，那么构造函数该如何继承，同时子类中又如何定义自己的属性？</p><p>继承类的构造方法：<br>1.经典类的写法： 父类名称.<strong>init</strong>(self,参数1，参数2，…)  </p><ol start="2"><li><font color="#0059ff" size="5" face="黑体"> 新式类的写法：super(子类，self).<strong>init</strong>(参数1，参数2，….)</font></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span>  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span>  </span><br><span class="line">        self.name = name  </span><br><span class="line">        self.age = age  </span><br><span class="line">        self.weight = <span class="string">'weight'</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        print(<span class="string">"person is talking...."</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span><span class="params">(Person)</span>:</span>  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, language)</span>:</span>  <span class="comment"># 先继承，在重构  </span></span><br><span class="line">Person.__init__(self, name, age)  </span><br><span class="line"><span class="comment"># 继承父类的构造方法，也可以写成：</span></span><br><span class="line"><span class="comment"># super(Chinese,self).__init__(name,age)  </span></span><br><span class="line">        self.language = language  <span class="comment"># 定义类的本身属性  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">walk</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        print(<span class="string">'is walking...'</span>)  </span><br><span class="line">        </span><br><span class="line">c = Chinese(<span class="string">'bigberg'</span>, <span class="number">22</span>, <span class="string">'Chinese'</span>)  </span><br><span class="line">print(c.name)  </span><br><span class="line">print(c.language)</span><br><span class="line">c.talk()</span><br></pre></td></tr></table></figure><p>输出</p><blockquote><p>bigberg<br>Chinese<br>person is talking….</p></blockquote><h3 id="3-子类对父类方法的重写"><a href="#3-子类对父类方法的重写" class="headerlink" title="3.子类对父类方法的重写"></a>3.子类对父类方法的重写</h3><p>如果我们对基类/父类的方法需要修改，可以在子类中重构该方法。如下的talk()方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span>  </span><br><span class="line">        self.name = name  </span><br><span class="line">        self.age = age  </span><br><span class="line">        self.weight = <span class="string">'weight'</span>  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        print(<span class="string">"person is talking...."</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span><span class="params">(Person)</span>:</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, language)</span>:</span>  </span><br><span class="line">        Person.__init__(self, name, age)  </span><br><span class="line">        self.language = language  </span><br><span class="line">        print(self.name, self.age, self.weight, self.language)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span>  <span class="comment"># 子类 重构方法  </span></span><br><span class="line">  print(<span class="string">'%s is speaking chinese'</span> % self.name)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">walk</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        print(<span class="string">'is walking...'</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">c = Chinese(<span class="string">'bigberg'</span>, <span class="number">22</span>, <span class="string">'Chinese'</span>)  </span><br><span class="line">c.talk()</span><br></pre></td></tr></table></figure><p>输出</p><blockquote><p>bigberg 22 weight Chinese<br>bigberg is speaking chinese</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谱聚类</title>
      <link href="/2019/04/08/%E8%B0%B1%E8%81%9A%E7%B1%BB/"/>
      <url>/2019/04/08/%E8%B0%B1%E8%81%9A%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<ul><li><p>先占位置</p></li><li><p><a href="https://www.cnblogs.com/pinard/p/6221564.html" target="_blank" rel="noopener">参考某博客</a>  </p></li><li><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.SpectralClustering.html#sklearn.cluster.SpectralClustering" target="_blank" rel="noopener">sklearn.cluster.SpectralClustering</a></p><ul><li>References<br>Normalized cuts and image segmentation, 2000 Jianbo Shi, Jitendra Malik <a href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.160.2324" target="_blank" rel="noopener">http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.160.2324</a><br>A Tutorial on Spectral Clustering, 2007 Ulrike von Luxburg <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.165.9323" target="_blank" rel="noopener">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.165.9323</a><br>Multiclass spectral clustering, 2003 Stella X. Yu, Jianbo Shi <a href="http://www1.icsi.berkeley.edu/~stellayu/publication/doc/2003kwayICCV.pdf" target="_blank" rel="noopener">http://www1.icsi.berkeley.edu/~stellayu/publication/doc/2003kwayICCV.pdf</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图卷积网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图卷积网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spectral Networks and Deep Locally Connected Networks on Graphs</title>
      <link href="/2019/04/08/Spectral-Networks-and-Deep-Locally-Connected-Networks-on-Graphs/"/>
      <url>/2019/04/08/Spectral-Networks-and-Deep-Locally-Connected-Networks-on-Graphs/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>(SCST)Self-critical Sequence Training for Image Captioning</title>
      <link href="/2019/04/08/SCST-Self-critical-Sequence-Training-for-Image-Captioning/"/>
      <url>/2019/04/08/SCST-Self-critical-Sequence-Training-for-Image-Captioning/</url>
      
        <content type="html"><![CDATA[<p>强化学习中的策略梯度法可以针对那些不可微分的度量进行优化，<br>本文中，使用强化学习的方法来优化图像描述任务，将这个新的优化方法称为self-critical sequence training (SCST)。</p><p><strong>sequence models for image captioning的理想训练过程， 应该是避免 exposure bias 并且可以直接优化任务中的度量</strong></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="图像描述方面的现状"><a href="#图像描述方面的现状" class="headerlink" title="图像描述方面的现状"></a><strong>图像描述方面的现状</strong></h3><p>[1] <strong>show attend and tell</strong> 证明在caption任务中，使用attention机制是有益处的。<br>[2] <strong>Teacher-Forcing</strong> 用于文本的deep generative models 的训练方法一般是：给定上一步word的ground truth 来最大化该步生成word的最大似然，来反向传播。这个方法称为“Teacher-Forcing”  。但是这种方法导致在训练和测试时很不匹配。因为在测试时，该步生成的单词是在给定上一步预测出的单词的前提下。  </p><ul><li><p>这个exposure  bias [2]导致在测试时产生误差累积，因为模型从未暴露于其自己的预测中。<br>This exposure  bias [2], results in error accumulation during generation at  test time,<br>since the model has never been exposed to its own  predictions</p><p>一些克服exposure bias的方法[3] [4]<br>[3] <strong>Scheduled sampling</strong> 他们表明，反馈模型自己的预测，并在训练过程中缓慢地增加反馈概率p，可以显着地提高测试时间的性能。<br>[4] <strong>Professor forcing</strong> a  technique that uses adversarial training to encourage the dynamics of the recurrent network to be the same when training conditioned on ground truth previous words and when  sampling freely from the network</p></li></ul><h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><h3 id="实验结果证明"><a href="#实验结果证明" class="headerlink" title="实验结果证明"></a>实验结果证明</h3><p>we find that directly optimizing the CIDEr metric with  SCST and greedy decoding at test-time is highly effective.</p><h2 id="Image-Features"><a href="#Image-Features" class="headerlink" title="Image Features"></a>Image Features</h2><ul><li>FC Models<br>由CNN+FC得到image 的 特征向量，并送入LSTM中，来生成caption<br>但是需要注意的是仅在first step 输入该特征向量，其余步输入上一步生成的word (embedding)   </li><li>Spatial CNN features for Attention models<br>在不缩放也不裁剪图片的基础上，使用resnet-101来提取最后一个卷积层的特征，并应用apply spatially adaptive max-pooling来得到一个固定的尺寸14 × 14 × 2048。在每一个time step，attention model在这14 × 14=196个位置上计算一个<font color="#0099ff" size="6" face="黑体"> attention mask</font>（注意力系数/权重）。由这个mask 计算所有位置的加权求和，以此得到image feature。  </li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] Show, attend and tell: Neural image caption generation with visual attention. In ICML,  2015.<br>[2] Sequence level training with recurrent neural networks. ICLR, 2015.<br>[3] Scheduled sampling for sequence prediction with recurrent neural networks. In NIPS, 2015.<br>[4] Professor forcing: A  new algorithm for training recurrent networks. Neural Information Processing Systems. (NIPS) 2016.  </p>]]></content>
      
      
      <categories>
          
          <category> 图像描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像描述 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bottom-Up and Top-Down Attention for Image Captioning and Visual Question Answering</title>
      <link href="/2019/04/07/Bottom-Up-and-Top-Down-Attention-for-Image-Captioning-and-Visual-Question-Answering/"/>
      <url>/2019/04/07/Bottom-Up-and-Top-Down-Attention-for-Image-Captioning-and-Visual-Question-Answering/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在object级别上计算 attention<br><strong>bottom-up</strong>: 使用Faster R-CNN 来提取 object，并得到相对应的特征向量。<br><strong>top-down</strong>: 用来计算attention 的系数，作为bottom-up中得到的每个object feature 的权重。</p><h2 id="概括："><a href="#概括：" class="headerlink" title="概括："></a>概括：</h2><p><strong>（1）Bottom-Up</strong><br>使用Faster R-CNN 中的R-CNN来得到object feature。<br><strong>（2）Top-Down Attention</strong><br>得到了该层的隐层状态，并与object features  中的每一个<strong>v<sub>i</sub></strong>来计算一个attention 系数。<br><strong>（3）对object features 进行attention 权重求和</strong><br>得到image feature<br><strong>（4）Decoder：language LSTM</strong><br>输出预测单词</p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g19d1x7kiij30im0bvaat.jpg" style="zoom:60%">  <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14xg3jwvdj30mo0h2wfi.jpg" style="zoom:60%"><h2 id="Bottom-Up"><a href="#Bottom-Up" class="headerlink" title="Bottom-Up"></a>Bottom-Up</h2><ul><li><strong>主要介绍一下Faster R-CNN 的训练过程</strong><br>（1）首先Resnet-101 是在ImageNet上预训练的<br>（2）Faster R-CNN在MS COCO上进行预训练<br>rpn 的score classification loss，bbox regression loss<br>r-cnn 的score classification loss，bbox regression loss<br>（3）Faster R-CNN在Visual Genome上再进行预训练<br>为了得到更好的特征表达，增加一个预测属性的输出： </li><li><strong>具体的网络：</strong><br>To predict attributes for region i, we concatenate the mean  pooled convolutional feature vi with a learned embedding  of the ground-truth object class, and feed this into an additional output layer defining a softmax distribution over each  attribute class plus a ‘no attributes’ class.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 图像描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像描述 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>self.training in pytorch</title>
      <link href="/2019/04/07/self-training-in-pytorch/"/>
      <url>/2019/04/07/self-training-in-pytorch/</url>
      
        <content type="html"><![CDATA[<ul><li>代码来源于：<a href="https://zhuanlan.zhihu.com/p/26893755" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26893755</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable, Function</span><br><span class="line"></span><br><span class="line">x_train = np.array([[<span class="number">3.3</span>], [<span class="number">4.4</span>], [<span class="number">5.5</span>], [<span class="number">6.71</span>], [<span class="number">6.93</span>], [<span class="number">4.168</span>],</span><br><span class="line">                    [<span class="number">9.779</span>], [<span class="number">6.182</span>], [<span class="number">7.59</span>], [<span class="number">2.167</span>], [<span class="number">7.042</span>],</span><br><span class="line">                    [<span class="number">10.791</span>], [<span class="number">5.313</span>], [<span class="number">7.997</span>], [<span class="number">3.1</span>]], dtype=np.float32)</span><br><span class="line"></span><br><span class="line">y_train = np.array([[<span class="number">1.7</span>], [<span class="number">2.76</span>], [<span class="number">2.09</span>], [<span class="number">3.19</span>], [<span class="number">1.694</span>], [<span class="number">1.573</span>],</span><br><span class="line">                    [<span class="number">3.366</span>], [<span class="number">2.596</span>], [<span class="number">2.53</span>], [<span class="number">1.221</span>], [<span class="number">2.827</span>],</span><br><span class="line">                    [<span class="number">3.465</span>], [<span class="number">1.65</span>], [<span class="number">2.904</span>], [<span class="number">1.3</span>]], dtype=np.float32)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x_train = torch.from_numpy(x_train)</span><br><span class="line">y_train = torch.from_numpy(y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"---------------------------------------"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearRegression</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(LinearRegression, self).__init__()</span><br><span class="line">        self.linear = nn.Linear(<span class="number">1</span>, <span class="number">1</span>)  <span class="comment"># input and output is 1 dimension</span></span><br><span class="line">        print(<span class="string">"self.training: "</span> + str(self.training))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        out = self.linear(x)</span><br><span class="line">        print(<span class="string">"self.training；"</span> + str(self.training))</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">print(<span class="string">"initialize"</span>)</span><br><span class="line">model = LinearRegression()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"---------------------------------------"</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"model.eval()"</span>)</span><br><span class="line">model.eval()</span><br><span class="line">inputs = Variable(x_train)</span><br><span class="line">target = Variable(y_train)</span><br><span class="line"><span class="comment"># forward</span></span><br><span class="line">out = model(inputs) <span class="comment"># 前向传播</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"---------------------------------------"</span>)</span><br><span class="line">print(<span class="string">"model.train()"</span>)</span><br><span class="line">model.train()</span><br><span class="line">inputs = Variable(x_train)</span><br><span class="line">target = Variable(y_train)</span><br><span class="line"><span class="comment"># forward</span></span><br><span class="line">out = model(inputs) <span class="comment"># 前向传播</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tensorboard_logger</title>
      <link href="/2019/04/06/tensorboard-logger/"/>
      <url>/2019/04/06/tensorboard-logger/</url>
      
        <content type="html"><![CDATA[<p>使用tensorboard_logger记录训练过程中的数据<br>（1）首先需要安装tensorflow</p><ul><li>可参考<a href="https://blog.csdn.net/love666666shen/article/details/77099843" target="_blank" rel="noopener">https://blog.csdn.net/love666666shen/article/details/77099843</a></li><li>不需要单独设置一个tensorflow的环境，直接pip install 一个CPU 版本的即可</li><li>pip install –ignore-installed –upgrade <a href="https://storage.googleapis.com/tensorflow/windows/cpu/tensorflow-1.1.0-cp35-cp35m-win_amd64.whl" target="_blank" rel="noopener">https://storage.googleapis.com/tensorflow/windows/cpu/tensorflow-1.1.0-cp35-cp35m-win_amd64.whl</a></li></ul><p>（2）安装tensorboard</p><ul><li>pip install tensorboard</li></ul><p>（3）No scalar data was found的解决<br>只需将cmd目录cd进入日志文件存放的目录，再加载日志文件便可解决：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">f:</span></span><br><span class="line">cd logdir</span><br><span class="line">tensorboard --logdir=<span class="string">F:</span>\logdir</span><br></pre></td></tr></table></figure><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1szi2wjhyj30it0c7mxh.jpg">https://blog.csdn.net/LOOKTHEWIND/article/details/70767799]]></content>
      
      
      
        <tags>
            
            <tag> tensorboard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>range xrange np.arange np.linspace</title>
      <link href="/2019/04/05/range-xrange-np-arange-np-linspace/"/>
      <url>/2019/04/05/range-xrange-np-arange-np-linspace/</url>
      
        <content type="html"><![CDATA[<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1rmpadk75j309a07saa2.jpg"><p>python</p><ul><li>xrange 得到一个迭代器，（仅可以在python2中使用）</li><li>range 得到一个列表，（python2/python3均可）</li></ul><p>numpy</p><ul><li>numpy.arange 得到一份数组</li><li>numpy.linspace <strong>得到固定数量的等间隔数组，注意包含指定的尾部</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> numpy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>glob.glob vs os.listdir</title>
      <link href="/2019/04/05/glob-glob-vs-os-listdir/"/>
      <url>/2019/04/05/glob-glob-vs-os-listdir/</url>
      
        <content type="html"><![CDATA[<ul><li>现在想要得到某个文件夹下的一些图片，并按照顺序排列，如下图所示：  </li></ul><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1rl9d9xq9j30ia0cbjri.jpg">  <ul><li>第一种方法：（得到的frames_list是不包含路径的）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frames_list = sorted(os.listdir(video_path))</span><br></pre></td></tr></table></figure></li></ul><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1rlb8uq8aj309h0a8q2z.jpg"><ul><li>第二种方法：（得到的frames_list包含路径的）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frames_list = sorted(glob.glob(os.path.join(video_path, <span class="string">'*.jpg'</span>)))</span><br></pre></td></tr></table></figure></li></ul><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1rlbroiqmj30nt0b40u9.jpg"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>os.listdir 仅可以得到对当前路径下文件名称，但是不包含路径信息<br>glob.glob 可以得到对当前路径下文件名称，并包含路径信息</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python list sort方法</title>
      <link href="/2019/04/04/python-list-sort%E6%96%B9%E6%B3%95/"/>
      <url>/2019/04/04/python-list-sort%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><strong>sort()</strong> 函数用于对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>sort()方法语法：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.sort(<span class="attribute">cmp</span>=None, <span class="attribute">key</span>=None, <span class="attribute">reverse</span>=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li>cmp – 可选参数, 如果指定了该参数会使用该参数的方法进行排序。</li><li>key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</li><li>reverse – 排序规则，<strong>reverse = True</strong> 降序， <strong>reverse = False</strong> 升序（默认）。</li></ul><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>该方法没有返回值，但是会对列表的对象进行排序。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">video_sort_lambda = <span class="keyword">lambda</span> x: int(x[<span class="number">3</span>:<span class="number">-4</span>]) <span class="comment"># 定义一个函数对元素x进行操作，并得到一个整数Int</span></span><br><span class="line">video_root = <span class="string">"/userhome/dataset/MSVD/Video-Description-with-Spatial-Temporal-Attention/youtube"</span></span><br><span class="line">videos = sorted(os.listdir(video_root), key=video_sort_lambda) <span class="comment"># 按得到的整数，对list进行排序</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytohn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>史雅雅的收藏夹</title>
      <link href="/2019/04/04/%E5%8F%B2%E9%9B%85%E9%9B%85%E7%9A%84%E6%94%B6%E8%97%8F%E5%A4%B9/"/>
      <url>/2019/04/04/%E5%8F%B2%E9%9B%85%E9%9B%85%E7%9A%84%E6%94%B6%E8%97%8F%E5%A4%B9/</url>
      
        <content type="html"><![CDATA[<p><a href="http://pygments.org/" target="_blank" rel="noopener">http://pygments.org/</a></p><p><a href="https://202.38.95.226:7443/view.html" target="_blank" rel="noopener">https://202.38.95.226:7443/view.html</a></p><p><a href="https://aideadlin.es/?sub=ML,RO,CV,SP,NLP,DM" target="_blank" rel="noopener">https://aideadlin.es/?sub=ML,RO,CV,SP,NLP,DM</a></p><p><a href="https://yjs.ustc.edu.cn/" target="_blank" rel="noopener">https://yjs.ustc.edu.cn/</a></p><p><a href="https://www.json.cn/" target="_blank" rel="noopener">https://www.json.cn/</a></p><p><a href="https://kevinj-huang.github.io/" target="_blank" rel="noopener">https://kevinj-huang.github.io/</a></p><p><a href="https://shiyaya.github.io/" target="_blank" rel="noopener">https://shiyaya.github.io/</a></p><p><a href="https://stackedit.io/app#" target="_blank" rel="noopener">https://stackedit.io/app#</a></p><p><a href="http://jsonviewer.stack.hu/" target="_blank" rel="noopener">http://jsonviewer.stack.hu/</a></p><p><a href="http://www.nlpjob.com/" target="_blank" rel="noopener">http://www.nlpjob.com/</a></p><p><a href="https://nlp.stanford.edu/software/scenegraph-parser.shtml#Usage" target="_blank" rel="noopener">https://nlp.stanford.edu/software/scenegraph-parser.shtml#Usage</a></p><p><a href="https://paperswithcode.com/sota" target="_blank" rel="noopener">https://paperswithcode.com/sota</a></p>]]></content>
      
      
      <categories>
          
          <category> 杂类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytorch 减小显存消耗，优化显存使用，避免out of memory</title>
      <link href="/2019/04/03/pytorch-%E5%87%8F%E5%B0%8F%E6%98%BE%E5%AD%98%E6%B6%88%E8%80%97%EF%BC%8C%E4%BC%98%E5%8C%96%E6%98%BE%E5%AD%98%E4%BD%BF%E7%94%A8%EF%BC%8C%E9%81%BF%E5%85%8Dout-of-memory/"/>
      <url>/2019/04/03/pytorch-%E5%87%8F%E5%B0%8F%E6%98%BE%E5%AD%98%E6%B6%88%E8%80%97%EF%BC%8C%E4%BC%98%E5%8C%96%E6%98%BE%E5%AD%98%E4%BD%BF%E7%94%A8%EF%BC%8C%E9%81%BF%E5%85%8Dout-of-memory/</url>
      
        <content type="html"><![CDATA[<h3 id="本文是整理了大神的两篇博客："><a href="#本文是整理了大神的两篇博客：" class="headerlink" title="本文是整理了大神的两篇博客："></a>本文是整理了大神的两篇博客：</h3><ul><li><p>如何计算模型以及中间变量的显存占用大小：<br><a href="https://oldpan.me/archives/how-to-calculate-gpu-memory" target="_blank" rel="noopener">https://oldpan.me/archives/how-to-calculate-gpu-memory</a></p></li><li><p>如何在Pytorch中精细化利用显存：<br><a href="https://oldpan.me/archives/how-to-use-memory-pytorch" target="_blank" rel="noopener">https://oldpan.me/archives/how-to-use-memory-pytorch</a></p></li><li><p>还有知乎中大神的解答：<br><a href="https://zhuanlan.zhihu.com/p/31558973" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31558973</a></p></li><li><p>ppt<br><a href="https://www.zhihu.com/question/67209417" target="_blank" rel="noopener">https://www.zhihu.com/question/67209417</a></p></li><li><p>在说之前先推荐一个实时监控内存显存使用的小工具：</p></li></ul><blockquote><p>sudo apt-get install htop</p></blockquote><ul><li>监控内存（-d为更新频率，下为每0.1s更新一次）：</li></ul><blockquote><p>htop -d=0.1</p></blockquote><ul><li>监控显存（-n为更新频率，下为每0.1s更新一次）：</li></ul><blockquote><p>watch -n 0.1 nvidia-smi</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>torch.backends.cudnn.benchmark = true 使用情形</title>
      <link href="/2019/04/03/torch-backends-cudnn-benchmark-true-%E4%BD%BF%E7%94%A8%E6%83%85%E5%BD%A2/"/>
      <url>/2019/04/03/torch-backends-cudnn-benchmark-true-%E4%BD%BF%E7%94%A8%E6%83%85%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.pytorchtutorial.com/when-should-we-set-cudnn-benchmark-to-true/" target="_blank" rel="noopener">pytorch-torch.backends.cudnn.benchmark文档</a></p><ul><li>torch.backends.cudnn.benchmark<br>设置这个 flag 可以让内置的 cuDNN 的 auto-tuner 自动寻找最适合当前配置的高效算法，来达到优化运行效率的问题。</li></ul><p>应该遵循以下准则：</p><ul><li>如果网络的输入数据维度或类型上变化不大，设置  torch.backends.cudnn.benchmark = true  可以增加运行效率；</li><li>如果网络的输入数据在每次 iteration 都变化的话，会导致 cnDNN 每次都会去寻找一遍最优配置，这样反而会降低运行效率。</li><li>在程序刚开始加这条语句可以提升一点训练速度，没什么额外开销。</li><li>有时候可能是因为每次迭代都会引入点临时变量，会导致训练速度越来越慢，基本呈线性增长。<br>开发人员还不清楚原因，但如果周期性的使用torch.cuda.empty_cache()的话就可以解决这个问题。这个命令是清除没用的临时变量的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题经验</title>
      <link href="/2019/04/02/%E5%88%B7%E9%A2%98%E7%BB%8F%E9%AA%8C/"/>
      <url>/2019/04/02/%E5%88%B7%E9%A2%98%E7%BB%8F%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="输入输出的部分，需要注意："><a href="#输入输出的部分，需要注意：" class="headerlink" title="输入输出的部分，需要注意："></a>输入输出的部分，需要注意：</h3><ul><li>输出的地方，需要看人家是否<strong>保留固定的位数</strong>，否则输出的结果也是错误的</li></ul>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stanford Scene Graph Parser</title>
      <link href="/2019/03/26/Stanford-Scene-Graph-Parser/"/>
      <url>/2019/03/26/Stanford-Scene-Graph-Parser/</url>
      
        <content type="html"><![CDATA[<ul><li>官网：<a href="https://nlp.stanford.edu/software/scenegraph-parser.shtml#Usage" target="_blank" rel="noopener">https://nlp.stanford.edu/software/scenegraph-parser.shtml#Usage</a></li></ul><h2 id="下载相应的文件（官网有）"><a href="#下载相应的文件（官网有）" class="headerlink" title="下载相应的文件（官网有）"></a>下载相应的文件（官网有）</h2><ul><li>stanford-corenlp-full-2015-12-09.zip</li><li>scenegraph-1.0.jar<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2></li></ul><ol><li>将stanford-corenlp-full-2015-12-09.zip解压，然后按照博客<a href="https://shiyaya.github.io/2019/03/26/ubuntu-%E5%AE%89%E8%A3%85-Stanford-CoreNLP/" target="_blank" rel="noopener">ubuntu 安装 Stanford CoreNLP</a>来安装corenlp</li><li>需要将 scenegraph-1.0.jar 放入解压之后的文件夹stanford-corenlp-full-2015-12-09中，</li></ol><ul><li><p>需要注意版本</p></li><li><p>java  idk 1.8+ 按照博客来就可以</p></li><li><p>corenlp 使用人家给定的2015的，不要升级</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -mx2g -cp <span class="string">"*"</span> edu.stanford.nlp.scenegraph.RuleBasedParser</span><br></pre></td></tr></table></figure></li><li><p>注意该命令是在stanford-corenlp-full-2015-12-09文件夹下执行的<br>该方法是交互式的，提示你输入句子，他给出相对应的解析出的scene graph</p></li></ul><p>法2：</p>]]></content>
      
      
      <categories>
          
          <category> 自然语言理解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自然语言理解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu 安装 Stanford CoreNLP</title>
      <link href="/2019/03/26/ubuntu-%E5%AE%89%E8%A3%85-Stanford-CoreNLP/"/>
      <url>/2019/03/26/ubuntu-%E5%AE%89%E8%A3%85-Stanford-CoreNLP/</url>
      
        <content type="html"><![CDATA[<h3 id="安装java-jdk"><a href="#安装java-jdk" class="headerlink" title="安装java jdk"></a>安装java jdk</h3><ul><li><p>更新软件包列表：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure></li><li><p>安装openjdk-8-jdk：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="builtin-name">get</span> install openjdk-8-jdk</span><br></pre></td></tr></table></figure></li><li><p>查看java版本：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -<span class="built_in">version</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="下载并解压Stanford-coreNLP-包："><a href="#下载并解压Stanford-coreNLP-包：" class="headerlink" title="下载并解压Stanford coreNLP 包："></a>下载并解压Stanford coreNLP 包：</h3><ul><li>从这里下载<br><a href="https://stanfordnlp.github.io/CoreNLP/download.html" target="_blank" rel="noopener">https://stanfordnlp.github.io/CoreNLP/download.html</a><br>或者以命令行方式下载<blockquote><p>wget <a href="http://nlp.stanford.edu/software/stanford-corenlp-full-2018-02-27.zip" target="_blank" rel="noopener">http://nlp.stanford.edu/software/stanford-corenlp-full-2018-02-27.zip</a>  </p></blockquote></li></ul><ul><li><p>解压</p><blockquote><p>unzip stanford-corenlp-full-2018-02-27.zip</p></blockquote></li><li><p>转到文件目录</p></li></ul><blockquote><p>cd stanford-corenlp-full-2018-02-27/</p></blockquote><h3 id="配置环境变量："><a href="#配置环境变量：" class="headerlink" title="配置环境变量："></a>配置环境变量：</h3><p>把下列这行代码加到你的.bashrc里面(vim .bashrc)</p><blockquote><p> cd ~<br>vim .bashrc<br>export CLASSPATH=/path/to/stanford-corenlp-full-2018-02-27/stanford-corenlp-3.9.1.jar<br>source ~/.bashrc  ## 使之生效<br>把/path/to/替换为你保存stanford-corenlp-full-2016-10-31的地方的路径</p></blockquote><h3 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h3><blockquote><p>pip install stanfordcorenlp</p></blockquote><p>处理中文还需要下载中文的模型jar文件，然后放到stanford-corenlp-full-2018-02-27根目录下即可</p><p>wget <a href="http://nlp.stanford.edu/software/stanford-chinese-corenlp-2018-02-27-models.jar" target="_blank" rel="noopener">http://nlp.stanford.edu/software/stanford-chinese-corenlp-2018-02-27-models.jar</a></p><h3 id="检查自己是否装好了stanfordcorenlp"><a href="#检查自己是否装好了stanfordcorenlp" class="headerlink" title="检查自己是否装好了stanfordcorenlp"></a>检查自己是否装好了stanfordcorenlp</h3><p>进入python2或者python3</p><p>命令行下输入：</p><blockquote><p>python</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> stanfordcorenlp <span class="keyword">import</span> StanfordCoreNLP</span><br></pre></td></tr></table></figure><p>能成功导入不报错，就是安装成功了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java</title>
      <link href="/2019/03/26/java%20%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/"/>
      <url>/2019/03/26/java%20%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="java-的编译与执行"><a href="#java-的编译与执行" class="headerlink" title="java 的编译与执行"></a>java 的编译与执行</h2><ol><li><p>用文本编辑器新建一个yumhtest.java文件，在其中输入以下代码并保存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">yumhtest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译：在shell终端执行命令 <strong>javac yumhtest.java</strong></p></li><li><p>运行：在shell终端执行命令 <strong>java yumhtest</strong><br>当shell下出现“hello world !”字样</p></li></ol><p>注意事项：类名应和文件名相同。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java 的编译与执行</title>
      <link href="/2019/03/26/java/"/>
      <url>/2019/03/26/java/</url>
      
        <content type="html"><![CDATA[<h2 id="java-的编译与执行"><a href="#java-的编译与执行" class="headerlink" title="java 的编译与执行"></a>java 的编译与执行</h2><ol><li><p>用文本编辑器新建一个yumhtest.java文件，在其中输入以下代码并保存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">yumhtest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译：在shell终端执行命令 <strong>javac yumhtest.java</strong></p></li><li><p>运行：在shell终端执行命令 <strong>java yumhtest</strong><br>当shell下出现“hello world !”字样</p></li></ol><p>注意事项：类名应和文件名相同。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPICE</title>
      <link href="/2019/03/25/SPICE/"/>
      <url>/2019/03/25/SPICE/</url>
      
        <content type="html"><![CDATA[<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><h3 id="Ubuntu下安装Stanford-CoreNLP"><a href="#Ubuntu下安装Stanford-CoreNLP" class="headerlink" title="Ubuntu下安装Stanford CoreNLP"></a><a href="https://blog.csdn.net/Hay54/article/details/82313535" target="_blank" rel="noopener">Ubuntu下安装Stanford CoreNLP</a></h3>]]></content>
      
      
      <categories>
          
          <category> 自然语言理解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自然语言理解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>faster r-cnn 解读</title>
      <link href="/2019/03/24/faster-r-cnn-%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/03/24/faster-r-cnn-%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>来自<a href="https://mp.weixin.qq.com/s/M_i38L2brq69BYzmaPeJ9w" target="_blank" rel="noopener">机器之心</a><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e0ltm2y7j30u0083wev.jpg"><br>by yaya:<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e10a6tguj31fj0mw0vw.jpg"></p><h2 id="RPN"><a href="#RPN" class="headerlink" title="RPN"></a>RPN</h2><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e0p68j95j30t80gaaar.jpg" style="zoom:60%"><p>anchor: 定义anchor的长: scale=[4,8,16], 长宽比: ratio=[0.5, 1, 1.5, 2]，则在each position of conv feature 将会有k=len(scale)×len(ratio)=12个anchor</p><p>(1)对于分类层，我们对每个锚点输出两个预测值：它是背景（不是目标）的分数，和它是前景（实际的目标）的分数.<br><br>则经过该1×1的卷积层，输出的shape=N×2k×H×W  <br><br>(2)对于回归或边框调整层，我们输出四个预测值：Δxcenter、Δycenter、Δwidth、Δheight，我们将会把这些值用到锚点中来得到最终的建议.<br><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e0p66yxyj312w066t91.jpg"></p><h2 id="R-CNN"><a href="#R-CNN" class="headerlink" title="R-CNN"></a>R-CNN</h2><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e0p6ekybj30u00c175l.jpg"><p>有两个不同的目标：<br><br>(1) 将建议分到一个类中，加上一个背景类（用于删除不好的建议）。<br><br>(2) 根据预测的类别更好地调整建议的边框。<br><br>在最初的 Faster R-CNN 论文中，R-CNN 对每个建议采用特征图，将它平坦化并使用两个大小为 4096 的有 ReLU 激活函数的全连接层。然后，它对每个不同的目标使用两种不同的全连接层：<br><br>一个有 N+1 个单元的全连接层，其中 N 是类的总数，另外一个是背景类。<br><br>一个有 4N 个单元的全连接层。我们希望有一个回归预测，因此对 N 个类别中的每一个可能的类别，我们都需要 Δcenterx、Δcentery、Δwidth、Δheight。<br><br>训练和目标<br><br>R-CNN 的目标与 RPN 的目标的计算方法几乎相同，但是考虑的是不同的可能类别。我们采用建议和真实边框，并计算它们之间的 IoU。<br></p><p>那些有任何真实边框的建议，只要其 IoU 大于 0.5，都被分配给那个真实数据。那些 IoU 在 0.1 和 0.5 之间的被标记为背景。与我们在为 RPN 分配目标时相反的是，我们忽略了没有任何交集的建议。这是因为在这个阶段，我们假设已经有好的建议并且我们对解决更困难的情况更有兴趣。当然，这些所有的值都是可以为了更好的拟合你想找的目标类型而做调整的超参数。<br></p><p>边框回归的目标是计算建议和与其对应的真实框之间的偏移量，仅针对那些基于 IoU 阈值分配了类别的建议。<br></p><p>我们随机抽样了一个尺寸为 64 的 balanced mini batch，其中我们有高达 25% 的前景建议（有类别）和 75% 的背景。<br></p><p>按照我们对 RPN 损失所做的相同处理方式，现在的分类损失是一个多类别的交叉熵损失，使用所有选定的建议和用于与真实框匹配的 25% 建议的 Smooth L1 loss。由于 R-CNN 边框回归的全连接网络的输出对于每个类都有一个预测，所以当我们得到这种损失时必须小心。在计算损失时，我们只需要考虑正确的类。<br><br>这里若假定类别可知，则每个类都有预测，若类别不可知，则仅有一个预测即可，代码如下：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e0p66uafj30nq03vt8o.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 目标检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Image Caption 常用评价指标</title>
      <link href="/2019/03/24/Image-Caption-%E5%B8%B8%E7%94%A8%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"/>
      <url>/2019/03/24/Image-Caption-%E5%B8%B8%E7%94%A8%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Graph R-CNN for Scene Graph Generation</title>
      <link href="/2019/03/24/Graph-R-CNN-for-Scene-Graph-Generation/"/>
      <url>/2019/03/24/Graph-R-CNN-for-Scene-Graph-Generation/</url>
      
        <content type="html"><![CDATA[<p>这是ECCV 2018 场景图生成 的一篇文章。<br>写在前面，本文使用的GCN网络与“Graph Attention Networks”一致，都是计算两个节点之间的attention来计算邻接矩阵中的元素值，更新节点特征的公式是AXW。</p><ul><li><strong>查看本文的原因，主要是想看，其是如何提取relation feature的，但是文中仅使用了union box feature 作为relation feature。较为朴素！</strong>—————–不好</li><li><strong>同时也将relation 作为node放入graph 中，但是是object feature 与 realtion feature之间的混合graph，与“Auto-Encoding Scene Graphs for Image Captioning”一样采用的是异构图</strong>  </li><li><strong>文中对W<sup>sr</sup>Z<sup>r</sup>α<sup>sr</sup>， 为该node<sub>i</sub>与所有的relation nodes之间计算的注意力系数，并不合理，因为object 可能仅有一两个relation，怎么可能与所有的relation有关系呢</strong>————————–不好（后又考虑了一下，可能没有关系的直接算0，就不再计算attention了）</li></ul><p>思索良久，终于发现是哪里不对了，一般的情况下，都是X’=AXW，这样的形式，以 X 为中心，更新X的特征，而Z<sub>i</sub><sup>r</sup>的更新公式中是以Z<sup>o</sup>为中心，因此是不是有些不对头呢？？？</p><p>本文的<strong>两个主要的贡献</strong>：</p><ol><li><strong>GCN</strong> with attention 用于scene graph generate 任务。Updating each object and relationship representation based on its neighbors</li><li>对于N个object ,若两两配对，则会产生N×N个relation，数量是N的二次，数量很多，但是很多又是没有必要的，以前的工作采用随机采样的方式，但是本文提出了<strong>RePN 网络来采样relation</strong>。</li><li>提出了一个新的用于scene graph generate 的评价指标，SGGen+（不是笔者关注的内容，因此此处忽略了对SGGen+的介绍）</li></ol><h2 id="场景图生成任务的主要步骤"><a href="#场景图生成任务的主要步骤" class="headerlink" title="场景图生成任务的主要步骤"></a>场景图生成任务的主要步骤</h2><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1dxanmhpfj312o08p75l.jpg">    <ol><li>P( V|I )  指：在给定image的情况下，去得到 <strong>object proposals</strong><br>使用pytorch 版本[1]的faster R-CNN来得到 bbox，类似于[2]，采用分段训练的方式，先对faster R-CNN进行预训练，然后，固定faster r-cnn参数，训练整个场景图生成网络。  </li><li>P( E|V, I ) 指：在给定image 和 bbox的情况下来得到 <strong>relation proposals</strong><br>如果假设每个object proposals 之间都会有一个relation，则有N×N个relation，或者是说，有N×N个object pairs。但是含有很多不合适的relation（本身这object pairs 之间不存在关系，但是却指定了某种关系），因此本文提出使用ReRN 网络来采样得到 relatedness relations。</li><li>P( R,O|V,E,I ) 指： 在给定image，object proposals以及relation proposal之后，得到object label 和 relation label。<br>一般的方法是采用iterative refinement process[2]，本文使用的是用GCN来迭代。</li></ol><ul><li>overview<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1dy02tb1zj31du0crajb.jpg"></li></ul><h2 id="Object-Proposal"><a href="#Object-Proposal" class="headerlink" title="Object Proposal"></a>Object Proposal</h2><p>使用faster r-cnn来提取<strong>object proposals</strong>，并得到相对应的一维特征向量（<strong>pooled feat</strong>），faster r-cnn 使用类别可知，则可以得到每个object 对应的<strong>label</strong><br>使用</p><h2 id="Relation-Proposal-Network"><a href="#Relation-Proposal-Network" class="headerlink" title="Relation Proposal Network"></a>Relation Proposal Network</h2><p>输入： <strong>labels</strong> of object pairs<br>输出：relatedness relations/ m 个object pairs<br>主要的步骤见下图：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e8ud0p66j32v311qjyg.jpg"></p><h2 id="Attention-GCN"><a href="#Attention-GCN" class="headerlink" title="Attention GCN"></a>Attention GCN</h2><h3 id="Formulation"><a href="#Formulation" class="headerlink" title="Formulation"></a>Formulation</h3><ul><li>与GAT的公式是一致的，具体可以参看论文GAT[ 3]，<strong>α<sub>i</sub></strong> 是注意力系数<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e8wl8yubj30f60360sr.jpg" style="zoom:60%"><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e8wl8m92j30gn04sjrp.jpg" style="zoom:60%"></li></ul><h3 id="aGCN-for-Scene-Graph-Generation"><a href="#aGCN-for-Scene-Graph-Generation" class="headerlink" title="aGCN for Scene Graph Generation"></a>aGCN for Scene Graph Generation</h3><ul><li>只构建一个graph，在这个graph中，object是node，relation也是node。<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e98pvy7aj30dh0cq0t3.jpg" style="zoom:60%">  </li><li>用skip代表object node之间的连接；构建的是有向边；捕捉了三中类型的连接：</li></ul><p><strong>object &lt;–&gt; relationship</strong>， <strong>relationship &lt;–&gt; subject</strong> and <strong>object &lt;–&gt; object</strong><br><strong>s</strong>=subjects, <strong>o</strong>=objects, and <strong>r</strong>=relationships<br>object and relationship features as  <strong>Z<sup>o</sup></strong> and <strong>Z<sup>r</sup></strong><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e9gaiumnj30vp0dg0v2.jpg" style="zoom:60%"><br>对上图的解读：<br>（1）虽说是一个图，但是进行了两个aGCN的计算，使用的object and relationship node representation是什么？文中说，visual aGCN 使用visual feature 来进行计算，semantic aGCN 使用pre-softmax outputs来进行计算。（没看懂）<br>（2）WZα公式是GCN的计算公式，</p><ul><li><p>以 <strong>W<sup>skip</sup> Z<sup>o</sup> α<sup>skip</sup></strong> 为例，<strong>W<sup>skip</sup></strong> 是可学习参数，<strong>Z<sup>o</sup></strong> 是object nodes feature 组成的矩阵（d,N），<strong>α<sup>skip</sup></strong> 是一个向量，为该 node<sub>i</sub>与所有的object nodes之间计算的注意力系数，维度为(1,N）（N个objects）</p></li><li><p>以 <strong>W<sup>sr</sup> Z<sup>r</sup> α<sup>sr</sup></strong> 为例，<strong>W<sup>sr</sup></strong> 是可学习参数，<strong>Z<sup>r</sup></strong> 是realtion nodes feature 组成的矩阵（d,m），<strong>α<sup>sr</sup></strong> 是一个向量，为该node<sub>i</sub>与所有的relation nodes之间计算的注意力系数，维度为(1,m）（m个realtion）</p></li><li><p>以 <strong>W<sup>rs</sup> Z<sup>o</sup> α<sup>rs</sup></strong> 为例，<strong>W<sup>rs</sup></strong> 是可学习参数，<strong>Z<sup>o</sup></strong> 是object nodes feature 组成的矩阵（d,N），<strong>α<sup>rs</sup></strong> 是一个向量，为该relation<sub>i</sub>与所有的object nodes之间计算的注意力系数，维度为(1,N）（N个objects）  </p><p>（3）需要注意的是，<strong>α<sub>ii</sub></strong>=1，这将使得，每一行想加不为1</p></li></ul><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1ea7p889dj313l0dzwj3.jpg"><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] A faster pytorch implementation of faster  r-cnn. <a href="https://github.com/jwyang/faster-rcnn.pytorch" target="_blank" rel="noopener">https://github.com/jwyang/faster-rcnn.pytorch</a><br>[2] Scene graph generation by iterative message passing<br>[3] Graph Attention Networks<br>[3] Graph Attention Networks</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Batch Normalization(BN层)</title>
      <link href="/2019/03/23/Batch-Normalization-BN%E5%B1%82/"/>
      <url>/2019/03/23/Batch-Normalization-BN%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>参看：<a href="https://blog.csdn.net/donkey_1993/article/details/81871132" target="_blank" rel="noopener">https://blog.csdn.net/donkey_1993/article/details/81871132</a><br>参看：<a href="https://zhuanlan.zhihu.com/p/34879333" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34879333</a></p><h2 id="BN层的原理"><a href="#BN层的原理" class="headerlink" title="BN层的原理"></a>BN层的原理</h2><ul><li><p>在训练阶段，输入到网络中的是mini batch</p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1chneox3hj30dv0bddgx.jpg">解析：</li><li><p>Normalization操作我们虽然缓解了ICS问题，让每一层网络的输入数据分布都变得稳定，但却导致了数据表达能力的缺失。也就是我们通过变换操作改变了原有数据的信息表达（representation ability of the network），使得底层网络学习到的参数信息丢失。另一方面，通过让每一层的输入分布均值为0，方差为1，会使得输入在经过sigmoid或tanh激活函数时，容易陷入非线性激活函数的线性区域。  </p></li><li><p>因此，BN又引入了两个可学习（learnable）的参数  γ与β  。这两个参数的引入是为了恢复数据本身的表达能力，对规范化后的数据进行线性变换，即<img src="https://www.zhihu.com/equation?tex=%5Ctilde%7BZ_j%7D%3D%5Cgamma_j+%5Chat%7BZ%7D_j%2B%5Cbeta_j" alt="\tilde{Z_j}=\gamma_j \hat{Z}_j+\beta_j">。特别地，当  γ<sup>2</sup>=σ<sup>2</sup> ， β=μ 时，可以实现等价变换（identity transform）并且保留了原始输入特征的分布信息。</p></li></ul><h2 id="测试阶段如何使用Batch-Normalization？"><a href="#测试阶段如何使用Batch-Normalization？" class="headerlink" title="测试阶段如何使用Batch Normalization？"></a>测试阶段如何使用Batch Normalization？</h2><p>我们知道BN在每一层计算的  μ与σ<sup>2</sup>都是基于当前batch中的训练数据，但是这就带来了一个问题：我们在预测阶段，有可能只需要预测一个样本或很少的样本，没有像训练样本中那么多的数据，此时 μ与σ<sup>2</sup>的计算一定是有偏估计，这个时候我们该如何进行计算呢？</p><p>利用BN训练好模型后，我们保留了每组mini-batch训练数据在网络中每一层的<br> μ<sub>batch</sub>与σ<sup>2</sup><sub>batch</sub> 。此时我们使用整个样本的统计量来对Test数据进行归一化，具体来说使用均值与方差的无偏估计：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmu_%7Btest%7D%3D%5Cmathbb%7BE%7D+%28%5Cmu_%7Bbatch%7D%29" alt="\mu_{test}=\mathbb{E} (\mu_{batch})"></p><p><img src="https://www.zhihu.com/equation?tex=%5Csigma%5E2_%7Btest%7D%3D%5Cfrac%7Bm%7D%7Bm-1%7D%5Cmathbb%7BE%7D%28%5Csigma%5E2_%7Bbatch%7D%29" alt="\sigma^2_{test}=\frac{m}{m-1}\mathbb{E}(\sigma^2_{batch})"></p><p>得到每个特征的均值与方差的无偏估计后，我们对test数据采用同样的normalization方法：</p><p><img src="https://www.zhihu.com/equation?tex=BN%28X_%7Btest%7D%29%3D%5Cgamma%5Ccdot+%5Cfrac%7BX_%7Btest%7D-%5Cmu_%7Btest%7D%7D%7B%5Csqrt%7B%5Csigma%5E2_%7Btest%7D%2B%5Cepsilon%7D%7D%2B%5Cbeta" alt="BN(X_{test})=\gamma\cdot \frac{X_{test}-\mu_{test}}{\sqrt{\sigma^2_{test}+\epsilon}}+\beta"></p><p>另外，除了采用整体样本的无偏估计外。吴恩达在Coursera上的Deep Learning课程指出可以对train阶段每个batch计算的mean/variance采用<a href="[https://zhuanlan.zhihu.com/p/29895933](https://zhuanlan.zhihu.com/p/29895933)"><font color="#0099ff" size="5" face="楷体"> 指数加权平均</font></a>来得到test阶段mean/variance的估计。</p><h2 id="Batch-Normalization的优势"><a href="#Batch-Normalization的优势" class="headerlink" title="Batch Normalization的优势"></a>Batch Normalization的优势</h2><p>Batch Normalization在实际工程中被证明了能够缓解神经网络难以训练的问题，BN具有的有事可以总结为以下三点：</p><p><strong>（1）BN使得网络中每层输入数据的分布相对稳定，加速模型学习速度</strong></p><p>BN通过规范化与线性变换使得每一层网络的输入数据的均值与方差都在一定范围内，使得后一层网络不必不断去适应底层网络中输入的变化，从而实现了网络中层与层之间的解耦，允许每一层进行独立学习，有利于提高整个神经网络的学习速度。</p><p><strong>（2）BN使得模型对网络中的参数不那么敏感，简化调参过程，使得网络学习更加稳定</strong></p><p>在神经网络中，我们经常会谨慎地采用一些权重初始化方法（例如Xavier）或者合适的学习率来保证网络稳定训练。<br>当学习率设置太高时，会使得参数更新步伐过大，容易出现震荡和不收敛。但是使用BN的网络将不会受到参数数值大小的影响。<br>在使用Batch Normalization之后，抑制了参数微小变化随着网络层数加深被放大的问题，使得网络对参数大小的适应能力更强，此时我们可以设置较大的学习率而不用过于担心模型divergence的风险。</p><p><strong>（3）BN允许网络使用饱和性激活函数（例如sigmoid，tanh等），缓解梯度消失问题</strong></p><p>在不使用BN层的时候，由于网络的深度与复杂性，很容易使得底层网络变化累积到上层网络中，导致模型的训练很容易进入到激活函数的梯度饱和区；通过normalize操作可以让激活函数的输入数据落在梯度非饱和区，缓解梯度消失的问题；另外通过自适应学习 γ与β又让数据保留更多的原始信息。</p><p><strong>（4）BN具有一定的正则化效果</strong></p><p>在Batch Normalization中，由于我们使用mini-batch的均值与方差作为对整体训练样本均值与方差的估计，尽管每一个batch中的数据都是从总体样本中抽样得到，但不同mini-batch的均值与方差会有所不同，这就为网络的学习过程中增加了随机噪音，与Dropout通过关闭神经元给网络训练带来噪音类似，在一定程度上对模型起到了正则化的效果。</p><p>另外，原作者通过也证明了网络加入BN后，可以丢弃Dropout，模型也同样具有很好的泛化效果。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>optical flow(光流)</title>
      <link href="/2019/03/23/optical-flow-%E5%85%89%E6%B5%81/"/>
      <url>/2019/03/23/optical-flow-%E5%85%89%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="https://blog.csdn.net/zouxy09/article/details/8683859" target="_blank" rel="noopener">https://blog.csdn.net/zouxy09/article/details/8683859</a></p><h2 id="光流的定义"><a href="#光流的定义" class="headerlink" title="光流的定义"></a>光流的定义</h2><p>在人的眼睛在观察物体时，物体的景象在人的视网膜上形成一系列连续变化的图像，这一系列连续变化的信息不断“流过”视网膜，好像一种光的流，故称之为光流。<br>一般，光流是由于场景中前景目标本身的移动、相机的移动，或者两者的共同运动所产生的。<br>定义：它是空间运动物体在观察成像平面上的像素运动的瞬时速度，是利用图像序列中<strong>像素在时间域上的变化以及相邻帧之间的相关性</strong>来找到上一帧跟当前帧之间存在的<strong>对应关系</strong>，从而计算出<strong>相邻帧</strong>之间物体的运动信息的一种方法。</p><h2 id="如何计算光流"><a href="#如何计算光流" class="headerlink" title="如何计算光流"></a>如何计算光流</h2><ul><li><p>那通俗的讲就是通过一个图片序列，把每张图像中每个像素的运动速度和运动方向找出来就是光流场。那怎么找呢？咱们直观理解肯定是：第t帧的时候A点的位置是(x1, y1)，那么我们在第t+1帧的时候再找到A点，假如它的位置是(x2,y2)，那么我们就可以确定A点的运动了：(ux, vy) = (x2, y2) - (x1,y1)。</p></li><li><p>那怎么知道第t+1帧的时候A点的位置呢？ 这就存在很多的光流计算方法了。</p></li><li><p>1981年，Horn和Schunck创造性地将二维速度场与灰度相联系，引入光流约束方程，得到光流计算的基本算法。人们基于不同的理论基础提出各种光流计算方法，算法性能各有不同。Barron等人对多种光流计算技术进行了总结，按照理论基础与数学方法的区别把它们分成四种：<strong>基于梯度的方法、基于匹配的方法、基于能量的方法、基于相位的方法</strong>。近年来神经动力学方法也颇受学者重视。</p></li><li><p>yaya: 即光流法计算的是：相邻两帧之间的对应像素点之间的<strong>速度矢量</strong>，但是如何得到相邻帧对应的像素点是一个问题。<br>光流法主要依赖于三个假设：</p><p>  [亮度恒定] 图像中目标的像素强度在连续帧之间不会发生变化。<br>  [时间规律] 相邻帧之间的时间足够短，以至于在考虑运行变化时可以忽略它们之间的差异。该假设用于导出下面的核心方程。<br>  [空间一致性] 相邻像素具有相似的运动。  </p></li></ul><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1cgxrjz19j30hi0h90uo.jpg">  <p>上式中，I<sub>x</sub>,  I<sub>y</sub>可以通过图像沿x方向和y方向的导数计算，I<sub>t</sub>可以通过I(x,y,t)−I(x,y,t−1)计算。未知数是(u,v)， 正是我们想要求解的每个像素在前后相邻两帧的位移。</p><p>这里只有一个方程，却有两个未知数（实际是NN个方程，2N2N个未知数，NN是图像中待估计的像素点的个数，但是我们通过矩阵表示，将它们写成了如上式所述的紧凑形式），所以是一个不定方程。我们需要找出其它的约束求解方程。</p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1cgxrjo7dj30g00e6ta4.jpg"><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1cgxrhmkgj30gh05swej.jpg">  <p>如上图所示，H中的像素点(x,y)在I中的移动到了(x+u,y+v)的位置，偏移量为(u,v)。速度=位移在极短时间你内的位移量。  </p><p>参看：<a href="https://xmfbit.github.io/2017/05/03/cs131-opticalflow/" target="_blank" rel="noopener">https://xmfbit.github.io/2017/05/03/cs131-opticalflow/</a><br>参看：<a href="https://blog.csdn.net/carson2005/article/details/7581642" target="_blank" rel="noopener">https://blog.csdn.net/carson2005/article/details/7581642</a></p>]]></content>
      
      
      <categories>
          
          <category> 行为识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 行为识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从bagging到dropout</title>
      <link href="/2019/03/22/%E4%BB%8Ebagging%E5%88%B0dropout/"/>
      <url>/2019/03/22/%E4%BB%8Ebagging%E5%88%B0dropout/</url>
      
        <content type="html"><![CDATA[<ul><li>转载 from: <a href="https://blog.csdn.net/m0_37477175/article/details/77145459" target="_blank" rel="noopener">https://blog.csdn.net/m0_37477175/article/details/77145459</a></li></ul><p>dropout的思想继承自bagging方法，学习dropout先了解一下bagging方法。</p><h2 id="bagging"><a href="#bagging" class="headerlink" title="bagging"></a>bagging</h2><ul><li>bagging是一种集成方法（ensemble methods）,可以通过集成来减小泛化误差（generalization error）。 </li><li>bagging的<strong>最基本的思想</strong>是通过分别训练几个不同分类器，最后对测试的样本，每个分类器对其进行投票。在机器学习上这种策略叫model averaging。 </li><li>model averaging 之所以有效，是因为并非所有的分类器都会产生相同的误差，只要有不同的分类器产生的误差不同就会对减小泛化误差非常有效。 </li><li>对于bagging方法，允许采用相同的分类器，相同的训练算法，相同的目标函数。但是在<strong>数据集方面</strong>，<a href="https://www.baidu.com/s?wd=%E6%96%B0%E6%95%B0%E6%8D%AE&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">新数据</a>集与原始数据集的大小是相等的。每个数据集都是通过在原始数据集中随机选择一个样本进行替换而得到的。意味着，每个新数据集中会<strong>存在重复</strong>的样本。 </li><li>在数据集建好之后，用<strong>相同的学习算法</strong>分别作用于每个数据集就得到了几个分类器。 </li><li>下面这幅图片很好的解释了bagging的工作方式：我们想实现一个对数字8进行分类的分类器。此时构造了两个数据集，使用相同的学习算法，第一个分类器学习到的是8的上面那部分而第二个分类器学习的是8的下面那个部分。当我们把两个分类器集合起来的时候，此时的分类才是比较好的。 </li><li>Each of these individual classification ruls is brittle, but if we average there output then the detector is robust.<br><img src="https://img-blog.csdn.net/20170813153102572?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbTBfMzc0NzcxNzU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></li></ul><h2 id="dropout"><a href="#dropout" class="headerlink" title="dropout"></a>dropout</h2><ul><li><p>我们可以把dropout类比成将许多大的神经网络进行集成的一种bagging方法。 </p></li><li><p>但是每一个神经网络的训练是非常耗时和占用很多内存的，训练很多的神经网络进行集合分类就显得太不实际了。 </p></li><li><p>但是，dropout可以训练所有子网络的集合，这些子网络通过去除整个网络中的一些<a href="https://www.baidu.com/s?wd=%E7%A5%9E%E7%BB%8F%E5%85%83&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">神经元</a>来获得。 </p></li><li><p>如下图所示：<br><img src="https://img-blog.csdn.net/20170813154717429?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbTBfMzc0NzcxNzU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p></li><li><p>可能有些人会问上图的有些子网络，从输入到不了最终的输出，怎么办？其实对于比较宽的层（wider layers）从输入到输出都切断的概率是非常小的，多以影响不是很大。</p></li><li><p>如何移除一个神经元呢，我们通过仿射和非线性变换，试神经元的输出乘以0。</p></li><li><p>每次我们加载一个样本到minibatch，然后随机的采样一个不同的二进制掩膜作用在所有的输出，输入，隐藏节点上。每个节点的掩膜都是独立采样的。采样一个掩膜值为1的概率是固定的超参数。</p></li></ul><h2 id="bagging与dropout训练的对比"><a href="#bagging与dropout训练的对比" class="headerlink" title="bagging与dropout训练的对比"></a>bagging与dropout训练的对比</h2><ul><li>在bagging中，所有的分类器都是独立的，而在dropout中，所有的模型都是共享参数的。</li><li>在bagging中，所有的分类器都是在特定的数据集下训练至收敛，而在dropout中没有明确的模型训练过程。网络都是在一步中训练一次（输入一个样本，随机训练一个子网络）</li><li>（相同点）对于训练集来说，每一个子网络的训练数据是通过原始数据的替代采样得到的子集。<strong>？？？</strong>（自己的理解：每一个输入一个样本初始化某一个子网络）</li></ul><h2 id="dropout的优势"><a href="#dropout的优势" class="headerlink" title="dropout的优势"></a>dropout的优势</h2><ul><li>very computationally cheap在dropout训练阶段，每一个样本每一次更新只需要O(n)<br>，同时要生成n个二进制数字与每个状态相乘。除此之外，还需要O(n)的额外空间存储这些二进制数字，直到反向传播阶段。</li><li>没有很显著的限制模型的大小和训练的过程。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梯度消失与梯度爆炸的原因以及解决方案</title>
      <link href="/2019/03/22/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E4%B8%8E%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2019/03/22/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E4%B8%8E%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>转载from: <a href="https://blog.csdn.net/raojunyang/article/details/79962665" target="_blank" rel="noopener">https://blog.csdn.net/raojunyang/article/details/79962665</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要深入介绍深度学习中的梯度消失和梯度爆炸的问题以及解决方案。本文分为三部分，第一部分主要直观的介绍深度学习中为什么使用梯度更新，第二部分主要介绍深度学习中梯度消失及爆炸的原因，第三部分对提出梯度消失及爆炸的解决方案。有基础的同鞋可以跳着阅读。<br>其中，梯度消失爆炸的解决方案主要包括以下几个部分。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>预训练加微调</span><br><span class="line"><span class="bullet">- </span>梯度剪切、权重正则（针对梯度爆炸）</span><br><span class="line"><span class="bullet">- </span>使用不同的激活函数</span><br><span class="line"><span class="bullet">- </span>使用batchnorm</span><br><span class="line"><span class="bullet">- </span>使用残差结构</span><br><span class="line"><span class="bullet">- </span>使用LSTM网络</span><br></pre></td></tr></table></figure><h1 id="第一部分：为什么要使用梯度更新规则"><a href="#第一部分：为什么要使用梯度更新规则" class="headerlink" title="第一部分：为什么要使用梯度更新规则"></a>第一部分：为什么要使用梯度更新规则</h1><hr><ul><li><p>在介绍梯度消失以及爆炸之前，先简单说一说梯度消失的根源—–深度神经网络和反向传播。目前深度学习方法中，深度神经网络的发展造就了我们可以构建更深层的网络完成更复杂的任务，深层网络比如深度卷积网络，LSTM等等，而且最终结果表明，在处理复杂任务上，深度网络比浅层的网络具有更好的效果。但是，目前优化神经网络的方法都是基于反向传播的思想，即根据损失函数计算的误差通过梯度反向传播的方式，指导深度网络权值的更新优化。这样做是有一定原因的，首先，深层网络由许多非线性层堆叠而来，每一层非线性层都可以视为是一个非线性函数 (非线性来自于非线性激活函数），因此整个深度网络可以视为是一个复合的非线性多元函数 </p></li><li><p>我们最终的目的是希望这个多元函数可以很好的完成输入到输出之间的映射，那么，优化深度网络就是为了寻找到合适的权值，满足取得极小值点，比如最简单的损失函数 </p></li><li><p>假设损失函数的数据空间是下图这样的，我们最优的权值就是为了寻找下图中的最小值点，对于这种数学寻找最小值问题，采用梯度下降的方法再适合不过了。 </p></li></ul><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1baz0q65tj30e809edj1.jpg"><h1 id="第二部分：梯度消失、爆炸"><a href="#第二部分：梯度消失、爆炸" class="headerlink" title="第二部分：梯度消失、爆炸"></a>第二部分：梯度消失、爆炸</h1><p>梯度消失与梯度爆炸其实是一种情况，看接下来的文章就知道了。两种情况下梯度消失经常出现，一是在<strong>深层网络</strong>中，二是采用了<strong>不合适的损失函数</strong>，比如sigmoid。梯度爆炸一般出现在深层网络和<strong>权值初始化值太大</strong>的情况下，下面分别从这两个角度分析梯度消失和爆炸的原因。</p><h3 id="1-深层网络角度"><a href="#1-深层网络角度" class="headerlink" title="1.深层网络角度"></a>1.深层网络角度</h3><p>比较简单的深层网络如下：<br><img src="https://img-blog.csdn.net/20171219215626301?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图中是一个四层的全连接网络，假设每一层网络激活后的输出为,其中为第层, 代表第层的输入，也就是第层的输出，是激活函数，那么，得出，简单记为。<br>BP算法基于梯度下降策略，以目标的负梯度方向对参数进行调整，参数的更新为，给定学习率，得出。如果要更新第二隐藏层的权值信息，根据链式求导法则，更新梯度信息：<br>，很容易看出来，即第二隐藏层的输入。<br>所以说，就是对激活函数进行求导，如果此部分大于1，那么层数增多的时候，最终的求出的梯度更新将以指数形式增加，即发生<strong>梯度爆炸</strong>，如果此部分小于1，那么随着层数增多，求出的梯度更新信息将会以指数形式衰减，即发生了<strong>梯度消失</strong>。如果说从数学上看不够直观的话，下面几个图可以很直观的说明深层网络的梯度问题（图片内容来自参考文献1）：</p><p>注：下图中的隐层标号和第一张全连接图隐层标号刚好相反。<br>图中的曲线表示权值更新的速度，对于下图两个隐层的网络来说，已经可以发现隐藏层2的权值更新速度要比隐藏层1更新的速度慢</p><p><img src="https://img-blog.csdn.net/20171220110058983?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">那么对于四个隐层的网络来说，就更明显了，第四隐藏层比第一隐藏层的更新速度慢了两个数量级：</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20171220110732927?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>总结：</strong>从深层网络角度来讲，不同的层学习的速度差异很大，表现为网络中靠近输出的层学习的情况很好，靠近输入的层学习的很慢，有时甚至训练了很久，前几层的权值和刚开始随机初始化的值差不多。因此，梯度消失、爆炸，其<strong>根本原因</strong>在于反向传播训练法则，属于<a href="https://www.baidu.com/s?wd=%E5%85%88%E5%A4%A9%E4%B8%8D%E8%B6%B3&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">先天不足</a>，另外多说一句，Hinton提出capsule的原因就是为了彻底抛弃反向传播，如果真能大范围普及，那真是一个革命。</p><h3 id="2-激活函数角度"><a href="#2-激活函数角度" class="headerlink" title="2.激活函数角度"></a>2.激活函数角度</h3><p>其实也注意到了，上文中提到计算权值更新信息的时候需要计算前层偏导信息，因此如果激活函数选择不合适，比如使用sigmoid，梯度消失就会很明显了，原因看下图，左图是sigmoid的损失函数图，右边是其倒数的图像，如果使用sigmoid作为损失函数，其梯度是不可能超过0.25的，这样经过链式求导之后，很容易发生梯度消失，sigmoid函数数学表达式为：<br><img src="https://img-blog.csdn.net/20171220113129230?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="sigmoid函数"><img src="https://img-blog.csdn.net/20171220113422675?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="sigmoid函数导数"></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同理，<span class="built-in">tanh</span>作为损失函数，它的导数图如下，可以看出，<span class="built-in">tanh</span>比<span class="built-in">sigmoid</span>要好一些，但是它的倒数仍然是小于<span class="number">1</span>的。<span class="built-in">tanh</span>数学表达为：</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20171220114016270?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h1 id="第三部分：梯度消失、爆炸的解决方案"><a href="#第三部分：梯度消失、爆炸的解决方案" class="headerlink" title="第三部分：梯度消失、爆炸的解决方案"></a>第三部分：梯度消失、爆炸的解决方案</h1><hr><h3 id="2-1-方案1-预训练加微调"><a href="#2-1-方案1-预训练加微调" class="headerlink" title="2.1 方案1-预训练加微调"></a>2.1 方案1-预训练加微调</h3><p>此方法来自Hinton在2006年发表的一篇论文，Hinton为了解决梯度的问题，提出采取无监督逐层训练方法，其基本思想是每次训练一层隐节点，训练时将上一层隐节点的输出作为输入，而本层隐节点的输出作为下一层隐节点的输入，此过程就是逐层“预训练”（pre-training）；在预训练完成后，再对整个网络进行“微调”（fine-tunning）。Hinton在训练深度信念网络（Deep Belief Networks中，使用了这个方法，在各层预训练完成后，再利用BP算法对整个网络进行训练。此思想相当于是先寻找局部最优，然后整合起来寻找全局最优，此方法有一定的好处，但是目前应用的不是很多了。</p><h3 id="2-2-方案2-梯度剪切、正则"><a href="#2-2-方案2-梯度剪切、正则" class="headerlink" title="2.2 方案2-梯度剪切、正则"></a>2.2 方案2-梯度剪切、正则</h3><p><strong>梯度剪切</strong>这个方案主要是针对梯度爆炸提出的，其思想是设置一个梯度剪切阈值，然后更新梯度的时候，如果梯度超过这个阈值，那么就将其强制限制在这个范围之内。这可以防止梯度爆炸。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注：在WGAN中也有梯度剪切限制操作，但是和这个是不一样的，WGAN限制梯度更新信息是为了保证lipchitz条件。</span><br></pre></td></tr></table></figure><p>另外一种解决梯度爆炸的手段是采用<strong>权重正则化</strong>（weithts regularization）比较常见的是正则，和正则，在各个深度框架中都有相应的API可以使用正则化，比如在中，若搭建网络的时候已经设置了正则化参数，则调用以下代码可以直接计算出正则损失：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regularization_loss = tf.add_n(tf<span class="selector-class">.losses</span><span class="selector-class">.get_regularization_losses</span>(scope=<span class="string">'my_resnet_50'</span>))</span><br></pre></td></tr></table></figure><p>如果没有设置初始化参数，也可以使用以下代码计算正则损失：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l2_loss = tf.add_n([tf<span class="selector-class">.nn</span><span class="selector-class">.l2_loss</span>(var) <span class="keyword">for</span> <span class="selector-tag">var</span> <span class="keyword">in</span> tf.trainable_variables() <span class="keyword">if</span> <span class="string">'weights'</span> <span class="keyword">in</span> <span class="selector-tag">var</span>.name])</span><br></pre></td></tr></table></figure><p>正则化是通过对网络权重做正则限制过拟合，仔细看正则项在损失函数的形式： </p><p>其中，是指正则项系数，因此，如果发生梯度爆炸，权值的范数就会变的非常大，通过正则化项，可以部分限制梯度爆炸的发生。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注：事实上，在深度神经网络中，往往是梯度消失出现的更多一些。</span><br></pre></td></tr></table></figure><h3 id="2-3-方案3-relu、leakrelu、elu等激活函数"><a href="#2-3-方案3-relu、leakrelu、elu等激活函数" class="headerlink" title="2.3 方案3-relu、leakrelu、elu等激活函数"></a>2.3 方案3-relu、leakrelu、elu等激活函数</h3><p><strong>Relu:</strong>思想也很简单，如果激活函数的导数为1，那么就不存在梯度消失爆炸的问题了，每层的网络都可以得到相同的更新速度，relu就这样应运而生。先看一下relu的数学表达式：</p><p><img src="https://img-blog.csdn.net/20171220115642365?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>其函数图像：</p><p><img src="https://img-blog.csdn.net/20171220115719332?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>从上图中，我们可以很容易看出，relu函数的导数在正数部分是恒等于1的，因此在深层网络中使用relu激活函数就不会导致梯度消失和爆炸的问题。</p><p><strong>relu</strong>的主要贡献在于：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 解决了梯度消失、爆炸的问题</span></span><br><span class="line"><span class="comment">-- 计算方便，计算速度快</span></span><br><span class="line"><span class="comment">-- 加速了网络的训练</span></span><br></pre></td></tr></table></figure><p>同时也存在一些<strong>缺点</strong>：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 由于负数部分恒为0，会导致一些神经元无法激活（可通过设置小学习率部分解决）</span></span><br><span class="line"> <span class="comment">-- 输出不是以0为中心的</span></span><br></pre></td></tr></table></figure><p>尽管relu也有缺点，但是仍然是目前使用最多的激活函数</p><p><strong>leakrelu</strong><br>leakrelu就是为了解决relu的0区间带来的影响，其数学表达为：其中k是leak系数，一般选择0.01或者0.02，或者通过学习而来</p><p><img src="https://img-blog.csdn.net/20170702211001517?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FpY2FpYXRuYnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>leakrelu解决了0区间带来的影响，而且包含了relu的所有优点<br><strong>elu</strong><br>elu激活函数也是为了解决relu的0区间带来的影响，其数学表达为：<img src="https://img-blog.csdn.net/20171220134603079?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>其函数及其导数数学形式为：</p><p><img src="https://img-blog.csdn.net/20171220134614121?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>但是elu相对于leakrelu来说，计算要更耗时间一些</p><h3 id="2-4-解决方案4-batchnorm"><a href="#2-4-解决方案4-batchnorm" class="headerlink" title="2.4 解决方案4-batchnorm"></a>2.4 解决方案4-batchnorm</h3><p><strong>Batchnorm</strong>是深度学习发展以来提出的最重要的成果之一了，目前已经被广泛的应用到了各大网络中，具有加速网络收敛速度，提升训练稳定性的效果，Batchnorm本质上是解决反向传播过程中的梯度问题。batchnorm全名是batch normalization，简称BN，即批规范化，通过规范化操作将输出信号x规范化到均值为0，方差为1保证网络的稳定性。<br>具体的batchnorm原理非常复杂，在这里不做详细展开，此部分大概讲一下batchnorm解决梯度的问题上。具体来说就是反向传播中，经过每一层的梯度会乘以该层的权重，举个简单例子：<br>正向传播中，那么反向传播中，，反向传播式子中有的存在，所以的大小影响了梯度的消失和爆炸，batchnorm就是通过对每一层的输出规范为均值和方差一致的方法，消除了带来的放大缩小的影响，进而解决梯度消失和爆炸的问题。<br>有关batch norm详细的内容可以参考我的另一篇博客：<br><a href="http://blog.csdn.net/qq_25737169/article/details/79048516" target="_blank" rel="noopener">http://blog.csdn.net/qq_25737169/article/details/79048516</a></p><h3 id="2-5-解决方案5-残差结构"><a href="#2-5-解决方案5-残差结构" class="headerlink" title="2.5 解决方案5-残差结构"></a>2.5 解决方案5-残差结构</h3><p><strong>残差结构</strong>说起残差的话，不得不提这篇论文了：Deep Residual Learning for Image Recognition，关于这篇论文的解读，可以参考知乎链接：<a href="https://zhuanlan.zhihu.com/p/31852747" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31852747</a>这里只简单介绍残差如何解决梯度的问题。<br>事实上，就是残差网络的出现导致了image net比赛的终结，自从残差提出后，几乎所有的深度网络都离不开残差的身影，相比较之前的几层，几十层的深度网络，在残差网络面前都不值一提，残差可以很轻松的构建几百层，一千多层的网络而不用担心梯度消失过快的问题，原因就在于残差的捷径（shortcut）部分，其中残差单元如下图所示：<br><img src="https://img-blog.csdn.net/20171220144105760?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>相比较于以前网络的直来直去结构，残差中有很多这样的跨层连接结构，这样的结构在反向传播中具有很大的好处，见下式：<br><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial%20loss%7D%7B%5Cpartial%20%7B%7Bx%7D_%7Bl%7D%7D%7D=%5Cfrac%7B%5Cpartial%20loss%7D%7B%5Cpartial%20%7B%7Bx%7D_%7BL%7D%7D%7D%5Ccdot%20%5Cfrac%7B%5Cpartial%20%7B%7Bx%7D_%7BL%7D%7D%7D%7B%5Cpartial%20%7B%7Bx%7D_%7Bl%7D%7D%7D=%5Cfrac%7B%5Cpartial%20loss%7D%7B%5Cpartial%20%7B%7Bx%7D_%7BL%7D%7D%7D%5Ccdot%20%5Cleft%28%201%2B%5Cfrac%7B%5Cpartial%20%7D%7B%5Cpartial%20%7B%7Bx%7D_%7BL%7D%7D%7D%5Csum%5Climits_%7Bi=l%7D%5E%7BL-1%7D%7BF%28%7B%7Bx%7D_%7Bi%7D%7D,%7B%7BW%7D_%7Bi%7D%7D%29%7D%20%5Cright%29" alt="这里写图片描述"><br>式子的第一个因子  表示的损失函数到达 L 的梯度，小括号中的1表明短路机制可以无损地传播梯度，而另外一项残差梯度则需要经过带有weights的层，梯度不是直接传递过来的。残差梯度不会那么巧全为-1，而且就算其比较小，有1的存在也不会导致梯度消失。所以残差学习会更容易。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注：上面的推导并不是严格的证明。</span><br></pre></td></tr></table></figure><h3 id="2-6-解决方案6-LSTM"><a href="#2-6-解决方案6-LSTM" class="headerlink" title="2.6 解决方案6-LSTM"></a>2.6 解决方案6-LSTM</h3><p><strong>LSTM</strong>全称是长短期记忆网络（long-short term memory networks），是不那么容易发生梯度消失的，主要原因在于LSTM内部复杂的“门”(gates)，如下图，LSTM通过它内部的“门”可以接下来更新的时候“记住”前几次训练的”残留记忆“，因此，经常用于生成文本中。目前也有基于CNN的LSTM，感兴趣的可以尝试一下。</p><p><img src="http://upload-images.jianshu.io/upload_images/42741-b9a16a53d58ca2b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="这里写图片描述"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h2><p>1.《Neural networks and deep learning》<br>2.<a href="https://www.baidu.com/s?wd=%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">《机器学习》</a>周志华 </p><ol start="3"><li><p><a href="https://www.cnblogs.com/willnote/p/6912798.html&gt;" target="_blank" rel="noopener">https://www.cnblogs.com/willnote/p/6912798.html&gt;</a> </p></li><li><p><a href="https://www.zhihu.com/question/38102762" target="_blank" rel="noopener">https://www.zhihu.com/question/38102762</a> </p><ol start="5"><li><a href="http://www.jianshu.com/p/9dc9f41f0b29" target="_blank" rel="noopener">http://www.jianshu.com/p/9dc9f41f0b29</a></li></ol></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python: list vs tuple</title>
      <link href="/2019/03/20/python-list-vs-tuple/"/>
      <url>/2019/03/20/python-list-vs-tuple/</url>
      
        <content type="html"><![CDATA[<ul><li><p><a href="https://shiyaya.github.io/2019/03/12/python%E5%9F%BA%E7%A1%80%EF%BC%9A-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-python-%E4%B8%AD%E7%9A%84%E8%B5%8B%E5%80%BC%E3%80%81%E5%BC%95%E7%94%A8%E3%80%81%E6%8B%B7%E8%B4%9D%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/" target="_blank" rel="noopener">shiyaya.github.io-python基础： 深入理解 python 中的赋值、引用、拷贝、作用域</a></p></li><li><p><a href="https://data-flair.training/blogs/python-tuples-vs-lists/" target="_blank" rel="noopener">https://data-flair.training/blogs/python-tuples-vs-lists/</a>  </p></li></ul><table><thead><tr><th>list</th><th>tuple</th></tr></thead><tbody><tr><td>可变对象</td><td>不可变对象</td></tr><tr><td>参数传递是传递的是引用</td><td>参数传递是传递的是值</td></tr><tr><td></td><td></td></tr><tr><td>可以修改某个元素的值</td><td>不可以修改某个元素的值，即不可以按索引来修改元素值</td></tr><tr><td>a= [1,2,3]<br>b=a<br>b[0]=8<br>print(a) #a=[8,2,3]</td><td>略</td></tr><tr><td>可以修改slice<br>del a[0:2]</td><td>不可以修改slice<br>del a[0:2]#会提示错误</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习知识点</title>
      <link href="/2019/03/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2019/03/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<ul><li><p>讲一下正则化，L1和L2正则化各自的特点和适用场景。<br>答：L1用来获得稀疏化特征；L2用来防止过拟合。L1让一部分特征的系数缩小到0，从而间接实现特征选择，用于特征间有关联的场合；L2让所有的特征系数都减小，但不会减为0，会使优化求解稳定快速。</p></li><li><p>防止过拟合的方法：<br>（1）早停，使用验证集，当验证集的损失下降，但是训练集的损失仍在上升时，则停止训练<br>（2）加入正则化项，L1、L2</p></li><li><p>分类问题有哪些评价指标？每种的适用场景<br>Precision  精确率，在所有预测为正样本的样本(TP+FP)中预测正确(TP)的比例，也就是：</p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1asfgshjuj307c01d3yb.jpg">适用于：检索出的信息有多少是用户感兴趣的Recall  召回率，在所有正样本(TP+FN)中，预测正确(TP)的比例，也就是：<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1asfv7ikpj306d019t8i.jpg">  适用于：用户感兴趣的信息有多少被检索出来了Accuracy  准确率，正确分类的样本占所有样本的比例，不适于数据极度不平衡的场景如广告点击率一般在千分之几。<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1asg2ggqgj30ab01eglg.jpg">适用于多分类问题F1-measure  F1分数，是综合考虑Precision和Recall得到的一个指标，一般在需要PR都要保证的场景使用，针对一个值的优化更加直观容易衡量<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1asgb0qo9j304701dwe9.jpg"></li><li><p>逻辑回归可以处理非线性问题吗<br>只用原始特征不能；对特征做非线性变换，比如kernel，当然可以。 但那就不是lr了 或者一个神经网络 最后一层看成是lr 前面看成是提特征<br>lr的应用场景主要是特征很多的情况下 比如特征是上亿维的一些场景</p></li><li><p>讲一下pooling的作用， 为什么max pooling要更常用？哪些情况下，average pooling比max pooling更合适？<br>（1）保证特征的位置与旋转不变性。对于图像处理这种特性是很好的，但是对于NLP来说特征出现的位置是很重要的。比如主语一般出现在句子头等等<br>maxpooling提供了一定position的invariance，当图像某些区域像素变化时，maxpooling得到的output并不会变<br>（2）减少模型参数数量，减少过拟合问题。2D或1D的数组转化为单一数值，对于后续的convolution层或者全连接隐层来说，减少了单个Filter参数或隐层神经元个数<br>（3）可以把变长的输入x整理成固定长度的输入。CNN往往最后连接全连接层，神经元个数需要固定好，但是cnn输入x长度不确定，通过pooling操作，每个filter固定取一个值。有多少个Filter，Pooling就有多少个神经元，这样就可以把全连接层神经元固定住<br>（4）yaya: pooling 一般是对缩小image size，从而可以减小后续步骤中的参数量<br>max-pooling还提供了非线性, 这是max-pooling效果更好的一个重要原因.</p></li></ul><p><strong>average pooling比max pooling更合适：</strong>有的时候在模型接近分类器的末端使用全局平均池化还可以代替Flatten操作，使输入数据变成一位向量。</p><ul><li><p>1x1的卷积核有什么作用？<br>1*1的卷积核在NIN、Googlenet中被广泛使用，作用：<br>（1）实现跨通道的交互和信息整合<br>（2）进行卷积核通道数的降维和升维<br>（3）对于单通道feature map 用单核卷积即为乘以一个参数，而一般情况都是多核卷积多通道，实现多个feature map的线性组合</p></li><li><p>梯度消失和梯度爆炸的原因是什么？ 有哪些解决方法？<br>转载：<a href="https://blog.csdn.net/raojunyang/article/details/79962665（解释的很清楚）" target="_blank" rel="noopener">https://blog.csdn.net/raojunyang/article/details/79962665（解释的很清楚）</a><br>梯度消失更容易发生，当网络较深或者使用了不合适的激活函数时，会发生梯度消失；当为深层网络且权值初始化值太大时，容易发生梯度爆炸<br>yaya: 由于深层网络，在底层的网络权重的更新，需要高层网络权重的连乘，因此，当高层网络权重较小时，使得发生梯度消失，相反，当权重较大时，则发生梯度爆炸。<br>那么什么时候高层网络权重小—当使用sigmoid/tanh这样的激活函数时，因为sigmoid的导数最大为1/2；什么时候高层网络权重大–当初始化的权重较大时<br>如何解决梯度消失与爆炸：（1）使用正确的非线性激活函数（2）对于梯度爆炸问题使用梯度剪切（3）使用batch normalization（4）使用残差结构</p></li><li><p>CNN和RNN的梯度消失是一样的吗？  </p></li><li><p>有哪些防止过拟合的方法？<br>早停；添加正则化项：L1、L2；使用dropout</p></li><li><p>讲一下激活函数sigmoid，tanh，relu. Leaky ReLU各自的优点和适用场景？<br>sigmoid，tanh 有梯度消失的问题<br>relu 部分解决梯度消失问题（x&gt;0）<br>leaky relu </p></li><li><p>relu的负半轴导数都是0，这部分产生的梯度消失怎么办？  </p></li><li><p>batch size对收敛速度的影响。  </p></li><li><p>讲一下batch normalization<br>对输入的数据进行mini batch 的归一化</p></li><li><p>讲一下你怎么理解dropout，分别从bagging和正则化的角度<br><a href="https://blog.csdn.net/m0_37477175/article/details/77145459" target="_blank" rel="noopener">https://blog.csdn.net/m0_37477175/article/details/77145459</a><br>bagging 都是使用集成学习的思想，但是</p></li><li><p>data augmentation有哪些技巧？  </p></li><li><p>讲一下你了解的优化方法，sgd, momentum, rmsprop, adam的区别和联系  </p></li><li><p>如果训练的神经网络不收敛，可能有哪些原因？<br>可以参见此博文，具体来说，可以简述为以下几点：<br>（1）<strong>没有对数据进行归一化</strong>，即对数据减均值，并除以方差。而大部分神经网络的输入输出都是在0附近的分布。因此无法收敛。<br>（2）<strong>学习率不正确</strong><br>（3）<strong>在输出层使用错误的激活函数</strong>：在最后一层使用激活函数时，无法产生所需全部范围的值。假使你使用Relu这类限制范围的函数，神经网络便只会训练得到正值<br>（4）<strong>没有正确初始化权重</strong></p></li></ul><p>（1）代码题（leetcode类型），主要考察数据结构和基础算法，以及代码基本功<br>虽然这部分跟机器学习，深度学习关系不大，但也是面试的重中之重。基本每家公司的面试都问了大量的算法题和代码题，即使是商汤、face++这样的深度学习公司，考察这部分的时间也占到了我很多轮面试的60%甚至70%以上。我去face++面试的时候，面试官是residual net，shuffle net的作者；但他们的面试中，写代码题依旧是主要的部分。<br>大部分题目都不难，基本是leetcode medium的难度。但是要求在现场白板编程，思路要流畅，能做到一次性Bug-free. 并且，一般都是要给出时间复杂度和空间复杂度最优的做法。对于少数难度很大的题，也不要慌张。一般也不会一点思路也没有，尽力给面试官展现自己的思考过程。面试官也会引导你，给一点小提示，沿着提示把题目慢慢做出来也是可以通过面试的。<br>以下是我所遇到的一些需要当场写出完整代码的题目：<br>&lt;1&gt; 二分查找。分别实现C++中的lower_bound和upper_bound.<br>&lt;2&gt; 排序。 手写快速排序，归并排序，堆排序都被问到过。<br>&lt;3&gt; 给你一个数组，求这个数组的最大子段积<br>时间复杂度可以到O(n)<br>&lt;4&gt; 给你一个数组，在这个数组中找出不重合的两段，让这两段的字段和的差的绝对值最小。<br>时间复杂度可以到O(n)<br>&lt;5&gt; 给你一个数组，求一个k值，使得前k个数的方差 + 后面n-k个数的方差最小<br>时间复杂度可以到O(n)<br>&lt;6&gt; 给你一个只由0和1组成的字符串，找一个最长的子串，要求这个子串里面0和1的数目相等。<br>时间复杂度可以到O(n)<br>&lt;7&gt; 给你一个数组以及一个数K， 从这个数组里面选择三个数，使得三个数的和小于等于K， 问有多少种选择的方法？<br>时间复杂度可以到O(n^2)<br>&lt;8&gt; 给你一个只由0和1组成的矩阵，找出一个最大的子矩阵，要求这个子矩阵是方阵，并且这个子矩阵的所有元素为1<br>时间复杂度可以到O(n^2)<br>&lt;9&gt; 求一个字符串的最长回文子串<br>时间复杂度可以到O(n) (Manacher算法)<br>&lt;10&gt; 在一个数轴上移动，初始在0点，现在要到给定的某一个x点， 每一步有三种选择，坐标加1，坐标减1，坐标乘以2，请问最少需要多少步从0点到x点。<br>&lt;11&gt; 给你一个集合，输出这个集合的所有子集。<br>&lt;12&gt; 给你一个长度为n的数组，以及一个k值（k &lt; n) 求出这个数组中每k个相邻元素里面的最大值。其实也就是一个一维的max pooling<br>时间复杂度可以到O(n)<br>&lt;13&gt; 写一个程序，在单位球面上随机取点，也就是说保证随机取到的点是均匀的。<br>&lt;14&gt; 给你一个长度为n的字符串s，以及m个短串（每个短串的长度小于10）， 每个字符串都是基因序列，也就是说只含有A,T,C,G这四个字母。在字符串中找出所有可以和任何一个短串模糊匹配的子串。模糊匹配的定义，两个字符串长度相等，并且至多有两个字符不一样，那么我们就可以说这两个字符串是模糊匹配的。<br>&lt;15&gt; 其它一些描述很复杂的题这里就不列了。</p><p>（2）数学题或者”智力”题。<br>不会涉及特别高深的数学知识，一般就是工科数学（微积分，概率论，线性代数）和一些组合数学的问题。<br>下面是我在面试中被问到过的问题：<br>&lt;1&gt; 如果一个女生说她集齐了十二个星座的前男友，她前男友数量的期望是多少？<br>ps：这道题在知乎上有广泛的讨论，作为知乎重度用户我也看到过。如果一个女生说，她集齐了十二个星座的前男友，我们应该如何估计她前男友的数量？<br>&lt;2&gt; 两个人玩游戏。有n堆石头，每堆分别有a1, a2, a3…. an个石头，每次一个游戏者可以从任意一堆石头里拿走至少一个石头，也可以整堆拿走，但不能从多堆石头里面拿。无法拿石头的游戏者输，请问这个游戏是否有先手必胜或者后手必胜的策略？ 如果有，请说出这个策略，并证明这个策略能保证必胜。<br>&lt;3&gt; 一个一维数轴，起始点在原点。每次向左或者向右走一步，概率都是0.5. 请问回到原点的步数期望是多少？<br>&lt;4&gt; 一条长度为1的线段，随机剪两刀，求有一根大于0.5的概率。<br>&lt;5&gt; 讲一下你理解的矩阵的秩。低秩矩阵有什么特点？ 在图像处理领域，这些特点有什么应用？<br>&lt;6&gt; 讲一下你理解的特征值和特征向量。<br>&lt;7&gt; 为什么负梯度方向是使函数值下降最快的方向？简单数学推导一下</p><p>（3）机器学习基础<br>这部分建议参考周志华老师的《机器学习》。<br>下面是我在面试中被问到过的问题：<br>&lt;1&gt; 逻辑回归和线性回归对比有什么优点？<br>&lt;2&gt; 逻辑回归可以处理非线性问题吗？<br>&lt;3&gt; 分类问题有哪些评价指标？每种的适用场景。<br>&lt;4&gt; 讲一下正则化，L1和L2正则化各自的特点和适用场景。<br>&lt;5&gt; 讲一下常用的损失函数以及各自的适用场景。<br>&lt;6&gt; 讲一下决策树和随机森林<br>&lt;7&gt; 讲一下GBDT的细节，写出GBDT的目标函数。 GBDT和Adaboost的区别与联系<br>&lt;8&gt; 手推softmax loss公式<br>&lt;9&gt; 讲一下SVM, SVM与LR有什么联系。<br>&lt;10&gt;讲一下PCA的步骤。PCA和SVD的区别和联系<br>&lt;11&gt; 讲一下ensemble<br>&lt;12&gt; 偏差和方差的区别。ensemble的方法中哪些是降低偏差，哪些是降低方差？<br>…… 这部分问得太琐碎了，我能记起来的问题就这么多了。我的感觉，这部分问题大多数不是问得很深，所以不至于被问得哑口无言，总有得扯；但是要想给出一个特别深刻的回答，还是需要对机器学习的基础算法了解比较透彻。</p><p>（4）深度学习基础<br>这部分的准备，我推荐花书（Bengio的Deep learning）和 @魏秀参 学长的《解析卷积神经网络-深度学习实践手册》<br>下面是我在面试中被问到过的问题：<br>&lt;1&gt; 手推BP<br>&lt;2&gt; 手推RNN和LSTM结构<br>&lt;3&gt; LSTM中每个gate的作用是什么，为什么跟RNN比起来，LSTM可以防止梯度消失<br>&lt;4&gt; 讲一下pooling的作用， 为什么max pooling要更常用？哪些情况下，average pooling比max pooling更合适？<br>&lt;5&gt; 梯度消失和梯度爆炸的原因是什么？ 有哪些解决方法？<br>&lt;6&gt; CNN和RNN的梯度消失是一样的吗？<br>&lt;6&gt; 有哪些防止过拟合的方法？<br>&lt;7&gt; 讲一下激活函数sigmoid，tanh，relu. 各自的优点和适用场景？<br>&lt;8&gt; relu的负半轴导数都是0，这部分产生的梯度消失怎么办？<br>&lt;9&gt; batch size对收敛速度的影响。<br>&lt;10&gt; 讲一下batch normalization<br>&lt;11&gt; CNN做卷积运算的复杂度。如果一个CNN网络的输入channel数目和卷积核数目都减半，总的计算量变为原来的多少？<br>&lt;12&gt; 讲一下AlexNet的具体结构，每层的作用<br>&lt;13&gt; 讲一下你怎么理解dropout，分别从bagging和正则化的角度<br>&lt;14&gt; data augmentation有哪些技巧？<br>&lt;15&gt; 讲一下你了解的优化方法，sgd, momentum, rmsprop, adam的区别和联系<br>&lt;16&gt; 如果训练的神经网络不收敛，可能有哪些原因？<br>&lt;17&gt; 说一下你理解的卷积核， 1x1的卷积核有什么作用？<br>……..<br>同上，这部分的很多问题也是每个人都或多或少能回答一点，但要答得很好还是需要功底的。</p><p>（5）科研上的开放性问题<br>这部分的问题没有固定答案，也没法很好地针对性准备。功在平时，多读paper多思考，注意培养自己的insight和intuition<br>下面是我在面试中被问到过的问题：<br>&lt;1&gt; 选一个计算机视觉、深度学习、机器学习的子领域，讲一下这个领域的发展脉络，重点讲出各种新方法提出时的motivation，以及谈谈这个领域以后会怎么发展。<br>&lt;2&gt; 讲一下你最近看的印象比较深的paper<br>&lt;3&gt; 讲一下经典的几种网络结构， AlexNet， VGG，GoogleNet， Residual Net等等，它们各自最重要的contribution<br>&lt;4&gt; 你看过最近很火的XXX paper吗? 你对这个有什么看法？<br>……<br>（6） 编程语言、操作系统等方面的一些问题。<br>C++， Python， 操作系统，Linux命令等等。这部分问得比较少，但还是有的，不具体列了<br>（7）针对简历里项目/论文 / 实习的一些问题。<br>这部分因人而异，我个人的对大家也没参考价值，也不列了。</p><p>作者：wendy_要努力努力再努力<br>链接：<a href="https://www.jianshu.com/p/d40fc51874c8" target="_blank" rel="noopener">https://www.jianshu.com/p/d40fc51874c8</a><br>来源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unexpected key(s) in state_dict: “**module**.features.conv1.0.weight”</title>
      <link href="/2019/03/20/Unexpected-key-s-in-state-dict-%E2%80%9C-module-features-conv1-0-weight%E2%80%9D/"/>
      <url>/2019/03/20/Unexpected-key-s-in-state-dict-%E2%80%9C-module-features-conv1-0-weight%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<ul><li><p>参考此处<a href="https://discuss.pytorch.org/t/when-loading-a-model-unexpected-key-s-in-state-dict-module-features-conv1-0-weight/20505" target="_blank" rel="noopener">[link]</a></p></li><li><p>问题描述：在使用pytorch 加载预训练的模型时:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decoder.load_state_dict(checkpoint[<span class="string">'dec'</span>])</span><br></pre></td></tr></table></figure></li></ul><p>出现错误：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Missing</span> <span class="selector-tag">key</span>(<span class="selector-tag">s</span>) <span class="selector-tag">in</span> <span class="selector-tag">state_dict</span>: “<span class="selector-tag">features</span><span class="selector-class">.conv1</span><span class="selector-class">.0</span><span class="selector-class">.weight</span>”,</span><br><span class="line"><span class="selector-tag">Unexpected</span> <span class="selector-tag">key</span>(<span class="selector-tag">s</span>) <span class="selector-tag">in</span> <span class="selector-tag">state_dict</span>: “**<span class="selector-tag">module</span>**<span class="selector-class">.features</span><span class="selector-class">.conv1</span><span class="selector-class">.0</span><span class="selector-class">.weight</span>”,</span><br></pre></td></tr></table></figure><ul><li>原因：<br>在训练阶段，使用的是多GPU，采用了nn.DataParallel，因此在测试阶段，对应的模型也需要是多GPU的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非极大值抑制(NMS)</title>
      <link href="/2019/03/20/%E9%9D%9E%E6%9E%81%E5%A4%A7%E5%80%BC%E6%8A%91%E5%88%B6-NMS/"/>
      <url>/2019/03/20/%E9%9D%9E%E6%9E%81%E5%A4%A7%E5%80%BC%E6%8A%91%E5%88%B6-NMS/</url>
      
        <content type="html"><![CDATA[<p>非极大值抑制（Non-maximum suppression，NMS）是一种去除非极大值的算法，常用于计算机视觉中的边缘检测、物体识别等。</p><h2 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h2><p>给出一张图片和上面许多物体检测的候选框（即每个框可能都代表某种物体），但是这些框很可能有互相重叠的部分，我们要做的就是只保留最优的框。假设有N个框，每个框被分类器计算得到的分数为Si, 1&lt;=i&lt;=N。</p><p>0、建造一个存放待处理候选框的集合H，初始化为包含全部N个框；</p><p>建造一个存放最优框的集合M，初始化为空集。</p><p>1、将所有集合 H 中的框进行排序，选出分数最高的框 m，从集合 H 移到集合 M；</p><p>2、遍历集合 H 中的框，分别与框 m 计算交并比（Interection-over-union，IoU），如果高于某个阈值（一般为0~0.5），则认为此框与 m 重叠，将此框从集合 H 中去除。</p><p>3、回到第1步进行迭代，直到集合 H 为空。集合 M 中的框为我们所需。</p><h2 id="需要优化的参数："><a href="#需要优化的参数：" class="headerlink" title="需要优化的参数："></a>需要优化的参数：</h2><p>IoU 的阈值是一个可优化的参数，一般范围为0~0.5，可以使用交叉验证来选择最优的参数。<br>比如人脸识别的一个例子：</p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g19dbcocjfj30gw07kdmg.jpg"><p>已经识别出了 5 个候选框，但是我们只需要最后保留两个人脸。</p><p>首先选出分数最大的框（0.98），然后遍历剩余框，计算 IoU，会发现露丝脸上的两个绿框都和 0.98 的框重叠率很大，都要去除。</p><p>然后只剩下杰克脸上两个框，选出最大框（0.81），然后遍历剩余框（只剩下0.67这一个了），发现0.67这个框与 0.81 的 IoU 也很大，去除。</p><p>至此所有框处理完毕，算法结果：</p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g19dbr3kk4j30gw07kdmi.jpg"><p>（图片来自<a href="https://blog.csdn.net/shuzfan/article/details/52711706）" target="_blank" rel="noopener">https://blog.csdn.net/shuzfan/article/details/52711706）</a></p><h2 id="添加-by-yaya"><a href="#添加-by-yaya" class="headerlink" title="添加 by yaya:"></a>添加 by yaya:</h2><ul><li>在faster r-cnn中，得到了pred_boxes以及cls_boxes 之后，分别对每个类的objects进行NMS。（这里多说一句：使用了class_agnostic=false，即对每个bbox都有N个类别的得分）</li><li>首先得到得分最高的一个object bbox，之后，进行IOU分析，若IoU大于阈值，则剔除，否则保留。</li><li>对这一个得分最高的bbox分析完之后，再分析下一个次高得分的，并剔除所有与它IoU值大于阈值的object。一直这样分析，直到剩下的object之间的IoU值两两之间均小于阈值。</li><li>即可得到该类对应的bbox，且不交叠。</li><li>下一循环分析下一个类<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, imdb.num_classes):</span><br><span class="line">    inds = torch.nonzero(scores[:,j]&gt;thresh).view(<span class="number">-1</span>) </span><br><span class="line">    <span class="comment"># thresh = 0   inds.shape = torch.Size([300])</span></span><br><span class="line">    <span class="comment"># if there is det</span></span><br><span class="line">    <span class="keyword">if</span> inds.numel() &gt; <span class="number">0</span>:</span><br><span class="line">      cls_scores = scores[:,j][inds] <span class="comment"># 某个类在300个object上的得分</span></span><br><span class="line">      _, order = torch.sort(cls_scores, <span class="number">0</span>, <span class="literal">True</span>) <span class="comment"># 某个类在这300个object上的得分的高低排序</span></span><br><span class="line">      <span class="keyword">if</span> args.class_agnostic:</span><br><span class="line">        cls_boxes = pred_boxes[inds, :]</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        cls_boxes = pred_boxes[inds][:, j * <span class="number">4</span>:(j + <span class="number">1</span>) * <span class="number">4</span>]  <span class="comment"># 某个类对应的predict bbox</span></span><br><span class="line">      </span><br><span class="line">      cls_dets = torch.cat((cls_boxes, cls_scores.unsqueeze(<span class="number">1</span>)), <span class="number">1</span>)  <span class="comment"># torch.Size([300, 5])</span></span><br><span class="line">      <span class="comment"># cls_dets = torch.cat((cls_boxes, cls_scores), 1)</span></span><br><span class="line">      cls_dets = cls_dets[order]  <span class="comment"># torch.Size([300, 5]) 排了序之后的cat</span></span><br><span class="line">      keep = nms(cls_dets, cfg.TEST.NMS)  <span class="comment"># torch.Size([91, 1])</span></span><br><span class="line">      cls_dets = cls_dets[keep.view(<span class="number">-1</span>).long()]  <span class="comment"># torch.Size([91, 5])</span></span><br><span class="line">      <span class="keyword">if</span> vis:</span><br><span class="line">        im2show = vis_detections(im2show, imdb.classes[j], cls_dets.cpu().numpy(), <span class="number">0.3</span>)</span><br><span class="line">      all_boxes[j][i] = cls_dets.cpu().numpy()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      all_boxes[j][i] = empty_array</span><br></pre></td></tr></table></figure></li></ul><p>作者：HappyRocking<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/HappyRocking/article/details/79970627" target="_blank" rel="noopener">https://blog.csdn.net/HappyRocking/article/details/79970627</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>]]></content>
      
      
      <categories>
          
          <category> 目标检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CV vs PIL</title>
      <link href="/2019/03/20/CV-vs-PIL/"/>
      <url>/2019/03/20/CV-vs-PIL/</url>
      
        <content type="html"><![CDATA[<h2 id="PIL"><a href="#PIL" class="headerlink" title="PIL"></a>PIL</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line">pil_image = Image.open(<span class="string">'test.jpg'</span>) <span class="comment"># 图片是360x480 宽x高  </span></span><br><span class="line">print(type(pil_image)) <span class="comment"># out: PIL.JpegImagePlugin.JpegImageFile  </span></span><br><span class="line">print(pil_image.size)  <span class="comment"># out: (360,480) # w,h  </span></span><br><span class="line">print(pil_image.mode) <span class="comment"># out: 'RGB'  </span></span><br><span class="line">  </span><br><span class="line">pil_image = np.array(pil_image,dtype=np.float32) <span class="comment"># image = np.array(image)默认是uint8  </span></span><br><span class="line">print(pil_image.shape) <span class="comment"># out: (480, 360, 3)  </span></span><br><span class="line"><span class="comment"># 神奇的事情发生了，w和h换了，变成(h,w,c)了  </span></span><br><span class="line"><span class="comment"># 注意ndarray中是 行row x 列col x 维度dim 所以行数是高，列数是宽</span></span><br></pre></td></tr></table></figure><blockquote><pre><code>输出结果：&lt;class &apos;PIL.JpegImagePlugin.JpegImageFile&apos;&gt;(360, 480)RGB(480, 360, 3)</code></pre></blockquote><p>这里截图在pycharm下调试的信息（未转化成numpy array之前）</p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g193y86ko4j30lt0ixmy8.jpg">  <blockquote><p>可以看到PIL.Image读出的image格式为（w,h,c）且image.mode = ‘RGB’<br>并且由代码的注释可以看到，当PIL.Image转化成numpy.array格式之后，image.size将转为（h,w,c）,c 仍为“RGB”</p></blockquote><h2 id="CV"><a href="#CV" class="headerlink" title="CV"></a>CV</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line">cv_image = cv2.imread(<span class="string">'test.jpg'</span>)  </span><br><span class="line">print(type(cv_image)) <span class="comment"># out: numpy.ndarray  </span></span><br><span class="line">print(cv_image.dtype) <span class="comment"># out: dtype('uint8')  </span></span><br><span class="line">print(cv_image.shape) <span class="comment"># out: (360,480, 3) (h,w,c) 和skimage类似  </span></span><br><span class="line"><span class="comment"># print(image) # BGR</span></span><br></pre></td></tr></table></figure><h2 id="为了比较PIL-和-CV"><a href="#为了比较PIL-和-CV" class="headerlink" title="为了比较PIL 和 CV"></a>为了比较PIL 和 CV</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(cv_image == pil_image)</span><br></pre></td></tr></table></figure><p>可以看到 分别是 False True False<br><strong>原因是PIL提取的是“RGB”，而CV提取的是“BGR”</strong><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g194ap1lw4j306d07zmx0.jpg"></p><p>综上，可以凝练为以下几点：</p><ol><li>PIL提取的是PIL.image类型的数据（w,h,c），通道是“RGB”。</li><li>将该数据转为numpy.array之后，得到的是（h,w,c），通道仍是“RGB”。</li><li>CV提取的是numpy.array类型的数据（h,w,c），注意通道是“BGR”。</li></ol><ul><li>再</li><li>在pytorch中输入的image模式是“RGB”</li><li>在caffe中输入的是“BGR”</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pytorch_normalze</span><span class="params">(img)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    https://github.com/pytorch/vision/issues/223</span></span><br><span class="line"><span class="string">    return appr -1~1 RGB</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    normalize = tvtsf.Normalize(mean=[<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>],</span><br><span class="line">                                std=[<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">    img = normalize(t.from_numpy(img))</span><br><span class="line">    <span class="keyword">return</span> img.numpy()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">caffe_normalize</span><span class="params">(img)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    return appr -125-125 BGR</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    img = img[[<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>], :, :]  <span class="comment"># RGB-BGR</span></span><br><span class="line">    img = img * <span class="number">255</span></span><br><span class="line">    mean = np.array([<span class="number">122.7717</span>, <span class="number">115.9465</span>, <span class="number">102.9801</span>]).reshape(<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    img = (img - mean).astype(np.float32, copy=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> img</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础知识-try与except处理异常语句</title>
      <link href="/2019/03/19/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-try%E4%B8%8Eexcept%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E8%AF%AD%E5%8F%A5/"/>
      <url>/2019/03/19/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-try%E4%B8%8Eexcept%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="try-except介绍"><a href="#try-except介绍" class="headerlink" title="try/except介绍"></a>try/except介绍</h2><blockquote><p>与其他语言相同，在python中，try/except语句主要是用于处理程序正常执行过程中出现的一些异常情况，如语法错（python作为脚本语言没有编译的环节，在执行过程中对语法进行检测，出错后发出异常消息）、数据除零错误、从未定义的变量上取值等；而try/finally语句则主要用于在无论是否发生异常情况，都需要执行一些清理工作的场合，如在通信过程中，无论通信是否发生错误，都需要在通信完成或者发生错误时关闭网络连接。尽管<strong>try/except和**</strong>try/finally**的作用不同，但是在编程实践中通常可以把它们组合在一起使用try/except/else/finally的形式来实现稳定性和灵活性更好的设计。</p><p>默认情况下，在程序段的执行过程中，如果没有提供try/except的处理，脚本文件执行过程中所产生的异常消息会自动发送给程序调用端，如python shell，而python shell对异常消息的默认处理则是终止程序的执行并打印具体的出错信息。这也是在python shell中执行程序错误后所出现的出错打印信息的由来。</p></blockquote><h2 id="try-except格式"><a href="#try-except格式" class="headerlink" title="try/except格式"></a>try/except格式</h2><blockquote><p>python中try/except/else/finally语句的完整格式如下所示：</p><p>try:</p><p>​     Normal execution block</p><p>except A:</p><p>​     Exception A handle</p><p>except B:</p><p>​     Exception B handle</p><p>except:</p><p>​     Other exception handle</p><p>else:</p><p>​     if no exception,get here</p><p>finally:</p><p>​     print(“finally”)   </p></blockquote><blockquote><p>说明：</p><p>正常执行的程序在try下面的Normal execution block执行块中执行，在执行过程中如果发生了异常，则<strong>中断当前在Normal execution block中的执行</strong>，跳转到对应的异常处理块中开始执行；</p><p>python<strong>从第一个except X处开始查找</strong>，如果找到了对应的exception类型则进入其提供的exception handle中进行处理，如果没有找到则直接进入except块处进行处理。except块是可选项，如果没有提供，该exception将会被提交给python进行默认处理，处理方式则是<strong>终止应用程序并打印提示信息</strong>；</p><p>如果在Normal execution block执行块中执行过程中没有发生任何异常，则在执行完Normal execution block后会进入else执行块中（如果存在的话）执行。</p></blockquote><blockquote><p>无论是否发生了异常，只要提供了finally语句，以上try/except/else/finally代码块执行的最后一步总是执行finally所对应的代码块。</p><p>需要注意的是：</p><p>1.在上面所示的完整语句中try/except/else/finally所出现的顺序必须是try–&gt;except X–&gt;except–&gt;else–&gt;finally，即所有的<strong>except必须在else和finally之前</strong>，<strong>else（如果有的话）必须在finally之前</strong>，而<strong>except X必须在except之前</strong>。否则会出现语法错误。</p><p>2.对于上面所展示的try/except完整格式而言，else和finally都是可选的，而不是必须的，但是如果存在的话e<strong>lse必须在finally之前</strong>，<strong>finally</strong>（如果存在的话）<strong>必须在整个语句的最后位置</strong>。</p><p>3.在上面的完整语句中，else语句的存在必须以except X或者except语句为前提，<strong>如果在没有except语句的try block中使用else语句会引发语法错误</strong>。也就是说<strong>else不能与try/finally配合使用</strong>。</p></blockquote><p>4.except的使用要非常小心，慎用。</p><p>class AError(Exception):<br>     “””AError—exception”””<br>     print(‘AError’)</p><blockquote><p>try:</p><p>​     #raise AError</p><p>​     asdas(‘123’)</p><p>except AError:</p><p>​     print(“Get AError”)</p><p>except:</p><p>​     print(“exception”)     </p><p>else:</p><p>​     print(“else”)</p><p>finally:</p><p>​     print(“finally”)     </p><p>print(“hello wolrd”)</p><p>在上面的代码中，Normal execution block中出现了语法错误，但是由于使用了except语句，该语法错误就被掩盖掉了。因此在使用try/except是最好还是要非常清楚的知道Normal execution block中有可能出现的异常类型以进行针对性的处理。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(SAGE)Auto-Encoding Scene Graphs for Image Captioning</title>
      <link href="/2019/03/16/SAGE-Auto-Encoding-Scene-Graphs-for-Image-Captioning/"/>
      <url>/2019/03/16/SAGE-Auto-Encoding-Scene-Graphs-for-Image-Captioning/</url>
      
        <content type="html"><![CDATA[<p>本文是CVPR2019 的关于图像描述的文章，主要让我关注的原因是用到了scene graph 和 GCN，这也是本文最大的创新点。但是本文利用的是saptial GCN（悄悄说，构建的graph节点数量少，而且是异质的，不如说是多方面融合信息已达到丰富信息的目的 :-) ）</p><ul><li>后记<br>这里讲一下图卷积中spatial  gcn①②③ 与 spectral gcn ④⑤⑥<br>①Learning task-dependent distributed representations by backpropagation through structure.<br>②A new model for  learning in graph domains<br>③The graph neural network model<br>④Spectral networks and locally connected networks on graphs.<br>⑤Deep convolutional networks on graph-structured data.<br>⑥Semi-supervised classification with graph convolutional networks</li></ul><p>关于这篇论文采用的graph  convolutional network：采用的数</p><ul><li>为什么这样说？<br>本文提到了两类graph，一类是sentence scene graph，另一类是image scene graph，而在这两类下，又进行细分为relationship、attribute、object graph。但是，每个graph 中节点是异质的，比如在relationship graph中，obejct<sub>a</sub>， obejct<sub>b</sub>，relationship<sub>ab</sub>构成了一个graph，目的是来更新relationship embedding。从我的角度来看，只是融合相关信息来更新某一目标的特征，与graph无关。  </li><li>写在最前面，我个人的理解，在得到graph 节点的embedding 之后，就要输入gcn layer 来更新特征，这里，gcn layer 的表达公式可以这样理解： 该graph中所有的节点v<sub>i</sub>，经过concatenate之后，再经过一个全连接层。<br>gcn(.) = fc( concatenate(v1, v2, … , vn) )**</li></ul><p>下面说正文：</p><h1 id="General-encoder-decoder-network-for-image-captioning"><a href="#General-encoder-decoder-network-for-image-captioning" class="headerlink" title="General encoder-decoder network for image captioning"></a>General encoder-decoder network for image captioning</h1><ul><li><p>目前一般的encoder-decoder network for image captioning 是<strong>CNN提取image的特征，然后RNN来生成句子</strong>，例如下图所示。</p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14r211sidj30kb0fy0v3.jpg" style="zoom:80%"></li><li><p>进一步有<strong>加入attention</strong> [1]，下图是提取14×14×512 feature map of the fourth  convolutional layer，然后 flatten to 196 × 512 before feed into decoder。在输入到decoder时对这196个feature vector进行attention的加权求和。</p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14rdh7wg7j33ak1ep7wj.jpg" style="zoom:50%"></li><li><p>也有<strong>提取images 中的object，以此来提取显著信息，对object feature 进行attention的加权求和并送入decoder</strong>。具体地，使用RPN 的ROI pooling来提取objects feature，然后对LSTM的每一个step ,对这所有的object features进行attention操作，再作为输入送入LSTM[2]。如下图</p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14u74yahwj30q30modsg.jpg" style="zoom:70%"></li></ul><h1 id="本文的encoder-decoder-baseline"><a href="#本文的encoder-decoder-baseline" class="headerlink" title="本文的encoder-decoder baseline"></a>本文的encoder-decoder baseline</h1><h2 id="1-Encoder"><a href="#1-Encoder" class="headerlink" title="1. Encoder"></a><strong>1.</strong> <strong>Encoder</strong></h2><p>本文有两个encoder ： image-encoder；sentence-encoder<br>本文sentence-encoder  是用来预训练Dictionary，并共享给 image-encoder。但是在baseline中不用GCN/MGCN 和 Dictionary，因此image-encoder与sentence-encoder 之间是没有交集的。（我猜测 baseline中没有用到sentence-encoder）</p><p><strong>（1）对于image encoder 得到object embedding，relationship embedding , attribute embedding。</strong></p><p>如何得到object embedding，relationship embedding , attribute embedding？</p><ul><li>object detector : 采用与[1]一致的方式来训练faster r-cnn， 0.7的阈值 for proposal NMS， 0.3的阈值for object NMS。Faster R-CNN在visual genome上预训练，预训练之后，对proposals采取0.7的IoU阈值进行NMS，对objects 采取0.3的IoU阈值进行NMS，对每个image，采取10-100个object。使用RoI pooling 来提取object features，该object features 将作为后边relationship classifier 和attribute classifier的输入。</li><li>relationship classifier：使用在[5] 中提到的LSTM结构来作为关系分类器，来为两个object 分配一个relationship label。</li><li>attribute classifier : 为某个object 分配属性标签，将该object feature输入fc-relu-fc-softmax网络，则得到属性标签。</li></ul><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14vip74y0j311l09eq4y.jpg" style="zoom:60%">      <ul><li><p>以上三个输出的所有构成一个image scene graph  </p></li><li><p>需要说明以上三个是在<strong>Visual Genome数据集</strong>上预训练的，该数据集具有丰富的scene graph 标注，含有obejct’s categories，obejct’s attributes and pairwise relationships，因此可以用来训练目标检测器、属性分类器、关系分类器。但是由于这些标注含有很多噪声，因此采用一定的措施进行过滤：对于在数据集中出现超过2000次的objects，attributes，relationships保留下来，其余的去掉。经过这样的处理，则得到305个objects类，103个属性类，64个关系类  </p></li><li><p>经过分类器得到 label 之后，还需要得到相对应的embedding: <strong>u<sub>o</sub> , u<sub>r</sub> , u<sub>a</sub></strong> 。<br>其中 label 的维度472 = 305 + 103 + 64，即object/realation/attribute label的one hot vector 维度是三种节点的总类别数。</p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14w80gi8tj30w70ik0xu.jpg" style="zoom:70%">  </li></ul><p><strong>（2）对于sentence encoder 使用[6] 来得到 parse scene graph，进而得到object embedding，relationship embedding , attribute embedding</strong><br>注意这里的sentences使用的是<strong>MS COCO</strong>中的caption，而不是Visual Genome中的caption。同样对其进行过滤，过滤掉在all parsed scene graph中出现的objects、attributes、relationships次数少于10的，则剩下5364个objects类，1308个realtionships类，3430个attributes类。<br>sentence encoder 使用[6] 来得到 parse scene graph，但实际上，[6]又是使用[7]中的方法，所以读者最好看[7]<br>这里介绍 一下[6] SPICE 是用来评价image caption的一个性能指标，这里为什么使用它，它是用来做为一个评价指标的吗？首先回答第二个问题，不是用来作为评价指标的，而是利用了它的原理：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1dwj56im1j30iq0nmk00.jpg"></p><p>parse scene graph 的过程：sentence-&gt; syntax dependency tree-&gt; scene graph<br>给定一个句子，首先分析句法依赖树，再根据给定句法依赖树的情况下，输出scene graph，而scene graph 的输出是对sentence中的每一个次元，输出其是object，还是 relation，还是attribute（即，对每个word 输出一个one hot vector （我的猜测））。如下图所示：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1gbldqsamj30q50kntkm.jpg"></p><p>经过parse scene graph得到的是object <strong>label</strong>、relationship <strong>label</strong>、attributes <strong>label</strong>的one hot vector（注意one hot 的长度是 5346+1308+3430 = 10102，即 将三种node合在了一起）。得到label之后，再经过word embedding层即可得到对应的word embedding: <strong>e<sub>o</sub> , e<sub>r</sub> , e<sub>a</sub></strong>。<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14w6j9aouj31670aqdiw.jpg" style="zoom:50%"></p><h2 id="2-Decoder"><a href="#2-Decoder" class="headerlink" title="2.  Decoder"></a><strong>2.</strong>  <strong>Decoder</strong></h2><p>由两层LSTM组成（该部分与论文[1][4] 的decoder部分是完全一致的，只是输入的encoder output不一样而已），下图给出了我自己画的decoder 结构[1]给出的结构[4]中给出的decoder结构</p><ul><li>在[4]中encoder output是GCN输出的object features（两个graph生成的encoder output分别送入decoder）。</li><li>但是在本文中encoder output是 <strong>u<sub>o</sub> , u<sub>r</sub> , u<sub>a</sub></strong> 组合成的d×M 矩阵，或者是 <strong>e<sub>o</sub> , e<sub>r</sub> , e<sub>a</sub></strong> 组合成的d×M 矩阵 。M = num_objects + num_relationships + num_attributes  注意：在sentence-encoder中的输出，这里的M是该句子的parse scene graph实际生成的object、relation、attribute的数量（有可能baseline 中不使用 sentence-encoder）；在image-encoder中的输出，这里也是实际的object detector、relationship classifier、attribute classifier 输出的实际数量总和</li></ul><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14xg3jwvdj30mo0h2wfi.jpg" style="zoom:60%"><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g19d1x7kiij30im0bvaat.jpg" style="zoom:60%"><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14v8kb8kmj30sr0gzwgz.jpg" style="zoom:60%">具体地，这里也给出本文的表达方式如下表:这里的10369是对MS COCO中的captions 进行预处理之后，得到的 len of vocabulary<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14wrwfzplj30ze0hcjwe.jpg" style="zoom:60%"><h1 id="在baseline-上加东西"><a href="#在baseline-上加东西" class="headerlink" title="在baseline 上加东西"></a>在baseline 上加东西</h1><ul><li>一般的encoder-decoder如下图中的top所示，本文提出加入MGCN for image和GCN for sentence，同时加入Dictionary（共享参数 betwen sentence and image）<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14yn2vbtej30k40jzac6.jpg" style="zoom:50%">由以上可知，构建了image scene graph 和 sentence scene graph，下面将本文的主要创新点，加入GCN和Dictionary  </li></ul><h2 id="sentence-graph-gt-GCN-更新embedding"><a href="#sentence-graph-gt-GCN-更新embedding" class="headerlink" title="sentence graph -&gt; GCN (更新embedding )"></a>sentence graph -&gt; GCN (更新embedding )</h2><p>经上面的分析构建的sentence scene graph 在得到了object、relation、attribute label 对应的word embedding之后，将通过GCN来更新embedding。</p><ul><li>表中的（7）（8）（9）可以认为是三个relationship、attribute、object graph。<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14y1f5p02j31370e1jw1.jpg" style="zoom:60%"></li><li>解释这里的<strong>g<sub>r</sub> g<sub>a</sub> g<sub>o</sub> g<sub>s</sub></strong><br>以<strong>g<sub>r</sub></strong> 为例：g<sub>r</sub> (D<sub>in</sub>，D<sub>out</sub>）。输入维度为什么是3000？因为e<sub>oi</sub> , e<sub>rij</sub> , e<sub>oj</sub>的维度分别均是1000，论文中省略了将其concatenate的操作的说明，但是实际上是进行了concatenate操作，使得维度变为3000，并作为g<sub>r</sub>的输入。输出是1000维度。</li><li><strong>因此这里图卷积层，可以认为是 该graph中所有的节点v<sub>i</sub>，经过concatenate之后，再经过一个全连接层。<br>g(.) = fc( concatenate(v1, v2, … , vn) )</strong><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14y594pa8j30og0ksdi2.jpg" style="zoom:50%">  </li></ul><h2 id="image-graph-gt-Multi-modal-GCN-更新embedding"><a href="#image-graph-gt-Multi-modal-GCN-更新embedding" class="headerlink" title="image graph -&gt; Multi-modal GCN (更新embedding )"></a>image graph -&gt; Multi-modal GCN (更新embedding )</h2><p>与sentence graph 对应的GCN类似，这里的 multimodal 也没什么意思，就是特征融合时（9）（10）（11），既使用了label 对应的word embedding，又使用了feature。<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14yf14p1mj30sp0k0ten.jpg">  </p><ul><li>解释这里的<strong>f<sub>r</sub> f<sub>a</sub> f<sub>o</sub> f<sub>s</sub></strong><br>与sentence scene graph 对应的g一致，首先对输入进行了concatenate操作<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14yhc6gpzj314l0gktax.jpg"></li></ul><h2 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h2><ul><li><strong>该部分的作用</strong>是一个memory network。首先Dictionary在<strong>S-&gt;G-&gt;D-&gt;S</strong>上预训练，之后才被用于<strong>I-&gt;G-&gt;D-&gt;S</strong>  。即是参数共享的。而在<strong>S-&gt;G-&gt;D-&gt;S</strong>中，输入的sentence是由human generated。因此Dictionary中就preserve human’s inductive bias。进而与<strong>I-&gt;G-&gt;D-&gt;S</strong>  共享，使得由image 生成的predict caption也含有 human’s inductive bias</li><li>由上文分析可知，经过GCN/MGCN更新的embedding的维度均是1000，则Dictionary的输入维度均是1000，D是可学习参数矩阵1000*10000，输入的x经过Dictionary得到 x^<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14yrlt89sj310c07e40b.jpg">  </li></ul><h2 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h2><p>经过encoder 结合GCN/MGCN之后，输出发生了改变，这里再讲一下decoder的输入。</p><ul><li>在<strong>S-&gt;G-&gt;D-&gt;S</strong> 这个序列过程中由D-&gt;S 即输入decoder LSTM的过程，输入的是D的输出。</li><li>而在<strong>I-&gt;G-&gt;D-&gt;S</strong> 这个序列过程中，输入decoder LSTM的过程，输入的是D的输出v’和G的输出v^，即concate[v’, v^]<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1507wpmlij30zf0h8dku.jpg"></li></ul><h1 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h1><ul><li>首先使用交叉熵损失函数训练 <strong>S-&gt;G-&gt;S</strong>  20 epoch。注意D不参与训练</li><li>使用交叉熵损失函数训练 <strong>S-&gt;G-&gt;D-&gt;S</strong>  20 epoch。这里的D参与训练</li><li>使用交叉熵损失函数训练 <strong>I-&gt;G-&gt;D-&gt;S</strong>  20 epoch。这里的D使用在上一步骤中预训练的参数，并fine-tune</li><li>使用RL-based reward 训练 <strong>I-&gt;G-&gt;D-&gt;S</strong>  40 epoch。 D参与训练  </li></ul><h1 id="推理过程"><a href="#推理过程" class="headerlink" title="推理过程"></a>推理过程</h1><ul><li>文章中没有写，但是我认为是<strong>I-&gt;G-&gt;D-&gt;S</strong>  </li></ul><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><ul><li>由下表可知，实验结果并不突出，尤其是与GCN-LSTM[7]对比可知，GCN-LSTM的结构更加简单的情况下，两个模型的结果却相差不多。</li><li>可以看到表中有三个GCN-LSTM， 最上边那个是本文作者的复现，由于GCN-LSTM的作者batch_size 太大，本文作者觉得对比不公平，因此重新复现了代码（没公开代码）并减小了bs进行实验得到的结果。第二个GCN-LSTM（sem graph）是原作者论文中的实验数据。第三个GCN-LSTM是融合了semantic graph 和saptial graph。</li><li>对于SGAE的融合应该是输入decoder的不仅是<strong>I-&gt;G-&gt;D-&gt;S</strong> 中D的输出v’，而且也输入G的输出 v^，即concate[v’,  v^]<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14zjng66yj30oc0f0djs.jpg">   </li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] Bottom-up and top-down attention for image captioning and visual question answering<br>[2] Show, Attend and Tell: Neural Image Caption  Generation with Visual Attention<br>[3] Image Captioning with Object Detection and Localization<br>[4] Exploring Visual Relationship  for Image Captioning<br><strong>[5] Neural motifs: Scene graph parsing with global context</strong><br><strong>[6] Spice:  Semantic propositional image caption evaluation</strong><br><strong>[7] Generating Semantically Precise Scene Graphs from Textual Descriptions for Improved Image Retrieval</strong></p>]]></content>
      
      
      <categories>
          
          <category> 图像描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像描述 </tag>
            
            <tag> 图卷积网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Video as Space-Time Region Graphs</title>
      <link href="/2019/03/15/Video-as-Space-Time-Region-Graphs/"/>
      <url>/2019/03/15/Video-as-Space-Time-Region-Graphs/</url>
      
        <content type="html"><![CDATA[<p>本篇文章主要是讲图卷积网络应用在行为识别任务中。<br>使用的两个数据集是：charades和something-something数据集</p><ul><li>从数据集中video丰富性方面：其中charades数据集含有丰富的室内场景，video中的object较为复杂，也不居中。而，something-something 数据集中的video只含有1~2个object，且位于画面中的中心位置。</li><li>从数据集中video时长：charades的一整个video近30s长，但是annotation是对clips of video进行的标注，clips的分割也不具备规律性，几秒到几十秒不等。something-something数据集的video 时长为3s-6s。均为较短的视频。  </li></ul><p>由以上对数据集的分析，与作者的实验结果，结合，由于something-something的video时长短，objects of video 也较小，因此gcn+i3d 相比于对i3d的提升不大，而相反，charades数据集的提升较大。</p><ul><li>这里给出自己的看法：由于在charades上的提升较为明显，因此使用该网络应用到其他的网络中时，最好可以使用charades数据集进行pre-train，而不要使用something-something数据集。</li></ul><h2 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h2><p>在训练阶段，首先对video以6 fps的帧率进行截取帧，输入网络时，每个video选取30帧，这样相当于video中的5s。即在训练阶段，每个5s长的clips作为一个sample，赋给它相对应的label，进行训练。</p><h2 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h2><p>在测试阶段，charades对每个video 提取10个clips ，对每个clips的输出结果，以最大池化的方式进行聚合，对于something-something数据集，每个video提取2个clips，其他同理。</p><h2 id="Construct-Graph"><a href="#Construct-Graph" class="headerlink" title="Construct Graph"></a>Construct Graph</h2><p>对于charades dataset，每帧中提取50个object，对于something-something dataset ，每帧中提取10个object。</p><ul><li>Similarity Graph<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g13qsziabzj30fk0ahjrw.jpg" style="zoom:65%">Similarity graph 含有可学习参数</li><li>Spatial Graph</li><li>无可学习参数</li><li>We denote the IoU between object i in frame t and object  j in frame t + 1 as σ<sub>ij</sub><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g13qv0z3bxj30fq0b30t3.jpg" style="zoom:65%"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 行为识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 行为识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-物理CPU和逻辑CPU</title>
      <link href="/2019/03/13/linux-%E7%89%A9%E7%90%86CPU%E5%92%8C%E9%80%BB%E8%BE%91CPU/"/>
      <url>/2019/03/13/linux-%E7%89%A9%E7%90%86CPU%E5%92%8C%E9%80%BB%E8%BE%91CPU/</url>
      
        <content type="html"><![CDATA[<p>通过cat /proc/cpuinfo 来查看CPU的信息</p><p><img src="https:////upload-images.jianshu.io/upload_images/5262207-4e29a8e7da45169c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/837/format/webp" alt="img"></p><p>cpu.png</p><p>physical id 表示物理CPU的编号<br> CPU cores 表示每个物理CPU上的内核数<br> core id 表示每个内核的编号<br> processor 表示每个逻辑CPU的编号</p><p>逻辑CPU的总数=物理CPU的数量 * 每个物理CPU上的核数 * 超线程数<br> 如果 逻辑CPU的总数=物理CPU的数量 * 每个物理CPU上的核数 则表示超线程没开，否则表示超线程以开</p><p>作者：君子亮剑</p><p>链接：<a href="https://www.jianshu.com/p/ff8e8be262ac" target="_blank" rel="noopener">https://www.jianshu.com/p/ff8e8be262ac</a></p><p>来源：简书</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-查看cpu状态</title>
      <link href="/2019/03/13/linux-%E6%9F%A5%E7%9C%8Bcpu%E7%8A%B6%E6%80%81/"/>
      <url>/2019/03/13/linux-%E6%9F%A5%E7%9C%8Bcpu%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<ul><li>转载 “<a href="https://www.tianmaying.com/tutorial/cpu-top&quot;" target="_blank" rel="noopener">https://www.tianmaying.com/tutorial/cpu-top&quot;</a><br><code>top</code>命令是<code>Linux</code>下常用的性能分析工具，但本质上它提供了实时的对系统处理器的状态监视</li></ul><p>在命令行中输入<code>top</code>将输出一下信息：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">top - 23:16:12 up  7:40, <span class="number"> 1 </span>user,  load average: 0.97, 0.98, 1.01</span><br><span class="line">Tasks:<span class="number"> 440 </span>total,  <span class="number"> 2 </span>running,<span class="number"> 438 </span>sleeping,  <span class="number"> 0 </span>stopped,  <span class="number"> 0 </span>zombie</span><br><span class="line">%Cpu(s):  1.3 us,  1.4 sy,  0.0 ni, 96.9 id,  0.0 wa,  0.0 hi,  0.4 si,  0.0 st</span><br><span class="line">KiB Mem : 13183891+total, 12378241+free, <span class="number"> 3884532 </span>used, <span class="number"> 4171956 </span>buff/cache</span><br><span class="line">KiB Swap:       <span class="number"> 0 </span>total,       <span class="number"> 0 </span>free,       <span class="number"> 0 </span>used. 12719112+avail Mem </span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                                               </span><br><span class="line">11746 jenkins  <span class="number"> 20 </span> <span class="number"> 0 </span><span class="number"> 159972 </span> <span class="number"> 4760 </span> <span class="number"> 1600 </span>R  99.7  0.0 362:41.65 root/2                                                                                                                </span><br><span class="line">  <span class="number"> 42 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   4.3  0.0  14:46.50 rcu_sched                                                                                                             </span><br><span class="line">  <span class="number"> 68 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   2.6  0.0   0:55.10 rcuos/25                                                                                                              </span><br><span class="line">11414 jenkins  <span class="number"> 20 </span> <span class="number"> 0 </span>42.134g 1.652g <span class="number"> 24516 </span>S   0.7  1.3   2:37.54 java                                                                                                                  </span><br><span class="line">  <span class="number"> 49 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.3  0.0   0:32.35 rcuos/6                                                                                                               </span><br><span class="line"><span class="number"> 6818 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.3  0.0   0:34.33 kworker/0:1                                                                                                           </span><br><span class="line">14702 root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.3  0.0   0:00.26 kworker/2:0                                                                                                           </span><br><span class="line">15491 txq      <span class="number"> 20 </span> <span class="number"> 0 </span><span class="number"> 158044 </span> <span class="number"> 2616 </span> <span class="number"> 1552 </span>R   0.3  0.0   0:00.13 top                                                                                                                   </span><br><span class="line">   <span class="number"> 1 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span> <span class="number"> 45892 </span> <span class="number"> 8580 </span> <span class="number"> 3908 </span>S   0.0  0.0   0:13.06 systemd                                                                                                               </span><br><span class="line">   <span class="number"> 2 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.06 kthreadd</span><br></pre></td></tr></table></figure><p>前五行是当前整个系统资源的统计信息。</p><p>第一行是任务队列，包括当前时间，系统运行的总时间，系统用户登陆的数量，以及1分钟，5分钟，15分钟系统的负载情况。</p><p>第二行是<code>Tasks</code>信息，显示当前系统总共的进程数为440，运行状态的进程有两个，438个处于休眠状态，0个停止，0个僵尸进程。</p><p>第三行是<code>CPU</code>信息，很多人可能会忽略这些信息，我之前就是，所以详细说一下。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%<span class="selector-tag">Cpu</span>(<span class="selector-tag">s</span>):  1<span class="selector-class">.3</span> <span class="selector-tag">us</span>,  1<span class="selector-class">.4</span> <span class="selector-tag">sy</span>,  0<span class="selector-class">.0</span> <span class="selector-tag">ni</span>, 96<span class="selector-class">.9</span> <span class="selector-tag">id</span>,  0<span class="selector-class">.0</span> <span class="selector-tag">wa</span>,  0<span class="selector-class">.0</span> <span class="selector-tag">hi</span>,  0<span class="selector-class">.4</span> <span class="selector-tag">si</span>,  0<span class="selector-class">.0</span> <span class="selector-tag">st</span></span><br></pre></td></tr></table></figure><p><code>us</code> user CPU time —-用户空间占用<code>CPU</code>百分比</p><p><code>sy</code> system CPU time—-内核空间占用<code>CPU</code>百分比</p><p><code>ni</code> nice CPU time—-用户进程空间内改变过优先级的进程占用<code>CPU</code>百分比</p><p><code>id</code> idle—-空闲<code>CPU</code>百分比</p><p><code>wa</code> iowait—- 等待输入输出的<code>CPU</code>时间百分比</p><p><code>hi</code> hardware irq—-硬件中断</p><p><code>si</code> software irq—-软件中断</p><p><code>st</code> steal time—-实时</p><p>具体对应到第三行的详细信息，大家自己对照一下就行，或者在你命令行中试一下。</p><p>第四行<code>Memory</code>的状态信息，总共13183891+内存，空闲12378241+，使用3884532，缓存为4171956</p><p>第五行<code>Swap</code>交换分区信息，总共0，空闲0，使用0，缓存交换区总量12719112+</p><p>第六行是各个进程监视的项目列</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PID   <span class="built_in"> USER </span>     PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+   COMMAND</span><br><span class="line">PID` — 进程`id</span><br></pre></td></tr></table></figure><p><code>USER</code> — 进程所有者</p><p><code>PR</code> — 进程优先级</p><p><code>NI</code> — nice值。负值表示高优先级，正值表示低优先级</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VIRT` — 进程使用的虚拟内存总量。`VIRT=SWAP+RES</span><br><span class="line">RES` — 进程使用的、未被换出的物理内存大小。`RES=CODE+DATA</span><br></pre></td></tr></table></figure><p><code>SHR</code> — 共享内存大小</p><p><code>S</code>— 进程状态。<code>D</code>=不可中断的睡眠状态 <code>R</code>=运行 <code>S</code>=睡眠 <code>T</code>=跟踪/停止 <code>Z</code>=僵尸进程</p><p><code>%CPU</code> — 上次更新到现在的<code>CPU</code>时间占用百分比</p><p><code>%MEM</code> — 进程使用的物理内存百分比</p><p><code>TIME+</code> — 进程使用的<code>CPU</code>时间总计</p><p><code>COMMAND</code> — 进程名称（命令名/命令行）</p><p>对应的每个进程的信息，大家可以自己看一下。</p><p>如果你在命令行下再输入<code>1</code>，输出如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">top - <span class="number">23</span>:<span class="number">16</span>:<span class="number">12</span> <span class="keyword">up</span>  <span class="number">7</span>:<span class="number">40</span>,  <span class="number">1</span> user,  load average: <span class="number">0.97</span>, <span class="number">0.98</span>, <span class="number">1.01</span></span><br><span class="line">Task<span class="variable">s:</span> <span class="number">440</span> total,   <span class="number">2</span> running, <span class="number">438</span> sleeping,   <span class="number">0</span> stopped,   <span class="number">0</span> zombie</span><br><span class="line">%Cpu0  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu1  :  <span class="number">0.0</span> us,  <span class="number">0.3</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni, <span class="number">99.7</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu2  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu3  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu4  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu5  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu6  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu7  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu8  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu9  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu10 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu11 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu12 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu13 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu14 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu15 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu16 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu17 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu18 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu19 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu20 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu21 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu22 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu23 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu24 : <span class="number">44.2</span> us, <span class="number">43.9</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,  <span class="number">0.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>, <span class="number">12.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu25 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu26 :  <span class="number">0.3</span> us,  <span class="number">0.3</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni, <span class="number">99.3</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu27 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu28 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu29 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu30 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu31 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">KiB Mem : <span class="number">13183891</span>+total, <span class="number">12377862</span>+free,  <span class="number">3887628</span> used,  <span class="number">4172660</span> buff/cache</span><br><span class="line">KiB Swap:        <span class="number">0</span> total,        <span class="number">0</span> free,        <span class="number">0</span> used. <span class="number">12718814</span>+avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                                               </span><br><span class="line"><span class="number">11746</span> jenkins   <span class="number">20</span>   <span class="number">0</span>  <span class="number">159972</span>   <span class="number">4760</span>   <span class="number">1600</span> R <span class="number">100.0</span>  <span class="number">0.0</span> <span class="number">393</span>:<span class="number">16.94</span> root/<span class="number">2</span>                                                                                                                </span><br><span class="line">   <span class="number">42</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">2.7</span>  <span class="number">0.0</span>  <span class="number">15</span>:<span class="number">59.27</span> rcu_sched                                                                                                             </span><br><span class="line">   <span class="number">67</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">1.3</span>  <span class="number">0.0</span>   <span class="number">1</span>:<span class="number">03.60</span> rcuos/<span class="number">24</span></span><br></pre></td></tr></table></figure><p>输入<code>1</code>可以查看每个逻辑<code>CPU</code>的情况，如上总共有32个逻辑<code>CPU</code>；</p><p>其他命令：</p><p>输入<code>b</code>，显示高亮，<code>shift+&gt;</code>和<code>shift+&lt;</code>可以左右切换</p><p>输入<code>x</code>也是显示高亮，但没有<code>b</code>那么明显，同理<code>shift+&gt;</code>和<code>shift+&lt;</code>可以左右切换</p><p>直接输入<code>top -c</code>，会显示完整命令，输出如下：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">top - 23:56:31 up  8:20, <span class="number"> 1 </span>user,  load average: 0.95, 0.97, 1.00</span><br><span class="line">Tasks:<span class="number"> 439 </span>total,  <span class="number"> 2 </span>running,<span class="number"> 437 </span>sleeping,  <span class="number"> 0 </span>stopped,  <span class="number"> 0 </span>zombie</span><br><span class="line">%Cpu(s):  1.4 us,  1.5 sy,  0.0 ni, 96.8 id,  0.0 wa,  0.0 hi,  0.4 si,  0.0 st</span><br><span class="line">KiB Mem : 13183891+total, 12377344+free, <span class="number"> 3892304 </span>used, <span class="number"> 4173168 </span>buff/cache</span><br><span class="line">KiB Swap:       <span class="number"> 0 </span>total,       <span class="number"> 0 </span>free,       <span class="number"> 0 </span>used. 12718340+avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                                               </span><br><span class="line">11746 jenkins  <span class="number"> 20 </span> <span class="number"> 0 </span><span class="number"> 159972 </span> <span class="number"> 4760 </span> <span class="number"> 1600 </span>R 100.0  0.0 402:57.42 root/2                                                                                                                </span><br><span class="line">  <span class="number"> 42 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   3.3  0.0  16:21.24 [rcu_sched]                                                                                                           </span><br><span class="line">  <span class="number"> 57 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.7  0.0   1:03.01 [rcuos/14]                                                                                                            </span><br><span class="line">  <span class="number"> 63 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.3  0.0   0:29.22 [rcuos/20]                                                                                                            </span><br><span class="line"><span class="number"> 7933 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.3  0.0   0:05.50 [kworker/20:0]                                                                                                        </span><br><span class="line">11414 jenkins  <span class="number"> 20 </span> <span class="number"> 0 </span>42.134g 1.661g <span class="number"> 24516 </span>S   0.3  1.3   2:47.29 /etc/alternatives/java -Dcom.sun.akuma.Daemon=daemonized -Djava.awt.headless=true -DJENKINS_HOME=/var/lib/jenkins -j+ </span><br><span class="line">14702 root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.3  0.0   0:01.48 [kworker/2:0]                                                                                                         </span><br><span class="line">15098 root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.3  0.0   0:01.37 [kworker/6:2]                                                                                                         </span><br><span class="line">18465 txq      <span class="number"> 20 </span> <span class="number"> 0 </span><span class="number"> 158088 </span> <span class="number"> 2720 </span> <span class="number"> 1640 </span>R   0.3  0.0   0:00.18 top -c                                                                                                                </span><br><span class="line">   <span class="number"> 1 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span> <span class="number"> 45892 </span> <span class="number"> 8580 </span> <span class="number"> 3908 </span>S   0.0  0.0   0:13.78 /usr/lib/systemd/systemd --switched-root --system --deserialize<span class="number"> 21 </span>                                                   </span><br><span class="line">   <span class="number"> 2 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.06 [kthreadd]                                                                                                            </span><br><span class="line">   <span class="number"> 3 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.34 [ksoftirqd/0]                                                                                                         </span><br><span class="line">   <span class="number"> 5 </span>root      <span class="number"> 0 </span>-20      <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.00 [kworker/0:0H]                                                                                                        </span><br><span class="line">   <span class="number"> 8 </span>root      rt  <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.35 [migration/0]                                                                                                         </span><br><span class="line">   <span class="number"> 9 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.00 [rcu_bh]                                                                                                              </span><br><span class="line">  <span class="number"> 10 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.00 [rcuob/0]                                                                                                             </span><br><span class="line">  <span class="number"> 11 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.00 [rcuob/1]</span><br></pre></td></tr></table></figure><p>输入<code>q</code>是退出，还有其他命令参数，用到的时候再说，今天先统计这几个。</p><p>版权声明</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> cpu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NumPy 副本和视图</title>
      <link href="/2019/03/13/NumPy-%E5%89%AF%E6%9C%AC%E5%92%8C%E8%A7%86%E5%9B%BE/"/>
      <url>/2019/03/13/NumPy-%E5%89%AF%E6%9C%AC%E5%92%8C%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="NumPy-副本和视图"><a href="#NumPy-副本和视图" class="headerlink" title="NumPy 副本和视图"></a>NumPy 副本和视图</h1><p><strong>副本（赋值）</strong>是一个数据的完整的拷贝，如果我们对副本进行修改，它不会影响到原始数据，物理内存不在同一位置。</p><p><strong>视图（引用）</strong>是数据的一个别称或引用，通过该别称或引用亦便可访问、操作原有数据，但原有数据不会产生拷贝。如果我们对视图进行修改，它会影响到原始数据，物理内存在同一位置。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>视图（引用）一般发生在：</strong></p><ul><li>1、numpy 的切片操作返回原数据的视图。</li><li>2、调用 ndarray 的 view() 函数产生一个视图。</li></ul><p><strong>副本一般发生在：</strong></p><ul><li>Python 序列的切片操作，调用deepCopy()函数。</li><li>调用 ndarray 的 copy() 函数产生一个副本。</li></ul><h2 id="yaya-举例："><a href="#yaya-举例：" class="headerlink" title="yaya 举例："></a>yaya 举例：</h2><p><strong>视图（引用）一般发生在：</strong></p><ul><li>1、numpy 的切片操作返回原数据的视图。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>)  <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b = a[:]   <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">10</span>  <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line">print(a)   <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line"><span class="comment"># 修改b数据值，将修改原数据a的值</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>)  <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b = a[:]   <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b.shape = <span class="number">2</span>,<span class="number">3</span>  <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line">print(b)  </span><br><span class="line"><span class="comment"># [[0 1]</span></span><br><span class="line"><span class="comment">#  [2 3]</span></span><br><span class="line"><span class="comment">#  [4 5]]</span></span><br><span class="line">print(a)   <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line"><span class="comment"># 修改b数据形状，不会修改原数据a的形状</span></span><br></pre></td></tr></table></figure><ul><li>2、调用 ndarray 的 view() 函数产生一个视图。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>)  <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b = a.view()   <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">10</span>  <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line">print(a)   <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line"><span class="comment"># 修改b数据值，将修改原数据a的值</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>)  <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b = a[:]   <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b.shape = <span class="number">2</span>,<span class="number">3</span>  <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line">print(b)  </span><br><span class="line"><span class="comment"># [[0 1]</span></span><br><span class="line"><span class="comment">#  [2 3]</span></span><br><span class="line"><span class="comment">#  [4 5]]</span></span><br><span class="line">print(a)   <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line"><span class="comment"># 修改b数据形状，不会修改原数据a的形状</span></span><br></pre></td></tr></table></figure><p><strong>副本一般发生在：</strong></p><ul><li>Python 序列的切片操作，调用deepCopy()函数。</li><li>调用 ndarray 的 copy() 函数产生一个副本。</li></ul><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><h3 id="无复制-指向同一地址"><a href="#无复制-指向同一地址" class="headerlink" title="无复制 (指向同一地址)"></a>无复制 (指向同一地址)</h3><p>简单的赋值不会创建数组对象的副本。 相反，它使用原始数组的相同id()来访问它。 id()返回 Python 对象的通用标识符，类似于 C 中的指针。</p><p>此外，一个数组的任何变化都反映在另一个数组上。 例如，一个数组的形状改变也会改变另一个数组的形状。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np    </span><br><span class="line">a = np.arange(<span class="number">6</span>)   </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'我们的数组是：'</span>) </span><br><span class="line"><span class="keyword">print</span> (a) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'调用 id() 函数：'</span>) </span><br><span class="line"><span class="keyword">print</span> (id(a)) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'a 赋值给 b：'</span>) </span><br><span class="line">b = a  <span class="keyword">print</span> (b) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'b 拥有相同 id()：'</span>) </span><br><span class="line"><span class="keyword">print</span> (id(b)) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'修改 b 的形状：'</span>) </span><br><span class="line">b.shape =  <span class="number">3</span>,<span class="number">2</span>   </span><br><span class="line"><span class="keyword">print</span> (b) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'a 的形状也修改了：'</span>) </span><br><span class="line"><span class="keyword">print</span> (a)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">我们的数组是：</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">调用 id() 函数：</span><br><span class="line"><span class="number">4349302224</span></span><br><span class="line">a 赋值给 b：</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">b 拥有相同 id()：</span><br><span class="line"><span class="number">4349302224</span></span><br><span class="line">修改 b 的形状：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">a 的形状也修改了：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br></pre></td></tr></table></figure><h3 id="视图或浅拷贝"><a href="#视图或浅拷贝" class="headerlink" title="视图或浅拷贝"></a>视图或浅拷贝</h3><p>ndarray.view() 方会创建一个新的数组对象，该方法创建的新数组的维数更改不会更改原始数据的维数。但是修改新数组的数值将会更改原始数据的数值。</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  numpy  <span class="keyword">as</span>  np  </span><br><span class="line">a = np.arange(<span class="number">6</span>)  </span><br><span class="line"><span class="keyword">print</span>  (<span class="string">'我们的数组是：'</span>)  </span><br><span class="line"><span class="keyword">print</span>  (a)  </span><br><span class="line"><span class="keyword">print</span>  (<span class="string">'调用 id() 函数：'</span>)  </span><br><span class="line"><span class="keyword">print</span>  (id(a))  </span><br><span class="line"><span class="keyword">print</span>  (<span class="string">'a 赋值给 b：'</span>)  </span><br><span class="line">b = a  <span class="keyword">print</span>  (b)  </span><br><span class="line"><span class="keyword">print</span>  (<span class="string">'b 拥有相同 id()：'</span>)  </span><br><span class="line"><span class="keyword">print</span>  (id(b))  </span><br><span class="line"><span class="keyword">print</span>  (<span class="string">'修改 b 的形状：'</span>)  </span><br><span class="line">b.shape = <span class="number">3</span>,<span class="number">2</span>  </span><br><span class="line"><span class="keyword">print</span>  (b)  </span><br><span class="line"><span class="keyword">print</span>  (<span class="string">'a 的形状也修改了：'</span>)  </span><br><span class="line"><span class="keyword">print</span>  (a)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">数组 a：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">创建 a 的视图：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">两个数组的 id() 不同：</span><br><span class="line">a 的 id()：</span><br><span class="line"><span class="number">4314786992</span></span><br><span class="line">b 的 id()：</span><br><span class="line"><span class="number">4315171296</span></span><br><span class="line">b 的形状：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">a 的形状：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br></pre></td></tr></table></figure><p>使用切片创建视图修改数据会影响到原始数组：</p><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np   </span><br><span class="line">arr = np.arange(<span class="number">12</span>) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'我们的数组：'</span>) </span><br><span class="line"><span class="keyword">print</span> (arr) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'创建切片：'</span>) </span><br><span class="line">a=arr[<span class="number">3</span>:] </span><br><span class="line">b=arr[<span class="number">3</span>:] </span><br><span class="line">a[<span class="number">1</span>]=<span class="number">123</span> </span><br><span class="line">b[<span class="number">2</span>]=<span class="number">234</span> </span><br><span class="line">print(arr) </span><br><span class="line">print(id(a),id(b),id(arr[<span class="number">3</span>:]))</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我们的数组：</span><br><span class="line">[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br><span class="line">创建切片：</span><br><span class="line">[  <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span> <span class="number">123</span> <span class="number">234</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>]</span><br><span class="line"><span class="number">4545878416</span> <span class="number">4545878496</span> <span class="number">4545878576</span></span><br></pre></td></tr></table></figure><p>变量 a,b 都是 arr 的一部分视图，对视图的修改会直接反映到原数据中。但是我们观察 a,b 的 id，他们是不同的，也就是说，视图虽然指向原数据，但是他们和赋值引用还是有区别的。</p><h3 id="副本或深拷贝"><a href="#副本或深拷贝" class="headerlink" title="副本或深拷贝"></a>副本或深拷贝</h3><p>ndarray.copy() 函数创建一个副本。 对副本数据进行修改，不会影响到原始数据，它们物理内存不在同一位置。</p><h2 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np    </span><br><span class="line">a = np.array([[<span class="number">10</span>,<span class="number">10</span>],  [<span class="number">2</span>,<span class="number">3</span>],  [<span class="number">4</span>,<span class="number">5</span>]])   </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'数组 a：'</span>) </span><br><span class="line"><span class="keyword">print</span> (a) <span class="keyword">print</span> (<span class="string">'创建 a 的深层副本：'</span>) </span><br><span class="line">b = a.copy()   </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'数组 b：'</span>) </span><br><span class="line"><span class="keyword">print</span> (b) <span class="comment"># b 与 a 不共享任何内容   </span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">'我们能够写入 b 来写入 a 吗？'</span>) </span><br><span class="line"><span class="keyword">print</span> (b <span class="keyword">is</span> a) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'修改 b 的内容：'</span>) </span><br><span class="line">b[<span class="number">0</span>,<span class="number">0</span>]  =  <span class="number">100</span>   </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'修改后的数组 b：'</span>) </span><br><span class="line"><span class="keyword">print</span> (b) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'a 保持不变：'</span>) </span><br><span class="line"><span class="keyword">print</span> (a)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">数组 a：</span><br><span class="line">[[<span class="number">10</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>]]</span><br><span class="line">创建 a 的深层副本：</span><br><span class="line">数组 b：</span><br><span class="line">[[<span class="number">10</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>]]</span><br><span class="line">我们能够写入 b 来写入 a 吗？</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">修改 b 的内容：</span><br><span class="line">修改后的数组 b：</span><br><span class="line">[[<span class="number">100</span>  <span class="number">10</span>]</span><br><span class="line"> [  <span class="number">2</span>   <span class="number">3</span>]</span><br><span class="line"> [  <span class="number">4</span>   <span class="number">5</span>]]</span><br><span class="line">a 保持不变：</span><br><span class="line">[[<span class="number">10</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>]]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> numpy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python  面试</title>
      <link href="/2019/03/12/python-%E9%9D%A2%E8%AF%95/"/>
      <url>/2019/03/12/python-%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5b6bc1d16fb9a04f9c43edc3" target="_blank" rel="noopener">https://juejin.im/post/5b6bc1d16fb9a04f9c43edc3</a></p><p><a href="https://juejin.im/post/5b8505b6e51d4538884d22bf" target="_blank" rel="noopener">https://juejin.im/post/5b8505b6e51d4538884d22bf</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础： 深入理解 python 中的赋值、引用、拷贝、作用域</title>
      <link href="/2019/03/12/python%E5%9F%BA%E7%A1%80%EF%BC%9A-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-python-%E4%B8%AD%E7%9A%84%E8%B5%8B%E5%80%BC%E3%80%81%E5%BC%95%E7%94%A8%E3%80%81%E6%8B%B7%E8%B4%9D%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2019/03/12/python%E5%9F%BA%E7%A1%80%EF%BC%9A-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-python-%E4%B8%AD%E7%9A%84%E8%B5%8B%E5%80%BC%E3%80%81%E5%BC%95%E7%94%A8%E3%80%81%E6%8B%B7%E8%B4%9D%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="浅复制："><a href="#浅复制：" class="headerlink" title="浅复制："></a>浅复制：</h3><ul><li>仅复制对象的引用，而不开辟内存，即，改变复制后的对象时，其实是在改变原对象内存中的内容。</li><li>b = a[ : ]<h3 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a>深复制</h3>将开辟新的内存，把原对象内存中的内容复制到新的内存中来，如果改变复制后的对象，将改变原对象的内容。即，这两个对象在完成复制之后，已经是两个独立的对象了</li></ul><p><strong>- 转载： <a href="https://draapho.github.io/2016/11/21/1618-python-variable/" target="_blank" rel="noopener">https://draapho.github.io/2016/11/21/1618-python-variable/</a></strong></p><h3 id="可变对象：list-dict-set-（引用传递）"><a href="#可变对象：list-dict-set-（引用传递）" class="headerlink" title="可变对象：list dict set  （引用传递）"></a>可变对象：list dict set  （引用传递）</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta"># list</span></span><br><span class="line">a= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">9</span></span><br><span class="line"><span class="keyword">print</span>(b) <span class="meta"># [9, 2, 3]</span></span><br><span class="line"><span class="keyword">print</span>(a) <span class="meta"># [9, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># dict</span></span><br><span class="line">a = &#123;&#125;</span><br><span class="line">a['key1'] = <span class="number">1</span></span><br><span class="line">b = a</span><br><span class="line">b['key1'] = <span class="number">9</span></span><br><span class="line"><span class="keyword">print</span>(b) <span class="meta"># &#123;'key1': 9&#125;</span></span><br><span class="line"><span class="keyword">print</span>(a) <span class="meta"># &#123;'key1': 9&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]  </span><br><span class="line">values[<span class="number">1</span>] = values  </span><br><span class="line">values  </span><br><span class="line">[<span class="number">0</span>, [...], <span class="number">2</span>] # 实际结果, 为何要赋值无限次?  </span><br><span class="line">[<span class="number">0</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="number">2</span>] # 预想结果</span><br></pre></td></tr></table></figure><p>   Python 没有赋值，只有引用。你这样相当于创建了一个引用自身的结构，所以导致了无限循环</p><h3 id="不可变对象：tuple-string-int-float-bool-（值传递）"><a href="#不可变对象：tuple-string-int-float-bool-（值传递）" class="headerlink" title="不可变对象：tuple string int float bool （值传递）"></a>不可变对象：<strong><em>tuple</em></strong> string int float bool （值传递）</h3><p>对于可变对象，对象的操作不会重建对象，而对于不可变对象，每一次操作就重建新的对象。</p><pre><code>def func_int(a):    a += 4def func_list(a_list):    a_list[0] = 4t = 0func_int(t)print t# output: 0t_list = [1, 2, 3]func_list(t_list)print t_list# output: [4, 2, 3]</code></pre><h3 id="Dictionary-与-List-与-Tuple的区别"><a href="#Dictionary-与-List-与-Tuple的区别" class="headerlink" title="Dictionary 与 List 与 Tuple的区别"></a>Dictionary 与 List 与 Tuple的区别</h3><p>元组和列表在结构上没有什么区别，唯一的差异在于元组是只读的，不能修改。</p><p><strong>Dictionary</strong> </p><ol><li>Dictionary 是 Python 的内置数据类型之一, 它定义了键和值之间一对一的关系。</li><li>每一个元素都是一个 key-value 对, 整个元素集合用大括号括起来</li><li>您可以通过 key 来引用其值, 但是不能通过值获取 key</li><li>在一个 dictionary 中不能有重复的 key。给一个存在的 key 赋值会覆盖原有的值。 <a href="file:///home/echo/.chmsee/bookshelf/4791a2294b7b1d4cf68b0e1df606181d/native_data_types/index.html#odbchelper.dict.2.2" target="_blank" rel="noopener"><img src="file:///home/echo/.chmsee/bookshelf/4791a2294b7b1d4cf68b0e1df606181d/images/callouts/2.png" alt="2"></a> 在任何时候都可以加入新的 key-value 对。这种语法同修改存在的值是一样的。</li><li>当使用 dictionary 时, 您需要知道: dictionary 的 key 是大小写敏感的</li><li>Dictionary 不只是用于存储字符串。Dictionary 的值可以是任意数据类型, 包括字符串, 整数, 对象, 甚至其它的 dictionary。在单个 dictionary 里, dictionary 的值并不需要全都是同一数据类型, 可以根据需要混用和匹配。 Dictionary 的 key 要严格多了, 但是它们可以是字符串, 整数和几种其它的类型 (后面还会谈到这一点) 。也可以在一个 dictionary 中混用和配匹 key 的数据类型</li><li><code>del</code> 允许您使用 key 从一个 dictionary 中删除独立的元素。</li><li><code>clear</code> 从一个 dictionary 中清除所有元素。注意空的大括号集合表示一个没有元素的 dictionary。</li></ol><hr><p><strong>List</strong> </p><ol><li>list是一个使用方括号括起来的有序元素集合。</li><li>List 可以作为以 0 下标开始的数组。任何一个非空 list 的第一个元素总是 <code>li[0]</code></li><li><code>负数索引从 list 的尾部开始向前计数来存取元素。任何一个非空的 list 最后一个元素总是</code> li[-1]。 <a href="file:///home/echo/.chmsee/bookshelf/4791a2294b7b1d4cf68b0e1df606181d/native_data_types/lists.html#odbchelper.list.2.2" target="_blank" rel="noopener"><img src="file:///home/echo/.chmsee/bookshelf/4791a2294b7b1d4cf68b0e1df606181d/images/callouts/2.png" alt="2"></a>如果负数索引使您感到糊涂, 可以这样理解: <code>li[-n] == li[len(li) - n]</code>。 所以在这个 list 里, <code>li[-3] == li[5 - 3] == li[2]</code>。</li><li><code>您可以通过指定 2 个索引得到 list 的子集, 叫做一个 “slice” 。返回值是一个新的 list, 它包含了 list 中按顺序从第一个 slice 索引 (这里为</code> li[1]) 开始, 直到但是不包括第二个 slice 索引 (这里为<code>li[3]</code>) 的所有元素。</li><li><code>如果将两个分片索引全部省略, 这将包括 list 的所有元素。但是与原始的名为</code> li 的 list 不同, 它是一个新 list, 恰好拥有与 <code>li</code> 一样的全部元素。<code>li[:]</code> 是生成一个 list 完全拷贝的一个简写。</li><li><code>``append</code> 向 list 的末尾追加单个元素。</li><li><code>insert</code> 将单个元素插入到 list 中。数值参数是插入点的索引。请注意, list 中的元素不必唯一, 有有两个独立的元素具有 <code>&#39;new&#39;</code> 这个相同的值<code>。</code></li><li><code>extend</code> 用来连接 list。请注意不要使用多个参数来调用 <code>extend</code>, 要使用一个 list 参数进行调用。</li><li>Lists 的两个方法 <code>extend</code> 和 <code>append</code> 看起来类似, 但实际上完全不同。 <code>extend</code> 接受一个参数, 这个参数总是一个 list, 并且添加这个 list 中的每个元素到原 list 中</li><li>另一方面, <code>append</code> 接受一个参数, 这个参数可以是任何数据类型, 并且简单地追加到 list 的尾部。 在这里使用一个含有 3 个元素的 list 参数调用 <code>append</code> 方法。</li><li><code>index</code> 在 list 中查找一个值的首次出现并返回索引值。</li><li>要测试一个值是否在 list 内, 使用 <code>in</code>, 如果值存在, 它返回 <code>True</code>, 否则返为 <code>False</code> 。</li><li><code>remove</code> 从 list 中删除一个值的首次出现。</li><li><code>pop</code> 是一个有趣的东西。它会做两件事: 删除 list 的最后一个元素, 然后返回删除元素的值。请注意, 这与 <code>li[-1]</code> 不同, 后者返回一个值但不改变 list 本身。也不同于 <code>li.remove(*value*)</code>, 后者改变 list 但并不返回值。</li><li>Lists 也可以用 <code>+</code> 运算符连接起来。 <code>*list* = *list* + *otherlist*</code> 相当于 <code>*list*.extend(*otherlist*)</code>。 但 <code>+</code>运算符把一个新 (连接后) 的 list 作为值返回, 而 <code>extend</code> 只修改存在的 list。 也就是说, 对于大型 list 来说, <code>extend</code> 的执行速度要快一些。</li><li>Python 支持 <code>+=</code> 运算符。 <code>li += [&#39;two&#39;]</code> 等同于 <code>li.extend([&#39;two&#39;])</code>。 <code>+=</code> 运算符可用于 list, 字符串和整数, 并且它也可以被重载用于用户自定义的类中。</li><li><code>*</code> 运算符可以作为一个重复器作用于 list。 <code>li = [1, 2] * 3</code> 等同于 <code>li = [1, 2] + [1, 2] + [1, 2]</code>, 即将三个 list 连接成一个。</li></ol><hr><p><strong>Tuple</strong></p><ol><li>​    Tuple是不可变的list.一是创建了一个tuple就不能以任何方式改变它.</li><li>​    定义tuple与定义list的方式相同,除了整个元素集是用小括号包围的而不是方括号.</li><li>　 Tuple的元素与list一样按定义的次序进行排序.Tuples的索引与list一样从0开始,所以一个非空的tuple的第一个元素总是t[0].</li><li>​    负数索引与 list 一样从 tuple 的尾部开始计数。</li><li>​    与 list 一样分片 (slice) 也可以使用。注意当分割一个 list 时, 会得到一个新的 list ；当分割一个 tuple 时, 会得到一个新的 tuple。</li><li>​    Tuple 没有方法：没有 <code>append</code> 或 <code>extend</code> 方法、没有 <code>remove</code> 或 <code>pop</code> 方法、没有 <code>index</code> 方法、可以使用 <code>in</code> 来查看一个元素是否存在于 tuple 中。</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(LSTM_TSA)Video Captioning with Transferred Semantic Attributes</title>
      <link href="/2019/03/03/LSTM-TSA-Video-Captioning-with-Transferred-Semantic-Attributes/"/>
      <url>/2019/03/03/LSTM-TSA-Video-Captioning-with-Transferred-Semantic-Attributes/</url>
      
        <content type="html"><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>在这篇文章中，我们提出了一个 Long Short-Term Memory with Transferred Semantic Attributes （LSTM-TSA）model，这是一个新颖的结构，可以将从images 和 videos 中学习到的transferred semantic attributes  结合到 encoder - decoder 结构中去。</p>]]></content>
      
      
      <categories>
          
          <category> 视频描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频描述 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytorch-Multi-Gpus</title>
      <link href="/2019/03/02/pytorch-Multi-Gpus/"/>
      <url>/2019/03/02/pytorch-Multi-Gpus/</url>
      
        <content type="html"><![CDATA[<ul><li>源为pytorch的官方文档</li><li><a href="https://pytorch.org/tutorials/beginner/blitz/data_parallel_tutorial.html" target="_blank" rel="noopener">website</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset, DataLoader</span><br><span class="line"></span><br><span class="line"><span class="comment"># Parameters and DataLoaders</span></span><br><span class="line">input_size = <span class="number">5</span></span><br><span class="line">output_size = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">30</span></span><br><span class="line">data_size = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="comment"># Our model</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_size, output_size)</span>:</span></span><br><span class="line">        super(Model, self).__init__()</span><br><span class="line">        self.fc = nn.Linear(input_size, output_size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, input)</span>:</span></span><br><span class="line">        output = self.fc(input)</span><br><span class="line">        print(<span class="string">"\tIn Model: input size"</span>, input.size(),</span><br><span class="line">              <span class="string">"output size"</span>, output.size())</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomDataset</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, size, length)</span>:</span></span><br><span class="line">        self.len = length</span><br><span class="line">        self.data = torch.randn(length, size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.data[index]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.len</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rand_loader = DataLoader(dataset=RandomDataset(input_size, data_size), batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">model = Model(input_size, output_size)</span><br><span class="line"><span class="keyword">if</span> torch.cuda.device_count() &gt; <span class="number">1</span>:</span><br><span class="line">    print(<span class="string">"Let's use"</span>, torch.cuda.device_count(), <span class="string">"GPUs!"</span>)</span><br><span class="line">    <span class="comment"># dim = 0 [30, xxx] -&gt; [10, ...], [10, ...], [10, ...] on 3 GPUs</span></span><br><span class="line">    model = nn.DataParallel(model)</span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">"cuda:0"</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line">model.to(device)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> rand_loader:</span><br><span class="line">    input = data.to(device)</span><br><span class="line">    output = model(input)</span><br><span class="line">    print(<span class="string">"Outside: input size"</span>, input.size(),</span><br><span class="line">          <span class="string">"output_size"</span>, output.size())</span><br></pre></td></tr></table></figure><h2 id="转载：-PyTorch-论文pytorch复现中遇到的BUG-https-www-cnblogs-com-kk17-p-10139884-html"><a href="#转载：-PyTorch-论文pytorch复现中遇到的BUG-https-www-cnblogs-com-kk17-p-10139884-html" class="headerlink" title="转载：[[PyTorch]论文pytorch复现中遇到的BUG]](https://www.cnblogs.com/kk17/p/10139884.html)"></a>转载：[[PyTorch]论文pytorch复现中遇到的BUG]](<a href="https://www.cnblogs.com/kk17/p/10139884.html" target="_blank" rel="noopener">https://www.cnblogs.com/kk17/p/10139884.html</a>)</h2><ul><li>我在Multi-GPUs时，也遇到了第一个问题</li></ul><p>目录</p><ul><li><a href="https://www.cnblogs.com/kk17/p/10139884.html#zip-argument-1-must-support-iteration" target="_blank" rel="noopener">1. zip argument #1 must support iteration</a></li><li><a href="https://www.cnblogs.com/kk17/p/10139884.html#torch.nn.dataparallel" target="_blank" rel="noopener">2. torch.nn.DataParallel</a></li><li><a href="https://www.cnblogs.com/kk17/p/10139884.html#model.state_dict" target="_blank" rel="noopener">3. model.state_dict()</a></li></ul><h1 id="1-zip-argument-1-must-support-iteration"><a href="#1-zip-argument-1-must-support-iteration" class="headerlink" title="1. zip argument #1 must support iteration"></a>1. zip argument #1 must support iteration</h1><p>在多gpu训练的时候，自动把你的batch_size分成n_gpu份，每个gpu跑一些数据， 最后再合起来。我之所以出现这个bug是因为返回的时候 返回了一个常量。。</p><h1 id="2-torch-nn-DataParallel"><a href="#2-torch-nn-DataParallel" class="headerlink" title="2. torch.nn.DataParallel"></a>2. torch.nn.DataParallel</h1><p>在使用torch.nn.DataParallel时候，要先把模型放在gpu上，再进行parallel。</p><h1 id="3-model-state-dict"><a href="#3-model-state-dict" class="headerlink" title="3. model.state_dict()"></a>3. model.state_dict()</h1><p>一般在现有的网络加载预训练模型通常是找到预训练模型在现有的model里面的参数，然后model进行更新，遇到一个bug， 发现加载预训练模型的时候， 效果很差，跟参数没有更新一样，找了一大顿bug，最后才发现，之前是单gpu进行的预训练，现在的模型使用的是多gpu， 打印现在模型的参数你会发现他所有的参数前面都加了一个module. 所以向以前一样更新，没有一个参数会被更新，因此写了一个万能模型参数加载函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pretrained_dict = checkpoint[<span class="string">'state_dict'</span>]</span><br><span class="line">model_dict = self.model.state_dict()</span><br><span class="line"><span class="keyword">if</span> checkpoint[<span class="string">'config'</span>][<span class="string">'n_gpu'</span>] &gt; <span class="number">1</span> <span class="keyword">and</span> self.config[<span class="string">'n_gpu'</span>] == <span class="number">1</span>:</span><br><span class="line">    new_dict = OrderedDict()</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> pretrained_dict.items():</span><br><span class="line">        name = k[<span class="number">7</span>:]</span><br><span class="line">        new_dict[name] = v</span><br><span class="line">    pretrained_dict = new_dict</span><br><span class="line"><span class="keyword">elif</span> checkpoint[<span class="string">'config'</span>][<span class="string">'n_gpu'</span>] == <span class="number">1</span> <span class="keyword">and</span> self.config[<span class="string">'n_gpu'</span>] &gt; <span class="number">1</span>:</span><br><span class="line">    new_dict = OrderedDict()</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> pretrained_dict.items():</span><br><span class="line">        name = <span class="string">"module."</span>+k</span><br><span class="line">        new_dict[name] = v</span><br><span class="line">    pretrained_dict = new_dict</span><br><span class="line">print(<span class="string">"The pretrained model's para is following"</span>)</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> pretrained_dict.items():</span><br><span class="line">    print(k)</span><br><span class="line">pretrained_dict = &#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> pretrained_dict.items() <span class="keyword">if</span> k <span class="keyword">in</span> model_dict&#125;</span><br><span class="line">model_dict.update(pretrained_dict)</span><br><span class="line">self.model.load_state_dict(model_dict)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>coco-detection</title>
      <link href="/2019/03/02/coco-detection/"/>
      <url>/2019/03/02/coco-detection/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spatio-Temporal Dynamics and Semantic Attribute Enriched Visual Encoding for Video Captioning</title>
      <link href="/2019/03/01/Spatio-Temporal-Dynamics-and-Semantic-Attribute-Enriched-Visual-Encoding-for-Video-Captioning/"/>
      <url>/2019/03/01/Spatio-Temporal-Dynamics-and-Semantic-Attribute-Enriched-Visual-Encoding-for-Video-Captioning/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>nltk-tokenize</title>
      <link href="/2019/02/28/nltk-tokenize/"/>
      <url>/2019/02/28/nltk-tokenize/</url>
      
        <content type="html"><![CDATA[<p>转载：<a href="https://pythonprogramming.net/tokenizing-words-sentences-nltk-tutorial/" target="_blank" rel="noopener">https://pythonprogramming.net/tokenizing-words-sentences-nltk-tutorial/</a></p><p>Next, you’re going to need NLTK 3. The easiest method to installing the NLTK module is going to be with pip.</p><p>For all users, that is done by opening up cmd.exe, bash, or whatever shell you use and typing:<br><code>pip install nltk</code></p><p>These are the words you will most commonly hear upon entering the Natural Language Processing (NLP) space, but there are many more that we will be covering in time. With that, let’s show an example of how one might actually tokenize something into tokens with the NLTK module.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from nltk<span class="selector-class">.tokenize</span> import sent_tokenize, word_tokenize</span><br><span class="line"></span><br><span class="line">EXAMPLE_TEXT = <span class="string">"Hello Mr. Smith, how are you doing today? The weather is great, and Python is awesome. The sky is pinkish-blue. You shouldn't eat cardboard."</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(sent_tokenize(EXAMPLE_TEXT)</span></span>)</span><br></pre></td></tr></table></figure><p>At first, you may think tokenizing by things like words or sentences is a rather trivial enterprise. For many sentences it can be. The first step would be likely doing a simple .split(‘. ‘), or splitting by period followed by a space. Then maybe you would bring in some <a href="https://pythonprogramming.net/regular-expressions-regex-tutorial-python-3/" target="_blank" rel="noopener"><strong>regular expressions</strong></a> to split by period, space, and then a capital letter. The problem is that things like Mr. Smith would cause you trouble, and many other things. Splitting by word is also a challenge, especially when considering things like concatenations like we and are to we’re. NLTK is going to go ahead and just save you a ton of time with this seemingly simple, yet very complex, operation.</p><p>The above code will output the sentences, split up into a list of sentences, which you can do things like iterate through with a <a href="https://pythonprogramming.net/loop-python-3-basics-tutorial/" target="_blank" rel="noopener"><strong>for loop</strong></a>.<br><code>[&#39;Hello Mr. Smith, how are you doing today?&#39;, &#39;The weather is great, and Python is awesome.&#39;, &#39;The sky is pinkish-blue.&#39;, &quot;You shouldn&#39;t eat cardboard.&quot;]</code></p><p>So there, we have created tokens, which are sentences. Let’s tokenize by word instead this time:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="name">word_tokenize</span>(<span class="name">EXAMPLE_TEXT</span>))</span><br></pre></td></tr></table></figure><p>Now our output is: <code>[&#39;Hello&#39;, &#39;Mr.&#39;, &#39;Smith&#39;, &#39;,&#39;, &#39;how&#39;, &#39;are&#39;, &#39;you&#39;, &#39;doing&#39;, &#39;today&#39;, &#39;?&#39;, &#39;The&#39;, &#39;weather&#39;, &#39;is&#39;, &#39;great&#39;, &#39;,&#39;, &#39;and&#39;, &#39;Python&#39;, &#39;is&#39;, &#39;awesome&#39;, &#39;.&#39;, &#39;The&#39;, &#39;sky&#39;, &#39;is&#39;, &#39;pinkish-blue&#39;, &#39;.&#39;, &#39;You&#39;, &#39;should&#39;, &quot;n&#39;t&quot;, &#39;eat&#39;, &#39;cardboard&#39;, &#39;.&#39;]</code></p><p>There are a few things to note here. First, notice that punctuation is treated as a separate token. Also, notice the separation of the word “shouldn’t” into “should” and “n’t.” Finally, notice that “pinkish-blue” is indeed treated like the “one word” it was meant to be turned into. Pretty cool!</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Maxout Networks</title>
      <link href="/2019/02/27/Maxout-Networks/"/>
      <url>/2019/02/27/Maxout-Networks/</url>
      
        <content type="html"><![CDATA[<p>本文是蒙特利尔大学信息与信息技术学院的几位大牛2013年在ICML上发表的一篇论文，提出了一种叫maxout的新模型，到目前用的比较少，可能这个算法参数个数会成k倍增加(k是maxout的一个参数)。文中提到这样命名的原因：（1）它的输出是一组输入的最大值（2）它与dropout是天然的组合。</p><p>文章首先肯定了dropout的意义，从音频分类到超大规模物体识别都有很好的改进，同时提出不应该把dropout作为一个适用于任意模型的轻微性能增强，而是通过直接设计一个模型来提高dropout能力，作为模型平均技术，可以获得最好的性能。</p><p>Dropout：</p><ul><li>dropout可以训练集成模型，它们共享参数并近似的对这些模型的预测进行了平均。它可以被当作一种通用的方法用在任何一种MLP和CNN模型中，但是在论文中，由于dropout的模型平均过程没有被证明，因而一个模型最好的性能的获得，应该通过直接设计这个模型使之可以增强dropout的模型平均的能力。使用了dropout的训练过程和一般的SGD方法完全不同。dropout在更新时使用更大的步长最有效，因为这样可以在不同的训练子集上对不同的模型有明显的影响来使得目标函数有持续的波动性，理想情况下整个训练过程就类似于使用bagging来训练集成的模型（带有参数共享的约束）。而一般的SGD更新时会使用更小的步长，来使得目标函数平滑的下降。对于深度网络模型，dropout只能作为模型平均的一种近似，显式的设计模型来最小化这种近似误差也可以提高dropout的性能。</li><li>dropout训练的集成模型中，所有模型都只包括部分输入和部分隐层参数。对每一个训练样本，我们都会训练一个包括不同隐层参数的子模型。dropout与bagging的相同点是不同的模型使用不同数据子集，不同点是dropout的每个模型都只训练一次且所有模型共享参数。</li><li>对于预测时如何平均所有子模型的问题，bagging一般使用的是算数平均，而对dropout产生的指数多个子模型则并非显而易见。但是如果模型只有一层 <img src="https://www.zhihu.com/equation?tex=p%28y+%7C+v%3B%CE%B8%29%3Dsoftmax%28v%5E%7BT%7D%2Bb%29" alt="p(y | v;θ)=softmax(v^{T}+b)">作为输出（p(y | v;θ)的几何平均），则最终的预测分布就是简单的 <img src="https://www.zhihu.com/equation?tex=softmax%28v%5E%7BT%7DW%2F2%2Bb%29" alt="softmax(v^{T}W/2+b)">，即指数多个子模型的平均预测就是完整模型的预测仅仅将权重减半而已。这个结果只能用在单softmax层的模型中，如果是深层模型如MLP，那么权重减半的方法只是几何平均的一种近似。</li></ul><p>Maxout是深度学习网络中的一层网络，就像池化层、卷积层一样等，我们可以把maxout 看成是网络的激活函数层。我们假设网络某一层的输入特征向量为：X=（x1,x2,……xd），也就是我们输入是d个神经元。Maxout隐藏层每个神经元的计算公式如下：</p><p><img src="https://www.zhihu.com/equation?tex=h_%7Bi%7D%3D%5Cmax_%7Bj+%5Cin+%5B1%2Ck%5D%7D%7Bz_%7Bij%7D%7D" alt="h_{i}=\max_{j \in [1,k]}{z_{ij}}"></p><p>上面的公式就是maxout隐藏层神经元i的计算公式。其中，k就是maxout层所需要的参数了，由我们人为设定大小。就像dropout一样，也有自己的参数p(每个神经元dropout概率)，maxout的参数是k。公式中Z的计算公式为： <img src="https://www.zhihu.com/equation?tex=z_%7Bij%7D%3Dx%5E%7BT%7DW_%7B..ij%7D%2Bb_%7Bij%7D" alt="z_{ij}=x^{T}W_{..ij}+b_{ij}"> ，权重w是一个大小为(d,m,k)三维矩阵，b是一个大小为(m,k)的二维矩阵，这两个就是我们需要学习的参数。如果我们设定参数k=1，那么这个时候，网络就类似于以前我们所学普通的MLP网络。</p><p>我们可以这么理解，本来传统的MLP算法在第i层到第i+1层，参数只有一组，然而现在我们不怎么干了，我们在这一层同时训练n组参数，然后选择激活值最大的作为下一层神经元的激活值。下面还是用一个例子进行讲解，比较容易搞懂。</p><p>（1）以前MLP的方法。<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0ldm6b5ujj30ix08mdg0.jpg"></p><p>其中 f 就是我们所谓的激活函数，比如Sigmod、Relu、Tanh等。</p><p>(2)Maxout 的方法。如果我们设置maxout的参数k=5，maxout层就如下所示：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0ldmxgg2zj30n60e33zh.jpg"></p><p>相当于在每个输出神经元前面又多了一层。这一层有5个神经元。<br>所以这就是为什么采用maxout的时候，参数个数成k倍增加的原因。本来我们只需要一组参数就够了，采用maxout后，就需要有k组参数。</p><ul><li>对MLP而言，2个输入节点先构成5个“隐隐层”节点，然后在5个“隐隐层”节点中使用最大的构成了本层的一个节点，本层其他节点类似。<strong>实现技巧：</strong><code>maxout</code>和<code>relu</code>唯一的区别是，<code>relu</code>使用的max(x,0)是对隐层每一个单元执行的与0比较最大化操作，而<code>maxout</code>是对5个“隐隐层”单元的值执行最大化操作。如果将“隐隐层”单元在隐层展开，那么隐层就有20个“隐隐层”单元，<code>maxout</code>做的就是在这20个中每5个取一个最大值作为最后的隐层单元，最后的隐层单元仍然为4个。这里每5个取一个最大值也称为最大池化步长（max pooling stride）为5，最大池化步长默认和“隐隐层”个数相等，如果步长更小，则可以实现重叠最大池化。实现的时候，可以将隐层单元数设置为20个，权重维度（2，20）偏置维度（1，20），然后在20个中每5个取一个最大值得到4个隐层单元。</li><li>对于CNN而言，假设上一层有2个特征图，本层有4个特征图，那么就是将输入的2个特征图用5个滤波器卷积得到5张仿射特征图（affine feature maps），然后从这5张仿射特征图每个位置上选择最大值（跨通道池化，pool across channels）构成一张本层的特征图，本层其他特征图类似。<strong>实现技巧：</strong><code>relu</code>使用的max(x,0)是对每个通道的特征图的每一个单元执行的与0比较最大化操作，而<code>maxout</code>是对5个通道的特征图在通道的维度上执行最大化操作。而如果把5个特征图在本层展开，那么本层就有20个特征图，<code>maxout</code>做的就是在这20个中每5个取在通道维度上的最大值作为最后的特征图，最后本层特征图仍然为4个。同样最大池化步长默认为5。实现的时候，可以将本层特征图数设置为20个，权重维度（20，2，3，3）偏置维度（1，20，1，1），然后在20个中每5个取一个最大特征图得到4个特征图。<strong>注意：</strong> 对于CNN而言，在maxout输出后如果连接一个一般的降采样最大池化层，则可以将这个降采样最大池化融合进跨通道池化中，即在仿射特征图的每个池化窗口中选择最大值（相当于同时在通道间和空间取最大值）。这样就可以在maxout网络中省略显式的降采样最大池化层。</li></ul><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><ol><li>MNIST</li></ol><p>排列不变限制的MNIST（MNIST with permutation invariant，即像素排列顺序可以改变，输入的数据是2维的），使用两个全连接maxout层再接上一个softmax层，结合dropout和权重衰减。验证集选取训练集中后10000个样本。在得到最小的验证集误差时记录下前50000个样本的训练集对数似然L，接着在整个60000样本的训练集上<strong>继续训练</strong>直到验证集的对数似然达到L。<em>0.94%</em></p><p>无排列不变限制的MNIST（MNIST without permutation invariant，即像素排列顺序不变，输入的数据是3维的），使用三个卷积maxout层，之后接上空间最大池化层，最后接上一个softmax层。还可以使用扩充数据集的方法进一步提高。<em>0.45%</em></p><p>\2. CIFAR-10</p><p>预处理：全局像素归一化和ZCA白化</p><p>过程与MNIST类似，只是将继续训练改为了<strong>重新训练</strong>，因为继续训练的学习率很低训练太久。</p><p>使用三个卷积maxout层，之后接上全连接maxout层，最后接上一个softmax层。<em>13.2%</em>（不使用验证集数据）<em>11.68%</em>（使用验证集数据）<em>9.35%</em>（使用平移、水平翻转的扩充数据集）</p><p>\3. CIFAR-100</p><p>超参数使用和CIFAR-10一样</p><p><em>41.48%</em>（不使用验证集数据）<em>38.57%</em>（使用验证集数据）</p><p>\4. SVHN</p><p>验证集为训练集每类选取400个样本和额外集每类选取200个样本，其他的为训练集。</p><p>预处理：局部像素归一化</p><p>使用三个卷积maxout层，之后接上全连接maxout层，最后接上一个softmax层（同CIFAR-10）。<em>2.47%</em></p><h2 id="maxout对比relu"><a href="#maxout对比relu" class="headerlink" title="maxout对比relu"></a>maxout对比relu</h2><ul><li>跨通道池化可以减少网络状态并减少模型所需要的参数。</li><li>对于maxout，性能与跨通道池化时滤波器数量有很大关系，但对relu，性能与输出单元的数量没有关系，也就是relu并不从跨通道池化中受益。</li><li>要让relu达到maxout的表现，需要使之具有和maxout相同数量的滤波器（即使用比原来k倍的滤波器，同样也要k倍的relu单元），但网络状态和所需要的参数也是原来的k倍，也是对应maxout的k倍。</li></ul><h2 id="模型平均"><a href="#模型平均" class="headerlink" title="模型平均"></a>模型平均</h2><ul><li>单层softmax有对模型进行平均的能力，但是通过观察，多层模型中使用dropout也存在这样的模型平均，只是有拟合精度的问题。</li><li>训练中使用dropout使得maxout单元有了更大的输入附近的线性区域，因为每个子模型都要预测输出，每个maxout单元就要学习输出相同的预测而不管哪些输入被丢弃。改变dropout mask将经常明显移动有效输入，从而决定了输入被映射到分段线性函数的哪一段。使用dropout训练的maxout具有一种特性，即当dropout mask改变时每个maxout单元的最大化滤波器相对很少变化。</li><li>maxout网络中的线性和最大化操作可以让dropout的拟合模型平均的精度很高。而一般的激活函数几乎处处都是弯曲的，因而dropout的拟合模型平均的精度不高。</li></ul><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ul><li>训练中使用dropout时，maxout的优化性能比relu+max pooling好</li><li>dropout使用更大的步长最有效，使得目标函数有持续的波动性。而一般的SGD会使用更小的步长，来使得目标函数平滑的下降。dropout快速的探索着许多不同的方向然后拒绝那些损害性能的方向，而SGD缓慢而平稳的朝向最可能的方向移动。</li><li>实验中SGD使得relu饱和在0值的时间少于5%，而dropout则超过60%。由于relu激活函数中的0值是一个常数，这就会阻止梯度在这些单元上传播（无论正向还是反向），这也就使得这些单元很难再次激活，这会导致很多单元由激活转变为非激活。而maxout就不会存在这样的问题，梯度在maxout单元上总是能够传播，即使maxout出现了0值，但是这些0值是参数的函数可以被改变，从而maxout单元总是激活的。单元中较高比例的且不易改变的0值会损害优化性能。</li><li>dropout要求梯度随着dropout mask的改变而明显改变，而一旦梯度几乎不随着dropout mask的改变而改变时，dropout就简化成为了SGD。relu网络的低层部分会有梯度衰减的问题（梯度的方差在高层较大而反向传播到低层后较小）。maxout更好的将变化的信息反向传播到低层并帮助dropout以类似bagging的方式训练低层参数。relu则由于饱和使得梯度损失，导致dropout在低层的训练类似于一般的SGD。</li></ul><h2 id="总结文中的点"><a href="#总结文中的点" class="headerlink" title="总结文中的点"></a>总结文中的点</h2><ul><li>单个<code>maxout</code>激活函数可以理解成一种分段线性函数来近似任意凸函数（任意的凸函数都可由分段线性函数来拟合）。它在每处都是局部线性的（k个“隐隐层”节点都是线性的，取其最大值则为局部线性，分段的个数与k值有关），而一般的激活函数都有明显的曲率。</li><li>如同MLP一样，maxout网络也可以拟合任意连续函数。只要<code>maxout</code>单元含有任意多个“隐隐层”节点，那么只要两个隐层的maxout网络就可以实现任意连续函数的近似。</li><li>maxout网络不仅可以学习到隐层之间的关系，还可以学习到每个隐层单元的激活函数。</li><li>maxout放弃了传统激活函数的设计，它产生的表示不再是稀疏的，但是它的梯度是稀疏的，且dropout可以将它稀疏化。</li><li>maxout没有上下界，所以让它在某一端饱和是零概率事件。</li><li>如果训练时使用dropout，则dropout操作在矩阵相乘之前，而并不对<code>max</code>操作的输入执行dropout。</li><li>使用maxout会默认一个先验：样本集是凸集可分的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python:理解 yield 关键字</title>
      <link href="/2019/02/25/Python-%E7%90%86%E8%A7%A3-yield-%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2019/02/25/Python-%E7%90%86%E8%A7%A3-yield-%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<pre><code>转载：https://liam.page/2017/06/30/understanding-yield-in-python/</code></pre><h1 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h1><p>为了理解<a href="https://github.com/sususushi/reconstruction-network-for-video-captioning" target="_blank" rel="noopener">reconstruction-network</a> 代码中，如下代码是如何实现的，查看了此篇博客，并转载。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cycle</span><span class="params">(iterable)</span>:</span>  </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> iterable:  </span><br><span class="line">            <span class="keyword">yield</span> x</span><br><span class="line"></span><br><span class="line">train_data_loader = iter(cycle(MSVD.train_data_loader))</span><br><span class="line"><span class="keyword">for</span> iteration, batch <span class="keyword">in</span> enumerate(train_data_loader, <span class="number">1</span>):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> iteration == C.train_n_iteration:  </span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>解释：<strong>iter()</strong> 是python的一个函数，用来生成迭代器。而cycle中一整个for循环是对整个数据集调用一遍，而外部又有一个while true，该判断是一直成立的，则，会一直调用数据。因此此处不适用n_epoch 来停止加载数据，而是使用train_n_iteration。</p><hr><p>Python 是非常灵活的语言，其中 <code>yield</code> 关键字是普遍容易困惑的概念。</p><p>此篇将介绍 <code>yield</code> 关键字，及其相关的概念。</p><h2 id="迭代、可迭代、迭代器"><a href="#迭代、可迭代、迭代器" class="headerlink" title="迭代、可迭代、迭代器"></a>迭代、可迭代、迭代器</h2><h3 id="迭代（iteration）与可迭代（iterable）"><a href="#迭代（iteration）与可迭代（iterable）" class="headerlink" title="迭代（iteration）与可迭代（iterable）"></a>迭代（iteration）与可迭代（iterable）</h3><blockquote><p>迭代是一种操作；可迭代是对象的一种特性。</p></blockquote><p>很多数据都是「容器」；它们包含了很多其他类型的元素。实际使用容器时，我们常常需要逐个获取其中的元素。<strong>逐个获取元素的过程，就是「迭代」</strong>。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iteration</span></span><br><span class="line">a_list = [1, 2, 3]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a_list:</span><br><span class="line">    <span class="builtin-name">print</span>(i)</span><br></pre></td></tr></table></figure><p>如果我们可以从一个对象中，逐个地获取元素，那么我们就说这个对象是「可迭代的」。</p><p>Python 中的顺序类型，都是可迭代的（<code>list</code>, <code>tuple</code>, <code>string</code>）。其余包括 <code>dict</code>, <code>set</code>, <code>file</code> 也是可迭代的。对于用户自己实现的类型，如果提供了 <code>__iter__()</code> 或者 <code>__getitem__()</code> 方法，那么该类的对象也是可迭代的。</p><h3 id="迭代器（iterator）"><a href="#迭代器（iterator）" class="headerlink" title="迭代器（iterator）"></a>迭代器（iterator）</h3><blockquote><p>迭代器是一种对象。</p></blockquote><p>迭代器抽象的是一个「数据流」，是只允许迭代一次的对象。对迭代器不断调用 <code>next()</code> 方法，则可以依次获取下一个元素；当迭代器中没有元素时，调用 <code>next()</code> 方法会抛出 <code>StopIteration</code> 异常。迭代器的 <code>__iter__()</code> 方法返回迭代器自身；因此迭代器也是可迭代的。</p><h3 id="迭代器协议（iterator-protocol）"><a href="#迭代器协议（iterator-protocol）" class="headerlink" title="迭代器协议（iterator protocol）"></a>迭代器协议（iterator protocol）</h3><blockquote><p>迭代器协议指的是容器类需要包含一个特殊方法。</p></blockquote><p>如果一个容器类提供了 <code>__iter__()</code> 方法，并且该方法能返回一个能够逐个访问容器内所有元素的迭代器，则我们说该容器类实现了迭代器协议。</p><p>Python 中的迭代器协议和 Python 中的 <code>for</code> 循环是紧密相连的。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">iterator</span> protocol <span class="keyword">and</span> <span class="keyword">for</span> <span class="keyword">loop</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> something:</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure><p>Python 处理 <code>for</code> 循环时，首先会调用内建函数 <code>iter(something)</code>，它实际上会调用 <code>something.__iter__()</code>，返回 <code>something</code> 对应的迭代器。而后，<code>for</code> 循环会调用内建函数 <code>next()</code>，作用在迭代器上，获取迭代器的下一个元素，并赋值给 <code>x</code>。此后，Python 才开始执行循环体。</p><h2 id="生成器、yield-表达式"><a href="#生成器、yield-表达式" class="headerlink" title="生成器、yield 表达式"></a>生成器、<code>yield</code> 表达式</h2><h3 id="生成器函数（generator-function）和生成器（generator）"><a href="#生成器函数（generator-function）和生成器（generator）" class="headerlink" title="生成器函数（generator function）和生成器（generator）"></a>生成器函数（generator function）和生成器（generator）</h3><blockquote><p>生成器函数是一种特殊的函数；生成器则是特殊的迭代器。</p></blockquote><p>如果一个函数包含 <code>yield</code> 表达式，那么它是一个生成器函数；调用它会返回一个特殊的迭代器，称为生成器。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def <span class="built_in">func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">def <span class="built_in">gen</span>():</span><br><span class="line">    yield <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>(<span class="built_in">type</span>(func))   <span class="meta"># &lt;class 'function'&gt;</span></span><br><span class="line"><span class="keyword">print</span>(<span class="built_in">type</span>(gen))    <span class="meta"># &lt;class 'function'&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>(<span class="built_in">type</span>(<span class="built_in">func</span>())) <span class="meta"># &lt;class 'int'&gt;</span></span><br><span class="line"><span class="keyword">print</span>(<span class="built_in">type</span>(<span class="built_in">gen</span>()))  <span class="meta"># &lt;class 'generator'&gt;</span></span><br></pre></td></tr></table></figure><p>如上，生成器 <code>gen</code> 看起来和普通的函数没有太大区别。仅只是将 <code>return</code> 换成了 <code>yield</code>。用 <code>type()</code> 函数打印二者的类型也能发现，<code>func</code> 和 <code>gen</code> 都是函数。然而，二者的返回值的类型就不同了。<code>func()</code> 是一个 <code>int</code> 类型的对象；而 <code>gen()</code> 则是一个迭代器对象。</p><h3 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield 表达式"></a><code>yield</code> 表达式</h3><p>如前所述，如果一个函数定义中包含 <code>yield</code> 表达式，那么该函数是一个生成器函数（而非普通函数）。实际上，<code>yield</code> 仅能用于定义生成器函数。</p><p>与普通函数不同，生成器函数被调用后，其函数体内的代码并不会立即执行，而是返回一个生成器（generator-iterator）。当返回的生成器调用成员方法时，相应的生成器函数中的代码才会执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">yield</span> x ** <span class="number">2</span></span><br><span class="line">square_gen = square()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> square_gen:</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure><p>前面说到，<code>for</code> 循环会调用 <code>iter()</code> 函数，获取一个生成器；而后调用 <code>next()</code> 函数，将生成器中的下一个值赋值给 <code>x</code>；再执行循环体。因此，上述 <code>for</code> 循环基本等价于：</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">genitor = square_gen.__iter__()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    x = geniter.<span class="keyword">next</span>()<span class="meta"> # Python 3 是 __next__()</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>注意到，<code>square</code> 是一个生成器函数；作为它的返回值，<code>square_gen</code> 已经是一个迭代器；迭代器的 <code>__iter__()</code> 返回它自己。因此 <code>geniter</code> 对应的生成器函数，即是 <code>square</code>。</p><p>每次执行到 <code>x = geniter.next()</code> 时，<code>square</code> 函数会从上一次暂停的位置开始，一直执行到下一个 <code>yield</code> 表达式，将 <code>yield</code> 关键字后的表达式列表返回给调用者，并再次暂停。注意，<strong>每次从暂停恢复时，生成器函数的内部变量、指令指针、内部求值栈等内容和暂停时完全一致</strong>。</p><h3 id="生成器的方法"><a href="#生成器的方法" class="headerlink" title="生成器的方法"></a>生成器的方法</h3><p>生成器有一些方法。调用这些方法可以控制对应的生成器函数；不过，若是生成器函数已在执行过程中，调用这些方法则会抛出 <code>ValueError</code> 异常。</p><ul><li><code>generator.next()</code>：从上一次在 <code>yield</code> 表达式暂停的状态恢复，继续执行到下一次遇见 <code>yield</code> 表达式。当该方法被调用时，当前 <code>yield</code> 表达式的值为 <code>None</code>，下一个 <code>yield</code> 表达式中的表达式列表会被返回给该方法的调用者。若没有遇到 <code>yield</code> 表达式，生成器函数就已经退出，那么该方法会抛出 <code>StopIterator</code> 异常。</li><li><code>generator.send(value)</code>：和 <code>generator.next()</code> 类似，差别仅在与它会将当前 <code>yield</code> 表达式的值设置为 <code>value</code>。</li><li><code>generator.throw(type[, value[, traceback]])</code>：向生成器函数抛出一个类型为 <code>type</code> 值为 <code>value</code> 调用栈为 <code>traceback</code> 的异常，而后让生成器函数继续执行到下一个 <code>yield</code> 表达式。其余行为与 <code>generator.next()</code> 类似。</li><li><code>generator.close()</code>：告诉生成器函数，当前生成器作废不再使用。</li></ul><h3 id="举例和说明"><a href="#举例和说明" class="headerlink" title="举例和说明"></a>举例和说明</h3><h4 id="如果你看不懂生成器函数"><a href="#如果你看不懂生成器函数" class="headerlink" title="如果你看不懂生成器函数"></a>如果你看不懂生成器函数</h4><p>如果你还是不太能理解生成器函数，那么大致上你可以这样去理解。</p><ul><li>在函数开始处，加入 <code>result = list()</code>；</li><li>将每个 <code>yield</code> 表达式 <code>yield expr</code> 替换为 <code>result.append(expr)</code>；</li><li>在函数末尾处，加入 <code>return result</code>。</li></ul><h4 id="关于「下一个」yield-表达式"><a href="#关于「下一个」yield-表达式" class="headerlink" title="关于「下一个」yield 表达式"></a>关于「下一个」<code>yield</code> 表达式</h4><p>介绍「生成器的方法」时，我们说当调用 <code>generator.next()</code> 时，生成器函数会从当前位置开始执行到下一个 <code>yield</code> 表达式。这里的「下一个」指的是执行逻辑的下一个。因此</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f123</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> f123(): <span class="comment"># 1, 2, and 3, will be printed</span></span><br><span class="line">    print(item)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f13</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">False</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> f13(): <span class="comment"># 1 and 3, will be printed</span></span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure><h4 id="使用-send-方法与生成器函数通信"><a href="#使用-send-方法与生成器函数通信" class="headerlink" title="使用 send() 方法与生成器函数通信"></a>使用 <code>send()</code> 方法与生成器函数通信</h4><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def <span class="function"><span class="keyword">func</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        y = (yield x)</span><br><span class="line">        x += y</span><br><span class="line"></span><br><span class="line">geniter = <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">geniter.<span class="keyword">next</span>()  <span class="meta"># 1</span></span><br><span class="line">geniter.<span class="built_in">send</span>(<span class="number">3</span>) <span class="meta"># 4</span></span><br><span class="line">geniter.<span class="built_in">send</span>(<span class="number">10</span>)<span class="meta"># 14</span></span><br></pre></td></tr></table></figure><p>此处，生成器函数 <code>func</code> 用 <code>yield</code> 表达式，将处理好的 <code>x</code> 发送给生成器的调用者；与此同时，生成器的调用者通过 <code>send</code> 函数，将外部信息作为生成器函数内部的 <code>yield</code> 表达式的值，保存在 <code>y</code> 当中，并参与后续的处理。</p><p>这一特性是使用 <code>yield</code> 在 Python 中使用协程的基础。</p><h2 id="yield-的好处"><a href="#yield-的好处" class="headerlink" title="yield 的好处"></a><code>yield</code> 的好处</h2><p>Python 的老用户应该会熟悉 Python 2 中的一个特性：内建函数 <code>range</code> 和 <code>xrange</code>。其中，<code>range</code> 函数返回的是一个列表，而 <code>xrange</code> 返回的是一个迭代器。</p><blockquote><p>在 Python 3 中，<code>range</code> 相当于 Python 2 中的 <code>xrange</code>；而 Python 2 中的 <code>range</code> 可以用 <code>list(range())</code> 来实现。</p></blockquote><p>Python 之所以要提供这样的解决方案，是因为在很多时候，我们只是需要逐个顺序访问容器内的元素。大多数时候，我们不需要「一口气获取容器内所有的元素」。比方说，顺序访问容器内的前 5 个元素，可以有两种做法：</p><ul><li>获取容器内的所有元素，然后取出前 5 个；</li><li>从头开始，逐个迭代容器内的元素，迭代 5 个元素之后停止。</li></ul><p>显而易见，如果容器内的元素数量非常多（比如有 <code>10 ** 8</code> 个），或者容器内的元素体积非常大，那么后一种方案能节省巨大的时间、空间开销。</p><p>现在假设，我们有一个函数，其产出（返回值）是一个列表。而若我们知道，调用者对该函数的返回值，只有逐个迭代这一种方式。那么，如果函数生产列表中的每一个元素都需要耗费非常多的时间，或者生成所有元素需要等待很长时间，则使用 <code>yield</code> 把函数变成一个生成器函数，每次只产生一个元素，就能节省很多开销了。</p><p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Video captioning summary</title>
      <link href="/2019/02/23/Video-captioning-summary/"/>
      <url>/2019/02/23/Video-captioning-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="总结一下各论文使用的encoder的model分别是什么，是否采用了C3D，若采用了C3D-每16帧输出一个特征向量，这样的话，n-frames-16-个特征向量，那么论文中又是如何聚合特征来得到video-特征的？"><a href="#总结一下各论文使用的encoder的model分别是什么，是否采用了C3D，若采用了C3D-每16帧输出一个特征向量，这样的话，n-frames-16-个特征向量，那么论文中又是如何聚合特征来得到video-特征的？" class="headerlink" title="总结一下各论文使用的encoder的model分别是什么，是否采用了C3D，若采用了C3D,每16帧输出一个特征向量，这样的话，n_frames/16 个特征向量，那么论文中又是如何聚合特征来得到video 特征的？"></a>总结一下各论文使用的encoder的model分别是什么，是否采用了C3D，若采用了C3D,每16帧输出一个特征向量，这样的话，n_frames/16 个特征向量，那么论文中又是如何聚合特征来得到video 特征的？</h2><h2 id="总结一下使用attention-的模型，如何得到attention的，是在encoder，还是在decoder中使用的attention"><a href="#总结一下使用attention-的模型，如何得到attention的，是在encoder，还是在decoder中使用的attention" class="headerlink" title="总结一下使用attention 的模型，如何得到attention的，是在encoder，还是在decoder中使用的attention"></a>总结一下使用attention 的模型，如何得到attention的，是在encoder，还是在decoder中使用的attention</h2><h2 id="训练和测试的一般过程"><a href="#训练和测试的一般过程" class="headerlink" title="训练和测试的一般过程"></a>训练和测试的一般过程</h2><p>The training process predicts the next word given the previous words from groundtruth, while the generation process conditions the prediction on the ones previously generated by itself.  </p><h2 id="训练损失"><a href="#训练损失" class="headerlink" title="训练损失"></a>训练损失</h2><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0iyn2xsz9j30r00higpg.jpg" style="zoom:70%"><h2 id="Code-总结"><a href="#Code-总结" class="headerlink" title="Code 总结"></a>Code 总结</h2><table><thead><tr><th>model</th><th>batch_size</th><th>epoch</th><th>learning_rate</th><th>MSVD<br>train-dataset</th><th>MSR-train-dataset</th></tr></thead><tbody><tr><td>video-caption.pytorch</td><td>128</td><td>6001（MSR）</td><td>0.0004 (每200epoch下降0.8)</td><td>✘</td><td>6513 pairs<br>(每一次随机的从captions中选择一个作为label)</td></tr><tr><td>SA-tensorflow</td><td>100</td><td>200</td><td>0.0001（不变）</td><td>1200×41个pairs</td><td>✘</td></tr><tr><td>reconstruction-network</td><td>100</td><td>iter=100000  （epoch=100000×100/(1200*41）=203</td><td>0.00001（不变）</td><td>1200×41个pairs</td><td>✘</td></tr><tr><td>saliency-based</td><td>100</td><td>100</td><td>0.0003（不变）</td><td>略</td><td>✘</td></tr><tr><td>HRNE</td><td>200</td><td>128</td><td>0.0002</td><td>略</td><td>✘</td></tr></tbody></table><table><thead><tr><th>model</th><th>construct vocab use which dataset</th></tr></thead><tbody><tr><td>video-caption.pytorch</td><td>MSR: all</td></tr><tr><td>SA-tensorflow</td><td>MSVD: train</td></tr><tr><td>reconstruction-network</td><td>MSVD: all</td></tr><tr><td>saliency-based</td><td></td></tr><tr><td>HRNE</td><td></td></tr></tbody></table><table><thead><tr><th>model</th><th>loss function</th><th>input of decoder</th></tr></thead><tbody><tr><td>video-caption.pytorch</td><td>output of decoder（bs, hidden size）,经过一个全连接层得到one-hot形式(bs, n_vocab），在经过F.log_softmax。则损失函数 nn.NLLLoss（）</td><td>rnn1的输入是video feature;<br>rnn2的输入是rnn1的输出cancatenate 上一步ground truth的word embedding<br> output1, state1 = self.rnn1(vid_feats, state1)<br> input2 = torch.cat((output1, padding_words), dim=2)<br>          output2, state2 = self.rnn2(input2, state2)</td></tr><tr><td>SA-tensorflow</td><td><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0izmumz8sj30ry01l74i.jpg">LSTM的output/hidden state、经过attention加权求和得到的videofeature、上一步step的groundtruth word embedding进行concatenate，在经过全连接层、非线性层、全连接层、输入交叉熵损失函数：tf.nn.softmax_cross_entropy_with_logits</td><td>LSTM的输入是concatenate(video_feature, 上一步ground truth的word embdedding）</td></tr><tr><td>reconstruction-network</td><td>output of decoder（bs, hidden size）,经过一个全连接层得到one-hot形式(bs, n_vocab），在经过dropout。  则损失函数 nn.CrossEntropyLoss()</td><td>LSTM的输入是concatenate(video_feature, 上一步ground truth的word embdedding）</td></tr></tbody></table><hr><h2 id="Paper-总结"><a href="#Paper-总结" class="headerlink" title="Paper 总结"></a>Paper 总结</h2><table><thead><tr><th>model</th><th>dataset</th><th>n_frames</th></tr></thead><tbody><tr><td>S2VT</td><td>MSVD</td><td>每10帧取1帧</td></tr><tr><td>SA</td><td>MSVD</td><td>前240帧等间隔取26帧</td></tr><tr><td>h-RNN</td><td>MSVD</td><td>没讲( ˇˍˇ )</td></tr><tr><td>HRNE</td><td>MSVD</td><td>fixed 160帧</td></tr><tr><td>LSTM-TSA</td><td>MSVD</td><td>等间隔采取25帧</td></tr><tr><td>LSTM-E</td><td>MSVD</td><td>all frames</td></tr><tr><td>Reconstruction</td><td>MSVD  MSR-VTT</td><td>等间隔28帧</td></tr><tr><td>M3</td><td>MSVD  MSR-VTT</td><td>28帧for MSVD; 40帧for MSR-VTT</td></tr></tbody></table><table><thead><tr><th>model</th><th>词频</th><th>MSVD  vocabulary</th><th>MSR-VTT  vocabulary</th></tr></thead><tbody><tr><td>Hierarchical Boundary-Aware Neural Encoder for Video Captioning</td><td>大于等于5</td><td>4215</td><td></td></tr><tr><td>Multimodal Memory Modelling for Video Captioning</td><td></td><td>13,000</td><td>29,000</td></tr><tr><td>Spatio-Temporal Dynamics and Semantic Attribute Enriched Visual Encoding for Video Captioning</td><td></td><td>9450</td><td>23500</td></tr><tr><td>Describing Videos by Exploiting Temporal Structure</td><td></td><td>16,000</td><td></td></tr><tr><td>Video Paragraph Captioning Using Hierarchical Recurrent Neural Networks</td><td></td><td>12, 766（1, 297 and 670 videos ）</td><td></td></tr></tbody></table><table><thead><tr><th>model</th><th>feature</th><th>METER</th></tr></thead><tbody><tr><td>Mean Pool + LSTM</td><td>在COCO上预训练的Alex net</td><td>29.1</td></tr><tr><td>S2VT</td><td>RGB frames on VGG Net<br>optical flows on AlexNet</td><td>29.8</td></tr><tr><td>SA</td><td>GoogLeNet and 3D-CNN</td><td>29.6</td></tr><tr><td>LSTM-E</td><td>VGGNet and C3D</td><td>31.0</td></tr><tr><td>h-RNN</td><td>VGGNet and C3D</td><td>32.6</td></tr><tr><td>HRNE</td><td>GooLeNet</td><td>33.1</td></tr><tr><td>Reconstruction</td><td>Inception-V4<br> last pooling layer</td><td>34.1</td></tr></tbody></table><h2 id="提取frames-features-之后，获取video-feature的几种方法："><a href="#提取frames-features-之后，获取video-feature的几种方法：" class="headerlink" title="提取frames features 之后，获取video feature的几种方法："></a>提取frames features 之后，获取video feature的几种方法：</h2><p><strong>1. Mean pooling</strong></p><ul><li>Translating videos to natural language using deep recurrent neural networks. NACACL, 2015</li><li>Jointly modeling embedding and translation to bridge video and language. CoRR,  2015  </li></ul><p><strong>2. Weighted mean Pooling with an attention model</strong>    </p><ul><li>Describing videos by exploiting temporal structure. ICCV, 2015  </li><li>Exploring Visual Relationship for Image Captioning</li><li>2层LSTM，第一层LSTM的输入是对object/frames features进行平均池化，第二层LSTM的输入是给定第一层的hidden state 来得到attention 系数，从而对object/frames features进行加权求和。 即第一层用平均池化的特征来表征 global feture，第二层用加权求和的特征来表征 global feature</li></ul><p><strong>3. Taking the last output from an RNN encoder which summarizes the feature sequence</strong>    </p><ul><li>Long-term recurrent convolutional networks for visual recognition and description. CVPR, 2015</li><li>Sequence to sequence - video to tex. ICCV, 2015</li><li>A multi-scale multiple instance video description network. CoRR, 2015  </li></ul><h2 id="video-captioning-的模型中，含有extract-object-proposal的论文"><a href="#video-captioning-的模型中，含有extract-object-proposal的论文" class="headerlink" title="video captioning 的模型中，含有extract object proposal的论文"></a>video captioning 的模型中，含有extract object proposal的论文</h2><ul><li>Video paragraph captioning using hierarchical recurrent neural networks.  CVPR, 2016.  </li></ul>]]></content>
      
      
      <categories>
          
          <category> 视频描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频描述 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(h-RNN)Video Paragraph Captioning Using Hierarchical Recurrent Neural Networks</title>
      <link href="/2019/02/23/h-RNN-Video-Paragraph-Captioning-Using-Hierarchical-Recurrent-Neural-Networks/"/>
      <url>/2019/02/23/h-RNN-Video-Paragraph-Captioning-Using-Hierarchical-Recurrent-Neural-Networks/</url>
      
        <content type="html"><![CDATA[<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><ul><li>这篇文章主要针对于一个video 划分为多个interval，并分别对其进行caption这样的数据集。其中段落生成器的作用：可以捕捉句子之间的相互依赖关系，同时段落生成器的输出作为句子生成器的输入，可以使得<strong>下一个句子的生成是建立在当前句子的语境下生成的</strong>。</li><li>另外对于MSVD这种一个video直接由一个sentence来描述的数据集，段落生成器不起作用，只是在<strong>decoder的结构相较于其他的model有不同之处</strong>：video feature 不输入decoder 的 RNN，而是与RNN的hidden state 级联后输入Multimodal层，Multimodal( concatenate( hidden state，video feature ) )。</li></ul><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>提出了一个方法：<strong>利用分层RNN开解决视频描述</strong>。我们的分层框架包含一个句子生成器和一个段落生成器。<strong><em>句子生成器</em></strong>产生一个简短的句子，这个句子可以描述一个特定的短视频间隔。它利用时间和空间的注意力机制，有选择地将注意力集中在视觉元素上。<strong><em>段落生成器</em></strong>通过将句子生成器产生的句子嵌入与段落历史结合起来作为输入来捕获句子间的依赖关系，并段落生成器的parahraph state 将作为输出语句生成器的新初始状态，然后句子生成器再生成下一个句子，~ 循环</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul><li><strong>对当前方法的总结：</strong><br>当给出了从视频帧中提取的深度卷积特征序列(例如vggnet 和c3d)，则视频的特征可以用以下几种方法获取：<br>（1）平均池化[1, 2]<br>（2）加权平均池化（attention 机制）[3]<br>（3）RNN encoder 的最后一个输出[4, 5, 6]<br>当前基于序列学习的视频描述方法，只专注于为一个简短的视频剪辑生成一个句子。到目前为止，深层次学习方法还没有尝试为长视频生成多个句子或段落的问题。使用平均池化得到 video feature 的方法，只适用于 short video clips where there is only one major event，随后有了 recurrent encoder 和 attention model。<br>我们的方法也采用了attention 机制。但是我们的框架和他们的框架之间存在两个不同之处，1. 解释<strong>空间注意力</strong>：即对每个frames 提取object proposals 然后基于注意力机制对proposal features of one frames 进行加权求和来得到frames features。这对于数据集中 object 非常小且难定位的情况有很大的帮助。另外，也解释一下<strong>时域注意力</strong>：是指对features of frames 进行加权求和，从而得到 video feature。 <strong>本文的注意力机制</strong>：提取M帧，每帧K个object, 则对这M*K个 object 进行基于attention 系数的加权求和。2. 在加权视频特征和注意权重之后，我们不会在加权特征的基础上限制递归层的隐藏状态。 </li><li><strong>Motivation</strong><br>大多数视频描述的不仅仅是一个事件。只用一个简短的句子来描述一个语义丰富的视频通常会产生信息不多甚至无聊的结果。例如，一个video 应该描述成<strong>那个人把土豆切成片，把洋葱切成块，把洋葱和土豆放进锅里</strong>，但是只产生one sentence的方法可能会说<strong>这个人在做饭</strong>。</li><li><strong>Idea</strong><br>我们想要利用句子之间的时域依赖性，这样，在生成段落时，句子就不会独立地生成。相反，一个句子的生成可能会受到前几句所提供的语义上下文的影响。<br>我们的分层RNN结构包括两个生成器，一个句子生成器和一个段落生成器，这两个生成器都使用RNN layers<br>据我们所知，这是分层RNN在视频字幕任务中的首次应用。  </li></ul><h2 id="Hierarchical-RNN-for-Video-Captioning"><a href="#Hierarchical-RNN-for-Video-Captioning" class="headerlink" title="Hierarchical RNN for Video Captioning"></a>Hierarchical RNN for Video Captioning</h2><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0gmi1zayjj314o0h2n1f.jpg">***designed by yaya:***<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0k7r1p5ygj316f0jyq47.jpg">我们的方法：在句子生成器之上堆叠了一个段落生成器**句子生成器**：1) RNN 用来语言建模 2) 多模态层对多源信息进行聚合 3) 注意力模型<ul><li>RNN1：word embedding 作为RNN的输入，并更新 hidden state </li><li>Attention layer: RNN 的hidden state 作为attention layer 的输入，来计算weight:   <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0gohii8woj30xx02saab.jpg" style="zoom:30%"><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0gom9zybsj30kg04mwes.jpg" style="zoom:45%">假设视频中有M帧，每帧有K个objects，则features：  <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0go2kemkqj30bq01pt8m.jpg" style="zoom:50%">若计算出了一组权重:  <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0go382u2qj309m0250so.jpg" style="zoom:50%">则 video feature：  <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0go5n8g7dj30if036mx8.jpg" style="zoom:30%">得到的video feature是一个特征通道，完整的模型是两个特征通道，一个由 object appearance 生成，另一个由action 生成</li><li>Multimodal<br>输入：RNN 的hidden state <strong>concate</strong> 2个Attention 的输出（两个特征通道Ua  C3D，action feature；Uo aggregate object appearance）。既有语言，又有视觉，因此成为多模态。<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0gpaasqgmj30sb022dg0.jpg" style="zoom:50%"></li><li>Hidden layer<br>-输出维度512 与 word embdeding 的维度一致</li><li>Softmax layer<br>输出维度与vocabulary size 一致</li><li>Maxid layer<br>Maxid layer 在softmax layer 的输出中挑选了最大值所在的索引，该索引将会被作为predicted word 的id(对应到vocabulary 的 索引)</li><li>预测的单词将会作为句子生成器的下一个输入（test）；下一个输入单词总是由带注释的句子（ground truth/ reference）提供。</li></ul><p><strong>段落生成器</strong> : 另外一个RNN，来建模句子之间的相互依赖。输入：1.句子生成器的输出， 2. paragraph history  输出：该输出作为句子生成器的初始状态<br>使用的RNN为GRU</p><ul><li>Word Embedding<br>1) 对sentences中的所有单词的embedding 取平均，得到一个压缩embedding vector<br>2) 同时也接受RNN1 的最后一个hidden state 作为 压缩表达<br>将上面两个压缩表达concatenated </li><li>Sentences Embedding<br>将上面concatenated 的特征输入该层，得到512维度的输出</li><li>RNN2</li><li>Paragraph State layer<br>输入：结合RNN2的hidden state 和 sentence embedding<br>输出：作为RNN1下一个句子的初始状态，为句子生成器提供了段落历史是有必要的，以便在上下文语境中中生成下一句。<br>它实质上为句子生成器提供了段落历史，以便在上下文中生成下一句。</li></ul><h2 id="Training-and-Generation"><a href="#Training-and-Generation" class="headerlink" title="Training and Generation"></a>Training and Generation</h2><p><strong>整个网络的循环过程</strong></p><ul><li>当RNN1在每一时间步骤中不断更新其hidden state，RNN2只在处理完整句子时才更新其hidden state。</li><li>RNN1 由beam search 得到 J 个sequence cost 最低的句子，挑选出1个最低的，然后送入RNN2。RNN2又输出隐层状态，最为RNN1下一个句子的初始隐层状态。如此循环，直至， when the sentence received by the paragraph generator is the EOP (end-of-paragraph) which consists of only the BOS and the EOS。</li></ul><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p><strong>数据集</strong><br>two benchmark datasets: YouTubeClips and TACoS-MultiLevel<br>YouTubeClips： 虽然每个video 有多个sentences进行描述，但是sentences是对这个video的整体描述，而不是分别对video进行分段描述。因此这个数据集作为我们方法的特例，paragraph length N=1.<br><strong>Encoder</strong></p><ul><li>由于YouTubeClips数据集中的object 十分显著，因此不进行提取object的操作，只对frame 提取特征，这样attention 只包括temporal attention ，而不包括 spatial attention。</li><li>对于TACoS-MultiLevel 数据集，首先使用光流大体的提取boundinig box，然后沿着bounding box 的边，提取220*220的image patches，保证相邻两个box 重合度为50%。使用VGG模型对每个patch提取特征，并使用attention的权重，对这些patches进行加权求和。此时，attention同时包括temporal 和 spatial。</li><li>C3D 提取 action/motion feature of video<br>C3D 模型：输入frames of video ，每16帧输出一个固定长度的特征向量。然后采用attention机制对C3D特征进行polling（加权求和）<br><strong>实验结果对比分析</strong></li><li>YouTubeClips  <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0hdv8rde9j30i7099jtg.jpg">   相比于**LSTM-E[2]**（同样同时利用了VGG和C3D特征），我们的模型效果更好。相比于**SA[3]**（同样利用了temporal attention）我们的方法更好，原因：RNN的输入不包括视频特征，换句话说， hidden state的更新不建立在video feature的基础上。video feature直接的输入到multimodal layer。</li><li>TACoS-MultiLevel<br>这里不做分析（可以自行参考论文）</li></ul><h2 id="Discussions-and-Limitations"><a href="#Discussions-and-Limitations" class="headerlink" title="Discussions and Limitations"></a>Discussions and Limitations</h2><ol><li>目前我们使用的目标检测方法很难处理small object，造成在生成句子时，极容易混淆，比如应该是orange ，却生成了mango</li><li>句子信息通过段落循环层单向流动，从段落开始到结尾，但也不是以相反的方式。如果第一个句子中含有错误信息，则会导致错误信息依次传递，目前使用双向RNN来生成句子，仍然是一个开放性的问题（yaya: sorry , i don’t kow what’s mean，可能是目前还不知道使用BiRNN来生成句子的效果是否好于单向RNN）。</li><li>与其他大多数图像/视频字幕方法一样，我们的方法存在一个已知的问题，即训练所使用的目标函数与生成方法所使用的目标函数之间存在差异。训练过程给定来自groundtruth的先前单词来预测下一个单词，而生成过程则对先前由其自身生成的单词进行预测。这个问题在我们的分层框架中更加放大，因为在训练时，段落生成器输入的是groundtruth，但是在测试阶段，输入的是句子生成器生成的句子。潜在的解决办法：</li></ol><ul><li>Scheduled Sampling<br>在训练过程中增加Scheduled Sampling，即随机的选择words of groundtruth或者由model生成的单词。</li><li>在训练的过程中直接优化metric(BLEU， CIDER, etc)</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <strong><em>Translating videos to natural language using deep recurrent neural networks</em></strong>. NACACL, 2015<br>[2] <strong><em>Jointly modeling embedding and translation to bridge video and language</em></strong>. CoRR,  2015<br>[3] <strong><em>Describing videos by exploiting temporal structure</em></strong>. ICCV, 2015<br>[4] <strong><em>Long-term recurrent convolutional networks for visual recognition and description</em></strong>. CVPR, 2015<br>[5] <strong><em>Sequence to sequence - video to text</em></strong>. ICCV, 2015<br>[6]  <strong><em>A multi-scale multiple instance video description network</em></strong>. CoRR, 2015</p>]]></content>
      
      
      <categories>
          
          <category> 视频描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频描述 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hierarchical Boundary-Aware Neural Encoder for Video Captioning</title>
      <link href="/2019/02/22/Hierarchical-Boundary-Aware-Neural-Encoder-for-Video-Captioning/"/>
      <url>/2019/02/22/Hierarchical-Boundary-Aware-Neural-Encoder-for-Video-Captioning/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0g5c5cwmxj30l00mh45o.jpg">  In this paper, we focus on the video encoding stage. we propose a recurrent network which can learn to adapt its temporal structure to input data.Our network is the first proposal which exploits temporal segments invideo captioning。在这篇文章中，给出了一个循环视频编码方案，该方案可以发现和利用视频的分层结构。不同于经典的编码解码方法（视频由一个循环层来连续的编码），我们提出了一个新颖的LSTM单元， 其可以识别帧/段之间非连续的点，相应地修改编码层的时间连接。Encoder Model---------<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0g57reyepj316c0m7k74.jpg">   - **traditional lstm network**使用LSTM来获得video feature，将每个frames 按每time step 依次送入LSTM，最后一个LSTM cell 的hidden state 用来得到video feature。  - **Time Boundary-aware LSTM network** ***(ours)***figure1 与 figure2 结合来看，存在BD（boundary detection ）来检测该帧是否为一个边界（an appearance or action change），若BD检测到存在一个边界，则**保存当前LSTM的输出**，并开始一个新的LSTM（即，hidden state and the cell memory 被重新初始化）。这就确保了在边界之后的输入数据，不受边界之前数据的影响。经过对all frames of video 进行这样的操作，于是得到可变长度的输出 (s1; s2; ...; sm), m是检测到segments的数量。这组输出又经过另外一个LSTM层（称为第二LSTM层），第二LSTM层的hidden state 作为整个视频的特征（参考figure1）。Decoder model-------------A Gated Recurrent Unit (GRU) layer]]></content>
      
      
      <categories>
          
          <category> 视频描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频描述 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>video-caption-dataset</title>
      <link href="/2019/02/22/video-caption-dataset/"/>
      <url>/2019/02/22/video-caption-dataset/</url>
      
        <content type="html"><![CDATA[<h2 id="Youtube2Text-（MSVD）-1"><a href="#Youtube2Text-（MSVD）-1" class="headerlink" title="Youtube2Text （MSVD）[1]"></a>Youtube2Text （MSVD）[1]</h2><ul><li>这个数据集包含 1967个短视频，10-25s，平均时长为9s，视频包含不同的人，动物，动作，场景等。</li><li>每个视频由不同的人标注了多个句子，大约41 annotated sentences per clip，共有 80839 个sentences，平均每个句子有8个words，这些所有的句子中共包含近16000个 unique words。</li><li>caption中包括多国的语言进行描述，部分论文中采取只选用laguage = english 的caption 进行训练和测试[3][4]</li><li>采用的split根据 [2] ： 1,200 videos for training, 100 for validation and 670 for testing.<br><a href="https://github.com/ShiYaya/video_captioning/tree/master/MSVD" target="_blank" rel="noopener">我的整理</a></li></ul><ul><li>数据的下载：</li><li><a href="https://www.microsoft.com/en-us/download/details.aspx?spm=a2c4e.11153940.blogcont209612.6.42ba7e9eAA1K2o&id=52422&from=http%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fdownloads%2F38cf15fd-b8df-477e-a4e4-a4680caa75af%2Fdefault.aspx" target="_blank" rel="noopener">[website]</a></li><li>原数据：只给出了video_id,以及strart and end time , 若需要video数据，则需要自己通过url下载</li><li>某篇对于视频分析的总结，给出了<a href="https://github.com/sinyeratlantis/sinyeratlantis.github.io/blob/master/content/dl/%E8%A7%86%E9%A2%91%E5%88%86%E6%9E%90%E6%96%87%E7%8C%AE%E8%B0%83%E7%A0%94.md" target="_blank" rel="noopener">MSVD的下载链接</a>，可用，推荐(下载速度快，且video命名相对较好)☀☀<br><br><a href="http://www.cs.utexas.edu/users/ml/clamp/videoDescription/YouTubeClips.tar" target="_blank" rel="noopener">直接的下载链接</a><strong>[推荐]</strong></li><li>某篇github 含有MSVD(Youtube2Text)的<a href="https://github.com/yaoli/arctic-capgen-vid" target="_blank" rel="noopener">[preproceed dataset]</a><br><br><a href="http://lisaweb.iro.umontreal.ca/transfert/lisa/users/yaoli/youtube2text_iccv15.zip" target="_blank" rel="noopener">直接的下载链接</a>(下载速度慢)</li><li>该篇github上含有<a href="https://github.com/ShiYaya/Video-Description-with-Spatial-Temporal-Attention#video-datas-and-pre-extracted-features-on-msvd-dataset" target="_blank" rel="noopener">MSVD数据集下载链接</a><br><br><a href="https://www.multcloud.com/share/050e69cd-cab9-4ba3-a671-ed459341ab41" target="_blank" rel="noopener">直接的下载链接</a></li><li>对caption 常用的预处理: 1) verting all text to lower case, 2) tokenizing the sentences, 3) removing punctuation.</li></ul><h2 id="MSR-VTT-dataset"><a href="#MSR-VTT-dataset" class="headerlink" title="MSR-VTT dataset"></a>MSR-VTT dataset</h2><p> 共10000个video, 每个video有20个sentences, 共20万 video/sentence pair，10-30s居多</p><ul><li>split:  train:6513, val:497, test：2990</li><li>MSR-VTT dataset v2 , just video url: <a href="http://ms-multimedia-challenge.com/2017/dataset" target="_blank" rel="noopener">http://ms-multimedia-challenge.com/2017/dataset</a></li><li>author split train test val by himself and provied video data :<a href="https://github.com/xiadingZ/video-caption.pytorch" target="_blank" rel="noopener">https://github.com/xiadingZ/video-caption.pytorch</a>  <br></li></ul><p><strong>下载这个数据集即可使用，但是还需要再找split!</strong><br></p><ul><li>MSR VTT 采用的split 是2016年提供的，<strong>目前科研广泛使用的都是2016年的</strong>。</li><li><a href="https://github.com/adi-dhal/In_Depth_Video_Analysis/tree/master/msr-vtt/2016" target="_blank" rel="noopener">[split]</a><br>MSR-VTT. Test video doesn’t have captions, so I spilit train-viedo to train/val/test. Extract and put them in <code>./data/</code> directory</li></ul><p>train-video: <a href="https://drive.google.com/file/d/1Qi6Gn_l93SzrvmKQQu-drI90L-x8B0ly/view?usp=sharing" target="_blank" rel="noopener">download link</a> <br><br>test-video: <a href="https://drive.google.com/file/d/10fPbEhD-ENVQihrRvKFvxcMzkDlhvf4Q/view?usp=sharing" target="_blank" rel="noopener">download link</a> <br><br>json info of train-video: <a href="https://drive.google.com/file/d/1LcTtsAvfnHhUfHMiI4YkDgN7lF1-_-m7/view?usp=sharing" target="_blank" rel="noopener">download link</a> <br><br>json info of test-video: <a href="https://drive.google.com/file/d/1Kgra0uMKDQssclNZXRLfbj9UQgBv-1YE/view?usp=sharing" target="_blank" rel="noopener">download link</a> <br></p><ul><li><p>download.py 可以下载MSR-VTT数据集(step by video)：<a href="https://github.com/OSUPCVLab/VideoToTextDNN" target="_blank" rel="noopener">[链接]</a></p></li><li><p>msr-vtt 2017 vs 2016<br>In the 2nd MSR Video to Language Challenge, we have combined the training set, validation set, and testing data in the 1st MSR Video to Language Challenge as the new training data. An additional test set of around 3K video clips will be released on June 1st as the final evaluation set. As such, we have 10K video clips for training and 3K video clips for testing this year. Each video is annotated with 20 natural sentences.<br><br>总结：就仅仅是将2016的train val and test 综合到一起，组成了2017： 一个大的含10000个video的train 数据集，并另外提供了2000个test video。<br><br>科研上普遍使用2016的分割方案，</p></li></ul><ul><li>In MSR-VTT dataset, we provide the category information for each video clip and the video clip contains audio information as well.</li></ul><p>[1] Youtube2text: Recognizing and describing arbitrary activities using semantic hierarchies and zero-shot recognition. In ICCV 2013</p><p>[2] Translating videos to natural language using deep recurrent neural networks. NAACL, 2015.<br>[3] (ICCV 2015)Sequence to Sequence – Video to Text<br>[4] Jointly Modeling Embedding and Translation to Bridge Video and Language</p>]]></content>
      
      
      <categories>
          
          <category> 视频描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频描述 </tag>
            
            <tag> 数据集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown用法</title>
      <link href="/2019/02/22/Markdown%E7%94%A8%E6%B3%95/"/>
      <url>/2019/02/22/Markdown%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ul><li><p>参考该网址：<br><a href="https://www.kancloud.cn/wizardforcel/markdown-simple-world/97375" target="_blank" rel="noopener">https://www.kancloud.cn/wizardforcel/markdown-simple-world/97375</a></p></li><li><p>在线编辑器<br><a href="https://stackedit.io/editor" target="_blank" rel="noopener">https://stackedit.io/editor</a></p></li><li><p>首行缩进两个字符：<br>切换至中文全角，shift+space 按一次，然后再摁space两次，即可出现首行缩进两个字符</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(LSTM-E)Jointly Modeling Embedding and Translation to Bridge Video and Language</title>
      <link href="/2019/02/22/LSTM-E-Jointly-Modeling-Embedding-and-Translation-to-Bridge-Video-and-Language/"/>
      <url>/2019/02/22/LSTM-E-Jointly-Modeling-Embedding-and-Translation-to-Bridge-Video-and-Language/</url>
      
        <content type="html"><![CDATA[<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><p>本文的主要贡献：</p><ol><li>同时使用了action feature of C3D and frames features。但是由于对C3D的特征也采用了mean pooling的方法，有缺陷，对action 特征的一种破坏。</li><li>提出了relevance loss ， 来加强整个句子的语义与视觉特征之间的关系。  </li></ol><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>目前存在的方法，依据给定的先前的单词以及视觉信息，来生成words，但是并没有利用句子语义与视觉内容之间的关系，导致生成的句子可能上下文是正确的，但是语义是错误的。<br>如 figure1，LSTM model 生成的句子是a man is riding a horse，逻辑上是没有错误的，但是语义却错了，图中出现的是woman 而不是man。<br>　　<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0f0qr6d2ij30lq0biq8s.jpg" width="500" hegiht="313" align="center"></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>  简单介绍LSTM-E：LSTM-E可以同时利用LSTM学习和视觉-语义embedding。LSTM 学习是为了在给定先前的单词以及视觉特征的基础上，最大化生成下一个单词的概率，后者是为了生成视觉-语义embedding，来加强整个句子的语义与视觉特征之间的关系。<br>  <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0f87gorc9j316d0kr11m.jpg" title="overview">  </p><ul><li><strong>Overview</strong><br>2D/3D 卷积神经网络被用来提取视频frames/clips的特征，平均池化来得到视频的特征。<br>基于视频特征<strong><em>v</em></strong>和句子语义<strong><em>s</em></strong>，生成sentences的<strong>LSTM model</strong> 和<strong>视觉-语义embeddeing model</strong> 联合学习。</li><li><strong>The sprit of LSTM-E</strong><br>在coherence和relevance之间的相互增强下来生成sentences。<strong><em>coherence:</em></strong>表达了生成words与视频内容之间的相关关系，由LSTM优化完成。<strong><em>relevance:</em></strong>整个句子的语义与视频内容之间的关系，由视觉-语义embeddeing model来度量。通过联合学习coherence和relevance，期望生成的句子在语境和语义上是正确的。</li><li><strong>说人话</strong><br>由两个model组成，一个是sequence learning 都有的coherence loss ，来最大化生成next word的似然概率；另一个是本文添加的relevance loss，通过优化视频特征与生成句子之间的差距，使得生成的句子语义上能对应video的内容。即同时考虑了句子单词之间的上下文关系，也考虑了句子语义与视频内容之间的关系。</li><li><strong>contribution</strong><br>提出了relevance loss !  </li></ul><h2 id="Video-Description-with-Relevance-and-Coherence"><a href="#Video-Description-with-Relevance-and-Coherence" class="headerlink" title="Video Description with Relevance and Coherence"></a>Video Description with Relevance and Coherence</h2><ul><li><strong>Visual-Semantic Embedding: Relevance</strong><br><strong><em>v</em></strong> 和 <strong><em>s</em></strong> 分别是视频的特征和sentences的特征（即，都是已知的），Ts和Tv用来降维到相同的维度，为了度量视频内容与句子语义之间的相关性，一个自然地方法是计算embedding之间的距离，因此定义relevance loss:<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0f8zoni8tj30bc01pmx2.jpg" 　style="zoom:45%"></li><li><strong>Translation by Sequence Learning: Coherence</strong><br>coherence loss：即为在给定视频特征的条件下，生成sentences的最大似然概率。  <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0f9l8bbvoj30ph02pglq.jpg" style="zoom:50%">  由overview的图可知，在实际的情况下LSTM的输入是：第一个LSTM输入是视频特征，其余的是前一个time step 生成的单词（在train时：是caption中给定的第t个单词，在test时：是前一个time step 生成的单词）。因此似然函数可以具体的表示为：  　　<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0f9lgy6nfj317806fgm5.jpg" style="zoom:40%"></li></ul><h2 id="Joint-Modeling-Embedding-and-Translation"><a href="#Joint-Modeling-Embedding-and-Translation" class="headerlink" title="Joint Modeling Embedding and Translation"></a>Joint Modeling Embedding and Translation</h2><ul><li><p><strong>simultaneously minimizing the relevance loss and coherence loss.</strong>  </p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0fa1y3nkgj30nu05pq3p.jpg" style="zoom:70%"></li><li><p>*<em>LSTM结构 *</em><br>这里有多种方式来结合visual content 和 word of last time step。法一：each time step 都输入视频特征；法二：只在第一步输入视频特征。但是在[ 1 ]中指出，由于网络可以显式地利用噪声和更容易覆盖，所以每次输入图像都会产生劣质的效果。 因此，采用第二种方法，在给定视频特征v 和相对应的 sentence W ≡ [w0, w1, …, wNs]，LSTM的更新步骤如下：  </p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0fcc8tiqej30z708l0t3.jpg">  <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0faic2fuzj30n508njs2.jpg" style="width: 50%; height: 50%">  在初始的第一步，视频特征作为LSTM的输入；在第二步，<#start#>开始的标志作为LSTM的输入，同时接受上一步的hidden state, cell state，以后每一步，都将上一步生成的word 作为输入，直至生成<#end#>。从第二步开始，使用LSTM cell 的hidden state 来预测 word( 对于LSTM output 与 hidden[0] 是一样的，参考：[https://mp.csdn.net/postedit/87516958](https://mp.csdn.net/postedit/87516958))<blockquote><p><code>output, hidden = self.rnn(input, hidden)</code></p></blockquote></#end#></#start#></li></ul><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><ul><li><strong>dataset</strong><br>MSVD:<br>Microsoft Research Video Description Corpus (YouTube2Text) , which contains 1,970 YouTube snippets. There are roughly 40 available English descriptions per video. In our experiments, we follow the setting used in prior works, taking 1,200 videos for training, 100 for validation and 670 for testing.</li><li><strong>result</strong><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0fcs7kt8cj31ap0bhgow.jpg"></li><li><strong>The effect of hidden layer size</strong>  <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0fcvqbzvsj30qz09x760.jpg" style="width: 70%; height: 70%">  </li></ul><h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>a visual-semantic embedding space is additionally incorporated into LSTM learning. In this way, <strong>a global relationship between the video content and sentence semantics</strong> is simultaneously measured in addition to <strong>the local contextual relationship between the word at each step and the previous ones</strong> in LSTM learning. On the popular YouTube2Text dataset, the results of our experiments demonstrate the success of our approach, outperforming the current state-ofthe-art models </p><h2 id="Future-Work"><a href="#Future-Work" class="headerlink" title="Future Work"></a>Future Work</h2><p>视频作为一个时域序列，未来将会探究使用RNN来获得更好的特征；另外，如果有更大的数据集，更多的video sentences pairs ，那么可以使用更深的RNN，来得到更好的视频描述</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] O. Vinyals, A. Toshev, S. Bengio, and D. Erhan. Show and tell: A neural image caption generator. In CVPR, 2015.</p>]]></content>
      
      
      <categories>
          
          <category> 视频描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频描述 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub+Hexo 搭建个人网站详细教程</title>
      <link href="/2019/02/21/GitHub-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/"/>
      <url>/2019/02/21/GitHub-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26625249</a></p><p><a href="https://blog.csdn.net/xuezhisdc/article/details/53130328" target="_blank" rel="noopener">https://blog.csdn.net/xuezhisdc/article/details/53130328</a></p><h3 id="增加本地搜索功能"><a href="#增加本地搜索功能" class="headerlink" title="增加本地搜索功能"></a>增加本地搜索功能</h3><h4 id="自定义站点内容搜索"><a href="#自定义站点内容搜索" class="headerlink" title="自定义站点内容搜索"></a>自定义站点内容搜索</h4><ol><li><p>安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-generator-searchdb <span class="comment">--save</span></span><br></pre></td></tr></table></figure></li><li><p>编辑博客配置文件，新增以下内容到任意位置：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">search:</span></span><br><span class="line"><span class="symbol">      path:</span> search.xml</span><br><span class="line"><span class="symbol">      field:</span> post</span><br><span class="line"><span class="symbol">      format:</span> html</span><br><span class="line"><span class="symbol">      limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure></li><li><p>编辑主题配置文件，启用本地搜索功能：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 杂类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
