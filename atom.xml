<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ShiYaya</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-06-07T03:24:49.672Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ShiYaya</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Non-Autoregressive Neural Machine Translation</title>
    <link href="http://yoursite.com/2021/06/07/Non-Autoregressive-Neural-Machine-Translation/"/>
    <id>http://yoursite.com/2021/06/07/Non-Autoregressive-Neural-Machine-Translation/</id>
    <published>2021-06-07T02:50:12.000Z</published>
    <updated>2021-06-07T03:24:49.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本篇博客针对当前使用<strong>非自回归</strong>方式处理<strong>机器翻译</strong>任务的相关论文进行总结。</p><h2 id="为什么要进行非自回归机器翻译？"><a href="#为什么要进行非自回归机器翻译？" class="headerlink" title="为什么要进行非自回归机器翻译？"></a>为什么要进行非自回归机器翻译？</h2><p>最近的一系列工作提出了非自回归机器翻译的方法 (NAT, <a href="https://arxiv.org/abs/1711.02281" target="_blank" rel="noopener">Gu et al. 2018</a>) 。NAT并行生成目标单词，这与标准自动回归翻译（AT）形成对比，后者可以预测以所有先前单词为条件的每个单词。虽然AT通常在相似配置下比NAT表现更好，但是NAT通过并行计算加快了推理速度。这种非自回归生成的一个非常成功的应用是Parallel WaveNet  (<a href="https://arxiv.org/abs/1711.10433" target="_blank" rel="noopener">Oord et al. 2017</a>)，将原始自回归Wavenet的速度提高了1000倍以上，并部署在了Google助手中。从NAT快速推断得到的收益可以允许在工业界的特定延迟和预算下部署更大，更深的Transformer模型。在这篇博客文章中，我将概述有关非自回归翻译的最新研究，并讨论我认为对进一步发展而言缺失或重要的内容。</p><h2 id="基本问题和可能的解决方法"><a href="#基本问题和可能的解决方法" class="headerlink" title="基本问题和可能的解决方法"></a>基本问题和可能的解决方法</h2><p>生成中的<a href="https://arxiv.org/abs/1711.02281" target="_blank" rel="noopener">多模式性(Multimodality)</a>对NAT提出了根本的挑战。我们都知道语言是高度多模态的(multimodal)。举一个小例子，英文句子<code>he is very good at Japanese</code>和<code>he speaks Japanese very well</code>是日语句子<code>彼は日本語が上手です</code>的两个有效译文。但是，看起很像的两个句子：<code>he speaks very good at Japanese</code>或<code>he is very good at very well</code>则没有任何意义。我们需要知道模型提交给它自己的两种可能的翻译是哪一种，但是在条件独立的解码中很难实现这一点。并行解码打破了条件依赖性，并经常导致输出不一致。文献中的一些工作已经提出解决NAT中Multimodality问题的方法。在这里，我对提出的方法进行了概括和分类。</p><h3 id="1-基于迭代（Iteration-based）的方法"><a href="#1-基于迭代（Iteration-based）的方法" class="headerlink" title="1. 基于迭代（Iteration-based）的方法"></a>1. 基于迭代（Iteration-based）<strong>的方法</strong></h3><p>解决并行解码问题的一种方法是迭代地优化模型输出([1,2,3])。在此框架中，我们放弃了完全可并行化的生成，而是在<strong>每次迭代中优化了先前生成的单词</strong>。由于通常我们所需的迭代次数比输出句子中单词的数量少得多，因此与自回归模型相比，迭代方法仍可以改善等待时间。这些论文均采用不同的方法进行细化，为了更清晰地理解，您可以参考 [2] 提出的一种典型的条件屏蔽语言模型（CMLM）。在给定源文本的情况下，使用目标端的BERT-style的掩蔽语言建模目标对CMLM进行训练，在推断中，我们Mask住<em>低置信度</em>的token，并在每次迭代中对其进行更新。[3] 工作提出了DisCo Transformer，该Transformer可计算出这种掩盖语言建模MLM的有效替代方案。特别地，在给定其他reference token的任意子集的情况下，可以训练DisCo Transformer来预测每个输出token。可以将其视为一次模拟多个masking。我们证明了DisCo Transformer可以减少所需的迭代次数（从而减少解码时间），同时保持转换质量。</p><blockquote><p>[1] Deterministic Non-Autoregressive Neural Sequence Modeling by Iterative Refinement</p><p>[2] Mask-Predict: Parallel Decoding of Conditional Masked Language Models. Marjan Ghazvininejad, Omer Levy, Yinhan Liu, Luke Zettlemoyer</p><p>[3] Non-autoregressive Machine Translation with Disentangled Context Transformer. Jungo Kasai,  James Cross,  Marjan Ghazvininejad, Jiatao Gu</p></blockquote><h3 id="2-比NLL更好的训练目标"><a href="#2-比NLL更好的训练目标" class="headerlink" title="2. 比NLL更好的训练目标"></a>2. 比NLL更好的训练目标</h3><p>一些工作提出了对数负似然性NLL的替代损失函数。我的直觉是使用普通NLL损失进行训练无法捕捉高度多峰分布(multimodal distributions)的表征。这在某种程度上让人联想到生成对抗网络（GAN）中的对抗损失。在图像生成中，原始的L2重建损失将使模式崩溃并产生模糊的图像，当使用NLL损失训练NAT模型时，可能会发生类似情况。拟议的替代损失函数包括NAT模型与自回归教师之间的隐藏状态的距离(<a href="https://arxiv.org/abs/1909.06708" target="_blank" rel="noopener">Li et al. 2019</a>)，Ngram词袋差 (<a href="https://arxiv.org/pdf/1911.09320.pdf" target="_blank" rel="noopener">Shao et al. 2020</a>) 和辅助正则化 (<a href="https://arxiv.org/pdf/1902.10245.pdf" target="_blank" rel="noopener">Wang et al. 2019</a>). 。与基于迭代的方法相比，这一系列方法可以并行实现一次生成，但代价是性能大大降低。</p><h3 id="3-精简-部分的自回归解码"><a href="#3-精简-部分的自回归解码" class="headerlink" title="3. 精简/部分的自回归解码"></a>3. 精简/部分的自回归解码</h3><p>先前的工作还提出了将轻度或部分自回归模块整合到NAT模型中的方法。 <a href="https://arxiv.org/pdf/1803.03382.pdf" target="_blank" rel="noopener">Kaiser et al. 2018</a> 生成了较短序列的潜在变量，并在顶部进行了并行单词预测。Blockwise decoding和Insertion Transformer产生的局部自回归方式一个句子 (<a href="https://arxiv.org/abs/1811.03115" target="_blank" rel="noopener">Stern et al. 2018</a>, <a href="https://arxiv.org/abs/1902.03249" target="_blank" rel="noopener">2019</a>).  <a href="https://arxiv.org/abs/1910.11555" target="_blank" rel="noopener">Sun et al. 2019</a> 在变压器输出向量之上引入了factorized CRF层，并通过波束近似(beam approximation)进行了快速自回归解码。 <a href="https://arxiv.org/abs/1911.02215" target="_blank" rel="noopener">Ran et al. 2019</a> 引入了精简自回归源端重排序模块，以促进并行目标解码。请注意，他们还使用非自回归重排序模块显示了结果，但是性能却差得多。</p><h3 id="4-用潜在变量建模"><a href="#4-用潜在变量建模" class="headerlink" title="4. 用潜在变量建模"></a>4. 用潜在变量建模</h3><p>我们可以在此框架中解释许多模型。例如，可以将所有以预测长度(predicted length)为条件的NAT模型视为具有潜在变量的建模。但尤其是 <a href="https://arxiv.org/abs/1909.02480" target="_blank" rel="noopener">Ma et al. 2019</a>  使用生成流技术对目标句子的复杂分布进行建模。 <a href="https://arxiv.org/abs/1908.07181" target="_blank" rel="noopener">Shu et al. 2020</a> 开发出了具有确定性推论(deterministic inference)的连续潜在变量NAT模型。</p><h3 id="5-从自回归模型中蒸馏"><a href="#5-从自回归模型中蒸馏" class="headerlink" title="5. 从自回归模型中蒸馏"></a>5. 从自回归模型中蒸馏</h3><p>据我所知，几乎所有表现好的NAT模型都经过自回归模型 (e.g. <a href="https://arxiv.org/abs/1711.02281" target="_blank" rel="noopener">Gu et al. 2018</a>) 的序列级知识蒸馏(<a href="https://arxiv.org/abs/1606.07947" target="_blank" rel="noopener">Kim &amp; Rush 2016</a>）训练而成。虽然较大Transformer的蒸馏也有助于自回归机器翻译，尤其是在贪婪解码的情况下，但它的作用是是较大程度上简化NAT模型 (<a href="https://arxiv.org/pdf/2001.05136.pdf" target="_blank" rel="noopener">Kasai et al. 2020</a>)。 <a href="https://arxiv.org/abs/1911.02727" target="_blank" rel="noopener">Zhou et al. 2019</a> 研究了模型容量与蒸馏数据之间的关系，表明模型容量与蒸馏数据复杂性之间存在相关性。这表明知识蒸馏可以杀死原始数据中的某些模式，从而可以更好地训练NAT模型。</p><h2 id="悬而未决的问题和未来目标"><a href="#悬而未决的问题和未来目标" class="headerlink" title="悬而未决的问题和未来目标"></a>悬而未决的问题和未来目标</h2><p>在这里，我重点介绍了我个人好奇的非自回归机器翻译中的开放性问题。</p><ul><li><strong>我们需要蒸馏吗？</strong>蒸馏肯定是一次性的训练成本，但是如果每次更改训练数据或语言对时都必须这样做，则蒸馏成本可能会很高。我们是否可以利用原始数据获得合理的性能？</li><li><strong>我们需要预测目标长度吗？</strong>我仍然发现目标长度预测很奇怪。当前的许多NAT方法都要求目标长度预测并且以这个预测的长度作为条件。虽然长度预测为我们提供了在潜在变量空间中进行搜索的机会，但长度预测会破坏生成的灵活性。</li><li><strong>NAT可以胜过AT吗？</strong>我们已经看到，在相同的配置下，AT的性能通常优于NAT。但是，NAT可以做得更好吗？或者更实际的说，在相同的延迟预算下，NAT是否能明显胜过AT？NAT可以使用更大的配置。</li><li><strong>预训练和NAT。</strong>在非自回归机器翻译中使用大规模预训练的掩蔽语言模型MLM可能比在自回归翻译中使用更容易。NAT中的解码器（例如条件屏蔽语言模型）看起来更像BERT。</li><li><strong>训练和推理中的隔阂(bridge)。</strong>在迭代NAT框架中，<strong><strong style="color:red;">训练和推理之间经常会出现差距</strong></strong>。例如，训练条件语言模型（CMLM），以在给定其他观察到的token的情况下预测被掩盖的token。最近一项成功的尝试是对CMLM进行SMART训练 (<a href="https://arxiv.org/abs/2001.08785" target="_blank" rel="noopener">Ghazvininejad et al. 2020</a>) ，他们训练模型以从先前的预测误差中恢复。这种方法可普及到基于迭代的NAT。</li><li><strong>向结构化预测学习。</strong>NLP中已经在结构化预测（例如语法和语义解析）方面投入了很多精力。我们可以从结构化预测的方法中学习以更好地处理生成中的条件依赖性吗？训练和推理之间的上述差距是句法分析中研究的一个问题 (e.g. dynamic oracle, <a href="https://www.aclweb.org/anthology/C12-1059/" target="_blank" rel="noopener">Goldberg &amp; Nivre 2012</a>)。我怀疑从结构化预测中还会吸取更多教训。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://zhuanlan.zhihu.com/p/110794460" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/110794460</a></p><p><a href="https://homes.cs.washington.edu/~jkasai/2020-01-28/nat/" target="_blank" rel="noopener">https://homes.cs.washington.edu/~jkasai/2020-01-28/nat/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本篇博客针对当前使用&lt;strong&gt;非自回归&lt;/strong&gt;方式处理&lt;strong&gt;机器翻译&lt;/strong&gt;任务的相关论文进行总结。&lt;/
      
    
    </summary>
    
      <category term="NLP" scheme="http://yoursite.com/categories/NLP/"/>
    
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>The multimodality problem in NAT</title>
    <link href="http://yoursite.com/2021/06/07/The-multimodality-problem-in-NAT/"/>
    <id>http://yoursite.com/2021/06/07/The-multimodality-problem-in-NAT/</id>
    <published>2021-06-07T02:40:43.000Z</published>
    <updated>2021-06-07T03:22:24.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="multimodality-problem"><a href="#multimodality-problem" class="headerlink" title="multimodality problem"></a>multimodality problem</h2><p>非自回归神经机器翻译系统(NAT)通过打破自回归性，并行地生成所有目标词，大幅度地提高了推断速度。然而，现有的NAT模型由于<strong>多峰问题</strong>，与自回归神经网络机器翻译模型相比，翻译质量仍有很大差距。</p><p><strong><strong style="color:red;">什么是多峰问题</strong></strong>，举个简单的例子将汉语句子“干/得/好/！”翻译成英文，可以翻译成“Good job !”或者“Well done !”。由于<strong style="color:blue;">非自回归模型</strong>的条件独立性假设，推断时第一个词“Good”和“Well”的概率是差不多大的，如果第二个词“job”和“done”的概率也差不多大，会使得模型生成出“Good done !”或者“Well job !”这样错误的翻译。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;multimodality-problem&quot;&gt;&lt;a href=&quot;#multimodality-problem&quot; class=&quot;headerlink&quot; title=&quot;multimodality problem&quot;&gt;&lt;/a&gt;multimodality problem&lt;/
      
    
    </summary>
    
      <category term="NLP" scheme="http://yoursite.com/categories/NLP/"/>
    
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>最新机器翻译进展</title>
    <link href="http://yoursite.com/2021/06/07/%E6%9C%80%E6%96%B0%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91%E8%BF%9B%E5%B1%95/"/>
    <id>http://yoursite.com/2021/06/07/最新机器翻译进展/</id>
    <published>2021-06-07T02:10:19.000Z</published>
    <updated>2021-06-07T02:41:40.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AAAI-2021"><a href="#AAAI-2021" class="headerlink" title="AAAI  2021"></a>AAAI  2021</h2><p>在 AAAI2021 上同样涌现了许多关于机器翻译任务的研究工作，几乎所有的工作都是基于Transformer模型展开讨论。这里对机器翻译在AAAI2021上的最新研究进展进行总结：</p><h2 id="1-引入语法信息"><a href="#1-引入语法信息" class="headerlink" title="1. 引入语法信息"></a><strong>1. 引入语法信息</strong></h2><p>尽管依托于模型本身本文就能从海量数据中捕获到语言之间的映射关系，但研究人员一直在探索如何将句法、语义等先验知识有效地融入到模型中，并指导模型取得进一步的性能突破。传统的做法通常使用外部工具从训练样本中构造句法树等先验知识，之后在编码端、解码端分别融入先验知识。SyntAligner[1]采取一种自监督双语句法对齐方法，让模型在高维空间中对源语-目标语的句法结构进行精确对齐，从而最大限度地利用对齐后的句法结构之间的互信息提高翻译的性能。</p><blockquote><p>Self-supervised Bilingual Syntactic Alignment for Neural Machine Translation</p></blockquote><h2 id="2-无监督机器翻译"><a href="#2-无监督机器翻译" class="headerlink" title="2. 无监督机器翻译"></a><strong>2. 无监督机器翻译</strong></h2><p>无监督机器翻译同样是机器翻译中备受关注的研究热点。在现实世界中，除了部分富资源语言（如英语，汉语，德语，俄语，印地语等），更多的语言本身受众较小，缺乏海量的双语平行语料进行监督学习。因此，如何在这种资源匮乏，甚至零资源的条件下，学习语言之间的映射是极具挑战的。目前无监督机器翻译通常采用迭代式的back-translation。此外，利用预训练的技术手段能够有效地加快模型的收敛，提高翻译的正确性。[2]通过在构造伪数据的过程中对合成的句子进行正则化约束能够有效地改善翻译的性能。</p><blockquote><p>Empirical Regularization for Synthetic Sentence Pairs in Unsupervised Neural Machine Translation</p></blockquote><h2 id="3-多语言翻译"><a href="#3-多语言翻译" class="headerlink" title="3. 多语言翻译"></a><strong>3. 多语言翻译</strong></h2><p>伴随着机器翻译的发展，研究人员逐渐开始探索不局限于双语句对之间的翻译。多语言模型通过一个模型实现多个语种之间的翻译能够有效降低多语言翻译部署成本。同时将一种源语言翻译成多种不同的目标语言是多语言翻译最常见的场景之一。SimNMT[3]提出了一种同步交叉交互解码器，即在每个目标语生成时，可以依赖未来的信息，以及其他目标语言的历史和未来的上下文信息，充分利用语言内与语言间的信息。</p><h2 id="4-语音翻译"><a href="#4-语音翻译" class="headerlink" title="4. 语音翻译"></a><strong>4. 语音翻译</strong></h2><p>语音翻译直接将源语的语音翻译成目标语言的文本。传统的方法中，采用语音识别和机器翻译级联的方法来解决这一问题。但是具有延迟高，占用存储大，以及容易产生错误累积的问题，很多工作开始关注直接使用端到端的语音到文本的模型来解决这一问题。对于跨模态之间的语言映射，为了让单一的模型充分学习模态之间的关联信息，往往需要引入更多的跨模态和跨语言的特征，造成了沉重的负担，同时单纯的用于端到端模型的语音到文本数据较少，无法充分利用语言识别和机器翻译的数据。为了解决这些问题，COSTT[4]作为一种通用的框架同时结合了级联模型与端到端模型的优点，能够更好地利用大规模双语平行语料，在多个测试集上取得了最优的效果。</p><p>同声传译是一种实时的语言翻译场景，对翻译时延的要求更加严格。目前主流的手段是采用Wait-K策略，但仍然存在由于重复编码导致的训练慢，以及缺少对未来信息建模的问题。Future-guided Training[5]采取unidirectional Transformer方式来避免重复编码，并引入averaged embedding来满足当前词与过去词之间的信息交互。同时利用知识精炼的手段让网络充分利用未来的信息，从而达到更准确的预测。</p><h2 id="5-领域适应"><a href="#5-领域适应" class="headerlink" title="5. 领域适应"></a><strong>5. 领域适应</strong></h2><p>在神经机器翻译中，通过微调来做领域的迁移是一种常见的方法。但是，无约束的微调需要非常仔细的超参数调整，否则很容易在目标域上出现过拟合，导致在通用领域上的性能退化。PRUNE-TUNE[6]是一种基于渐变修剪的领域适应算法。它学习微小的特定于领域的子网以进行调优，通过调整它相应的子网来适应一个新的领域。有效缓解了在微调过中的过拟合和退化问题。</p><p>此外，领域适应与其他方法相结合也是研究的一个热点。元学习对于低资源神经机器翻译(NMT)的有效性已经得到了充分的验证。但是元训练的NMT系统在未见领域中的翻译性能仍然较差。Meta-Curriculum Learning[7]是一种新的面向领域适应的元课程学习方法。在元训练过程中，NMT首先从各个领域学习相似的知识，以避免早期陷入局部最优，最后学习针对不同领域学习个性化的知识，以提高模型对领域特定知识学习的鲁棒性。</p><h2 id="6-解码加速：轻量模型-非自回归解码"><a href="#6-解码加速：轻量模型-非自回归解码" class="headerlink" title="6. 解码加速：轻量模型/非自回归解码"></a><strong>6. 解码加速：轻量模型/非自回归解码</strong></h2><p>过参数化的（超大规模）模型能够有效提升神经机器翻译的性能，但是庞大的存储开销和高昂的计算复杂度使得这类模型无法直接部署到边缘设备(如手机，翻译笔，离线翻译机等)上。早期为了提高模型对未登录词的覆盖度往往使用更大的词表，同时增大了词嵌入矩阵的存储开销，以及构建词表上概率分布时对计算资源的消耗。针对该问题，Partial Vector Quantization[8]提出了一种部分矢量量化的方法，通过压缩词嵌入降低softmax层的计算复杂度，同时使用查找操作来替换softmax层中的大部分乘法运算，在保障翻译质量的同时大大减少了词嵌入矩阵的参数和softmax层的计算复杂度。</p><p>近期，深层模型在神经机器翻译中取得突破性进展，但伴随着层数的堆叠同样面临上述问题。GPKD[9]中提出一种基于群体置换的知识蒸馏方法将深层模型压缩为浅层模型，该方法可以分别应用与编码端与解码端达到模型压缩和解码加速的目的。文中探讨了一种深编码器-浅解码器的异构网络， 其既能保证翻译的准确度，同时满足工业生产的推断时延需求。此外采用子层跳跃的正则化训练方法缓解随着网络加深带来的过拟合问题。</p><p>此外，沿着减少解码端计算复杂度的研究方向，例如Averaged Attention Network（ACL2018）和Sharing Attention Network（IJCAI2019），Compressed Attention Network[10]采取压缩子层的方式，将解码器每一层中分离的多个子层压缩成一个子层，进而简化解码端的计算复杂度，达到解码加速的目的。这种方式在深编码器-浅解码器的结构上取得了进一步的加速增益。</p><p>上述的工作通过轻量化模型提高推断速度，本质上在解码过程中还是采用自回归的方式。相比之下非自回归解码同样是一种有效的解码加速手段。非自回归神经机器翻译系统(NAT)通过打破自回归性，并行地生成所有目标词，大幅度地提高了推断速度。然而，现有的NAT模型由于<strong>多峰问题</strong>，与自回归神经网络机器翻译模型相比，翻译质量仍有很大差距。<strong>什么是多峰问题</strong>，举个简单的例子将汉语句子“干/得/好/！”翻译成英文，可以翻译成“Good job !”或者“Well done !”。由于非自回归模型的条件独立性假设，推断时第一个词“Good”和“Well”的概率是差不多大的，如果第二个词“job”和“done”的概率也差不多大，会使得模型生成出“Good done !”或者“Well job !”这样错误的翻译。ReorderNAT[11]提出一个新颖的NAT框架，通过显式地建模重排序信息来指导非自回归解码。区别于传统方法，根据源语的繁衍率来构造解码端的输入，ReorderNAT在编码器和解码器中间引入了重排序机制。该机制将源语的表示按照目标语的语序进行重新组合，减少解码器对语序的再加工。</p><h2 id="7-评测方法及应用"><a href="#7-评测方法及应用" class="headerlink" title="7. 评测方法及应用"></a><strong>7. 评测方法及应用</strong></h2><p>除了针对机器翻译系统的研究外，如何有效的评估机器翻译系统的性能也是一个重要的研究方向。通常情况下我们使用BLEU作为译文质量评估的常用指标，但是在很多应用场景中，并没有可以对比的参考译文。机器翻译质量评估(QE)便是在不依赖任何参考译文的情况下预测机器翻译质量的一项任务。在QE任务中，通常使用预测器-估计器框架(Predictor-Estimator)。使用预训练的预测器作为特征提取器，再通过评估器对译文进行评估。但是预测器和估计器在训练数据和训练目标上都存在差距，这使得QE模型不能更直接地从大量平行语料库中受益。<strong>DirectQE</strong>[12]中提出了一个新框架，通过生成器在构造QE伪数据，使用额外的探测器在生成的数据上进行训练，并为QE任务设定了新的学习目标，将原本分离的过程进行整合。</p><p>同样机器翻译本身也可以作为工具应用于其他的任务。研究人员为了解决问答任务的数据稀缺问题，通过机器翻译方法来构造多语言问答数据[13]。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <strong>Self-supervised Bilingual Syntactic Alignment for Neural Machine Translation</strong></p><p>[2] Empirical Regularization for Synthetic Sentence Pairs in Unsupervised Neural Machine Translation</p><p>[3] Synchronous Interactive Decoding for Multilingual Neural Machine Translation</p><p>[4] Consecutive Decoding for Speech-to-text Translation</p><p>[5] Future-Guided Incremental Transformer for Simultaneous Translation</p><p>[6] Finding Sparse Structure for Domain Specific Neural Machine Translation</p><p>[7] Meta-Curriculum Learning for Domain Adaptation in Neural Machine Translation</p><p>[8] Accelerating Neural Machine Translation with Partial Word Embedding Compression</p><p>[9] Learning Light-Weight Translation Models from Deep Transformer</p><p>[10] An Efficient Transformer Decoder with Compressed Sub-layers</p><p>[11] <strong>Guiding Non-Autoregressive Neural Machine Translation Decoding with Reordering Information</strong></p><p>[12] <strong>DirectQE: Direct Pretraining for Machine Translation Quality Estimation</strong></p><p>[13] Multilingual Transfer Learning for QA Using Translation as Data Augmentation</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AAAI-2021&quot;&gt;&lt;a href=&quot;#AAAI-2021&quot; class=&quot;headerlink&quot; title=&quot;AAAI  2021&quot;&gt;&lt;/a&gt;AAAI  2021&lt;/h2&gt;&lt;p&gt;在 AAAI2021 上同样涌现了许多关于机器翻译任务的研究工作，几乎所有的工作
      
    
    </summary>
    
      <category term="NLP" scheme="http://yoursite.com/categories/NLP/"/>
    
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>Masked Non-Autoregressive Image Captioning</title>
    <link href="http://yoursite.com/2021/06/06/Masked-Non-Autoregressive-Image-Captioning/"/>
    <id>http://yoursite.com/2021/06/06/Masked-Non-Autoregressive-Image-Captioning/</id>
    <published>2021-06-06T06:53:49.000Z</published>
    <updated>2021-06-06T08:21:43.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>以 Non-Autoregressive 的方式来做 Image Captioning</p><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><ul><li><p>自回归的方式做生成任务存在的问题</p><p>自回归解码导致了一些问题，如连续的错误积累、生成缓慢、不恰当的语义和缺乏多样性。 </p><p><strong>顺序解码很容易从训练数据中 copy tokens 来提高语法准确性</strong>，这很容易造成语义错误，而且在图像字幕的生成方面缺乏多样性。</p></li><li><p>非自回归的方式</p><p>非自回归解码已被提出来解决神经机器翻译（NMT）的生成速度较慢的问题。但直接应用到多模态描述生成任务上不是很直接：由于对真实目标分布的间接建模，不可避免地引入了另一个问题，被称为 “多模态问题”。</p><p>多模态问题【网络】：一种特殊的<strong>问题</strong>，其中不存在唯一的全局解决方案。可以在搜索空间周围找到多个全局优化或一个具有多个局部优化（或峰值）的全局优化。即，一对多问题。</p><p>多模态问题【本文】：完全的条件独立会导致对真实目标分布的近似度低。complete conditional independence results in the poor approximation to the true target distribution。</p></li></ul><h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><p>本文提出 masked non-autoregressive decoding 来解决 自回归解码 和 非自回归解码 中存在的问题。</p><ul><li><p>训练阶段</p><p>对于输入句子，以几种 （K） 比例进行掩码。</p></li><li><p>在推理阶段</p><p>在推理过程中，从一个<strong>完全被掩盖</strong>的序列到一个<strong>完全没有被掩盖</strong>的序列，以一种合成的方式，分几个 （K） 阶段平行地生成字幕。</p></li></ul><p>实验证明，我们提出的模型可以更有效地保留语义内容，并可以生成更多样性的标题。</p><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p><img src="https://i.loli.net/2021/06/06/GagfcOSPqskTiEW.png" alt="image-20210606152813892"></p><h3 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h3><p>使用CNN提取的特征图，或者是 使用目标检测器检测得到的 object features.</p><h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><p>与传统的Tansformer 来做seq-to-seq 是一样的，只是移去了 decoder的 autoregressive mask ， 即decoder 中的每个token，是双向attention。</p><h3 id="Masked-non-autoregressive-decoding"><a href="#Masked-non-autoregressive-decoding" class="headerlink" title="Masked non-autoregressive decoding"></a>Masked non-autoregressive decoding</h3><p>如图1</p><p>训练阶段，以 K 种比例进行掩码，比如 K = [1, 0.6, 0.2],其中 k=1, 代表全部掩码</p><p>测试阶段，使用 K stage，从全部掩码到部分掩码，来一步一步的优化caption。</p><details><summary>细节-增强鲁邦性</summary>我们还以一定比例的随机词来替代 [MASK] token 或 ground-truth token。 在我们的实验中，由于标题的长度相对较短，我们只是在每个非完全屏蔽的输入序列中用一个随机的词替换一个词。 使用随机词可以增强标记的上下文表示，并通过在训练期间引入噪声标记来提高推理过程的稳健性，因为模型在推理的早期阶段很容易产生错误的标记。</details><h3 id="作者分析"><a href="#作者分析" class="headerlink" title="作者分析"></a>作者分析</h3><p>我们提供了更多的分析和讨论，关于模型在不同比例的掩蔽序列中所学习的内容，以及模型在推理过程中不同阶段的预测。 我们进一步讨论了自回归和屏蔽式非自回归解码之间的内在差异。</p><ul><li><p>在训练阶段</p><ul><li>掩码的比例大时，会输出视觉单词</li><li>掩码的比例小时，会对语法进行修正</li></ul></li><li><p>在测试阶段</p><p>在推理过程中，the masked non-autoregressive 解码过程很好地反映了模型在训练过程中所学习的内容。 在早期阶段，该模型倾向于在语言组织较差的图像中生成包含高频率（如 “a”、”on”）和突出的视觉线索（如物体、颜色名词和重要动词）的caption，而在后期阶段，该模型可以通过采用训练好的双向语言模型来选择最合适的词来连接子序列的两边，从而生成语义和语法上正确的标题。 如图1 </p></li><li><p>自回归和屏蔽式非自回归解码之间的内在差异</p><p>在推理过程中，自回归解码和掩码非自回归解码的区别在于掩码非自回归解码自然接近人类的语言生成。更具体地说，人类首先在大脑中生成视觉场景的关键词，然后选择其他词来连接不同的部分，并按照语言规则组成整个句子。这是一个<strong>先视觉再语言</strong>的生成过程，视觉信息奠定了字幕的基础，语言信息辅助以组合的方式而不是顺序的方式形成最终的字幕，这样会更好地保留有意义的语义信息。<strong>掩码非自回归解码一步生成整个句子，因此前面标记的质量不会显着影响后面的标记，这从根本上缓解了自回归解码中存在的顺序错误累积</strong>。相比之下，自回归解码是一个从左到右逐字的生成过程，因此后面步骤生成的标记在很大程度上取决于前面步骤的标记，一旦前面的标记不合适，就容易出现顺序错误累积。更糟糕的是，它只有一次机会生成整个标题，而无法调整前面不适当的标记。因此，自回归解码在保持流畅性方面相当不错，但难以准确说出图像丰富的显着语义内容。</p></li></ul><h2 id="Inference-rules"><a href="#Inference-rules" class="headerlink" title="Inference rules"></a>Inference rules</h2><ul><li><p>推理阶段每个 stage, 如何确定mask 哪些token？或者保留哪些token ?</p><p><strong>保留信息量最大的 token</strong> 并屏蔽每个阶段生成的字幕中的其他位置以生成新的屏蔽输入序列至关重要。</p><p>在本文中，我们采用了一种直接的方法。在这种方法中，在这种方法中，那些不包括在高频率的标记集中的 tokens (tf-idf的思想) ，以及具有高概率且与迄今所选标记不重复的 tokens ，被指定为高度优先保留的 tokens 。例如，在图 <a href="https://www.arxiv-vanity.com/papers/1906.00717/#S3.F1" target="_blank" rel="noopener">1中</a>，我们保留了第一阶段输出序列的 “二”、“鸭子”、“游泳” 和“水”。此外，对最后阶段生成的 caption 进行处理，选择与之前选择的 tokens 不重复的 tokens 。 </p></li><li><p>推理阶段，caption的长度是如何确定的？</p><p>关于推理过程中 length of caption 的确定, 我们首先计算训练数据中的长度的分布情况，然后从这个分布中选择一个随机的长度 T 作为标题。 随后。由T个 [MASK] token 组成的序列被送入模型，这样，一个完整的标题就可以最终被解码。 另一个选择是，我们直接为所有图像设置一个固定的序列长度。 该模型将根据长度自动强制生成粗略或精细的标题，但具有类似的语义信息。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h2&gt;&lt;p&gt;以 Non-Autoregressive 的方式来做 Image Captioning&lt;/p&gt;
&lt;h2 id=&quot;存在的问题&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="cross-modal" scheme="http://yoursite.com/categories/cross-modal/"/>
    
    
      <category term="cross-modal" scheme="http://yoursite.com/tags/cross-modal/"/>
    
  </entry>
  
  <entry>
    <title>Mask-Predict: Parallel Decoding of Conditional Masked Language Models</title>
    <link href="http://yoursite.com/2021/06/06/Mask-Predict-Parallel-Decoding-of-Conditional-Masked-Language-Models/"/>
    <id>http://yoursite.com/2021/06/06/Mask-Predict-Parallel-Decoding-of-Conditional-Masked-Language-Models/</id>
    <published>2021-06-06T06:38:51.000Z</published>
    <updated>2021-06-06T06:45:31.307Z</updated>
    
    <content type="html"><![CDATA[<p>Facebook发表在EMNLP 2019上的工作</p><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>机器翻译</p><h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><p>非自回归的生成方式</p><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p>这篇文章将masked language model和iterative refinement进行了结合。并提出了更精确的解码方法。</p><p>具体来说，在训练时，这篇文章采用了和masked language model一样的设定。即，随机mask掉目标语句中的一些单词作为decoder input，mask的策略也和Bert中的一致。而decoder output则是这些位置上被mask掉的原始单词。其中，与Bert对每个句子固定mask掉15%的单词不同的是，这篇文章中被mask单词的数目是在从1到句子长度的范围中随机选取的。这样做的好处会在decoding时显现出来。</p><p><img src="https://i.loli.net/2021/06/06/bBgAcQlLFVSt6Es.jpg" alt="img"></p><p>图二：Mask-Predict 解码示意图</p><p>在预测时，这篇文章提出了基于mask and predict的解码方法，是文章的主要贡献。其实在masked language model这个框架下，解码方法是水到渠成的，即每次迭代时，都在当前翻译结果上mask掉一些词，再预测这些词即可。这里有几个点需要特别考虑。一是如何决定mask掉哪些词。文中给出的解决方法是选取top k个解码时置信度最小的词，把他们mask掉再重新预测。二是如何确定mask掉多少个词，也就是如何选取k。文中给出了基于迭代次数递减的策略，即<strong>在第一次解码时，将所有位置都置为[MASK]</strong>，同时预测所有位置的词。<strong>在之后解码迭代中，按照随迭代次数线性衰减的方式确定需要mask的单词个数</strong>：</p><p>$n=N \cdot \frac{T-t}{T}$</p><p>其中N是目标语句的长度，T和t则分别是总的迭代次数和当前迭代次数。上图中展示了解码过程的一个例子。</p><p>上面提到对每个句子，训练时每个epoch确定被mask单词数目时都是随机从 [1，句子长度] 中选取得到的。由于在解码时，被mask单词的个数是线性递减的，即会从 [句子长度，1] 依次递减。因此，训练时这样选取被mask单词的数目可以增加模型的capacity，让模型能处理任意个单词被mask掉时的情况，从而更符合解码时的策略，减少bias并达到更好的效果。</p><p>在确定目标语句的长度时，这篇文章采用了与上篇文章相同的方法，即通过encoder output来预测目标语句的长度，和golden目标语句的长度作为额外的loss function单独训练。</p><h2 id="Results"><a href="#Results" class="headerlink" title="Results"></a><strong>Results</strong></h2><p><img src="https://i.loli.net/2021/06/06/xongXjtwZciSe42.jpg" alt="img" style="zoom:50%;"></p><p>从上表中可以看到，这篇文章在WMT14 En-De和WMT16 En-Ro上均达到了SOTA。但有一点存疑的是，由于文章中也采用了knowledge distillation来训练non-autoregressive模型，而其采用的autoregressive teacher模型均为比较强的模型（28.6 on WMT14 En-De and 34.28 on WMT16 En-Ro），没有控制变量采用和baseline相同效果的autoregressive teacher。而一般来说，teacher越强训练出的non-autoregressive模型也会越强，因此<strong>这篇文章良好的效果应该也有一部分是得益于其选择了较强的teacher</strong>。</p><p>文中也做了在WMT17 En-Zh上的实验，以及对迭代次数和mutiple length candidates的分析，这里就不一一赘述了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Iterative refinement无疑是一个改善 $O(1)$非自回归模型的良好方向，在增加了有限的复杂度（通常是 $O(10)$)的代价下，非自回归模型的翻译质量得到了大幅提高。在这个方向中， Mask-Predict这篇文章给出了一个优良的解码范例，即每次迭代并不会预测所有的单词，而是预测置信度较低的数个单词。</p><p>但这样的解码范例也可能并不是最优的。因为模型给出的概率上的置信度有时候并不会反应真正的翻译质量。如何证明/设计与翻译质量挂钩的解码策略也是一个值得思考的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Facebook发表在EMNLP 2019上的工作&lt;/p&gt;
&lt;h2 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h2&gt;&lt;p&gt;机器翻译&lt;/p&gt;
&lt;h2 id=&quot;本文的点&quot;&gt;&lt;a href=&quot;#本文的点
      
    
    </summary>
    
      <category term="NLP" scheme="http://yoursite.com/categories/NLP/"/>
    
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>Improving Neural Machine Translation with Soft Template Prediction</title>
    <link href="http://yoursite.com/2021/06/06/Improving-Neural-Machine-Translation-with-Soft-Template-Prediction/"/>
    <id>http://yoursite.com/2021/06/06/Improving-Neural-Machine-Translation-with-Soft-Template-Prediction/</id>
    <published>2021-06-06T01:51:58.000Z</published>
    <updated>2021-06-06T04:11:11.576Z</updated>
    
    <content type="html"><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>机器翻译</p><h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><p>受到人类翻译过程和其他领域基于模板和基于语法的方法启发，微软亚洲研究院提出了一种使用<strong>从语法树结构中提取的模板</strong>作为<strong>软目标模板</strong>来指导翻译过程的方法 ST-NMT。</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>尽管近年来神经机器翻译（NMT）取得了长足的进步，但大多数神经机器翻译模型直接从源文本生成翻译。受到人类翻译过程和其他领域基于模板和基于语法的方法的成功启发，我们提出了一种使用从语法树结构中提取的模板作为软目标模板来指导翻译过程的方法。为了学习目标句子的句法结构，我们采用语法分析树来生成候选模板，并将模板信息融合到编码器-解码器框架中，同时利用模板和源文本生成翻译。实验表明，我们的模型在四个数据集上明显优于基线模型，证明了软目标模板的有效性。</p><h2 id="软模板预测"><a href="#软模板预测" class="headerlink" title="软模板预测"></a>软模板预测</h2><p>近年来，神经机器翻译取得了巨大的进步，但常规的神经机器翻译模型一般直接把源语言文本翻译到目标语言文本。但实际上，我们知道人类在翻译一句话时通常是先对目标文本的句型或者结构有一个大致的想法，然后再将源语言文本翻译成为目标语言文本，并不是直接逐词进行翻译。</p><p>通常我们在进行造句训练的时候，最开始老师会教给我们一些句型，例如 “sb. like doing sth; There be…” 等，然后让我们做练习。下图是一个中英翻译训练教材的内容，要求根据以下句型将中文翻译到英文。</p><p><img src="https://i.loli.net/2021/06/06/ipqb2FWnoZxsufz.png" alt="img" style="zoom:50%;"></p><p><em>图1：中英翻译训练教材内容</em></p><p>受到人类翻译过程的启示，我们提出了使用从句法分析树提取模板作为软目标语言模板来指导翻译过程的方法。为了学习目标句子的句法结构，我们采用句法分析树来生成候选模板。如图2所示，我们首先根据源语言文本预测将要用到的目标语言的模板，这里 “我喜欢打篮球”，很容易想到 “sb. like doing sth” 这个句型，随后我们根据源语言和模板来生成翻译。</p><p><img src="https://i.loli.net/2021/06/06/UnaNz1vmtAidhTQ.png" alt="img" style="zoom:50%;"></p><p><em>图2：使用软目标模板指导翻译过程示例</em></p><p>基于这一核心思想以及模板方法在机器摘要、问答和其他文本上取得的成功。我们假设目标句子的候选模板可以指导句子翻译过程。我们将这些从句法分析树中提取的模板作为软模板，由 S, NP, VP 这些具有句子结构信息和目标语言组成。这里模板是“软 (soft) ”的，因为我们<strong>并不强制要求生成的目标语言翻译一定是完全基于模板来生成</strong>，这里的模板仅仅是提供一种参考来对翻译提供一定的帮助。</p><p>为了更有效地使用软模板，我们引入了基于目标语言软模板的神经机器翻译模型 (Soft Template-based NMT，ST-NMT)，它可以使用源文本和软模板来预测最终的翻译。我们的方法可以分为两个阶段。在第一阶段，通过使用源文本和从句法分析树中提取的模板，训练一个标准的 Transformer 模型来专门预测软目标模板。在第二阶段，我们使用两种编码器，包括软目标模板编码器和源语言编码器，以对源文本和模板进行编码并生成最终翻译。</p><h2 id="目标软模板预测"><a href="#目标软模板预测" class="headerlink" title="目标软模板预测"></a>目标软模板预测</h2><p><img src="https://i.loli.net/2021/06/06/MSToYB93vDrqCwz.png" alt="img" style="zoom:50%;"></p><p><em>图3：从分析树中抽取模板</em></p><p>在此过程中，通过使用源语言 S 和模板 T 数据，我们对 P(T|X) 建模，使得我们能够根据源语言对模板进行预测。为了构造源语言-模板数据集，我们使用句法分析树来解析目标语言文本并获得树形结构。然后，我们裁剪超过一定深度的节点，并将裁剪后的子树按照原有顺序还原回去得到模板数据。通过这些操作，我们获得了源语言-模板平行训练数据，并训练了 Transformer 模型 P(T|X) 来预测软目标模板。</p><p>语法解析树可以显示整个句子的结构和语法信息，利用语法来区分终端（terminal nodes）和非终端节点（non-terminal nodes）。更确切地说，非终端节点由属于非终端节点集合 S，而终端节点属于目标语言节点集合 V。S={V, VP, NP, …, ASBR} 等代表语法成分的标记和 V={There, are, …, people} 包含目标语言单词。如 图3 所示，句子“有人在奔跑”通过语法解析树生成树形结构。在这种情况下，非终端节点集合S0={S, NP, VP, EX, VBP, NP, DT, NNS, VBG} 和终端节点集合 V0={There, are, some, people, running}。我们的模板 T={t1, t2, t3, t4} 是有序序列，由终端节点和非终端节点组成。在这种情况下，t1=There, t2=are, t3=VP, t4=NP。我们的模板是提取特定深度的子树，并使用位于子树的叶节上的终端和非终端节点来生成模板。</p><p>为了预测软目标模板，我们根据源文本和提取的模板的训练数据来训练一个Transformer 模型。Transformer 模型读取源文本，并使用束搜索预测软目标模板。然后，我们选择束搜索的前 K 个结果作为模板。</p><p><strong>选择子树的深度是一个权衡。在图3中，当深度等于1是一种特殊的情况，此时模板仅具有一个符号 S。模板 S 无法提供任何有用的信息。另一个特殊情况是当深度大于6时，“There are some people running” 此时模板只有终端节点。该模板仅包含目标语言单词，不能提供任何其他信息。而当深度等于4时，模板为 “There are VP NP”。该模板包含句子句法和结构信息，适用于我们的方法。</strong></p><p>使用 Transformer 模型 P(T|X)，我们需要构造伪训练数据(源语言文本、目标语言文本、目标软模板)，而不是通过语法分析树直接提取的模板。给定源文本 X，我们使用 P(T|X) 通过束搜索来生成排名靠前的目标语言软模板 T。最后，我们得到三元组训练数据 (源语言文本、目标语言文本、软模板）为下一阶段做准备。</p><h2 id="ST-NMT模型"><a href="#ST-NMT模型" class="headerlink" title="ST-NMT模型"></a>ST-NMT模型</h2><p>我们的模型首先通过源语言 Transformer 编码器以读取源语言序列 X=(x1, x2, x3, …, xn)并生成模板序列 T=(t1, t2, t3, …, tm) 由模板 Transformer 解码器提供。如图3所示，我们的模型使用源语言 Transformer 编码器和模板 Transformer 编码器，分别对源语言序列 X 和模板序列 T 进行编码，最终解码器生成最终翻译。我们的方法主要包括两个阶段：（1）训练数据由基于选区的解析树构造。然后，我们采用标准的 Transformer 将源文本转换为下一代软目标模板。（2）基于源文本和预测的软目标模板，我们使用两个编码器分别将两个序列编码为隐藏状态，并使用目标语言解码器生成最终翻译。</p><p><img src="https://i.loli.net/2021/06/06/Lz1C5HU7uFwle6K.png" alt="image-20210606102157632"></p><p><em>图4：ST-NMT 模型</em></p><p>给定三元组训练数据（源语言文本，目标语言文本，软模板）后，我们使用源语言文本和软模板生成目标语言文本如下公式。源语言 Transformer 编码器和软模板Transformer 编码器将输入序列 X 和由目标语言单词和非终端节点组成的模板 T 映射到隐层向量。然后，与两个编码器交互的 Transformer 解码器生成最终翻译 Y，即：</p><p><img src="https://i.loli.net/2021/06/06/qFu6TDtBbhQOXnf.png" alt="image-20210606102328094" style="zoom: 33%;"></p><p>基于源语言编码器隐藏层状态和软模板编码器隐藏层状态，目标语言 Transformer 解码器使用编码器-解码器多头注意共同使用源语言和模板信息来生成最终翻译 Y。此外，目标序列解码器使用两组注意力机制参数用于不同的编码器。解码器分别使用源语句上下文 X=(x1, …, xm)和目标模板上下文 T=(t1, …, tn)，然后我们的模型通过关注源上下文和模板上下文获得两个隐藏状态,在这里，我们使用门控单元融合了包含源语言信息的隐藏层状态和包含模板信息的隐藏层状态，如下所示：</p><p><img src="https://i.loli.net/2021/06/06/2omSktuZxNEUYeC.png" alt="image-20210606111455578" style="zoom:50%;"></p><p><img src="https://i.loli.net/2021/06/06/F4RvzfdciHe3Jr8.png" alt="image-20210606111502794" style="zoom:50%;"></p><p>与常规 NMT 相似，为了使模型能够预测目标序列，我们使用最大似然估计来更新模型参数。当我们在不使用模板 Transformer 编码器的情况下训练 P(Y|X) 时，我们仅需要优化以下损失函数:</p><p><img src="https://i.loli.net/2021/06/06/BZDHSQC19LhXlOA.png" alt="image-20210606120505997" style="zoom:50%;"></p><p>我们使用模板 Transformer 编码器训练 P(Y|X,T) 时，损失函数可以通过以下公式计算：</p><p><img src="https://i.loli.net/2021/06/06/kvnLlAHoF42XbcG.png" alt="image-20210606120523147" style="zoom:50%;"></p><p>在实践中，我们发现优化这两个目标可以使得模型更易于训练避免收到模板中噪声的干扰，并获得较高的 BLEU 分数，因为存在一些影响翻译质量的低质量模板。<strong>通过同时优化两个目标，我们可以减少某些低质量模板的影响并提高模型的稳定性。</strong>为了平衡这两个目标，我们的模型在两个目标上同时进行了迭代训练，如下所示：</p><p><img src="https://i.loli.net/2021/06/06/BrkEVRDWHZen41L.png" alt="image-20210606120604504" style="zoom:50%;"></p><h2 id="实验与分析"><a href="#实验与分析" class="headerlink" title="实验与分析"></a>实验与分析</h2><p>为了证明该方法的有效性，我们在多个数据集和多个语种进行了实验，包括 IWSLT14 德语-英语翻译任务，WMT14 英语-德语翻译任务，LDC 中英翻译任务和 ASPEC 日中翻译任务。实验表明，与基线模型相比，我们的方法取得了更好的结果，这表明软目标模板可以有效地指导翻译过程并提供积极的影响。同时我们的方法可用于不同规模、不同语种、不同领域的数据集。</p><p><img src="https://i.loli.net/2021/06/06/EfX8xaJeFYLzpDb.png" alt="image-20210606120732113" style="zoom:50%;"></p><p><em>表1：LDC 中英翻译任务结果</em></p><p><img src="https://i.loli.net/2021/06/06/19RGWj5xsK7HzXV.png" alt="image-20210606120755429" style="zoom: 50%;"></p><p><em>表2：WMT14 英语-德语翻译任务结果</em></p><p><img src="https://i.loli.net/2021/06/06/2HjICRYAgV9db5L.png" alt="image-20210606120824797" style="zoom:50%;"></p><p><em>表3：IWSLT14 德语-英语翻译任务结果</em></p><p><img src="https://i.loli.net/2021/06/06/e4hJ8gaKn3xmXwz.png" alt="image-20210606120844581" style="zoom:50%;"></p><p><em>表4：ASPEC 日中翻译任务结果</em></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这项工作中，我们提出了一种利用源文本和软模板生成翻译的机器翻译模型。我们的方法可以从子树中提取模板，该子树是从语法分析树的特定深度得到的。然后，我们使用 Transformer 模型来预测源文本的软目标模板。进一步，我们结合了源文本和模板信息来指导翻译过程。我们将软模板神经机器翻译模型（ST-NMT）与其他基线模型在多个数据集上进行比较。实验结果表明，ST-NMT 可以显著提高翻译性能。</p><h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><ul><li>其实也可以构造成 hard target, 强硬使其输出为对应的span</li><li>但是如果这样的话，soft target 是作为辅助信息，影响力 (&gt;=0)。如果使用强硬的，则影响力可能为&lt;0</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h2&gt;&lt;p&gt;机器翻译&lt;/p&gt;
&lt;h2 id=&quot;本文的点&quot;&gt;&lt;a href=&quot;#本文的点&quot; class=&quot;headerlink&quot; title=&quot;本文的点&quot;
      
    
    </summary>
    
      <category term="NLP" scheme="http://yoursite.com/categories/NLP/"/>
    
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>Frozen in Time: A Joint Video and Image Encoder for End-to-End Retrieval</title>
    <link href="http://yoursite.com/2021/05/29/Frozen-in-Time-A-Joint-Video-and-Image-Encoder-for-End-to-End-Retrieval/"/>
    <id>http://yoursite.com/2021/05/29/Frozen-in-Time-A-Joint-Video-and-Image-Encoder-for-End-to-End-Retrieval/</id>
    <published>2021-05-29T02:02:01.000Z</published>
    <updated>2021-05-29T02:33:06.447Z</updated>
    
    <content type="html"><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p> text-to-video-retrieval</p><h2 id="当前存在的问题"><a href="#当前存在的问题" class="headerlink" title="当前存在的问题"></a>当前存在的问题</h2><ul><li>这一领域的挑战包括: (1) 视觉结构的设计和 (2) 训练数据的性质，因为现有的大规模视频-文本训练数据集，如HowTo100M，是有噪声的，因此只有通过大量的计算才能实现有竞争力的性能。</li></ul><h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><ul><li>【训练使用的数据集】针对上述提到的问题，本文提出了一个端到端的可训练模型，该模型利用大规模的图像描述和视频描述数据集。该模型可以灵活的在图像-文本，视频-文本数据集上进行训练，可以是单独的方式或者是组合的方式。</li><li>【模型结构】本文提出的模型是对最近的ViT和Timesformer架构的改编和扩展，由空间和时间上的 attention 组成。</li><li>【训练方案】使用课程学习的训练方式（由易到难），开始时将图像视为视频的 “冻结 “快照，然后在视频数据集上训练时逐渐学会关注越来越多的时域上下文。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h2&gt;&lt;p&gt; text-to-video-retrieval&lt;/p&gt;
&lt;h2 id=&quot;当前存在的问题&quot;&gt;&lt;a href=&quot;#当前存在的问题&quot; class
      
    
    </summary>
    
      <category term="cross-modal" scheme="http://yoursite.com/categories/cross-modal/"/>
    
    
      <category term="cross-modal" scheme="http://yoursite.com/tags/cross-modal/"/>
    
  </entry>
  
  <entry>
    <title>[T5] Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer</title>
    <link href="http://yoursite.com/2021/04/28/T5-Exploring-the-Limits-of-Transfer-Learning-with-a-Unified-Text-to-Text-Transformer/"/>
    <id>http://yoursite.com/2021/04/28/T5-Exploring-the-Limits-of-Transfer-Learning-with-a-Unified-Text-to-Text-Transformer/</id>
    <published>2021-04-28T11:38:01.000Z</published>
    <updated>2021-06-02T02:41:50.709Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<a href="https://zhuanlan.zhihu.com/p/88438851" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/88438851</a></p><p>对于 T5 这篇论文，<em>Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer</em>，无疑也是类似的论文。它的意义不在烧了多少钱，也不在屠了多少榜（砸钱就能砸出来），其中 idea 创新也不大，它最重要作用是给<strong style="color:red;"><strong>整个 NLP 预训练模型领域提供了一个通用框架</strong></strong>，把所有任务都转化成一种形式，正如论文里所说的</p><blockquote><p>introducing a unified framework that converts every language problem into a text-to-text format.</p></blockquote><p>之后未来做 NLP 实验时，可能就不再是自己怎么调一些模型了，而是无论什么任务，直接拿来一个超大预训练模型，然后<strong style="color:red;"><strong>主要工作就变成了怎么把任务转换成合适的文本输入输出</strong></strong>，于是我们就成了带引号的”数据科学家“。而且可以用于多种任务，而模型对这些任务的区分只是根据你构建的输入输出形式，其实这让我想起 Jeff Dean 在某次谈话中谈到的谷歌未来方向，想做一个超级模型，什么任务都能直接处理，而它内部可以是稀疏的，或者可以局部 Distill，来对单独任务进行处理。</p><p>关于论文，作者们做了很多实验。将近七十个实验，这也是大家吐槽财大气粗的原因，太有冲击力了，小家小业的话估计跑里面个小实验就够呛了。</p><p>正因为如此多实验，所以才对预训练模型中的大量技巧获得了一个较公平的比对和分析，但这也使得整篇论文长度巨长，读起来头晕。不是 idea 的冲击，而都是些琐碎细节，看了几大段后发现，还是看图表一目了然。</p><p>这里就简单介绍一下里面做了哪些实验，之后各取所需回看论文。</p><h2 id="Why-Text-to-Text？"><a href="#Why-Text-to-Text？" class="headerlink" title="Why Text-to-Text？"></a>Why Text-to-Text？</h2><p>首先为什么叫 T5 模型，因为是 <strong>Transfer Text-to-Text Transformer</strong> 的简写，和 XLNet 一样也不在芝麻街玩了，也有说法是吐槽谷歌 <strong>T5 Level</strong>（高级软件工程师）。</p><p>Transfer 来自 Transfer Learning，预训练模型大体在这范畴，Transformer 也不必多说，那么 Text-to-Text 是什么呢。那就是作者在这提出的一个统一框架，靠着大力出奇迹，<strong>将所有 NLP 任务都转化成 Text-to-Text （文本到文本）任务</strong>。</p><p><img src="https://i.loli.net/2021/04/28/zSwycrjd2qkPGas.png" alt="image-20210428195223812"></p><p>举几个例子就明白了，比如英德翻译，只需将训练数据集的输入部分前加上“translate English to German（给我从英语翻译成德语）” 就行。假设需要翻译”That is good”，那么先转换成 “translate English to German：That is good.” 输入模型，之后就可以直接输出德语翻译 “Das ist gut.”</p><p>再比如情感分类任务，输入”sentiment：This movie is terrible!”，前面直接加上 “sentiment：”，然后就能输出结果“negative（负面）”。</p><p>最神奇的是，对于需要输出连续值的 STS-B（文本语义相似度任务），居然也是直接输出文本，而不是加个连续值输出头。以每 0.2 为间隔，从 1 到 5 分之间分成 21 个值作为输出分类任务。比如上图中，输出 3.8 其实不是数值，而是一串文本，之所以能进行这样的操作，应该完全赖于 T5 模型强大的容量。</p><p>通过这样的方式就能将 NLP 任务都转换成 Text-to-Text 形式，也就可以<strong>用同样的模型，同样的损失函数，同样的训练过程，同样的解码过程来完成所有 NLP 任务</strong>。其实这个思想之前 GPT2 论文里有提，上斯坦福 cs224n 时 Socher 讲的 The Natural Language Decathlon 也有提。</p><h2 id="Data：C4-（Bomb-）"><a href="#Data：C4-（Bomb-）" class="headerlink" title="Data：C4 （Bomb!）"></a>Data：C4 （Bomb!）</h2><p>作者从 Common Crawl（一个公开的网页存档数据集，每个月大概抓取 20TB 文本数据） 里清出了 750 GB 的训练数据，然后取名为 ” Colossal Clean Crawled Corpus （超大型干净爬取数据）“，简称 C4，论作者取名之恶趣味。</p><p>大概清理过程如下：</p><ul><li>只保留结尾是正常符号的行；</li><li>删除任何包含不好的词的页面，具体词表参考<strong><a href="https://link.zhihu.com/?target=https%3A//github.com/LDNOOBW/List-of-Dirty-Naughty-Obscene-and-Otherwise-Bad-Words" target="_blank" rel="noopener">List-of-Dirty-Naughty-Obscene-and-Otherwise-Bad-Words</a></strong>库（笔者按：宝藏库，到里面转了一圈，看了看熟悉的几门语言，瞬间涨了不少新姿势 ）；</li><li>包含 Javascript 词的行全去掉；</li><li>包含编程语言中常用大括号的页面；</li><li>任何包含”lorem ipsum（用于排版测试）“的页面；</li><li>连续三句话重复出现情况，保留一个。</li></ul><h2 id="Architecture：The-Best-One"><a href="#Architecture：The-Best-One" class="headerlink" title="Architecture：The Best One"></a><strong>Architecture：The Best One</strong></h2><p>首先作者们先对预训练模型中的多种模型架构（Transformer）进行了比对，最主要的模型架构可以分成下面三种。</p><p><img src="C:\Users\shiyaya\AppData\Roaming\Typora\typora-user-images\image-20210428195326843.png" alt="image-20210428195326843"></p><p>第一种，<strong>Encoder-Decoder 型</strong>，即 Seq2Seq 常用模型，分成 Encoder 和 Decoder 两部分，对于 Encoder 部分，输入可以看到全体，之后结果输给 Decoder，而 Decoder 因为输出方式只能看到之前的。此架构代表是 MASS（今年WMT的胜者），而 BERT 可以看作是其中 Encoder 部分。</p><p>第二种， 相当于上面的 <strong>Decoder 部分</strong>，当前时间步只能看到之前时间步信息。典型代表是 GPT2 还有最近 CTRL 这样的。</p><p>第三种，<strong>Prefix LM（Language Model） 型</strong>，可看作是上面 Encoder 和 Decoder 的融合体，一部分如 Encoder 一样能看到全体信息，一部分如 Decoder 一样只能看到过去信息。最近开源的 UniLM 便是此结构。</p><p>上面这些模型架构都是 Transformer 构成，之所以有这些变换，主要是<strong>对其中注意力机制的 Mask 操作</strong>。</p><p><img src="C:\Users\shiyaya\AppData\Roaming\Typora\typora-user-images\image-20210428195656637.png" alt="image-20210428195656637"></p><p>通过实验作者们发现，在提出的这个 Text-to-Text 架构中，Encoder-Decoder 模型效果最好。于是乎，就把它定为 T5 模型，因此<strong>所谓的 T5 模型其实就是个 Transformer 的 Encoder-Decoder 模型</strong>。</p><p>之后是对预训练目标的大范围探索，具体做了哪些实验，下面这张图就能一目了然。</p><p><img src="https://i.loli.net/2021/04/28/HGA86geR3s5JoOl.png" alt="image-20210428200712939"></p><p>总共从四方面来进行比较。</p><p>第一个方面，<strong>高层次方法（自监督的预训练方法）对比</strong>，总共三种方式。</p><ol><li><strong>语言模型式</strong>，就是 GPT-2 那种方式，从左到右预测；</li><li><strong>BERT-style 式</strong>，就是像 BERT 一样将一部分给破坏掉，然后还原出来；</li><li><strong>Deshuffling （顺序还原）式</strong>，就是将文本打乱，然后还原出来。</li></ol><p><img src="https://i.loli.net/2021/04/28/La7uURigVxpHzdG.png" alt="image-20210428200943309"></p><p>其中发现 Bert-style 最好，进入下一轮。</p><p>第二方面，对文本一部分进行<strong>破坏时的策略</strong>，也分三种方法。</p><ol><li><strong>Mask 法</strong>，如现在大多模型的做法，将被破坏 token 换成特殊符如 [M]；</li><li><strong style="color:red;"><strong>replace span（小段替换）法</strong>，可以把它当作是把上面 Mask 法中相邻 [M] 都合成了一个特殊符，每一小段替换一个特殊符，提高计算效率；</strong></li><li><strong>Drop 法</strong>，没有替换操作，直接随机丢弃一些字符。</li></ol><p><img src="https://i.loli.net/2021/04/28/swF3Ab4uBetv1Nf.png" alt="image-20210428201451717"></p><p>此轮获胜的是 <strong>Replace Span 法</strong>（如下图），类似做法如 SpanBERT 也证明了有效性。</p><p><img src="https://i.loli.net/2021/04/28/9gAnaOWSlmMbxCF.png" alt="image-20210428195311177"></p><p>当当当，进入下一轮。</p><p>第三方面，到底该<strong>对文本百分之多少进行破坏</strong>呢，挑了 4 个值，10%，15%，25%，50%，最后发现 BERT 的 <strong>15%</strong> 就很 ok了。这时不得不感叹 BERT 作者 Devlin 这个技术老司机直觉的厉害。</p><p>接着进入更细节，第四方面，因为 Replace Span 需要决定<strong>对大概多长的小段进行破坏</strong>，于是对不同长度进行探索，2，3，5，10 这四个值，最后发现 <strong>3</strong> 结果最好。</p><p>终于获得了完整的 T5 模型，还有它的训练方法。</p><p><img src="C:\Users\shiyaya\AppData\Roaming\Typora\typora-user-images\image-20210428201927674.png" alt="image-20210428201927674"></p><ul><li>Transformer Encoder-Decoder 模型；</li><li>BERT-style 式的破坏方法；</li><li>Replace Span 的破坏策略；</li><li>15 %的破坏比；</li><li>3 的破坏时小段长度。</li></ul><p>到此基本上 T5 预训练就大致说完了，之后是些细碎探索。</p><h2 id="Datasets"><a href="#Datasets" class="headerlink" title="Datasets"></a>Datasets</h2><p>接着作者们拿着 C4 数据集做了各种实验，比如说从里面分出各种类型的数据集，单独训练 T5 模型，之后看在下游任务的表现，发现一些情况<strong>领域内的预训练数据可以增强下游任务</strong>（想当然的）。而 C4 完整数据集因为数据太多太杂，可能反而不如这种领域内较少数据集。</p><p>还有从 C4 中抽出不同量数据做实验，发现<strong>数据少时，模型会记住数据所以之后表现会比较差</strong>（这个也是想当然）。</p><p><img src="https://i.loli.net/2021/04/28/8bgrwBkAYaWQTJp.png" alt="image-20210428202002738" style="zoom:67%;"></p><h2 id="Training：Multi-Task-Learning"><a href="#Training：Multi-Task-Learning" class="headerlink" title="Training：Multi-Task Learning"></a><strong>Training：Multi-Task Learning</strong></h2><p>作者们之后又针对 MTDNN 给 T5 做了一系列类似训练，在一堆监督和非监督数据上进行预训练。</p><p>结果发现，只要<strong>混合训练比例调得OK，和前面说的非监督预训练性能差不多</strong>。</p><h2 id="Scaling：bigger-is-better"><a href="#Scaling：bigger-is-better" class="headerlink" title="Scaling：bigger is better?"></a><strong>Scaling：bigger is better?</strong></h2><p>接着又做了当放大模型某方面规模的相关实验，分别是增大模型，增大数据，还有在一定资源限制下的集成。</p><p>结论是，当<strong>这些因素放大时对性能都有提高，但其中大模型是最必要的</strong>。</p><h2 id="Models"><a href="#Models" class="headerlink" title="Models"></a><strong>Models</strong></h2><p>最后就是结合上面所有实验结果，训练了不同规模几个模型，由小到大：</p><ul><li>Small，Encoder 和 Decoder 都只有 6 层，隐维度 512，8 头；</li><li>Base，相当于 Encoder 和 Decoder 都用 BERT-base；</li><li>Large，Encoder 和 Decoder 都用 BERT-large 设置，除了层数只用 12 层；</li><li>3B（Billion）和11B，层数都用 24 层，不同的是其中头数量和前向层的维度。</li></ul><p>11B 的模型最后在 GLUE，SuperGLUE，SQuAD，还有 CNN/DM 上取得了 SOTA，而 WMT 则没有。看了性能表之后，我猜想之所以会有 3B 和 11B 模型出现，主要是为了刷榜。看表就能发现。</p><p><img src="https://i.loli.net/2021/04/28/JF4X6LzSgpxho93.jpg" alt="img"></p><p>比如说 GLUE，到 3B 时效果还并不是 SOTA，大概和 RoBERTa 评分差不多都是 88.5，而把模型加到 11B 才打破 ALBERT 的记录。然后其他实验结果也都差不多，3B 时还都不是 SOTA，而是靠 11B 硬拉上去的。除了 WMT 翻译任务，可能感觉差距太大，要拿 SOTA 代价过大，所以就没有再往上提。根据这几个模型的对比，可以发现<strong>即使是容量提到 11B，性能提升的间隔还是没有变缓</strong>，<strong>因此我认为再往上加容量还是有提升空间</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/88438851&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/88438851&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于 T5 
      
    
    </summary>
    
      <category term="NLP" scheme="http://yoursite.com/categories/NLP/"/>
    
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>A Straightforward Framework For Video Retrieval Using CLIP</title>
    <link href="http://yoursite.com/2021/04/20/A-Straightforward-Framework-For-Video-Retrieval-Using-CLIP/"/>
    <id>http://yoursite.com/2021/04/20/A-Straightforward-Framework-For-Video-Retrieval-Using-CLIP/</id>
    <published>2021-04-20T05:59:23.000Z</published>
    <updated>2021-04-23T02:52:45.215Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Deferf/CLIP_Video_Representation" target="_blank" rel="noopener">code</a></p><h2 id="本文的任务"><a href="#本文的任务" class="headerlink" title="本文的任务"></a>本文的任务</h2><p>Zero-shot Video-Text Retrieval</p><h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><p>CLIP model 是用互联网上<strong>大规模</strong>的image-text pairs 训练出来的一个多模态检索模型，其在 image text 检索上获得了非常优异的性能，且适合于zero-shot 的场景。</p><p>在本文中，作者尝试使用clip model 来处理 video-text pair, 并且仍然以  <strong style="color:red;">zero-shot</strong> 的方式。</p><ul><li>使用clip的 image encoder 来 获取frame feature, 然后使用 平均聚合，获取video-level feature.</li><li><p>使用 clip 的 text encoder 来获取 text feature。</p></li><li><p>使用cosine similarity 来计算 video-text sim</p></li></ul><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>TVR: Text Video Retrieval</p><p>VTR: Video Text Retrieval</p><h3 id="MSR-VTT"><a href="#MSR-VTT" class="headerlink" title="MSR-VTT"></a>MSR-VTT</h3><p><img src="https://i.loli.net/2021/04/23/pKQ6Y8msudJSgah.png" alt="image-20210423101035581" style="zoom: 67%;"></p><h3 id="MSVD"><a href="#MSVD" class="headerlink" title="MSVD"></a>MSVD</h3><p><img src="https://i.loli.net/2021/04/23/3jQUnoyTuNWBvPs.png" alt="image-20210423101137713" style="zoom:67%;"></p><h3 id="LSMDC"><a href="#LSMDC" class="headerlink" title="LSMDC"></a>LSMDC</h3><p><img src="https://i.loli.net/2021/04/23/bhjOL9yDcdunm7W.png" alt="image-20210423101208808" style="zoom:67%;"></p><h2 id="others"><a href="#others" class="headerlink" title="others"></a>others</h2><p>本文也探索了其他两种时域聚合的方式，但是不如取平均的方式好。</p><ul><li>（1） Follow【1】。将视频提取帧之后，取第30帧。由于视频每秒大约有30帧，所以，相当于取第一秒的最后一针。</li><li>（2）Follow【2】。使用 K-means， 获取K个video embedding , 计算每个embedding 与 text embedding 之间的相似度 and <strong>register each query’s minimum rank,</strong></li></ul><p>在MSR-VTT 验证集上的1000个视频-文本对上进行了实验：</p><p><img src="https://i.loli.net/2021/04/23/ZSOYgE2zj7nHpeI.png" alt="image-20210423100745024" style="zoom:67%;"></p><p>值得注意的是，在K-means方法中，结果之间没有明显的差异。 这可能是因为MSR视频的长度不超过32秒，这可能不足以在创建聚类时区分中心点。<strong style="color:red;">（<strong>yaya: 可能K-means 这种方法更加适合long-term video</strong>）</strong></p><h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>本文虽然创新性，没有那么强，但是在<strong>性能上是非常可观</strong>的。而且采取的是 <strong>Zero-Shot</strong> 的方式。</li><li>这种zero-shot 的方式，就可以应用到很多需要泛化性的地方。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><p>但是本文只是在这几个数据集上进行了测试，在其他的数据集上的性能还不可知，例如，在long-term videos 上的性能如何呢？</p></li><li><p>因为CLIP是在英文的句子上进行预训练的，当前测试的数据集仅仅是 english text，那么对于Chinese text效果如何呢？</p></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>本文的视频是直接解帧，然后对所有的帧进行时域聚合（平均池化）？这样的采样，是不是比较密集，且是不是含有冗余？？</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/Deferf/CLIP_Video_Representation&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;code&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;本文的任务&quot;&gt;&lt;a href=&quot;#本文的任务&quot;
      
    
    </summary>
    
      <category term="cross-modal" scheme="http://yoursite.com/categories/cross-modal/"/>
    
    
      <category term="cross-modal" scheme="http://yoursite.com/tags/cross-modal/"/>
    
  </entry>
  
  <entry>
    <title>Seeing Out of tHe bOx End-to-End Pre-training for Vision-Language Representation Learning</title>
    <link href="http://yoursite.com/2021/04/20/Seeing-Out-of-tHe-bOx-End-to-End-Pre-training-for-Vision-Language-Representation-Learning-1/"/>
    <id>http://yoursite.com/2021/04/20/Seeing-Out-of-tHe-bOx-End-to-End-Pre-training-for-Vision-Language-Representation-Learning-1/</id>
    <published>2021-04-20T05:57:17.000Z</published>
    <updated>2021-04-20T05:57:17.985Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Understanding Chinese Video and Language via Contrastive Multimodal Pre-Training</title>
    <link href="http://yoursite.com/2021/04/20/Understanding-Chinese-Video-and-Language-via-Contrastive-Multimodal-Pre-Training/"/>
    <id>http://yoursite.com/2021/04/20/Understanding-Chinese-Video-and-Language-via-Contrastive-Multimodal-Pre-Training/</id>
    <published>2021-04-20T05:56:47.000Z</published>
    <updated>2021-04-20T05:56:47.322Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CLIP4Clip: An Empirical Study of CLIP for End to End Video Clip Retrieval</title>
    <link href="http://yoursite.com/2021/04/20/CLIP4Clip-An-Empirical-Study-of-CLIP-for-End-to-End-Video-Clip-Retrieval/"/>
    <id>http://yoursite.com/2021/04/20/CLIP4Clip-An-Empirical-Study-of-CLIP-for-End-to-End-Video-Clip-Retrieval/</id>
    <published>2021-04-20T05:53:18.000Z</published>
    <updated>2021-04-23T03:28:18.295Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/ArrowLuo/CLIP4Clip" target="_blank" rel="noopener">code</a></p><h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><p>将 CLIP的知识迁移到 video-text retrieval 任务中，但是存在以下几个问题：</p><ul><li>图像的特征对于 video-text retrieval 是足够的吗？</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/ArrowLuo/CLIP4Clip&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;code&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;本文的点&quot;&gt;&lt;a href=&quot;#本文的点&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="cross-modal" scheme="http://yoursite.com/categories/cross-modal/"/>
    
    
      <category term="cross-modal" scheme="http://yoursite.com/tags/cross-modal/"/>
    
  </entry>
  
  <entry>
    <title>CLIPScore: A Reference-free Evaluation Metric for Image Captioning</title>
    <link href="http://yoursite.com/2021/04/20/CLIPScore-A-Reference-free-Evaluation-Metric-for-Image-Captioning/"/>
    <id>http://yoursite.com/2021/04/20/CLIPScore-A-Reference-free-Evaluation-Metric-for-Image-Captioning/</id>
    <published>2021-04-20T05:50:12.000Z</published>
    <updated>2021-04-23T09:41:12.682Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-本文研究的任务"><a href="#1-本文研究的任务" class="headerlink" title="1. 本文研究的任务"></a>1. 本文研究的任务</h2><ul><li>图像描述的评价指标</li></ul><h2 id="2-目前存在的问题"><a href="#2-目前存在的问题" class="headerlink" title="2. 目前存在的问题"></a>2. 目前存在的问题</h2><ul><li>当前图像描述的评价指标(automatic metrics )都是基于 predicted caption 与 reference 之间的文本匹配。但是人类进行评价时是直接将图片与prediction进行对比。即 automatic metrics与 human evaluation的评价方式是不一样的</li><li>reference的收集需要耗费人力，且较慢</li><li>reference是有限的，并不能覆盖所有可能的描述。因此，这些automatic metrics 更加<strong>偏向于</strong>reference中出现的单词，对于新的且正确的单词会给予错误的<strong>惩罚</strong>。</li></ul><h2 id="3-Motivation"><a href="#3-Motivation" class="headerlink" title="3. Motivation"></a>3. Motivation</h2><p>本文提出使用 clip model 来作为 图像描述的reference-free metric，基于以下两点原因：</p><ul><li><p><strong>基于在WMT上的借鉴：</strong>在多语言机器翻译任务中，提出了使用多语言模型（M-BERT), 计算 source-target 之间的相似性，作为reference free metric 来评估机器翻译。因此，可以使用image-text matching model 来计算image 与 predicted caption 之间的相似性。</p></li><li><p>CLIP，ALIGN，这种模型以 <strong>zero-shot</strong> 的方式展示出了在image-text matching task 上的优异性能。因此CLIP可以作为一个现成的(<strong>off-the-shelf</strong>) 的reference-free caption evaluation。</p></li></ul><h2 id="4-本文的贡献"><a href="#4-本文的贡献" class="headerlink" title="4. 本文的贡献"></a>4. 本文的贡献</h2><ul><li>提出一个 评估图像描述的 reference-free metric（CLIPScore, CLIP-s）。<br>另外提出了一个增强版本(RefCLIPScore,)，可以结合reference。</li><li>一个信息增益的分析实验，证明了CLIP-S 与 other metrics（B_4, Cider, Meteor， ViLBERTScore-F）是互相补充的。</li><li>实验验证CLIP-S对恶意构建的图像标题是敏感的，其中一个名词短语被换成了一个可信的（但不正确的）单词。</li><li><p>构建一个从未在网上公开发布过的图像语料库，以检验CLIP-S是否能够重建人类对从未见过的图像的判断。</p></li><li><p>最后，我们在四个与直接场景描述(direct scene description)不同的案例研究中评估CLIP-S。在两种情况下，CLIP-S效果很好。 它与<strong>Twitter</strong>上的alt-text质量评级实现了高度关联，并展示了对<strong>clipart images+captions</strong>进行推理的惊人能力。对于<strong>新闻标题</strong>的生成，基于参考的方法与人类的判断有最好的相关性。 而且，对于由<strong>社交媒体上的语言使用所激发的情感性标题</strong>，即使是基于参考的指标也是不足的。</p></li></ul><h2 id="5-实验"><a href="#5-实验" class="headerlink" title="5. 实验"></a>5. 实验</h2><h3 id="5-1-Performance-on-a-set-of-literal-image-description-corpora"><a href="#5-1-Performance-on-a-set-of-literal-image-description-corpora" class="headerlink" title="5.1 Performance on a set of literal image description corpora"></a>5.1 Performance on a set of literal image description corpora</h3><h4 id="Caption-level-Likert-Judgments"><a href="#Caption-level-Likert-Judgments" class="headerlink" title="Caption-level Likert Judgments"></a>Caption-level Likert Judgments</h4><ul><li>BERT-S  是指 BERTScore: Evaluating text generation with BERT</li><li>BERT-S++ 是指 Improving image captioning evaluation by considering inter references variance.</li></ul><p><img src="https://i.loli.net/2021/04/21/8A2W4u7EalDmTYL.png" alt="image-20210421104120105"></p><p><img src="https://i.loli.net/2021/04/21/OUaqp5JvolduweY.png" alt="image-20210421104130443"></p><p><img src="https://i.loli.net/2021/04/21/3n72RmIfBZFUcza.png" alt="image-20210421104218527"></p><h4 id="Pairwise-Ranking-on-Pascal-50S"><a href="#Pairwise-Ranking-on-Pascal-50S" class="headerlink" title="Pairwise Ranking on Pascal-50S"></a>Pairwise Ranking on Pascal-50S</h4><p><img src="https://i.loli.net/2021/04/21/ck1xFipoPAEf74m.png" alt="image-20210421104150925"></p><h4 id="System-level-Correlation-for-MSCOCO"><a href="#System-level-Correlation-for-MSCOCO" class="headerlink" title="System-level Correlation for MSCOCO."></a>System-level Correlation for MSCOCO.</h4><p>该文章作者提出，该数据其实仅有12个数据，数据量太少，用来评估相关性，其实是不准确的。但是还是做了这方面的实验。</p><p>在M1 和 M2 上，CLIP-S achieves Spearman $\rho_{M 1} / \rho_{M 2}=.59 / .63$ and RefCLIP-S achieves $\rho_{M 1} / \rho_{M 2}=.69 / .74$ </p><h3 id="5-2-Sensitivity-of-CLIP-S-to-hallucination"><a href="#5-2-Sensitivity-of-CLIP-S-to-hallucination" class="headerlink" title="5.2 Sensitivity of CLIP-S to hallucination"></a>5.2 Sensitivity of CLIP-S to hallucination</h3><p>先前的研究（Object hallucination in image captioning）表明，人类在给human打分时，会更加偏向于caption是否正确，而不是caption是否足够具体(全面)。因此，了解评价指标是否以及如何处理包含不正确的 “幻觉 “(incorrect “hallucinations,”)的图像描述，例如，对未描述的物体的引用，是很重要的。</p><p>本文使用FOIL数据集（FOIL it! find one mismatch between image and language caption），来测试CLIPScore对检测描述中潜在的微妙不准确的细节有多敏感。这个语料库由MSCOCO的reference进行修改后组成，其中有一个名词短语被对抗性地换掉，以使caption不正确，例如，将 “摩托车 “换成 “自行车”。</p><p><img src="https://i.loli.net/2021/04/21/Kqsab4TN7lC3OJX.png" alt="image-20210421111246841"></p><h3 id="5-3-Sensitivity-of-CLIP-S-to-memorization"><a href="#5-3-Sensitivity-of-CLIP-S-to-memorization" class="headerlink" title="5.3  Sensitivity of CLIP-S to memorization"></a>5.3  Sensitivity of CLIP-S to memorization</h3><p>以上数据集的成功表现，可能存在一种风险，即在评估时使用的数据已经在预训练时看到过。可能是在CLIP的预训练数据中包含了 COCO，Flickr 这种数据。为了消除这个疑虑，本文收集了250图片，这些图片没有上传到网上。然后使用Microsoft Azure Cognitive Services 和 Discriminability objective for training descriptive captions 这两个工具为每张图片生成两个预测的描述，然后，组织3个author去分析，哪个预测更好。</p><p>CLIP-S 实验了86%的 accuracy（人类的一致性92%）。</p><h3 id="5-4-评价指标之间的冗余和互补"><a href="#5-4-评价指标之间的冗余和互补" class="headerlink" title="5.4 评价指标之间的冗余和互补"></a>5.4 评价指标之间的冗余和互补</h3><p><img src="https://i.loli.net/2021/04/21/B1OvP7LW5ycr4u2.png" alt="image-20210421114103630"></p><p>6个常用的metrics (B_1, B_4, Meteor, Rouge, Cider, Spice)</p><p>4个新的metrics (TIGER, BERTScore, ViLBERTScore-F, and CLIP-S/RefCLIPS)</p><p>在这10个评价指标上，执行greedy前向搜索，开始时为一个空集，选择最有信息量的metric 添加到集合中来。关于信息增益的考量：根据线性回归模型，一个指标与人类判断的additional (增加)相关性有多大。（yaya: 当前步，引入一个metric到集合中来，可以带来多少相关性的提升）</p><p><strong>yaya: 具体实现细节不是很清楚，可以等代码开源之后看看</strong></p><h2 id="6-Other-Captioning-Domains"><a href="#6-Other-Captioning-Domains" class="headerlink" title="6. Other Captioning Domains"></a>6. Other Captioning Domains</h2><ul><li><p>Alt-Text ratings from Twitter</p></li><li><p>Abstract-50S</p></li><li>Personality Captions</li><li>News Image Captioning</li></ul><h2 id="7-Future-Work"><a href="#7-Future-Work" class="headerlink" title="7. Future Work"></a>7. Future Work</h2><ul><li><p>consider CLIP-S as a reinforcement learning reward for literal caption generators<br><strong>以clipscore 作为reward来做强化学习，提升captioning tasks</strong></p></li><li><p>explore whether a small amount of labelled human rating data could help CLIP-S adapt to domains where it struggles, e.g., engagingness prediction.</p><p><strong>用human ratings data来提升CLIP-S 作为评价指标的性能，从而提升对于一些目前它比较困难的领域。</strong></p></li></ul><h2 id="8-yaya"><a href="#8-yaya" class="headerlink" title="8. yaya"></a>8. yaya</h2><font color="red">由于clip的预训练过程对文本添加了前缀，类似”A photo of"。因此，在本文CLIPScore 中，对candidate captions也添加了前缀：“A photo depicts"</font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-本文研究的任务&quot;&gt;&lt;a href=&quot;#1-本文研究的任务&quot; class=&quot;headerlink&quot; title=&quot;1. 本文研究的任务&quot;&gt;&lt;/a&gt;1. 本文研究的任务&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;图像描述的评价指标&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-目前存
      
    
    </summary>
    
      <category term="cross-modal" scheme="http://yoursite.com/categories/cross-modal/"/>
    
    
      <category term="cross-modal" scheme="http://yoursite.com/tags/cross-modal/"/>
    
  </entry>
  
  <entry>
    <title>TVR: A Large-Scale Dataset for Video-Subtitle Moment Retrieval</title>
    <link href="http://yoursite.com/2021/04/20/TVR-A-Large-Scale-Dataset-for-Video-Subtitle-Moment-Retrieval/"/>
    <id>http://yoursite.com/2021/04/20/TVR-A-Large-Scale-Dataset-for-Video-Subtitle-Moment-Retrieval/</id>
    <published>2021-04-20T00:50:08.000Z</published>
    <updated>2021-04-20T01:25:51.931Z</updated>
    
    <content type="html"><![CDATA[<p>本文新提出了一个数据集 Video Corpus Moment Retrieval (VCMR)。</p><p>该数据集与以前数据集不同的点有：</p><ul><li>人类标注的query，不仅依据视频(视觉信息)，还根据subtitles(文本信息)</li><li>选取的moment不是对video进行均匀采样得到的(DiDeMo dataset)，而是自由选取的，这样可以更加关注于重要的moment</li><li>人类标注的query不依赖上下文信息，不会出现first, then这种描述（ActivityNet Captions），使得标注的数据更加适合检索任务。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文新提出了一个数据集 Video Corpus Moment Retrieval (VCMR)。&lt;/p&gt;
&lt;p&gt;该数据集与以前数据集不同的点有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;人类标注的query，不仅依据视频(视觉信息)，还根据subtitles(文本信息)&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Seeing Out of tHe bOx End-to-End Pre-training for Vision-Language Representation Learning</title>
    <link href="http://yoursite.com/2021/04/19/Seeing-Out-of-tHe-bOx-End-to-End-Pre-training-for-Vision-Language-Representation-Learning/"/>
    <id>http://yoursite.com/2021/04/19/Seeing-Out-of-tHe-bOx-End-to-End-Pre-training-for-Vision-Language-Representation-Learning/</id>
    <published>2021-04-19T07:24:36.000Z</published>
    <updated>2021-04-19T07:24:37.002Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Fill-in-the-Blank as a Challenging Video Understanding Evaluation Framework</title>
    <link href="http://yoursite.com/2021/04/13/Fill-in-the-Blank-as-a-Challenging-Video-Understanding-Evaluation-Framework/"/>
    <id>http://yoursite.com/2021/04/13/Fill-in-the-Blank-as-a-Challenging-Video-Understanding-Evaluation-Framework/</id>
    <published>2021-04-13T09:02:34.000Z</published>
    <updated>2021-05-29T02:03:57.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本文研究的任务"><a href="#本文研究的任务" class="headerlink" title="本文研究的任务"></a>本文研究的任务</h2><p>本文提出了一个新的任务，给定一段视频和一个带有blank的文本，目标是对blank进行补充。该任务的目的是测试系统（模型）对视频的理解。</p><p>In this task, given a video and a blanked caption, the model needs to generate the missing phrase.</p><h2 id="目前存在的问题"><a href="#目前存在的问题" class="headerlink" title="目前存在的问题"></a>目前存在的问题</h2><p>迄今为止，有关语言知识的视频理解的工作主要解决了两个任务：（1）<strong>使用多项选择题的方式来做视频VQA任务</strong>，当前模型的性能一般表现都相对较好，这是因为多项选择的方式，使得候选答案是容易获得的；（2）<strong>视频描述任务</strong>，通常会以开放式评估框架来对生成的caption进行评估，但是这种评估方式存在缺陷。比如，如果prediction的形式与reference有所不同，则prediction可能被认为是不正确的。</p><p>因此，在本文中，提出了一个fill-in-the-blanks任务来作为 视频理解评估框架，以解决以上的问题。这种任务形式，更加符合现实生活中，是没有预先给定多项选择的。</p><h2 id="fill-in-the-blank-task-的优势"><a href="#fill-in-the-blank-task-的优势" class="headerlink" title="fill-in-the-blank task 的优势"></a>fill-in-the-blank task 的优势</h2><ul><li>相比于 多项选择的video VQA 更加符合现实场景</li><li>不会遇到 video captioning 评估存在偏差的问题</li><li>fill-in-the-blank data 是可以自动生成的，因此训练数据的规模是可以无限增大的</li></ul><h2 id="构建数据集"><a href="#构建数据集" class="headerlink" title="构建数据集"></a>构建数据集</h2><p>我们通过两个步骤来构建这个 “填空 “视频数据集。 (1)数据生成，我们编制了大量的视频-字幕对，并有选择地挖去某些<strong>名词</strong>（multi-word spans）。 (2)数据标注，AMT workers 为这些空白提供<strong>额外</strong>的有效答案。（收集这种附加注释的主要原因是为了说明语言的自然多样性，并为每个空白有多个备选答案。）</p><p><strong>数据来源：</strong>we generate our training, validation, and test data starting with the VATEX v1.1 training set, a random subset of size 1,000 from the validation set, and a random subset of size 1,000 from the test set, respectively.</p><p><img src="https://i.loli.net/2021/04/13/dHsFYELJyvQunef.png" alt="image-20210413180750120" style="zoom: 50%;"></p><h2 id="本文设计的方法"><a href="#本文设计的方法" class="headerlink" title="本文设计的方法"></a>本文设计的方法</h2><p>本文设计了两种encoder: 早期融合encoder 和 后期融合encoder</p><p><img src="https://i.loli.net/2021/04/13/pJkgYWhMsncd7TN.png" alt="image-20210413183537583"></p><p>考虑到 <strong>T5</strong> 可以填充可变长度的blanks的能力，因此使用 <strong>T5</strong> 来初始化本文的多模态模型。</p><p>对于early fusion model: 使用T5-base weights。</p><p>对于late fusion model: 使用 T5-base 来初始化 text encoder 和 decoder。使用两个一层transformer 来作为video encoder 和 multimodal transformer encoder。</p><p>特殊字符：the special token <strong><extra_id_0></extra_id_0></strong> is used to represent the blanked phrase, and <strong>&lt;\s&gt;</strong> is used to separate the text and video sequences。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>本文提出了两个baseline:</p><ul><li>使用最频繁的answer作为预测：“a man”</li><li>Text-based Transformer (T5): 使用text-only model来测试该文构建数据集的language bias</li></ul><p>评估指标（Evaluation Metrics）</p><ul><li><p>exact match： we count a generated text string as correct if it has at least one string-level match among the provided annotations.</p></li><li><p>token-level F1：we compute the token overlap (true positives) between the generated text string and each annotation, normalize by the sum of the true positives and average of the false negatives/positives, then compute the maximum across all annotations. </p></li></ul><h3 id="本文数据集的-langauge-bias如何"><a href="#本文数据集的-langauge-bias如何" class="headerlink" title="本文数据集的 langauge bias如何"></a>本文数据集的 langauge bias如何</h3><ul><li>T5 fine-tuned 结果与 下面 multimodal models的结果相差不多，可以看到其实语言偏置还是很大的。</li></ul><p><img src="https://i.loli.net/2021/04/13/Pmf9nKMXdWvqAN8.png" alt="image-20210413185634092"></p><h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><ul><li><p>(1) 仅对 noun phrase 挖空，(2) 只挖了一个空，都是对任务的简化，使得该任务变得简单。</p></li><li><p>文中图表说明，最频繁的名词是 man, person。这是这个数据集的 language bias。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;本文研究的任务&quot;&gt;&lt;a href=&quot;#本文研究的任务&quot; class=&quot;headerlink&quot; title=&quot;本文研究的任务&quot;&gt;&lt;/a&gt;本文研究的任务&lt;/h2&gt;&lt;p&gt;本文提出了一个新的任务，给定一段视频和一个带有blank的文本，目标是对blank进行补充。该任务的
      
    
    </summary>
    
      <category term="cross-modal" scheme="http://yoursite.com/categories/cross-modal/"/>
    
    
      <category term="cross-modal" scheme="http://yoursite.com/tags/cross-modal/"/>
    
  </entry>
  
  <entry>
    <title>Exploiting Cloze Questions for Few Shot Text Classification and Natural Language Inference</title>
    <link href="http://yoursite.com/2021/04/06/Exploiting-Cloze-Questions-for-Few-Shot-Text-Classification-and-Natural-Language-Inference/"/>
    <id>http://yoursite.com/2021/04/06/Exploiting-Cloze-Questions-for-Few-Shot-Text-Classification-and-Natural-Language-Inference/</id>
    <published>2021-04-06T07:02:56.000Z</published>
    <updated>2021-04-29T02:13:00.592Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-存在的问题"><a href="#1-存在的问题" class="headerlink" title="1. 存在的问题"></a>1. 存在的问题</h2><p>当前的语言模型都依赖大量的数据，但是在现实中，大量的标注数据是很难获取的(cost) 。因此，在少样本下的训练方式需要被研究。</p><h2 id="2-本文的点"><a href="#2-本文的点" class="headerlink" title="2. 本文的点"></a>2. 本文的点</h2><ul><li>本文出发点：将任务描述 （task description）组合到模型的输入中，会使得任务变得简单。</li><li><p>通过本文提出的Pattern-Exploiting Training (PET)，<strong>将输入样本转为cloze-style phrases。并以半监督的方式来训练</strong>。具体的分为以下三步：</p><ul><li>(1) 首先设计了几种pattern, 对于不同的pattern，在小的训练集上以cloze-style的方式进行训练。</li><li>(2) 使用(1)中训练出来的多个模型的集成，来为未标记样本添加soft labels。</li><li>(3) 使用(2) 中<font color="red">扩充的伪标签数据 Finetune 一个<strong>常规</strong></font> 的（非 MLM 的）模型。</li></ul></li><li><p>在多语言的不同任务集上，本文表明，给定少量到中等数量的标记示例，本文提出的PET的表现大幅优于无监督方法、监督训练和强半监督基线。</p></li></ul><h2 id="3-PET"><a href="#3-PET" class="headerlink" title="3. PET"></a>3. PET</h2><p>We define a <strong>pattern</strong> to be a function $P$ that takes $\mathrm{x}$ as input and outputs a phrase or sentence $P(\mathbf{x}) \in V^{*}$ that contains exactly one mask token, i.e., its output can be viewed as a cloze question. </p><p>We define a <strong>verbalizer</strong> as an injective function $v: \mathcal{L} \rightarrow V$ that maps each label to a word from $M$ ‘s vocabulary. We refer to $(P, v)$ as a pattern-verbalizer pair (PVP).</p><h3 id="3-1-PVP-Training-and-Inference"><a href="#3-1-PVP-Training-and-Inference" class="headerlink" title="3.1 PVP Training and Inference"></a>3.1 PVP Training and Inference</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-存在的问题&quot;&gt;&lt;a href=&quot;#1-存在的问题&quot; class=&quot;headerlink&quot; title=&quot;1. 存在的问题&quot;&gt;&lt;/a&gt;1. 存在的问题&lt;/h2&gt;&lt;p&gt;当前的语言模型都依赖大量的数据，但是在现实中，大量的标注数据是很难获取的(cost) 。因此，在
      
    
    </summary>
    
      <category term="NLP" scheme="http://yoursite.com/categories/NLP/"/>
    
      <category term="few-shot learning" scheme="http://yoursite.com/categories/NLP/few-shot-learning/"/>
    
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
      <category term="few-shot learning" scheme="http://yoursite.com/tags/few-shot-learning/"/>
    
  </entry>
  
  <entry>
    <title>GPT Understands, Too</title>
    <link href="http://yoursite.com/2021/04/06/GPT-Understands-Too/"/>
    <id>http://yoursite.com/2021/04/06/GPT-Understands-Too/</id>
    <published>2021-04-06T02:34:25.000Z</published>
    <updated>2021-05-31T06:08:37.607Z</updated>
    
    <content type="html"><![CDATA[<p>转载：苏剑林. (Apr. 03, 2021). 《P-tuning：自动构建模版，释放语言模型潜能 》[Blog post]. Retrieved from <a href="https://kexue.fm/archives/8295" target="_blank" rel="noopener">https://kexue.fm/archives/8295</a></p><h2 id="1-P-tuning：自动构建模版，释放语言模型潜能"><a href="#1-P-tuning：自动构建模版，释放语言模型潜能" class="headerlink" title="1. P-tuning：自动构建模版，释放语言模型潜能"></a>1. P-tuning：自动构建模版，释放语言模型潜能</h2><p>在之前的文章<a href="https://kexue.fm/archives/7764" target="_blank" rel="noopener">《必须要GPT3吗？不，BERT的MLM模型也能小样本学习》</a>中，我们介绍了一种名为Pattern-Exploiting Training（PET）的方法，它通过人工构建的模版与BERT的MLM模型结合，能够起到非常好的零样本、小样本乃至半监督学习效果，而且该思路比较优雅漂亮，因为它将预训练任务和下游任务统一起来了。然而，人工构建这样的模版有时候也是比较困难的，而且不同的模版效果差别也很大，如果能够通过少量样本来自动构建模版，也是非常有价值的。</p><p>最近Arxiv上的论文<a href="https://arxiv.org/abs/2103.10385" target="_blank" rel="noopener">《GPT Understands, Too》</a>提出了名为P-tuning的方法，成功地实现了模版的自动构建。不仅如此，借助P-tuning，GPT在SuperGLUE上的成绩首次超过了同等级别的BERT模型，这颠覆了一直以来“GPT不擅长NLU”的结论，也是该论文命名的缘由。</p><h3 id="1-1-yaya-与本文相关的文献"><a href="#1-1-yaya-与本文相关的文献" class="headerlink" title="1.1 yaya-与本文相关的文献"></a>1.1 yaya-与本文相关的文献</h3><p>All NLP Tasks Are Generation Tasks: A General Pretraining Framework<br>GPT Understands, Too<br>How Many Data Points is a Prompt Worth<br>It’s Not Just Size That Matters:  Small Language Models Are Also Few-Shot Learners</p><h2 id="2-什么是模版-Pattern"><a href="#2-什么是模版-Pattern" class="headerlink" title="2. 什么是模版(Pattern)"></a>2. 什么是模版(Pattern)</h2><p>所谓PET，主要的思想是借助由自然语言构成的模版（英文常称Pattern或Prompt），将下游任务也转化为一个完形填空任务，这样就可以用BERT的MLM模型来进行预测了。比如下图中通过条件前缀来实现情感分类和主题分类的例子：</p><p><img src="https://i.loli.net/2021/04/06/Pov8T9D2a7Xur41.png" alt="通过特定模版将情感分类转换为MLM任务" style="zoom:33%;"></p><p>以上，通过特定模版将情感分类转换为MLM任务</p><p><img src="https://i.loli.net/2021/04/06/QyFxiS7RWTNGMK9.png" alt="通过特定模版将新闻分类转换为MLM任务" style="zoom:33%;"></p><p>以上，通过特定模版将新闻分类转换为MLM任务</p><p>当然，这种方案也不是只有MLM模型可行，用GPT这样的单向语言模型（LM）其实也很简单：</p><p><img src="https://i.loli.net/2021/04/06/GBAsIiEjOdvuSKp.png" alt="通过特定模版将情感分类转换为LM任务" style="zoom:33%;"></p><p>以上，通过特定模版将情感分类转换为LM任务</p><p><img src="https://i.loli.net/2021/04/06/lXsUG8bhfc4amLn.png" alt="通过特定模版将新闻分类转换为LM任务" style="zoom:33%;"></p><p>以上，通过特定模版将新闻分类转换为LM任务</p><p>不过由于语言模型是从左往右解码的，因此预测部分只能放在句末了（但还可以往补充前缀说明，只不过预测部分放在最后）。</p><p>某种意义上来说，这些模版属于语言模型的“探针”，我们可以通过模版来抽取语言模型的特定知识，从而做到不错的零样本效果，而配合少量标注样本，可以进一步提升效果，这些在<a href="https://kexue.fm/archives/7764" target="_blank" rel="noopener">《必须要GPT3吗？不，BERT的MLM模型也能小样本学习》</a>中已经比较详细讨论过了。</p><p>然而，前面已经说了，对于某些任务而言，<strong style="color:red;"><strong>人工构建模版并不是那么容易的事情</strong></strong>，模型的优劣我们也不好把握，而不同模型之间的效果差别可能很大，在这种情况下，人工标注一些样本可能比构建模版还要轻松得多。<strong style="color:red;">所以，如何根据已有的标注样本来自动构建模版，便成了一个值得研究的问题了。</strong></p><h2 id="3-P-tuning"><a href="#3-P-tuning" class="headerlink" title="3. P-tuning"></a>3. P-tuning</h2><p>P-tuning重新审视了关于模版的定义，放弃了“模版由自然语言构成”这一常规要求，从而将模版的构建转化为连续参数优化问题，虽然简单，但却有效。</p><h3 id="3-1-模版的反思"><a href="#3-1-模版的反思" class="headerlink" title="3.1 模版的反思"></a>3.1 模版的反思</h3><p>首先，我们来想一下“<strong style="color:red;">什么是模版</strong>“”。直观来看，模版就是由自然语言构成的前缀/后缀，通过这些模版我们使得下游任务跟预训练任务一致，这样才能更加充分地利用原始预训练模型，起到更好的零样本、小样本学习效果。</p><p><strong style="color:red;">等等，我们真的在乎模版是不是“自然语言”构成的吗？</strong></p><p>并不是。本质上来说，我们并不关心模版长什么样，<strong style="color:red;">我们只需要知道模版由哪些token组成，该插入到哪里，插入后能不能完成我们的下游任务，输出的候选空间是什么。</strong>模版是不是自然语言组成的，对我们根本没影响，“自然语言”的要求，只是为了更好地实现“一致性”，但不是必须的。于是，P-tuning考虑了如下形式的模版：</p><p><img src="https://i.loli.net/2021/04/06/SNYaqglG1LvJsMu.png" alt="img" style="zoom:33%;"></p><p>以上，<strong><strong style="color:blue;">P-tuning直接使用[unused*]的token来构建模版，不关心模版的自然语言性</strong></strong></p><p>这里的[u1]～[u6]，代表BERT词表里边的<strong style="color:red;">[unused1]～[unused6]</strong>，也就是用几个从未见过的token来构成模板，这里的token数目是一个超参数，放在前面还是后面也可以调整。接着，为了让“模版”发挥作用，我们<strong style="color:red;">用标注数据来求出这个模板</strong>。</p><h3 id="3-2-如何去优化"><a href="#3-2-如何去优化" class="headerlink" title="3.2 如何去优化"></a>3.2 如何去优化</h3><p>这时候，根据标注数据量的多少，我们又分两种情况讨论。</p><p><strong>第一种，标注数据比较少。</strong>这种情况下，我们固定整个模型的权重，只优化[unused1]～[unused6]这几个token的Embedding，换句话说，其实我们就是要学6个新的Embedding，使得它起到了模版的作用。这样一来，因为模型权重几乎都被固定住了，训练起来很快，而且因为要学习的参数很少，因此哪怕标注样本很少，也能把模版学出来，不容易过拟合。</p><p><strong>第二种，标注数据很充足。</strong>这时候如果还按照第一种的方案来，就会出现欠拟合的情况，因为只有6个token的可优化参数实在是太少了。因此，我们可以放开所有权重微调，原论文在SuperGLUE上的实验就是这样做的。读者可能会想：这样跟直接加个全连接微调有什么区别？原论文的结果是这样做效果更好，可能还是因为跟预训练任务更一致了吧。</p><p><img src="https://i.loli.net/2021/04/06/bJ2oPygslG3MhCN.png" alt="P-tuning在SuperGLUE上的表现"></p><p>以上，P-tuning在SuperGLUE上的表现</p><p>此外，在上面的例子中，目标token 如 “很”、“体育”是认为选定的，那么它们可不可以也用[unused$<em>$] 的token代替呢？答案是可以，但也分两种情况考虑：1、在标注数据比较少的时候，人工来选定适当的目标token效果往往更好些；2、在标注数据很充足的情况下，目标token用[unused$</em>$]效果更好些，因为这时候模型的优化空间更大一些。</p><h3 id="3-3-增强相关性"><a href="#3-3-增强相关性" class="headerlink" title="3.3 增强相关性"></a>3.3 增强相关性</h3><p>在原论文中，P-tuning并不是随机初始化几个新token然后直接训练的，而是通过一个小型的LSTM模型把这几个Embedding算出来，并且将这个LSTM模型设为可学习的。这样多绕了一步有什么好处呢？原论文大概的意思是：<strong>LSTM出现的token表示相关性更强，某种程度上来说更像“自然语言”（因为自然语言的token之间不是独立的），此外还能防止局部最优</strong>。我在Github上进一步向作者确认了一下（参考<a href="https://github.com/THUDM/P-tuning/issues/5" target="_blank" rel="noopener">这里</a>），效果上的差别是通过LSTM多绕一步的方法可以使得模型收敛更快、效果更优。</p><p>然而，这样多了一个LSTM，总感觉有些别扭，而且实现上也略微有点麻烦。按照作者的意思，LSTM是为了帮助模版的几个token（某种程度上）更贴近自然语言，但这并不一定要用LSTM生成，而且就算用LSTM生成也不一定达到这一点。<strong>笔者认为，更自然的方法是在训练下游任务的时候，不仅仅预测下游任务的目标token（前面例子中的“很”、“新闻”），还应该同时做其他token的预测。</strong></p><p>比如，<strong>如果是MLM模型，那么也随机mask掉其他的一些token来预测；如果是LM模型，则预测完整的序列，而不单单是目标词</strong>。这样做的理由是：因为我们的MLM/LM都是经过自然语言预训练的，所以我们（迷之自信地）认为能够很好完成重构的序列必然也是接近于自然语言的，因此这样增加训练目标，也能起到让模型更贴近自然语言的效果。经过笔者的测试，<strong>加上这样辅助目标，相比单纯优化下游任务的目标，确实提升了效果。</strong></p><h2 id="4-实验与效果"><a href="#4-实验与效果" class="headerlink" title="4. 实验与效果"></a>4. 实验与效果</h2><p>所谓“talk is cheap, show me the code”，又到了喜闻乐见的实验时间了。这里分享一下P-tuning的实验结果，其中还包括笔者对P-tuning的实现思路，以及笔者在中文任务上的实验结果。</p><h3 id="4-1-停止的梯度"><a href="#4-1-停止的梯度" class="headerlink" title="4.1 停止的梯度"></a>4.1 停止的梯度</h3><p>怎么实现上述的P-tuning算法比较好呢？如果是放开所有权重训练，那自然是简单的，跟普通的BERT微调没有什么区别。关键是在小样本场景下，如何实现“只优化几个token”呢？</p><p>当然，实现的方法也不少，比如为那几个要优化的token重新构建一个Embedding层，然后拼接到BERT的Embedding层中，然后训练的时候只放开新Embedding层的权重。但这样写对原来模型的改动还是蛮大的，最好的方法是尽可能少改动代码，让使用者几乎无感。为此，笔者构思了一种用<code>stop_gradient</code>简单修改<code>Embedding</code>层的方案，大体上是将<code>Embedding</code>层修改如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PtuningEmbedding</span><span class="params">(Embedding)</span>:</span></span><br><span class="line">    <span class="string">"""新定义Embedding层，只优化部分Token</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, inputs, mode=<span class="string">'embedding'</span>)</span>:</span></span><br><span class="line">        embeddings = self.embeddings</span><br><span class="line">        embeddings_sg = K.stop_gradient(embeddings)</span><br><span class="line">        mask = np.zeros((K.int_shape(embeddings)[<span class="number">0</span>], <span class="number">1</span>))</span><br><span class="line">        mask[<span class="number">1</span>:<span class="number">9</span>] += <span class="number">1</span>  <span class="comment"># 只优化id为1～8的token</span></span><br><span class="line">        self.embeddings = embeddings * mask + embeddings_sg * (<span class="number">1</span> - mask)</span><br><span class="line">        <span class="keyword">return</span> super(PtuningEmbedding, self).call(inputs, mode)</span><br></pre></td></tr></table></figure><p>变量经过<code>stop_gradient</code>算子后，在反向传播的时候梯度为0，但是前向传播不变，因此在上述代码中，前向传播的结果不会有变化，但是反向传播求梯度的时候，梯度不为0的token由<code>mask</code>变量控制，其余token的梯度都为零，因此就实现了只更新部分token。</p><p>完整代码可见：</p><blockquote><p><strong>Github：<a href="https://github.com/bojone/P-tuning" target="_blank" rel="noopener">https://github.com/bojone/P-tuning</a></strong></p></blockquote><p>对了，原论文也开源了代码：</p><blockquote><p><strong>Github：<a href="https://github.com/THUDM/P-tuning" target="_blank" rel="noopener">https://github.com/THUDM/P-tuning</a></strong></p></blockquote><h3 id="4-2-测试与效果"><a href="#4-2-测试与效果" class="headerlink" title="4.2 测试与效果"></a>4.2 测试与效果</h3><p>前面已经分享了原作者在SuperGLUE上的实验结果，显示出如果配合P-tuning，那么：<strong style="color:red;">1、GPT、BERT的效果相比直接finetune都有所提升</strong>；<strong style="color:red;">2、GPT的效果还能超过了BERT。</strong>这表明GPT不仅有NLG的能力，也有NLU能力，可谓是把GPT的潜能充分“压榨”出来了，当然BERT配合P-tuning也有提升，说明P-tuning对语言模型潜能的释放是较为通用的。</p><p>原论文的实验比较丰富，建议读者仔细阅读原论文，相信会收获颇多。特别指出的是原论文的Table 2最后一列，当预训练模型足够大的时候，我们的设备可能无法finetune整个模型，而P-tuning可以选择只优化几个Token的参数，因为优化所需要的显存和算力都会大大减少，所以<strong>P-tuning实则上给了我们一种在有限算力下调用大型预训练模型的思路</strong>。</p><p><img src="https://i.loli.net/2021/04/06/BMTubQ4AvSJperz.png" alt="P-tuning在各个体量的语言模型下的效果" style="zoom: 50%;"></p><p>以上，P-tuning在各个体量的语言模型下的效果</p><p>当然，笔者一直以来的观点是“没有在中文上测试过的算法是没有灵魂的”，因此笔者也在中文任务上简单测试了，测试任务跟<a href="https://kexue.fm/archives/7764" target="_blank" rel="noopener">《必须要GPT3吗？不，BERT的MLM模型也能小样本学习》</a>一致，都是情感分类的小样本学习，测试模型包括BERT和GPT，两者的候选模版分别如下图：</p><p><img src="https://i.loli.net/2021/04/06/SJfYPAulG4Lt7km.png" alt="笔者在中文情感分类上使用的“BERT+P-tuning”模版" style="zoom:33%;"></p><p>以上，笔者在中文情感分类上使用的“BERT+P-tuning”模版</p><p><img src="https://i.loli.net/2021/04/06/DV5OrLdygc3wxfn.png" alt="笔者在中文情感分类上使用的“GPT+P-tuning”模版" style="zoom:33%;"></p><p>以上，笔者在中文情感分类上使用的“GPT+P-tuning”模版</p><p>注意，对于LM模型，前缀的引入非常重要，只引入后缀时效果会明显变差；而对于MLM模型，前缀的效果通常也优于后缀。总的效果如下表：</p><p><img src="https://i.loli.net/2021/04/06/3N8TOk1YsmpSbHc.png" alt="image-20210406111755122" style="zoom:50%;"></p><p>其中“小样本”只用到了“少量标注样本”，“无监督”则用到了“大量无标注样本”，“半监督”则用到了“少量标注样本+大量无标注样本”，“P-tuning”都是小样本，PET的几个任务报告的是最优的人工模版的结果，其实还有更差的人工模版。从小样本角度来看，P-tuning确实取得了最优的小样本学习效果；从模版构建的角度来看，P-tuning确实也比人工构建的模版要好得多；从模型角度看，P-tuning确实可以将GPT的分类性能发挥到跟BERT相近，从而揭示了GPT也有很强的NLU能力的事实。</p><h2 id="5-进一步理解"><a href="#5-进一步理解" class="headerlink" title="5. 进一步理解"></a>5. 进一步理解</h2><p>这一节将会介绍笔者对P-tuning的进一步思考，以求从多个维度来理解P-tuning。</p><h3 id="5-1-离散-vs-连续"><a href="#5-1-离散-vs-连续" class="headerlink" title="5.1 离散 vs 连续"></a>5.1 离散 vs 连续</h3><p>在P-tuning之前，也已经有一些在做模版的自动构建，如<a href="https://arxiv.org/abs/1911.12543" target="_blank" rel="noopener">《How Can We Know What Language Models Know?》</a>、<a href="https://arxiv.org/abs/2010.15980" target="_blank" rel="noopener">《AutoPrompt: Eliciting Knowledge from Language Models with Automatically Generated Prompts》</a>等，但<strong>它们搜索的都是在离散空间下搜索的自然语言模版</strong>，所以效果有所限制，并没有取得特别突出的结果。</p><p>相反，P-tuning放弃了“模版由自然语言构成”这一要求，从而将其变成了可以简单梯度下降求解的连续参数问题，效果还更好。同时，这一改动意味着P-tuning突出了模版的本质——即模版的关键在于它是怎么用的，不在于它由什么构成——给人一种去芜存菁、眼前一亮额的感觉，确实值得点赞。</p><h3 id="5-2-Adapter"><a href="#5-2-Adapter" class="headerlink" title="5.2 Adapter"></a>5.2 Adapter</h3><p>我们还可以从Adapter的角度来理解P-tuning。BERT出来后不久，Google在论文<a href="https://arxiv.org/abs/1902.00751" target="_blank" rel="noopener">《Parameter-Efﬁcient Transfer Learning for NLP》</a>中提出了一种名为Adapter的微调方式，它并不是直接微调整个模型，而是固定住BERT原始权重，然后在BERT的基础上添加一些残差模块，只优化这些残差模块，由于残差模块的参数更少，因此微调成本更低。Adapter的思路实际上来源于CV的<a href="https://arxiv.org/abs/1705.08045" target="_blank" rel="noopener">《Learning multiple visual domains with residual adapters》</a>，不过这两年似乎很少看到了，也许是因为它虽然提高了训练速度，但是预测速度却降低了，精度往往还有所损失。</p><p><strong>在P-tuning中，如果我们不将新插入的token视为“模版”，是将它视为模型的一部分，那么实际上P-tuning也是一种类似Adapter的做法，<strong style="color:red;">同样是固定原模型的权重，然后插入一些新的可优化参数</strong>，<strong style="color:purple;">同样是只优化这些新参数，只不过这时候新参数插入的是Embedding层</strong>。因此，从这个角度看，P-tuning与Adapter有颇多异曲同工之处。</strong></p><h3 id="5-3-为什么有效"><a href="#5-3-为什么有效" class="headerlink" title="5.3 为什么有效"></a>5.3 为什么有效</h3><p>然后，还有一个值得思考的问题：为什么P-tuning会更好？比如全量数据下，大家都是放开所有权重，P-tuning的方法依然比直接finetune要好，为啥呢？</p><p>事实上，提出这个问题的读者，应该是对BERT加个全连接层的直接finetune做法“习以为常”了。很明显，不管是PET还是P-tuning，它们其实都更接近预训练任务，而加个全连接层的做法，其实还没那么接近预训练任务，所以某种程度上来说，P-tuning有效更加“显然”，反而是加个全连接层微调为什么会有效才是值得疑问的。</p><p>去年有篇论文<a href="https://arxiv.org/abs/2010.03648" target="_blank" rel="noopener">《A Mathematical Exploration of Why Language Models Help Solve Downstream Tasks》</a>试图回答这个问题，大致的论证顺序是：</p><blockquote><p>1、预训练模型是某种语言模型任务；</p><p>2、下游任务可以表示为该种语言模型的某个特殊情形；</p><p>3、当输出空间有限的时候，它又近似于加一个全连接层；</p><p>4、所以加一个全连接层微调是有效的。</p></blockquote><p>可以看到，该论文的假设主要是第2点，其实就是直接假设了下游任务可以表达为类似PET的形式，然后才去证明的。所以这进一步说明了，PET、P-tuning等才是更自然的使用预训练模型的方式，加全连接直接finetune的做法其实只是它们的推论罢了，也就是说，PET、P-tuning才是返璞归真、回归本质的方案，所以它们更有效。</p><h2 id="6-简单的总结"><a href="#6-简单的总结" class="headerlink" title="6. 简单的总结"></a>6. 简单的总结</h2><p>本文介绍了P-tuning，它是一种模版的自动构建方法，而通过模版我们可以从语言模型中抽取知识，完成零样本、小样本等学习任务，并且效果往往还更好。借助P-tuning，GPT也能实现优秀的NLU效果，在SuperGLUE上的表现甚至超过了BERT。除此之外，P-tuning还一种在有限算力下调用大型预训练模型的有效方案。</p><h1 id="智源"><a href="#智源" class="headerlink" title="智源"></a>智源</h1><p><img src="https://i.loli.net/2021/05/31/x3uXTm5QU47IKZF.png" alt="image-20210531133837040" style="zoom:50%;"></p><p><img src="https://i.loli.net/2021/05/31/5tbaTcxr8FCivUL.png" alt="image-20210531133920627" style="zoom:50%;"></p><p><img src="https://i.loli.net/2021/05/31/NWXjCMk4zsIVubE.png" alt="image-20210531134146305" style="zoom:50%;"></p><p><img src="https://i.loli.net/2021/05/31/7j3lW4vrfcVIwgU.png" alt="image-20210531134313255" style="zoom:50%;"></p><p><img src="https://i.loli.net/2021/05/31/VKDJZYjpRd63UWP.png" alt="image-20210531134449585" style="zoom:50%;"></p><p><img src="https://i.loli.net/2021/05/31/5gzWlk74Z18Exf3.png" alt="image-20210531134511330" style="zoom:50%;"></p><p><img src="https://i.loli.net/2021/05/31/8FK6wd1Ez9pouLC.png" alt="image-20210531134639415" style="zoom:50%;"></p><p><img src="https://i.loli.net/2021/05/31/vqU6M3CftRNSbh2.png" alt="image-20210531134820215" style="zoom:50%;"></p><p><img src="https://i.loli.net/2021/05/31/Wn2Qw4A1bOZLXpI.png" alt="image-20210531134929428" style="zoom:50%;"></p><p><img src="https://i.loli.net/2021/05/31/qlV85o9kDLza6Fj.png" alt="image-20210531134943431" style="zoom:50%;"></p><p><img src="https://i.loli.net/2021/05/31/Ya8I5cBEC7OmURA.png" alt="image-20210531135052454" style="zoom:50%;"></p><p><img src="https://i.loli.net/2021/05/31/pRGmzBlJ6DiW7Uf.png" alt="image-20210531135156520" style="zoom:50%;"></p><p><img src="https://i.loli.net/2021/05/31/TEhUFRkCWa3nX6Z.png" alt="image-20210531135528640" style="zoom:50%;"></p><p><img src="https://i.loli.net/2021/05/31/65buBKrIaRnPgJX.png" alt="image-20210531135651006" style="zoom:50%;"></p><p><img src="https://i.loli.net/2021/05/31/rAc7YBSuMXk12se.png" alt="image-20210531135716122" style="zoom:50%;"></p><p><img src="https://i.loli.net/2021/05/31/kd1PwMIaQHWoNRA.png" alt="image-20210531135826044" style="zoom:50%;"></p><p><img src="https://i.loli.net/2021/05/31/Ley1OMGqgDaJpsF.png" alt="image-20210531140027073" style="zoom: 50%;"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：苏剑林. (Apr. 03, 2021). 《P-tuning：自动构建模版，释放语言模型潜能 》[Blog post]. Retrieved from &lt;a href=&quot;https://kexue.fm/archives/8295&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
      <category term="NLP" scheme="http://yoursite.com/categories/NLP/"/>
    
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>[COOT] Cooperative Hierarchical Transformer for Video-Text Representation Learning</title>
    <link href="http://yoursite.com/2021/04/03/COOT-Cooperative-Hierarchical-Transformer-for-Video-Text-Representation-Learning/"/>
    <id>http://yoursite.com/2021/04/03/COOT-Cooperative-Hierarchical-Transformer-for-Video-Text-Representation-Learning/</id>
    <published>2021-04-03T02:04:28.000Z</published>
    <updated>2021-04-06T02:38:21.329Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章发表在 NeurIPS 2020，同时做 video-text retrieval and video captioning task.</p><p><img src="https://i.loli.net/2021/04/03/c8m4XTZtS6NE7hJ.png" alt="image-20210403102956324" style="zoom:50%;"></p><p><img src="https://i.loli.net/2021/04/04/IXfubaGzPV21sEt.png" alt="image-20210404124021644" style="zoom:50%;"></p><h2 id="本文的方法"><a href="#本文的方法" class="headerlink" title="本文的方法"></a>本文的方法</h2><p><font color="red"><strong>To model intra-level cooperation</strong></font>, we introduce <strong>an attention-aware feature aggregation layer (Attention-FA)</strong> to focus on temporal interactions between low-level entities (Figure 1-Attention-FA).<br>This component replaces traditional sequence representation aggregation methods in transformers such as using a [CLS] token [11, 14, 15, 19] or mean pooling [25] with an attention-aware fusion. It leverages temporal context to encourage important entities to contribute more to the final representation of a sequence of frames or words.</p><p><font color="red"><strong>For the inter-level cooperation</strong></font>, we introduce <strong>a contextual attention module(Contextual transformer)</strong>, which enforces the network to highlight semantics relevant to the general context of the video and to suppress the irrelevant semantics. This is done by modeling the interaction between low-level (clips-sentences) and high-level entities (global contexts), as shown in Figure 1-green region.</p><p>In addition to this architectural contributions, we introduce <strong style="color:red;">a new cross-modal cycle-consistency loss</strong> to enforce interaction between modalities and encourage the semantic alignment between them in the learned common space. We show that enforcing two domains to produce consistent representations leads to substantially improved semantic alignment.</p><h3 id="An-attention-aware-feature-aggregation-layer-Attention-FA"><a href="#An-attention-aware-feature-aggregation-layer-Attention-FA" class="headerlink" title="An attention-aware feature aggregation layer (Attention-FA)"></a>An attention-aware feature aggregation layer (Attention-FA)</h3><ul><li>简单来说，就是以自身（sentence/clip）特征计算一个权重，然后权重求和得到（paragraph/video）特征。</li></ul><p><img src="https://i.loli.net/2021/04/04/PtqSgLAi2Ky6Fc7.png" alt="image-20210404143442057" style="zoom:50%;"></p><h3 id="cross-modal-cycle-consistency-loss-lt-strong-gt"><a href="#cross-modal-cycle-consistency-loss-lt-strong-gt" class="headerlink" title="cross-modal cycle-consistency loss&lt;/strong&gt;"></a>cross-modal cycle-consistency loss&lt;/strong&gt;</h3><p>sentences of  a paragraph, clip of a video</p><p>给定一个第$i$ 个 sentence embedding， 计算其与 clips 之间的关系 $\alpha_i$，然后由$\alpha_i$权重求和计算得到soft nearest neighbor.</p><p>由该soft nearest neighbor, 计算其与 sentences 之间的关系 $\beta_j$, 然后由$\beta_j$计算 soft location: $\mu=\sum_{j=1}^{m} \beta_{j} j$</p><p>The sentence embedding  is semantically cycle consistent if and only if it cycles back to the original location.</p><p>Our objective is the distance between the source location $i$ and the soft destination location $\mu .$</p><script type="math/tex; mode=display">\ell_{C M C}=\|i-\mu\|^{2}</script><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><ul><li><p>探究本文提出的 the attention-aware feature aggregation (AF), the Contextual Transformer (CoT), and the cross-modal<br>cycle-consistency loss (CMC) 的作用</p><ul><li>对比 COOT+ CLS/AVG/MAX  和 COOT+AFA, 可以发现，AFA是有效的</li><li>对比 COOT+AFA X X  和 COOT+AFA √ X, 可以发现，CMC是有效的，但是效果其实没有那么明显</li><li>对比 COOT+AFA √ X 和  COOT+AFA √ √，可以发现，CoT是有效的</li></ul><p><img src="https://i.loli.net/2021/04/04/NlfV3giYjohSDbn.png" alt="image-20210404141458907" style="zoom:50%;"></p></li></ul><ul><li><p>在ActivityNet-caption dataset 上与最新方法对比</p><p><img src="https://i.loli.net/2021/04/04/1C26nJMLsBlwdEP.png" alt="image-20210404142959158" style="zoom:50%;"></p></li><li><p>在 YouCook2 dataset  上与最新方法对比</p><ul><li>利用howto100m进行预训练是有用的。</li></ul><p><img src="https://i.loli.net/2021/04/04/bmDwJnpIBXPHA1j.png" alt="image-20210404143035311" style="zoom:50%;"></p></li><li><p>验证本模型学到的特征包含了有意义的信息，对于其他任务(e.g., video captioning )也是有效的。</p><p>在 MART [2] 上使用了本文提出的特征，实验结果如下：</p><p><img src="https://i.loli.net/2021/04/04/Em3ILM27ueTbCOa.png" alt="image-20210404145023633" style="zoom: 50%;"></p><p><img src="https://i.loli.net/2021/04/04/i71VYerR8gZSWCj.png" alt="image-20210404144942155" style="zoom:50%;"></p></li></ul><h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><ul><li>对我的启发： the attention-aware feature aggregation (AF)是有用的，可以借鉴。</li><li>本文不仅使用了普通的ranking loss, 本文提出的循环一致损失，还使用了【1】提出的 一个损失</li><li>本文仅在 activitynet-caption 和 youcook2 上做了实验。</li><li>To apply the cycle-consistency loss, we found that sampling 1 clip per video and 1 sentence per paragraph works best.<br>这句话，是什么意思？？？？</li><li>本文的方法可能更加适合于 paragraph-video 的匹配任务。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1]  Bowen Zhang, Hexiang Hu, and Fei Sha. Cross-modal and hierarchical modeling of video and text. In ECCV, 2018.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇文章发表在 NeurIPS 2020，同时做 video-text retrieval and video captioning task.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/03/c8m4XTZtS6NE7hJ.p
      
    
    </summary>
    
      <category term="cross-modal" scheme="http://yoursite.com/categories/cross-modal/"/>
    
    
      <category term="cross-modal" scheme="http://yoursite.com/tags/cross-modal/"/>
    
  </entry>
  
  <entry>
    <title>Cross-Batch Memory for Embedding Learning</title>
    <link href="http://yoursite.com/2021/04/02/Cross-Batch-Memory-for-Embedding-Learning/"/>
    <id>http://yoursite.com/2021/04/02/Cross-Batch-Memory-for-Embedding-Learning/</id>
    <published>2021-04-02T08:51:02.000Z</published>
    <updated>2021-04-06T02:38:39.146Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://zhuanlan.zhihu.com/p/139187724" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/139187724</a></p><p>转载的原因：</p><ul><li>此篇论文与 MoCo 的思路非常的相似</li><li>其实度量学习的思想也是可以用于 跨模态检索任务中的，毕竟跨模态检索做的也是度量任务。<br>目前看到有两篇论文已经这样做了：<ul><li>HiT Hierarchical Transformer with Momentum Contrast for Video-Text Retrieval</li><li>Memory Enhanced Embedding Learning for Cross-Modal Video-Text Retrieval</li></ul></li></ul><p>码隆科技今年在 CVPR 多有斩获。在大会论文接受率仅有 22%、被称为“十年来最难的一届”的情况下，有两篇论文入选 CVPR 2020，其中本文 Cross-Batch Memory for Embedding Learning为口头报告论文（Oral）。口头报告论文是 CVPR 官方核定的含金量最高的论文，以 CVPR 2019 为例，投稿的 5160 篇论文中，仅有约 5.6% 获评口头报告论文。同时，作为以技术为先的人工智能企业，码隆科技和往年一样，是 CVPR 2020 的金牌赞助商。</p><p>本篇论文提出了 XBM 方法，能够用极小的代价，提供巨量的样本对，为 pair-based 的深度度量学习方法取得巨大的效果提升。这种提升难例挖掘效果的方式突破了过去两个传统思路：加权和聚类，并且效果也更加简单、直接，很好地解决了深度度量学习的痛点。XBM 在多个国际通用的图像搜索标准数据库上（比如 SOP、In-Shop 和 VehicleID 等)，取得了目前最好的结果。</p><p><strong>我们的算法研究员也在知乎上针对这篇论文撰写了一版更为通俗有趣的解读文章。感兴趣的话，可以点击下方直达。</strong></p><p><a href="https://zhuanlan.zhihu.com/p/136522363" target="_blank" rel="noopener">王珣：跨越时空的难样本挖掘zhuanlan.zhihu.com<img src="https://i.loli.net/2021/04/02/xsgfovFm5TVaCyq.jpg" alt="图标"></a></p><p><strong>论文</strong>：Cross-Batch Memory for Embedding Learning</p><p><strong>地址</strong>：<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1912.06798" target="_blank" rel="noopener">https://arxiv.org/abs/1912.06798</a></p><h2 id="背景和动机"><a href="#背景和动机" class="headerlink" title="背景和动机"></a><strong>背景和动机</strong></h2><p>难例挖掘是深度度量学习领域中的核心问题，最近有颇多研究都通过改进采样或者加权方案来解决这一难题，目前主要两种思路：第一种思路是在 mini-batch 内下功夫，对于 mini-batch 内的样本对，从各种角度去衡量其难度，然后给予难样本对更高权重，比如 N-pairs、Lifted Struture Loss、MS Loss 使用的就是此种方案。第二种思路是在 mini-batch 的生成做文章，比如 HTL、Divide and Conquer，他们的做法虽然看上去各有不同，但是整体思路有异曲同工之处。大致思路都是对整个数据集进行聚类，每次生成 mini-batch 不是从整个数据集去采样，而是从一个子集，或者说一个聚类小簇中去采样。这样一来，由于采样范围本身更加集中，生成的 mini-batch 中难例的比例自然也会更大，某种程度上也能解决问题。然而，无论是第一种方法的额外注重难样本，还是第二种方法的小范围采样，他们的难例的挖掘能力其实依然有一个天花板——那就是 mini-batch 的大小。这个 mini-batch 的大小决定了在模型中单次迭代更新中，可以利用的样本对的总量。因此，即使是很精细的采样加权方法，在 mini-batch 大小有限的情况下，也很难有顶级的表现。我们在三个标准图像检索数据库上进行了实验，基于三种标准的 pair-based 方法，我们发现随着 mini-batch 变大，效果（Recall@1）大幅提升。实验结果如下图：</p><p><img src="https://i.loli.net/2021/04/02/XnEsAeKYZ78Sak3.png" alt="image-20210402165727364"></p><p>可以看出，随着 mini-batch 的增大，效果有显著提升。但是，在实际工业应用中 mini-batch 越大，训练所需要的 GPU 或 TPU 就越多，即使计算资源有充分保证，在多机多卡的训练过程中，如何在工程上保证通信的效率也是一个有挑战的问题。</p><h2 id="特征偏移"><a href="#特征偏移" class="headerlink" title="特征偏移"></a><strong>特征偏移</strong></h2><p>由此，我们希望另辟蹊径，得以在 mini-batch 有限的情况下，也能获得充足的难例样本对。首先，必须突破深度度量学习一直以来的一个思维局限——仅在对当前 mini-batch里的样本对两两比较，形成样本对。以此我们引入了 XBM（Cross-batch Memory）这一方法来突破局限，跨越时空进行难例挖掘，把过去的 mini-batch 的样本提取的特征也拿过来与当前 mini-batch 作比较，构建样本对。</p><p><img src="https://i.loli.net/2021/04/02/gzBpr4V6MLxbPCd.jpg" alt="img"></p><p>我们将样本特征随着模型训练的偏移量，称之为特征偏移（Feature Drift）。从上图我们发现，在训练的一开始，模型还没有稳定，特征剧烈变化，每过 100 次迭代，特征偏移大约 0.7 以上。但是，随着训练的进行，模型逐步稳定，特征的偏移也变小。我们称这个现象为慢偏移（Slow Drift），这是我们可以利用的一点。</p><h2 id="方法梗概"><a href="#方法梗概" class="headerlink" title="方法梗概"></a><strong>方法梗概</strong></h2><p>我们发现，虽然在训练的前 3K iterations，mini-batch 过去的提取特征与当前模型偏差很大，但是，随着训练时间的延长，过去的迭代里所提取过的特征，逐渐展示为当前模型的一个有效近似。我们要做的不过是把这些特征给存下来，每个特征不过是 128 个 float 的数组，即便我们存下了过去 100 个 mini-batch 的特征，不过是6400个（假设 batch size = 64）float 数组，所需要不过是几十 MB 的显存。而它带来的好处是显而易见的，我们能够组成的样本对的个数是仅仅利用当前 mini-batch 的一百倍。即便这些特征不能高精准地反映当前模型的信息，但是只要特征偏移在合理的范围内，这种数量上带来的好处，可以完全补足这种误差带来的副作用。具体来看，我们的 XBM 的方法架构大致如下：</p><p><img src="https://i.loli.net/2021/04/02/ixCLyrXDOHwck8u.jpg" alt="img"></p><p>伪代码如下：</p><p><img src="https://i.loli.net/2021/04/02/yWbPMmZtnerAHV3.jpg" alt="img"></p><p>我们的 XBM 从结构上非常简单清晰。我们先训练一个 epoch 左右，等待特征偏移变小。然后，我们使用 XBM：一个特征队列去记忆过去 mini-batch 的特征，每次迭代都会把当前 mini-batch 提取出来的新鲜特征加入队列，并把最旧的特征踢出队列，从而保证 XBM 里的特征尽量是最新的。每次去构建样本队列的时候，我们将当前 mini-batch 和 XBM 里的所有特征都进行配对比较，从而形成了巨量的样本对。如果说 XBM 存储了过去 100 个 mini-batch，那么其所产生的样本对就是基于 mini-batch 方法的 100 倍。不难发现，XBM 其实直接和过去基于样本对的方法结合，只需要把原来的 mini-batch 内的样本对换成当前 mini-batch 和 XBM 的特征构成的样本对就可以了。所以，我们通过 XBM 这种存储特征的机制，能够让不同时序的 mini-batch 的特征成功配对。</p><h2 id="消融实验一"><a href="#消融实验一" class="headerlink" title="消融实验一"></a><strong>消融实验一</strong></h2><p><img src="https://i.loli.net/2021/04/02/Be4GvZMLxiCbEyt.jpg" alt="img"></p><p>首先，我们在三个常用的检索数据集，和三个基于样本对的深度学习的方法上，使用 XBM 进行测试，同时控制其他的设置全部不变。我们发现，XBM 带来的效果很明显。尤其是在最基本的对比损失（Contrastive Loss）上，可以看到，本来这个方法只利用 mini-batch 内的样本时，其效果并不显著，但是 XBM 带来了显著的效果提升。在三个数据集， Recall@1 都至少提升 10 个点，尤其是 VehicleID 数据集的最大（Large）测试集，效果提升了 22 个点，从 70.0 到 92.5。</p><h2 id="消融实验二"><a href="#消融实验二" class="headerlink" title="消融实验二"></a><strong>消融实验二</strong></h2><p><img src="https://i.loli.net/2021/04/02/VD6UHdejXizlyTf.jpg" alt="img"></p><p>关于 mini-batch 的大小对结果的影响， 从上图可发现三点：</p><p><strong>1.</strong> 无论是否使用 XBM，mini-batch 越大，效果越好；</p><p><strong>2.</strong> XBM 方法即便是使用很小的 batch (16)， 也比没有 XBM 使用大的 batch (256) 效果好；</p><p><strong>3.</strong> 由于 XBM 本身可以提供正样本对，所以可以不一定要用 PK sampler 来生成 mini-batch，而是可以直接使用原始的 shuffle sampler，效果相似。</p><h2 id="计算资源消耗"><a href="#计算资源消耗" class="headerlink" title="计算资源消耗"></a><strong>计算资源消耗</strong></h2><p>下图我们展示了在 SOP 上训练 XBM 时的计算资源消耗，即便把整个训练集（50K+）的特征都加载到 XBM，不过需要 0.2GB 的显存；而如果是使用增大 batch 的方法，会额外需要 15GB 显存，是 XBM 的 80 倍，但是效果的提升比 XBM 差很多。毕竟 XBM 仅仅需要存特征，特征也是直过去的 mini-batch 的前向计算的结果，计算资源的需求很小。</p><p><img src="https://i.loli.net/2021/04/02/ATGEJLXR9UjWCN6.jpg" alt="img"></p><h2 id="对比-SOTA"><a href="#对比-SOTA" class="headerlink" title="对比 SOTA"></a><strong>对比 SOTA</strong></h2><p>与最近的深度度量学习方法对比，我们在四个检索数据库上效果均大幅提升，这里仅列出 VehicleID 的效果，其他数据集的效果见原论文。</p><p><img src="https://i.loli.net/2021/04/02/veWF2knBIuEogwj.jpg" alt="img"></p><p>简单来说，不同于部分文章中使用更好的网络结构，更大的输出维度，或者更大的 mini-batch 来提升效果，强行 SOTA。我们列出 XBM 在 64 的 mini-batch 在不同的主干网络下及各种维度下的效果，其效果一直是最好的。</p><p><strong>另外，我们的方法也将整理开源，地址在：</strong></p><p><strong><a href="https://link.zhihu.com/?target=https%3A//github.com/MalongTech/research-xbm" target="_blank" rel="noopener">https://github.com/MalongTech/research-xbm</a></strong></p><p><strong>论文地址在：</strong></p><p><strong><a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1912.06798" target="_blank" rel="noopener">https://arxiv.org/abs/1912.06798</a></strong></p><p><strong>期待与更多研究者共同学习交流。</strong></p><h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a><strong>可视化</strong></h2><p><img src="https://i.loli.net/2021/04/02/TIxiYh9LDWnUq4s.jpg" alt="img"></p><p>更多可视化见论文补充材料，有更多实例说明效果。</p><h2 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a><strong>总结与展望</strong></h2><p>第一，本文提出的 XBM 方法能够记住过去的特征，使得模型的训练不再仅仅依靠当前 mini-batch 的样本，而是可以跨越时空进行样本配对。从而用极小的代价，提供了巨量的样本对，为 pair-based 的深度度量学习方法取得了巨大的效果提升。这种提升难例挖掘效果的方式，也是突破了过去两个传统思路：加权和聚类，并且效果也更加简单、直接，很好地解决了深度度量学习的痛点。</p><p>第二，其实 Memory 机制并不是本文原创，但是用 Memory 来做难例挖掘是一个全新的尝试。同样在 CVPR 2020 获得 Oral，也是由 Kaiming He 作为一作的 MoCo 也是这种思路。<font color="red"><strong>本文的方法其实可以认为是 MoCo 在 ｍ=0 的特例</strong></font>，Kaiming 通过动量更新 key encoder，可以直接控制住特征偏移。作者认为，这种方法还会在很多任务带来提升，不局限于 Kaiming 的自监督表示学习，以及此前我们一直关注研究的度量学习（或者说监督表示学习）。</p><p>第三，在本文中，虽然 XBM 在所有的 pair-based 的方法都有提升，但是明显在对比损失（Contrastive Loss）上提升最大，具体原因待考。另外，我们也把在无监督表示上表现很好的 infoNCE 方法用到了深度度量学习，但效果并不显著。作者认为这两个问题的答案是同一个，且有值得深究的价值，希望在后续研究中进行进一步跟进探索。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载自：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/139187724&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/139187724&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转载的
      
    
    </summary>
    
    
      <category term="metric learning" scheme="http://yoursite.com/tags/metric-learning/"/>
    
  </entry>
  
</feed>
