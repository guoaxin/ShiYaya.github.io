<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Graph Matching Networks for Learning the Similarity of Graph Structured Objects</title>
      <link href="/2019/12/20/Graph-Matching-Networks-for-Learning-the-Similarity-of-Graph-Structured-Objects/"/>
      <url>/2019/12/20/Graph-Matching-Networks-for-Learning-the-Similarity-of-Graph-Structured-Objects/</url>
      
        <content type="html"><![CDATA[<ul><li>ICML 2019</li></ul><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><ul><li>本文主要是提出了一种 新的方法来计算图的相似度问题</li><li>普通的方法分别单独计算 graph vector，而后再计算graph 之间的相似性</li><li>新提出的方法在计算  graph vector 时考虑了 cross graph matching vector来得到 更具有判别性的 graph vector，从而更好的用于 计算 graph similarity.</li></ul><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><ul><li>Graph Edit Distance（GED）：文中对问题进行了简化，两个graph（G1, G2），相同数量的节点数和边数, 如何变动一个图中的edge(i, j) 到 edge(i’, j’) 才能使两个graph 完全一样。以下是 GED=1 的例子。</li></ul><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ga3ats0xyzj308p07jaaw.jpg" alt="搜狗截图20191220170651.png"></p><ul><li>该文主要是想解决graph 的相似性问题，而不是真正的要求解出来需要几步的 graph edit distance。因此对问题做了如下的设定：<code>positive pair:（原图G，对G变动一条边：G1）</code>，<code>negative pair: （原图G，对G变动两条边：G1）</code></li><li>positive pair 认为这两个 graph 是相似的，label=1; 而negative pair认为两个graph 是不相似的, label=-1。</li></ul><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1ga3b3udt8bj30pe0bsgnq.jpg" alt="搜狗截图20191220171642.png"></p><ul><li><p>一般的计算两个graph之间的相似性问题采用上图中的左图的方法，分别单独计算出 graph vector，而后再计算 vector space similarity</p></li><li><p>而本文：计算两个graph之间的匹配，然后互相作为补充特征（cross-graph matching vector），得到更加 <strong>discriminative</strong>  graph representation， 从而更加有效的graph 之间的相似度问题。</p></li><li><p>yaya: 文中使用的是 <code>difference between node_i and its closest neighbor in the other graph</code>  来计算  <code>cross-graph matching vector</code> 。我认为还可以有其他的方法或许会更加有效。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图卷积网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图卷积网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quality Estimation for Image Captions Based on Large-scale Human Evaluations</title>
      <link href="/2019/12/12/Quality-Estimation-for-Image-Captions-Based-on-Large-scale-Human-Evaluations/"/>
      <url>/2019/12/12/Quality-Estimation-for-Image-Captions-Based-on-Large-scale-Human-Evaluations/</url>
      
        <content type="html"><![CDATA[<h3 id="Quality-Estimation-QE-of-image-captions"><a href="#Quality-Estimation-QE-of-image-captions" class="headerlink" title="Quality Estimation (QE) of image-captions"></a>Quality Estimation (QE) of image-captions</h3><ul><li>本文提出了在图像描述领域一个新的问题，Quality Estimation。由于当前的 automatic metric 非常依赖 ground-truth references，因此当一个模型训练好后，若是对一个 unseen images which don’t have gt sentence 进行描述，则无法对该描述进行评价。    </li></ul><h3 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h3><h4 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h4><ul><li>（1）首先在 Conceptual Captions dataset  上训练多个 image-captioning model （这个数据集会在比 coco上训练的captioning model 更好），captioning model的差异可以体现在 image feature extraction model，object detection提取的object 数量，caption decoder。    </li><li>（2）以上的 image-captioning model 可以为一个image 提供多个 sentence，作者对image 进行了脱敏处理    </li></ul><h4 id="数据打分及处理"><a href="#数据打分及处理" class="headerlink" title="数据打分及处理"></a>数据打分及处理</h4><ul><li><p>（1）这些 image-caption pairs 放到 crowdsource.google上让大家对这些 captioning，进行评价：好、坏或者跳过。每个image-captioning pair 被分配给10个人进行打分     </p></li><li><p>（2）得到收集的 rating image-captioning pairs 之后，对 unique image，将10个评分进行处理， using the equation y = round(mean(ri) ∗ 8)/8.     </p></li></ul><h4 id="QE-Model"><a href="#QE-Model" class="headerlink" title="QE Model"></a>QE Model</h4><ul><li>本文作者设计了两个模型（并把这两个模型进行融合）来处理 QE task。一个是使用到 image-captioning model，两一个是不使用   </li><li>（1）使用image-captioning model：<strong>Confidence-based Features QE Model</strong><br><img src="http://ww1.sinaimg.cn/large/006uWRWVgy1g9txhzr2swj30yc0i642k.jpg" alt="搜狗截图20191212143453.png"></li><li>（2） 不使用 image-captioning model：<strong>Generation-independent Bilinear QE model</strong><br><img src="http://ww1.sinaimg.cn/large/006uWRWVgy1g9txhzmt4rj30xs0apq5u.jpg" alt="搜狗截图20191212143515.png"></li></ul><h4 id="Spearman’s-ρ-Analysis"><a href="#Spearman’s-ρ-Analysis" class="headerlink" title="Spearman’s ρ Analysis"></a>Spearman’s ρ Analysis</h4><ul><li>该文的主要目的就是希望在 没有gt sentence 的情况下，对 unseen-image 进行描述时，可以给出一个caption 的评分。或者是说，该captioning与 人类的描述的相近程度。</li><li>该任务也是希望提出一个 machine learning metric similar to human evaluation （trained-metric），则对该模型好坏的一个的评判就是这个模型给出的评分与人类评分的相近程度。</li><li>predict： 模型对image-caption pair 的评分， Gt:  人类给出的评分</li><li>指标：Spearman’s correlation.  <a href="https://github.com/ShiYaya/spearman-rank" target="_blank" rel="noopener">my github explanation</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图像描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pth: save in py2, but load in py3</title>
      <link href="/2019/12/11/pth-save-in-py2-but-load-in-py3/"/>
      <url>/2019/12/11/pth-save-in-py2-but-load-in-py3/</url>
      
        <content type="html"><![CDATA[<h3 id="在torch-load-pth-时出现的问题：UnicodeDecodeError-39-utf-8-39-codec-can-39-t-decode-byte-0xba-in-position-0-invalid-start-byte"><a href="#在torch-load-pth-时出现的问题：UnicodeDecodeError-39-utf-8-39-codec-can-39-t-decode-byte-0xba-in-position-0-invalid-start-byte" class="headerlink" title="在torch.load(*.pth) 时出现的问题：UnicodeDecodeError: &#39;utf-8&#39; codec can&#39;t decode byte 0xba in position 0: invalid start byte"></a>在torch.load(*.pth) 时出现的问题：<code>UnicodeDecodeError: &#39;utf-8&#39; codec can&#39;t decode byte 0xba in position 0: invalid start byte</code></h3><ul><li><p>经过网络查询，发现是由于该文件是在 python2 下保存的，但是现在却是在python3下读取，而导致的错误</p></li><li><p>有的人给出了下面的解决方案(但是对于我是无效的)：    </p><p>来自：<a href="https://github.com/CSAILVision/places365/issues/25" target="_blank" rel="noopener">https://github.com/CSAILVision/places365/issues/25</a></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools import partial</span><br><span class="line">import pickle</span><br><span class="line">pickle.load = partial(pickle.load, <span class="attribute">encoding</span>=<span class="string">"latin1"</span>)</span><br><span class="line">pickle.Unpickler = partial(pickle.Unpickler, <span class="attribute">encoding</span>=<span class="string">"latin1"</span>)</span><br><span class="line">model = torch.load(model_file, <span class="attribute">map_location</span>=lambda storage, loc: storage, <span class="attribute">pickle_module</span>=pickle)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>这里给出我的解决办法</strong>   </p><p>（1） 在python2 环境下读取该文件，然后用 pickle来保存   </p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tmp_data = torch.<span class="built_in">load</span>(model_file)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'tmp.pickle'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> <span class="built_in">file</span>:</span><br><span class="line">    pickle.dump(tmp_data, <span class="built_in">file</span>, protocol=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>（2）换到python3环境下，再读取pickle文件，再用torch.load来保存（这一点或可以省略）</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'tmp.pickle'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> <span class="built_in">file</span>:</span><br><span class="line">    tmp_data = pickle.<span class="built_in">load</span>(<span class="built_in">file</span>, encoding=<span class="string">'latin1'</span>)</span><br><span class="line">    </span><br><span class="line">torch.save(tmp_data, tmp_model.pth)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Weakly-Supervised Spatio-Temporally Grounding Natural Sentence in Video</title>
      <link href="/2019/12/02/Weakly-Supervised-Spatio-Temporally-Grounding-Natural-Sentence-in-Video/"/>
      <url>/2019/12/02/Weakly-Supervised-Spatio-Temporally-Grounding-Natural-Sentence-in-Video/</url>
      
        <content type="html"><![CDATA[<ul><li><strong>ACL 2019</strong></li></ul><h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><ul><li><p>image grounding取得了很大的进步，但是将该任务迁移到视频上，需要对视频中的每帧都标注region，这个工程量是巨大的。</p></li><li><p>为了避免这种标注工作的工程量，一些<strong>weakly-supervised</strong> video grouding工作【1】【2】被提出来，他们只提供了video-sentence pairs，没有提供 fine-grained regional annotations。在他们的 video grounding任务中，他们仅仅对名词和代词在 视频的静态帧进行grounding。</p></li><li><p>但是这种 grounding存在问题，比如sentence: A brown and white dog is lying on the grass and then it stands up. 但是帧中出现了多个狗，而我们给出的要搜索的对象仅仅是一个名词： ‘dog’，没有其他更多的信息，来进行更加具体地定位，那么就有可能定位错误。另外只对一张静态帧进行定位，也无法捕捉到object在时域上的动态变化。</p></li><li><p>基于上述的分析，本文提出了一个在video grounding上 weakly-supervised 的新任务：<strong>weakly-supervised spatio-temporally grounding sentence in video (WSSTG).</strong>    </p></li></ul><h3 id="Weakly-supervised-spatio-temporally-grounding-sentence-in-video"><a href="#Weakly-supervised-spatio-temporally-grounding-sentence-in-video" class="headerlink" title="Weakly-supervised spatio-temporally grounding sentence in video"></a>Weakly-supervised spatio-temporally grounding sentence in video</h3><ul><li>Specifically, given a natural sentence and a video, we aim to localize a spatio-temporal tube (i.e., a sequence of bounding boxes) ,（本文中作者将tube 称作 instance）</li><li>yaya: 相比于之前的video-grounding任务，同是 weakly-supervised，但是有两点不同：（1）是句子级别的描述，对要定位的对象的描述更加具体，而不是仅仅是个noun。（2）是要定位出一个 spatial-temporal tube，而不是仅在一张静态帧中定位出一个bbox。</li><li>这两点不同同时带来了优势和挑战</li><li>（1）细节性的描述可以消除歧义，但是如何捕捉句子中的语义并在video中定位出来是一个难题；（2）相比于在静态帧中定位一个bbox, 而是在video中定位一个tube,更能呈现出一个object在时域上的动态。但是，如何利用和建模tube的时空特性以及它们与句子的复杂关系提出了另一个挑战。</li><li>compared with 【2】: different from 【2】，whose text input consists of nouns/pronouns and output is a bounding box in a specific frame, we aim  to ground a natural sentence and output a spatio-temporal tube in the video. </li></ul><h3 id="Contributions"><a href="#Contributions" class="headerlink" title="Contributions"></a>Contributions</h3><ul><li>提出了一个新任务：weakly-supervised spatio-temporally grounding sentence in video</li><li>针对该任务提出了一个method：提出了一个Attentive interactor利用 tube(instance) 与 sentence之间的细粒度的关系来计算 匹配度；提出了一个diversity loss来加强 reliable instance-sentence pairs 并惩罚 unreliable ones。</li><li>在VID object detection dataset 数据集的基础上，对tube(instance) 增加了description</li></ul><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><h4 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h4><ul><li>该任务是 给出一个 a natural sentence query <strong>q</strong> and a video <strong>v</strong> 来定位一个spatial-temporal tube，作者也将这个tube 称作 instance。</li><li>由于是弱监督，因此仅仅只给出 video-sentence pair，细粒度的regional annotations不给出！</li><li>将该任务转为一个 Multiple instance learning problem。给定一个video，首先由instance generator【3】来生成一组instance proposals，然后再根据语义相似性来匹配 natural sentence query 和 instance。  </li></ul><h4 id="Instance-Extraction"><a href="#Instance-Extraction" class="headerlink" title="Instance Extraction"></a>Instance Extraction</h4><ul><li><strong>Instance Generation</strong> ：  先由faster rcnn提取object proposals，假设每帧提取N个proposal ， 然后根据【3】得到N个spatial-temporal tube</li><li><strong>Feature Representation</strong> ：I3D-RGB， I3D-Flow， frame-level RoI pooled feature   </li></ul><h4 id="Attentive-Interactor"><a href="#Attentive-Interactor" class="headerlink" title="Attentive Interactor"></a>Attentive Interactor</h4><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g9io2sodynj30i40hk0v9.jpg" alt="搜狗截图20191202204720.png"></p><ul><li>（1）分别对 sequential visual features 和 sequential textual features 经过LSTM进行编码，LSTM每个step输出的隐层状态作为新的representation，得到新的visual feature 和 sentence representation</li><li>（2）依次以visual feature中的每个隐状态作为查询，以 sentence 所有隐状态作为key 和 value，输入Attention中，则得到了<strong>visual guided sentence feature</strong>。（直观的理解：在给定某一个视觉特征，用attention去分析要关注哪一个word）  </li></ul><h4 id="Matching-Behavior-Characterization"><a href="#Matching-Behavior-Characterization" class="headerlink" title="Matching Behavior Characterization"></a>Matching Behavior Characterization</h4><ul><li>用余弦函数计算 <code>i-th</code> visual feature 和 visual guided sentence features 之间的 匹配度</li><li>对所有的step 加和，则得到instance proposal 与 sentence 之间的匹配度</li></ul><h3 id="Training-Loss"><a href="#Training-Loss" class="headerlink" title="Training Loss"></a>Training Loss</h3><ul><li><p>论文对这里介绍的比较详细，参见论文。</p></li><li><p><strong>ranking loss</strong>： aiming at distinguishing aligned video-sentence pairs from the unaligned ones.  这个损失是希望不匹配的video-sentence之间计算出来的匹配度差一些，比如给网络输入不与该视频对应的句子。</p></li><li><p><strong>novel diversity loss</strong> ：to strengthen the matching behaviors between reliable instance-sentence pairs and penalize the unreliable ones from the aligned video-sentence pair.  这个损失主要是希望对一个video，在计算tube 与 sentence之间的匹配度时，希望不同的 tube之间的差异性（diversity）大一些！</p></li></ul><h3 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h3><ul><li>一个video 给出了N个 tube proposal，当计算完匹配度之后，选取匹配度最大的那个proposal，然后计算与GT之间的 overlap【4】，若overlap 大于一个阈值，则任务预测正确。</li></ul><h3 id="Yaya-Analysis："><a href="#Yaya-Analysis：" class="headerlink" title="Yaya Analysis："></a>Yaya Analysis：</h3><ul><li><p><strong>此类任务可提升的point</strong></p></li><li><p>更好的 detector来获取 object proposal</p></li><li><p>更好的算法来获取 tube proposal</p></li><li><p>设计算法更好滴计算 sentence 与 tube proposal 匹配度！</p></li><li><p>对 rank loss 给予更多的约束，像此文：提出了一个novel  diversity loss</p></li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li>【1】De-An Huang, Shyamal Buch, Lucio Dery, Animesh Garg, Li Fei-Fei, and Juan Carlos Niebles. 2018. <strong>Finding “it”: Weakly-supervised reference-aware visual grounding in instructional videos</strong>. In CVPR. </li><li>【2】Luowei Zhou, Nathan Louis, and Jason J Corso. 2018. <strong>Weakly-supervised video object grounding from text by loss weighting and object interaction</strong>. BMVC. </li><li>【3】Georgia Gkioxari and Jitendra Malik. 2015. <strong>Finding action tubes</strong>. In CVPR, pages 759–768. </li><li>【4】Masataka Yamaguchi, Kuniaki Saito, Yoshitaka Ushiku, and Tatsuya Harada. 2017. <strong>Spatio-temporal person retrieval via natural language queries</strong>. In ICCV. </li></ul>]]></content>
      
      
      <categories>
          
          <category> Visual Grounding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Viusal Grounding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Finding It: Weakly-Supervised Reference-Aware Visual Grounding in Instructional Videos</title>
      <link href="/2019/12/02/Finding-It-Weakly-Supervised-Reference-Aware-Visual-Grounding-in-Instructional-Videos/"/>
      <url>/2019/12/02/Finding-It-Weakly-Supervised-Reference-Aware-Visual-Grounding-in-Instructional-Videos/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Learning to Generate Grounded Visual Captions without Localization Supervision</title>
      <link href="/2019/12/01/Learning-to-Generate-Grounded-Visual-Captions-without-Localization-Supervision/"/>
      <url>/2019/12/01/Learning-to-Generate-Grounded-Visual-Captions-without-Localization-Supervision/</url>
      
        <content type="html"><![CDATA[<h3 id="ICLR-2020-under-view"><a href="#ICLR-2020-under-view" class="headerlink" title="ICLR 2020 under view"></a>ICLR 2020 under view</h3><h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><ul><li><p>问题：在captioning 任务中，当前的评价指标并不能很好的反应生成的句子与该视频之间的契合度（Groud），有可能生成的句子只是基于在训练过程中学习到的priors（一种统计特性，而不是基于该视频本身）</p></li><li><p>当前模型对于 groud 这个任务，存在的困难：（1）由于当前的 language model 常使用 attention 机制来关注某一个 region，以此来预测下一个生成的单词。换句话说，就是在不知道将会生成什么单词的情况下，却要先定位region， 另外，一篇论文 [1] 提出，attention机制关注的region与人类所关注的并不一致（2）更难的是：传入 attention网络的是 RNN 的 hidden_state，由于 RNN 的记录历史的特性，这个输入包括的是过去所有的信息，而不是针对于某一个individual word。  </p></li></ul><h3 id="Contributions"><a href="#Contributions" class="headerlink" title="Contributions"></a>Contributions</h3><ul><li>不同于 GVD，该文不使用 annotation bbox 作为监督信号，而是使用了 decoder + localizer + redecoder的结构来自我监督（self-supervision）</li><li>由于其自监督的特性，在一些infrequent word上该文的方法比监督的方法，效果更好</li><li>不仅使用一般的为每个 object class 计算 grounding accuracy， 还提出了一个新的指标：为每个sentence 计算grounding accuracy。</li></ul><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><ul><li><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g9heo6n8glj318k0lp0ze.jpg" alt="搜狗截图20191201183637.png"></p></li><li><p><strong>分阶段训练</strong></p></li><li><p>（1）正常的 encoder-decoder先训练 ~30个epoch</p></li><li><p>（2）在正常的基础上进行添加。 （a）<strong>re-localize</strong>: language_lstm 会得到y1, y2, …, yT 个预测的序列，将这些序列作为attention机制中的 查询向量，赋给每个region一个attention系数，这样就可以在每一个step重构attention系数分配，这样也解决了motivation中提到的问题，即attention是由某一个individual word 而计算得来的。（b）每个step 有了attention对齐之后的attention_region， 再输入到language_LSTM中，得到<strong>再次预测的sequence of word</strong>。</p></li><li><p>在这第二阶段，就是两个loss 交叉熵损失进行权重加和来训练</p></li><li><p>可以发现一个问题，对于visual-words 和 non-visual-words都进行了re-localize。实际上对于，on a 等这类词汇，并不需要在image中找到 grounded region。 该文作者在补充材料里给出了一些额外的实验， eg, 将这些non-visual words 进行抑制，不计算reconstruction loss, 或者给这些localized region representation重新赋给invalid representaion。但是实验表明，在Flickr30 上性能（caption and ground）有提升，但是在 activity上（caption 没变化，ground下降）。</p></li><li><p>但是作者并没有给出分析，我个人总觉得实验设计的不完善，分析的也不多。</p></li></ul><h3 id="Measuring-grounding-per-generated-sentence"><a href="#Measuring-grounding-per-generated-sentence" class="headerlink" title="Measuring grounding per generated sentence"></a>Measuring grounding per generated sentence</h3><ul><li>提该指标的原因：（Such metrics （F1all, F1loc） are extremely stringent as captioning models are generally biased toward certain words in the vocabulary, given the long-tailed distribution of words. ）</li></ul><h3 id="Analysis-Grounding-performance-when-using-a-better-object-detector"><a href="#Analysis-Grounding-performance-when-using-a-better-object-detector" class="headerlink" title="Analysis:  Grounding performance when using a better object detector."></a>Analysis:  Grounding performance when using a better object detector.</h3><ul><li>在 Flickr30k Entities 上进行实验，分析 better detector 对 grounding性能的影响</li><li>（1）使用 GT box (ubrealistically) ，进行实验，发现 caption metric 和 grounding accuracy都有提升</li><li>（2）在 Flickr30k上训练一个detector（之前使用的是在 visual genome上训练好的），进行实验，发现，使得caption metirc下降，（作者分析：由于在本数据集上进行训练，得到的 the ROI features and their associated object predictions 更偏向于 该数据中的  the annotated object words 却不能很好地泛化以预测 diverse captions， 从而导致了captioning 指标下降）</li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1] Abhishek Das, Harsh Agrawal, Larry Zitnick, Devi Parikh, and Dhruv Batra.  <strong>Human attention in visual question answering: Do humans and deep networks look at the same regions?</strong>  Computer Vision and Image Understanding, 163:90–100, 2017. </p>]]></content>
      
      
      <categories>
          
          <category> 视频描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vatex_challenge_solutions</title>
      <link href="/2019/10/20/vatex-challenge-solutions/"/>
      <url>/2019/10/20/vatex-challenge-solutions/</url>
      
        <content type="html"><![CDATA[<script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.4.1.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />    <label for="pass">Welcome to my blog, enter password to read.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> 视频描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytorch 索引 切片</title>
      <link href="/2019/10/10/pytorch-%E7%B4%A2%E5%BC%95-%E5%88%87%E7%89%87/"/>
      <url>/2019/10/10/pytorch-%E7%B4%A2%E5%BC%95-%E5%88%87%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h2 id="给出：四维张量，三维的索引。根据索引得到张量中对应的数据"><a href="#给出：四维张量，三维的索引。根据索引得到张量中对应的数据" class="headerlink" title="给出：四维张量，三维的索引。根据索引得到张量中对应的数据"></a>给出：四维张量，三维的索引。根据索引得到张量中对应的数据</h2><ul><li><p>四维张量，object_feats.shape = [bs, 28, 5, 1024]。一个video中截取 28帧，每帧提取5个object, 其特征向量维度为1024</p></li><li><p>三维索引，traj_idx.shape = [bs, 28, 5]。以第一帧 frame上的 5个object 作为anchor，找到以该anchor 作为开头的轨迹（即，在其余帧上的对应的objects的索引），</p></li><li><p>目标：由索引，提取对应的 object feature</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traj_feats = object_feats.gather(<span class="number">2</span>, traj_idx.unsqueeze(<span class="number">3</span>).expand_as(object_feats))</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 objects position 作为特征的论文</title>
      <link href="/2019/10/10/%E4%BD%BF%E7%94%A8-objects-position-%E4%BD%9C%E4%B8%BA%E7%89%B9%E5%BE%81%E7%9A%84%E8%AE%BA%E6%96%87/"/>
      <url>/2019/10/10/%E4%BD%BF%E7%94%A8-objects-position-%E4%BD%9C%E4%B8%BA%E7%89%B9%E5%BE%81%E7%9A%84%E8%AE%BA%E6%96%87/</url>
      
        <content type="html"><![CDATA[<script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.4.1.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />    <label for="pass">Welcome to my blog, enter password to read.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对分类损失的优化</title>
      <link href="/2019/09/23/%E5%AF%B9%E5%88%86%E7%B1%BB%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E4%BC%98%E5%8C%96/"/>
      <url>/2019/09/23/%E5%AF%B9%E5%88%86%E7%B1%BB%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>视频描述评价指标的分析</title>
      <link href="/2019/09/21/%E8%A7%86%E9%A2%91%E6%8F%8F%E8%BF%B0%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87%E7%9A%84%E5%88%86%E6%9E%90/"/>
      <url>/2019/09/21/%E8%A7%86%E9%A2%91%E6%8F%8F%E8%BF%B0%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87%E7%9A%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.4.1.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />    <label for="pass">Welcome to my blog, enter password to read.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 视频描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neural Motifs: Scene Graph Parsing with Global Context</title>
      <link href="/2019/09/18/Neural-Motifs-Scene-Graph-Parsing-with-Global-Context/"/>
      <url>/2019/09/18/Neural-Motifs-Scene-Graph-Parsing-with-Global-Context/</url>
      
        <content type="html"><![CDATA[<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><ul><li>给出了一个对 repeated structures 的量化分析</li><li>分析显示，（1）由object label对预测 relation label是有效的，但是反之却不成立。（2）在一个image graph中会出现重复的模板（eg：大象有耳朵，大象有鼻子，  XX has YY）</li></ul><h2 id="Models"><a href="#Models" class="headerlink" title="Models"></a>Models</h2><ul><li>给定 object feature 和 object label 来去预测 relation label</li></ul>]]></content>
      
      
      <categories>
          
          <category> 场景图解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 场景图解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>video captioning 任务的难点？</title>
      <link href="/2019/09/07/video-captioning-%E4%BB%BB%E5%8A%A1%E7%9A%84%E9%9A%BE%E7%82%B9%EF%BC%9F/"/>
      <url>/2019/09/07/video-captioning-%E4%BB%BB%E5%8A%A1%E7%9A%84%E9%9A%BE%E7%82%B9%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.4.1.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />    <label for="pass">Welcome to my blog, enter password to read.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 视频描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频描述任务中用到objects的论文总结</title>
      <link href="/2019/09/01/%E8%A7%86%E9%A2%91%E6%8F%8F%E8%BF%B0%E4%BB%BB%E5%8A%A1%E4%B8%AD%E7%94%A8%E5%88%B0objects%E7%9A%84%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/"/>
      <url>/2019/09/01/%E8%A7%86%E9%A2%91%E6%8F%8F%E8%BF%B0%E4%BB%BB%E5%8A%A1%E4%B8%AD%E7%94%A8%E5%88%B0objects%E7%9A%84%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<ul><li><p>CVPR 2018</p><ol><li>Fine-grained Video Captioning for Sports Narrative</li></ol></li><li><p>CVPR 2019</p><ol><li>Grounded Video Description</li><li>Object-aware Aggregation with Bidirectional Temporal Graph for Video Captioning</li><li>Spatio-Temporal Dynamics and Semantic Attribute Enriched Visual Encoding for Video Captioning 【再去读一遍】</li><li>Adversarial Inference for Multi-Sentence Video Description</li></ol></li><li><p>ACM 2019</p><ol><li>Hierarchical Global-Local Temporal Modeling for Video Captioning</li></ol></li></ul><h3 id="Grounded-Video-Description"><a href="#Grounded-Video-Description" class="headerlink" title="Grounded Video Description"></a>Grounded Video Description</h3><p><img src="https://i.loli.net/2019/09/02/Hvtk4BJVNQ2WwdM.png" alt="搜狗截图20190902104324.png"></p><ol><li><p>如何使用region feature？</p><p> 仅在language lstm 用到了 region featrue, attention 加权求和之后 与 cat[ fc, motion] features 对应元素相加（cat[fc, motion]也是在经过attention加权求和之后的）</p><p> 但我个人认为对应元素相加，并没有道理，相当于在 cat[ fc, motion] 的基础上增加了一个 bias，没有什么道理</p></li><li><p>region feature 的构成？</p><p>R：是 object detector  在 fc6 输出的 feature</p><p>Ms(R)：是 object detector 在 fc7 输出的feature (这里有一些细节的修改，具体见论文)</p><p>Ml： 是 position embedding</p></li></ol><p><img src="https://i.loli.net/2019/09/02/y4JkxlmLQpqaj5c.png" alt="搜狗截图20190902105022.png"></p><h3 id="Object-aware-Aggregation-with-Bidirectional-Temporal-Graph-for-Video-Captioning"><a href="#Object-aware-Aggregation-with-Bidirectional-Temporal-Graph-for-Video-Captioning" class="headerlink" title="Object-aware Aggregation with Bidirectional Temporal Graph for Video Captioning"></a>Object-aware Aggregation with Bidirectional Temporal Graph for Video Captioning</h3><p><img src="https://i.loli.net/2019/09/02/TIP7Ww3FnLNKzvu.png" alt="搜狗截图20190902144125.png"></p><ol><li><p>简要介绍本文的结构</p><p> 在encoder 部分，使用 object feature 和 frame feature，分别经过设计的VALD 得到更新的特征向量</p><p> 在 decoder 部分，对object feature 使用两层的attention, 先对 <strong>一个轨迹</strong>上的objects 进行attention 的加权求和，再对N different objects instances进行 attention 的加权求和，这样就可以得到对所有objects 的聚合表达</p><p> 轨迹：对于第一帧的ojects, 根据相似性分别去找其他帧与其对应的objects，而构成的时域轨迹。</p><p>  这里采用了前向轨迹，和后向轨迹两种，在decoder 输出预测的单词之后，进行融合。</p></li><li><p>如何使用region feature？<br> 仅有一个lstm ，在输入lstm前对objects features进行两层attention 加权求和后，与同样经过attention的frames feature进行加和（sum）。<br> 本文没有使用 motion feeture</p></li><li><p>region feature 的构成？<br> 非常简单，只有 appearance feature，但是经过了 obejct VLAD module！</p></li><li><p><font color="#0099ff" size="5" face="黑体">object feature 的 hierarchical attention 值得借鉴呢！<br>计算object 相似性的部分也不错</font></p></li></ol><h3 id="Spatio-Temporal-Dynamics-and-Semantic-Attribute-Enriched-Visual-Encoding-for-Video-Captioning"><a href="#Spatio-Temporal-Dynamics-and-Semantic-Attribute-Enriched-Visual-Encoding-for-Video-Captioning" class="headerlink" title="Spatio-Temporal Dynamics and Semantic Attribute Enriched Visual Encoding for Video Captioning"></a>Spatio-Temporal Dynamics and Semantic Attribute Enriched Visual Encoding for Video Captioning</h3><p><img src="https://i.loli.net/2019/09/02/T5AzpW8DHkVL2Oy.png" alt="搜狗截图20190902152617.png"></p><ul><li>此文没有太看懂</li></ul><ol><li><p>如何使用region feature？</p><p> 得到 obejcts sematics embeddding 一起其他三个信息，经过聚合之后得到特征向量v，再经过一个线性变换得到v，再送入decoder中</p></li><li><p>region feature 的构成？</p><p> 由 object detector 输出的特征，以及其他输出（objetcs 存现的频率、概率），来构建semantics</p></li></ol><h3 id="Hierarchical-Global-Local-Temporal-Modeling-for-Video-Captioning"><a href="#Hierarchical-Global-Local-Temporal-Modeling-for-Video-Captioning" class="headerlink" title="Hierarchical Global-Local Temporal Modeling for Video Captioning"></a>Hierarchical Global-Local Temporal Modeling for Video Captioning</h3><p><img src="https://i.loli.net/2019/09/02/m5xLQnzCJGsjWVc.png" alt="搜狗截图20190902161552.png"></p><ol><li><p>如何使用region features ?</p><p> encoder 部分由两层LSTM，第一层LSTM 构建 frames features 和 c3d features的 隐层状态，并送入第二层LSTM，</p><p>在第二层LSTM 的每一个step, 都对该step 对应帧上的 objetcs进行attention 加权求和，并送入LSTM中，得到该帧的objects 的聚合特征的隐层状态   </p><p> <img src="https://i.loli.net/2019/09/02/q6XNP8iSVzekyCE.png" alt="搜狗截图20190902165813.png"></p></li><li><p>region feature 的构成？</p><p>   每帧 objects features 的加权求和，再经过LSTM得到隐层状态</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>当前基于 objects feature 的论文，decoder 部分没有太大的新颖（一般都是Top-Down或者是 Soft-Attention），主要的新颖的地方是在 encoder 部分</li><li>encoder部分有的使用LSTM 以及attention 来更新 objects features；有的使用VLAD 来构建 行为特征，使用 objects 的时域轨迹和两层attention 来聚合特征；使用objetcs 的其他信息，比如 position 以及 label 等信息</li></ul>]]></content>
      
      
      <categories>
          
          <category> 视频描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>目标检测模型中的性能评估——MAP(Mean Average Precision))</title>
      <link href="/2019/08/31/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E2%80%94%E2%80%94MAP-Mean-Average-Precision/"/>
      <url>/2019/08/31/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E2%80%94%E2%80%94MAP-Mean-Average-Precision/</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="https://blog.csdn.net/katherine_hsr/article/details/79266880" target="_blank" rel="noopener">https://blog.csdn.net/katherine_hsr/article/details/79266880</a></p>]]></content>
      
      
      <categories>
          
          <category> 目标检测 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多标签图像分类任务的评价方法-mAP</title>
      <link href="/2019/08/31/%E5%A4%9A%E6%A0%87%E7%AD%BE%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%AF%84%E4%BB%B7%E6%96%B9%E6%B3%95-mAP/"/>
      <url>/2019/08/31/%E5%A4%9A%E6%A0%87%E7%AD%BE%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%AF%84%E4%BB%B7%E6%96%B9%E6%B3%95-mAP/</url>
      
        <content type="html"><![CDATA[<p>转载 from: <a href="http://blog.sina.com.cn/s/blog_9db078090102whzw.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_9db078090102whzw.html</a></p><p>多标签图像分类（Multi-label   Image  Classification）任务中图片的标签不止一个，因此评价不能用普通单标签图像分类的标准，即mean  accuracy，该任务采用的是和信息检索中类似的方法—mAP（mean  Average  Precision）。mAP虽然字面意思和mean  accuracy看起来差不多，但是计算方法要繁琐得多，以下是mAP的计算方法：</p><p>首先用训练好的模型得到所有测试样本的confidence  score，每一类（如car）的confidence   score保存到一个文件中（如comp1_cls_test_car.txt）。假设共有20个测试样本，每个的id，confidence  score和ground  truth  label如下：</p><p><a href="http://blog.photo.sina.com.cn/showpic.html#url=http://album.sina.com.cn/pic/002T2ChPgy6XQd58yJ15f" target="_blank" rel="noopener"><img src="http://s16.sinaimg.cn/mw690/002T2ChPgy6XQd58yJ15f" alt="img"></a> </p><p>接下来对confidence  score排序，得到：</p><p><a href="http://blog.photo.sina.com.cn/showpic.html#url=http://album.sina.com.cn/pic/002T2ChPgy6XQd86isc4c" target="_blank" rel="noopener"><img src="http://s13.sinaimg.cn/mw690/002T2ChPgy6XQd86isc4c" alt="img"></a><em>这张表很重要，接下来的precision和recall都是依照这个表计算的</em>﻿</p><p>然后计算precision和recall，这两个标准的定义如下：</p><p><a href="http://blog.photo.sina.com.cn/showpic.html#url=http://album.sina.com.cn/pic/002T2ChPgy6XQdjij4Ae8" target="_blank" rel="noopener"><img src="http://s9.sinaimg.cn/mw690/002T2ChPgy6XQdjij4Ae8" alt="img"></a></p><p>上图比较直观，圆圈内（true   positives + false  positives）是我们选出的元素,它对应于分类任务中我们取出的结果，比如对测试样本在训练好的car模型上分类，我们想得到top-5的结果，即：</p><p><a href="http://blog.photo.sina.com.cn/showpic.html#url=http://album.sina.com.cn/pic/002T2ChPgy6XQdbTpla5c" target="_blank" rel="noopener"><img src="http://s13.sinaimg.cn/mw690/002T2ChPgy6XQdbTpla5c" alt="img"></a></p><p>在这个例子中，true   positives就是指第4和第2张图片，false   positives就是指第13，19，6张图片。方框内圆圈外的元素（false   negatives和true  negatives）是相对于方框内的元素而言，在这个例子中，是指confidence   score排在top-5之外的元素，即：</p><p><a href="http://blog.photo.sina.com.cn/showpic.html#url=http://album.sina.com.cn/pic/002T2ChPgy6XQdcMwKCea" target="_blank" rel="noopener"><img src="http://s11.sinaimg.cn/mw690/002T2ChPgy6XQdcMwKCea" alt="img"></a> </p><p>其中，false   negatives是指第9，16，7，20张图片，true   negatives是指第1,18,5,15,10,17,12,14,8,11,3张图片。</p><p>那么，这个例子中Precision=2/5=40%，意思是对于car这一类别，我们选定了5个样本，其中正确的有2个，即准确率为40%；Recall=2/6=30%，意思是在所有测试样本中，共有6个car，但是因为我们只召回了2个，所以召回率为30%。</p><p>实际多类别分类任务中，我们通常不满足只通过top-5来衡量一个模型的好坏，而是需要知道从top-1到top-N（N是所有测试样本个数，本文中为20）对应的precision和recall。显然随着我们选定的样本越来也多，recall一定会越来越高，而precision整体上会呈下降趋势。把recall当成横坐标，precision当成纵坐标，即可得到常用的precision-recall曲线。这个例子的precision-recall曲线如下：</p><p><a href="http://blog.photo.sina.com.cn/showpic.html#url=http://album.sina.com.cn/pic/002T2ChPgy6XQddBz7ze9" target="_blank" rel="noopener"><img src="http://s10.sinaimg.cn/mw690/002T2ChPgy6XQddBz7ze9" alt="img"></a></p><p>接下来说说AP的计算，此处参考的是PASCAL  VOC  CHALLENGE的计算方法。首先设定一组阈值，[0, 0.1, 0.2, …, 1]。然后对于recall大于每一个阈值（比如recall&gt;0.3），我们都会得到一个对应的最大precision。这样，我们就计算出了11个precision。AP即为这11个precision的平均值。这种方法英文叫做11-point interpolated average precision。</p><p>当然PASCAL VOC CHALLENGE自2010年后就换了另一种计算方法。新的计算方法假设这N个样本中有M个正例，那么我们会得到M个recall值（1/M, 2/M, …, M/M）,对于每个recall值r，我们可以计算出对应（r’ &gt; r）的最大precision，然后对这M个precision值取平均即得到最后的AP值。计算方法如下：</p><p><a href="http://blog.photo.sina.com.cn/showpic.html#url=http://album.sina.com.cn/pic/002T2ChPzy76AuWjHOp29" target="_blank" rel="noopener"><img src="http://s10.sinaimg.cn/mw690/002T2ChPzy76AuWjHOp29" alt="img"></a></p><p>相应的Precision-Recall曲线（这条曲线是单调递减的）如下：</p><p><a href="http://blog.photo.sina.com.cn/showpic.html#url=http://album.sina.com.cn/pic/002T2ChPzy76AuH9Z6010" target="_blank" rel="noopener"><img src="http://s1.sinaimg.cn/mw690/002T2ChPzy76AuH9Z6010" alt="img"></a></p><p>AP衡量的是学出来的模型在每个类别上的好坏，mAP衡量的是学出的模型在所有类别上的好坏，得到AP后mAP的计算就变得很简单了，就是取所有AP的平均值。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>到底ResNet在解决一个什么问题呢</title>
      <link href="/2019/08/17/%E5%88%B0%E5%BA%95ResNet%E5%9C%A8%E8%A7%A3%E5%86%B3%E4%B8%80%E4%B8%AA%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%91%A2/"/>
      <url>/2019/08/17/%E5%88%B0%E5%BA%95ResNet%E5%9C%A8%E8%A7%A3%E5%86%B3%E4%B8%80%E4%B8%AA%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%91%A2/</url>
      
        <content type="html"><![CDATA[<p>对知乎上回答的简单总结</p><hr><p><strong>一、引言：为什么会有ResNet？Why ResNet？</strong></p><ul><li><p>过拟合？<br>  不是！因为深层网络表现为训练误差和测试误差都比较高，所以不是过拟合</p></li><li><p>梯度消失？梯度爆炸？<br>  不是！因为已经使用了 batch normalization ，在很大程度上解决了梯度消失、爆炸的问题，（yaya：我个人认为对梯度消失问题有一定的帮助，毕竟梯度值为1）</p></li><li><p>深层网络退化的原因？</p><p>  由于非线性激活函数的存在，使得信息被丢失，而不能完整保留，所以，应该在网络中加入恒等映射</p></li></ul><p>*<em>二、关于resnet网络结构 【没看懂为什么要有两层】  *</em></p><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g62hrnrs6nj30h9048aax.jpg" alt></p><ul><li>yaya 分析：<br>一层：  relu(x +  w1 x)<br>两层：  relu(x +w2 relu(w1 x))</li></ul><p>​       既然非线性激活函数会把信息丢失，为什么不这样：relu(wx) + x ，因为这样是错误的，本身relu是需要放在输出后面，起到非线性的作用，但是这样，就不算作对输出的非线</p><p>*<em>三、更多的理解    *</em></p><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g62hpvudvxj30iu0cc3zi.jpg" alt></p><hr><p>yaya 的总结/理解</p><ol><li>resnet 解决的不是过拟合的问题，因为过拟合的现象是，train loss 小，但是val loss大，但是当前深层网络的问题是train loss大，val loss也大</li><li>resnet 提供了一个梯度为1的反向传播，在一定程度上解决了梯度消失的问题</li><li>FPN中指出，不同深度的网络的结合可以结合不同的分辨率，但是当前resnet 只跨越了一种分辨率，因此，没能很好地利用这一特点，因此desnet便被提出来</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Batch Normalization批标准化</title>
      <link href="/2019/08/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Batch-Normalization%E6%89%B9%E6%A0%87%E5%87%86%E5%8C%96/"/>
      <url>/2019/08/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Batch-Normalization%E6%89%B9%E6%A0%87%E5%87%86%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<ul><li>转载 from：<a href="https://www.cnblogs.com/guoyaohua/p/8724433.html" target="_blank" rel="noopener">https://www.cnblogs.com/guoyaohua/p/8724433.html</a></li></ul><blockquote><p>这几天面试经常被问到BN层的原理，虽然回答上来了，但还是感觉答得不是很好，今天仔细研究了一下Batch Normalization的原理，以下为参考网上几篇文章总结得出。</p></blockquote><p>　　Batch Normalization作为最近一年来DL的重要成果，已经广泛被证明其有效性和重要性。虽然有些细节处理还解释不清其理论原因，但是实践证明好用才是真的好，别忘了DL从Hinton对深层网络做Pre-Train开始就是一个<strong>经验领先于理论分析</strong>的偏经验的一门学问。本文是对论文《Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift》的导读。</p><p>　　机器学习领域有个很重要的假设：<strong>IID独立同分布假设</strong>，就是假设训练数据和测试数据是满足相同分布的，这是通过训练数据获得的模型能够在测试集获得好的效果的一个基本保障。那BatchNorm的作用是什么呢？<strong>BatchNorm就是在深度神经网络训练过程中使得每一层神经网络的输入保持相同分布的。</strong></p><p>　　接下来一步一步的理解什么是BN。</p><p>　　为什么深度神经网络<strong>随着网络深度加深，训练起来越困难，收敛越来越慢？</strong>这是个在DL领域很接近本质的好问题。很多论文都是解决这个问题的，比如ReLU激活函数，再比如Residual Network，BN本质上也是解释并从某个不同的角度来解决这个问题的。</p><h2 id="一、“Internal-Covariate-Shift”问题"><a href="#一、“Internal-Covariate-Shift”问题" class="headerlink" title="一、“Internal Covariate Shift”问题"></a>一、“Internal Covariate Shift”问题</h2><p>　　从论文名字可以看出，BN是用来解决“Internal Covariate Shift”问题的，那么首先得理解什么是“Internal Covariate Shift”？</p><p>　　论文首先说明Mini-Batch SGD相对于One Example SGD的两个优势：梯度更新方向更准确；并行计算速度快；（为什么要说这些？因为BatchNorm是基于Mini-Batch SGD的，所以先夸下Mini-Batch SGD，当然也是大实话）；然后吐槽下SGD训练的缺点：超参数调起来很麻烦。（作者隐含意思是用BN就能解决很多SGD的缺点）</p><p>　　接着引入<strong>covariate shift的概念</strong>：<strong>如果ML系统实例集合&lt;X,Y&gt;中的输入值X的分布老是变，这不符合IID假设</strong>，网络模型很难<strong>稳定的学规律</strong>，这不得引入迁移学习才能搞定吗，我们的ML系统还得去学习怎么迎合这种分布变化啊。对于深度学习这种包含很多隐层的网络结构，在训练过程中，因为各层参数不停在变化，所以每个隐层都会面临covariate shift的问题，也就是<strong>在训练过程中，隐层的输入分布老是变来变去，这就是所谓的“Internal Covariate Shift”，Internal指的是深层网络的隐层，是发生在网络内部的事情，而不是covariate shift问题只发生在输入层。</strong></p><p>　　然后提出了BatchNorm的基本思想：能不能<strong>让每个隐层节点的激活输入分布固定下来呢</strong>？这样就避免了“Internal Covariate Shift”问题了。</p><p>　　BN不是凭空拍脑袋拍出来的好点子，它是有启发来源的：之前的研究表明如果在图像处理中对输入图像进行白化（Whiten）操作的话——所谓<strong>白化</strong>，<strong>就是对输入数据分布变换到0均值，单位方差的正态分布</strong>——那么神经网络会较快收敛，那么BN作者就开始推论了：图像是深度神经网络的输入层，做白化能加快收敛，那么其实对于深度网络来说，其中某个隐层的神经元是下一层的输入，意思是其实深度神经网络的每一个隐层都是输入层，不过是相对下一层来说而已，那么能不能对每个隐层都做白化呢？这就是启发BN产生的原初想法，而BN也确实就是这么做的，<strong>可以理解为对深层神经网络每个隐层神经元的激活值做简化版本的白化操作。</strong></p><h2 id="二、BatchNorm的本质思想"><a href="#二、BatchNorm的本质思想" class="headerlink" title="二、BatchNorm的本质思想"></a><strong>二、</strong>BatchNorm的本质思想</h2><p>　　BN的基本思想其实相当直观：因为深层神经网络在做非线性变换前的<strong>激活输入值</strong>（就是那个x=WU+B，U是输入）<strong>随着网络深度加深或者在训练过程中，其分布逐渐发生偏移或者变动，之所以训练收敛慢，一般是整体分布逐渐往非线性函数的取值区间的上下限两端靠近</strong>（对于Sigmoid函数来说，意味着激活输入值WU+B是大的负值或正值），所以这<strong>导致反向传播时低层神经网络的梯度消失</strong>，这是训练深层神经网络收敛越来越慢的<strong>本质原因</strong>，<strong>而BN就是通过一定的规范化手段，把每层神经网络任意神经元这个输入值的分布强行拉回到均值为0方差为1的标准正态分布</strong>，其实就是把越来越偏的分布强制拉回比较标准的分布，这样使得激活输入值落在非线性函数对输入比较敏感的区域，这样输入的小变化就会导致损失函数较大的变化，意思是<strong>这样让梯度变大，避免梯度消失问题产生，而且梯度变大意味着学习收敛速度快，能大大加快训练速度。</strong></p><p>　　THAT’S IT。其实一句话就是：<strong>对于每个隐层神经元，把逐渐向非线性函数映射后向取值区间极限饱和区靠拢的输入分布强制拉回到均值为0方差为1的比较标准的正态分布，使得非线性变换函数的输入值落入对输入比较敏感的区域，以此避免梯度消失问题。</strong>因为梯度一直都能保持比较大的状态，所以很明显对神经网络的参数调整效率比较高，就是变动大，就是说向损失函数最优值迈动的步子大，也就是说收敛地快。BN说到底就是这么个机制，方法很简单，道理很深刻。</p><p>　　上面说得还是显得抽象，下面更形象地表达下这种调整到底代表什么含义。</p><p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180405225246905-37854887.png" alt="img"></p><p>  图1  几个正态分布</p><p>　　假设某个隐层神经元原先的激活输入x取值符合正态分布，正态分布均值是-2，方差是0.5，对应上图中最左端的浅蓝色曲线，通过BN后转换为均值为0，方差是1的正态分布（对应上图中的深蓝色图形），意味着什么，意味着输入x的取值正态分布整体右移2（均值的变化），图形曲线更平缓了（方差增大的变化）。这个图的意思是，BN其实就是把每个隐层神经元的激活输入分布从偏离均值为0方差为1的正态分布通过平移均值压缩或者扩大曲线尖锐程度，调整为均值为0方差为1的正态分布。</p><p>　　那么把激活输入x调整到这个正态分布有什么用？首先我们看下均值为0，方差为1的标准正态分布代表什么含义：</p><p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180405225314624-527885612.png" alt="img"></p><p>图2  均值为0方差为1的标准正态分布图</p><p>　　这意味着在一个标准差范围内，也就是说64%的概率x其值落在[-1,1]的范围内，在两个标准差范围内，也就是说95%的概率x其值落在了[-2,2]的范围内。那么这又意味着什么？我们知道，激活值x=WU+B,U是真正的输入，x是某个神经元的激活值，假设非线性函数是sigmoid，那么看下sigmoid(x)其图形：</p><p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180407143109455-1460017374.png" alt="img"></p><p>图3. Sigmoid(x)</p><p>及sigmoid(x)的导数为：G’=f(x)*(1-f(x))，因为f(x)=sigmoid(x)在0到1之间，所以G’在0到0.25之间，其对应的图如下：</p><p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180407142351924-124461667.png" alt="img"></p><p>图4  Sigmoid(x)导数图</p><p>　　假设没有经过BN调整前x的原先正态分布均值是-6，方差是1，那么意味着95%的值落在了[-8,-4]之间，那么对应的Sigmoid（x）函数的值明显接近于0，这是典型的梯度饱和区，在这个区域里梯度变化很慢，为什么是梯度饱和区？请看下sigmoid(x)如果取值接近0或者接近于1的时候对应导数函数取值，接近于0，意味着梯度变化很小甚至消失。而假设经过BN后，均值是0，方差是1，那么意味着95%的x值落在了[-2,2]区间内，很明显这一段是sigmoid(x)函数接近于线性变换的区域，意味着x的小变化会导致非线性函数值较大的变化，也即是梯度变化较大，对应导数函数图中明显大于0的区域，就是梯度非饱和区。</p><p>　　从上面几个图应该看出来BN在干什么了吧？其实就是把隐层神经元激活输入x=WU+B从变化不拘一格的正态分布通过BN操作拉回到了均值为0，方差为1的正态分布，即原始正态分布中心左移或者右移到以0为均值，拉伸或者缩减形态形成以1为方差的图形。什么意思？就是说<strong>经过BN后，目前大部分Activation的值落入非线性函数的线性区内，其对应的导数远离导数饱和区，这样来加速训练收敛过程。</strong></p><p>　　但是很明显，看到这里，稍微了解神经网络的读者一般会提出一个疑问：如果都通过BN，那么不就跟把非线性函数替换成线性函数效果相同了？这意味着什么？我们知道，如果是多层的线性函数变换其实这个深层是没有意义的，因为多层线性网络跟一层线性网络是等价的。这意味着网络的<strong>表达能力</strong>下降了，这也意味着深度的意义就没有了。<strong>所以BN为了保证非线性的获得，对变换后的满足均值为0方差为1的x又进行了scale加上shift操作(y=scale*x+shift)</strong>，每个神经元增加了两个参数scale和shift参数，这两个参数是通过训练学习到的，意思是通过scale和shift把这个值从标准正态分布左移或者右移一点并长胖一点或者变瘦一点，每个实例挪动的程度不一样，这样等价于非线性函数的值从正中心周围的线性区往非线性区动了动。核心思想应该是想找到一个线性和非线性的较好平衡点，既能享受非线性的较强表达能力的好处，又避免太靠非线性区两头使得网络收敛速度太慢。当然，这是我的理解，论文作者并未明确这样说。但是很明显这里的scale和shift操作是会有争议的，因为按照论文作者论文里写的理想状态，就会又通过scale和shift操作把变换后的x调整回未变换的状态，那不是饶了一圈又绕回去原始的“Internal Covariate Shift”问题里去了吗，感觉论文作者并未能够清楚地解释scale和shift操作的理论原因。</p><h2 id="三、训练阶段如何做BatchNorm"><a href="#三、训练阶段如何做BatchNorm" class="headerlink" title="三、训练阶段如何做BatchNorm"></a>三、训练阶段如何做BatchNorm</h2><p>　　上面是对BN的抽象分析和解释，具体在Mini-Batch SGD下做BN怎么做？其实论文里面这块写得很清楚也容易理解。为了保证这篇文章完整性，这里简单说明下。</p><p>　　假设对于一个深层神经网络来说，其中两层结构如下：</p><p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180405213859690-1933561230.png" alt="img"></p><p>  图5  DNN其中两层</p><p>　　要对每个隐层神经元的激活值做BN，可以想象成每个隐层又加上了一层BN操作层，它位于X=WU+B激活值获得之后，非线性函数变换之前，其图示如下：</p><p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180405213955224-1791925244.png" alt="img"></p><p>  图6. BN操作</p><p>　　对于Mini-Batch SGD来说，一次训练过程里面包含m个训练实例，其具体BN操作就是对于隐层内每个神经元的激活值来说，进行如下变换：</p><p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180407142802238-1209499294.png" alt="img"></p><p>　　要注意，这里t层某个神经元的x(k)不是指原始输入，就是说不是t-1层每个神经元的输出，而是t层这个神经元的线性激活x=WU+B，这里的U才是t-1层神经元的输出。变换的意思是：某个神经元对应的原始的激活x通过减去mini-Batch内m个实例获得的m个激活x求得的均值E(x)并除以求得的方差Var(x)来进行转换。</p><p>　　上文说过经过这个<strong>变换后某个神经元的激活x形成了均值为0，方差为1的正态分布，目的是把值往后续要进行的非线性变换的线性区拉动，增大导数值，增强反向传播信息流动性，加快训练收敛速度。**</strong>但是这样会导致网络表达能力下降，为了防止这一点，每个神经元增加两个调节参数（scale和shift），这两个参数是通过训练来学习到的，用来对变换后的激活反变换，使得网络表达能力增强，即对变换后的激活进行如下的scale和shift操作，这其实是变换的反操作：**</p><p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180407142923190-79595046.png" alt="img"></p><p>　　BN其具体操作流程，如论文中描述的一样：</p><p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180407142956288-903484055.png" alt="img"></p><p>　　过程非常清楚，就是上述公式的流程化描述，这里不解释了，直接应该能看懂。</p><h2 id="四、BatchNorm的推理-Inference-过程"><a href="#四、BatchNorm的推理-Inference-过程" class="headerlink" title="四、BatchNorm的推理(Inference)过程"></a>四、BatchNorm的推理(Inference)过程</h2><p>　　BN在训练的时候可以根据Mini-Batch里的若干训练实例进行激活数值调整，但是在推理（inference）的过程中，很明显输入就只有一个实例，看不到Mini-Batch其它实例，那么这时候怎么对输入做BN呢？因为很明显一个实例是没法算实例集合求出的均值和方差的。这可如何是好？</p><p>　　既然没有从Mini-Batch数据里可以得到的统计量，那就想其它办法来获得这个统计量，就是均值和方差。可以用从所有训练实例中获得的统计量来代替Mini-Batch里面m个训练实例获得的均值和方差统计量，因为本来就打算用全局的统计量，只是因为计算量等太大所以才会用Mini-Batch这种简化方式的，那么在推理的时候直接用全局统计量即可。</p><p>　　决定了获得统计量的数据范围，那么接下来的问题是如何获得均值和方差的问题。很简单，因为每次做Mini-Batch训练时，都会有那个Mini-Batch里m个训练实例获得的均值和方差，现在要全局统计量，只要把每个Mini-Batch的均值和方差统计量记住，然后对这些均值和方差求其对应的数学期望即可得出全局统计量，即：</p><p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180407143405654-1995556833.png" alt="img"></p><p>　　有了均值和方差，每个隐层神经元也已经有对应训练好的Scaling参数和Shift参数，就可以在推导的时候对每个神经元的激活数据计算NB进行变换了，在推理过程中进行BN采取如下方式：</p><p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180407143658338-63450857.png" alt="img"></p><p>　　这个公式其实和训练时</p><p><img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180407143807788-1841864822.png" alt="img"></p><p>　　是等价的，通过简单的合并计算推导就可以得出这个结论。那么为啥要写成这个变换形式呢？我猜作者这么写的意思是：在实际运行的时候，按照这种变体形式可以减少计算量，为啥呢？因为对于每个隐层节点来说：</p><p>　　　　　　　　<img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180407144519480-1024698421.png" alt="img">　　<img src="https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180407144549010-487189588.png" alt="img"></p><p>　　都是固定值，这样这两个值可以事先算好存起来，在推理的时候直接用就行了，这样比原始的公式每一步骤都现算少了除法的运算过程，乍一看也没少多少计算量，但是如果隐层节点个数多的话节省的计算量就比较多了。</p><h2 id="五、BatchNorm的好处"><a href="#五、BatchNorm的好处" class="headerlink" title="五、BatchNorm的好处"></a>五、BatchNorm的好处</h2><p>　　BatchNorm为什么NB呢，关键还是效果好。<strong>①**</strong>不仅仅极大提升了训练速度，收敛过程大大加快；②还能增加分类效果，一种解释是这是类似于Dropout的一种防止过拟合的正则化表达方式，所以不用Dropout也能达到相当的效果；③另外调参过程也简单多了，对于初始化要求没那么高，而且可以使用大的学习率等。**总而言之，经过这么简单的变换，带来的好处多得很，这也是为何现在BN这么快流行起来的原因。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 文件名中有空格、括号 时如何操作</title>
      <link href="/2019/08/14/linux-%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%AD%E6%9C%89%E7%A9%BA%E6%A0%BC%E3%80%81%E6%8B%AC%E5%8F%B7-%E6%97%B6%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/08/14/linux-%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%AD%E6%9C%89%E7%A9%BA%E6%A0%BC%E3%80%81%E6%8B%AC%E5%8F%B7-%E6%97%B6%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="如何处理-cd-cp"><a href="#如何处理-cd-cp" class="headerlink" title="如何处理 cd cp"></a>如何处理 <code>cd</code> <code>cp</code></h3><ul><li><p>将文件名用<strong>双引号</strong> 包起来</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd = 'cp -r <span class="string">"&#123;&#125;"</span> <span class="string">"&#123;&#125;"</span>'.format(source_path, target_path)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 3.3.3 字面量,正则,反斜杠和原始字符串</title>
      <link href="/2019/08/14/python-3-3-3-%E5%AD%97%E9%9D%A2%E9%87%8F-%E6%AD%A3%E5%88%99-%E5%8F%8D%E6%96%9C%E6%9D%A0%E5%92%8C%E5%8E%9F%E5%A7%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2019/08/14/python-3-3-3-%E5%AD%97%E9%9D%A2%E9%87%8F-%E6%AD%A3%E5%88%99-%E5%8F%8D%E6%96%9C%E6%9D%A0%E5%92%8C%E5%8E%9F%E5%A7%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<ul><li>注明：转载 from <a href="https://www.cnblogs.com/xiangnan/p/3446904.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiangnan/p/3446904.html</a></li></ul><h1 id="两个不起眼但是比较重要的设定"><a href="#两个不起眼但是比较重要的设定" class="headerlink" title="两个不起眼但是比较重要的设定"></a>两个不起眼但是比较重要的设定</h1><ul><li>Python str类型的字面量解释器</li></ul><p>当反斜杠及其紧接字符无法构成一个具有特殊含义的序列(‘recognized escape sequences’)时,Python选择保留全部字符.直接看例子:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\c'</span></span><br><span class="line"><span class="string">'\\c'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\d'</span></span><br><span class="line"><span class="string">'\\d'</span></span><br></pre></td></tr></table></figure><p>官方管’\c’这种序列叫’unrecognized escape sequences’.官方文档相应部分:</p><p>Unlike Standard C, all unrecognized escape sequences are left in the string unchanged, i.e., <em>the backslash is left in the string</em>. (This behavior is useful when debugging: if an escape sequence is mistyped, the resulting output is more easily recognized as broken.) </p><p>按这段英文的意思,估计C语言里面,’c’和’\c’是等同的.Python是’\c’和’\c’等同.这个等以后学C语言再确定.</p><p>与上面对应的是,如果紧接字符能够和反斜杠构成’recognized escape sequences’的<strong>全部</strong>或者<strong>起始部分</strong>,中文就叫’被承认的转义序列’吧.比如:</p><p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\b'</span></span><br><span class="line"><span class="string">'\x08'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\n'</span></span><br><span class="line"><span class="string">'\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\x'</span></span><br><span class="line"><span class="symbol">SyntaxError:</span> (unicode error) <span class="string">'unicodeescape'</span> codec can<span class="string">'t decode bytes in position 0-1: truncated \xXX escape</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; '</span>\N<span class="string">'</span></span><br><span class="line"><span class="string">SyntaxError: (unicode error) '</span>unicodeescape<span class="string">' codec can'</span>t decode bytes <span class="keyword">in</span> position <span class="number">0</span>-<span class="number">1</span>: malformed \N character escape</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\U'</span></span><br><span class="line"><span class="symbol">SyntaxError:</span> (unicode error) <span class="string">'unicodeescape'</span> codec can<span class="string">'t decode bytes in position 0-1: truncated \UXXXXXXXX escape</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; '</span>\u<span class="string">'</span></span><br><span class="line"><span class="string">SyntaxError: (unicode error) '</span>unicodeescape<span class="string">' codec can'</span>t decode bytes <span class="keyword">in</span> position <span class="number">0</span>-<span class="number">1</span>: truncated \uXXXX escape</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><ul><li>Python re模块正则表达式解释器</li></ul><p>当反斜杠及其紧接字符无法构成一个具有特殊含义的序列(special sequences)时,re选择忽略反斜杠,例如:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\e'</span>,<span class="string">'eee'</span>)</span><br><span class="line">[<span class="string">'e'</span>, <span class="string">'e'</span>, <span class="string">'e'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'e'</span>,<span class="string">'eee'</span>)</span><br><span class="line">[<span class="string">'e'</span>, <span class="string">'e'</span>, <span class="string">'e'</span>]</span><br></pre></td></tr></table></figure><p>可见,’\e’和’e’起到了完全一样的效果.Python相关文档描述是:</p><p>If the ordinary character is not on the list, then the resulting RE will match the second character. For example, <code>\$</code> matches the character <code>&#39;$&#39;</code>.</p><p>与上面对应的是,如果能够构成special sequences,那么re会解释为相应含义.例如:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\w'</span>,<span class="string">'abcdefghijklmnopqrstuvwxyz'</span>)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span>, <span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'o'</span>, <span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>, <span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>, <span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]</span><br></pre></td></tr></table></figure><h1 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h1><p>字面量(Literals),是用于表示一些Python内建类型的常量的符号.最常见的字面量类型是str literals 和 bytes literals.</p><p>比如:</p><p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'abc'</span></span><br><span class="line"><span class="string">'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"abc"</span></span><br><span class="line"><span class="string">'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'啊哦额'</span></span><br><span class="line"><span class="string">'啊哦额'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'abc'</span></span><br><span class="line"><span class="string">b'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">r'\n'</span></span><br><span class="line"><span class="string">'\\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'啊哦额'</span></span><br><span class="line">SyntaxError: bytes can only contain ASCII literal characters.</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>反斜杠\的用途按紧接其后的字符种类可划分为3类:</p><p>1.将特殊字符转换为字面量.这特殊字符包括(单引号,双引号,反斜杠):’”\</p><p>2.将普通字符转换为特殊序列.包括:abfNnrtuUvx0123456789.</p><p>(注意,bytes字面量中,NuU这三个普通字符无法被转义成特殊序列)</p><p>3.将”新行”和自身忽略掉.这个比较抽象,举例说明:py文件中,某个字符串太长了,以至于需要分两行写,那么你可以插个反斜杠,紧接着换行,然后写剩余字符串.</p><p>下面是官方文档归纳的表:</p><table><thead><tr><th>Escape Sequence</th><th>Meaning</th><th>Notes</th></tr></thead><tbody><tr><td><code>\newline</code></td><td>Backslash and newline ignored</td><td></td></tr><tr><td><code>\\</code></td><td>Backslash (<code>\</code>)</td><td></td></tr><tr><td><code>\&#39;</code></td><td>Single quote (<code>&#39;</code>)</td><td></td></tr><tr><td><code>\&quot;</code></td><td>Double quote (<code>&quot;</code>)</td><td></td></tr><tr><td><code>\a</code></td><td>ASCII Bell (BEL)</td><td></td></tr><tr><td><code>\b</code></td><td>ASCII Backspace (BS)</td><td></td></tr><tr><td><code>\f</code></td><td>ASCII Formfeed (FF)</td><td></td></tr><tr><td><code>\n</code></td><td>ASCII Linefeed (LF)</td><td></td></tr><tr><td><code>\r</code></td><td>ASCII Carriage Return (CR)</td><td></td></tr><tr><td><code>\t</code></td><td>ASCII Horizontal Tab (TAB)</td><td></td></tr><tr><td><code>\v</code></td><td>ASCII Vertical Tab (VT)</td><td></td></tr><tr><td><code>\ooo</code></td><td>Character with octal value <em>ooo</em></td><td>(1,3)</td></tr><tr><td><code>\xhh</code></td><td>Character with hex value <em>hh</em></td><td>(2,3)</td></tr></tbody></table><p>Escape sequences only recognized in string literals are:</p><table><thead><tr><th>Escape Sequence</th><th>Meaning</th><th>Notes</th></tr></thead><tbody><tr><td><code>\N{name}</code></td><td>Character named <em>name</em> in the Unicode database</td><td>(4)</td></tr><tr><td><code>\uxxxx</code></td><td>Character with 16-bit hex value <em>xxxx</em></td><td>(5)</td></tr><tr><td><code>\Uxxxxxxxx</code></td><td>Character with 32-bit hex value <em>xxxxxxxx</em></td><td>(6)</td></tr></tbody></table><p>举例:</p><p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\N&#123;END OF LINE&#125;'</span></span><br><span class="line"><span class="string">'\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\N&#123;HORIZONTAL TABULATION&#125;'</span></span><br><span class="line"><span class="string">'\t'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\u9f6a'</span>==<span class="string">'齪'</span></span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\1'</span>==<span class="string">'\01'</span></span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\1'</span>==<span class="string">'\001'</span></span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\1'</span>==<span class="string">'\0000001'</span></span><br><span class="line">False</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h1><ul><li>正则表达式的反斜杠的作用</li></ul><p>一种是使紧跟在后面的元字符(special characters或metacharacters)失去特殊含义,变为字面量.这些元字符有14个:</p><p>.^$*+?{}<a href></a>|</p><p>另一种是使紧跟在后面的普通字符变得具有特殊含义.这些普通字符是:</p><p>AbBdDsSwWZ0123456789</p><p>以及在str字面量中能被反斜杠转义的字符:</p><p>&#39;“abfnrtuUvx0123456789</p><p>例如:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\"'</span>,<span class="string">'"'</span>)</span><br><span class="line">[<span class="string">'"'</span>]</span><br></pre></td></tr></table></figure><p>正则pattern的反斜杠的作用和Python字面量的反斜杠类似,这据说是带来”反斜杠灾难”的根源.最典型的莫过于你需要用正则’\\‘才能匹配字面量反斜杠’\‘.</p><p>为方便说明,我们假设re.search(pattern,string)中,pattern表示正则表达式字符串,string表示待匹配的字符串.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; re.search(<span class="string">'\\\\'</span>,<span class="string">'\\'</span>)</span><br><span class="line">&lt;_sre<span class="selector-class">.SRE_Match</span> <span class="selector-tag">object</span> at <span class="number">0</span>x02858528&gt;</span><br></pre></td></tr></table></figure><p>详细来说就是一个文本层级的反斜杠’&#39;(比如你在txt文件中看到的反斜杠),对应Python str 字面量的’\‘,对应正则pattern的’\\‘.这个确实比较难以理解,实在不行就住这点就好:<strong>如果不是最简单的正则类型(比如’ab’),强烈推荐对pattern使用r前缀符</strong>.这样容易理解:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(<span class="string">r'\\'</span>,<span class="string">'\\'</span>)</span><br><span class="line">&lt;_sre.SRE_Match object at <span class="number">0x02858448</span>&gt;</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>1.多重含义的特殊序列处理机制</li></ul><p>b0123456789比较特殊,它们在Python字面量和re正则中都能和反斜杠构成作用不同的特殊序列.例如\b,在python 字面量中解释为”退格键”.re正则中解释为’单词边界’.<strong>python 字面量有优先解释权</strong>,如下可证:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\b'</span>,<span class="string">'\b'</span>)  <span class="comment">#'\b'被优先解释为退格键,而不是单词边界</span></span><br><span class="line">[<span class="string">'\x08'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\b'</span>,<span class="string">'\b'</span>)</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\b'</span>,<span class="string">'b'</span>) </span><br><span class="line">[<span class="string">''</span>, <span class="string">''</span>]</span><br></pre></td></tr></table></figure><p>再比如:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'(a)\1\1'</span>,<span class="string">'aaa'</span>) <span class="comment">#\1按字面量优先解释为八进制字符串,因此无匹配结果</span></span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'(a)\\1\\1'</span>,<span class="string">'aaa'</span>)  <span class="comment">#\\1按正则引擎层级的反斜杠解释为第一个匹配组提取到的字符,相当于'(a)aa'</span></span><br><span class="line">[<span class="string">'a'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'a\1\1'</span>,<span class="string">'a\1\1'</span>) <span class="comment">#\1按字面量优先解释为八进制字符串,所以有匹配结果</span></span><br><span class="line">[<span class="string">'a\x01\x01'</span>]</span><br></pre></td></tr></table></figure><p>了解这个设置有什么用?</p><p>1.当你想使用正则层级的特殊序列\1时,如果你没有使用r作为前缀,那么你必须使用\1才能如愿.</p><p>2.当你想使用字面量层级的特殊序列\1时,则不能使用r作为pattern前缀.</p><p>想想,你有可能在一个r前缀的字符串中写出能够匹配值为1的八进制字符串的pattern吗?</p><p>也许我太较真了,因为实践中好像从没遇到过需要匹配值为1的八进制字符串的情况,但理论上就是这样的.</p><ul><li><strong>2.正则表达式中特殊序列的准确定义的猜想</strong></li></ul><p>官方文档下面的一句话值得推敲:</p><p>Note that <code>\b</code> is used to represent word boundaries, and means “backspace” only inside character classes</p><p>意思是说\b只有在[…]里面时才表示退格键,这显然是错的.比如下面这个例子,\b没有在[]之内,但它是按”退格键”解释的,并非”单词边界”:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\b'</span>,<span class="string">'\b'</span>)</span><br><span class="line">[<span class="string">'\x08'</span>]</span><br></pre></td></tr></table></figure><p>除非官方文档描述的\b是指文本层面的数据(比如你在txt文档里看到的\b).</p><p>由此引出了一个猜想,re的正则pattern中”反斜杠+普通字符”构成特殊序列或”反斜杠+特殊字符”构成字面量–这种描述中的反斜杠准确来说是指两个反斜杠!</p><p>仍然是举例说明:</p><p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\b\w+\\b'</span>,<span class="string">'one two three'</span>)  <span class="comment">#必须用\\b才能表示单词边界</span></span><br><span class="line">[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\b\\w+\\b'</span>,<span class="string">'one two three'</span>)  <span class="comment">#想想,为什么\w和\\w都一样</span></span><br><span class="line">[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\d'</span>,<span class="string">'123'</span>)</span><br><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\d'</span>,<span class="string">'123'</span>)</span><br><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><ul><li>3.u和U只在str字面量中才能被转义,bytes字面量中是普通字符.</li></ul><p>以下是我猜测的正则表达式分析器和Python字面量分析器的传递规则表格:</p><table><thead><tr><th>Python string literal</th><th>values passed to regular expression</th><th>number of characters</th><th>what regular expression engine does</th><th>real meaning for regular expression</th></tr></thead><tbody><tr><td>\e</td><td>\e</td><td>2</td><td>ignore the backslash</td><td>e</td></tr><tr><td>\e</td><td>\e</td><td>2</td><td>ignore the backslash</td><td>e</td></tr><tr><td>e</td><td>e</td><td>1</td><td>nothing spacial</td><td>e</td></tr><tr><td>\n</td><td>\n</td><td>1</td><td>nothing spacial</td><td>换行符</td></tr><tr><td>\n</td><td>\n</td><td>2</td><td>\n is special</td><td>换行符</td></tr><tr><td>\b</td><td>\b</td><td>1</td><td>nothing spacial</td><td>退格键</td></tr><tr><td>\b</td><td>\b</td><td>2</td><td>\b is special</td><td>word boundary</td></tr><tr><td>\s</td><td>\s</td><td>2</td><td>\s is special</td><td>Unicode whitespace characters</td></tr><tr><td>\</td><td>\</td><td>1</td><td>must followed by a charcter</td><td>Can’t form any meaning</td></tr><tr><td>\\</td><td>\</td><td>2</td><td>remove all special meanning of \</td><td>\</td></tr><tr><td>*</td><td>*</td><td>1</td><td>* is special</td><td>repeat the left characters 0 or more times</td></tr><tr><td>*</td><td>*</td><td>2</td><td>remove all special meanning of *</td><td>*</td></tr></tbody></table><p>最后是待探究的例子:</p><p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\n'</span>,<span class="string">'\n\n'</span>)</span><br><span class="line">[<span class="string">'\n'</span>, <span class="string">'\n'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\n'</span>,<span class="string">'\n\n'</span>)</span><br><span class="line">[<span class="string">'\n'</span>, <span class="string">'\n'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\\n'</span>,<span class="string">'\n\n'</span>)</span><br><span class="line">[<span class="string">'\n'</span>, <span class="string">'\n'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\\\n'</span>,<span class="string">'\n\n'</span>)</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\b'</span>,<span class="string">'\b\b'</span>)</span><br><span class="line">[<span class="string">'\x08'</span>, <span class="string">'\x08'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\b'</span>,<span class="string">'\b\b'</span>)</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\\b'</span>,<span class="string">'\b\b'</span>)</span><br><span class="line">[<span class="string">'\x08'</span>, <span class="string">'\x08'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\\\b'</span>,<span class="string">'\b\b'</span>)</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\c'</span>,<span class="string">'\c\c'</span>)</span><br><span class="line">[<span class="string">'c'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\c'</span>,<span class="string">'\c\c'</span>)</span><br><span class="line">[<span class="string">'c'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\\c'</span>,<span class="string">'\c\c'</span>)</span><br><span class="line">[<span class="string">'\\c'</span>, <span class="string">'\\c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; re.findall(<span class="string">'\\\\c'</span>,<span class="string">'\c\c'</span>)</span><br><span class="line">[<span class="string">'\\c'</span>, <span class="string">'\\c'</span>]</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>参考:</p><p>Python 3.3.3 官方文档</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>glob 之 **</title>
      <link href="/2019/08/13/glob-%E4%B9%8B/"/>
      <url>/2019/08/13/glob-%E4%B9%8B/</url>
      
        <content type="html"><![CDATA[<ul><li>该篇主要介绍glob的一些使用小技巧</li></ul><h3 id="想要获得某个文件目录下所有-指定文件格式-的所有文件"><a href="#想要获得某个文件目录下所有-指定文件格式-的所有文件" class="headerlink" title="想要获得某个文件目录下所有 指定文件格式 的所有文件"></a>想要获得某个文件目录下所有 <strong><em>指定文件格式</em></strong> 的所有文件</h3><ul><li><p>假设有一个文件环境如下图所示</p><p><img src="https://i.loli.net/2019/08/14/sjTANPfDuV6cord.png" alt="搜狗截图20190814100532.png"></p></li></ul><ul><li><p>比如想要获得<code>/userhome/dataset/MSVD/YouTubeClips/YouTubeClips</code> 下 <code>.avi</code>格式的所有文件</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">path</span> = <span class="string">'/userhome/dataset/MSVD/YouTubeClips/YouTubeClips/'</span></span><br><span class="line">glob.glob(<span class="built_in">path</span> + <span class="string">'*.avi'</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>想要获得某目录下的所有子目录中的所有指定文件格式的所有文件</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">path</span> = <span class="string">'/userhome/dataset/MSVD/YouTubeClips/'</span></span><br><span class="line">glob.glob(<span class="built_in">path</span> + <span class="string">'**/'</span> + <span class="string">'*.avi'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">path</span> = <span class="string">'/userhome/dataset/MSVD/'</span></span><br><span class="line">glob.glob(<span class="built_in">path</span> + <span class="string">'**/'</span> + <span class="string">'**/'</span> + <span class="string">'*.avi'</span>)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> pytorch clone() vs copy_()</title>
      <link href="/2019/08/06/pytorch-clone-vs-copy/"/>
      <url>/2019/08/06/pytorch-clone-vs-copy/</url>
      
        <content type="html"><![CDATA[<p><code>clone</code>() → Tensor</p><ul><li>反向传播时，将会返回到原来的变量上<br>Returns a copy of the <code>self</code> tensor. The copy has the same size and data type as <code>self</code>.</li><li>NOTE</li><li>Unlike copy_(), this function is recorded in the computation graph. Gradients propagating to the cloned tensor will propagate to the original tensor.</li></ul><hr><p><code>copy_</code>(<em>src</em>, <em>non_blocking=False</em>) → Tensor</p><ul><li><p>只是值得复制<br>Copies the elements from <code>src</code> into <code>self</code> tensor and returns <code>self</code>.</p></li><li><p>The <code>src</code> tensor must be <a href="https://pytorch.org/docs/stable/notes/broadcasting.html#broadcasting-semantics" target="_blank" rel="noopener">broadcastable</a> with the <code>self</code> tensor. It may be of a different data type or reside on a different device.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验中遇到的问题及解决</title>
      <link href="/2019/08/05/%E5%AE%9E%E9%AA%8C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
      <url>/2019/08/05/%E5%AE%9E%E9%AA%8C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题 1"></a>问题 1</h3><ul><li>问题描述：首先表现为：在pycharm debug下和在running模式下的实验结果不一致，<br><br>后来，在训练阶段将预训练的模型保存下来，载入evaluate.py 文件中再次进行评估，得到的分数与在训练阶段评估的分数不一致</li><li>解决思路：由于第二个现象，更加容易解决，因此先解决他，师兄提出一个办法，将保存的模型再次载入，这样就可以有两个网络，然后比较两个网络的数据是在哪里出现差异的，这样可以找到问题。</li><li>解决办法：</li></ul><ol><li>在训练一个epoch 后，将模型保存了下来，然后用两个网络，一个时train.py中重新加载这个网络，一个是在evaluate.py中加载这个网络，将得到的结果，进行比较，（看输出的结果是否一致），然后发现，在一些video 输出的结果是一样的，在一些video是不一样的。<br></li><li>找到那些video对应的结果不一样的所对应的iteration，在该iteration打印出了网络中的部分变量的数据，发现，在dataloader的数据就是不一样的.<br></li><li>那么问题就是出现在数据加载上。通过对数据加载部分的代码进行调试，发现，仅在num_workers=0时，两个dataloader的数据才一样，而采用多线程的话，两个dataloader的数据不完全一样。而又在其他的代码上测试，多线程不会影响数据加载，那么问题就是出现在，自己设计的dataset上，<br></li><li>又发现在加载h5py文件时，没有取切片，而self.critical pytorch代码时加上了的，通过加上切片 <code>[:]</code> 发现在多线程时，是正常的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 问题总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bridging the Gap between Training and Inference for Neural Machine Translation</title>
      <link href="/2019/08/04/Bridging-the-Gap-between-Training-and-Inference-for-Neural-Machine-Translation/"/>
      <url>/2019/08/04/Bridging-the-Gap-between-Training-and-Inference-for-Neural-Machine-Translation/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Multi-Label Image Recognition with Graph Convolutional Networks</title>
      <link href="/2019/08/02/Multi-Label-Image-Recognition-with-Graph-Convolutional-Networks/"/>
      <url>/2019/08/02/Multi-Label-Image-Recognition-with-Graph-Convolutional-Networks/</url>
      
        <content type="html"><![CDATA[<h3 id="Motivation：建模-label-之间的依赖"><a href="#Motivation：建模-label-之间的依赖" class="headerlink" title="Motivation：建模  label 之间的依赖"></a>Motivation：建模  label 之间的依赖</h3><ul><li>使用GCN来建模label之间的依赖</li><li>有向图</li><li>每个节点用 label 的词向量来表达</li></ul><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><h4 id="GCN"><a href="#GCN" class="headerlink" title="GCN"></a>GCN</h4><ul><li><p>GCN 的输入：GCN 的 输入是label的word embedding，使用预训练的glove vector，如果label 是含有多个词的，那么对这多个词的词向量取平均，</p></li><li><p>GCN的输出<code>C*D</code>是为了得到一个分类器，<code>C</code>是类别数，<code>D</code>是image representation的维度，</p></li><li><p>邻接矩阵：a<sub>ij</sub>用条件概率来表示：当label<sub>i</sub>出现时，label<sub>j</sub>出现的概率，因此这不是一个对称矩阵，具体地论文中还给出了更加细节的修改。</p></li></ul><h4 id="image-representation"><a href="#image-representation" class="headerlink" title="image representation"></a>image representation</h4><ul><li>使用 ResNet101 得到 conv5层的输出，再经过全局池化得到一个<code>D</code>维度的特征向量</li></ul><h4 id="multi-label-classifier"><a href="#multi-label-classifier" class="headerlink" title="multi-label classifier"></a>multi-label classifier</h4><ul><li>将上两步的输出进行矩阵相乘，就可以得到 计算的multi-label</li></ul><p><img src="https://i.loli.net/2019/08/03/cdwYEWSF9q6tk3p.png" alt="搜狗截图20190802221229.png"></p><h3 id="不同点-vs-semi-supervised-gcn"><a href="#不同点-vs-semi-supervised-gcn" class="headerlink" title="不同点 vs semi-supervised gcn"></a>不同点 vs semi-supervised gcn</h3><p>1.</p><ul><li>不同于一般的GCN，输入节点的特征，和边，经过GCN之后，得到的是更新后的节点特征</li><li>本文GCN的输出<code>C*D</code>是为了得到一个分类器，<code>C</code>是类别数，<code>D</code>是image representation的维度，</li><li>GCN 的 输入是label的word embedding，使用预训练的glove vector，如果label 是含有多个词的，那么对这多个词的词向量取平均</li></ul><p>2.</p><ul><li>一般的GCN的邻接矩阵是预先定义好的，</li><li>但是本文的邻接矩阵：need to construct the <code>A</code> from scrach</li></ul>]]></content>
      
      
      <categories>
          
          <category> 图卷积网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图卷积网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>word2vec</title>
      <link href="/2019/08/02/word2vec-1/"/>
      <url>/2019/08/02/word2vec-1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>word2vec</title>
      <link href="/2019/08/01/word2vec/"/>
      <url>/2019/08/01/word2vec/</url>
      
        <content type="html"><![CDATA[<h3 id="使用one-hot-来作为词向量"><a href="#使用one-hot-来作为词向量" class="headerlink" title="使用one-hot 来作为词向量"></a>使用one-hot 来作为词向量</h3><ul><li>存在一个缺点，即，两个单词之间的余弦相似度为0，因为one-hot是两两正交的形式。</li><li>但是相似度为0，显然是不对的</li></ul><h3 id="word2vet"><a href="#word2vet" class="headerlink" title="word2vet"></a>word2vet</h3><ul><li><p>跳字模型：中心词生成背景词</p></li><li><p>连续词袋模型：背景词生成中心词</p></li><li><p>这两个模型存在的问题：在softmax中，由于分母是对整个vocab进行求和，导致反向传播的计算量非常大</p></li><li><p><a href="https://www.bilibili.com/video/av18512944/" target="_blank" rel="noopener">相关教程</a></p></li></ul><p>预训练模型</p><ul><li>glove</li><li>fasttext</li><li><a href="https://www.bilibili.com/video/av18795160/?spm_id_from=333.788.videocard.0" target="_blank" rel="noopener">相关教程</a></li><li>spacy</li><li><a href="https://shiyaya.github.io/2019/07/16/Spacy工具包/" target="_blank" rel="noopener">https://shiyaya.github.io/2019/07/16/Spacy%E5%B7%A5%E5%85%B7%E5%8C%85/</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>FPN</title>
      <link href="/2019/08/01/FPN/"/>
      <url>/2019/08/01/FPN/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://vision.cornell.edu/se3/wp-content/uploads/2017/07/fpn-poster.pdf" target="_blank" rel="noopener">poster</a></li><li><a href="https://blog.csdn.net/WZZ18191171661/article/details/79494534" target="_blank" rel="noopener">某篇博客</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>VideoGraph: Recognizing Minutes-Long Human Activities in Videos</title>
      <link href="/2019/07/30/VideoGraph-Recognizing-Minutes-Long-Human-Activities-in-Videos/"/>
      <url>/2019/07/30/VideoGraph-Recognizing-Minutes-Long-Human-Activities-in-Videos/</url>
      
        <content type="html"><![CDATA[<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><ul><li>当前基于CNN或者non-lcoal的方法，可以建模 temporal concepts，但是却不能建模分钟级长的时域依赖。</li><li>学习一个无向图，节点和边都是直接从video中得到，而不需要进行单独的节点标注。</li><li>这里的节点是：组成activity的一个unit-action，比如 “煎鸡蛋” 这个activity里的 “打破鸡蛋” 。</li><li>边，表示 (units-action) 运动单元之间的时域关系</li></ul><h3 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h3><ul><li>建模长范围的activity</li><li>捕捉到细节信息</li></ul><h3 id="Vs-Video-as-space-time-region-graph"><a href="#Vs-Video-as-space-time-region-graph" class="headerlink" title="Vs  Video as space-time region graph"></a>Vs  <code>Video as space-time region graph</code></h3><ul><li>Video as space-time region graph： 需要提取 key objects</li><li>Video graph：自动的从video中学到 nodes</li></ul>]]></content>
      
      
      <categories>
          
          <category> 行为识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装pytorch_geometricc</title>
      <link href="/2019/07/30/%E5%AE%89%E8%A3%85pytorch-geometricc/"/>
      <url>/2019/07/30/%E5%AE%89%E8%A3%85pytorch-geometricc/</url>
      
        <content type="html"><![CDATA[<ul><li><p><a href="https://pytorch-geometric.readthedocs.io/en/latest/notes/installation.html#frequently-asked-questions" target="_blank" rel="noopener">官方链接</a></p></li><li><p>下面是截取自官方</p></li></ul><h2 id="Directly-Installation"><a href="#Directly-Installation" class="headerlink" title="Directly Installation"></a>Directly Installation</h2><p>We have outsourced a lot of functionality of PyTorch Geometric to other packages, which needs to be installed in advance. These packages come with their own CPU and GPU kernel implementations based on the newly introduced <a href="https://github.com/pytorch/extension-cpp/" target="_blank" rel="noopener">C++/CUDA extensions</a> in PyTorch 0.4.0.</p><p>Note</p><p>We do not recommend installation as root user on your system python. Please setup an <a href="https://conda.io/docs/user-guide/install/index.html/" target="_blank" rel="noopener">Anaconda/Miniconda</a> environment or create a <a href="https://www.docker.com/" target="_blank" rel="noopener">Docker image</a>.</p><p>Please follow the steps below for a successful installation:</p><ol start="0"><li><p>Added  by yaya:</p><ul><li><p>may be you can select a conda environments, will be more fine</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash Anaconda3<span class="number">-5.0</span><span class="number">.0</span>-Linux-x86_64.sh</span><br><span class="line">conda create -n pytorch_geometric python=<span class="number">3.7</span> -y</span><br><span class="line">source activate pytorch_geometric</span><br></pre></td></tr></table></figure></li><li><p>after into env: pytorch_geometric</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">pip</span> <span class="selector-tag">install</span> <span class="selector-tag">torch-1</span><span class="selector-class">.1</span><span class="selector-class">.0-cp37-cp37m-manylinux1_x86_64</span><span class="selector-class">.whl</span>  # <span class="selector-tag">download</span> <span class="selector-tag">at</span> <span class="selector-tag">first</span></span><br><span class="line"><span class="selector-tag">pip</span> <span class="selector-tag">installl</span> <span class="selector-tag">numpy-1</span><span class="selector-class">.17</span><span class="selector-class">.0-cp37-cp37m-manylinux1_x86_64</span><span class="selector-class">.whl</span>  # <span class="selector-tag">download</span> <span class="selector-tag">at</span> <span class="selector-tag">first</span></span><br><span class="line"><span class="selector-tag">pip</span> <span class="selector-tag">install</span> <span class="selector-tag">scipy-1</span><span class="selector-class">.3</span><span class="selector-class">.0-cp37-cp37m-manylinux1_x86_64</span><span class="selector-class">.whl</span>  # <span class="selector-tag">download</span> <span class="selector-tag">at</span> <span class="selector-tag">first</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><ol><li><p>Ensure that at least PyTorch 1.1.0 is installed:</p><blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ python -c <span class="string">"import torch; print(torch.__version__)"</span></span><br><span class="line">&gt; <span class="meta">&gt;&gt;&gt; </span><span class="number">1.1</span>.<span class="number">0</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>Ensure CUDA is setup correctly (optional):</p><blockquote><ol><li><p>Check if PyTorch is installed with CUDA support:</p><blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;    &gt; $ python -c <span class="string">"import torch; print(torch.cuda.is_available())"</span></span><br><span class="line">&gt;    &gt; <span class="meta">&gt;&gt;&gt; </span>True</span><br><span class="line">&gt;    &gt;</span><br></pre></td></tr></table></figure></blockquote></li></ol></blockquote><blockquote><ol start="2"><li><p>Add CUDA to <code>$PATH</code> and <code>$CPATH</code> (note that your actual CUDA path may vary from <code>/usr/local/cuda</code>):</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; $ <span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/cuda/bin:<span class="variable">$PATH</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; $ <span class="built_in">echo</span> <span class="variable">$PATH</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; &gt;&gt;&gt; /usr/<span class="built_in">local</span>/cuda/bin:...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; $ <span class="built_in">export</span> CPATH=/usr/<span class="built_in">local</span>/cuda/include:<span class="variable">$CPATH</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; $ <span class="built_in">echo</span> <span class="variable">$CPATH</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; &gt;&gt;&gt; /usr/<span class="built_in">local</span>/cuda/include:...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt;</span></span><br></pre></td></tr></table></figure></blockquote></li></ol></blockquote><blockquote><ol start="3"><li><p>Add CUDA to <code>$LD_LIBRARY_PATH</code> on Linux and to <code>$DYLD_LIBRARY_PATH</code> on macOS (note that your actual CUDA path may vary from <code>/usr/local/cuda</code>):</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; $ <span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/cuda/lib64:<span class="variable">$LD_LIBRARY_PATH</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; $ <span class="built_in">echo</span> <span class="variable">$LD_LIBRARY_PATH</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; &gt;&gt;&gt; /usr/<span class="built_in">local</span>/cuda/lib64:...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; $ <span class="built_in">export</span> DYLD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/cuda/lib:<span class="variable">$DYLD_LIBRARY_PATH</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; $ <span class="built_in">echo</span> <span class="variable">$DYLD_LIBRARY_PATH</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt; &gt;&gt;&gt; /usr/<span class="built_in">local</span>/cuda/lib:...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &gt;</span></span><br></pre></td></tr></table></figure></blockquote></li></ol></blockquote><blockquote><ol start="4"><li><p>Verify that <code>nvcc</code> is accessible from terminal:</p><blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt;    &gt; $ nvcc --version</span></span><br><span class="line"><span class="quote">&gt;    &gt; &gt;&gt;&gt; 10.0</span></span><br><span class="line"><span class="quote">&gt;    &gt;</span></span><br></pre></td></tr></table></figure></blockquote></li></ol></blockquote><blockquote><ol start="5"><li><p>Ensure that PyTorch and system CUDA versions match:</p><blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;    &gt; $ python -c <span class="string">"import torch; print(torch.version.cuda)"</span></span><br><span class="line">&gt;    &gt; <span class="meta">&gt;&gt;&gt; </span><span class="number">10.0</span></span><br><span class="line">&gt;    &gt; </span><br><span class="line">&gt;    &gt; $ nvcc --version</span><br><span class="line">&gt;    &gt; <span class="meta">&gt;&gt;&gt; </span><span class="number">10.0</span></span><br><span class="line">&gt;    &gt;</span><br></pre></td></tr></table></figure></blockquote></li></ol></blockquote></li><li><p>Install all needed packages:</p><blockquote><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="symbol">$</span> you can see <span class="number">4.</span> first (optional)</span><br><span class="line">&gt; <span class="symbol">$</span> pip install --verbose --<span class="keyword">no</span>-cache-dir torch-scatter</span><br><span class="line">&gt; <span class="symbol">$</span> pip install --verbose --<span class="keyword">no</span>-cache-dir torch-sparse</span><br><span class="line">&gt; <span class="symbol">$</span> pip install --verbose --<span class="keyword">no</span>-cache-dir torch-cluster</span><br><span class="line">&gt; <span class="symbol">$</span> pip install --verbose --<span class="keyword">no</span>-cache-dir torch-spline-conv (optional)</span><br><span class="line">&gt; <span class="symbol">$</span> pip install torch-geometric</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>added by yaya:<br>may be you can pip install scipy at first ,because above need it.</p></li></ol><h2 id="Docker-install"><a href="#Docker-install" class="headerlink" title="Docker install"></a>Docker install</h2><ul><li><a href="https://github.com/rusty1s/pytorch_geometric/tree/master/docker" target="_blank" rel="noopener">https://github.com/rusty1s/pytorch_geometric/tree/master/docker</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GCN_LSTM  vs  SGAE</title>
      <link href="/2019/07/30/gcn-on-captioning/"/>
      <url>/2019/07/30/gcn-on-captioning/</url>
      
        <content type="html"><![CDATA[<script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.4.1.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />    <label for="pass">Welcome to my blog, enter password to read.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Video Description: A Survey of Methods, Datasets and Evaluation Metrics</title>
      <link href="/2019/07/29/Video-Description-A-Survey-of-Methods-Datasets-and-Evaluation-Metrics/"/>
      <url>/2019/07/29/Video-Description-A-Survey-of-Methods-Datasets-and-Evaluation-Metrics/</url>
      
        <content type="html"><![CDATA[<h3 id="视频描述仍然处于起步阶段的原因"><a href="#视频描述仍然处于起步阶段的原因" class="headerlink" title="视频描述仍然处于起步阶段的原因"></a>视频描述仍然处于起步阶段的原因</h3><ul><li>对视频描述模型的分析是困难的，很难去判别是visual feature 亦或是 language model 哪个做的贡献大</li><li>当前的数据集，既没有包含足够的视觉多样性，也没有复杂的语言结构</li><li>当前的凭据指标并不能非常正确的去评估生成的句子与人类生成的句子之间的一致程度</li></ul><h3 id="the-difficulty-of-video-caption"><a href="#the-difficulty-of-video-caption" class="headerlink" title="the difficulty of video caption"></a>the difficulty of video caption</h3><ul><li>并不是在video中的所有object 都是与description相关的，可能其只是背景中的一个元素。    </li><li>此外，还需要objects的运动信息，以及 事件，动作，对象之间的因果关系。   </li><li>视频中的action可能有不同的长度，不同的action之间，可能有重叠。    </li></ul><h3 id="Sequence-Learning-based-Video-Captioning-Methods"><a href="#Sequence-Learning-based-Video-Captioning-Methods" class="headerlink" title="Sequence Learning based Video Captioning Methods"></a>Sequence Learning based Video Captioning Methods</h3><h4 id="CNN-RNN-based"><a href="#CNN-RNN-based" class="headerlink" title="CNN-RNN-based"></a>CNN-RNN-based</h4><ul><li><p>第一个 end-to-end：</p><p>S. Venugopalan, H. Xu, J. Donahue, M. Rohrbach, R. Mooney, and K. Saenko. 2014. Translating videos to natural language using deep recurrent neural networks. arXiv preprint arXiv:1412.4729, (2014).    </p><img src="https://i.loli.net/2019/07/29/5d3ea016090c918345.png" alt="图片1.png" title="图片1.png"></li><li><p>S2VT （变长输入，变长输出）</p><p>I. Sutskever, O. Vinyals, and Q. V. Le. 2014. Sequence to sequence learning with neural networks. In Advances in Neural Information Processing Systems. 3104-3112.    </p><img src="https://i.loli.net/2019/07/29/5d3ea01536b3144846.png" alt="图片2.png" title="图片2.png">   </li><li><p>TA ( 加入C3D[1] )</p><p>L. Yao, A. Torabi, K. Cho, N. Ballas, C. Pal, H. Larochelle, and A.Courville. 2015. Describing videos by exploiting temporal structure. In IEEE ICCV    </p><img src="https://i.loli.net/2019/07/29/5d3ea016a248c95582.png" alt="图片3.png" title="图片3.png">  </li><li><p>LSTM-E （making a common visual-semantic-embedding ）</p><p>Y. Pan, T. Mei, T. Yao, H. Li, and Y. Rui. 2016. Jointly modeling embedding and translation to bridge video and language. In IEEE CVPR. </p><img src="https://i.loli.net/2019/07/29/5d3ea421aaf9013065.png" alt="图片4.png" title="图片4.png"></li></ul><ul><li><p>GRU-EVE  ( short fourier transform)</p><p>N. Aafaq, N. Akhtar, W. Liu, S. Z. Gilani and A. Mian. 2019. Spatio-Temporal Dynamics and Semantic Attribute Enriched Visual Encoding for Video Captioning. In IEEE CVPR.    </p><img src="https://i.loli.net/2019/07/29/5d3ea0163113561600.png" alt="搜狗截图20190729152752.png" title="搜狗截图20190729152752.png">   </li><li><p>h-RNN<br>H. Yu, J. Wang, Z. Huang, Y. Yang, and W. Xu. 2016. Video paragraph captioning using hierarchical recurrent neural networks. In IEEE CVPR.</p><img src="https://i.loli.net/2019/07/29/5d3ea63af2e0354548.png" alt="图片5.png" title="图片5.png"></li></ul><h4 id="RL-based"><a href="#RL-based" class="headerlink" title="RL-based"></a>RL-based</h4><ul><li><p>Z. Ren, X. Wang, N. Zhang, X. Lv, and L. Li. 2017. Deep reinforcement learning-based image captioning with embedding reward. arXiv preprint arXiv:1704.03899, (2017).</p></li><li><p>Y. Chen, S. Wang, W. Zhang, and Q. Huang. 2018.  ==Less Is More: Picking Informative Frames for Video Captioning.==  arXiv preprint arXiv:1803.01457, (2018).</p><p>提出了一个基于强化学习的方法，来选择 key informative frames 来表达一个 complete video ，希望这样的操作可以忽略掉噪声和不必要的计算。</p></li><li><p>L. Li and B. Gong. 2018. End-to-End Video Captioning with Multitask Reinforcement Learning. arXiv preprint arXiv:1803.07950,<br>(2018).</p></li><li><p>R. Pasunuru and M. Bansal. 2017. Reinforced video captioning with entailment rewards. arXiv preprint arXiv:1708.02300, (2017).</p></li><li><p>S. Phan, G. E. Henter, Y. Miyao, and S. Satoh. 2017. Consensusbased Sequence Training for Video Captioning. arXiv preprint arXiv:1712.09532, (2017).</p></li><li><p>X. Wang, W. Chen, J. Wu, Y. Wang, and W. Y. Wang. 2017.  ==Video Captioning via Hierarchical Reinforcement Learning.==  arXiv preprint arXiv:1711.11135, (2017).</p><p>在 decoder阶段，使用 深度强化学习，这个方法证明可以捕捉到视频内容中的细节，并生成细粒度的description，但是！这个方法相对于当前的baseline 没有多大的提高。（我自己还需要再看看， 使用DRL的motivation）</p></li></ul><h3 id="Evaluation-Metrics"><a href="#Evaluation-Metrics" class="headerlink" title="Evaluation Metrics"></a>Evaluation Metrics</h3><ul><li><p><a href="https://blog.csdn.net/joshuaxx316/article/details/58696552" target="_blank" rel="noopener">参考链接</a></p></li><li><p>BLEU、ROUGE、METEOR  来源于 机器翻译</p></li><li><p>CIDEr、SPICE 来源于图像描述   </p></li></ul><h4 id="BLEU"><a href="#BLEU" class="headerlink" title="BLEU"></a>BLEU</h4><ul><li><a href="https://blog.csdn.net/allocator/article/details/79657792" target="_blank" rel="noopener">BLEU参考链接</a></li><li>==BLEU实质是对两个句子的共现词频率计算==，但计算过程中使用好些技巧，追求计算的数值可以衡量这两句话的一致程度。 </li><li>BLEU容易陷入常用词和短译句的陷阱中，而给出较高的评分值。本文主要是对解决BLEU的这两个弊端的优化方法介绍。</li><li>缺点</li></ul><ol><li>　不考虑语言表达（语法）上的准确性； </li><li>　 测评精度会受常用词的干扰； </li><li>　 短译句的测评精度有时会较高； </li><li>　没有考虑同义词或相似表达的情况，可能会导致合理翻译被否定；</li></ol><h4 id="ROUGE"><a href="#ROUGE" class="headerlink" title="ROUGE"></a>ROUGE</h4><img src="https://i.loli.net/2019/07/29/5d3ed71f2086769963.png" alt="20170228224903951.png" title="20170228224903951.png"><h4 id="METEOR"><a href="#METEOR" class="headerlink" title="METEOR"></a>METEOR</h4><img src="https://i.loli.net/2019/07/29/5d3edcce1761442736.png" alt="20170228225011405.png" title="20170228225011405.png">   <h4 id="CIDEr"><a href="#CIDEr" class="headerlink" title="CIDEr"></a>CIDEr</h4><img src="https://i.loli.net/2019/07/29/5d3edcce646d089162.png" alt="20170228225056046.png" title="20170228225056046.png"><h4 id="SPICE"><a href="#SPICE" class="headerlink" title="SPICE"></a>SPICE</h4><ul><li>基于 gt 和 pred 的场景图解析，来对预测结果进行评价，</li><li>不被广泛使用的原因是，当前sentence scene graph 的能力还比较若，很容易解析错误(eg:dog swimming through river”, the failure case could be the word “swimming” being parsed as “object” and the word “dog” parsed as “attribute” )</li><li>对句子解析错误了，那么给出的评价指标也不会很好！！！</li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><img src="https://i.loli.net/2019/07/29/5d3edd503479c20027.png" alt="搜狗截图20190729194921.png" title="搜狗截图20190729194921.png">    <h3 id="当前的瓶颈："><a href="#当前的瓶颈：" class="headerlink" title="当前的瓶颈："></a>当前的瓶颈：</h3><h4 id="缺乏有效的评价指标"><a href="#缺乏有效的评价指标" class="headerlink" title="缺乏有效的评价指标"></a>缺乏有效的评价指标</h4><ul><li><p>我们的调查显示，阻碍这一研究进展的一个主要瓶颈是缺乏有效和有目的设计的视频描述评价指标。目前，无论是从机器翻译还是从图像字幕中，都采用了现有的度量标准，无法衡量机器生成的视频字幕的质量及其与人类判断的一致性。改进这些指标的一种方法是增加引用语句的数量。我们认为，从数据本身学习的目的构建的度量标准是推进视频描述研究的关键。    </p></li><li><p>王鑫也曾说：human evaluation在video captioning任务中是有必要的       </p><h4 id="视觉特征部分的瓶颈"><a href="#视觉特征部分的瓶颈" class="headerlink" title="视觉特征部分的瓶颈"></a>视觉特征部分的瓶颈</h4></li><li><p>在一个video中，可能出现多个activity，但是caption model只能检测出部分几个，导致性能下降。   </p></li><li><p>可能这个video中 action 的持续时间较长，但是，当前的video representation方法只能捕捉时域较短的运动信息（eg:C3D），因此不能很好地提取视频特征。   </p></li><li><p>大多数特征提取器只适用于静态或平稳变化的图像，因此难以处理突然的场景变化。目前的方法通过表示整体视频或帧来简化视觉编码部分。可能需要进一步探索注意力模型，以关注视频中具有重要意义的空间和时间部分。   </p></li><li><p>当前的encoder 与 decoder 部分，并 ==不是端到端的==，需要先提取 video representation再进行decoder，这样分布进行，而不是端到端的训练是不好的！    </p></li></ul><h3 id="captioning-model-的可解释性不足"><a href="#captioning-model-的可解释性不足" class="headerlink" title="captioning model 的可解释性不足"></a>captioning model 的可解释性不足</h3><ul><li>举个例子：当我们从包含“白色消防栓”的帧中看到视频描述模型生成的标题“红色消防栓”时，很难确定颜色特征是视觉特征提取器编码错误还是由于使用的语言模型bias( 由于有过多的训练数据是“红色消防栓)。<img src="https://i.loli.net/2019/07/29/5d3ee4996cf7480633.png" alt="搜狗截图20190729202028.png" title="搜狗截图20190729202028.png"></li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li>[1] D. Tran, L. D. Bourdev, R. Fergus, L. Torresani, and M. Paluri. 2014. C3D: Generic Features for Video Analysis. CoRR abs/1412.0767, (2014). </li></ul>]]></content>
      
      
      <categories>
          
          <category> 视频描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Temporal Deformable Convolutional Encoder-Decoder Networks for Video Captioning</title>
      <link href="/2019/07/28/Temporal-Deformable-Convolutional-Encoder-Decoder-Networks-for-Video-Captioning/"/>
      <url>/2019/07/28/Temporal-Deformable-Convolutional-Encoder-Decoder-Networks-for-Video-Captioning/</url>
      
        <content type="html"><![CDATA[<h3 id="当前存在的问题"><a href="#当前存在的问题" class="headerlink" title="当前存在的问题"></a>当前存在的问题</h3><ul><li>RNN 存在梯度消失和梯度下降的问题</li><li>RNN 的本质的循环依赖，限制了其并行计算</li><li>因此本文提出了 ==Temporal Deformable Convolutional Encoder-Decoder Networks (dubbed as TDConvED) ==that fully employ convolutions in both encoder and decoder networks for video captioning. </li></ul>]]></content>
      
      
      <categories>
          
          <category> 视频描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Motion Guided Spatial Attention for Video Captioning</title>
      <link href="/2019/07/28/Motion-Guided-Spatial-Attention-for-Video-Captioning/"/>
      <url>/2019/07/28/Motion-Guided-Spatial-Attention-for-Video-Captioning/</url>
      
        <content type="html"><![CDATA[<h3 id="当前的问题"><a href="#当前的问题" class="headerlink" title="当前的问题"></a>当前的问题</h3><ul><li>spatial attention 很少有人去探索</li><li>motion information 被利用通常是使用3D-CNNs来作为另外一种模态</li></ul><h3 id="本文的工作"><a href="#本文的工作" class="headerlink" title="本文的工作"></a>本文的工作</h3><ul><li>两个贡献： MGSA、GARU</li><li>The proposed MGSA utilize motion information between consecutive frames by applying CNN to stacked optical flows. </li><li>In addition, a gated recurrent unit named GARU is designed to adaptively relate spatial attention maps across time. <img src="https://i.loli.net/2019/07/28/5d3d877e9c0d546970.png" alt="搜狗截图20190728193057.png" title="搜狗截图20190728193057.png">    </li></ul><h3 id="Encoder-部分我的理解"><a href="#Encoder-部分我的理解" class="headerlink" title="Encoder 部分我的理解"></a>Encoder 部分我的理解</h3><ul><li>对一个video 采取N帧，对这N帧提取appearences feature，得到<code>N*H*W*D</code>的特征向量</li><li>以每帧为中心，采取连续的M帧，这M帧计算optical flow，并将这个<code>N*M</code>帧的optical flow images送入CNN中，得到<code>N*H*W*1</code>的特征向量。</li><li>==构造一个长度为N的GRU时域序列，每次送入一帧==  appearence feature 和 optical flow cnn feature，并得到一个输出,维度为<code>H*W</code>，</li><li>该输出作为一个attention系数，并与 ==当前帧== frame feature 相乘。得到一个为该帧的每个像素点（<code>H*W</code>）分配的权重系数。即进行加权求和，则可以得到该帧的spatial attention</li></ul><h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><img src="https://i.loli.net/2019/07/28/5d3d87b91afaa36288.png" alt="搜狗截图20190728193156.png" title="搜狗截图20190728193156.png" width="440px" height="400px">    <h3 id="Experimental-results"><a href="#Experimental-results" class="headerlink" title="Experimental results"></a>Experimental results</h3><ul><li>这里只是想提一点，就是有一些论文在MSR-VTT上的实验结果，是使用了==音频信息==。<img src="https://i.loli.net/2019/07/28/5d3d80835814750581.png" alt="搜狗截图20190728190107.png" title="搜狗截图20190728190107.png"></li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><p>基于 spatial attention的 video captioning model</p></li><li><p>Li, X.; Zhao, B.; and Lu, X. 2017. MAM-RNN: multi-level attention model based RNN for video captioning. In IJCAI, 2208–2214. </p></li><li><p>Yang, Z.; Han, Y.; and Wang, Z. 2017. Catching the temporal regions-of-interest for video captioning. In ACM MM, 146–153. attention, spatial. </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 视频描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Object-aware Aggregation with Bidirectional Temporal Graph for Video Captioning</title>
      <link href="/2019/07/27/Object-aware-Aggregation-with-Bidirectional-Temporal-Graph-for-Video-Captioning/"/>
      <url>/2019/07/27/Object-aware-Aggregation-with-Bidirectional-Temporal-Graph-for-Video-Captioning/</url>
      
        <content type="html"><![CDATA[<h3 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h3><ul><li>本文旨在于捕捉基于object的运动信息(capture object-based trajectory)，以前向流为例，以第一帧中的object regions 作为anchor， 来寻找在其他帧中相对应的regions， 计算该anchor 与 第i帧中的regions的相似性【相似性不仅考虑了特征相似性，还考虑了空间位置相似性】，然后相似性最大的那个region，认为是与anchor一致的objects， 然后将他们组成一组。反向流类似。  </li><li>这个捕捉运动信息的思想与 【Learning Video Representations from Correspondence Proposals】中的很相似。   </li></ul><h3 id="当前存在的问题"><a href="#当前存在的问题" class="headerlink" title="当前存在的问题"></a>当前存在的问题</h3><ul><li>当前的工作主要使用 global frame 或者是 salient regions而不是使用specific objects，那么将不能捕捉到每个object 的细节的时域动态。</li></ul><h3 id="文章的主要工作"><a href="#文章的主要工作" class="headerlink" title="文章的主要工作"></a>文章的主要工作</h3><h4 id="encoder"><a href="#encoder" class="headerlink" title="encoder"></a>encoder</h4><ul><li>constructs ==bidirectional temporal graph== to extract  the temporal trajectories for each object instance, which captures the detailed temporal dynamics in video content.    </li><li>==aggregation process on object regions==, which can capture the object-aware semantic information， 这里主要是得到了 VLAD[5, 6] representation   </li></ul><h4 id="decoder"><a href="#decoder" class="headerlink" title="decoder"></a>decoder</h4><ul><li><p>对object VLAD representation实施了temporal attention 和 object attention</p></li><li><p>对 frames VLAD representation 实施了 temporal attention</p></li><li><p>然后分别进行nn.linear 线性变换后，相加</p></li><li><p>再与word_embedding相加送入GRU</p></li><li></li><li><p><font color="#0099ff" size="5" face="黑体">前向流和后向流的融合：</font>在分别得到两流输出的word score 之后，进行 sum</p><img src="https://i.loli.net/2019/07/28/5d3d37324d6d283934.png" alt="搜狗截图20190728134820.png" title="搜狗截图20190728134820.png">   </li></ul><h3 id="本文的性能分析"><a href="#本文的性能分析" class="headerlink" title="本文的性能分析"></a>本文的性能分析</h3><ul><li>可以准确的描述video，比如关键的objects。</li><li><strong>但是！不能很好地去描述 objects 之间的交互</strong></li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li>【NetVLAD】Relja Arandjelovic, Petr Gronat, Akihiko Torii, Tomas Pajdla, and Josef Sivic. Netvlad: Cnn architecture for weakly supervised place recognition. In CVPR, pages 5297–5307, 2016.</li><li>【SeqVLAD】Youjiang Xu, Yahong Han, Richang Hong, and Qi Tian. Sequential video vlad: Training the aggregation locally and temporally. IEEE Transactions on Image Processing (TIP), 27(10):4933–4944, 2018</li></ul>]]></content>
      
      
      <categories>
          
          <category> 视频描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pointing Novel Objects in Image Captioning</title>
      <link href="/2019/07/26/Pointing-Novel-Objects-in-Image-Captioning/"/>
      <url>/2019/07/26/Pointing-Novel-Objects-in-Image-Captioning/</url>
      
        <content type="html"><![CDATA[<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><img src="https://i.loli.net/2019/07/27/5d3c1676f301a18995.png" alt="搜狗截图20190727171628.png" title="搜狗截图20190727171628.png"><h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>当前的模型，都是以image-caption对来进行训练，因此训练模型只能输出in-domain objects，但是，在实际应用中有些图片含有丰富的信息，但是用现有的模型却不能充分的表达。   </li></ul><h4 id="解决1"><a href="#解决1" class="headerlink" title="解决1"></a>解决1</h4><ul><li>希望可以生成新的words,(没有出现在training dataset)   </li><li>本文提出了解决办法：用object learner 来扩增标准的deep caption 结构。即，由一个图像分类任务，则可以得到该图像中出现的obects。这可以作为一个补充信息，加入到当前现有的deep caption Model 中。   </li><li>具体地：（1）标准的LSTM decoder 会输出一个predicted word,  （2）objects learner 通过一个copying layer 也可以得到一个预测单词。那么该选谁，本文并不硬选择，而是软选择，即给一个系数，来给这两个分配个概率，然后加和。这个选择的过程称为 <strong>Pointing Mechanism</strong>   </li><li>loss:   <img src="https://i.loli.net/2019/07/27/5d3c1c012cccc48971.png" alt="搜狗截图20190727173939.png" title="搜狗截图20190727173939.png">   </li></ul><h4 id="解决2"><a href="#解决2" class="headerlink" title="解决2:"></a>解决2:</h4><ul><li>希望将image中的所有信息，在句子中都可以覆盖到</li><li>提出了一个新的损失。target caption中含有 n词，即对应到image 中的 objects。那么希望生成的句子中含有的n词信息能够包含image中所有出现到的objects（即 target caption中的所有名词）</li><li>那么可以根据预测的单词是否生成了 target caption 中的名词，来计算损失（文章中这里在计算损失的时候忽略了语法结构，即不要求名词出现的在句子中的位置，只要求出现就可以）.   </li><li>loss:</li></ul><img src="https://i.loli.net/2019/07/27/5d3c1c754b56a83488.png" alt="搜狗截图20190727174134.png" title="搜狗截图20190727174134.png">    <img src="https://i.loli.net/2019/07/27/5d3c1c7536e6674709.png" alt="搜狗截图20190727174147.png" title="搜狗截图20190727174147.png"> ]]></content>
      
      
      <categories>
          
          <category> 图像描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vision to language 大牛</title>
      <link href="/2019/07/26/vision-to-language-%E5%A4%A7%E7%89%9B/"/>
      <url>/2019/07/26/vision-to-language-%E5%A4%A7%E7%89%9B/</url>
      
        <content type="html"><![CDATA[<h3 id="王鑫"><a href="#王鑫" class="headerlink" title="王鑫"></a>王鑫</h3><p>Papers can be found at <a href="https://sites.cs.ucsb.edu/~xwang" target="_blank" rel="noopener">https://sites.cs.ucsb.edu/~xwang</a><br>Email: <a href="mailto:xwang@cs.ucsb.edu" target="_blank" rel="noopener">xwang@cs.ucsb.edu</a></p><h4 id="video-captioning-via-hierarchical-reinforcement-learning"><a href="#video-captioning-via-hierarchical-reinforcement-learning" class="headerlink" title="video captioning via hierarchical  reinforcement learning"></a>video captioning via hierarchical  reinforcement learning</h4><ol><li>强化学习</li><li>加入音频信号</li></ol><h4 id="zero-shot-video-captioning"><a href="#zero-shot-video-captioning" class="headerlink" title="zero-shot video captioning"></a>zero-shot video captioning</h4><ul><li>Topic-Aware Mixture of Experts (TAMoE)  <h4 id="evaluation"><a href="#evaluation" class="headerlink" title="evaluation"></a>evaluation</h4></li></ul><ol><li><p>如何去评判，本身就是一个问题，当前的评价指标并不是那么合理</p></li><li><p>human evaluation是一个必要的评测方法，尤其是对于生成story的</p></li></ol><h4 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h4><ul><li>利用强化学习直接对指标进行优化，很可能会造成，指标上去了，但是生成的句子语义并不好。所以提出了下篇论文</li></ul><ol><li>Adversarial REward Learning (AREL)</li></ol><h4 id="Connecting-Language-and-Vision-to-Actions"><a href="#Connecting-Language-and-Vision-to-Actions" class="headerlink" title="Connecting Language and Vision to Actions"></a>Connecting Language and Vision to Actions</h4><ul><li>Look Before You Leap: Model-based RL</li><li>Reinforced Cross-Modal Matching (RCM)</li></ul><h3 id="吴琦"><a href="#吴琦" class="headerlink" title="吴琦"></a>吴琦</h3><h4 id="从-Vision-到-Language-再到-Action，万字漫谈三年跨域信息融合研究"><a href="#从-Vision-到-Language-再到-Action，万字漫谈三年跨域信息融合研究" class="headerlink" title="从 Vision 到 Language 再到 Action，万字漫谈三年跨域信息融合研究"></a><a href="https://mp.weixin.qq.com/s/lnoL1TpKY8HQqCMaBqWA5Q" target="_blank" rel="noopener">从 Vision 到 Language 再到 Action，万字漫谈三年跨域信息融合研究</a></h4><h4 id="一文纵览-Vision-and-Language-领域最新研究与进展"><a href="#一文纵览-Vision-and-Language-领域最新研究与进展" class="headerlink" title="一文纵览 Vision-and-Language 领域最新研究与进展"></a><a href="https://mp.weixin.qq.com/s/dyY64QrvPWbjGvJw5H51OA" target="_blank" rel="noopener">一文纵览 Vision-and-Language 领域最新研究与进展</a></h4>]]></content>
      
      
      <categories>
          
          <category> 视频描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU课程上新：Neural Networks for NLP</title>
      <link href="/2019/07/26/CMU%E8%AF%BE%E7%A8%8B%E4%B8%8A%E6%96%B0%EF%BC%9ANeural-Networks-for-NLP/"/>
      <url>/2019/07/26/CMU%E8%AF%BE%E7%A8%8B%E4%B8%8A%E6%96%B0%EF%BC%9ANeural-Networks-for-NLP/</url>
      
        <content type="html"><![CDATA[<h1 id="CMU课程上新：Neural-Networks-for-NLP（18年视频课件放出）"><a href="#CMU课程上新：Neural-Networks-for-NLP（18年视频课件放出）" class="headerlink" title="CMU课程上新：Neural Networks for NLP（18年视频课件放出）"></a>CMU课程上新：Neural Networks for NLP（18年视频课件放出）</h1><p>今天文摘菌给大家推荐一门非常棒的课程《Neural Networks for NLP》。这个课程首先简要介绍一下神经网络的基本知识，然后课程的大部讲分如何将神经网络应用于自然语言处理。</p><p>课程中的每一节都会介绍自然语言中的特定问题和现象，并描述建模的难点，当然，并也会绍几个解决这些问题的模型。</p><p>总的来说，这个“神课”会涉及用神经网络建模过程中所使用的各种技术，包括如何处理结构化句子，如何处理大数据，以及半监督和无监督学习，结构化预测和多语言建模等等。</p><p>注意，修读本门课程需要有一定的自然语言处理的知识储备，按照课程的要求，就是应该上过《17-711，NLP算法》。</p><p>2018年的课程视频已经公开，无法上外网的同学，国内也有热心的小伙伴将课程搬到了国内的B站，通过下面的链接可以打开哟</p><p><a href="https://www.bilibili.com/video/av31156700/" target="_blank" rel="noopener">https://www.bilibili.com/video/av31156700/</a></p><p>19年的春季新课程新增了ELMo/BERT上下文词表示、模型可解释性等内容，PyTorch/DyNet代码示例。</p><p>19年课程的课程目录等详细信息，可以去课程主页去查看哟~~文摘菌在下面给大家简单介绍一下这门课程的师资以及作业等情况。</p><p><a href="https://phontron.com/class/nn4nlp2019/schedule.html" target="_blank" rel="noopener">https://phontron.com/class/nn4nlp2019/schedule.html</a></p><p><strong>师资力量</strong></p><p><img src="https://image.jiqizhixin.com/uploads/editor/6e56a929-53db-4396-bd4d-e42e2bd166cd/640.png" alt="img"></p><p>本课程有两位主讲教师，分别是：Graham Neubig、Antonios Anastasopoulos。其中Graham Neubig是卡内基梅陇大学的教授，主要研究自然语言处理，他对机器学习非常感兴趣。Antonios Anastasopoulos我是圣母大学的在读博士，目前David Chiang自然语言处理技术组的成员。专注于“濒危”语言的机器翻译和语音识别。</p><p><img src="https://image.jiqizhixin.com/uploads/editor/db527776-dbf8-4611-a415-1c94e99db32e/640.png" alt="img"></p><p>除了上课的教师外，还有一大批助教来解答同学们的疑惑。从助教安排，我们可以看出，课程在尽量做到有问必答。</p><h2 id="作业介绍及资料公开"><a href="#作业介绍及资料公开" class="headerlink" title="作业介绍及资料公开"></a>作业介绍及资料公开</h2><p>在课程的官网上，对课程的每一次作业都做了详细的说明，包括评分要求，完成作业的条件等等。除此之外还给出了作业示例。</p><p><img src="https://image.jiqizhixin.com/uploads/editor/0cf289f4-3ea8-43ad-b318-c97703e921ac/640.png" alt="img"></p><p>课程官网也贴心的给大家准备好了每一次讲课的PPT，在上课之前，大家多多预习哟~</p><p>PPT下载地址：<a href="https://phontron.com/class/nn4nlp2019/schedule.html" target="_blank" rel="noopener">https://phontron.com/class/nn4nlp2019/schedule.html</a></p><p>此次课程，初步是线下课程。请大家关注大数据文摘，如果后期有视频放出，文摘菌也一定会为大家更新的。</p><p>最后，再次给出课程主页：<a href="https://phontron.com/class/nn4nlp2019/schedule.html" target="_blank" rel="noopener">https://phontron.com/class/nn4nlp2019/schedule.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learning Video Representations from Correspondence Proposals</title>
      <link href="/2019/07/26/Learning-Video-Representations-from-Correspondence-Proposals/"/>
      <url>/2019/07/26/Learning-Video-Representations-from-Correspondence-Proposals/</url>
      
        <content type="html"><![CDATA[<h3 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h3><ul><li>与Non-local 类似，都是在现有CNN（2D， 3D）模型中加入一个设计的模块</li></ul><h3 id="CPNet-介绍"><a href="#CPNet-介绍" class="headerlink" title="CPNet 介绍"></a>CPNet 介绍</h3><p>（1）在CNN的某一层，得到了<code>T*H*W*d</code>的特征，这<code>T*H*W</code>个特征，是经过conv来的，即一个特征，返回到原图对应的是一个块（区域）的特征。   </p><p>（2）类似于graph 中的邻接矩阵的操作，计算这个<code>T*H*W</code>个节点之间的相似性，相似性近的前K个（且不在同一帧），认为他们之间存在对应关系，即找到了一个区域对应到其他帧的对应区域。   </p><p>（3）将原区域，与对应区域的特征，与他们之间的位置关系，输入到MLP中，得到了一个更新的特征。对每个对应区域都采取这样的操作，得到K个特征。取max，得到了一个鲁棒的特征（可以去掉不是对应块区域的特征，即去掉噪声）。   </p><img src="https://i.loli.net/2019/07/26/5d3a7afee6b0178187.png" alt="搜狗截图20190726120054.png" title="搜狗截图20190726120054.png"><ul><li>是不是跟Non-Local很像，==CP Module就是融合了相似区域的特征，对原区域的特征进行更新。==</li></ul><h3 id="Non-local-vs-CPNet"><a href="#Non-local-vs-CPNet" class="headerlink" title="Non-local  vs   CPNet"></a>Non-local  vs   CPNet</h3><ul><li><p>在toy dataset （figure4）上设计了toy model（两层 CNN）,将现有的三个SOTA model以及自己设计的CPNet上进行试验</p></li><li><p>可以看到 I3D，ARTNet ，TRN三个模型的效果都不是很好</p></li><li><p>ARTNet ，TRN 是由于只使用了两个卷积层，不能捕捉长范围的运动信息</p></li><li><p>Non-local 可以捕捉长范围的运动信息，但是为什么效果还是不好：==NL block 没有加进去位置信息==（作者这么说的原因，就是因为在他们的CP module中有position information）</p></li></ul><img src="https://i.loli.net/2019/07/26/5d3a6c44659ae30922.png" alt="搜狗截图20190726102546.png" title="搜狗截图20190726102546.png"><h3 id="CPNet-可以退化成这三个model-没看懂-之后可以结合代码再深入分析"><a href="#CPNet-可以退化成这三个model-没看懂-之后可以结合代码再深入分析" class="headerlink" title="CPNet 可以退化成这三个model: ( 没看懂 ,之后可以结合代码再深入分析)"></a>CPNet 可以退化成这三个model: ( 没看懂 ,之后可以结合代码再深入分析)</h3><img src="https://i.loli.net/2019/07/26/5d3a889e2ce0b69830.png" alt="搜狗截图20190726125811.png" title="搜狗截图20190726125811.png">]]></content>
      
      
      <categories>
          
          <category> 行为识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Memory-Attended Recurrent Network for Video Captioning</title>
      <link href="/2019/07/25/Memory-Attended-Recurrent-Network-for-Video-Captioning/"/>
      <url>/2019/07/25/Memory-Attended-Recurrent-Network-for-Video-Captioning/</url>
      
        <content type="html"><![CDATA[<h3 id="词频"><a href="#词频" class="headerlink" title="词频"></a>词频</h3><p>“&gt; =3”的保留</p><p>MSR-VTT :11K   MSVD:4K</p><h3 id="Attention-Decoder"><a href="#Attention-Decoder" class="headerlink" title="Attention Decoder"></a>Attention Decoder</h3><ul><li><p>采用SA-LSTM的结构</p></li><li><p>细节：</p><ul><li><p>==共享attention==<br>由于需要对frames_feature ==(L帧)==  与 C3D_feature ==（L帧 -&gt; L/16个特征向量）== 都进行attention，这里进行了共享attention，好处：   <br>  </p><p>（1）将2D 和 3D 特征映射到相似的特征空间  <br></p><p>（2）像是一种正则化，减少了参数，避免过拟合  <br>  </p></li><li><p>降维<br>将2D 和 3D 的2048维度的特征，降维到512</p></li></ul></li></ul><h3 id="Attended-Memory-Decoder"><a href="#Attended-Memory-Decoder" class="headerlink" title="Attended Memory Decoder"></a>Attended Memory Decoder</h3><ul><li><p>当前模型的不足：</p><ul><li>现有的模型在生成word的时候，只依赖于当前video的信息，而不能依赖于那些，出现过该单词的其他video的信息</li><li>生成下一个单词，仅依赖于video信息和当前单词，没有建模相邻两个单词之间的兼容性（没看懂）</li></ul></li><li><p>具体的memeory设计详见论文</p></li></ul><h3 id="Attention-Coherent-Loss-AC-Loss"><a href="#Attention-Coherent-Loss-AC-Loss" class="headerlink" title="Attention-Coherent Loss (AC Loss)"></a>Attention-Coherent Loss (AC Loss)</h3><ul><li>将C3D 输入的L帧作为1个time interval,希望对一个time interval 中的frames feature 的attention系数值相近</li><li>仅对frames_features 的attention 系数，计算这样的一个loss</li></ul><img src="https://i.loli.net/2019/07/25/5d397582d36f640160.png" alt="搜狗截图20190725172350.png" title="搜狗截图20190725172350.png">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>深度层次化图卷积神经网络</title>
      <link href="/2019/07/25/%E6%B7%B1%E5%BA%A6%E5%B1%82%E6%AC%A1%E5%8C%96%E5%9B%BE%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2019/07/25/%E6%B7%B1%E5%BA%A6%E5%B1%82%E6%AC%A1%E5%8C%96%E5%9B%BE%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="池化-可以扩大感受野"><a href="#池化-可以扩大感受野" class="headerlink" title="池化 可以扩大感受野"></a>池化 可以扩大感受野</h3><h3 id="GCN（两层）-node-classification"><a href="#GCN（两层）-node-classification" class="headerlink" title="GCN（两层）( node classification )"></a>GCN（两层）( node classification )</h3><ul><li>基于邻域聚合的</li><li><code>H= AXW</code><h3 id="deeper-insight-into-graph-convolutional-networks-for-semi-supervised-learning"><a href="#deeper-insight-into-graph-convolutional-networks-for-semi-supervised-learning" class="headerlink" title="deeper insight into graph convolutional networks for semi-supervised learning"></a>deeper insight into graph convolutional networks for semi-supervised learning</h3></li><li>GCN层数多效果不好：特征之间过于平滑<h3 id="GAT-（两层）-GraphSAGE"><a href="#GAT-（两层）-GraphSAGE" class="headerlink" title="GAT （两层）  GraphSAGE"></a>GAT （两层）  GraphSAGE</h3></li><li>两层，感受野小，2-hop</li></ul><h3 id="Hierarchical-Graph-Representation-Learning-with-Differentiable-Pooling-（graph-classification）"><a href="#Hierarchical-Graph-Representation-Learning-with-Differentiable-Pooling-（graph-classification）" class="headerlink" title="Hierarchical Graph Representation Learning with Differentiable Pooling （graph classification）"></a>Hierarchical Graph Representation Learning with Differentiable Pooling （graph classification）</h3><ol><li>优点</li></ol><ul><li>简单的两层GCN 的感受野只有2-hop</li><li>但是如果GCN- clusterpooling，把相同的节点聚类在一起，再进行GCN，那么感受野就会扩大，</li><li>捕捉到了graph 中的Hierarchical  structure</li></ul><ol start="2"><li>缺点</li></ol><ul><li>但是由于他自身网络设计的，一次池化，就需要一个全连接层，使得想要设计一个很深的网络，就需要很多的参数，容易过拟合</li><li>很难去训练pooling matrix，这是由于不能保证，经过这一个池化层，就可以把相似的objects聚类到一起。本文作者在每层都增加了两个正则项</li></ul><h3 id="Hierarchical-Graph-Convolutional-Networks-for-Semi-supervised-Node-Classification-9层-IJCAI-2019"><a href="#Hierarchical-Graph-Convolutional-Networks-for-Semi-supervised-Node-Classification-9层-IJCAI-2019" class="headerlink" title="Hierarchical Graph Convolutional Networks for Semi-supervised Node Classification ( 9层 ) ( IJCAI 2019)"></a>Hierarchical Graph Convolutional Networks for Semi-supervised Node Classification ( 9层 ) ( IJCAI 2019)</h3><ul><li>粗化 coarsening</li><li>结构一致粗化</li><li>结构相似粗化</li></ul>]]></content>
      
      
      <categories>
          
          <category> 图卷积网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图卷积网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hierarchical Global-Local Temporal Modeling for Video Captioning</title>
      <link href="/2019/07/23/Hierarchical-Global-Local-Temporal-Modeling-for-Video-Captioning/"/>
      <url>/2019/07/23/Hierarchical-Global-Local-Temporal-Modeling-for-Video-Captioning/</url>
      
        <content type="html"><![CDATA[<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><ul><li>使用object features能够更好地检测出action 和 关键的Object</li></ul><h3 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h3><ul><li><p>两个LSTM层</p></li><li><p>global : frame features and C3D features</p></li><li><p>local : objects </p></li></ul><h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><ul><li><p>Top Down decoder</p><ul><li>Bottom LSTM：mean of regions</li><li>Top LSTM : attention of  regions</li></ul></li><li><p>Grounded video description的decoder：</p><ul><li>Bottom LSTM：mean of  fc+motion</li><li>Top LSTM: attention of  regions and attention of  fc+motion</li></ul></li><li><p>==Hierarchical Global-Local Temporal Modeling（本文） ==</p><ul><li>Bottom LSTM：attention of fc+motion</li><li>Top LSTM: attention of regions</li><li>本文不一样的地方是在Bottom LSTM的输入也加入了attention</li></ul></li></ul><h3 id="提取特征"><a href="#提取特征" class="headerlink" title="提取特征"></a>提取特征</h3><ul><li>等间隔提取帧的特征</li><li>由于帧之间的间隔，会使得没有运动信息，所以再使用C3D来补充运动信息（以该该为中心，提取16帧，输入C3D中）</li><li>object features: faster rcnn 去掉rcnn部分的类别/分数预测，提取head_to_heal处的pooled_feats</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 视频描述 </tag>
            
            <tag> [object Object] </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VATEX: a video caption dataset</title>
      <link href="/2019/07/23/VATEX-a-video-caption-dataset/"/>
      <url>/2019/07/23/VATEX-a-video-caption-dataset/</url>
      
        <content type="html"><![CDATA[<h2 id="VATEX数据集"><a href="#VATEX数据集" class="headerlink" title="VATEX数据集"></a>VATEX数据集</h2><ul><li>一个新的数据集，41269个video， 时长大约10s, 每个video有10个中文，10个英文，同时这10个之中，中英文之间有5个是两两配对的</li><li>提出了两个新的任务：（1）一个encoder-decoder模型，在两种语言之间共享参数，即希望一个模型，可以得到两种语言的描述。（2）提出了一种新的机器翻译任务，即当进行中英文的机器翻译任务时，可以添加视频的视觉特征作为辅助信息</li><li>数据集的来源：来自于kinetics的validation dataset, 然后它们找人进行了caption的标注。它们将这41269个video 分成了4部分，train, validation, public test, secret test(不公开，用于比赛)</li></ul><p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g8e7blhuobj30js0lfwkf.jpg" alt="搜狗截图20191028204431.png"></p><h3 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h3><ul><li>encoder-decoder 就是 TopDown的形式</li><li>视觉特征：通过I3D（在kinetics train上预训练且不再fine-tune）来提取视觉特征，应该是把video分成了很多segments，对每个segment都提取I3D的特征，每个特征作为vi。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 视频描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>faster_rcnn various box head</title>
      <link href="/2019/07/22/faster-rcnn-various-box-head/"/>
      <url>/2019/07/22/faster-rcnn-various-box-head/</url>
      
        <content type="html"><![CDATA[<h4 id="Ground-video-description"><a href="#Ground-video-description" class="headerlink" title="Ground video description"></a>Ground video description</h4><ul><li>在阅读这篇论文的时候，由于作者提取了objects，说是提取的fc6的特征，但是不太懂是哪里，在issue中，他说是借鉴这里的代码，于是乎，我就来看了看<a href="https://github.com/facebookresearch/Detectron/blob/8170b25b425967f8f1c7d715bea3c5b8d9536cd8/detectron/modeling/fast_rcnn_heads.py" target="_blank" rel="noopener">box_head</a>，哈哈哈哈哈哈 </li><li>fc6 是 box_head里边的，box_head就是 类似于faster_rcnn中的_head_to_tail</li></ul><h4 id="那么box-head-是干嘛的？"><a href="#那么box-head-是干嘛的？" class="headerlink" title="那么box_head 是干嘛的？"></a>那么box_head 是干嘛的？</h4><ul><li>由于经过roi_pooling 之后得到的是 7*7的一个pooled_feats，还要 ==再进行池化或者拍平，或者再进行全连接层等== ，以便于后边的预测，分类任务。</li></ul><ul><li><p>faster_rcnn 中的box_head就是 resnet layer4</p></li><li><p>mmdetection 中的 faster_rcnn 现将7*7  排成49 ，再送入两个全连接层，可以将这两个全连接层命名为fc6, fc7.   完美!！!！</p></li><li><p>这里展示了各种各样的 box_head</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 目标检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mmdetection的configs中的各项参数具体解释</title>
      <link href="/2019/07/21/mmdetection%E7%9A%84configs%E4%B8%AD%E7%9A%84%E5%90%84%E9%A1%B9%E5%8F%82%E6%95%B0%E5%85%B7%E4%BD%93%E8%A7%A3%E9%87%8A/"/>
      <url>/2019/07/21/mmdetection%E7%9A%84configs%E4%B8%AD%E7%9A%84%E5%90%84%E9%A1%B9%E5%8F%82%E6%95%B0%E5%85%B7%E4%BD%93%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<p>一、简介<br>在使用mmdetection对模型进行调优的过程中总会遇到很多参数的问题，不知道参数在代码中是什么作用，会对训练产生怎样的影响，这里我以faster_rcnn_r50_fpn_1x.py和cascade_rcnn_r50_fpn_1x.py为例，简单介绍一下mmdetection中的各项参数含义</p><p>二、faster_rcnn_r50_fpn_1x.py配置文件<br>首先介绍一下这个配置文件所描述的框架，它是基于resnet50的backbone，有着5个fpn特征层的faster-RCNN目标检测网络，训练迭代次数为标准的12次epoch，下面逐条解释其含义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># model settings</span></span><br><span class="line">model = dict(</span><br><span class="line">type=<span class="string">'FasterRCNN'</span>,                         <span class="comment"># model类型</span></span><br><span class="line">    pretrained=<span class="string">'modelzoo://resnet50'</span>,          <span class="comment"># 预训练模型：imagenet-resnet50</span></span><br><span class="line">    backbone=dict(</span><br><span class="line">        type=<span class="string">'ResNet'</span>,                         <span class="comment"># backbone类型</span></span><br><span class="line">        depth=<span class="number">50</span>,                              <span class="comment"># 网络层数</span></span><br><span class="line">        num_stages=<span class="number">4</span>,                          <span class="comment"># resnet的stage数量</span></span><br><span class="line">        out_indices=(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),              <span class="comment"># 输出的stage的序号</span></span><br><span class="line">        frozen_stages=<span class="number">1</span>,                       <span class="comment"># 冻结的stage数量，即该stage不更新参数，-1表示所有的stage都更新参数</span></span><br><span class="line">        style=<span class="string">'pytorch'</span>),                      <span class="comment"># 网络风格：如果设置pytorch，则stride为2的层是conv3x3的卷积层；如果设置caffe，则stride为2的层是第一个conv1x1的卷积层</span></span><br><span class="line">    neck=dict(</span><br><span class="line">        type=<span class="string">'FPN'</span>,                            <span class="comment"># neck类型</span></span><br><span class="line">        in_channels=[<span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>, <span class="number">2048</span>],    <span class="comment"># 输入的各个stage的通道数</span></span><br><span class="line">        out_channels=<span class="number">256</span>,                      <span class="comment"># 输出的特征层的通道数</span></span><br><span class="line">        num_outs=<span class="number">5</span>),                           <span class="comment"># 输出的特征层的数量</span></span><br><span class="line">    rpn_head=dict(</span><br><span class="line">        type=<span class="string">'RPNHead'</span>,                        <span class="comment"># RPN网络类型</span></span><br><span class="line">        in_channels=<span class="number">256</span>,                       <span class="comment"># RPN网络的输入通道数</span></span><br><span class="line">        feat_channels=<span class="number">256</span>,                     <span class="comment"># 特征层的通道数</span></span><br><span class="line">        anchor_scales=[<span class="number">8</span>],                     <span class="comment"># 生成的anchor的baselen，baselen = sqrt(w*h)，w和h为anchor的宽和高</span></span><br><span class="line">        anchor_ratios=[<span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">2.0</span>],         <span class="comment"># anchor的宽高比</span></span><br><span class="line">        anchor_strides=[<span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>],     <span class="comment"># 在每个特征层上的anchor的步长（对应于原图）</span></span><br><span class="line">        target_means=[<span class="number">.0</span>, <span class="number">.0</span>, <span class="number">.0</span>, <span class="number">.0</span>],         <span class="comment"># 均值</span></span><br><span class="line">        target_stds=[<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>],      <span class="comment"># 方差</span></span><br><span class="line">        use_sigmoid_cls=<span class="literal">True</span>),                 <span class="comment"># 是否使用sigmoid来进行分类，如果False则使用softmax来分类</span></span><br><span class="line">    bbox_roi_extractor=dict(</span><br><span class="line">        type=<span class="string">'SingleRoIExtractor'</span>,                                   <span class="comment"># RoIExtractor类型</span></span><br><span class="line">        roi_layer=dict(type=<span class="string">'RoIAlign'</span>, out_size=<span class="number">7</span>, sample_num=<span class="number">2</span>),   <span class="comment"># ROI具体参数：ROI类型为ROIalign，输出尺寸为7，sample数为2</span></span><br><span class="line">        out_channels=<span class="number">256</span>,                                            <span class="comment"># 输出通道数</span></span><br><span class="line">        featmap_strides=[<span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>]),                             <span class="comment"># 特征图的步长</span></span><br><span class="line">    bbox_head=dict(</span><br><span class="line">        type=<span class="string">'SharedFCBBoxHead'</span>,                     <span class="comment"># 全连接层类型</span></span><br><span class="line">        num_fcs=<span class="number">2</span>,                                   <span class="comment"># 全连接层数量</span></span><br><span class="line">        in_channels=<span class="number">256</span>,                             <span class="comment"># 输入通道数</span></span><br><span class="line">        fc_out_channels=<span class="number">1024</span>,                        <span class="comment"># 输出通道数</span></span><br><span class="line">        roi_feat_size=<span class="number">7</span>,                             <span class="comment"># ROI特征层尺寸</span></span><br><span class="line">        num_classes=<span class="number">81</span>,                              <span class="comment"># 分类器的类别数量+1，+1是因为多了一个背景的类别</span></span><br><span class="line">        target_means=[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],               <span class="comment"># 均值</span></span><br><span class="line">        target_stds=[<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.2</span>],            <span class="comment"># 方差</span></span><br><span class="line">        reg_class_agnostic=<span class="literal">False</span>))                   <span class="comment"># 是否采用class_agnostic的方式来预测，class_agnostic表示输出bbox时只考虑其是否为前景，后续分类的时候再根据该bbox在网络中的类别得分来分类，也就是说一个框可以对应多个类别</span></span><br><span class="line"><span class="comment"># model training and testing settings</span></span><br><span class="line">train_cfg = dict(</span><br><span class="line">    rpn=dict(</span><br><span class="line">        assigner=dict(</span><br><span class="line">            type=<span class="string">'MaxIoUAssigner'</span>,            <span class="comment"># RPN网络的正负样本划分</span></span><br><span class="line">            pos_iou_thr=<span class="number">0.7</span>,                  <span class="comment"># 正样本的iou阈值</span></span><br><span class="line">            neg_iou_thr=<span class="number">0.3</span>,                  <span class="comment"># 负样本的iou阈值</span></span><br><span class="line">            min_pos_iou=<span class="number">0.3</span>,                  <span class="comment"># 正样本的iou最小值。如果assign给ground truth的anchors中最大的IOU低于0.3，则忽略所有的anchors，否则保留最大IOU的anchor</span></span><br><span class="line">            ignore_iof_thr=<span class="number">-1</span>),               <span class="comment"># 忽略bbox的阈值，当ground truth中包含需要忽略的bbox时使用，-1表示不忽略</span></span><br><span class="line">        sampler=dict(</span><br><span class="line">            type=<span class="string">'RandomSampler'</span>,             <span class="comment"># 正负样本提取器类型</span></span><br><span class="line">            num=<span class="number">256</span>,                          <span class="comment"># 需提取的正负样本数量</span></span><br><span class="line">            pos_fraction=<span class="number">0.5</span>,                 <span class="comment"># 正样本比例</span></span><br><span class="line">            neg_pos_ub=<span class="number">-1</span>,                    <span class="comment"># 最大负样本比例，大于该比例的负样本忽略，-1表示不忽略</span></span><br><span class="line">            add_gt_as_proposals=<span class="literal">False</span>),       <span class="comment"># 把ground truth加入proposal作为正样本</span></span><br><span class="line">        allowed_border=<span class="number">0</span>,                     <span class="comment"># 允许在bbox周围外扩一定的像素</span></span><br><span class="line">        pos_weight=<span class="number">-1</span>,                        <span class="comment"># 正样本权重，-1表示不改变原始的权重</span></span><br><span class="line">        smoothl1_beta=<span class="number">1</span> / <span class="number">9.0</span>,                <span class="comment"># 平滑L1系数</span></span><br><span class="line">        debug=<span class="literal">False</span>),                         <span class="comment"># debug模式</span></span><br><span class="line">    rcnn=dict(</span><br><span class="line">        assigner=dict(</span><br><span class="line">            type=<span class="string">'MaxIoUAssigner'</span>,            <span class="comment"># RCNN网络正负样本划分</span></span><br><span class="line">            pos_iou_thr=<span class="number">0.5</span>,                  <span class="comment"># 正样本的iou阈值</span></span><br><span class="line">            neg_iou_thr=<span class="number">0.5</span>,                  <span class="comment"># 负样本的iou阈值</span></span><br><span class="line">            min_pos_iou=<span class="number">0.5</span>,                  <span class="comment"># 正样本的iou最小值。如果assign给ground truth的anchors中最大的IOU低于0.3，则忽略所有的anchors，否则保留最大IOU的anchor</span></span><br><span class="line">            ignore_iof_thr=<span class="number">-1</span>),               <span class="comment"># 忽略bbox的阈值，当ground truth中包含需要忽略的bbox时使用，-1表示不忽略</span></span><br><span class="line">        sampler=dict(</span><br><span class="line">            type=<span class="string">'RandomSampler'</span>,             <span class="comment"># 正负样本提取器类型</span></span><br><span class="line">            num=<span class="number">512</span>,                          <span class="comment"># 需提取的正负样本数量</span></span><br><span class="line">            pos_fraction=<span class="number">0.25</span>,                <span class="comment"># 正样本比例</span></span><br><span class="line">            neg_pos_ub=<span class="number">-1</span>,                    <span class="comment"># 最大负样本比例，大于该比例的负样本忽略，-1表示不忽略</span></span><br><span class="line">            add_gt_as_proposals=<span class="literal">True</span>),        <span class="comment"># 把ground truth加入proposal作为正样本</span></span><br><span class="line">        pos_weight=<span class="number">-1</span>,                        <span class="comment"># 正样本权重，-1表示不改变原始的权重</span></span><br><span class="line">        debug=<span class="literal">False</span>))                         <span class="comment"># debug模式</span></span><br><span class="line">test_cfg = dict(</span><br><span class="line">    rpn=dict(                                 <span class="comment"># 推断时的RPN参数</span></span><br><span class="line">        nms_across_levels=<span class="literal">False</span>,              <span class="comment"># 在所有的fpn层内做nms</span></span><br><span class="line">        nms_pre=<span class="number">2000</span>,                         <span class="comment"># 在nms之前保留的的得分最高的proposal数量</span></span><br><span class="line">        nms_post=<span class="number">2000</span>,                        <span class="comment"># 在nms之后保留的的得分最高的proposal数量</span></span><br><span class="line">        max_num=<span class="number">2000</span>,                         <span class="comment"># 在后处理完成之后保留的proposal数量</span></span><br><span class="line">        nms_thr=<span class="number">0.7</span>,                          <span class="comment"># nms阈值</span></span><br><span class="line">        min_bbox_size=<span class="number">0</span>),                     <span class="comment"># 最小bbox尺寸</span></span><br><span class="line">    rcnn=dict(</span><br><span class="line">        score_thr=<span class="number">0.05</span>, nms=dict(type=<span class="string">'nms'</span>, iou_thr=<span class="number">0.5</span>), max_per_img=<span class="number">100</span>)   <span class="comment"># max_per_img表示最终输出的det bbox数量</span></span><br><span class="line">    <span class="comment"># soft-nms is also supported for rcnn testing</span></span><br><span class="line">    <span class="comment"># e.g., nms=dict(type='soft_nms', iou_thr=0.5, min_score=0.05)            # soft_nms参数</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># dataset settings</span></span><br><span class="line">dataset_type = <span class="string">'CocoDataset'</span>                <span class="comment"># 数据集类型</span></span><br><span class="line">data_root = <span class="string">'data/coco/'</span>                    <span class="comment"># 数据集根目录</span></span><br><span class="line">img_norm_cfg = dict(</span><br><span class="line">    mean=[<span class="number">123.675</span>, <span class="number">116.28</span>, <span class="number">103.53</span>], std=[<span class="number">58.395</span>, <span class="number">57.12</span>, <span class="number">57.375</span>], to_rgb=<span class="literal">True</span>)   <span class="comment"># 输入图像初始化，减去均值mean并处以方差std，to_rgb表示将bgr转为rgb</span></span><br><span class="line">data = dict(</span><br><span class="line">    imgs_per_gpu=<span class="number">2</span>,                <span class="comment"># 每个gpu计算的图像数量</span></span><br><span class="line">    workers_per_gpu=<span class="number">2</span>,             <span class="comment"># 每个gpu分配的线程数</span></span><br><span class="line">    train=dict(</span><br><span class="line">        type=dataset_type,                                                 <span class="comment"># 数据集类型</span></span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/instances_train2017.json'</span>,       <span class="comment"># 数据集annotation路径</span></span><br><span class="line">        img_prefix=data_root + <span class="string">'train2017/'</span>,                               <span class="comment"># 数据集的图片路径</span></span><br><span class="line">        img_scale=(<span class="number">1333</span>, <span class="number">800</span>),                                             <span class="comment"># 输入图像尺寸，最大边1333，最小边800</span></span><br><span class="line">        img_norm_cfg=img_norm_cfg,                                         <span class="comment"># 图像初始化参数</span></span><br><span class="line">        size_divisor=<span class="number">32</span>,                                                   <span class="comment"># 对图像进行resize时的最小单位，32表示所有的图像都会被resize成32的倍数</span></span><br><span class="line">        flip_ratio=<span class="number">0.5</span>,                                                    <span class="comment"># 图像的随机左右翻转的概率</span></span><br><span class="line">        with_mask=<span class="literal">False</span>,                                                   <span class="comment"># 训练时附带mask</span></span><br><span class="line">        with_crowd=<span class="literal">True</span>,                                                   <span class="comment"># 训练时附带difficult的样本</span></span><br><span class="line">        with_label=<span class="literal">True</span>),                                                  <span class="comment"># 训练时附带label</span></span><br><span class="line">    val=dict(</span><br><span class="line">        type=dataset_type,                                                 <span class="comment"># 同上</span></span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/instances_val2017.json'</span>,         <span class="comment"># 同上</span></span><br><span class="line">        img_prefix=data_root + <span class="string">'val2017/'</span>,                                 <span class="comment"># 同上</span></span><br><span class="line">        img_scale=(<span class="number">1333</span>, <span class="number">800</span>),                                             <span class="comment"># 同上</span></span><br><span class="line">        img_norm_cfg=img_norm_cfg,                                         <span class="comment"># 同上</span></span><br><span class="line">        size_divisor=<span class="number">32</span>,                                                   <span class="comment"># 同上</span></span><br><span class="line">        flip_ratio=<span class="number">0</span>,                                                      <span class="comment"># 同上</span></span><br><span class="line">        with_mask=<span class="literal">False</span>,                                                   <span class="comment"># 同上</span></span><br><span class="line">        with_crowd=<span class="literal">True</span>,                                                   <span class="comment"># 同上</span></span><br><span class="line">        with_label=<span class="literal">True</span>),                                                  <span class="comment"># 同上</span></span><br><span class="line">    test=dict(</span><br><span class="line">        type=dataset_type,                                                 <span class="comment"># 同上</span></span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/instances_val2017.json'</span>,         <span class="comment"># 同上</span></span><br><span class="line">        img_prefix=data_root + <span class="string">'val2017/'</span>,                                 <span class="comment"># 同上</span></span><br><span class="line">        img_scale=(<span class="number">1333</span>, <span class="number">800</span>),                                             <span class="comment"># 同上</span></span><br><span class="line">        img_norm_cfg=img_norm_cfg,                                         <span class="comment"># 同上</span></span><br><span class="line">        size_divisor=<span class="number">32</span>,                                                   <span class="comment"># 同上</span></span><br><span class="line">        flip_ratio=<span class="number">0</span>,                                                      <span class="comment"># 同上</span></span><br><span class="line">        with_mask=<span class="literal">False</span>,                                                   <span class="comment"># 同上</span></span><br><span class="line">        with_label=<span class="literal">False</span>,                                                  <span class="comment"># 同上</span></span><br><span class="line">        test_mode=<span class="literal">True</span>))                                                   <span class="comment"># 同上</span></span><br><span class="line"><span class="comment"># optimizer</span></span><br><span class="line">optimizer = dict(type=<span class="string">'SGD'</span>, lr=<span class="number">0.02</span>, momentum=<span class="number">0.9</span>, weight_decay=<span class="number">0.0001</span>)   <span class="comment"># 优化参数，lr为学习率，momentum为动量因子，weight_decay为权重衰减因子</span></span><br><span class="line">optimizer_config = dict(grad_clip=dict(max_norm=<span class="number">35</span>, norm_type=<span class="number">2</span>))          <span class="comment"># 梯度均衡参数</span></span><br><span class="line"><span class="comment"># learning policy</span></span><br><span class="line">lr_config = dict(</span><br><span class="line">    policy=<span class="string">'step'</span>,                        <span class="comment"># 优化策略</span></span><br><span class="line">    warmup=<span class="string">'linear'</span>,                      <span class="comment"># 初始的学习率增加的策略，linear为线性增加</span></span><br><span class="line">    warmup_iters=<span class="number">500</span>,                     <span class="comment"># 在初始的500次迭代中学习率逐渐增加</span></span><br><span class="line">    warmup_ratio=<span class="number">1.0</span> / <span class="number">3</span>,                 <span class="comment"># 起始的学习率</span></span><br><span class="line">    step=[<span class="number">8</span>, <span class="number">11</span>])                         <span class="comment"># 在第8和11个epoch时降低学习率</span></span><br><span class="line">checkpoint_config = dict(interval=<span class="number">1</span>)      <span class="comment"># 每1个epoch存储一次模型</span></span><br><span class="line"><span class="comment"># yapf:disable</span></span><br><span class="line">log_config = dict(</span><br><span class="line">    interval=<span class="number">50</span>,                          <span class="comment"># 每50个batch输出一次信息</span></span><br><span class="line">    hooks=[</span><br><span class="line">        dict(type=<span class="string">'TextLoggerHook'</span>),      <span class="comment"># 控制台输出信息的风格</span></span><br><span class="line">        <span class="comment"># dict(type='TensorboardLoggerHook')</span></span><br><span class="line">    ])</span><br><span class="line"><span class="comment"># yapf:enable</span></span><br><span class="line"><span class="comment"># runtime settings</span></span><br><span class="line">total_epochs = <span class="number">12</span>                               <span class="comment"># 最大epoch数</span></span><br><span class="line">dist_params = dict(backend=<span class="string">'nccl'</span>)              <span class="comment"># 分布式参数</span></span><br><span class="line">log_level = <span class="string">'INFO'</span>                              <span class="comment"># 输出信息的完整度级别</span></span><br><span class="line">work_dir = <span class="string">'./work_dirs/faster_rcnn_r50_fpn_1x'</span> <span class="comment"># log文件和模型文件存储路径</span></span><br><span class="line">load_from = <span class="literal">None</span>                                <span class="comment"># 加载模型的路径，None表示从预训练模型加载</span></span><br><span class="line">resume_from = <span class="literal">None</span>                              <span class="comment"># 恢复训练模型的路径</span></span><br><span class="line">workflow = [(<span class="string">'train'</span>, <span class="number">1</span>)]                       <span class="comment"># 当前工作区名称</span></span><br></pre></td></tr></table></figure><p> 三、cascade_rcnn_r50_fpn_1x.py配置文件<br>cascade-RCNN是cvpr2018的文章，相比于faster-RCNN的改进主要在于其RCNN有三个stage，这三个stage逐级refine检测的结果，使得结果达到更高的精度。下面逐条解释其config的含义，与faster-RCNN相同的部分就不再赘述。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># model settings</span></span><br><span class="line">model = dict(</span><br><span class="line">    type=<span class="string">'CascadeRCNN'</span>,</span><br><span class="line">    num_stages=<span class="number">3</span>,                     <span class="comment"># RCNN网络的stage数量，在faster-RCNN中为1</span></span><br><span class="line">    pretrained=<span class="string">'modelzoo://resnet50'</span>,</span><br><span class="line">    backbone=dict(</span><br><span class="line">        type=<span class="string">'ResNet'</span>,</span><br><span class="line">        depth=<span class="number">50</span>,</span><br><span class="line">        num_stages=<span class="number">4</span>,</span><br><span class="line">        out_indices=(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">        frozen_stages=<span class="number">1</span>,</span><br><span class="line">        style=<span class="string">'pytorch'</span>),</span><br><span class="line">    neck=dict(</span><br><span class="line">        type=<span class="string">'FPN'</span>,</span><br><span class="line">        in_channels=[<span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>, <span class="number">2048</span>],</span><br><span class="line">        out_channels=<span class="number">256</span>,</span><br><span class="line">        num_outs=<span class="number">5</span>),</span><br><span class="line">    rpn_head=dict(</span><br><span class="line">        type=<span class="string">'RPNHead'</span>,</span><br><span class="line">        in_channels=<span class="number">256</span>,</span><br><span class="line">        feat_channels=<span class="number">256</span>,</span><br><span class="line">        anchor_scales=[<span class="number">8</span>],</span><br><span class="line">        anchor_ratios=[<span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">2.0</span>],</span><br><span class="line">        anchor_strides=[<span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>],</span><br><span class="line">        target_means=[<span class="number">.0</span>, <span class="number">.0</span>, <span class="number">.0</span>, <span class="number">.0</span>],</span><br><span class="line">        target_stds=[<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>],</span><br><span class="line">        use_sigmoid_cls=<span class="literal">True</span>),</span><br><span class="line">    bbox_roi_extractor=dict(</span><br><span class="line">        type=<span class="string">'SingleRoIExtractor'</span>,</span><br><span class="line">        roi_layer=dict(type=<span class="string">'RoIAlign'</span>, out_size=<span class="number">7</span>, sample_num=<span class="number">2</span>),</span><br><span class="line">        out_channels=<span class="number">256</span>,</span><br><span class="line">        featmap_strides=[<span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>]),</span><br><span class="line">    bbox_head=[</span><br><span class="line">        dict(</span><br><span class="line">            type=<span class="string">'SharedFCBBoxHead'</span>,</span><br><span class="line">            num_fcs=<span class="number">2</span>,</span><br><span class="line">            in_channels=<span class="number">256</span>,</span><br><span class="line">            fc_out_channels=<span class="number">1024</span>,</span><br><span class="line">            roi_feat_size=<span class="number">7</span>,</span><br><span class="line">            num_classes=<span class="number">81</span>,</span><br><span class="line">            target_means=[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">            target_stds=[<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.2</span>],</span><br><span class="line">            reg_class_agnostic=<span class="literal">True</span>),</span><br><span class="line">        dict(</span><br><span class="line">            type=<span class="string">'SharedFCBBoxHead'</span>,</span><br><span class="line">            num_fcs=<span class="number">2</span>,</span><br><span class="line">            in_channels=<span class="number">256</span>,</span><br><span class="line">            fc_out_channels=<span class="number">1024</span>,</span><br><span class="line">            roi_feat_size=<span class="number">7</span>,</span><br><span class="line">            num_classes=<span class="number">81</span>,</span><br><span class="line">            target_means=[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">            target_stds=[<span class="number">0.05</span>, <span class="number">0.05</span>, <span class="number">0.1</span>, <span class="number">0.1</span>],</span><br><span class="line">            reg_class_agnostic=<span class="literal">True</span>),</span><br><span class="line">        dict(</span><br><span class="line">            type=<span class="string">'SharedFCBBoxHead'</span>,</span><br><span class="line">            num_fcs=<span class="number">2</span>,</span><br><span class="line">            in_channels=<span class="number">256</span>,</span><br><span class="line">            fc_out_channels=<span class="number">1024</span>,</span><br><span class="line">            roi_feat_size=<span class="number">7</span>,</span><br><span class="line">            num_classes=<span class="number">81</span>,</span><br><span class="line">            target_means=[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">            target_stds=[<span class="number">0.033</span>, <span class="number">0.033</span>, <span class="number">0.067</span>, <span class="number">0.067</span>],</span><br><span class="line">            reg_class_agnostic=<span class="literal">True</span>)</span><br><span class="line">    ])</span><br><span class="line"><span class="comment"># model training and testing settings</span></span><br><span class="line">train_cfg = dict(</span><br><span class="line">    rpn=dict(</span><br><span class="line">        assigner=dict(</span><br><span class="line">            type=<span class="string">'MaxIoUAssigner'</span>,</span><br><span class="line">            pos_iou_thr=<span class="number">0.7</span>,</span><br><span class="line">            neg_iou_thr=<span class="number">0.3</span>,</span><br><span class="line">            min_pos_iou=<span class="number">0.3</span>,</span><br><span class="line">            ignore_iof_thr=<span class="number">-1</span>),</span><br><span class="line">        sampler=dict(</span><br><span class="line">            type=<span class="string">'RandomSampler'</span>,</span><br><span class="line">            num=<span class="number">256</span>,</span><br><span class="line">            pos_fraction=<span class="number">0.5</span>,</span><br><span class="line">            neg_pos_ub=<span class="number">-1</span>,</span><br><span class="line">            add_gt_as_proposals=<span class="literal">False</span>),</span><br><span class="line">        allowed_border=<span class="number">0</span>,</span><br><span class="line">        pos_weight=<span class="number">-1</span>,</span><br><span class="line">        smoothl1_beta=<span class="number">1</span> / <span class="number">9.0</span>,</span><br><span class="line">        debug=<span class="literal">False</span>),</span><br><span class="line">    rcnn=[                    <span class="comment"># 注意，这里有3个RCNN的模块，对应开头的那个RCNN的stage数量</span></span><br><span class="line">        dict(</span><br><span class="line">            assigner=dict(</span><br><span class="line">                type=<span class="string">'MaxIoUAssigner'</span>,</span><br><span class="line">                pos_iou_thr=<span class="number">0.5</span>,</span><br><span class="line">                neg_iou_thr=<span class="number">0.5</span>,</span><br><span class="line">                min_pos_iou=<span class="number">0.5</span>,</span><br><span class="line">                ignore_iof_thr=<span class="number">-1</span>),</span><br><span class="line">            sampler=dict(</span><br><span class="line">                type=<span class="string">'RandomSampler'</span>,</span><br><span class="line">                num=<span class="number">512</span>,</span><br><span class="line">                pos_fraction=<span class="number">0.25</span>,</span><br><span class="line">                neg_pos_ub=<span class="number">-1</span>,</span><br><span class="line">                add_gt_as_proposals=<span class="literal">True</span>),</span><br><span class="line">            pos_weight=<span class="number">-1</span>,</span><br><span class="line">            debug=<span class="literal">False</span>),</span><br><span class="line">        dict(</span><br><span class="line">            assigner=dict(</span><br><span class="line">                type=<span class="string">'MaxIoUAssigner'</span>,</span><br><span class="line">                pos_iou_thr=<span class="number">0.6</span>,</span><br><span class="line">                neg_iou_thr=<span class="number">0.6</span>,</span><br><span class="line">                min_pos_iou=<span class="number">0.6</span>,</span><br><span class="line">                ignore_iof_thr=<span class="number">-1</span>),</span><br><span class="line">            sampler=dict(</span><br><span class="line">                type=<span class="string">'RandomSampler'</span>,</span><br><span class="line">                num=<span class="number">512</span>,</span><br><span class="line">                pos_fraction=<span class="number">0.25</span>,</span><br><span class="line">                neg_pos_ub=<span class="number">-1</span>,</span><br><span class="line">                add_gt_as_proposals=<span class="literal">True</span>),</span><br><span class="line">            pos_weight=<span class="number">-1</span>,</span><br><span class="line">            debug=<span class="literal">False</span>),</span><br><span class="line">        dict(</span><br><span class="line">            assigner=dict(</span><br><span class="line">                type=<span class="string">'MaxIoUAssigner'</span>,</span><br><span class="line">                pos_iou_thr=<span class="number">0.7</span>,</span><br><span class="line">                neg_iou_thr=<span class="number">0.7</span>,</span><br><span class="line">                min_pos_iou=<span class="number">0.7</span>,</span><br><span class="line">                ignore_iof_thr=<span class="number">-1</span>),</span><br><span class="line">            sampler=dict(</span><br><span class="line">                type=<span class="string">'RandomSampler'</span>,</span><br><span class="line">                num=<span class="number">512</span>,</span><br><span class="line">                pos_fraction=<span class="number">0.25</span>,</span><br><span class="line">                neg_pos_ub=<span class="number">-1</span>,</span><br><span class="line">                add_gt_as_proposals=<span class="literal">True</span>),</span><br><span class="line">            pos_weight=<span class="number">-1</span>,</span><br><span class="line">            debug=<span class="literal">False</span>)</span><br><span class="line">    ],</span><br><span class="line">    stage_loss_weights=[<span class="number">1</span>, <span class="number">0.5</span>, <span class="number">0.25</span>])     <span class="comment"># 3个RCNN的stage的loss权重</span></span><br><span class="line">test_cfg = dict(</span><br><span class="line">    rpn=dict(</span><br><span class="line">        nms_across_levels=<span class="literal">False</span>,</span><br><span class="line">        nms_pre=<span class="number">2000</span>,</span><br><span class="line">        nms_post=<span class="number">2000</span>,</span><br><span class="line">        max_num=<span class="number">2000</span>,</span><br><span class="line">        nms_thr=<span class="number">0.7</span>,</span><br><span class="line">        min_bbox_size=<span class="number">0</span>),</span><br><span class="line">    rcnn=dict(</span><br><span class="line">        score_thr=<span class="number">0.05</span>, nms=dict(type=<span class="string">'nms'</span>, iou_thr=<span class="number">0.5</span>), max_per_img=<span class="number">100</span>),</span><br><span class="line">    keep_all_stages=<span class="literal">False</span>)         <span class="comment"># 是否保留所有stage的结果</span></span><br><span class="line"><span class="comment"># dataset settings</span></span><br><span class="line">dataset_type = <span class="string">'CocoDataset'</span></span><br><span class="line">data_root = <span class="string">'data/coco/'</span></span><br><span class="line">img_norm_cfg = dict(</span><br><span class="line">    mean=[<span class="number">123.675</span>, <span class="number">116.28</span>, <span class="number">103.53</span>], std=[<span class="number">58.395</span>, <span class="number">57.12</span>, <span class="number">57.375</span>], to_rgb=<span class="literal">True</span>)</span><br><span class="line">data = dict(</span><br><span class="line">    imgs_per_gpu=<span class="number">2</span>,</span><br><span class="line">    workers_per_gpu=<span class="number">2</span>,</span><br><span class="line">    train=dict(</span><br><span class="line">        type=dataset_type,</span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/instances_train2017.json'</span>,</span><br><span class="line">        img_prefix=data_root + <span class="string">'train2017/'</span>,</span><br><span class="line">        img_scale=(<span class="number">1333</span>, <span class="number">800</span>),</span><br><span class="line">        img_norm_cfg=img_norm_cfg,</span><br><span class="line">        size_divisor=<span class="number">32</span>,</span><br><span class="line">        flip_ratio=<span class="number">0.5</span>,</span><br><span class="line">        with_mask=<span class="literal">False</span>,</span><br><span class="line">        with_crowd=<span class="literal">True</span>,</span><br><span class="line">        with_label=<span class="literal">True</span>),</span><br><span class="line">    val=dict(</span><br><span class="line">        type=dataset_type,</span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/instances_val2017.json'</span>,</span><br><span class="line">        img_prefix=data_root + <span class="string">'val2017/'</span>,</span><br><span class="line">        img_scale=(<span class="number">1333</span>, <span class="number">800</span>),</span><br><span class="line">        img_norm_cfg=img_norm_cfg,</span><br><span class="line">        size_divisor=<span class="number">32</span>,</span><br><span class="line">        flip_ratio=<span class="number">0</span>,</span><br><span class="line">        with_mask=<span class="literal">False</span>,</span><br><span class="line">        with_crowd=<span class="literal">True</span>,</span><br><span class="line">        with_label=<span class="literal">True</span>),</span><br><span class="line">    test=dict(</span><br><span class="line">        type=dataset_type,</span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/instances_val2017.json'</span>,</span><br><span class="line">        img_prefix=data_root + <span class="string">'val2017/'</span>,</span><br><span class="line">        img_scale=(<span class="number">1333</span>, <span class="number">800</span>),</span><br><span class="line">        img_norm_cfg=img_norm_cfg,</span><br><span class="line">        size_divisor=<span class="number">32</span>,</span><br><span class="line">        flip_ratio=<span class="number">0</span>,</span><br><span class="line">        with_mask=<span class="literal">False</span>,</span><br><span class="line">        with_label=<span class="literal">False</span>,</span><br><span class="line">        test_mode=<span class="literal">True</span>))</span><br><span class="line"><span class="comment"># optimizer</span></span><br><span class="line">optimizer = dict(type=<span class="string">'SGD'</span>, lr=<span class="number">0.02</span>, momentum=<span class="number">0.9</span>, weight_decay=<span class="number">0.0001</span>)</span><br><span class="line">optimizer_config = dict(grad_clip=dict(max_norm=<span class="number">35</span>, norm_type=<span class="number">2</span>))</span><br><span class="line"><span class="comment"># learning policy</span></span><br><span class="line">lr_config = dict(</span><br><span class="line">    policy=<span class="string">'step'</span>,</span><br><span class="line">    warmup=<span class="string">'linear'</span>,</span><br><span class="line">    warmup_iters=<span class="number">500</span>,</span><br><span class="line">    warmup_ratio=<span class="number">1.0</span> / <span class="number">3</span>,</span><br><span class="line">    step=[<span class="number">8</span>, <span class="number">11</span>])</span><br><span class="line">checkpoint_config = dict(interval=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># yapf:disable</span></span><br><span class="line">log_config = dict(</span><br><span class="line">    interval=<span class="number">50</span>,</span><br><span class="line">    hooks=[</span><br><span class="line">        dict(type=<span class="string">'TextLoggerHook'</span>),</span><br><span class="line">        <span class="comment"># dict(type='TensorboardLoggerHook')</span></span><br><span class="line">    ])</span><br><span class="line"><span class="comment"># yapf:enable</span></span><br><span class="line"><span class="comment"># runtime settings</span></span><br><span class="line">total_epochs = <span class="number">12</span></span><br><span class="line">dist_params = dict(backend=<span class="string">'nccl'</span>)</span><br><span class="line">log_level = <span class="string">'INFO'</span></span><br><span class="line">work_dir = <span class="string">'./work_dirs/cascade_rcnn_r50_fpn_1x'</span></span><br><span class="line">load_from = <span class="literal">None</span></span><br><span class="line">resume_from = <span class="literal">None</span></span><br><span class="line">workflow = [(<span class="string">'train'</span>, <span class="number">1</span>)]</span><br></pre></td></tr></table></figure><p>参考链接：</p><p><a href="https://www.jiqizhixin.com/articles/2018-10-17-10" target="_blank" rel="noopener">https://www.jiqizhixin.com/articles/2018-10-17-10</a></p>]]></content>
      
      
      <categories>
          
          <category> 目标检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Visual Genome 数据集</title>
      <link href="/2019/07/21/Visual-Genome-%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
      <url>/2019/07/21/Visual-Genome-%E6%95%B0%E6%8D%AE%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<ul><li>数据集介绍<br><a href="https://cloud.tencent.com/developer/article/1391855" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1391855</a></li></ul><p><a href="https://visualgenome.org/" target="_blank" rel="noopener">Visual Genome 主页</a></p><p><a href="https://visualgenome.org/api/v0/api_home.html" target="_blank" rel="noopener">Visual Genome Data</a></p><p><a href="https://visualgenome.org/api/v0/api_readme" target="_blank" rel="noopener">Visual Genome Readme</a></p><p>Visual Genome 数据集总览：</p><ul><li>108077 张图片</li><li>5.4 Million Region Descriptions</li><li>1.7 Million Visual Question Answers</li><li>3.8 Million Object Instances</li><li>2.8 Million Attributes</li><li>2.3 Million Relationships</li><li>Everything Mapped to Wordnet Synsets  </li><li>标注数据：  objects，attributes，图片内的 relationships</li><li>共 108K 张图片，每张图片平均有， 35 个 objects，26 个 attributes，21对 objects 见的成对 relationships.</li></ul><p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/rex8eso6p5.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/vtmiv1yyr6.png?imageView2/2/w/1620" alt="img"></p><h2 id="1-Visual-Genome-数据标注"><a href="#1-Visual-Genome-数据标注" class="headerlink" title="1. Visual Genome 数据标注"></a>1. Visual Genome 数据标注</h2><p>数据集主要包括七个主要部分：</p><ul><li>region descriptions</li><li>objects</li><li>attributes</li><li>relationships</li><li>region graphs</li><li>scene graphs</li><li>question answer pairs</li></ul><h3 id="1-1-Region-Descriptions"><a href="#1-1-Region-Descriptions" class="headerlink" title="1.1. Region Descriptions"></a>1.1. Region Descriptions</h3><p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/8kgo0p0qim.png?imageView2/2/w/1620" alt="img"></p><p>数据集标注了图片的 regions descriptions，每个 region 有一个 bounding box. </p><p>如上图中，图片有三个 regions descriptions： “man jumping over a fire hydrant,”，“yellow fire hydrant,” 和   “woman in shorts is standing behind the man.”.</p><h3 id="1-2-Objects"><a href="#1-2-Objects" class="headerlink" title="1.2. Objects"></a>1.2. Objects</h3><p>数据集中每张图片平均有 35 个 objects，每个 object 采用 bounding box 标注.</p><p>如图：   </p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/ih1qpz1p3s.png?imageView2/2/w/1620" alt="img"></p><p><a href="http://blog.csdn.net/zziahgf/article/details/72819043" target="_blank" rel="noopener">MS-COCO 数据集</a> 只标注了 80 个 object categories，没有描述图片中的所有 objects. 实际场景中，可能有更多的 objects 类别.</p><p>Visual Genome 数据集旨在对图片里出现的所有视觉 objects 进行标注，objects categories 类别达到 33877 种.</p><h3 id="1-3-Attributes"><a href="#1-3-Attributes" class="headerlink" title="1.3. Attributes"></a>1.3. Attributes</h3><p>数据集中每张图片平均有 26 个 attributes. Objects 可能没有或者有更多的相关 attributes. </p><p>Attributes 可以是 color(如 yellow)，states(如 standing) 等，如图：   </p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/k1n26a1mdt.png?imageView2/2/w/1620" alt="img"></p><p>Attributes 能够对 objects 进行更容易的描述、对比与分类. 即使以前未见到某 object，根据 attributes 仍能推断出与 object 相关的东西. 如，“yellow and brown spotted with long neck(长脖子上有黄色和棕色的斑点)”，很可能推断出 object 是 giraffe(长颈鹿).</p><p>关于 attributes 的研究：</p><ul><li>采用examplar SVMs，利用相似特征来寻找 objects；</li><li>采用纹理(textures) 研究 objects，或者预测颜色.</li><li>采用 attributes 来提高目标分类结果. 如 fine-grained 识别.</li></ul><p>Attributes 一般被定义为 parts(如 has legs)、shapes(如，spherical球形的)、materials(如 furry毛皮的)；用于对新的 objects 类别进行分类.</p><p>Visual Genome 数据集对于 attributes 进行扩展，其 attributes 不是 image-specific 的，而是真实场景中 object-specific 的. attributes 类型包括：size(如 small), pose(如bent), state (如 transparent), emotion (如 happy)等等.</p><ul><li>基于 VGG16 的 attributes 预测结果：   </li></ul><p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/373ih7qquc.png?imageView2/2/w/1620" alt="img"></p><h3 id="1-4-Relationships"><a href="#1-4-Relationships" class="headerlink" title="1.4. Relationships"></a>1.4. Relationships</h3><p>Relationships 是两个 objects 的连接关系.</p><p>Relationships 可以是 actions(如 jumping over)，spatial(如 is build)，comparative(如 taller than)，prepositional phrases (如 drive on). 如图：   </p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/5ljbd3m2av.png?imageView2/2/w/1620" alt="img"></p><ul><li>Relationship 预测结果：   </li></ul><p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/pgbhzj5ui4.png?imageView2/2/w/1620" alt="img"></p><h3 id="1-5-Region-Graphs"><a href="#1-5-Region-Graphs" class="headerlink" title="1.5. Region Graphs"></a>1.5. Region Graphs</h3><p>结合 objects、attributes 以及  region descriptions 提取的 relationships，创建每个 regions 的 graph representation. </p><h3 id="1-6-Scene-Graphs"><a href="#1-6-Scene-Graphs" class="headerlink" title="1.6. Scene Graphs"></a>1.6. Scene Graphs</h3><p>Region graphs 是图片的局部区域表示，将 region graphs 结合，生成单个 scene graph来表示整张图片.</p><p>Scene graph 是全部 region graphs 的统一，包含了全部的 objects、attributes以及每个 region description 的 relationships.</p><p>Scene Graph 将多种不同层次的 scene 信息以更加一致的方式结合在一起.</p><h3 id="1-7-Question-Answer-QA-Pairs"><a href="#1-7-Question-Answer-QA-Pairs" class="headerlink" title="1.7. Question Answer(QA) Pairs"></a>1.7. Question Answer(QA) Pairs</h3><p>数据集中每张图片有两种类型的 QA pairs：</p><ul><li>freeform QAs - 基于整张图片；</li><li>region-based QAs - 基于图片的选择区域. </li></ul><p>每张图片标注了 6 中不同类型的问题：what, where, how, when, who, why.</p><p>如图：   </p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/vbxbgpfi92.png?imageView2/2/w/1620" alt="img"></p><p>Figure . Visual Genome 数据集. 每张图片包括：region descriptions - 描述了图像的局部信息；两种类型的 question answer pairs(QAs) - free form QAs 和 region-based QAs. 每个 region 转化为 objects、attributes 和 pairwise relationships region 构成的 region graph 表示. 最终， 结合 region graphs 以形成图片内全部 objects 的 scene graph.</p><h2 id="2-Visual-Genome-数据集应用"><a href="#2-Visual-Genome-数据集应用" class="headerlink" title="2. Visual Genome 数据集应用"></a>2. Visual Genome 数据集应用</h2><p>基本应用：</p><ul><li>attribute classification 属性分类</li><li>relationship classification 关系分类</li><li>description generation 描述生成</li><li>question answering QA</li></ul><p>更多应用：</p><ul><li>Dense image captioning</li><li>Visual question answering</li><li>Image understanding</li><li>Relationship extraction</li><li>Semantic image retrieval</li><li>Completing the Set of Annotations</li></ul><p>注 - 与其它数据集对比：   </p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1682974/cjqe5v7i44.png?imageView2/2/w/1620" alt="img"></p><h2 id="3-Reference"><a href="#3-Reference" class="headerlink" title="3. Reference"></a>3. Reference</h2><p>[1] - <a href="https://visualgenome.org/" target="_blank" rel="noopener">Visual Genome Home</a></p><p>[1] - <a href="https://visualgenome.org/static/paper/Visual_Genome.pdf" target="_blank" rel="noopener">Visual Genome Doc</a></p><p>[2] - <a href="https://arxiv.org/pdf/1701.02426.pdf" target="_blank" rel="noopener">Scene Graph Generation by Iterative Message Passing</a></p><p>本文参与<a href="https://cloud.tencent.com/developer/support-plan" target="_blank" rel="noopener">腾讯云自媒体分享计划</a>，欢迎正在阅读的你也加入，一起分享。</p>]]></content>
      
      
      <categories>
          
          <category> 目标检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设置随机种子</title>
      <link href="/2019/07/21/%E8%AE%BE%E7%BD%AE%E9%9A%8F%E6%9C%BA%E7%A7%8D%E5%AD%90/"/>
      <url>/2019/07/21/%E8%AE%BE%E7%BD%AE%E9%9A%8F%E6%9C%BA%E7%A7%8D%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p>def set_random_seed(seed):<br>    random.seed(seed)<br>    np.random.seed(seed)<br>    torch.manual_seed(seed)<br>    torch.cuda.manual_seed_all(seed)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mmdetection的安装</title>
      <link href="/2019/07/20/mmdetection%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2019/07/20/mmdetection%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li>选择镜像：py36-pytorch0.4.0-cu90-ctc （即，准备一个cuda9.0的环境）</li><li>note: 需要一个pytorch1.1.0（pytorch1.2测试不可以用，推荐使用1.1.0），后文有讲如何在anaconda下安装pytorch</li><li>进入容器，安装anaconda</li></ul><h3 id="按着Github-install的步骤进行安装如下："><a href="#按着Github-install的步骤进行安装如下：" class="headerlink" title="按着Github install的步骤进行安装如下："></a>按着<a href="https://github.com/open-mmlab/mmdetection/blob/master/INSTALL.md" target="_blank" rel="noopener">Github install</a>的步骤进行安装如下：</h3><ul><li>Create a conda virtual environment and activate it. Then install Cython.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n open-mmlab python=<span class="number">3.7</span> -y</span><br><span class="line">source activate open-mmlab</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>** 以下的操作都是在进入open-mmlab环境之后进行的**</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="keyword">install</span> cython</span><br></pre></td></tr></table></figure></li><li><p>安装 numpy</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> numpy</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>安装<a href="https://github.com/open-mmlab/mmcv" target="_blank" rel="noopener">mmcv</a> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install mmcv</span><br></pre></td></tr></table></figure></li><li><p>安装pytorch<br>最好是离线下载，然后再安装，因为conda install 或者 pip install 可能连接不上（细节：pip install torch  就会出现下载链接，然后自己复制链接去网页下载即可），下载之后：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">pip</span> <span class="selector-tag">install</span> <span class="selector-tag">torch-1</span><span class="selector-class">.1</span><span class="selector-class">.0-cp37-cp37m-manylinux1_x86_64</span><span class="selector-class">.whl</span></span><br></pre></td></tr></table></figure></li><li><p>安装opencv</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="keyword">install</span> -c menpo opencv</span><br></pre></td></tr></table></figure></li></ul><ul><li>安装matplotlib<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> matplotlib</span><br></pre></td></tr></table></figure></li></ul><ul><li>安装 terminaltables<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> terminaltables</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>安装 pip install pycocotools</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> pycocotools</span><br></pre></td></tr></table></figure></li><li><p>选择一个看的顺眼的位置：Clone the mmdetection repository.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/open-mmlab/mmdetection.git</span><br><span class="line">cd mmdetection</span><br></pre></td></tr></table></figure></li><li><p>Install mmdetection</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py develop</span><br></pre></td></tr></table></figure></li><li><p>大功告成</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 目标检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>torch.no_grad</title>
      <link href="/2019/07/17/torch-no-grad/"/>
      <url>/2019/07/17/torch-no-grad/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://discuss.pytorch.org/t/model-eval-vs-with-torch-no-grad/19615/21" target="_blank" rel="noopener">https://discuss.pytorch.org/t/model-eval-vs-with-torch-no-grad/19615/21</a></li><li>with torch.no_grad()</li><li>可以减少内存，加快运行速度，同时可以使得batch_size 增大</li><li>但不是说非得必要</li></ul>]]></content>
      
      
      <categories>
          
          <category> pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spacy工具包</title>
      <link href="/2019/07/16/Spacy%E5%B7%A5%E5%85%B7%E5%8C%85/"/>
      <url>/2019/07/16/Spacy%E5%B7%A5%E5%85%B7%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="spacy的主要操作："><a href="#spacy的主要操作：" class="headerlink" title="spacy的主要操作："></a>spacy的主要操作：</h2><h3 id="1、分词断句"><a href="#1、分词断句" class="headerlink" title="1、分词断句"></a>1、分词断句</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import spacy</span><br><span class="line">nlp = spacy.<span class="built_in">load</span>(<span class="string">'en'</span>)</span><br><span class="line">doc = nlp(<span class="string">'Hello World! My name is HanXiaoyang'</span>)</span><br><span class="line"><span class="comment"># 分词</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">token</span> <span class="keyword">in</span> doc:</span><br><span class="line">    print(<span class="string">'"'</span> + <span class="keyword">token</span>.<span class="keyword">text</span> + <span class="string">'"'</span>)</span><br><span class="line"><span class="comment"># 断句</span></span><br><span class="line"><span class="keyword">for</span> sent <span class="keyword">in</span> doc.sents:</span><br><span class="line">    print(sent)</span><br></pre></td></tr></table></figure><p>每个token对象有着非常丰富的属性，如下的方式可以取出其中的部分属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">doc</span> <span class="string">=</span> <span class="string">nlp("Next</span> <span class="string">week</span> <span class="string">I'll</span>   <span class="string">be</span> <span class="string">in</span> <span class="string">Shanghai.")</span></span><br><span class="line"><span class="string">for</span> <span class="string">token</span> <span class="string">in</span> <span class="attr">doc:</span></span><br><span class="line">    <span class="string">print("&#123;0&#125;\t&#123;1&#125;\t&#123;2&#125;\t&#123;3&#125;\t&#123;4&#125;\t&#123;5&#125;\t&#123;6&#125;\t&#123;7&#125;".format(</span></span><br><span class="line">        <span class="string">token.text,</span></span><br><span class="line">        <span class="string">token.idx,</span></span><br><span class="line">        <span class="string">token.lemma_,</span></span><br><span class="line">        <span class="string">token.is_punct,</span></span><br><span class="line">        <span class="string">token.is_space,</span></span><br><span class="line">        <span class="string">token.shape_,</span></span><br><span class="line">        <span class="string">token.pos_,</span></span><br><span class="line">        <span class="string">token.tag_</span></span><br><span class="line">    <span class="string">))</span></span><br><span class="line"><span class="string">输出结果如下：</span></span><br><span class="line"><span class="string">Next</span>    <span class="number">0</span>   <span class="string">next</span>    <span class="literal">False</span>   <span class="literal">False</span>   <span class="string">Xxxx</span>    <span class="string">ADJ</span> <span class="string">JJ</span></span><br><span class="line"><span class="string">week</span>    <span class="number">5</span>   <span class="string">week</span>    <span class="literal">False</span>   <span class="literal">False</span>   <span class="string">xxxx</span>    <span class="string">NOUN</span>    <span class="string">NN</span></span><br><span class="line"><span class="string">I</span>   <span class="number">10</span>  <span class="bullet">-PRON-</span>  <span class="literal">False</span>   <span class="literal">False</span>   <span class="string">X</span>   <span class="string">PRON</span>    <span class="string">PRP</span></span><br><span class="line"><span class="string">'ll 11  will    False   False   '</span><span class="string">xx</span> <span class="string">VERB</span>    <span class="string">MD</span></span><br><span class="line">    <span class="number">15</span>      <span class="literal">False</span>   <span class="literal">True</span>        <span class="string">SPACE</span>   <span class="string">_SP</span></span><br><span class="line"><span class="string">be</span>  <span class="number">17</span>  <span class="string">be</span>  <span class="literal">False</span>   <span class="literal">False</span>   <span class="string">xx</span>  <span class="string">VERB</span>    <span class="string">VB</span></span><br><span class="line"><span class="string">in</span>  <span class="number">20</span>  <span class="string">in</span>  <span class="literal">False</span>   <span class="literal">False</span>   <span class="string">xx</span>  <span class="string">ADP</span> <span class="string">IN</span></span><br><span class="line"><span class="string">Shanghai</span>    <span class="number">23</span>  <span class="string">shanghai</span>    <span class="literal">False</span>   <span class="literal">False</span>   <span class="string">Xxxxx</span>   <span class="string">PROPN</span>   <span class="string">NNP</span></span><br><span class="line"><span class="string">.</span>   <span class="number">31</span>  <span class="string">.</span>   <span class="literal">True</span>    <span class="literal">False</span>   <span class="string">.</span>   <span class="string">PUNCT</span>   <span class="string">.</span></span><br></pre></td></tr></table></figure><h3 id="2、词性标注"><a href="#2、词性标注" class="headerlink" title="2、词性标注"></a>2、词性标注</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 词性标注</span></span><br><span class="line">doc = nlp(<span class="string">"Next week I'll be in Shanghai."</span>)</span><br><span class="line">print([(<span class="keyword">token</span>.<span class="keyword">text</span>, <span class="keyword">token</span>.tag_) <span class="keyword">for</span> <span class="keyword">token</span> <span class="keyword">in</span> doc])</span><br></pre></td></tr></table></figure><p>[(‘Next’, ‘JJ’), (‘week’, ‘NN’), (‘I’, ‘PRP’), (“‘ll”, ‘MD’), (‘be’, ‘VB’), (‘in’, ‘IN’), (‘Shanghai’, ‘NNP’), (‘.’, ‘.’)]</p><h3 id="3、组块分析"><a href="#3、组块分析" class="headerlink" title="3、组块分析"></a>3、组块分析</h3><p>spaCy可以自动检测名词短语，并输出根(root)词，比如下面的”Journal”,”piece”,”currencies”</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doc = nlp(<span class="string">"Wall Street Journal just published an interesting piece on crypto currencies"</span>)</span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> doc<span class="selector-class">.noun_chunks</span>:</span><br><span class="line">    print(chunk<span class="selector-class">.text</span>, chunk<span class="selector-class">.label_</span>, chunk<span class="selector-class">.root</span><span class="selector-class">.text</span>)</span><br></pre></td></tr></table></figure><p>输出结果：<br>Wall Street Journal NP Journal<br>an interesting piece NP piece<br>crypto currencies NP currencies</p><h3 id="4、命名实体识别"><a href="#4、命名实体识别" class="headerlink" title="4、命名实体识别"></a>4、命名实体识别</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doc = nlp(<span class="string">"Two years ago, I lived in my Beijing."</span>)</span><br><span class="line"><span class="keyword">for</span> ent <span class="keyword">in</span> doc<span class="selector-class">.ents</span>:</span><br><span class="line">    print(ent<span class="selector-class">.text</span>, ent.label_)</span><br></pre></td></tr></table></figure><p>输出结果：<br>Two years ago DATE<br>BeijingGPE</p><p>还可以用非常漂亮的可视化做显示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> spacy import displacy</span><br><span class="line">displacy.render(doc, <span class="attribute">style</span>=<span class="string">'ent'</span>, <span class="attribute">jupyter</span>=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="//upload-images.jianshu.io/upload_images/11681023-77f9837fa7e661dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/454/format/webp" alt></p><p>输出结果.png</p><h3 id="5、句法依存解析"><a href="#5、句法依存解析" class="headerlink" title="5、句法依存解析"></a>5、句法依存解析</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">doc = nlp(<span class="string">'Wall Street Journal just published an interesting piece on crypto currencies'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> doc:</span><br><span class="line">    print(<span class="string">"&#123;0&#125;/&#123;1&#125; &lt;--&#123;2&#125;-- &#123;3&#125;/&#123;4&#125;"</span>.format(</span><br><span class="line">        token<span class="selector-class">.text</span>, token<span class="selector-class">.tag_</span>, token<span class="selector-class">.dep_</span>, token<span class="selector-class">.head</span><span class="selector-class">.text</span>, token<span class="selector-class">.head</span><span class="selector-class">.tag_</span>))</span><br></pre></td></tr></table></figure><p>输出结果：<br>Wall/NNP &lt;–compound– Street/NNP<br>Street/NNP &lt;–compound– Journal/NNP<br>Journal/NNP &lt;–nsubj– published/VBD<br>just/RB &lt;–advmod– published/VBD<br>published/VBD &lt;–ROOT– published/VBD<br>an/DT &lt;–det– piece/NN<br>interesting/JJ &lt;–amod– piece/NN<br>piece/NN &lt;–dobj– published/VBD<br>on/IN &lt;–prep– piece/NN<br>crypto/JJ &lt;–compound– currencies/NNS<br>currencies/NNS &lt;–pobj– on/IN</p><h3 id="6、-词向量"><a href="#6、-词向量" class="headerlink" title="6、==词向量=="></a>6、==词向量==</h3><p>NLP中有一个非常强大的文本表示学习方法叫做==word2vec==，通过词的上下文学习到词语的稠密向量化表示，同时在这个表示形态下，语义相关的词在向量空间中会比较接近。也有类似v(爷爷)-v(奶奶) ≈ v(男人)-v(女人)的关系。<br>在spaCy中，要使用英文的词向量，需先下载预先训练好的结果。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">python3</span> -m spacy download en_core_web_lg</span><br></pre></td></tr></table></figure><p>词向量的应用：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">nlp = spacy.<span class="built_in">load</span>(<span class="string">'en_core_web_lg'</span>)</span><br><span class="line"><span class="built_in">from</span> scipy import spatial</span><br><span class="line"></span><br><span class="line"><span class="comment"># 余弦相似度计算</span></span><br><span class="line">cosine_similarity = lambda x, y: <span class="number">1</span> - spatial.distance.cosine(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 男人、女人、国王、女王 的词向量</span></span><br><span class="line">man = nlp.vocab[<span class="string">'man'</span>].vector</span><br><span class="line">woman = nlp.vocab[<span class="string">'woman'</span>].vector</span><br><span class="line">queen = nlp.vocab[<span class="string">'queen'</span>].vector</span><br><span class="line">king = nlp.vocab[<span class="string">'king'</span>].vector</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 我们对向量做一个简单的计算，"man" - "woman" + "queen"</span></span><br><span class="line">maybe_king = man - woman + queen</span><br><span class="line">computed_similarities = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 扫描整个词库的词向量做比对，召回最接近的词向量</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">word</span> <span class="keyword">in</span> nlp.vocab:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">word</span>.has_vector:</span><br><span class="line">        continue</span><br><span class="line"> </span><br><span class="line">    similarity = cosine_similarity(maybe_king, <span class="built_in">word</span>.vector)</span><br><span class="line">    computed_similarities.append((<span class="built_in">word</span>, similarity))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序与最接近结果展示</span></span><br><span class="line">computed_similarities = sorted(computed_similarities, key=lambda <span class="keyword">item</span>: -<span class="keyword">item</span>[<span class="number">1</span>])</span><br><span class="line">print([w[<span class="number">0</span>].<span class="keyword">text</span> <span class="keyword">for</span> w <span class="keyword">in</span> computed_similarities[:<span class="number">10</span>]])</span><br></pre></td></tr></table></figure><p>输出结果：<br>[‘Queen’, ‘QUEEN’, ‘queen’, ‘King’, ‘KING’, ‘king’, ‘KIng’, ‘Kings’, ‘KINGS’, ‘kings’]</p><h3 id="6、词汇与文本相似度"><a href="#6、词汇与文本相似度" class="headerlink" title="6、词汇与文本相似度"></a>6、词汇与文本相似度</h3><p>在词向量的基础上，spaCy提供了从词到文档的相似度计算的方法，下面的例子是它的使用方法。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 词汇语义相似度(关联性)</span></span><br><span class="line">banana = nlp.vocab['banana']</span><br><span class="line">dog = nlp.vocab['dog']</span><br><span class="line">fruit = nlp.vocab['fruit']</span><br><span class="line">animal = nlp.vocab['animal']</span><br><span class="line"> </span><br><span class="line">print(dog.similarity(animal), dog.similarity(fruit)) <span class="comment"># 0.6618534 0.23552845</span></span><br><span class="line">print(banana.similarity(fruit), banana.similarity(animal)) <span class="comment"># 0.67148364 0.2427285</span></span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文本语义相似度(关联性)</span></span><br><span class="line">target = nlp(<span class="string">"Cats are beautiful animals."</span>)</span><br><span class="line"> </span><br><span class="line">doc1 = nlp(<span class="string">"Dogs are awesome."</span>)</span><br><span class="line">doc2 = nlp(<span class="string">"Some gorgeous creatures are felines."</span>)</span><br><span class="line">doc3 = nlp(<span class="string">"Dolphins are swimming mammals."</span>)</span><br><span class="line"> </span><br><span class="line">print(target.similarity(doc1))  <span class="comment"># 0.8901765218466683</span></span><br><span class="line">print(target.similarity(doc2))  <span class="comment"># 0.9115828449161616</span></span><br><span class="line">print(target.similarity(doc3))  <span class="comment"># 0.7822956752876101</span></span><br></pre></td></tr></table></figure><p>作者：还是那个没头脑<br>链接：<a href="https://www.jianshu.com/p/74e6c5376bc0" target="_blank" rel="noopener">https://www.jianshu.com/p/74e6c5376bc0</a><br>来源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 自然语言理解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自然语言理解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytorch-gather</title>
      <link href="/2019/07/12/pytorch-gather/"/>
      <url>/2019/07/12/pytorch-gather/</url>
      
        <content type="html"><![CDATA[<p>函数<code>torch.gather(input, dim, index, out=None) → Tensor</code><br> 沿给定轴 dim ,将输入索引张量 index 指定位置的值进行聚合.<br> 对一个 3 维张量,输出可以定义为:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">out[<span class="string">i</span>][<span class="symbol">j</span>][<span class="string">k</span>] = input[<span class="string">index[i</span>][<span class="symbol">j</span>][<span class="string">k</span>]][<span class="string">j</span>][<span class="symbol">k</span>]  # if dim == 0</span><br><span class="line">out[<span class="string">i</span>][<span class="symbol">j</span>][<span class="string">k</span>] = input[<span class="string">i</span>][<span class="symbol">index[i</span>][<span class="string">j</span>][<span class="symbol">k</span>]][<span class="symbol">k</span>]  # if dim == 1</span><br><span class="line">out[<span class="string">i</span>][<span class="symbol">j</span>][<span class="string">k</span>] = input[<span class="string">i</span>][<span class="symbol">j</span>][<span class="string">index[i</span>][<span class="symbol">j</span>][<span class="string">k</span>]]  # if dim == 2</span><br></pre></td></tr></table></figure><p>Parameters:</p><ul><li>input (Tensor) – 源张量</li><li>dim (int) – 索引的轴</li><li>index (LongTensor) – 聚合元素的下标(index需要是torch.longTensor类型)</li><li>out (Tensor, optional) – 目标张量</li></ul>]]></content>
      
      
      <categories>
          
          <category> pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/07/11/hello-world/"/>
      <url>/2019/07/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>numpy 函数</title>
      <link href="/2019/06/16/numpy-%E5%87%BD%E6%95%B0/"/>
      <url>/2019/06/16/numpy-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="np-round"><a href="#np-round" class="headerlink" title="np.round "></a><font color="#0099ff" size="7" face="黑体">np.round </font></h2><h3 id="round函数概念："><a href="#round函数概念：" class="headerlink" title="round函数概念："></a>round函数概念：</h3><p>英文：圆，四舍五入<br>是python内置函数，它在哪都能用，对数字取四舍五入。<br>round(number[, ndigits])<br>round 对传入的数据进行四舍五入，如果ngigits不传，默认是0（就是说保留整数部分）.ngigits&lt;0 的时候是来对整数部分进行四舍五入，返回的结果是浮点数.</p><h3 id="round-负数"><a href="#round-负数" class="headerlink" title="round 负数"></a>round 负数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 四舍五入是围绕着0来计算的，  </span></span><br><span class="line">round(<span class="number">0.5</span>) <span class="comment"># 1.0  </span></span><br><span class="line">round(<span class="number">-0.5</span>) <span class="comment">#-1.0</span></span><br></pre></td></tr></table></figure><h3 id="round-的陷阱"><a href="#round-的陷阱" class="headerlink" title="round 的陷阱"></a>round 的陷阱</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">round(<span class="number">1.675</span>, <span class="number">2</span>) <span class="comment">#1.68  </span></span><br><span class="line">round(<span class="number">2.675</span>, <span class="number">2</span>) <span class="comment">#2.67</span></span><br></pre></td></tr></table></figure><h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">round(<span class="number">3.4</span>) <span class="comment"># 3.0  </span></span><br><span class="line">round(<span class="number">3.5</span>) <span class="comment"># 4.0  </span></span><br><span class="line">round(<span class="number">3.6</span>) <span class="comment"># 4.0  </span></span><br><span class="line">round(<span class="number">3.6</span>, <span class="number">0</span>) <span class="comment"># 4.0  </span></span><br><span class="line">round(<span class="number">1.95583</span>, <span class="number">2</span>) <span class="comment"># 1.96  </span></span><br><span class="line">round(<span class="number">1241757</span>, <span class="number">-3</span>) <span class="comment"># 1242000.0  </span></span><br><span class="line">round(<span class="number">5.045</span>, <span class="number">2</span>) <span class="comment"># 5.05  </span></span><br><span class="line">round(<span class="number">5.055</span>, <span class="number">2</span>) <span class="comment"># 5.06</span></span><br></pre></td></tr></table></figure><h2 id="np-clip"><a href="#np-clip" class="headerlink" title="np.clip"></a><font color="#0099ff" size="7" face="黑体">np.clip</font></h2><p>numpy.clip(a, a_min, a_max, out=None)[source]<br>其中a是一个数组，后面两个参数分别表示最小和最大值，怎么用呢，老规矩，我们看代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x=np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>])</span><br><span class="line">np.clip(x,<span class="number">3</span>,<span class="number">8</span>)</span><br><span class="line">Out[<span class="number">88</span>]:</span><br><span class="line">array([<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>self-attention</title>
      <link href="/2019/06/16/self-attention/"/>
      <url>/2019/06/16/self-attention/</url>
      
        <content type="html"><![CDATA[<ul><li>一篇解读：<a href="https://kexue.fm/archives/4765" target="_blank" rel="noopener">https://kexue.fm/archives/4765</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 自然语言理解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自然语言理解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优先级队列式分支限界法---最小重量机器设计问题--python实现</title>
      <link href="/2019/05/22/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%BC%8F%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95-%E6%9C%80%E5%B0%8F%E9%87%8D%E9%87%8F%E6%9C%BA%E5%99%A8%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98-python%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/05/22/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%BC%8F%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95-%E6%9C%80%E5%B0%8F%E9%87%8D%E9%87%8F%E6%9C%BA%E5%99%A8%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98-python%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>这里给出两个解决方案：</p><p>1）不使用优先级，简单使用队列式分支限界法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 普通的FIFO 队列式分支限界法</span></span><br><span class="line"><span class="comment">## 当 不满足总价格不超过d的要求时，则剪枝</span></span><br><span class="line"><span class="comment">## 当搜索到深度n时，即搜索到了叶节点，不再进行扩展节点的操作，而是针对于叶节点所对应的最小值，</span></span><br><span class="line"><span class="comment"># 反向求得该节点所对应的的路径</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># coding : utf-8</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = <span class="number">3</span></span><br><span class="line">m = <span class="number">3</span></span><br><span class="line">d = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">price = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line">weight = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到当前扩展节点所在的Level</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getlevel</span><span class="params">(m, currrent)</span>:</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    level = <span class="number">0</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> currrent == <span class="number">0</span>:</span><br><span class="line">        level = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> level</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">        level = level+<span class="number">1</span></span><br><span class="line">        sum = m**level + sum  <span class="comment"># sum=m</span></span><br><span class="line">        <span class="keyword">if</span> sum-m**level &lt; currrent &lt;= sum:  <span class="comment"># m-m^0 = m-1</span></span><br><span class="line">            <span class="keyword">return</span> level</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到当前扩展节点，所对应的首个子节点所在的索引</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_idx</span><span class="params">(m, current)</span>:</span></span><br><span class="line">    level = getlevel(m, current)</span><br><span class="line">    <span class="comment"># 求current 在该level中的相对索引，即 相对于该level第一个元素的位置</span></span><br><span class="line">    current_level_idx = current - sum([m**i <span class="keyword">for</span> i <span class="keyword">in</span> range(level)])</span><br><span class="line">    <span class="comment"># 子节点所在层的开始绝对索引</span></span><br><span class="line">    start_idx  = sum([m**i <span class="keyword">for</span> i <span class="keyword">in</span> range(level+<span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> start_idx + current_level_idx*m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到最优解之后，反向查找其路径</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_path</span><span class="params">(m, current)</span>:</span></span><br><span class="line">    path = []</span><br><span class="line">    path.append(current%m)  <span class="comment"># from 1, not from 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        level = getlevel(m, current)</span><br><span class="line">        <span class="keyword">if</span> level == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> path[::<span class="number">-1</span>]</span><br><span class="line">        current_level_idx = current - sum([m ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(level)])  <span class="comment"># # 求current 在该level中的相对索引，即 相对于该level第一个元素的位置</span></span><br><span class="line">        path.append(current_level_idx // m + <span class="number">1</span>)  <span class="comment"># 得到上一级的索引位置</span></span><br><span class="line">        current = sum([m ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(level<span class="number">-1</span>)]) + current_level_idx // m  <span class="comment">#得到上一级的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MinWighet</span><span class="params">(n,m,d,price,weight)</span>:</span></span><br><span class="line">    minweight = float(<span class="string">"inf"</span>)</span><br><span class="line">    <span class="comment"># 子集树中的节点数</span></span><br><span class="line">    vec_len = sum([m ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>)]) + <span class="number">1</span></span><br><span class="line">    que = queue.Queue()</span><br><span class="line">    que.put(<span class="number">0</span>)</span><br><span class="line">    vec_price = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(vec_len)]</span><br><span class="line">    vec_weight = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(vec_len)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">not</span> que.empty()):</span><br><span class="line">        current = que.get()  <span class="comment"># 得到当前扩展节点（索引号）</span></span><br><span class="line">        level = getlevel(m, current)  <span class="comment"># 当前 扩展节点所在的level</span></span><br><span class="line"></span><br><span class="line">        idx = get_idx(m, current)   <span class="comment"># 得到当前扩展节点，所对应的首个子节点所在的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 若搜索完了整棵树</span></span><br><span class="line">        <span class="keyword">if</span> getlevel(m, current) == getlevel(m, vec_len)<span class="number">-1</span>:</span><br><span class="line">            minweight = vec_price[current]</span><br><span class="line">            min_at_idx = current</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">not</span> que.empty()):</span><br><span class="line">                <span class="comment"># minweight = min(minweight, vec_price[que.get()])</span></span><br><span class="line">                tmp = que.get()</span><br><span class="line">                <span class="keyword">if</span> minweight &gt; vec_price[tmp]:</span><br><span class="line">                    minweight = vec_price[tmp]</span><br><span class="line">                    min_at_idx = tmp</span><br><span class="line">            path = get_path(m, min_at_idx)</span><br><span class="line">            <span class="keyword">return</span> minweight, path</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断当前的扩展结点下的所有子节点是否可以加入活结点队列中</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            vec_price[idx] = int(vec_price[current] + price[level][i])</span><br><span class="line">            <span class="keyword">if</span> vec_price[idx] &lt;= d:</span><br><span class="line">                vec_weight[idx] = int(vec_weight[current] + weight[level][i])</span><br><span class="line">                que.put(idx)</span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(MinWighet(n,m,d,price,weight))</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>2） 优先级队列式分支限界法</p><p>解空间：子集树，每个分支节点的分支数为m<br>解向量：x[1:n]  n为部件数量， x[i] 表示第i个部件使用哪个供应商。</p><p>算法：采用优先队列式分支限界法。<br>类似于单源最短路径，使用当前节点所确定下的采购方案对应的机器重量和最为优先级。<br>由于wij不是负值，当前节点所对应的当前机器重量和是解空间中以该节点为根的子树的中所有节点所对应的重量和的下界。</p><p>算法代码实现：</p><p>1）使用列表来代表队列，通过对列表中的活结点按照其当前重量和进行从小到大排序（实现了最小堆的维护）<br>2）定义一个节点类，属性有：节点所在的索引，以及节点当前的重量和<br>3）取出一个扩展节点：由于对活结点表进行了某种规则的排序，则直接取出列表的第一个元素即可<br>4）加入活结点表：将满足条件的子节点加入到活结点表中</p><p>失活当前扩展节点：删掉列表中的第一个元素即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 普通的FIFO 队列式分支限界法</span></span><br><span class="line"><span class="comment">## 当 不满足总价格不超过d的要求时，则剪枝</span></span><br><span class="line"><span class="comment">## 当搜索到深度n时，即搜索到了叶节点，不再进行扩展节点的操作，而是针对于叶节点所对应的最小值，</span></span><br><span class="line"><span class="comment"># 反向求得该节点所对应的的路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入优先级--使用当前节点的重量作为优先级，重量小优先级高</span></span><br><span class="line"><span class="comment"># 将队列改成列表，以append的方式加入到列表中，再以排序的方式维护当前列表的首个元素为最小权值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># coding : utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到当前扩展节点所在的Level</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getlevel</span><span class="params">(m, currrent)</span>:</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    level = <span class="number">0</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> currrent == <span class="number">0</span>:</span><br><span class="line">        level = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> level</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">        level = level+<span class="number">1</span></span><br><span class="line">        sum = m**level + sum  <span class="comment"># sum=m</span></span><br><span class="line">        <span class="keyword">if</span> sum-m**level &lt; currrent &lt;= sum:  <span class="comment"># m-m^0 = m-1</span></span><br><span class="line">            <span class="keyword">return</span> level</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到当前扩展节点，所对应的首个子节点所在的索引</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_idx</span><span class="params">(m, current)</span>:</span></span><br><span class="line">    level = getlevel(m, current)</span><br><span class="line">    <span class="comment"># 求current 在该level中的相对索引，即 相对于该level第一个元素的位置</span></span><br><span class="line">    current_level_idx = current - sum([m**i <span class="keyword">for</span> i <span class="keyword">in</span> range(level)])</span><br><span class="line">    <span class="comment"># 子节点所在层的开始绝对索引</span></span><br><span class="line">    start_idx  = sum([m**i <span class="keyword">for</span> i <span class="keyword">in</span> range(level+<span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> start_idx + current_level_idx*m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到最优解之后，反向查找其路径</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_path</span><span class="params">(m, current)</span>:</span></span><br><span class="line">    path = []</span><br><span class="line">    path.append(current%m)  <span class="comment"># from 1, not from 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        level = getlevel(m, current)</span><br><span class="line">        <span class="keyword">if</span> level == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> path[::<span class="number">-1</span>]</span><br><span class="line">        current_level_idx = current - sum([m ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(level)])  <span class="comment"># # 求current 在该level中的相对索引，即 相对于该level第一个元素的位置</span></span><br><span class="line">        path.append(current_level_idx // m + <span class="number">1</span>)  <span class="comment"># 得到上一级的索引位置</span></span><br><span class="line">        current = sum([m ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(level<span class="number">-1</span>)]) + current_level_idx // m  <span class="comment">#得到上一级的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为活结点表中的节点 定义了一个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, idx, weight)</span>:</span></span><br><span class="line">        self.idx = idx</span><br><span class="line">        self.weight = weight</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MinWighet</span><span class="params">(n,m,d,price,weight)</span>:</span></span><br><span class="line">    <span class="comment"># 子集树中的节点数</span></span><br><span class="line">    vec_len = sum([m ** i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>)]) + <span class="number">1</span></span><br><span class="line">    que = []</span><br><span class="line">    que.append(Node(<span class="number">0</span>,<span class="number">0</span>))  <span class="comment"># 在活结点表中加入根节点</span></span><br><span class="line">    <span class="comment"># vec_price = [0 for _ in range(vec_len)]</span></span><br><span class="line">    <span class="comment"># vec_weight = [0 for _ in range(vec_len)]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(que):  <span class="comment"># 当活结点表非空时</span></span><br><span class="line">        que = sorted(que, key=<span class="keyword">lambda</span> node: node.weight)  <span class="comment"># 类似于最小堆的维护</span></span><br><span class="line">        current = que[<span class="number">0</span>]  <span class="comment"># 得到当前扩展节点（索引号）</span></span><br><span class="line">        level = getlevel(m, current.idx)  <span class="comment"># 当前 扩展节点所在的level</span></span><br><span class="line"></span><br><span class="line">        new_node_idx = get_idx(m, current.idx)   <span class="comment"># 得到当前扩展节点，所对应的首个子节点所在的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 若搜索完了整棵树</span></span><br><span class="line">        <span class="keyword">if</span> getlevel(m, current.idx) == getlevel(m, vec_len)<span class="number">-1</span>:</span><br><span class="line">            minweight = current.weight</span><br><span class="line">            min_at_idx = current.idx</span><br><span class="line"></span><br><span class="line">            path = get_path(m, min_at_idx)</span><br><span class="line">            <span class="keyword">return</span> minweight, path</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断当前的扩展结点下的所有子节点是否可以加入活结点队列中</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> int(current.weight + price[level][i]) &lt;= d:</span><br><span class="line">                new_node = Node(new_node_idx, int(current.weight + weight[level][i]))</span><br><span class="line">                que.append(new_node)</span><br><span class="line">            new_node_idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将当前的扩展节点失活</span></span><br><span class="line">        <span class="keyword">del</span> que[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    n = <span class="number">3</span></span><br><span class="line">    m = <span class="number">3</span></span><br><span class="line">    d = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    price = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]]</span><br><span class="line">    weight = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]]</span><br><span class="line">    result = MinWighet(n,m,d,price,weight)</span><br><span class="line">    print(MinWighet(n,m,d,price,weight))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Grounded Video Description</title>
      <link href="/2019/05/10/Grounded-Video-Description/"/>
      <url>/2019/05/10/Grounded-Video-Description/</url>
      
        <content type="html"><![CDATA[<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><ul><li>这是CVPR 2019 做视频描述的一篇文章，该文的主要贡献是对已有的ActivityNet dense caption数据集进行加强—对其中的帧进行了object bbox的标注，这就为视频描述任务增加了非常有用的信息。</li><li>总的来说，<font color="#dd00dd">该文的出发点是：1. 利用object 信息来生成句子. 2. 希望生成的句子中的名词，在video中可以找到相对应的证据(object)。</font><br></li><li>grounded-based video description model ：联合生成的单词，并微调在description中生成的object。可以探索这种显式的监督对视频描述带来的益处，并与无监督（可能利用region feature，但是没有 penalize grounding）的方法进行对比。</li></ul><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><ul><li>video输出的句子中提到的object，并没有在该video中实际存在。那么为什么有这种现象，是因为前的视频描述模型是基于先验知识，在之前的训练过程中，存在一个视频与该视频有 similar contexts，从而使得输出的单词中涵盖了训练video中的obejct，而不是该video本身的object，导致了该现象。</li><li>因此本文的工作： 将句子中的名词与视频中的object一 一对应起来，这样就可以建立sentence 与 evidence of video 之间的联系。<br>这样可以<font color="#0099ff" size="5">在视频描述模型中使用这些object 信息</font>，同时，<font color="#0099ff" size="5">还可以评估模型</font>（“teaching models to explicitly rely on the corresponding evidence in the video frame  when generating words and evaluating how well models   are doing in grounding individual words or phrases they  generated.”）。<br>如：该模型生成的句子中的名词与已经标注的object是否是一 一对应的（即便一个模型说出争取的sentence，比如一个男孩正在玩耍，但是如果video中有多个个男孩，那么该sentence输出的一个男孩是指向哪一个呢？）。</li></ul><h2 id="标注bbox时的细节"><a href="#标注bbox时的细节" class="headerlink" title="标注bbox时的细节"></a>标注bbox时的细节</h2><ul><li>“we collect ActivityNet-Entities (short as ANet-Entities) which  grounds or links noun phrases in sentences with bounding  boxes in the video frames.”<br>“we only  annotate a single frame of the video for each noun phrase” 。<br>即， 是对照着已有的sentence中的名词对其进行加框(bbox)，而不是对该video中的所有示例进行标注。对于sentence中的一个名词只在一帧上进行标注（稀疏标注） </li></ul><h2 id="调研工作"><a href="#调研工作" class="headerlink" title="调研工作"></a>调研工作</h2><h3 id="1-结合object-feature-做captioning任务"><a href="#1-结合object-feature-做captioning任务" class="headerlink" title="1. 结合object feature 做captioning任务"></a>1. 结合object feature 做captioning任务</h3><ul><li><strong>当前的方法</strong>，主要是两步：（1）使用off-the-shelf 或者是fine-tuned 的 object detector 来得到 object proposals （2）对object features采用动态attention，或者是对region进行分类，然后送入 decoder中。</li><li><strong>存在的问题</strong>，使用现成的object detector 将会使得到的object proposals 更偏向于 source dataset , 而不是偏向于当前的视频描述target dataset。一种解决方案是针对于target dataset 来fine-tune object detector。但是这种那个方案需要大量的标注，尤其是对于video，数据量会更大，</li><li>因此提出了<font color="#0099ff" size="5" face="黑体">本文的方法(给出了fine-tune obejct detector的改进方案)</font>：“Instead of  fine-tuning a general detector, we transfer the object classification knowledge from off-the-shelf object detectors to  our model and then fine-tune this representation as part of  our generation model with sparse box annotations. ”。</li><li>在文章中的4.4节开头给出了具体的实现：已经得到了bbox，现在的目的是想要得到the class probability distribution for each region. 将在visual genome上预训练的detector迁移到我们的<strong>object classifier</strong> 任务上，另外关于classes集合，假定我们已经有了K个类别，则我们在Visual Genome中根据最近距离找到与其对应的classes。  定义一个softmax( Wx+b )的分类层，W 和 b 的初始化是预训练的detector的最后一个线性层（分类层）的参数值（W应该是根据找出的K个类别按照索引抽出的一个矩阵）。<h3 id="2-object-attention"><a href="#2-object-attention" class="headerlink" title="2. object attention"></a>2. object attention</h3></li><li>某些作者指出，attention model关注的region和人类的关注点并不一致，增加attention supervision几乎不能提高性能。另一方面，在feature map attention 上增加监督，是有益处的。</li><li>在该文作者的实验中，region attention with supervision 并不能带来性能的提升，作者分析，这可能是由于缺少object context 信息，因此<font color="#0099ff" size="5" face="黑体">该文作者在attention model中引入了基于context encoding 的self-attention</font>，这将会使得信息能够在被采样的视频帧中的regions 传递(我理解的是，region feature 不仅仅是单纯的从fc层中提取到的信息，同时也结合了其余信息来得到 grounding-aware region encoding， 在文章的4.3 以及 4.4节有关于<strong>R<sup>~</sup></strong> 的定义)。 </li></ul><h2 id="Description-with-Grounding-Supervision"><a href="#Description-with-Grounding-Supervision" class="headerlink" title="Description with Grounding Supervision"></a>Description with Grounding Supervision</h2><ul><li>这个框架包括三个模块: <strong>grounding</strong>, <strong>region attention</strong> and <strong>language generation</strong>.<br>grounding： 对于生成的word， 从video中检测到对应的visual clue。<br>region attention: 动态的将visual clue 形成一个high-level的视觉内容的表达，并将其送入decoder。   </li><li>这里包括三种方式来结合object-level supervision: <strong>region classification</strong>,  <strong>object grounding (localization)</strong>, and <strong>supervised attention</strong>.  </li><li><strong>（我的理解，supervised attention直接针对attention中的系数，查看与真实的对应关系，设计的这个loss对于视频描述生成由益处；object grounding 涉及到了region attention中的系数，因此与描述生成有一定的关联，反向传播可能是有益处的；region classification中设计的loss： 它的反向传播会更新M<sub>s</sub>( R ), 进一步作用于region encoding, 进一步作用于region attention 和 language generate；）</strong></li></ul><h3 id="Language-Generation-Module"><a href="#Language-Generation-Module" class="headerlink" title="Language Generation Module"></a>Language Generation Module</h3><ul><li>本文的decoder 部分采用 [1] 中提到的decoder，与bottom up[3] 的结构大致近似，但是<strong>在[1]中</strong>第二层 language lstm的输入部分，不仅包括attention of region feature， 还包括attention of 最后一个卷积层k girds的特征。对应到本文的视频描述任务上，第二层language lstm的输入，不仅包括attention of region features ，还包括 attention of frames features。即region attention 和 temporal attention</li><li>需要注意的是该文中使用的<font color="#0099ff" size="5" face="黑体">temporal attention</font>是[2]中提到的self-attention context encoder with Bidirectional GRU (Bi-GRU)，而不是[1]中使用的attention机制。</li><li><font color="#0099ff" size="5" face="黑体">region attention</font>采用的就是bottom up 中的attention结构</li><li>下面将[1] 中的原图贴一下：   <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2x5hlq801j30l20ezq4v.jpg">   </li></ul><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><h3 id="Region-proposal-and-features"><a href="#Region-proposal-and-features" class="headerlink" title="Region proposal and features"></a>Region proposal and features</h3><p>For each frame, we use a Faster  R-CNN detector [24] with ResNeXt-101 backbone [30] for  region proposal and feature extraction (fc6). The detector is  pretrained on Visual Genome。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] Neural baby talk. In CVPR 2018.<br>[2] End-to-end dense video captioning with masked transformer. In CVPR 2018.<br>[3] Bottom-up and top-down attention for image captioning and  visual question answering. In CVPR 2018.</p>]]></content>
      
      
      <categories>
          
          <category> 视频描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spatio-Temporal Dynamics and Semantic Attribute Enriched Visual Encoding for Video Captioning（CVPR2019）</title>
      <link href="/2019/05/10/Spatio-Temporal-Dynamics-and-Semantic-Attribute-Enriched-Visual-Encoding-for-Video-Captioning-1/"/>
      <url>/2019/05/10/Spatio-Temporal-Dynamics-and-Semantic-Attribute-Enriched-Visual-Encoding-for-Video-Captioning-1/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/09/02/T5AzpW8DHkVL2Oy.png" alt="搜狗截图20190902152617.png"></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul><li>我们的方法丰富视觉特征的<strong>时域动态temporal dynamics</strong>，通过在整个video上分层对CNN特征应用短的fourier 变换</li><li>从object detector 中提取高层语义，来丰富被检测object 的<strong>空间动态 spatial dynamics</strong></li><li>最终的表达映射到一个压缩的空间</li></ul><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul><li>object detector YOLO[1]</li><li>目标检测和C3D的输出层被用来得到高层语义属性，</li><li>提出的视觉特征包含检测的目标属性、目标发生的频率</li></ul><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>现有的video captioning model 一种使用平均池化得到特征，一种使用attention得到high level特征，但是这些视觉特征都是直接的被使用，则，这些方法没有充分利用CNN在视频字幕框架中的最新特性。我们的模型丰富了视觉特征，实验结果证明，该视觉特征与任意一个简单的语言模型相结合，可以提高其性能。</p><h2 id="Visual-Representation"><a href="#Visual-Representation" class="headerlink" title="Visual Representation"></a>Visual Representation</h2><ul><li>the visual representation of a  video V as v = [α; β; γ; η]</li><li>α; β; γ; η 是四个列向量，下面具体介绍如何得到这四个列向量<h3 id="Encoding-temporal-dynamics"><a href="#Encoding-temporal-dynamics" class="headerlink" title="Encoding temporal dynamics"></a>Encoding temporal dynamics</h3></li><li>首先已经有 f 帧 对应的CNN[2]特征向量，和c个clip对应的C3D[3]得到的特征向量</li><li>对某个video而言，其所有帧再某一个维度的神经元，组成了一个特征向量a，利用<strong>傅里叶变换</strong>得到一个p维度的特征向量，将a分成两半，分别进行傅里叶变换，得到一个p维度的特征向量，再次进行分半，等等一系列操作，可以得到 p×7的矩阵。则对于所有的神经元m 则得到m×p×7的张量。至此得到<strong>α</strong></li><li><strong>β</strong>同理，只是对clips对应的C3D特征进行处理</li><li>目前已经有将傅里叶变换应用在行为识别上的文章吗，但是本文是第一篇将傅里叶变换应用在视频描述上的文章。</li><li><font color="#0099ff" size="4" face="黑体">但是需要注意的是，该文并没有说明使用傅里叶变换的动机（rich temporal dynamics?），但是为什么使用傅里叶变换可以丰富？？</font></li></ul><h3 id="Encoding-Semantics-and-Spatial-Evolution"><a href="#Encoding-Semantics-and-Spatial-Evolution" class="headerlink" title="Encoding Semantics and Spatial Evolution"></a>Encoding Semantics and Spatial Evolution</h3><ul><li>比较复杂，利用object detector YOLO 来提取Object 以及C3D来加强语义信息，具体看论文吧</li></ul><h2 id="Experimental-Results-on-MSVD"><a href="#Experimental-Results-on-MSVD" class="headerlink" title="Experimental Results on MSVD"></a>Experimental Results on MSVD</h2><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2wd8q6kegj30dh0ig0wc.jpg">    <ul><li>GRU-MP - (C3D) 与 使用了傅里叶变换的GRU-EVEhft - (C3D)  相比，可知，使用傅里叶变换是有小鬼的</li><li>GRU-EVEhft - (CI) 与GRU-EVEhft+sem - (CI)相比，可得增加的senmatic 效果是不显著的。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] Yolo9000: better, faster, stronger.  In IEEE CVPR, 2017<br>[2] Inception-v4, inception-resnet and the impact of residual  connections on learning. In AAAI, volume 4, page 12, 2017.<br>[3] Learning spatiotemporal features with 3d convolutional networks. In Proceedings of the IEEE international conference  on computer vision, pages 4489–4497, 2015.</p>]]></content>
      
      
      <categories>
          
          <category> 视频描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-dict</title>
      <link href="/2019/05/08/python-dict/"/>
      <url>/2019/05/08/python-dict/</url>
      
        <content type="html"><![CDATA[<h1 id="dict-的get-函数"><a href="#dict-的get-函数" class="headerlink" title="dict 的get 函数"></a>dict 的get 函数</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Python 字典(Dictionary) get() 函数返回指定键的值，如果值不在字典中返回默认值。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>get()方法语法：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict.<span class="builtin-name">get</span>(key, <span class="attribute">default</span>=None)</span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li>key – 字典中要查找的键。</li><li>default – 如果指定键的值不存在时，返回该默认值值。</li></ul><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>返回指定键的值，如果值不在字典中返回默认值None。</p><h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><p>get函数的作用是返回指定key的值，若key不存在，则返回default值，default值，默认为None，也可以自己指定</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Show, Attend and Tell: Neural Image Caption Generation with Visual Attention</title>
      <link href="/2019/05/06/Show-Attend-and-Tell-Neural-Image-Caption-Generation-with-Visual-Attention/"/>
      <url>/2019/05/06/Show-Attend-and-Tell-Neural-Image-Caption-Generation-with-Visual-Attention/</url>
      
        <content type="html"><![CDATA[<ul><li>encoder  attention<br>本文的出发点是利用低层次的特征，并结合了attention 机制<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2re7nfbn3j30q70430sx.jpg"></li></ul><p>参考链接：<a href="https://blog.csdn.net/shenxiaolu1984/article/details/51493673" target="_blank" rel="noopener">https://blog.csdn.net/shenxiaolu1984/article/details/51493673</a></p>]]></content>
      
      
      <categories>
          
          <category> 图像描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>池化层的反向传播</title>
      <link href="/2019/04/21/%E6%B1%A0%E5%8C%96%E5%B1%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/"/>
      <url>/2019/04/21/%E6%B1%A0%E5%8C%96%E5%B1%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/</url>
      
        <content type="html"><![CDATA[<ul><li>参考： <a href="https://blog.csdn.net/qq_21190081/article/details/72871704" target="_blank" rel="noopener">https://blog.csdn.net/qq_21190081/article/details/72871704</a></li><li>总结，<br>（1）对于平均池化层，比如2×2-&gt;1， 梯度的反向传递，是1-&gt;2×2，若梯度为x, 则，反向传播的梯度为4个 1/4<br>（1）对于最大池化层，比如2×2-&gt;1， 梯度的反向传递，是1-&gt;2×2，若梯度为x, 则，反向传播只赋值给最大值所在的元素，其余三个元素的梯度为0</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>An End-to-End Baseline for Video Captioning</title>
      <link href="/2019/04/20/An-End-to-End-Baseline-for-Video-Captioning/"/>
      <url>/2019/04/20/An-End-to-End-Baseline-for-Video-Captioning/</url>
      
        <content type="html"><![CDATA[<h3 id="积累梯度那里没有看明白-–-解决内存占用多的问题"><a href="#积累梯度那里没有看明白-–-解决内存占用多的问题" class="headerlink" title="积累梯度那里没有看明白 – 解决内存占用多的问题"></a>积累梯度那里没有看明白 – 解决内存占用多的问题</h3><p>我认为可能是积累 loss, 直到达到某一个batch size才进行反向传播<br>说是为了解决内存占用多的问题，可是这样，就解决了吗？？？</p><h3 id="灵魂反问"><a href="#灵魂反问" class="headerlink" title="灵魂反问"></a>灵魂反问</h3><p>为什么要是end-to-end，我最终需要的是一个效果比较好的模型，但是为了只得到这样的一点提升，反而会需要很多的GPU计算资源。这个end-to-end fine-tune 是否有必要。</p><h3 id="目前方法存在的问题"><a href="#目前方法存在的问题" class="headerlink" title="目前方法存在的问题"></a>目前方法存在的问题</h3><p>encoder：比如 CNN， 一般是在不同任务上的其他数据集上进行预训练的，之后，在训练video captioning任务时，得到的video/image feature就不再fine tune。这样得到的结果是次优的。<br>目前改进这一缺陷的文章有：[1][2][3]，他们尝试捕捉不同帧之间的动态时域，但是，他们没有从根本上改变一个事实：视频描述任务需要一个与该任务相关的特征。</p><h4 id="当前没有人去fine-tune-encoder的原因"><a href="#当前没有人去fine-tune-encoder的原因" class="headerlink" title="当前没有人去fine-tune encoder的原因"></a>当前没有人去fine-tune encoder的原因</h4><p>（1）because of the amount of memory required to process  video data for each batch。是因为每个批次都要处理视频数据，所需要的存储空间会很大。<br>（2）batch sizes for video captioning can become very high (e.g. 512), making training  prohibitive on a small number of GPUs。同时，视频描述的批次一般都比较大，使得所需要的GPU数量会很多。</p><h4 id="本文提取出的解决方案—-即训练过程"><a href="#本文提取出的解决方案—-即训练过程" class="headerlink" title="本文提取出的解决方案—-即训练过程"></a>本文提取出的解决方案—-即训练过程</h4><p>In this paper we address this issue by accumulating gradients over multiple steps, to update parameters only after  the required effective batch size is achieved.<br>在多步积累梯度，并只在达到有效的批次大小之后(当神经网络训练完512个examples)，才进行梯度更新。<br>这种训练方案相比于分别训练两部分收敛速度会慢，因为所需的迭代次数增加了。但是这里采用了一个加速训练过程的方案，先分别训练encoder和decoder，然后再end-to-end进行fine-tune。</p><h4 id="主要的贡献"><a href="#主要的贡献" class="headerlink" title="主要的贡献"></a>主要的贡献</h4><ol><li>可以得到与具体任务（视频描述）相关的特征</li><li>积累梯度来限制GPU存储消耗，因此可以处理大批次，这是基于RNN的decoders所需的。</li><li>使用了两阶段的训练来加速训练</li><li>为未来的工作，创建了一个简单的baseline</li></ol><h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><ol><li>先预训练encoder，例如利用图像识别、行为识别等</li><li>冻结encoder的参数，在视频描述任务上训练decoder，直到在验证数据集上表现出比较好的效果</li><li>整个网络，端到端的训练，冻结Inception-ResNet-v2中的BN层，由于该过程中占用的内存较多，作者采用了一种方法：accumulating gradients over multiple steps, to update parameters only after  the required effective batch size is achieved. </li></ol><ul><li>需要注意的是，在2. 3. 阶段的训练过程中，SA-LSTM都是使用target words(ground truth)作为输入，而不是使用之前的预测。</li></ul><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p> Inception-ResNet-v2[5] as an encoder，and a modified version of  Soft-Attention LSTM as a decoder.<br> <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2ad637ykjj30hy0h677d.jpg">    </p><ul><li>decoder<ul><li>输入LSTM的input: <strong>x<sup>t</sup></strong> ：<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2aeagi7o3j30a30280sl.jpg">    - 该step 生成的word：<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2aeiriwanj30jd014mx7.jpg"></li></ul></li></ul><p>soft-attention这里，原文是采用attention机制进行加权求和 ，这里与原soft-attention[2] 略有不同。</p><ul><li><p>原soft-attention论文：</p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2aeagheogj308o03ct8l.jpg">     </li><li><p>现修改为：（增加了β<sub>t</sub>）</p></li></ul><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2aeagka0rj30h504dq37.jpg">   <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2aeaggzpdj309302xdfq.jpg">   <ul><li><font color="#0099ff" size="5" face="黑体">这里与Figure2 图中显示的结构并不一致，这里是全权求和，但是在图中却是concatenate !</font></li></ul><ul><li>还有一些其他的修改<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2aes6w62rj30il09xwgp.jpg"></li></ul><h3 id="实验效果"><a href="#实验效果" class="headerlink" title="实验效果"></a>实验效果</h3><ul><li>step1 : encoder先训练，然后固定encoder的参数，训练decoder的参数，不进行联合训练</li><li>step2：在step1的基础上，联合训练encoder-decoder。</li><li>MSR-VTT的实验结果<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2ajqfodpkj30kl0b9acc.jpg">  </li><li>MSVD的实验结果<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2ajqfqhbjj30ks0icn0q.jpg"></li></ul><h4 id="yaya：-本文step1训练效果比较好的原因（相较于soft-attention-lstm-原论文）"><a href="#yaya：-本文step1训练效果比较好的原因（相较于soft-attention-lstm-原论文）" class="headerlink" title=" yaya： 本文step1训练效果比较好的原因（相较于soft-attention lstm 原论文）"></a><font color="#0099ff" size="5" face="黑体"> yaya： 本文step1训练效果比较好的原因（相较于soft-attention lstm 原论文）</font></h4><p>这里step1的意思是：encoder、decoder 分开训练，并不进行联合训练</p><ol><li>该文使用的 Inception-ResNet-v2作为encoder来提取特征。会比其他论文中使用的encoder更复杂。</li><li>初始化的细节<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2ak8as8u4j309703pglo.jpg"></li><li>对SA-LSTM[2]而言，进行了一些修改：<br>（1）frame features 转为一个特征向量，使用的注意力机制，但是该文在soft-attention的基础上，还增加了一个系数β<sub>t</sub><br>（2）LSTM的内部结构的计算公式增加了一项，如下图<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2ajg7vn8rj31fi0ci427.jpg">（3）在生成word时，主要差别就是E[y<sub>t-1</sub>]前边是否有权重的问题 - soft-attention 使用的公式：<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2aeiriwanj30jd014mx7.jpg"> - 但是在本文中使用的公式为：<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g2ajjxtsplj30d103v74i.jpg">- 但是就该文3.3.2节中说：These changes are inspired by  the original code repository by Yao et al [2]，也就是有可能人家的源代码和在论文中提到的不一致。</li></ol><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1] Video captioning with  transferred semantic attributes. CVPR, 2017<br>[2] Describing videos by exploiting temporal  structure. ICCV, 2015.<br>[3] Task-driven dynamic fusion: Reducing ambiguity in video description. CVPR, 2017.<br>[4] Show and  tell: Lessons learned from the 2015 mscoco image captioning challenge. TPAMI, 2016.<br>[5] Inception-v4, inception-resnet and the impact of residual  connections on learning. AAAI, 2017</p>]]></content>
      
      
      <categories>
          
          <category> 视频描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 关于list的操作</title>
      <link href="/2019/04/18/python-%E5%85%B3%E4%BA%8Elist%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/04/18/python-%E5%85%B3%E4%BA%8Elist%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="list-的置换"><a href="#list-的置换" class="headerlink" title="list 的置换"></a>list 的置换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">nums[<span class="number">0</span>],nums[<span class="number">1</span>] = nums[<span class="number">1</span>],nums[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># nums = [2,1,3]</span></span><br></pre></td></tr></table></figure><h3 id="判断是否为空列表"><a href="#判断是否为空列表" class="headerlink" title="判断是否为空列表"></a>判断是否为空列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> a:</span><br><span class="line">    print(<span class="string">"a is a null list"</span>)</span><br><span class="line"><span class="comment"># 输出：a is a null list</span></span><br></pre></td></tr></table></figure><h3 id="列表的连接"><a href="#列表的连接" class="headerlink" title="列表的连接"></a>列表的连接</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">c = a + b</span><br><span class="line">print(c)  <span class="comment"># [1, 2, 3, 6, 7, 8]</span></span><br><span class="line">d = a.extend(b)  <span class="comment"># extend()传入的参数需要是一个迭代对象 ：列表、元组、集合</span></span><br><span class="line">print(d) </span><br><span class="line"><span class="comment"># d 输出为None ,因为extend 无返回值，但是此时 a更改为[1, 2, 3, 6, 7, 8]</span></span><br></pre></td></tr></table></figure><h3 id="列表的排序函数"><a href="#列表的排序函数" class="headerlink" title="列表的排序函数"></a>列表的排序函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [2,4,6,5]</span><br><span class="line">b = a.sort()  # a = [2,4,5,6] , b = None</span><br><span class="line">a= [2,4,6,5]  </span><br><span class="line">b = sorted(a)  # a = [2, 4, 6, 5] , b = [2, 4, 5, 6]</span><br><span class="line"></span><br><span class="line">## sorted() 输出的是排序的结果，但是不更改传入的列表</span><br><span class="line">## sort() 直接对列表进行排序操作，并更改列表值</span><br></pre></td></tr></table></figure><h3 id="列表的置换顺序函数"><a href="#列表的置换顺序函数" class="headerlink" title="列表的置换顺序函数"></a>列表的置换顺序函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">b = a.reverse() <span class="comment"># a=[4,3,2,1] b = None</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于列表 nums<br>凡是可以进行 nums.function()，这样的函数，一般是无返回值的，直接对列表本身进行操作。<br>比如 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">nums.extend([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])     <span class="comment"># [1, 2, 3, 4, 1, 2, 3]</span></span><br><span class="line">nums.append(<span class="number">2</span>)           <span class="comment"># [1, 2, 3, 4, 1, 2, 3, 2]</span></span><br><span class="line">nums.sort()              <span class="comment"># [1, 1, 2, 2, 2, 3, 3, 4]</span></span><br><span class="line">nums.reverse()           <span class="comment"># [4, 3, 3, 2, 2, 2, 1, 1]</span></span><br><span class="line">nums.insert(<span class="number">5</span>,<span class="number">100</span>)       <span class="comment"># [4, 3, 3, 2, 2, 100, 2, 1, 1]    在索引为5的位置插入元素100</span></span><br></pre></td></tr></table></figure><ul><li>注意<br>nums.index(100)          # <strong>有返回值5</strong>, 查找对应元素<strong>首次出现</strong>所在位置的索引</li></ul><h3 id="数字转为列表-123-gt-“1”-“2”-“3”"><a href="#数字转为列表-123-gt-“1”-“2”-“3”" class="headerlink" title="数字转为列表  123 -&gt; [“1”, “2”, “3”]"></a>数字转为列表  123 -&gt; [“1”, “2”, “3”]</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">123</span></span><br><span class="line">A = list(str(num))  <span class="comment"># A = ['1', '2', '3']</span></span><br><span class="line">B = int(<span class="string">""</span>.join(A))  <span class="comment"># B = 123</span></span><br></pre></td></tr></table></figure><h3 id="中括号-for循环生成列表，，并使用判断"><a href="#中括号-for循环生成列表，，并使用判断" class="headerlink" title="中括号 for循环生成列表，，并使用判断"></a>中括号 for循环生成列表，，并使用判断</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">-7</span>,<span class="number">0</span>,]</span><br><span class="line">a = [<span class="number">1</span> <span class="keyword">if</span> num &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> num <span class="keyword">in</span> nums]</span><br><span class="line">print(a)   <span class="comment"># [1, 1, 0, 0]</span></span><br></pre></td></tr></table></figure><h2 id="python内置函数的复杂度"><a href="#python内置函数的复杂度" class="headerlink" title="python内置函数的复杂度"></a>python内置函数的复杂度</h2><p><a href="https://wiki.python.org/moin/TimeComplexity" target="_blank" rel="noopener">https://wiki.python.org/moin/TimeComplexity</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针(two pointers)</title>
      <link href="/2019/04/18/%E5%8F%8C%E6%8C%87%E9%92%88-two-pointers/"/>
      <url>/2019/04/18/%E5%8F%8C%E6%8C%87%E9%92%88-two-pointers/</url>
      
        <content type="html"><![CDATA[<ul><li>荷兰分区问题<br>可参考 <a href="https://blog.csdn.net/sylar_d/article/details/52742598" target="_blank" rel="noopener">https://blog.csdn.net/sylar_d/article/details/52742598</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pytorch0.4.0学习</title>
      <link href="/2019/04/18/pytorch0-4-0%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/04/18/pytorch0-4-0%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="不会的"><a href="#不会的" class="headerlink" title="不会的"></a>不会的</h2><ol><li>SGD 、 Adam中 的weight_decay 是干嘛的</li><li>SGD 中的 momentum是干嘛的，一般设置为多大</li><li>pytorch 中的初始化函数 </li><li>y = y.permute(0, 2, 1).contiguous()<br>这是干嘛的</li></ol><h3 id="学会的"><a href="#学会的" class="headerlink" title="学会的"></a>学会的</h3><ul><li>累加loss<br>以前（0.3.0）了累加loss(为了看loss的大小)一般是用total_loss+=loss.data[0] , 比较诡异的是, 为啥是.data[0]? 这是因为, 这是因为loss是一个Variable,<br>所以以后累加loss, 用loss.item().这个是必须的, 如果直接加, 那么随着训练的进行, 会导致后来的loss具有非常大的graph, 可能会超内存.<br>然而total_loss只是用来看的, 所以没必要进行维持这个graph!</li></ul><h3 id="pytorch-中-对tensor的一些函数"><a href="#pytorch-中-对tensor的一些函数" class="headerlink" title="pytorch 中 对tensor的一些函数"></a>pytorch 中 对tensor的一些函数</h3><ul><li><p>生成正态分布的随机张量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = torch.randn(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)  <span class="comment"># 正态分布的随机张量</span></span><br><span class="line">a.sum()                 <span class="comment"># 对a中的元素求和</span></span><br></pre></td></tr></table></figure></li><li><p>对tensor 求最大值</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">a</span> = torch.randn(<span class="number">10</span>,<span class="number">8</span>)</span><br><span class="line">max_value, max_index = <span class="keyword">a</span>.<span class="built_in">max</span>(<span class="number">1</span>)   </span><br><span class="line"><span class="comment"># 按照维度对a求最大值 ，此处为1，即得到（10,1）的张量，</span></span><br><span class="line"><span class="comment"># 有两个返回值，第一个返回值为具体的最大值为多少，第二个返回值为该最大值所在的索引</span></span><br></pre></td></tr></table></figure></li><li><p>判断两数有多少个元素相等</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = torch.tensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">b = torch.tensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>])</span><br><span class="line">a.eq(b)   # 输出 tensor([ <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">0</span>], dtype=torch.uint8)</span><br></pre></td></tr></table></figure></li><li><p>批矩阵相乘</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 批矩阵相乘 pytorch <span class="number">0.3</span><span class="number">.0</span></span><br><span class="line">output = torch.bmm(W, x)</span><br><span class="line"></span><br><span class="line"># 批矩阵相乘 pytorch <span class="number">0.4</span><span class="number">.0</span></span><br><span class="line">a = torch.randn(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">b = torch.rand(<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">c = torch.matmul(a, b)</span><br><span class="line">print(c.shape)  # torch.Size([<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line"># 在pytorch <span class="number">0.4</span><span class="number">.0</span>中使用torch.matmul 输入的参数是两个<span class="number">3</span>d的tensor ,tensor的首个维度是batch_size</span><br></pre></td></tr></table></figure></li><li><p>tensor 两个维度转置</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># tensor 两个维度转置</span><br><span class="line">x = torch.randn(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">x = x.permute(<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">print(x.shape)  # torch.Size([<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure></li><li><p>chunk  cat </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">torch.cat(inputs, <span class="attribute">dimension</span>=0) → Tensor</span><br><span class="line"><span class="comment"># cat 是将多个tensor按照指定的维度拼接起来</span></span><br><span class="line">torch.chunk(tensor, chunks, <span class="attribute">dim</span>=0)</span><br><span class="line"><span class="comment"># chunk是将某个tensor按照指定的维度进行拆分成指定的块数</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="初始化函数"><a href="#初始化函数" class="headerlink" title="初始化函数"></a>初始化函数</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import torch.nn as nn</span><br><span class="line">self.W = nn.Conv2d(in_channels=<span class="number">512</span>, out_channels=<span class="number">1024</span>, kernel_size=(<span class="number">3</span>,<span class="number">3</span>), \</span><br><span class="line">                   padding=(<span class="number">1</span>,<span class="number">1</span>), stride=(<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">nn.init.kaiming.normal(self.W.weight)</span><br><span class="line">nn.init.kaiming.uniform(self.W.weight)</span><br><span class="line">nn.init.constant(self.W.bias, <span class="number">0</span>)</span><br><span class="line"># 输出 tensor([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划(dynamic programming)</title>
      <link href="/2019/04/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dynamic-programming/"/>
      <url>/2019/04/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dynamic-programming/</url>
      
        <content type="html"><![CDATA[<h3 id="从起始点，走到终点"><a href="#从起始点，走到终点" class="headerlink" title="从起始点，走到终点"></a>从起始点，走到终点</h3><p>（1）共有多少路径<br>（2）哪条路径最短<br>对于grid 走路，只有两种走走法，这类问题，需要：   </p><ul><li>分析最后终点的结果，是怎么得来的：是由左邻和上邻的结果，进行某种运算得来的   </li><li>先将第一行、第一列进行初始化（结合具体问题）   </li><li>分析，递推公式，并采用自底向上的方式，因此，需要先高度的想，最后终点的递推公式，在结合这个公式，分析，在初始化之后，接下来的点，如何根据初始化的值，以及递推公式来计算得到。   </li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>分治递归： 一步一步的化解为小问题，最终由小问题再反向计算各大问题。自上而下   </li><li>动态规划：也需要得到递推公式，但是需要先将小问题的值写出来（初始化阶段），再根据递推公式，写for循环   </li></ul><h3 id="对于求解任意两个节点之间的值，并求全局最优解的问题，还需要再总结"><a href="#对于求解任意两个节点之间的值，并求全局最优解的问题，还需要再总结" class="headerlink" title="对于求解任意两个节点之间的值，并求全局最优解的问题，还需要再总结"></a>对于求解任意两个节点之间的值，并求全局最优解的问题，还需要再总结</h3><ul><li><a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-subarray/</a>  </li><li><a href="https://leetcode.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-product-subarray/</a>  </li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序(sort)</title>
      <link href="/2019/04/18/%E6%8E%92%E5%BA%8F-sort/"/>
      <url>/2019/04/18/%E6%8E%92%E5%BA%8F-sort/</url>
      
        <content type="html"><![CDATA[<ul><li>快速排序与冒泡排序均是进行交换操作，使用的空间复杂度为O(1)，而插入排序的空间复杂度为O(n)</li><li>快速排序的平均时间复杂度为O(nlogn)，最坏情况复杂度为O(n^2)</li><li>冒泡排序的时间复杂度为O(n^2)</li><li>插入排序的时间复杂度为O(n^2)</li></ul><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><blockquote><p>待补充</p></blockquote><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(nums, left, right)</span>:</span></span><br><span class="line">    tmp = left</span><br><span class="line">    reference = nums[left]  <span class="comment"># 以最左端的nums[left] 作为中位数</span></span><br><span class="line">    left = left</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] &lt;= reference:</span><br><span class="line">            left = left + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] &gt; reference:</span><br><span class="line">            right = right - <span class="number">1</span></span><br><span class="line">        nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">    <span class="keyword">if</span> nums[left] &lt; reference:</span><br><span class="line">        nums[left], nums[tmp] = nums[tmp], nums[left]</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        nums[left<span class="number">-1</span>], nums[tmp] = nums[tmp], nums[left<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> left<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">QuickSort</span><span class="params">(nums , left, right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; right:</span><br><span class="line">        index = partition(nums, left, right)</span><br><span class="line">        QuickSort(nums, left, index<span class="number">-1</span>)</span><br><span class="line">        QuickSort(nums, index+<span class="number">1</span>, right)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment"># nums = [1,2,3,4]</span></span><br><span class="line"><span class="comment"># nums = [3,2,5,6,4,4,4,5,6]</span></span><br><span class="line">left = <span class="number">0</span></span><br><span class="line">right = len(nums)<span class="number">-1</span></span><br><span class="line">QuickSort(nums, left, right)</span><br><span class="line">print(nums)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2019/04/18/%E7%AE%97%E6%B3%95/"/>
      <url>/2019/04/18/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ul><li><p><a href="https://blog.csdn.net/v_JULY_v/article/details/19131887" target="_blank" rel="noopener">别人的博客</a></p></li><li><p><a href="https://shiyaya.github.io/2019/04/18/%E5%8F%8C%E6%8C%87%E9%92%88-two-pointers/" target="_blank" rel="noopener">双指针</a></p></li><li><p><a href="https://shiyaya.github.io/2019/04/18/%E6%8E%92%E5%BA%8F-sort/" target="_blank" rel="noopener">排序</a></p></li><li><p><a href="https://shiyaya.github.io/2019/04/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dynamic-programming/" target="_blank" rel="noopener">动态规划</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 函数</title>
      <link href="/2019/04/10/python-%E5%87%BD%E6%95%B0/"/>
      <url>/2019/04/10/python-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>numpy广播</title>
      <link href="/2019/04/09/numpy%E5%B9%BF%E6%92%AD/"/>
      <url>/2019/04/09/numpy%E5%B9%BF%E6%92%AD/</url>
      
        <content type="html"><![CDATA[<ul><li>末尾有彩蛋</li></ul><h1 id="NumPy-广播-Broadcast"><a href="#NumPy-广播-Broadcast" class="headerlink" title="NumPy 广播(Broadcast)"></a>NumPy 广播(Broadcast)</h1><p>广播(Broadcast)是 numpy 对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。</p><p>如果两个数组 a 和 b 形状相同，即满足 <strong>a.shape == b.shape</strong>，那么 a*b 的结果就是 a 与 b 数组对应位相乘。这要求维数相同，且各维度的长度相同。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>import numpy as np    a = np.array([1,2,3,4])  b = np.array([10,20,30,40])  c = a * b  print (c)</p><p>输出结果为：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="number">10</span>  <span class="number">40</span>  <span class="number">90</span> <span class="number">160</span>]</span><br></pre></td></tr></table></figure><p>当运算中的 2 个数组的形状不同时，numpy 将自动触发广播机制。如：</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np    </span><br><span class="line">a = np.array([[ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],            [<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>],            [<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>],            [<span class="number">30</span>,<span class="number">30</span>,<span class="number">30</span>]]) </span><br><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) print(a + b)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[ <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [<span class="number">11</span> <span class="number">12</span> <span class="number">13</span>]</span><br><span class="line"> [<span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]</span><br><span class="line"> [<span class="number">31</span> <span class="number">32</span> <span class="number">33</span>]]</span><br></pre></td></tr></table></figure><p>下面的图片展示了数组 b 如何通过广播来与数组 a 兼容。</p><p><img src="http://www.runoob.com/wp-content/uploads/2018/10/image0020619.gif" alt="img"></p><p>4x3 的二维数组与长为 3 的一维数组相加，等效于把数组 b 在二维上重复 4 次再运算。</p><h2 id="yayay实例"><a href="#yayay实例" class="headerlink" title="yayay实例"></a>yayay实例</h2><p>在few-shot gnn任务中，想要计算邻接矩阵A，其公式为：<strong>a<sub>ij</sub> = fc(v<sub>i</sub>-v<sub>j</sub>)</strong><br>那么问题来了得到的邻接矩阵是N×N的，则计算的差值矩阵也应该是N×N的。那么该如何高效的计算出来这个差值矩阵。</p><pre><code class="python"><span class="keyword">import</span> numpy <span class="keyword">as</span> npN = <span class="number">10</span>D = <span class="number">7</span>X = np.ones((N,D))X1 = np.expand_dims(X, axis=<span class="number">0</span>)X2 = np.expand_dims(X, axis=<span class="number">1</span>)X_abs = np.abs(X1-X2)X_abs = np.reshape(X_abs, (N,N,D))X_T = X_abs ?????????????????需要考虑一下这个转置问题</code></pre>]]></content>
      
      
      <categories>
          
          <category> numpy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>少样本学习(few-shot learning)</title>
      <link href="/2019/04/09/%E5%B0%91%E6%A0%B7%E6%9C%AC%E5%AD%A6%E4%B9%A0-few-shot-learning/"/>
      <url>/2019/04/09/%E5%B0%91%E6%A0%B7%E6%9C%AC%E5%AD%A6%E4%B9%A0-few-shot-learning/</url>
      
        <content type="html"><![CDATA[<h2 id="小样本学习的概念"><a href="#小样本学习的概念" class="headerlink" title="小样本学习的概念"></a>小样本学习的概念</h2><ul><li>少样本学习(few-shot learning)的目标是在<strong>已知类别(Seen Class)训练一个分类模型，使它能够在只有少量数据的未知类别(Unseen Class)上面具有很好的泛化性能</strong>。</li><li>少样本学习面临两个重要的问题：<br>（1）已知类别和未知类别之间没有交集，导致它们的数据分布差别很大，不能直接通过训练分类器和微调(finetune)的方式得到很好的性能；<br>（2）未知类别只有极少量数据(每个类别1或者5个训练样本)，导致分类器学习不可靠。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>指数加权平均</title>
      <link href="/2019/04/09/%E6%8C%87%E6%95%B0%E5%8A%A0%E6%9D%83%E5%B9%B3%E5%9D%87/"/>
      <url>/2019/04/09/%E6%8C%87%E6%95%B0%E5%8A%A0%E6%9D%83%E5%B9%B3%E5%9D%87/</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="https://zhuanlan.zhihu.com/p/29895933" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29895933</a><br><a href="https://www.jianshu.com/p/41218cb5e099" target="_blank" rel="noopener">https://www.jianshu.com/p/41218cb5e099</a></p><h2 id="指数加权平均"><a href="#指数加权平均" class="headerlink" title="指数加权平均"></a>指数加权平均</h2><p><strong>v<sub>t</sub></strong> 是要代替  θ_t  的估计值，代表第t天的指数平均温度值<br><strong>θ<sub>t</sub></strong> 代表第t天的实际温度值<br><strong>β</strong> 代表可调节的超参数值  </p><p>则第t天的指数平均温度，可用如下公式表示<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1wnugwmkrj30ne0ggjsp.jpg" width="50%" height="50%">    </p><p>将<strong>v<sub>100</sub></strong> 展开可得:<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1wonisescj30j201o0sr.jpg"><br>v<sub>t</sub> 是对每天温度的加权平均，之所以称之为指数加权，是因为加权系数是随着时间以指数形式递减的，<strong>时间越靠近，权重越大</strong>，越靠前，权重越小。</p><p><img src="https://upload-images.jianshu.io/upload_images/1667471-485da343fbd96353.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/665/format/webp" alt><br>再来看下面三种情况：</p><p>当 β = 0.9 时，指数加权平均最后的结果如图<strong>红色线</strong>所示，代表的是最近 10 天的平均温度值；<br>当 β = 0.98 时，指结果如图<strong>绿色线</strong>所示，代表的是最近 50 天的平均温度值；<br>当 β = 0.5 时，结果如下图<strong>黄色线</strong>所示，代表的是最近 2 天的平均温度值；</p><p><img src="//upload-images.jianshu.io/upload_images/1667471-7d82e7b89e860299.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/473/format/webp" alt></p><p><img src="//upload-images.jianshu.io/upload_images/1667471-6fd989467bcb6121.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/475/format/webp" alt></p><p><strong>β 越小，噪音越多</strong>，虽然能够很快的适应温度的变化，但是更容易出现奇异值。</p><p><strong>β 越大，得到的曲线越平坦</strong>，因为多平均了几天的温度，这个曲线的波动更小。<br>但有个缺点是，因为只有 0.02 的权重给了当天的值，而之前的数值权重占了 0.98 ，<br>曲线进一步右移，在温度变化时就会适应地更缓慢一些，会出现一定延迟。</p><p>通过上面的内容可知，β 也是一个很重要的超参数，不同的值有不同的效果，需要调节来达到最佳效果，<strong>一般 0.9 的效果就很好</strong>。</p><p>作者：不会停的蜗牛<br>链接：<a href="https://www.jianshu.com/p/41218cb5e099" target="_blank" rel="noopener">https://www.jianshu.com/p/41218cb5e099</a><br>来源：简书  </p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>我们可以看到指数加权平均的求解过程实际上是一个递推的过程，那么这样就会有一个非常大的好处，每当我要求从0到某一时刻（n）的平均值的时候，我并不需要像普通求解平均值的作为，保留所有的时刻值，类和然后除以n。</p><p>而是只需要保留0-(n-1)时刻的平均值和n时刻的温度值即可。也就是每次只需要保留常数值，然后进行运算即可，这对于深度学习中的海量数据来说，是一个很好的减少内存和空间的做法。</p><h2 id="为什么在优化算法中使用指数加权平均"><a href="#为什么在优化算法中使用指数加权平均" class="headerlink" title="为什么在优化算法中使用指数加权平均"></a>为什么在优化算法中使用指数加权平均</h2><p>上面提到了一些 指数加权平均 的应用，这里我们着重看一下在优化算法中的作用。</p><p>以 Momentum 梯度下降法为例，</p><p><strong>Momentum 梯度下降法</strong>，就是计算了梯度的指数加权平均数，并以此来更新权重，它的运行<strong>速度几乎总是快于标准的梯度下降算法</strong>。</p><p><strong>这是为什么呢？</strong></p><p>让我们来看一下这个图，</p><p><img src="//upload-images.jianshu.io/upload_images/1667471-07d825d3e2624537.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/745/format/webp" alt></p><p>例如这就是我们要优化的成本函数的形状，图中红点就代表我们要达到的最小值的位置，<br>假设我们<strong>从左下角这里出发开始用梯度下降法</strong>，那么蓝色曲线就是一步一步迭代，一步一步向最小值靠近的轨迹。</p><p>可以看出<strong>这种上下波动，减慢了梯度下降法的速度</strong>，而且无法使用更大的学习率，因为如果用较大的学习率，可能会偏离函数的范围。</p><p>如果有一种方法，可以使得在纵轴上，学习得慢一点，减少这些摆动，但是在横轴上，学习得快一些，快速地从左向右移移向红点最小值，那么训练的速度就可以加快很多。</p><p>这个方法就是动量 Momentum 梯度下降法，它<strong>在每次计算梯度的迭代中，对 dw 和 db 使用了指数加权平均法的思想</strong>，</p><p><img src="//upload-images.jianshu.io/upload_images/1667471-eedf9342a4bce813.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/272/format/webp" alt></p><p>这样我们就可以得到如图红色线的轨迹：</p><p><img src="//upload-images.jianshu.io/upload_images/1667471-f9e70b57daae0359.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/718/format/webp" alt></p><p>可以看到：<br><strong>纵轴方向</strong>，平均过程中正负摆动相互抵消，平均值接近于零，摆动变小，学习放慢。<br><strong>横轴方向</strong>，因为所有的微分都指向横轴方向，因此平均值仍然较大，向最小值运动更快了。<br>在抵达最小值的路上减少了摆动，加快了训练速度。</p><p>作者：不会停的蜗牛<br>链接：<a href="https://www.jianshu.com/p/41218cb5e099" target="_blank" rel="noopener">https://www.jianshu.com/p/41218cb5e099</a><br>来源：简书  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>模型剪枝 Model Pruning</title>
      <link href="/2019/04/09/%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D-Model-Pruning/"/>
      <url>/2019/04/09/%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D-Model-Pruning/</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="https://xmfbit.github.io/2018/10/03/paper-summary-model-pruning/" target="_blank" rel="noopener">https://xmfbit.github.io/2018/10/03/paper-summary-model-pruning/</a><br>L1正则化项，加入损失函数中，可以对特征进行选择。<br>L1也可以应用到模型压缩任务中，选择某个filter是否有存在的必要，从而决定是否要剪掉。</p>]]></content>
      
      
      <categories>
          
          <category> 模型压缩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模型压缩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频分类总结</title>
      <link href="/2019/04/09/%E8%A7%86%E9%A2%91%E5%88%86%E7%B1%BB%E6%80%BB%E7%BB%93/"/>
      <url>/2019/04/09/%E8%A7%86%E9%A2%91%E5%88%86%E7%B1%BB%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="Two-Stream"><a href="#Two-Stream" class="headerlink" title="Two-Stream"></a>Two-Stream</h3><ul><li>训练<br>（1）spatial net：每个video中随机提取1帧：224<em>224</em>3，进行训练，<br>（2）temporal net：每个video中选取L=10帧光流，224<em>224</em>2L，进行训练<br>由于含有x,y 方向，因此10帧光流，对应的5帧图像，该5帧是连续的</li><li>测试：每个video中平均采25帧，并通过crop and flip等操作扩增10倍，整个video的得分，是这250帧的平均得分。</li></ul><h3 id="TSN"><a href="#TSN" class="headerlink" title="TSN"></a>TSN</h3><ul><li>训练，将video分段，默认为3段<br>（1）spatial net：每个video分成N段，每段随机提取1帧，则得到N帧，这N帧共享参数，一起训练，N帧分别得到的score进行平均，作为video的分数，并反向传播，训练。<br>（2）temporal net ,同理，每个video分成N段，每段随机提取L=10帧，这N段共享参数，一起训练，N段分别得到的score进行平均，作为video的分数，并反向传播，训练。</li><li>测试，将video分段，默认为25段</li><li>同训练过程</li></ul><h3 id="C3D"><a href="#C3D" class="headerlink" title="C3D"></a>C3D</h3><ul><li>在Sports-1M上进行训练，训练完成之后便得到一个video feature extractor </li><li>训练：在每个video中随机剪切5个2s长的clip，对clip进行训练 </li><li>测试：对于一个video，含有N帧，则将这N帧分成16帧的clips，每相邻的两个clips重叠8帧，然后将这些clips得到的fc6 activations 进行<strong>平均得到video feature</strong>，进而送入分类层得到video class label</li></ul><h3 id="I3D"><a href="#I3D" class="headerlink" title="I3D"></a>I3D</h3><ul><li>video 以25帧/秒的帧率来提取关键帧</li><li>训练：以64帧组成的snippets进行训练。</li><li>测试：同样以64帧组成的snippets进行测试，但是对于该video上的所有的snippet的<strong>预测结果进行取平均</strong>作为该video的预测结果</li></ul>]]></content>
      
      
      <categories>
          
          <category> 行为识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I3D</title>
      <link href="/2019/04/09/I3D/"/>
      <url>/2019/04/09/I3D/</url>
      
        <content type="html"><![CDATA[<ul><li>参考:<a href="https://zhuanlan.zhihu.com/p/34919655" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34919655</a></li></ul><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1wgkib11aj310b0ew77m.jpg">  <h3 id="训练和预测"><a href="#训练和预测" class="headerlink" title="训练和预测"></a>训练和预测</h3><ul><li>写在前面，方便看，哈哈哈哈</li><li>video 以25帧/秒的帧率来提取关键帧</li><li>在训练时，以64帧组成的snippets进行训练。</li><li>在测试时，同样以64帧组成的snippets进行测试，但是对于该video上的所有的snippet的预测结果进行取平均作为该video的预测结果</li></ul><h3 id="方法1：ConvNet-LSTM"><a href="#方法1：ConvNet-LSTM" class="headerlink" title="方法1：ConvNet+LSTM"></a><strong>方法1：ConvNet+LSTM</strong></h3><ul><li>该方案主要考虑到cnn在图像分类领域的成功以及LSTM对于序列建模的能力，很自然提出将两者结合起来的方案。如果只是用cnn的话，需要对每一帧都提取特征，然后将视频的所有帧特征进行总汇，以此来表达对视频的表示，显然这样做忽略的时间结构特征。而LSTM可以处理长时间依赖的问题，可以对视频从第一帧开始建模直到最后一帧，使用cnn网络对每帧提取特征，然后将特征送入LSTM来捕捉时间特征，最后一帧的输出用来对视频特征表示。<br>  LSTM往往依赖cnn的最后一层特征最为输入，因此不能够捕捉到<code>low-level motion</code>的特征，而且对于遍历整个视频也很难去训练。<h3 id="方法2：3D-ConvNets"><a href="#方法2：3D-ConvNets" class="headerlink" title="方法2：3D ConvNets"></a><strong>方法2：3D ConvNets</strong></h3></li><li><code>3D ConvNets</code>是对视频建模最自然的方式，和标准cnn区别在于由<code>2d conv</code>变为<code>3d conv</code>，来捕捉<code>spatio-temporal feature</code>。想法很好，但目前遇到一些问题，问题一：<code>3D ConvNets</code>的<code>3d conv</code>多了一个维度，参数量有较大增加，这将会很难去训练。问题二：没有利用那些Imagenet上成功的预训练模型来迁移学习，往往使用层数少的cnn在小数据集上从头训练。简要说就是要利用已有预训练模型，要减少参数或增大数据集。<br>  论文中实现了C3D（与原版略有差异）有8 conv layer、5 pooling layer 和 2 fc layer，并在所有圈卷积层和fc层加bn。输入是16×112×112（通过crop方法），将第一个pooling layer对时间的stride由1变成2，为了可以减少memory和允许更大batch。<h3 id="方法3：Two-Stream-Networks"><a href="#方法3：Two-Stream-Networks" class="headerlink" title="方法3：Two-Stream Networks"></a><strong>方法3：Two-Stream Networks</strong></h3></li><li>该方案利用短的视频段来建模，用每个clip的预测分数平均的方式（其实C3D也是类似），但不同的是输入，包括一张RGB和10张<code>optical flow</code>(其实是5张，x/y两个方向，运动特征)。模型能使用<code>two-branch</code>方式，利用预训练的imagenet模型，最后将预测结果平均下（最原始的，或者在最后softmax做融合），这样建模的模型比较好训练，同时也能获得更高的分数。  </li><li>模型的两个输入流也可以在后面的cnn层来进行融合，以提升相同，同时可以<code>end-to-end</code>训练。论文实现一个类似的two-stream方案，在最后一层用<code>3d conv</code>将spatial和flow特征进行融合。<h3 id="方法4：Two-Stream-Inflated-3D-ConvNets"><a href="#方法4：Two-Stream-Inflated-3D-ConvNets" class="headerlink" title="方法4：Two-Stream Inflated 3D ConvNets"></a><strong>方法4：Two-Stream Inflated 3D ConvNets</strong></h3></li><li>该方案是论文提出的，出发点是要利用imagenet的预训练模型，同时利用<code>3d conv</code>来提取<code>RGB stream</code>的<code>temporal feature</code>，最后再利用<code>optical-flow stream</code>提升网络性能，也就大融合的方案（把有效的技巧都用上）。  </li><li>通过对预训练的<code>2D conv</code>增加temporal维度，把N×N的filter变为N×N×N。简单的办法就是对N×N的filter重复复制N遍，并归一化，这样多的出发点是短期内时间不变性的假设，姑且把这当成<code>3D filter</code>初始化的一种策略吧。  </li><li>池化操作怎么膨胀？stride怎么选？主要依赖感受野尺寸，如果图像水平方向和竖直方向相等，那么stride也相等，而且越深的特征感受野越大。但是考虑到时间因素，对称感受野不是必须的，这主要还是依赖帧率和图片大小。时间相对于空间变化过快，将合并不同object的边信息，过慢将不能捕捉场景变化。  </li><li>虽然3D conv能够捕捉motion信息，但是与光流优化的方式和效果还是不一样，因此使用<code>two-stream</code>的方式构建，并分开训练两个网络。</li></ul><p><img src="https://pic2.zhimg.com/80/v2-34f1d3ac14884d5c9114d4e9383c2e89_hd.jpg" alt></p><hr><ul><li><p>数据集不同，评测结果也不同。flow在UCF-101上效果比HMDB-51、kinetics上好（有更多camera运动的原因）。<br><img src="https://pic2.zhimg.com/80/v2-e719a0a3a022e348838d4b6a5c0b8a55_hd.jpg" alt></p></li><li><p>在imagenet上训练后迁移到kinetics和直接在kinetics上的对比，迁移后的效果好，说明RGB流起的作用大。整体上I3D模型参数更少，更深，训练输入在时间和空间维度上都比C3D大。<br><img src="https://pic3.zhimg.com/80/v2-b358535638c000de801577fc84296252_hd.jpg" alt></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 行为识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C3D</title>
      <link href="/2019/04/09/C3D/"/>
      <url>/2019/04/09/C3D/</url>
      
        <content type="html"><![CDATA[<h2 id="pytorch-中"><a href="#pytorch-中" class="headerlink" title="pytorch 中"></a>pytorch 中</h2><h3 id="Conv2d"><a href="#Conv2d" class="headerlink" title="Conv2d"></a>Conv2d</h3><p><a href="https://pytorch.org/docs/stable/nn.html#conv2d" target="_blank" rel="noopener">https://pytorch.org/docs/stable/nn.html#conv2d</a><br>the shape of input:  <font size="5," color="#0099ff">batch×channel×height×width</font></p><h2 id="Conv3d"><a href="#Conv3d" class="headerlink" title="Conv3d"></a>Conv3d</h2><p><a href="https://pytorch.org/docs/stable/nn.html#conv3d" target="_blank" rel="noopener">https://pytorch.org/docs/stable/nn.html#conv3d</a><br>the shape of input: <font size="5," color="#0099ff">batch×channel×depth×height×width</font></p><h2 id="C3D-用于行为识别-1-2"><a href="#C3D-用于行为识别-1-2" class="headerlink" title="C3D 用于行为识别[1][2]"></a>C3D 用于行为识别[1][2]</h2><p>[1] C3D 的网络结构</p><ul><li>输入： bs×3×<font size="5," color="#0099ff">16</font>×H×W，即输入一个长为16的视频序列clip， 实际是 bs×3×16×12×12</li><li>输出： bs×feature_size</li></ul><p>对于一个video，含有N帧，则将这N帧分成16帧的clips，每相邻的两个clips重叠8帧，然后将这些clips得到的fc6 activations 进行平均得到video feature，进而送入分类层得到video class label</p><h2 id="解读论文Learning-Spatio-Temporal-Features-with-3D-Residual-Networks-for-Action-Recognition"><a href="#解读论文Learning-Spatio-Temporal-Features-with-3D-Residual-Networks-for-Action-Recognition" class="headerlink" title="解读论文Learning Spatio-Temporal Features with 3D Residual Networks for Action Recognition"></a>解读论文<code>Learning Spatio-Temporal Features with 3D Residual Networks for Action Recognition</code></h2><h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><ul><li>当前行为识别的方法，参数量不能过多的原因是，现在可以用于训练的数据集较小，一旦参数量过大，使得模型过拟合</li><li>但是，现在有了kinetics 这样的大型数据集，这时，便可以提出一个参数量大的model</li></ul><h3 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h3><ul><li>生成一个用于 spatio-temporal recognition的标准预训练模型</li></ul><h3 id="关于image-size-部分的介绍"><a href="#关于image-size-部分的介绍" class="headerlink" title="关于image size 部分的介绍"></a>关于image size 部分的介绍</h3><ul><li>截取帧时，固定长宽比，并设置高为360（resneXt是240），</li></ul><h4 id="train"><a href="#train" class="headerlink" title="train"></a>train</h4><ul><li>以一个 16 连续帧组成的clip来代表 video</li><li>先以最小边为尺寸进行裁剪（裁剪为一个正方形），然后再进行resize 112</li><li>为了数据增强，这里有三个trick  (1) 最小边=min(height, weight) * sacle (2) 选取哪个区域进行裁剪，有五种选择 四个角和中心 (3)以50%的概率进行随机水平翻转</li></ul><h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><ul><li>一个video 去选择 没有重叠的所有 16 连续帧，然后对这所有的clip的得分进行取平均作为video的得分</li><li>不再进行数据增强</li><li>先按照最小边，固定长宽比进行缩放</li><li>再 中心裁剪成指定的 <code>112*112</code></li></ul><h3 id="分析-resnet34-c3d-比-rgb-i3d-差的原因"><a href="#分析-resnet34-c3d-比-rgb-i3d-差的原因" class="headerlink" title="分析 resnet34-c3d 比 rgb-i3d 差的原因"></a>分析 resnet34-c3d 比 rgb-i3d 差的原因</h3><ol><li><p>rgb-i3d 使用了64个GPU，可能他们使用的batch size 也比较大。而 resnet34-c3d 仅使用了4个GPU，256 batch size。</p></li><li><p>rgb-i3d 使用的 clip 分辨率为：3 × 64 × 224 × 224.  而 resnet34-c3d 的 clip 分辨率为 3 × 16 × 112 × 112 。    </p><p>即，i3d 使用连续的 <strong>64</strong> 帧组成一个clip，并且 image 分辨率为 <strong>224</strong>，</p><p>而， resnet c3d 使用连续的 <strong>16</strong> 帧组成一个clip，并且 image 分辨率为 <strong>112</strong>，</p></li></ol><h2 id="解读论文Can-Spatiotemporal-3D-CNNs-Retrace-the-History-of-2D-CNNs-and-ImageNet"><a href="#解读论文Can-Spatiotemporal-3D-CNNs-Retrace-the-History-of-2D-CNNs-and-ImageNet" class="headerlink" title="解读论文Can Spatiotemporal 3D CNNs Retrace the History of 2D CNNs and ImageNet?"></a>解读论文<code>Can Spatiotemporal 3D CNNs Retrace the History of 2D CNNs and ImageNet?</code></h2><h3 id="Goal-1"><a href="#Goal-1" class="headerlink" title="Goal"></a>Goal</h3><ul><li>本文的目的是为了验证当前存在的数据集是否足够支撑训练一个很深的3d网络</li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1] Learning Spatio-Temporal Features with 3D Residual Networks for Action Recognition .  ICCV 2017<br>[2] Can Spatiotemporal 3D CNNs Retrace the History of 2D CNNs and ImageNet?  CVPR 2018</p>]]></content>
      
      
      <categories>
          
          <category> 行为识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频格式</title>
      <link href="/2019/04/09/%E8%A7%86%E9%A2%91%E6%A0%BC%E5%BC%8F/"/>
      <url>/2019/04/09/%E8%A7%86%E9%A2%91%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[ <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1w907erjdj30800ffq31.jpg">  <h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><ul><li>为了更好的对视频进行传输，需要对视频进行压缩编码</li><li>当前的对video中<strong>图像</strong>的压缩方法有两大阵营，MPEG系列和H.26x系列，</li><li>得到压缩后的图像和音频之后，需要组合封装起来，这时就需要一个容器，可以使用AVI、MPEG等进行封装</li><li>最后为了将该video用系统上的某个视频播放器来开，还需要给其添加个后缀名，一般采用了某个封装格式就会有相应的后缀名，但是若我们更改某个video的文件名，也不会改变video的实质。</li><li>如在上图中视频流压缩采用的是H.26系列，但是文件类型却是mp4，即容器采用的是MPEG封装格式</li></ul><h2 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h2><p>作者：袁园<br>链接：<a href="https://www.zhihu.com/question/20997688/answer/30720197" target="_blank" rel="noopener">https://www.zhihu.com/question/20997688/answer/30720197</a><br>来源：知乎<br>在生活语境里所说的“视频格式”，在学术上有两个概念与之对应：Container format (封装格式)和Codec (暂且译为“编解码格式”)。</p><h3 id="1-Container-format-封装格式"><a href="#1-Container-format-封装格式" class="headerlink" title="1. Container format (封装格式)"></a><strong>1. Container format (封装格式)</strong></h3><p>Container format 描述了视频文件的结构。正如它的字面含义所说，它是对一个“容器”的规范。一个视频文件往往会包含图像和音频，还有一些配置信息(如图像和音频的关联，如何解码它们等)：这些内容需要按照一定的规则组织、存储起来，Container format就是这些规则。<br>如果一个视频文件是以某个Container format封装起来的，那么它的后缀名一般会体现出来。所以，后缀名只是形式，只是为了便于识别(例如，windows系统会根据文件的后缀名决定以什么程序打开它)，无决定性的意义。</p><h3 id="2-Codec-编解码格式"><a href="#2-Codec-编解码格式" class="headerlink" title="2. Codec (编解码格式)"></a><strong>2. Codec (编解码格式)</strong></h3><p>Codec是一种压缩标准。而文件的压缩/还原是通过编/解码实现的，所以Codec也可理解成编/解码标准。要知道，未经过处理的原始视频和音频文件十分巨大，不好存储、传输。为了节省磁盘空间和网络带宽，原始的视频和音频文件都会通过编码压缩体积，然后需要播放时再通过逆向过程解码还原。Codec就是规定编/解码实现细节(数字存储空间、帧速率、比特率、分辨率等)的标准，不同的标准对于压缩的质量和效率有影响。<br>世界上有两大制定这套标准的阵营：ITU-T VCEG(Visual Coding Experts Group，国际电联旗下的标准化组织)和MPEG(Moving Picture Experts Group, ISO旗下的组织)。MPEG系列标准是MPEG制定的，H.26x系列标准是ITU-T制定的。</p><h3 id="3-Container-format-封装格式-和Codec-编解码格式-有关系吗？"><a href="#3-Container-format-封装格式-和Codec-编解码格式-有关系吗？" class="headerlink" title="3. Container format (封装格式)**和Codec** (编解码格式)**有关系吗？**"></a><strong>3. Container format</strong> <strong>(封装格式)**</strong>和Codec** <strong>(编解码格式)**</strong>有关系吗？**</h3><p>不妨将视频文件看作容器(Container)，那么这个容器里盛放的就是遵循某种Codec的内容(Content)。一个容器里应该能放下视频、音频、数据信息，即使它们遵循的Codec不相同。例如，QuickTime File Format (.MOV)支持几乎所有的Codec，MPEG(.MP4)也支持相当广的Codec。所以，单从视频文件的格式是无法获知它的质量细节的，这些细节取决与采用的Codec。比较专业的说法是，“给我一个H.264 Quicktime文件(.mov)”。</p><h3 id="4-为何还是有点迷糊？"><a href="#4-为何还是有点迷糊？" class="headerlink" title="4. 为何还是有点迷糊？"></a><strong>4. 为何还是有点迷糊？</strong></h3><p>以上的解释是从学术角度出发的，在学术上区分它们没有一点障碍。但现实生活中人们不会一丝不苟地区分“Container format ”“Codec”，往往只会说“这是一个mov格式的文件”。这是将日常用语与学术术语混为一谈导致的理解混乱。</p><p>另外，Container format和Codec的命名法有点奇葩，明白人有时也会晕。例如，“MPEG-4”既是“Container format ”，也是“Codec”，这确实够烦的。</p>]]></content>
      
      
      <categories>
          
          <category> 视频处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频解码</title>
      <link href="/2019/04/09/%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81/"/>
      <url>/2019/04/09/%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<ul><li><p>opencv提取关键帧（banet）</p></li><li><p>ffmpeg提取关键帧 （video to text）</p></li><li><p>i帧、P帧、B帧</p></li><li><p>参考：<a href="https://blog.csdn.net/huangblog/article/details/8739876" target="_blank" rel="noopener">https://blog.csdn.net/huangblog/article/details/8739876</a><br>I帧，Intra-coded frame：是一张完整的图片<br>P帧，predictive frame: 记录了与之前真的差别，在解码P帧之前需要参考之前的图片帧<br>B帧，Bi-Predictive frame: 不仅需要参考之前的图片帧，还需要参考之后的图片帧，才能完整解码。<br>因此解码P帧、B帧的速度相对较慢，直接解码I帧可以获得更快的速度。</p></li></ul><p><strong>简单地讲，I帧是一个完整的画面，而P帧和B帧记录的是相对于I帧的变化。没有I帧，P帧和B帧就无法解码</strong>  </p><h3 id="GOP"><a href="#GOP" class="headerlink" title="GOP"></a>GOP</h3><p>所谓GOP，意思是画面组，一个GOP就是一组连续的画面。从一个I帧到下一个I帧之间的所有帧的组合称为一个GOP。</p><ul><li><p><strong>I帧</strong><br>I帧是参考帧，一个GOP中必须含有I帧，它是一个全帧压缩编码帧。它将全帧图像信息进行JPEG压缩编码及传输。</p></li><li><p><strong>P帧的预测与重构:</strong><br>P帧是以I帧为参考帧,在I帧中找出P帧“某点”的预测值和运动矢量,取预测差值和运动矢量一起传送。在接收端根据运动矢量从I帧中找出P帧“某点”的预测值并与差值相加以得到P帧“某点”样值,从而可得到完整的P帧。</p></li><li><p><strong>B帧的预测与重构：</strong><br>B帧以前面的I或P帧和后面的P帧为参考帧,“找出”B帧“某点”的预测值和两个运动矢量,并取预测差值和运动矢量传送。接收端根据运动矢量在两个参考帧中“找出(算出)”预测值并与差值求和,得到B帧“某点”样值,从而可得到完整的B帧。</p></li><li><p><strong>用下图中的1234567帧来表达</strong><br>首先由1：I帧，<br>再由1、4帧得到第4帧所在位置处的图像信息<br>最后由1、4、2得到第2帧所在位置处的图像信息，由1、4、3得到第3帧所在位置处的图像信息</p></li></ul><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1w7ki6x02j30ra0ge0st.jpg">  <ul><li>另外一张图  </li></ul><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1w7ki8pfvj30nm0fk77r.jpg"><hr><h3 id="视频压缩：I帧、P帧、B帧"><a href="#视频压缩：I帧、P帧、B帧" class="headerlink" title="视频压缩：I帧、P帧、B帧"></a>视频压缩：I帧、P帧、B帧</h3><ul><li>来源： <a href="https://blog.csdn.net/huangblog/article/details/8739876" target="_blank" rel="noopener">https://blog.csdn.net/huangblog/article/details/8739876</a></li></ul><p>视频压缩中，每帧代表一幅静止的图像。而在实际压缩时，会采取各种算法减少数据的容量，其中IPB就是最常见的。</p><pre><code>简单地说，I帧是关键帧，属于帧内压缩。就是和AVI的压缩是一样的。P是向前搜索的意思。B是双向搜索。他们都是基于I帧来压缩数据。</code></pre><p>   I帧表示关键帧，你可以理解为这一帧画面的完整保留；解码时只需要本帧数据就可以完成（因为包含完整画面）</p><p>   P帧表示的是这一帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是差别帧，P帧没有完整画面数据，只有与前一帧的画面差别的数据）</p><p>   B帧是双向差别帧，也就是B帧记录的是本帧与前后帧的差别（具体比较复杂，有4种情况），换言之，要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时CPU会比较累~。</p><pre><code>采用的压缩方法: 分组:把几帧图像分为一组(GOP),为防止运动变化,帧数不宜取多。    1.定义帧:将每组内各帧图像定义为三种类型,即I帧、B帧和P帧;    2.预测帧:以I帧做为基础帧,以I帧预测P帧,再由I帧和P帧预测B帧;    3.数据传输:最后将I帧数据与预测的差值信息进行存储和传输。</code></pre><p>一、I帧  </p><pre><code>I图像（帧）是靠尽可能去除图像空间冗余信息来压缩传输数据量的帧内编码图像。I帧又称为内部画面 (intra picture)，I 帧通常是每个 GOP（MPEG 所使用的一种视频压缩技术）的第一个帧，经过适度地压缩（做为随机访问的参考点）可以当成图象。在MPEG编码的过程中部分视频帧序列压缩成为I帧，部分压缩成P帧，还有部分压缩成B帧。I帧法是帧内压缩法（P、B为帧间），也称为“关键帧”压缩法。I帧法是基于离散余弦变换DCT（Discrete Cosine Transform）的压缩技术，这种算法与JPEG压缩算法类似。采用I帧压缩可达到1/6的压缩比而无明显的压缩痕迹。I帧特点：    1.它是一个全帧压缩编码帧。它将全帧图像信息进行JPEG压缩编码及传输;    2.解码时仅用I帧的数据就可重构完整图像;    3.I帧描述了图像背景和运动主体的详情;    4.I帧不需要参考其他画面而生成;    5.I帧是P帧和B帧的参考帧(其质量直接影响到同组中以后各帧的质量);    6.I帧是帧组GOP的基础帧(第一帧),在一组中只有一个I帧;    7.I帧不需要考虑运动矢量;    8.I帧所占数据的信息量比较大。I帧编码流程：    (1)进行帧内预测，决定所采用的帧内预测模式。    (2)像素值减去预测值，得到残差。    (3)对残差进行变换和量化。    (4)变长编码和算术编码。    (5)重构图像并滤波，得到的图像作为其它帧的参考帧。</code></pre><p>二、P帧</p><pre><code> P图像（帧）是通过充分降低于图像序列中前面已编码帧的时间冗余信息来压缩传输数据量的编码图像，也叫预测帧。在针对连续动态图像编码时，将连续若干幅图像分成P,B,I三种类型，P帧由在它前面的P帧或者I帧预测而来，它比较与它前面的P帧或者I帧之间的相同信息或数据，也即考虑运动的特性进行帧间压缩。P帧法是根据本帧与相邻的前一帧（I帧或P帧）的不同点来压缩本帧数据。采取P帧和I帧联合压缩的方法可达到更高的压缩且无明显的压缩痕迹。P帧的预测与重构:    P帧是以I帧为参考帧,在I帧中找出P帧“某点”的预测值和运动矢量,取预测差值和运动矢量一起传送。在接收端根据运动矢量从I帧中找出P帧“某点”的预测值并与差值相加以得到P帧“某点”样值,从而可得到完整的P帧。P帧特点：    ①P帧是I帧后面相隔1-2帧的编码帧。      ②P帧采用运动补偿的方法传送它与前面的I或P帧的差值及运动矢量（预测误差）。      ③解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧图像。      ④P帧属于前向预测的帧间编码。它只参考前面最靠近它的I帧或P帧。      ⑤P帧可以是其后面P帧的参考帧，也可以是其前后的B帧的参考帧。    ⑥由于P帧是参考帧，它可能造成解码错误的扩散。     ⑦由于是差值传送，P帧的压缩比较高。</code></pre><p>三、B帧</p><pre><code>B图像（帧）是既考虑与源图像序列前面已编码帧，也顾及源图像序列后面已编码帧之间的时间冗余信息来压缩传输数据量的编码图像，也叫双向预测帧。   B帧法是双向预测的帧间压缩算法。当把一帧压缩成B帧时，它根据相邻的前一帧、本帧以及后一帧数据的不同点来压缩本帧，也即仅记录本帧与前后帧的差值。只有采用B帧压缩才能达到200：1的高压缩。一般地，I帧压缩效率最低，P帧较高，B帧最高。B帧的预测与重构：    B帧以前面的I或P帧和后面的P帧为参考帧,“找出”B帧“某点”的预测值和两个运动矢量,并取预测差值和运动矢量传送。接收端根据运动矢量在两个参考帧中“找出(算出)”预测值并与差值求和,得到B帧“某点”样值,从而可得到完整的B帧。B帧特点：    1.B帧是由前面的I或P帧和后面的P帧来进行预测的;    2.B帧传送的是它与前面的I或P帧和后面的P帧之间的预测误差及运动矢量;    3.B帧是双向预测编码帧;    4.B帧压缩比最高,因为它只反映2参考帧间运动主体的变化情况,预测比较准确;    5.B帧不是参考帧,不会造成解码错误的扩散。 P 帧和 B 帧编码的基本流程为：    (1)进行运动估计，计算采用帧间编码模式的率失真函数(节)值。P 帧 只参考前面的帧，B 帧可参考后面的帧。    (2)进行帧内预测，选取率失真函数值最小的帧内模式与帧间模式比较，确定采用哪种编码模式。    (3)计算实际值和预测值的差值。    (4)对残差进行变换和量化。    (5)若编码，如果是帧间编码模式，编码运动矢量。注:I、B、P各帧是根据压缩算法的需要,是人为定义的,它们都是实实在在的物理帧,至于图像中的哪一帧是I帧,是随机的,一但确定了I帧,以后的各帧就严格按规定顺序排列。 </code></pre><p>四、实际应用</p><pre><code>从上面的解释看，我们知道I和P的解码算法比较简单，资源占用也比较少，I只要自己完成就行了，P呢，也只需要解码器把前一个画面缓存一下，遇到P时就使用之前缓存的画面就好了，如果视频流只有I和P，解码器可以不管后面的数据，边读边解码，线性前进，大家很舒服。但网络上的电影很多都采用了B帧，因为B帧记录的是前后帧的差别，比P帧能节约更多的空间，但这样一来，文件小了，解码器就麻烦了，因为在解码时，不仅要用之前缓存的画面，还要知道下一个I或者P的画面（也就是说要预读预解码），而且，B帧不能简单地丢掉，因为B帧其实也包含了画面信息，如果简单丢掉，并用之前的画面简单重复，就会造成画面卡（其实就是丢帧了），并且由于网络上的电影为了节约空间，往往使用相当多的B帧，B帧用的多，对不支持B帧的播放器就造成更大的困扰，画面也就越卡。一般平均来说，I的压缩率是7（跟JPG差不多），P是20，B可以达到50，可见使用B帧能节省大量空间，节省出来的空间可以用来保存多一些I帧，这样在相同码率下，可以提供更好的画质。</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python类的继承</title>
      <link href="/2019/04/08/python%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
      <url>/2019/04/08/python%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<ul><li>参考：<a href="https://www.cnblogs.com/bigberg/p/7182741.html" target="_blank" rel="noopener">https://www.cnblogs.com/bigberg/p/7182741.html</a>  </li></ul><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><h3 id="1-继承的定义"><a href="#1-继承的定义" class="headerlink" title="1. 继承的定义"></a>1. 继承的定义</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span>   <span class="comment"># 定义一个父类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span>    <span class="comment"># 父类中的方法</span></span><br><span class="line">        print(<span class="string">"person is talking...."</span>)  </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span><span class="params">(Person)</span>:</span>    <span class="comment"># 定义一个子类， 继承Person类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">walk</span><span class="params">(self)</span>:</span>      <span class="comment"># 在子类中定义其自身的方法</span></span><br><span class="line">        print(<span class="string">'is walking...'</span>)</span><br><span class="line"> </span><br><span class="line">c = Chinese()</span><br><span class="line">c.talk()      <span class="comment"># 调用继承的Person类的方法</span></span><br><span class="line">c.walk()     <span class="comment"># 调用本身的方法</span></span><br></pre></td></tr></table></figure><p>输出</p><blockquote><p>person is talking….<br>is walking…</p></blockquote><h2 id="2-构造函数的继承"><a href="#2-构造函数的继承" class="headerlink" title="2. 构造函数的继承"></a>2. 构造函数的继承</h2><p>如果我们要给实例 c 传参，我们就要使用到构造函数，那么构造函数该如何继承，同时子类中又如何定义自己的属性？</p><p>继承类的构造方法：<br>1.经典类的写法： 父类名称.<strong>init</strong>(self,参数1，参数2，…)  </p><ol start="2"><li><font color="#0059ff" size="5" face="黑体"> 新式类的写法：super(子类，self).<strong>init</strong>(参数1，参数2，….)</font></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span>  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span>  </span><br><span class="line">        self.name = name  </span><br><span class="line">        self.age = age  </span><br><span class="line">        self.weight = <span class="string">'weight'</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        print(<span class="string">"person is talking...."</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span><span class="params">(Person)</span>:</span>  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, language)</span>:</span>  <span class="comment"># 先继承，在重构  </span></span><br><span class="line">Person.__init__(self, name, age)  </span><br><span class="line"><span class="comment"># 继承父类的构造方法，也可以写成：</span></span><br><span class="line"><span class="comment"># super(Chinese,self).__init__(name,age)  </span></span><br><span class="line">        self.language = language  <span class="comment"># 定义类的本身属性  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">walk</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        print(<span class="string">'is walking...'</span>)  </span><br><span class="line">        </span><br><span class="line">c = Chinese(<span class="string">'bigberg'</span>, <span class="number">22</span>, <span class="string">'Chinese'</span>)  </span><br><span class="line">print(c.name)  </span><br><span class="line">print(c.language)</span><br><span class="line">c.talk()</span><br></pre></td></tr></table></figure><p>输出</p><blockquote><p>bigberg<br>Chinese<br>person is talking….</p></blockquote><h3 id="3-子类对父类方法的重写"><a href="#3-子类对父类方法的重写" class="headerlink" title="3.子类对父类方法的重写"></a>3.子类对父类方法的重写</h3><p>如果我们对基类/父类的方法需要修改，可以在子类中重构该方法。如下的talk()方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span>  </span><br><span class="line">        self.name = name  </span><br><span class="line">        self.age = age  </span><br><span class="line">        self.weight = <span class="string">'weight'</span>  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        print(<span class="string">"person is talking...."</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span><span class="params">(Person)</span>:</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, language)</span>:</span>  </span><br><span class="line">        Person.__init__(self, name, age)  </span><br><span class="line">        self.language = language  </span><br><span class="line">        print(self.name, self.age, self.weight, self.language)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span>  <span class="comment"># 子类 重构方法  </span></span><br><span class="line">  print(<span class="string">'%s is speaking chinese'</span> % self.name)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">walk</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        print(<span class="string">'is walking...'</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">c = Chinese(<span class="string">'bigberg'</span>, <span class="number">22</span>, <span class="string">'Chinese'</span>)  </span><br><span class="line">c.talk()</span><br></pre></td></tr></table></figure><p>输出</p><blockquote><p>bigberg 22 weight Chinese<br>bigberg is speaking chinese</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谱聚类</title>
      <link href="/2019/04/08/%E8%B0%B1%E8%81%9A%E7%B1%BB/"/>
      <url>/2019/04/08/%E8%B0%B1%E8%81%9A%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<ul><li><p>先占位置</p></li><li><p><a href="https://www.cnblogs.com/pinard/p/6221564.html" target="_blank" rel="noopener">参考某博客</a>  </p></li><li><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.SpectralClustering.html#sklearn.cluster.SpectralClustering" target="_blank" rel="noopener">sklearn.cluster.SpectralClustering</a></p><ul><li>References<br>Normalized cuts and image segmentation, 2000 Jianbo Shi, Jitendra Malik <a href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.160.2324" target="_blank" rel="noopener">http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.160.2324</a><br>A Tutorial on Spectral Clustering, 2007 Ulrike von Luxburg <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.165.9323" target="_blank" rel="noopener">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.165.9323</a><br>Multiclass spectral clustering, 2003 Stella X. Yu, Jianbo Shi <a href="http://www1.icsi.berkeley.edu/~stellayu/publication/doc/2003kwayICCV.pdf" target="_blank" rel="noopener">http://www1.icsi.berkeley.edu/~stellayu/publication/doc/2003kwayICCV.pdf</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图卷积网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图卷积网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spectral Networks and Deep Locally Connected Networks on Graphs</title>
      <link href="/2019/04/08/Spectral-Networks-and-Deep-Locally-Connected-Networks-on-Graphs/"/>
      <url>/2019/04/08/Spectral-Networks-and-Deep-Locally-Connected-Networks-on-Graphs/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>(SCST)Self-critical Sequence Training for Image Captioning</title>
      <link href="/2019/04/08/SCST-Self-critical-Sequence-Training-for-Image-Captioning/"/>
      <url>/2019/04/08/SCST-Self-critical-Sequence-Training-for-Image-Captioning/</url>
      
        <content type="html"><![CDATA[<p>强化学习中的策略梯度法可以针对那些不可微分的度量进行优化，<br>本文中，使用强化学习的方法来优化图像描述任务，将这个新的优化方法称为self-critical sequence training (SCST)。</p><p><strong>sequence models for image captioning的理想训练过程， 应该是避免 exposure bias 并且可以直接优化任务中的度量</strong></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="图像描述方面的现状"><a href="#图像描述方面的现状" class="headerlink" title="图像描述方面的现状"></a><strong>图像描述方面的现状</strong></h3><p>[1] <strong>show attend and tell</strong> 证明在caption任务中，使用attention机制是有益处的。<br>[2] <strong>Teacher-Forcing</strong> 用于文本的deep generative models 的训练方法一般是：给定上一步word的ground truth 来最大化该步生成word的最大似然，来反向传播。这个方法称为“Teacher-Forcing”  。但是这种方法导致在训练和测试时很不匹配。因为在测试时，该步生成的单词是在给定上一步预测出的单词的前提下。  </p><ul><li><p>这个exposure  bias [2]导致在测试时产生误差累积，因为模型从未暴露于其自己的预测中。<br>This exposure  bias [2], results in error accumulation during generation at  test time,<br>since the model has never been exposed to its own  predictions</p><p>一些克服exposure bias的方法[3] [4]<br>[3] <strong>Scheduled sampling</strong> 他们表明，反馈模型自己的预测，并在训练过程中缓慢地增加反馈概率p，可以显着地提高测试时间的性能。<br>[4] <strong>Professor forcing</strong> a  technique that uses adversarial training to encourage the dynamics of the recurrent network to be the same when training conditioned on ground truth previous words and when  sampling freely from the network</p></li></ul><h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><h3 id="实验结果证明"><a href="#实验结果证明" class="headerlink" title="实验结果证明"></a>实验结果证明</h3><p>we find that directly optimizing the CIDEr metric with  SCST and greedy decoding at test-time is highly effective.</p><h2 id="Image-Features"><a href="#Image-Features" class="headerlink" title="Image Features"></a>Image Features</h2><ul><li>FC Models<br>由CNN+FC得到image 的 特征向量，并送入LSTM中，来生成caption<br>但是需要注意的是仅在first step 输入该特征向量，其余步输入上一步生成的word (embedding)   </li><li>Spatial CNN features for Attention models<br>在不缩放也不裁剪图片的基础上，使用resnet-101来提取最后一个卷积层的特征，并应用apply spatially adaptive max-pooling来得到一个固定的尺寸14 × 14 × 2048。在每一个time step，attention model在这14 × 14=196个位置上计算一个<font color="#0099ff" size="6" face="黑体"> attention mask</font>（注意力系数/权重）。由这个mask 计算所有位置的加权求和，以此得到image feature。  </li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] Show, attend and tell: Neural image caption generation with visual attention. In ICML,  2015.<br>[2] Sequence level training with recurrent neural networks. ICLR, 2015.<br>[3] Scheduled sampling for sequence prediction with recurrent neural networks. In NIPS, 2015.<br>[4] Professor forcing: A  new algorithm for training recurrent networks. Neural Information Processing Systems. (NIPS) 2016.  </p>]]></content>
      
      
      <categories>
          
          <category> 图像描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像描述 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bottom-Up and Top-Down Attention for Image Captioning and Visual Question Answering</title>
      <link href="/2019/04/07/Bottom-Up-and-Top-Down-Attention-for-Image-Captioning-and-Visual-Question-Answering/"/>
      <url>/2019/04/07/Bottom-Up-and-Top-Down-Attention-for-Image-Captioning-and-Visual-Question-Answering/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在object级别上计算 attention<br><strong>bottom-up</strong>: 使用Faster R-CNN 来提取 object，并得到相对应的特征向量。<br><strong>top-down</strong>: 用来计算attention 的系数，作为bottom-up中得到的每个object feature 的权重。</p><h2 id="概括："><a href="#概括：" class="headerlink" title="概括："></a>概括：</h2><p><strong>（1）Bottom-Up</strong><br>使用Faster R-CNN 中的R-CNN来得到object feature。<br><strong>（2）Top-Down Attention</strong><br>得到了该层的隐层状态，并与object features  中的每一个<strong>v<sub>i</sub></strong>来计算一个attention 系数。<br><strong>（3）对object features 进行attention 权重求和</strong><br>得到image feature<br><strong>（4）Decoder：language LSTM</strong><br>输出预测单词</p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g19d1x7kiij30im0bvaat.jpg" style="zoom:60%">  <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14xg3jwvdj30mo0h2wfi.jpg" style="zoom:60%"><h2 id="Bottom-Up"><a href="#Bottom-Up" class="headerlink" title="Bottom-Up"></a>Bottom-Up</h2><ul><li><strong>主要介绍一下Faster R-CNN 的训练过程</strong><br>（1）首先Resnet-101 是在ImageNet上预训练的<br>（2）Faster R-CNN在MS COCO上进行预训练<br>rpn 的score classification loss，bbox regression loss<br>r-cnn 的score classification loss，bbox regression loss<br>（3）Faster R-CNN在Visual Genome上再进行预训练<br>为了得到更好的特征表达，增加一个预测属性的输出： </li><li><strong>具体的网络：</strong><br>To predict attributes for region i, we concatenate the mean  pooled convolutional feature vi with a learned embedding  of the ground-truth object class, and feed this into an additional output layer defining a softmax distribution over each  attribute class plus a ‘no attributes’ class.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 图像描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像描述 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>self.training in pytorch</title>
      <link href="/2019/04/07/self-training-in-pytorch/"/>
      <url>/2019/04/07/self-training-in-pytorch/</url>
      
        <content type="html"><![CDATA[<ul><li>代码来源于：<a href="https://zhuanlan.zhihu.com/p/26893755" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26893755</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable, Function</span><br><span class="line"></span><br><span class="line">x_train = np.array([[<span class="number">3.3</span>], [<span class="number">4.4</span>], [<span class="number">5.5</span>], [<span class="number">6.71</span>], [<span class="number">6.93</span>], [<span class="number">4.168</span>],</span><br><span class="line">                    [<span class="number">9.779</span>], [<span class="number">6.182</span>], [<span class="number">7.59</span>], [<span class="number">2.167</span>], [<span class="number">7.042</span>],</span><br><span class="line">                    [<span class="number">10.791</span>], [<span class="number">5.313</span>], [<span class="number">7.997</span>], [<span class="number">3.1</span>]], dtype=np.float32)</span><br><span class="line"></span><br><span class="line">y_train = np.array([[<span class="number">1.7</span>], [<span class="number">2.76</span>], [<span class="number">2.09</span>], [<span class="number">3.19</span>], [<span class="number">1.694</span>], [<span class="number">1.573</span>],</span><br><span class="line">                    [<span class="number">3.366</span>], [<span class="number">2.596</span>], [<span class="number">2.53</span>], [<span class="number">1.221</span>], [<span class="number">2.827</span>],</span><br><span class="line">                    [<span class="number">3.465</span>], [<span class="number">1.65</span>], [<span class="number">2.904</span>], [<span class="number">1.3</span>]], dtype=np.float32)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x_train = torch.from_numpy(x_train)</span><br><span class="line">y_train = torch.from_numpy(y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"---------------------------------------"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearRegression</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(LinearRegression, self).__init__()</span><br><span class="line">        self.linear = nn.Linear(<span class="number">1</span>, <span class="number">1</span>)  <span class="comment"># input and output is 1 dimension</span></span><br><span class="line">        print(<span class="string">"self.training: "</span> + str(self.training))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        out = self.linear(x)</span><br><span class="line">        print(<span class="string">"self.training；"</span> + str(self.training))</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">print(<span class="string">"initialize"</span>)</span><br><span class="line">model = LinearRegression()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"---------------------------------------"</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"model.eval()"</span>)</span><br><span class="line">model.eval()</span><br><span class="line">inputs = Variable(x_train)</span><br><span class="line">target = Variable(y_train)</span><br><span class="line"><span class="comment"># forward</span></span><br><span class="line">out = model(inputs) <span class="comment"># 前向传播</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"---------------------------------------"</span>)</span><br><span class="line">print(<span class="string">"model.train()"</span>)</span><br><span class="line">model.train()</span><br><span class="line">inputs = Variable(x_train)</span><br><span class="line">target = Variable(y_train)</span><br><span class="line"><span class="comment"># forward</span></span><br><span class="line">out = model(inputs) <span class="comment"># 前向传播</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tensorboard_logger</title>
      <link href="/2019/04/06/tensorboard-logger/"/>
      <url>/2019/04/06/tensorboard-logger/</url>
      
        <content type="html"><![CDATA[<p>使用tensorboard_logger记录训练过程中的数据<br>（1）首先需要安装tensorflow</p><ul><li>可参考<a href="https://blog.csdn.net/love666666shen/article/details/77099843" target="_blank" rel="noopener">https://blog.csdn.net/love666666shen/article/details/77099843</a></li><li>不需要单独设置一个tensorflow的环境，直接pip install 一个CPU 版本的即可</li><li>pip install –ignore-installed –upgrade <a href="https://storage.googleapis.com/tensorflow/windows/cpu/tensorflow-1.1.0-cp35-cp35m-win_amd64.whl" target="_blank" rel="noopener">https://storage.googleapis.com/tensorflow/windows/cpu/tensorflow-1.1.0-cp35-cp35m-win_amd64.whl</a></li></ul><p>（2）安装tensorboard</p><ul><li>pip install tensorboard</li></ul><p>（3）No scalar data was found的解决<br>只需将cmd目录cd进入日志文件存放的目录，再加载日志文件便可解决：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e:</span><br><span class="line">cd logdir</span><br><span class="line">tensorboard <span class="attribute">--logdir</span>=E:\logdir <span class="attribute">--host</span>=127.0.0.1</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/09/05/7YODLiJAZ6aUTG4.png" alt="搜狗截图20190905112015.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> tensorboard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>range xrange np.arange np.linspace</title>
      <link href="/2019/04/05/range-xrange-np-arange-np-linspace/"/>
      <url>/2019/04/05/range-xrange-np-arange-np-linspace/</url>
      
        <content type="html"><![CDATA[<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1rmpadk75j309a07saa2.jpg"><p>python</p><ul><li>xrange 得到一个迭代器，（仅可以在python2中使用）</li><li>range 得到一个列表，（python2/python3均可）</li></ul><p>numpy</p><ul><li>numpy.arange 得到一份数组</li><li>numpy.linspace <strong>得到固定数量的等间隔数组，注意包含指定的尾部</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> numpy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>glob.glob vs os.listdir</title>
      <link href="/2019/04/05/glob-glob-vs-os-listdir/"/>
      <url>/2019/04/05/glob-glob-vs-os-listdir/</url>
      
        <content type="html"><![CDATA[<ul><li>现在想要得到某个文件夹下的一些图片，并按照顺序排列，如下图所示：  </li></ul><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1rl9d9xq9j30ia0cbjri.jpg">  <ul><li>第一种方法：（得到的frames_list是不包含路径的）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frames_list = sorted(os.listdir(video_path))</span><br></pre></td></tr></table></figure></li></ul><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1rlb8uq8aj309h0a8q2z.jpg"><ul><li>第二种方法：（得到的frames_list包含路径的）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frames_list = sorted(glob.glob(os.path.join(video_path, <span class="string">'*.jpg'</span>)))</span><br></pre></td></tr></table></figure></li></ul><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1rlbroiqmj30nt0b40u9.jpg"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>os.listdir 仅可以得到对当前路径下文件名称，但是不包含路径信息<br>glob.glob 可以得到对当前路径下文件名称，并包含路径信息</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python list sort方法</title>
      <link href="/2019/04/04/python-list-sort%E6%96%B9%E6%B3%95/"/>
      <url>/2019/04/04/python-list-sort%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><strong>sort()</strong> 函数用于对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>sort()方法语法：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.sort(<span class="attribute">cmp</span>=None, <span class="attribute">key</span>=None, <span class="attribute">reverse</span>=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li>cmp – 可选参数, 如果指定了该参数会使用该参数的方法进行排序。</li><li>key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</li><li>reverse – 排序规则，<strong>reverse = True</strong> 降序， <strong>reverse = False</strong> 升序（默认）。</li></ul><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>该方法没有返回值，但是会对列表的对象进行排序。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">video_sort_lambda = <span class="keyword">lambda</span> x: int(x[<span class="number">3</span>:<span class="number">-4</span>]) <span class="comment"># 定义一个函数对元素x进行操作，并得到一个整数Int</span></span><br><span class="line">video_root = <span class="string">"/userhome/dataset/MSVD/Video-Description-with-Spatial-Temporal-Attention/youtube"</span></span><br><span class="line">videos = sorted(os.listdir(video_root), key=video_sort_lambda) <span class="comment"># 按得到的整数，对list进行排序</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytohn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>史雅雅的收藏夹</title>
      <link href="/2019/04/04/%E5%8F%B2%E9%9B%85%E9%9B%85%E7%9A%84%E6%94%B6%E8%97%8F%E5%A4%B9/"/>
      <url>/2019/04/04/%E5%8F%B2%E9%9B%85%E9%9B%85%E7%9A%84%E6%94%B6%E8%97%8F%E5%A4%B9/</url>
      
        <content type="html"><![CDATA[<p><a href="http://pygments.org/" target="_blank" rel="noopener">http://pygments.org/</a></p><p><a href="https://202.38.95.226:7443/view.html" target="_blank" rel="noopener">https://202.38.95.226:7443/view.html</a></p><p><a href="https://aideadlin.es/?sub=ML,RO,CV,SP,NLP,DM" target="_blank" rel="noopener">https://aideadlin.es/?sub=ML,RO,CV,SP,NLP,DM</a></p><p><a href="https://yjs.ustc.edu.cn/" target="_blank" rel="noopener">https://yjs.ustc.edu.cn/</a></p><p><a href="https://www.json.cn/" target="_blank" rel="noopener">https://www.json.cn/</a></p><p><a href="https://kevinj-huang.github.io/" target="_blank" rel="noopener">https://kevinj-huang.github.io/</a></p><p><a href="https://shiyaya.github.io/" target="_blank" rel="noopener">https://shiyaya.github.io/</a></p><p><a href="https://stackedit.io/app#" target="_blank" rel="noopener">https://stackedit.io/app#</a></p><p><a href="http://jsonviewer.stack.hu/" target="_blank" rel="noopener">http://jsonviewer.stack.hu/</a></p><p><a href="http://www.nlpjob.com/" target="_blank" rel="noopener">http://www.nlpjob.com/</a></p><p><a href="https://nlp.stanford.edu/software/scenegraph-parser.shtml#Usage" target="_blank" rel="noopener">https://nlp.stanford.edu/software/scenegraph-parser.shtml#Usage</a></p><p><a href="https://paperswithcode.com/sota" target="_blank" rel="noopener">https://paperswithcode.com/sota</a></p><p><a href="https://sm.ms/" target="_blank" rel="noopener">https://sm.ms/</a></p><p><a href="http://www.arxiv-sanity.com/" target="_blank" rel="noopener">http://www.arxiv-sanity.com/</a></p><p><a href="http://www.cvpapers.com/" target="_blank" rel="noopener">http://www.cvpapers.com/</a></p><h3 id="论文搜索"><a href="#论文搜索" class="headerlink" title="论文搜索"></a>论文搜索</h3><ul><li><p><a href="https://dblp.uni-trier.de/db/" target="_blank" rel="noopener">https://dblp.uni-trier.de/db/</a></p><ul><li>（可以进行筛选，eg:nips, iccv, cvpr）; (也可以对某些作者进行查询)</li></ul></li><li><p><a href="http://openaccess.thecvf.com/menu.py" target="_blank" rel="noopener">http://openaccess.thecvf.com/menu.py</a></p></li><li><p><a href="http://actionrecognition.net/files/paper.php" target="_blank" rel="noopener">http://actionrecognition.net/files/paper.php</a></p></li><li><p><a href="http://www.aaai.org/Library/AAAI/aaai19contents.php" target="_blank" rel="noopener">http://www.aaai.org/Library/AAAI/aaai19contents.php</a></p></li><li><p><a href="https://dl.acm.org/results.cfm?within=owners.owner%3DHOSTED&amp;srt=_score&amp;query=&amp;Go.x=26&amp;Go.y=1" target="_blank" rel="noopener">https://dl.acm.org/results.cfm?within=owners.owner%3DHOSTED&amp;srt=_score&amp;query=&amp;Go.x=26&amp;Go.y=1</a></p></li></ul><h3 id="翻墙"><a href="#翻墙" class="headerlink" title="翻墙"></a>翻墙</h3><ul><li><p><a href="https://flyzyblog.com/install-ss-ssr-bbr-in-one-command/#ss" target="_blank" rel="noopener">https://flyzyblog.com/install-ss-ssr-bbr-in-one-command/#ss</a></p></li><li><p><a href="https://www.banpie.info/shadowsocks-pac-gfw/" target="_blank" rel="noopener">https://www.banpie.info/shadowsocks-pac-gfw/</a></p></li><li><p>Vultr搭建SS</p></li><li><p><a href="https://github.com/sirzdy/shadowsocks/wiki/Vultr搭建SS（VPS搭建SS）" target="_blank" rel="noopener">http://wuzhangyang.com/2019/03/06/vultr-ss/</a></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="comment">//raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</span></span><br><span class="line"></span><br><span class="line">chmod +x shadowsocks.sh</span><br><span class="line"></span><br><span class="line">./shadowsocks<span class="selector-class">.sh</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>搬瓦工</p></li><li><p>推荐：<a href="https://www.bandwagonhost.net/1967.html" target="_blank" rel="noopener">https://www.bandwagonhost.net/1967.html</a></p></li></ul><h2 id="会议搜索"><a href="#会议搜索" class="headerlink" title="会议搜索"></a>会议搜索</h2><ul><li><a href="http://www.searchconf.net/conf/searchresule/" target="_blank" rel="noopener">http://www.searchconf.net/conf/searchresule/</a></li></ul><h3 id="iccv-2019-challenge"><a href="#iccv-2019-challenge" class="headerlink" title="iccv 2019 challenge"></a>iccv 2019 challenge</h3><ul><li><a href="https://sites.google.com/site/iccv19clvllsmdc/home" target="_blank" rel="noopener">https://sites.google.com/site/iccv19clvllsmdc/home</a></li></ul><h3 id="GCN"><a href="#GCN" class="headerlink" title="GCN"></a>GCN</h3><ul><li><a href="https://github.com/rusty1s/pytorch_geometric" target="_blank" rel="noopener">https://github.com/rusty1s/pytorch_geometric</a></li></ul><p>深度学习课程</p><ul><li><a href="https://discuss.gluon.ai/c/5-category" target="_blank" rel="noopener">https://discuss.gluon.ai/c/5-category</a></li><li><a href="http://zh.d2l.ai/chapter_preface/preface.html" target="_blank" rel="noopener">http://zh.d2l.ai/chapter_preface/preface.html</a></li></ul><h3 id="tensorboard-可视化"><a href="#tensorboard-可视化" class="headerlink" title="tensorboard 可视化"></a>tensorboard 可视化</h3><ul><li><a href="https://www.aiuai.cn/aifarm646.html" target="_blank" rel="noopener">https://www.aiuai.cn/aifarm646.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytorch 减小显存消耗，优化显存使用，避免out of memory</title>
      <link href="/2019/04/03/pytorch-%E5%87%8F%E5%B0%8F%E6%98%BE%E5%AD%98%E6%B6%88%E8%80%97%EF%BC%8C%E4%BC%98%E5%8C%96%E6%98%BE%E5%AD%98%E4%BD%BF%E7%94%A8%EF%BC%8C%E9%81%BF%E5%85%8Dout-of-memory/"/>
      <url>/2019/04/03/pytorch-%E5%87%8F%E5%B0%8F%E6%98%BE%E5%AD%98%E6%B6%88%E8%80%97%EF%BC%8C%E4%BC%98%E5%8C%96%E6%98%BE%E5%AD%98%E4%BD%BF%E7%94%A8%EF%BC%8C%E9%81%BF%E5%85%8Dout-of-memory/</url>
      
        <content type="html"><![CDATA[<h3 id="本文是整理了大神的两篇博客："><a href="#本文是整理了大神的两篇博客：" class="headerlink" title="本文是整理了大神的两篇博客："></a>本文是整理了大神的两篇博客：</h3><ul><li><p>如何计算模型以及中间变量的显存占用大小：<br><a href="https://oldpan.me/archives/how-to-calculate-gpu-memory" target="_blank" rel="noopener">https://oldpan.me/archives/how-to-calculate-gpu-memory</a></p></li><li><p>如何在Pytorch中精细化利用显存：<br><a href="https://oldpan.me/archives/how-to-use-memory-pytorch" target="_blank" rel="noopener">https://oldpan.me/archives/how-to-use-memory-pytorch</a></p></li><li><p>还有知乎中大神的解答：<br><a href="https://zhuanlan.zhihu.com/p/31558973" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31558973</a></p></li><li><p>ppt<br><a href="https://www.zhihu.com/question/67209417" target="_blank" rel="noopener">https://www.zhihu.com/question/67209417</a></p></li><li><p>在说之前先推荐一个实时监控内存显存使用的小工具：</p></li></ul><blockquote><p>sudo apt-get install htop</p></blockquote><ul><li>监控内存（-d为更新频率，下为每0.1s更新一次）：</li></ul><blockquote><p>htop -d=0.1</p></blockquote><ul><li>监控显存（-n为更新频率，下为每0.1s更新一次）：</li></ul><blockquote><p>watch -n 0.1 nvidia-smi</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>torch.backends.cudnn.benchmark = true 使用情形</title>
      <link href="/2019/04/03/torch-backends-cudnn-benchmark-true-%E4%BD%BF%E7%94%A8%E6%83%85%E5%BD%A2/"/>
      <url>/2019/04/03/torch-backends-cudnn-benchmark-true-%E4%BD%BF%E7%94%A8%E6%83%85%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.pytorchtutorial.com/when-should-we-set-cudnn-benchmark-to-true/" target="_blank" rel="noopener">pytorch-torch.backends.cudnn.benchmark文档</a></p><ul><li>torch.backends.cudnn.benchmark<br>设置这个 flag 可以让内置的 cuDNN 的 auto-tuner 自动寻找最适合当前配置的高效算法，来达到优化运行效率的问题。</li></ul><p>应该遵循以下准则：</p><ul><li>如果网络的输入数据维度或类型上变化不大，设置  torch.backends.cudnn.benchmark = true  可以增加运行效率；</li><li>如果网络的输入数据在每次 iteration 都变化的话，会导致 cnDNN 每次都会去寻找一遍最优配置，这样反而会降低运行效率。</li><li>在程序刚开始加这条语句可以提升一点训练速度，没什么额外开销。</li><li>有时候可能是因为每次迭代都会引入点临时变量，会导致训练速度越来越慢，基本呈线性增长。<br>开发人员还不清楚原因，但如果周期性的使用torch.cuda.empty_cache()的话就可以解决这个问题。这个命令是清除没用的临时变量的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题经验</title>
      <link href="/2019/04/02/%E5%88%B7%E9%A2%98%E7%BB%8F%E9%AA%8C/"/>
      <url>/2019/04/02/%E5%88%B7%E9%A2%98%E7%BB%8F%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="输入输出的部分，需要注意："><a href="#输入输出的部分，需要注意：" class="headerlink" title="输入输出的部分，需要注意："></a>输入输出的部分，需要注意：</h3><ul><li>输出的地方，需要看人家是否<strong>保留固定的位数</strong>，否则输出的结果也是错误的</li></ul>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stanford Scene Graph Parser</title>
      <link href="/2019/03/26/Stanford-Scene-Graph-Parser/"/>
      <url>/2019/03/26/Stanford-Scene-Graph-Parser/</url>
      
        <content type="html"><![CDATA[<ul><li>官网：<a href="https://nlp.stanford.edu/software/scenegraph-parser.shtml#Usage" target="_blank" rel="noopener">https://nlp.stanford.edu/software/scenegraph-parser.shtml#Usage</a></li></ul><h2 id="下载相应的文件（官网有）"><a href="#下载相应的文件（官网有）" class="headerlink" title="下载相应的文件（官网有）"></a>下载相应的文件（官网有）</h2><ul><li>stanford-corenlp-full-2015-12-09.zip</li><li>scenegraph-1.0.jar<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2></li></ul><ol><li>将stanford-corenlp-full-2015-12-09.zip解压，然后按照博客<a href="https://shiyaya.github.io/2019/03/26/ubuntu-%E5%AE%89%E8%A3%85-Stanford-CoreNLP/" target="_blank" rel="noopener">ubuntu 安装 Stanford CoreNLP</a>来安装corenlp</li><li>需要将 scenegraph-1.0.jar 放入解压之后的文件夹stanford-corenlp-full-2015-12-09中，</li></ol><ul><li><p>需要注意版本</p></li><li><p>java  idk 1.8+ 按照博客来就可以</p></li><li><p>corenlp 使用人家给定的2015的，不要升级</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -mx2g -cp <span class="string">"*"</span> edu.stanford.nlp.scenegraph.RuleBasedParser</span><br></pre></td></tr></table></figure></li><li><p>注意该命令是在stanford-corenlp-full-2015-12-09文件夹下执行的<br>该方法是交互式的，提示你输入句子，他给出相对应的解析出的scene graph</p></li></ul><p>法2：</p>]]></content>
      
      
      <categories>
          
          <category> 自然语言理解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自然语言理解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu 安装 Stanford CoreNLP</title>
      <link href="/2019/03/26/ubuntu-%E5%AE%89%E8%A3%85-Stanford-CoreNLP/"/>
      <url>/2019/03/26/ubuntu-%E5%AE%89%E8%A3%85-Stanford-CoreNLP/</url>
      
        <content type="html"><![CDATA[<h3 id="安装java-jdk"><a href="#安装java-jdk" class="headerlink" title="安装java jdk"></a>安装java jdk</h3><ul><li><p>更新软件包列表：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure></li><li><p>安装openjdk-8-jdk：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="builtin-name">get</span> install openjdk-8-jdk</span><br></pre></td></tr></table></figure></li><li><p>查看java版本：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -<span class="built_in">version</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="下载并解压Stanford-coreNLP-包："><a href="#下载并解压Stanford-coreNLP-包：" class="headerlink" title="下载并解压Stanford coreNLP 包："></a>下载并解压Stanford coreNLP 包：</h3><ul><li>从这里下载<br><a href="https://stanfordnlp.github.io/CoreNLP/download.html" target="_blank" rel="noopener">https://stanfordnlp.github.io/CoreNLP/download.html</a><br>或者以命令行方式下载<blockquote><p>wget <a href="http://nlp.stanford.edu/software/stanford-corenlp-full-2018-02-27.zip" target="_blank" rel="noopener">http://nlp.stanford.edu/software/stanford-corenlp-full-2018-02-27.zip</a>  </p></blockquote></li></ul><ul><li><p>解压</p><blockquote><p>unzip stanford-corenlp-full-2018-02-27.zip</p></blockquote></li><li><p>转到文件目录</p></li></ul><blockquote><p>cd stanford-corenlp-full-2018-02-27/</p></blockquote><h3 id="配置环境变量："><a href="#配置环境变量：" class="headerlink" title="配置环境变量："></a>配置环境变量：</h3><p>把下列这行代码加到你的.bashrc里面(vim .bashrc)</p><blockquote><p> cd ~<br>vim .bashrc<br>export CLASSPATH=/path/to/stanford-corenlp-full-2018-02-27/stanford-corenlp-3.9.1.jar<br>source ~/.bashrc  ## 使之生效<br>把/path/to/替换为你保存stanford-corenlp-full-2016-10-31的地方的路径</p></blockquote><h3 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h3><blockquote><p>pip install stanfordcorenlp</p></blockquote><p>处理中文还需要下载中文的模型jar文件，然后放到stanford-corenlp-full-2018-02-27根目录下即可</p><p>wget <a href="http://nlp.stanford.edu/software/stanford-chinese-corenlp-2018-02-27-models.jar" target="_blank" rel="noopener">http://nlp.stanford.edu/software/stanford-chinese-corenlp-2018-02-27-models.jar</a></p><h3 id="检查自己是否装好了stanfordcorenlp"><a href="#检查自己是否装好了stanfordcorenlp" class="headerlink" title="检查自己是否装好了stanfordcorenlp"></a>检查自己是否装好了stanfordcorenlp</h3><p>进入python2或者python3</p><p>命令行下输入：</p><blockquote><p>python</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> stanfordcorenlp <span class="keyword">import</span> StanfordCoreNLP</span><br></pre></td></tr></table></figure><p>能成功导入不报错，就是安装成功了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java 的编译与执行</title>
      <link href="/2019/03/26/java/"/>
      <url>/2019/03/26/java/</url>
      
        <content type="html"><![CDATA[<h2 id="java-的编译与执行"><a href="#java-的编译与执行" class="headerlink" title="java 的编译与执行"></a>java 的编译与执行</h2><ol><li><p>用文本编辑器新建一个yumhtest.java文件，在其中输入以下代码并保存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">yumhtest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译：在shell终端执行命令 <strong>javac yumhtest.java</strong></p></li><li><p>运行：在shell终端执行命令 <strong>java yumhtest</strong><br>当shell下出现“hello world !”字样</p></li></ol><p>注意事项：类名应和文件名相同。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java</title>
      <link href="/2019/03/26/java%20%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/"/>
      <url>/2019/03/26/java%20%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="java-的编译与执行"><a href="#java-的编译与执行" class="headerlink" title="java 的编译与执行"></a>java 的编译与执行</h2><ol><li><p>用文本编辑器新建一个yumhtest.java文件，在其中输入以下代码并保存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">yumhtest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译：在shell终端执行命令 <strong>javac yumhtest.java</strong></p></li><li><p>运行：在shell终端执行命令 <strong>java yumhtest</strong><br>当shell下出现“hello world !”字样</p></li></ol><p>注意事项：类名应和文件名相同。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPICE</title>
      <link href="/2019/03/25/SPICE/"/>
      <url>/2019/03/25/SPICE/</url>
      
        <content type="html"><![CDATA[<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><h3 id="Ubuntu下安装Stanford-CoreNLP"><a href="#Ubuntu下安装Stanford-CoreNLP" class="headerlink" title="Ubuntu下安装Stanford CoreNLP"></a><a href="https://blog.csdn.net/Hay54/article/details/82313535" target="_blank" rel="noopener">Ubuntu下安装Stanford CoreNLP</a></h3>]]></content>
      
      
      <categories>
          
          <category> 自然语言理解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自然语言理解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>faster r-cnn 解读</title>
      <link href="/2019/03/24/faster-r-cnn-%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/03/24/faster-r-cnn-%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>来自<a href="https://mp.weixin.qq.com/s/M_i38L2brq69BYzmaPeJ9w" target="_blank" rel="noopener">机器之心</a><br>可能机器之心的那个链接无法转到，<a href="http://tech.ifeng.com/a/20180223/44884976_0.shtml" target="_blank" rel="noopener">看这个</a><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e0ltm2y7j30u0083wev.jpg"><br>by yaya:<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e10a6tguj31fj0mw0vw.jpg"></p><h2 id="RPN"><a href="#RPN" class="headerlink" title="RPN"></a>RPN</h2><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e0p68j95j30t80gaaar.jpg" style="zoom:60%"><p>anchor: 定义anchor的长: scale=[4,8,16], 长宽比: ratio=[0.5, 1, 1.5, 2]，则在each position of conv feature 将会有k=len(scale)×len(ratio)=12个anchor</p><p>(1)对于分类层，我们对每个锚点输出两个预测值：它是背景（不是目标）的分数，和它是前景（实际的目标）的分数.<br><br>则经过该1×1的卷积层，输出的shape=N×2k×H×W  <br></p><p>(2)对于回归或边框调整层，我们输出四个预测值(偏移值)：<font color="#0099ff" size="5" face="黑体">Δxcenter、Δycenter、Δwidth、Δheight</font>，我们将会把这些值用到锚点中来得到最终的建议：(x1, y1, x2, y2)分别为左下角和右上角的坐标，即area=(x2-x1)*(y2-y1).<br><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e0p66yxyj312w066t91.jpg"></p><p>(3) 补充，<font color="#0099ff" size="5" face="黑体">RoI Pooling</font>  得到 pooled feats，输入的是base feats, 得到的pred proposals 以及 <font color="#0099ff" size="5" face="黑体">1/scale</font><br>因为pred proposals得到的坐标是在原始的image上的，而当前的base feats 是相对于原图有尺度变化的，为了对应.</p><h2 id="R-CNN"><a href="#R-CNN" class="headerlink" title="R-CNN"></a>R-CNN</h2><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e0p6ekybj30u00c175l.jpg"><p>有两个不同的目标：<br><br>(1) 将建议分到一个类中，加上一个背景类（用于删除不好的建议）。<br><br>(2) 根据预测的类别更好地调整建议的边框。<br><br>在最初的 Faster R-CNN 论文中，R-CNN 对每个建议采用特征图，将它平坦化并使用两个大小为 4096 的有 ReLU 激活函数的全连接层。然后，它对每个不同的目标使用两种不同的全连接层：<br><br>一个有 N+1 个单元的全连接层，其中 N 是类的总数，另外一个是背景类。<br><br>一个有 4N 个单元的全连接层。我们希望有一个回归预测，因此对 N 个类别中的每一个可能的类别，我们都需要 <font color="#0099ff" size="5" face="黑体">Δxcenter、Δycenter、Δwidth、Δheight</font>。<br><br>训练和目标<br><br>R-CNN 的目标与 RPN 的目标的计算方法几乎相同，但是考虑的是不同的可能类别。我们采用建议和真实边框，并计算它们之间的 IoU。<br></p><p>那些有任何真实边框的建议，只要其 IoU 大于 0.5，都被分配给那个真实数据。那些 IoU 在 0.1 和 0.5 之间的被标记为背景。与我们在为 RPN 分配目标时相反的是，我们忽略了没有任何交集的建议。这是因为在这个阶段，我们假设已经有好的建议并且我们对解决更困难的情况更有兴趣。当然，这些所有的值都是可以为了更好的拟合你想找的目标类型而做调整的超参数。<br></p><p>边框回归的目标是计算建议和与其对应的真实框之间的偏移量，仅针对那些基于 IoU 阈值分配了类别的建议。<br></p><p>我们随机抽样了一个尺寸为 64 的 balanced mini batch，其中我们有高达 25% 的前景建议（有类别）和 75% 的背景。<br></p><p>按照我们对 RPN 损失所做的相同处理方式，现在的分类损失是一个多类别的交叉熵损失，使用所有选定的建议和用于与真实框匹配的 25% 建议的 Smooth L1 loss。由于 R-CNN 边框回归的全连接网络的输出对于每个类都有一个预测，所以当我们得到这种损失时必须小心。在计算损失时，我们只需要考虑正确的类。<br><br>这里若假定类别可知，则每个类都有预测，若类别不可知，则仅有一个预测即可，代码如下：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e0p66uafj30nq03vt8o.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 目标检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Image Caption 常用评价指标</title>
      <link href="/2019/03/24/Image-Caption-%E5%B8%B8%E7%94%A8%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"/>
      <url>/2019/03/24/Image-Caption-%E5%B8%B8%E7%94%A8%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Graph R-CNN for Scene Graph Generation</title>
      <link href="/2019/03/24/Graph-R-CNN-for-Scene-Graph-Generation/"/>
      <url>/2019/03/24/Graph-R-CNN-for-Scene-Graph-Generation/</url>
      
        <content type="html"><![CDATA[<p>这是ECCV 2018 场景图生成 的一篇文章。<br>写在前面，本文使用的GCN网络与“Graph Attention Networks”一致，都是计算两个节点之间的attention来计算邻接矩阵中的元素值，更新节点特征的公式是AXW。</p><ul><li><strong>查看本文的原因，主要是想看，其是如何提取relation feature的，但是文中仅使用了union box feature 作为relation feature。较为朴素！</strong>—————–不好</li><li><strong>同时也将relation 作为node放入graph 中，但是是object feature 与 realtion feature之间的混合graph，与“Auto-Encoding Scene Graphs for Image Captioning”一样采用的是异构图</strong>  </li><li><strong>文中对W<sup>sr</sup>Z<sup>r</sup>α<sup>sr</sup>， 为该node<sub>i</sub>与所有的relation nodes之间计算的注意力系数，并不合理，因为object 可能仅有一两个relation，怎么可能与所有的relation有关系呢</strong>————————–不好（后又考虑了一下，可能没有关系的直接算0，就不再计算attention了）</li></ul><p>思索良久，终于发现是哪里不对了，一般的情况下，都是X’=AXW，这样的形式，以 X 为中心，更新X的特征，而Z<sub>i</sub><sup>r</sup>的更新公式中是以Z<sup>o</sup>为中心，因此是不是有些不对头呢？？？</p><p>本文的<strong>两个主要的贡献</strong>：</p><ol><li><strong>GCN</strong> with attention 用于scene graph generate 任务。Updating each object and relationship representation based on its neighbors</li><li>对于N个object ,若两两配对，则会产生N×N个relation，数量是N的二次，数量很多，但是很多又是没有必要的，以前的工作采用随机采样的方式，但是本文提出了<strong>RePN 网络来采样relation</strong>。</li><li>提出了一个新的用于scene graph generate 的评价指标，SGGen+（不是笔者关注的内容，因此此处忽略了对SGGen+的介绍）</li></ol><h2 id="场景图生成任务的主要步骤"><a href="#场景图生成任务的主要步骤" class="headerlink" title="场景图生成任务的主要步骤"></a>场景图生成任务的主要步骤</h2><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1dxanmhpfj312o08p75l.jpg">    <ol><li>P( V|I )  指：在给定image的情况下，去得到 <strong>object proposals</strong><br>使用pytorch 版本[1]的faster R-CNN来得到 bbox，类似于[2]，采用分段训练的方式，先对faster R-CNN进行预训练，然后，固定faster r-cnn参数，训练整个场景图生成网络。  </li><li>P( E|V, I ) 指：在给定image 和 bbox的情况下来得到 <strong>relation proposals</strong><br>如果假设每个object proposals 之间都会有一个relation，则有N×N个relation，或者是说，有N×N个object pairs。但是含有很多不合适的relation（本身这object pairs 之间不存在关系，但是却指定了某种关系），因此本文提出使用ReRN 网络来采样得到 relatedness relations。</li><li>P( R,O|V,E,I ) 指： 在给定image，object proposals以及relation proposal之后，得到object label 和 relation label。<br>一般的方法是采用iterative refinement process[2]，本文使用的是用GCN来迭代。</li></ol><ul><li>overview<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1dy02tb1zj31du0crajb.jpg"></li></ul><h2 id="Object-Proposal"><a href="#Object-Proposal" class="headerlink" title="Object Proposal"></a>Object Proposal</h2><p>使用faster r-cnn来提取<strong>object proposals</strong>，并得到相对应的一维特征向量（<strong>pooled feat</strong>），faster r-cnn 使用类别可知，则可以得到每个object 对应的<strong>label</strong><br>使用</p><h2 id="Relation-Proposal-Network"><a href="#Relation-Proposal-Network" class="headerlink" title="Relation Proposal Network"></a>Relation Proposal Network</h2><p>输入： <strong>labels</strong> of object pairs<br>输出：relatedness relations/ m 个object pairs<br>主要的步骤见下图：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e8ud0p66j32v311qjyg.jpg"></p><h2 id="Attention-GCN"><a href="#Attention-GCN" class="headerlink" title="Attention GCN"></a>Attention GCN</h2><h3 id="Formulation"><a href="#Formulation" class="headerlink" title="Formulation"></a>Formulation</h3><ul><li>与GAT的公式是一致的，具体可以参看论文GAT[ 3]，<strong>α<sub>i</sub></strong> 是注意力系数<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e8wl8yubj30f60360sr.jpg" style="zoom:60%"><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e8wl8m92j30gn04sjrp.jpg" style="zoom:60%"></li></ul><h3 id="aGCN-for-Scene-Graph-Generation"><a href="#aGCN-for-Scene-Graph-Generation" class="headerlink" title="aGCN for Scene Graph Generation"></a>aGCN for Scene Graph Generation</h3><ul><li>只构建一个graph，在这个graph中，object是node，relation也是node。<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e98pvy7aj30dh0cq0t3.jpg" style="zoom:60%">  </li><li>用skip代表object node之间的连接；构建的是有向边；捕捉了三中类型的连接：</li></ul><p><strong>object &lt;–&gt; relationship</strong>， <strong>relationship &lt;–&gt; subject</strong> and <strong>object &lt;–&gt; object</strong><br><strong>s</strong>=subjects, <strong>o</strong>=objects, and <strong>r</strong>=relationships<br>object and relationship features as  <strong>Z<sup>o</sup></strong> and <strong>Z<sup>r</sup></strong><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1e9gaiumnj30vp0dg0v2.jpg" style="zoom:60%"><br>对上图的解读：<br>（1）虽说是一个图，但是进行了两个aGCN的计算，使用的object and relationship node representation是什么？文中说，visual aGCN 使用visual feature 来进行计算，semantic aGCN 使用pre-softmax outputs来进行计算。（没看懂）<br>（2）WZα公式是GCN的计算公式，</p><ul><li><p>以 <strong>W<sup>skip</sup> Z<sup>o</sup> α<sup>skip</sup></strong> 为例，<strong>W<sup>skip</sup></strong> 是可学习参数，<strong>Z<sup>o</sup></strong> 是object nodes feature 组成的矩阵（d,N），<strong>α<sup>skip</sup></strong> 是一个向量，为该 node<sub>i</sub>与所有的object nodes之间计算的注意力系数，维度为(1,N）（N个objects）</p></li><li><p>以 <strong>W<sup>sr</sup> Z<sup>r</sup> α<sup>sr</sup></strong> 为例，<strong>W<sup>sr</sup></strong> 是可学习参数，<strong>Z<sup>r</sup></strong> 是realtion nodes feature 组成的矩阵（d,m），<strong>α<sup>sr</sup></strong> 是一个向量，为该node<sub>i</sub>与所有的relation nodes之间计算的注意力系数，维度为(1,m）（m个realtion）</p></li><li><p>以 <strong>W<sup>rs</sup> Z<sup>o</sup> α<sup>rs</sup></strong> 为例，<strong>W<sup>rs</sup></strong> 是可学习参数，<strong>Z<sup>o</sup></strong> 是object nodes feature 组成的矩阵（d,N），<strong>α<sup>rs</sup></strong> 是一个向量，为该relation<sub>i</sub>与所有的object nodes之间计算的注意力系数，维度为(1,N）（N个objects）  </p><p>（3）需要注意的是，<strong>α<sub>ii</sub></strong>=1，这将使得，每一行想加不为1</p></li></ul><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1ea7p889dj313l0dzwj3.jpg"><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] A faster pytorch implementation of faster  r-cnn. <a href="https://github.com/jwyang/faster-rcnn.pytorch" target="_blank" rel="noopener">https://github.com/jwyang/faster-rcnn.pytorch</a><br>[2] Scene graph generation by iterative message passing<br>[3] Graph Attention Networks<br>[3] Graph Attention Networks</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Batch Normalization(BN层)</title>
      <link href="/2019/03/23/Batch-Normalization-BN%E5%B1%82/"/>
      <url>/2019/03/23/Batch-Normalization-BN%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>参看：<a href="https://blog.csdn.net/donkey_1993/article/details/81871132" target="_blank" rel="noopener">https://blog.csdn.net/donkey_1993/article/details/81871132</a><br>参看：<a href="https://zhuanlan.zhihu.com/p/34879333" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34879333</a></p><h2 id="BN层的原理"><a href="#BN层的原理" class="headerlink" title="BN层的原理"></a>BN层的原理</h2><ul><li><p>在训练阶段，输入到网络中的是mini batch</p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1chneox3hj30dv0bddgx.jpg">解析：</li><li><p>Normalization操作我们虽然缓解了ICS问题，让每一层网络的输入数据分布都变得稳定，但却导致了数据表达能力的缺失。也就是我们通过变换操作改变了原有数据的信息表达（representation ability of the network），使得底层网络学习到的参数信息丢失。另一方面，通过让每一层的输入分布均值为0，方差为1，会使得输入在经过sigmoid或tanh激活函数时，容易陷入非线性激活函数的线性区域。  </p></li><li><p>因此，BN又引入了两个可学习（learnable）的参数  γ与β  。这两个参数的引入是为了恢复数据本身的表达能力，对规范化后的数据进行线性变换，即<img src="https://www.zhihu.com/equation?tex=%5Ctilde%7BZ_j%7D%3D%5Cgamma_j+%5Chat%7BZ%7D_j%2B%5Cbeta_j" alt="\tilde{Z_j}=\gamma_j \hat{Z}_j+\beta_j">。特别地，当  γ<sup>2</sup>=σ<sup>2</sup> ， β=μ 时，可以实现等价变换（identity transform）并且保留了原始输入特征的分布信息。</p></li></ul><h2 id="测试阶段如何使用Batch-Normalization？"><a href="#测试阶段如何使用Batch-Normalization？" class="headerlink" title="测试阶段如何使用Batch Normalization？"></a>测试阶段如何使用Batch Normalization？</h2><p>我们知道BN在每一层计算的  μ与σ<sup>2</sup>都是基于当前batch中的训练数据，但是这就带来了一个问题：我们在预测阶段，有可能只需要预测一个样本或很少的样本，没有像训练样本中那么多的数据，此时 μ与σ<sup>2</sup>的计算一定是有偏估计，这个时候我们该如何进行计算呢？</p><p>利用BN训练好模型后，我们保留了每组mini-batch训练数据在网络中每一层的<br> μ<sub>batch</sub>与σ<sup>2</sup><sub>batch</sub> 。此时我们使用整个样本的统计量来对Test数据进行归一化，具体来说使用均值与方差的无偏估计：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmu_%7Btest%7D%3D%5Cmathbb%7BE%7D+%28%5Cmu_%7Bbatch%7D%29" alt="\mu_{test}=\mathbb{E} (\mu_{batch})"></p><p><img src="https://www.zhihu.com/equation?tex=%5Csigma%5E2_%7Btest%7D%3D%5Cfrac%7Bm%7D%7Bm-1%7D%5Cmathbb%7BE%7D%28%5Csigma%5E2_%7Bbatch%7D%29" alt="\sigma^2_{test}=\frac{m}{m-1}\mathbb{E}(\sigma^2_{batch})"></p><p>得到每个特征的均值与方差的无偏估计后，我们对test数据采用同样的normalization方法：</p><p><img src="https://www.zhihu.com/equation?tex=BN%28X_%7Btest%7D%29%3D%5Cgamma%5Ccdot+%5Cfrac%7BX_%7Btest%7D-%5Cmu_%7Btest%7D%7D%7B%5Csqrt%7B%5Csigma%5E2_%7Btest%7D%2B%5Cepsilon%7D%7D%2B%5Cbeta" alt="BN(X_{test})=\gamma\cdot \frac{X_{test}-\mu_{test}}{\sqrt{\sigma^2_{test}+\epsilon}}+\beta"></p><p>另外，除了采用整体样本的无偏估计外。吴恩达在Coursera上的Deep Learning课程指出可以对train阶段每个batch计算的mean/variance采用<a href="[https://zhuanlan.zhihu.com/p/29895933](https://zhuanlan.zhihu.com/p/29895933)"><font color="#0099ff" size="5" face="楷体"> 指数加权平均</font></a>来得到test阶段mean/variance的估计。</p><h2 id="Batch-Normalization的优势"><a href="#Batch-Normalization的优势" class="headerlink" title="Batch Normalization的优势"></a>Batch Normalization的优势</h2><p>Batch Normalization在实际工程中被证明了能够缓解神经网络难以训练的问题，BN具有的有事可以总结为以下三点：</p><p><strong>（1）BN使得网络中每层输入数据的分布相对稳定，加速模型学习速度</strong></p><p>BN通过规范化与线性变换使得每一层网络的输入数据的均值与方差都在一定范围内，使得后一层网络不必不断去适应底层网络中输入的变化，从而实现了网络中层与层之间的解耦，允许每一层进行独立学习，有利于提高整个神经网络的学习速度。</p><p><strong>（2）BN使得模型对网络中的参数不那么敏感，简化调参过程，使得网络学习更加稳定</strong></p><p>在神经网络中，我们经常会谨慎地采用一些权重初始化方法（例如Xavier）或者合适的学习率来保证网络稳定训练。<br>当学习率设置太高时，会使得参数更新步伐过大，容易出现震荡和不收敛。但是使用BN的网络将不会受到参数数值大小的影响。<br>在使用Batch Normalization之后，抑制了参数微小变化随着网络层数加深被放大的问题，使得网络对参数大小的适应能力更强，此时我们可以设置较大的学习率而不用过于担心模型divergence的风险。</p><p><strong>（3）BN允许网络使用饱和性激活函数（例如sigmoid，tanh等），缓解梯度消失问题</strong></p><p>在不使用BN层的时候，由于网络的深度与复杂性，很容易使得底层网络变化累积到上层网络中，导致模型的训练很容易进入到激活函数的梯度饱和区；通过normalize操作可以让激活函数的输入数据落在梯度非饱和区，缓解梯度消失的问题；另外通过自适应学习 γ与β又让数据保留更多的原始信息。</p><p><strong>（4）BN具有一定的正则化效果</strong></p><p>在Batch Normalization中，由于我们使用mini-batch的均值与方差作为对整体训练样本均值与方差的估计，尽管每一个batch中的数据都是从总体样本中抽样得到，但不同mini-batch的均值与方差会有所不同，这就为网络的学习过程中增加了随机噪音，与Dropout通过关闭神经元给网络训练带来噪音类似，在一定程度上对模型起到了正则化的效果。</p><p>另外，原作者通过也证明了网络加入BN后，可以丢弃Dropout，模型也同样具有很好的泛化效果。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>optical flow(光流)</title>
      <link href="/2019/03/23/optical-flow-%E5%85%89%E6%B5%81/"/>
      <url>/2019/03/23/optical-flow-%E5%85%89%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="https://blog.csdn.net/zouxy09/article/details/8683859" target="_blank" rel="noopener">https://blog.csdn.net/zouxy09/article/details/8683859</a></p><h2 id="光流的定义"><a href="#光流的定义" class="headerlink" title="光流的定义"></a>光流的定义</h2><p>在人的眼睛在观察物体时，物体的景象在人的视网膜上形成一系列连续变化的图像，这一系列连续变化的信息不断“流过”视网膜，好像一种光的流，故称之为光流。<br>一般，光流是由于场景中前景目标本身的移动、相机的移动，或者两者的共同运动所产生的。<br>定义：它是空间运动物体在观察成像平面上的像素运动的瞬时速度，是利用图像序列中<strong>像素在时间域上的变化以及相邻帧之间的相关性</strong>来找到上一帧跟当前帧之间存在的<strong>对应关系</strong>，从而计算出<strong>相邻帧</strong>之间物体的运动信息的一种方法。</p><h2 id="如何计算光流"><a href="#如何计算光流" class="headerlink" title="如何计算光流"></a>如何计算光流</h2><ul><li><p>那通俗的讲就是通过一个图片序列，把每张图像中每个像素的运动速度和运动方向找出来就是光流场。那怎么找呢？咱们直观理解肯定是：第t帧的时候A点的位置是(x1, y1)，那么我们在第t+1帧的时候再找到A点，假如它的位置是(x2,y2)，那么我们就可以确定A点的运动了：(ux, vy) = (x2, y2) - (x1,y1)。</p></li><li><p>那怎么知道第t+1帧的时候A点的位置呢？ 这就存在很多的光流计算方法了。</p></li><li><p>1981年，Horn和Schunck创造性地将二维速度场与灰度相联系，引入光流约束方程，得到光流计算的基本算法。人们基于不同的理论基础提出各种光流计算方法，算法性能各有不同。Barron等人对多种光流计算技术进行了总结，按照理论基础与数学方法的区别把它们分成四种：<strong>基于梯度的方法、基于匹配的方法、基于能量的方法、基于相位的方法</strong>。近年来神经动力学方法也颇受学者重视。</p></li><li><p>yaya: 即光流法计算的是：相邻两帧之间的对应像素点之间的<strong>速度矢量</strong>，但是如何得到相邻帧对应的像素点是一个问题。<br>光流法主要依赖于三个假设：</p><p>  [亮度恒定] 图像中目标的像素强度在连续帧之间不会发生变化。<br>  [时间规律] 相邻帧之间的时间足够短，以至于在考虑运行变化时可以忽略它们之间的差异。该假设用于导出下面的核心方程。<br>  [空间一致性] 相邻像素具有相似的运动。  </p></li></ul><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1cgxrjz19j30hi0h90uo.jpg">  <p>上式中，I<sub>x</sub>,  I<sub>y</sub>可以通过图像沿x方向和y方向的导数计算，I<sub>t</sub>可以通过I(x,y,t)−I(x,y,t−1)计算。未知数是(u,v)， 正是我们想要求解的每个像素在前后相邻两帧的位移。</p><p>这里只有一个方程，却有两个未知数（实际是NN个方程，2N2N个未知数，NN是图像中待估计的像素点的个数，但是我们通过矩阵表示，将它们写成了如上式所述的紧凑形式），所以是一个不定方程。我们需要找出其它的约束求解方程。</p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1cgxrjo7dj30g00e6ta4.jpg"><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1cgxrhmkgj30gh05swej.jpg">  <p>如上图所示，H中的像素点(x,y)在I中的移动到了(x+u,y+v)的位置，偏移量为(u,v)。速度=位移在极短时间你内的位移量。  </p><p>参看：<a href="https://xmfbit.github.io/2017/05/03/cs131-opticalflow/" target="_blank" rel="noopener">https://xmfbit.github.io/2017/05/03/cs131-opticalflow/</a><br>参看：<a href="https://blog.csdn.net/carson2005/article/details/7581642" target="_blank" rel="noopener">https://blog.csdn.net/carson2005/article/details/7581642</a></p>]]></content>
      
      
      <categories>
          
          <category> 行为识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 行为识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从bagging到dropout</title>
      <link href="/2019/03/22/%E4%BB%8Ebagging%E5%88%B0dropout/"/>
      <url>/2019/03/22/%E4%BB%8Ebagging%E5%88%B0dropout/</url>
      
        <content type="html"><![CDATA[<ul><li>转载 from: <a href="https://blog.csdn.net/m0_37477175/article/details/77145459" target="_blank" rel="noopener">https://blog.csdn.net/m0_37477175/article/details/77145459</a></li></ul><p>dropout的思想继承自bagging方法，学习dropout先了解一下bagging方法。</p><h2 id="bagging"><a href="#bagging" class="headerlink" title="bagging"></a>bagging</h2><ul><li>bagging是一种集成方法（ensemble methods）,可以通过集成来减小泛化误差（generalization error）。 </li><li>bagging的<strong>最基本的思想</strong>是通过分别训练几个不同分类器，最后对测试的样本，每个分类器对其进行投票。在机器学习上这种策略叫model averaging。 </li><li>model averaging 之所以有效，是因为并非所有的分类器都会产生相同的误差，只要有不同的分类器产生的误差不同就会对减小泛化误差非常有效。 </li><li>对于bagging方法，允许采用相同的分类器，相同的训练算法，相同的目标函数。但是在<strong>数据集方面</strong>，<a href="https://www.baidu.com/s?wd=%E6%96%B0%E6%95%B0%E6%8D%AE&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">新数据</a>集与原始数据集的大小是相等的。每个数据集都是通过在原始数据集中随机选择一个样本进行替换而得到的。意味着，每个新数据集中会<strong>存在重复</strong>的样本。 </li><li>在数据集建好之后，用<strong>相同的学习算法</strong>分别作用于每个数据集就得到了几个分类器。 </li><li>下面这幅图片很好的解释了bagging的工作方式：我们想实现一个对数字8进行分类的分类器。此时构造了两个数据集，使用相同的学习算法，第一个分类器学习到的是8的上面那部分而第二个分类器学习的是8的下面那个部分。当我们把两个分类器集合起来的时候，此时的分类才是比较好的。 </li><li>Each of these individual classification ruls is brittle, but if we average there output then the detector is robust.<br><img src="https://img-blog.csdn.net/20170813153102572?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbTBfMzc0NzcxNzU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></li></ul><h2 id="dropout"><a href="#dropout" class="headerlink" title="dropout"></a>dropout</h2><ul><li><p>我们可以把dropout类比成将许多大的神经网络进行集成的一种bagging方法。 </p></li><li><p>但是每一个神经网络的训练是非常耗时和占用很多内存的，训练很多的神经网络进行集合分类就显得太不实际了。 </p></li><li><p>但是，dropout可以训练所有子网络的集合，这些子网络通过去除整个网络中的一些<a href="https://www.baidu.com/s?wd=%E7%A5%9E%E7%BB%8F%E5%85%83&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">神经元</a>来获得。 </p></li><li><p>如下图所示：<br><img src="https://img-blog.csdn.net/20170813154717429?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbTBfMzc0NzcxNzU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p></li><li><p>可能有些人会问上图的有些子网络，从输入到不了最终的输出，怎么办？其实对于比较宽的层（wider layers）从输入到输出都切断的概率是非常小的，多以影响不是很大。</p></li><li><p>如何移除一个神经元呢，我们通过仿射和非线性变换，试神经元的输出乘以0。</p></li><li><p>每次我们加载一个样本到minibatch，然后随机的采样一个不同的二进制掩膜作用在所有的输出，输入，隐藏节点上。每个节点的掩膜都是独立采样的。采样一个掩膜值为1的概率是固定的超参数。</p></li></ul><h2 id="bagging与dropout训练的对比"><a href="#bagging与dropout训练的对比" class="headerlink" title="bagging与dropout训练的对比"></a>bagging与dropout训练的对比</h2><ul><li>在bagging中，所有的分类器都是独立的，而在dropout中，所有的模型都是共享参数的。</li><li>在bagging中，所有的分类器都是在特定的数据集下训练至收敛，而在dropout中没有明确的模型训练过程。网络都是在一步中训练一次（输入一个样本，随机训练一个子网络）</li><li>（相同点）对于训练集来说，每一个子网络的训练数据是通过原始数据的替代采样得到的子集。<strong>？？？</strong>（自己的理解：每一个输入一个样本初始化某一个子网络）</li></ul><h2 id="dropout的优势"><a href="#dropout的优势" class="headerlink" title="dropout的优势"></a>dropout的优势</h2><ul><li>very computationally cheap在dropout训练阶段，每一个样本每一次更新只需要O(n)<br>，同时要生成n个二进制数字与每个状态相乘。除此之外，还需要O(n)的额外空间存储这些二进制数字，直到反向传播阶段。</li><li>没有很显著的限制模型的大小和训练的过程。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梯度消失与梯度爆炸的原因以及解决方案</title>
      <link href="/2019/03/22/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E4%B8%8E%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2019/03/22/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E4%B8%8E%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>转载from: <a href="https://blog.csdn.net/raojunyang/article/details/79962665" target="_blank" rel="noopener">https://blog.csdn.net/raojunyang/article/details/79962665</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要深入介绍深度学习中的梯度消失和梯度爆炸的问题以及解决方案。本文分为三部分，第一部分主要直观的介绍深度学习中为什么使用梯度更新，第二部分主要介绍深度学习中梯度消失及爆炸的原因，第三部分对提出梯度消失及爆炸的解决方案。有基础的同鞋可以跳着阅读。<br>其中，梯度消失爆炸的解决方案主要包括以下几个部分。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>预训练加微调</span><br><span class="line"><span class="bullet">- </span>梯度剪切、权重正则（针对梯度爆炸）</span><br><span class="line"><span class="bullet">- </span>使用不同的激活函数</span><br><span class="line"><span class="bullet">- </span>使用batchnorm</span><br><span class="line"><span class="bullet">- </span>使用残差结构</span><br><span class="line"><span class="bullet">- </span>使用LSTM网络</span><br></pre></td></tr></table></figure><h1 id="第一部分：为什么要使用梯度更新规则"><a href="#第一部分：为什么要使用梯度更新规则" class="headerlink" title="第一部分：为什么要使用梯度更新规则"></a>第一部分：为什么要使用梯度更新规则</h1><hr><ul><li><p>在介绍梯度消失以及爆炸之前，先简单说一说梯度消失的根源—–深度神经网络和反向传播。目前深度学习方法中，深度神经网络的发展造就了我们可以构建更深层的网络完成更复杂的任务，深层网络比如深度卷积网络，LSTM等等，而且最终结果表明，在处理复杂任务上，深度网络比浅层的网络具有更好的效果。但是，目前优化神经网络的方法都是基于反向传播的思想，即根据损失函数计算的误差通过梯度反向传播的方式，指导深度网络权值的更新优化。这样做是有一定原因的，首先，深层网络由许多非线性层堆叠而来，每一层非线性层都可以视为是一个非线性函数 (非线性来自于非线性激活函数），因此整个深度网络可以视为是一个复合的非线性多元函数 </p></li><li><p>我们最终的目的是希望这个多元函数可以很好的完成输入到输出之间的映射，那么，优化深度网络就是为了寻找到合适的权值，满足取得极小值点，比如最简单的损失函数 </p></li><li><p>假设损失函数的数据空间是下图这样的，我们最优的权值就是为了寻找下图中的最小值点，对于这种数学寻找最小值问题，采用梯度下降的方法再适合不过了。 </p></li></ul><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1baz0q65tj30e809edj1.jpg"><h1 id="第二部分：梯度消失、爆炸"><a href="#第二部分：梯度消失、爆炸" class="headerlink" title="第二部分：梯度消失、爆炸"></a>第二部分：梯度消失、爆炸</h1><p>梯度消失与梯度爆炸其实是一种情况，看接下来的文章就知道了。两种情况下梯度消失经常出现，一是在<strong>深层网络</strong>中，二是采用了<strong>不合适的损失函数</strong>，比如sigmoid。梯度爆炸一般出现在深层网络和<strong>权值初始化值太大</strong>的情况下，下面分别从这两个角度分析梯度消失和爆炸的原因。</p><h3 id="1-深层网络角度"><a href="#1-深层网络角度" class="headerlink" title="1.深层网络角度"></a>1.深层网络角度</h3><p>比较简单的深层网络如下：<br><img src="https://img-blog.csdn.net/20171219215626301?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图中是一个四层的全连接网络，假设每一层网络激活后的输出为,其中为第层, 代表第层的输入，也就是第层的输出，是激活函数，那么，得出，简单记为。<br>BP算法基于梯度下降策略，以目标的负梯度方向对参数进行调整，参数的更新为，给定学习率，得出。如果要更新第二隐藏层的权值信息，根据链式求导法则，更新梯度信息：<br>，很容易看出来，即第二隐藏层的输入。<br>所以说，就是对激活函数进行求导，如果此部分大于1，那么层数增多的时候，最终的求出的梯度更新将以指数形式增加，即发生<strong>梯度爆炸</strong>，如果此部分小于1，那么随着层数增多，求出的梯度更新信息将会以指数形式衰减，即发生了<strong>梯度消失</strong>。如果说从数学上看不够直观的话，下面几个图可以很直观的说明深层网络的梯度问题（图片内容来自参考文献1）：</p><p>注：下图中的隐层标号和第一张全连接图隐层标号刚好相反。<br>图中的曲线表示权值更新的速度，对于下图两个隐层的网络来说，已经可以发现隐藏层2的权值更新速度要比隐藏层1更新的速度慢</p><p><img src="https://img-blog.csdn.net/20171220110058983?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">那么对于四个隐层的网络来说，就更明显了，第四隐藏层比第一隐藏层的更新速度慢了两个数量级：</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20171220110732927?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>总结：</strong>从深层网络角度来讲，不同的层学习的速度差异很大，表现为网络中靠近输出的层学习的情况很好，靠近输入的层学习的很慢，有时甚至训练了很久，前几层的权值和刚开始随机初始化的值差不多。因此，梯度消失、爆炸，其<strong>根本原因</strong>在于反向传播训练法则，属于<a href="https://www.baidu.com/s?wd=%E5%85%88%E5%A4%A9%E4%B8%8D%E8%B6%B3&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">先天不足</a>，另外多说一句，Hinton提出capsule的原因就是为了彻底抛弃反向传播，如果真能大范围普及，那真是一个革命。</p><h3 id="2-激活函数角度"><a href="#2-激活函数角度" class="headerlink" title="2.激活函数角度"></a>2.激活函数角度</h3><p>其实也注意到了，上文中提到计算权值更新信息的时候需要计算前层偏导信息，因此如果激活函数选择不合适，比如使用sigmoid，梯度消失就会很明显了，原因看下图，左图是sigmoid的损失函数图，右边是其倒数的图像，如果使用sigmoid作为损失函数，其梯度是不可能超过0.25的，这样经过链式求导之后，很容易发生梯度消失，sigmoid函数数学表达式为：<br><img src="https://img-blog.csdn.net/20171220113129230?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="sigmoid函数"><img src="https://img-blog.csdn.net/20171220113422675?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="sigmoid函数导数"></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同理，<span class="built-in">tanh</span>作为损失函数，它的导数图如下，可以看出，<span class="built-in">tanh</span>比<span class="built-in">sigmoid</span>要好一些，但是它的倒数仍然是小于<span class="number">1</span>的。<span class="built-in">tanh</span>数学表达为：</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20171220114016270?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h1 id="第三部分：梯度消失、爆炸的解决方案"><a href="#第三部分：梯度消失、爆炸的解决方案" class="headerlink" title="第三部分：梯度消失、爆炸的解决方案"></a>第三部分：梯度消失、爆炸的解决方案</h1><hr><h3 id="2-1-方案1-预训练加微调"><a href="#2-1-方案1-预训练加微调" class="headerlink" title="2.1 方案1-预训练加微调"></a>2.1 方案1-预训练加微调</h3><p>此方法来自Hinton在2006年发表的一篇论文，Hinton为了解决梯度的问题，提出采取无监督逐层训练方法，其基本思想是每次训练一层隐节点，训练时将上一层隐节点的输出作为输入，而本层隐节点的输出作为下一层隐节点的输入，此过程就是逐层“预训练”（pre-training）；在预训练完成后，再对整个网络进行“微调”（fine-tunning）。Hinton在训练深度信念网络（Deep Belief Networks中，使用了这个方法，在各层预训练完成后，再利用BP算法对整个网络进行训练。此思想相当于是先寻找局部最优，然后整合起来寻找全局最优，此方法有一定的好处，但是目前应用的不是很多了。</p><h3 id="2-2-方案2-梯度剪切、正则"><a href="#2-2-方案2-梯度剪切、正则" class="headerlink" title="2.2 方案2-梯度剪切、正则"></a>2.2 方案2-梯度剪切、正则</h3><p><strong>梯度剪切</strong>这个方案主要是针对梯度爆炸提出的，其思想是设置一个梯度剪切阈值，然后更新梯度的时候，如果梯度超过这个阈值，那么就将其强制限制在这个范围之内。这可以防止梯度爆炸。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注：在WGAN中也有梯度剪切限制操作，但是和这个是不一样的，WGAN限制梯度更新信息是为了保证lipchitz条件。</span><br></pre></td></tr></table></figure><p>另外一种解决梯度爆炸的手段是采用<strong>权重正则化</strong>（weithts regularization）比较常见的是正则，和正则，在各个深度框架中都有相应的API可以使用正则化，比如在中，若搭建网络的时候已经设置了正则化参数，则调用以下代码可以直接计算出正则损失：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regularization_loss = tf.add_n(tf<span class="selector-class">.losses</span><span class="selector-class">.get_regularization_losses</span>(scope=<span class="string">'my_resnet_50'</span>))</span><br></pre></td></tr></table></figure><p>如果没有设置初始化参数，也可以使用以下代码计算正则损失：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l2_loss = tf.add_n([tf<span class="selector-class">.nn</span><span class="selector-class">.l2_loss</span>(var) <span class="keyword">for</span> <span class="selector-tag">var</span> <span class="keyword">in</span> tf.trainable_variables() <span class="keyword">if</span> <span class="string">'weights'</span> <span class="keyword">in</span> <span class="selector-tag">var</span>.name])</span><br></pre></td></tr></table></figure><p>正则化是通过对网络权重做正则限制过拟合，仔细看正则项在损失函数的形式： </p><p>其中，是指正则项系数，因此，如果发生梯度爆炸，权值的范数就会变的非常大，通过正则化项，可以部分限制梯度爆炸的发生。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注：事实上，在深度神经网络中，往往是梯度消失出现的更多一些。</span><br></pre></td></tr></table></figure><h3 id="2-3-方案3-relu、leakrelu、elu等激活函数"><a href="#2-3-方案3-relu、leakrelu、elu等激活函数" class="headerlink" title="2.3 方案3-relu、leakrelu、elu等激活函数"></a>2.3 方案3-relu、leakrelu、elu等激活函数</h3><p><strong>Relu:</strong>思想也很简单，如果激活函数的导数为1，那么就不存在梯度消失爆炸的问题了，每层的网络都可以得到相同的更新速度，relu就这样应运而生。先看一下relu的数学表达式：</p><p><img src="https://img-blog.csdn.net/20171220115642365?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>其函数图像：</p><p><img src="https://img-blog.csdn.net/20171220115719332?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>从上图中，我们可以很容易看出，relu函数的导数在正数部分是恒等于1的，因此在深层网络中使用relu激活函数就不会导致梯度消失和爆炸的问题。</p><p><strong>relu</strong>的主要贡献在于：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 解决了梯度消失、爆炸的问题</span></span><br><span class="line"><span class="comment">-- 计算方便，计算速度快</span></span><br><span class="line"><span class="comment">-- 加速了网络的训练</span></span><br></pre></td></tr></table></figure><p>同时也存在一些<strong>缺点</strong>：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 由于负数部分恒为0，会导致一些神经元无法激活（可通过设置小学习率部分解决）</span></span><br><span class="line"> <span class="comment">-- 输出不是以0为中心的</span></span><br></pre></td></tr></table></figure><p>尽管relu也有缺点，但是仍然是目前使用最多的激活函数</p><p><strong>leakrelu</strong><br>leakrelu就是为了解决relu的0区间带来的影响，其数学表达为：其中k是leak系数，一般选择0.01或者0.02，或者通过学习而来</p><p><img src="https://img-blog.csdn.net/20170702211001517?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FpY2FpYXRuYnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>leakrelu解决了0区间带来的影响，而且包含了relu的所有优点<br><strong>elu</strong><br>elu激活函数也是为了解决relu的0区间带来的影响，其数学表达为：<img src="https://img-blog.csdn.net/20171220134603079?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>其函数及其导数数学形式为：</p><p><img src="https://img-blog.csdn.net/20171220134614121?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>但是elu相对于leakrelu来说，计算要更耗时间一些</p><h3 id="2-4-解决方案4-batchnorm"><a href="#2-4-解决方案4-batchnorm" class="headerlink" title="2.4 解决方案4-batchnorm"></a>2.4 解决方案4-batchnorm</h3><p><strong>Batchnorm</strong>是深度学习发展以来提出的最重要的成果之一了，目前已经被广泛的应用到了各大网络中，具有加速网络收敛速度，提升训练稳定性的效果，Batchnorm本质上是解决反向传播过程中的梯度问题。batchnorm全名是batch normalization，简称BN，即批规范化，通过规范化操作将输出信号x规范化到均值为0，方差为1保证网络的稳定性。<br>具体的batchnorm原理非常复杂，在这里不做详细展开，此部分大概讲一下batchnorm解决梯度的问题上。具体来说就是反向传播中，经过每一层的梯度会乘以该层的权重，举个简单例子：<br>正向传播中，那么反向传播中，，反向传播式子中有的存在，所以的大小影响了梯度的消失和爆炸，batchnorm就是通过对每一层的输出规范为均值和方差一致的方法，消除了带来的放大缩小的影响，进而解决梯度消失和爆炸的问题。<br>有关batch norm详细的内容可以参考我的另一篇博客：<br><a href="http://blog.csdn.net/qq_25737169/article/details/79048516" target="_blank" rel="noopener">http://blog.csdn.net/qq_25737169/article/details/79048516</a></p><h3 id="2-5-解决方案5-残差结构"><a href="#2-5-解决方案5-残差结构" class="headerlink" title="2.5 解决方案5-残差结构"></a>2.5 解决方案5-残差结构</h3><p><strong>残差结构</strong>说起残差的话，不得不提这篇论文了：Deep Residual Learning for Image Recognition，关于这篇论文的解读，可以参考知乎链接：<a href="https://zhuanlan.zhihu.com/p/31852747" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31852747</a>这里只简单介绍残差如何解决梯度的问题。<br>事实上，就是残差网络的出现导致了image net比赛的终结，自从残差提出后，几乎所有的深度网络都离不开残差的身影，相比较之前的几层，几十层的深度网络，在残差网络面前都不值一提，残差可以很轻松的构建几百层，一千多层的网络而不用担心梯度消失过快的问题，原因就在于残差的捷径（shortcut）部分，其中残差单元如下图所示：<br><img src="https://img-blog.csdn.net/20171220144105760?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU3MzcxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>相比较于以前网络的直来直去结构，残差中有很多这样的跨层连接结构，这样的结构在反向传播中具有很大的好处，见下式：<br><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial%20loss%7D%7B%5Cpartial%20%7B%7Bx%7D_%7Bl%7D%7D%7D=%5Cfrac%7B%5Cpartial%20loss%7D%7B%5Cpartial%20%7B%7Bx%7D_%7BL%7D%7D%7D%5Ccdot%20%5Cfrac%7B%5Cpartial%20%7B%7Bx%7D_%7BL%7D%7D%7D%7B%5Cpartial%20%7B%7Bx%7D_%7Bl%7D%7D%7D=%5Cfrac%7B%5Cpartial%20loss%7D%7B%5Cpartial%20%7B%7Bx%7D_%7BL%7D%7D%7D%5Ccdot%20%5Cleft%28%201%2B%5Cfrac%7B%5Cpartial%20%7D%7B%5Cpartial%20%7B%7Bx%7D_%7BL%7D%7D%7D%5Csum%5Climits_%7Bi=l%7D%5E%7BL-1%7D%7BF%28%7B%7Bx%7D_%7Bi%7D%7D,%7B%7BW%7D_%7Bi%7D%7D%29%7D%20%5Cright%29" alt="这里写图片描述"><br>式子的第一个因子  表示的损失函数到达 L 的梯度，小括号中的1表明短路机制可以无损地传播梯度，而另外一项残差梯度则需要经过带有weights的层，梯度不是直接传递过来的。残差梯度不会那么巧全为-1，而且就算其比较小，有1的存在也不会导致梯度消失。所以残差学习会更容易。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注：上面的推导并不是严格的证明。</span><br></pre></td></tr></table></figure><h3 id="2-6-解决方案6-LSTM"><a href="#2-6-解决方案6-LSTM" class="headerlink" title="2.6 解决方案6-LSTM"></a>2.6 解决方案6-LSTM</h3><p><strong>LSTM</strong>全称是长短期记忆网络（long-short term memory networks），是不那么容易发生梯度消失的，主要原因在于LSTM内部复杂的“门”(gates)，如下图，LSTM通过它内部的“门”可以接下来更新的时候“记住”前几次训练的”残留记忆“，因此，经常用于生成文本中。目前也有基于CNN的LSTM，感兴趣的可以尝试一下。</p><p><img src="http://upload-images.jianshu.io/upload_images/42741-b9a16a53d58ca2b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="这里写图片描述"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h2><p>1.《Neural networks and deep learning》<br>2.<a href="https://www.baidu.com/s?wd=%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">《机器学习》</a>周志华 </p><ol start="3"><li><p><a href="https://www.cnblogs.com/willnote/p/6912798.html&gt;" target="_blank" rel="noopener">https://www.cnblogs.com/willnote/p/6912798.html&gt;</a> </p></li><li><p><a href="https://www.zhihu.com/question/38102762" target="_blank" rel="noopener">https://www.zhihu.com/question/38102762</a> </p><ol start="5"><li><a href="http://www.jianshu.com/p/9dc9f41f0b29" target="_blank" rel="noopener">http://www.jianshu.com/p/9dc9f41f0b29</a></li></ol></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python: list vs tuple</title>
      <link href="/2019/03/20/python-list-vs-tuple/"/>
      <url>/2019/03/20/python-list-vs-tuple/</url>
      
        <content type="html"><![CDATA[<ul><li><p><a href="https://shiyaya.github.io/2019/03/12/python%E5%9F%BA%E7%A1%80%EF%BC%9A-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-python-%E4%B8%AD%E7%9A%84%E8%B5%8B%E5%80%BC%E3%80%81%E5%BC%95%E7%94%A8%E3%80%81%E6%8B%B7%E8%B4%9D%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/" target="_blank" rel="noopener">shiyaya.github.io-python基础： 深入理解 python 中的赋值、引用、拷贝、作用域</a></p></li><li><p><a href="https://data-flair.training/blogs/python-tuples-vs-lists/" target="_blank" rel="noopener">https://data-flair.training/blogs/python-tuples-vs-lists/</a>  </p></li></ul><table><thead><tr><th>list</th><th>tuple</th></tr></thead><tbody><tr><td>可变对象</td><td>不可变对象</td></tr><tr><td>参数传递是传递的是引用</td><td>参数传递是传递的是值</td></tr><tr><td></td><td></td></tr><tr><td>可以修改某个元素的值</td><td>不可以修改某个元素的值，即不可以按索引来修改元素值</td></tr><tr><td>a= [1,2,3]<br>b=a<br>b[0]=8<br>print(a) #a=[8,2,3]</td><td>略</td></tr><tr><td>可以修改slice<br>del a[0:2]</td><td>不可以修改slice<br>del a[0:2]#会提示错误</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习知识点</title>
      <link href="/2019/03/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2019/03/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<ul><li><p>讲一下正则化，L1和L2正则化各自的特点和适用场景。<br>答：L1用来获得稀疏化特征；L2用来防止过拟合。L1让一部分特征的系数缩小到0，从而间接实现特征选择，用于特征间有关联的场合；L2让所有的特征系数都减小，但不会减为0，会使优化求解稳定快速。</p></li><li><p>防止过拟合的方法：<br>（1）早停，使用验证集，当验证集的损失下降，但是训练集的损失仍在上升时，则停止训练<br>（2）加入正则化项，L1、L2</p></li><li><p>分类问题有哪些评价指标？每种的适用场景<br>Precision  精确率，在所有预测为正样本的样本(TP+FP)中预测正确(TP)的比例，也就是：</p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1asfgshjuj307c01d3yb.jpg">适用于：检索出的信息有多少是用户感兴趣的Recall  召回率，在所有正样本(TP+FN)中，预测正确(TP)的比例，也就是：<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1asfv7ikpj306d019t8i.jpg">  适用于：用户感兴趣的信息有多少被检索出来了Accuracy  准确率，正确分类的样本占所有样本的比例，不适于数据极度不平衡的场景如广告点击率一般在千分之几。<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1asg2ggqgj30ab01eglg.jpg">适用于多分类问题F1-measure  F1分数，是综合考虑Precision和Recall得到的一个指标，一般在需要PR都要保证的场景使用，针对一个值的优化更加直观容易衡量<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1asgb0qo9j304701dwe9.jpg"></li><li><p>逻辑回归可以处理非线性问题吗<br>只用原始特征不能；对特征做非线性变换，比如kernel，当然可以。 但那就不是lr了 或者一个神经网络 最后一层看成是lr 前面看成是提特征<br>lr的应用场景主要是特征很多的情况下 比如特征是上亿维的一些场景</p></li><li><p>讲一下pooling的作用， 为什么max pooling要更常用？哪些情况下，average pooling比max pooling更合适？<br>（1）保证特征的位置与旋转不变性。对于图像处理这种特性是很好的，但是对于NLP来说特征出现的位置是很重要的。比如主语一般出现在句子头等等<br>maxpooling提供了一定position的invariance，当图像某些区域像素变化时，maxpooling得到的output并不会变<br>（2）减少模型参数数量，减少过拟合问题。2D或1D的数组转化为单一数值，对于后续的convolution层或者全连接隐层来说，减少了单个Filter参数或隐层神经元个数<br>（3）可以把变长的输入x整理成固定长度的输入。CNN往往最后连接全连接层，神经元个数需要固定好，但是cnn输入x长度不确定，通过pooling操作，每个filter固定取一个值。有多少个Filter，Pooling就有多少个神经元，这样就可以把全连接层神经元固定住<br>（4）yaya: pooling 一般是对缩小image size，从而可以减小后续步骤中的参数量<br>max-pooling还提供了非线性, 这是max-pooling效果更好的一个重要原因.</p></li></ul><p><strong>average pooling比max pooling更合适：</strong>有的时候在模型接近分类器的末端使用全局平均池化还可以代替Flatten操作，使输入数据变成一位向量。</p><ul><li><p>1x1的卷积核有什么作用？<br>1*1的卷积核在NIN、Googlenet中被广泛使用，作用：<br>（1）实现跨通道的交互和信息整合<br>（2）进行卷积核通道数的降维和升维<br>（3）对于单通道feature map 用单核卷积即为乘以一个参数，而一般情况都是多核卷积多通道，实现多个feature map的线性组合</p></li><li><p>梯度消失和梯度爆炸的原因是什么？ 有哪些解决方法？<br>转载：<a href="https://blog.csdn.net/raojunyang/article/details/79962665（解释的很清楚）" target="_blank" rel="noopener">https://blog.csdn.net/raojunyang/article/details/79962665（解释的很清楚）</a><br>梯度消失更容易发生，当网络较深或者使用了不合适的激活函数时，会发生梯度消失；当为深层网络且权值初始化值太大时，容易发生梯度爆炸<br>yaya: 由于深层网络，在底层的网络权重的更新，需要高层网络权重的连乘，因此，当高层网络权重较小时，使得发生梯度消失，相反，当权重较大时，则发生梯度爆炸。<br>那么什么时候高层网络权重小—当使用sigmoid/tanh这样的激活函数时，因为sigmoid的导数最大为1/2；什么时候高层网络权重大–当初始化的权重较大时<br>如何解决梯度消失与爆炸：（1）使用正确的非线性激活函数（2）对于梯度爆炸问题使用梯度剪切（3）使用batch normalization（4）使用残差结构</p></li><li><p>CNN和RNN的梯度消失是一样的吗？  </p></li><li><p>有哪些防止过拟合的方法？<br>早停；添加正则化项：L1、L2；使用dropout</p></li><li><p>讲一下激活函数sigmoid，tanh，relu. Leaky ReLU各自的优点和适用场景？<br>sigmoid，tanh 有梯度消失的问题<br>relu 部分解决梯度消失问题（x&gt;0）<br>leaky relu </p></li><li><p>relu的负半轴导数都是0，这部分产生的梯度消失怎么办？  </p></li><li><p>batch size对收敛速度的影响。  </p></li><li><p>讲一下batch normalization<br>对输入的数据进行mini batch 的归一化</p></li><li><p>讲一下你怎么理解dropout，分别从bagging和正则化的角度<br><a href="https://blog.csdn.net/m0_37477175/article/details/77145459" target="_blank" rel="noopener">https://blog.csdn.net/m0_37477175/article/details/77145459</a><br>bagging 都是使用集成学习的思想，但是</p></li><li><p>data augmentation有哪些技巧？  </p></li><li><p>讲一下你了解的优化方法，sgd, momentum, rmsprop, adam的区别和联系  </p></li><li><p>如果训练的神经网络不收敛，可能有哪些原因？<br>可以参见此博文，具体来说，可以简述为以下几点：<br>（1）<strong>没有对数据进行归一化</strong>，即对数据减均值，并除以方差。而大部分神经网络的输入输出都是在0附近的分布。因此无法收敛。<br>（2）<strong>学习率不正确</strong><br>（3）<strong>在输出层使用错误的激活函数</strong>：在最后一层使用激活函数时，无法产生所需全部范围的值。假使你使用Relu这类限制范围的函数，神经网络便只会训练得到正值<br>（4）<strong>没有正确初始化权重</strong></p></li></ul><p>（1）代码题（leetcode类型），主要考察数据结构和基础算法，以及代码基本功<br>虽然这部分跟机器学习，深度学习关系不大，但也是面试的重中之重。基本每家公司的面试都问了大量的算法题和代码题，即使是商汤、face++这样的深度学习公司，考察这部分的时间也占到了我很多轮面试的60%甚至70%以上。我去face++面试的时候，面试官是residual net，shuffle net的作者；但他们的面试中，写代码题依旧是主要的部分。<br>大部分题目都不难，基本是leetcode medium的难度。但是要求在现场白板编程，思路要流畅，能做到一次性Bug-free. 并且，一般都是要给出时间复杂度和空间复杂度最优的做法。对于少数难度很大的题，也不要慌张。一般也不会一点思路也没有，尽力给面试官展现自己的思考过程。面试官也会引导你，给一点小提示，沿着提示把题目慢慢做出来也是可以通过面试的。<br>以下是我所遇到的一些需要当场写出完整代码的题目：<br>&lt;1&gt; 二分查找。分别实现C++中的lower_bound和upper_bound.<br>&lt;2&gt; 排序。 手写快速排序，归并排序，堆排序都被问到过。<br>&lt;3&gt; 给你一个数组，求这个数组的最大子段积<br>时间复杂度可以到O(n)<br>&lt;4&gt; 给你一个数组，在这个数组中找出不重合的两段，让这两段的字段和的差的绝对值最小。<br>时间复杂度可以到O(n)<br>&lt;5&gt; 给你一个数组，求一个k值，使得前k个数的方差 + 后面n-k个数的方差最小<br>时间复杂度可以到O(n)<br>&lt;6&gt; 给你一个只由0和1组成的字符串，找一个最长的子串，要求这个子串里面0和1的数目相等。<br>时间复杂度可以到O(n)<br>&lt;7&gt; 给你一个数组以及一个数K， 从这个数组里面选择三个数，使得三个数的和小于等于K， 问有多少种选择的方法？<br>时间复杂度可以到O(n^2)<br>&lt;8&gt; 给你一个只由0和1组成的矩阵，找出一个最大的子矩阵，要求这个子矩阵是方阵，并且这个子矩阵的所有元素为1<br>时间复杂度可以到O(n^2)<br>&lt;9&gt; 求一个字符串的最长回文子串<br>时间复杂度可以到O(n) (Manacher算法)<br>&lt;10&gt; 在一个数轴上移动，初始在0点，现在要到给定的某一个x点， 每一步有三种选择，坐标加1，坐标减1，坐标乘以2，请问最少需要多少步从0点到x点。<br>&lt;11&gt; 给你一个集合，输出这个集合的所有子集。<br>&lt;12&gt; 给你一个长度为n的数组，以及一个k值（k &lt; n) 求出这个数组中每k个相邻元素里面的最大值。其实也就是一个一维的max pooling<br>时间复杂度可以到O(n)<br>&lt;13&gt; 写一个程序，在单位球面上随机取点，也就是说保证随机取到的点是均匀的。<br>&lt;14&gt; 给你一个长度为n的字符串s，以及m个短串（每个短串的长度小于10）， 每个字符串都是基因序列，也就是说只含有A,T,C,G这四个字母。在字符串中找出所有可以和任何一个短串模糊匹配的子串。模糊匹配的定义，两个字符串长度相等，并且至多有两个字符不一样，那么我们就可以说这两个字符串是模糊匹配的。<br>&lt;15&gt; 其它一些描述很复杂的题这里就不列了。</p><p>（2）数学题或者”智力”题。<br>不会涉及特别高深的数学知识，一般就是工科数学（微积分，概率论，线性代数）和一些组合数学的问题。<br>下面是我在面试中被问到过的问题：<br>&lt;1&gt; 如果一个女生说她集齐了十二个星座的前男友，她前男友数量的期望是多少？<br>ps：这道题在知乎上有广泛的讨论，作为知乎重度用户我也看到过。如果一个女生说，她集齐了十二个星座的前男友，我们应该如何估计她前男友的数量？<br>&lt;2&gt; 两个人玩游戏。有n堆石头，每堆分别有a1, a2, a3…. an个石头，每次一个游戏者可以从任意一堆石头里拿走至少一个石头，也可以整堆拿走，但不能从多堆石头里面拿。无法拿石头的游戏者输，请问这个游戏是否有先手必胜或者后手必胜的策略？ 如果有，请说出这个策略，并证明这个策略能保证必胜。<br>&lt;3&gt; 一个一维数轴，起始点在原点。每次向左或者向右走一步，概率都是0.5. 请问回到原点的步数期望是多少？<br>&lt;4&gt; 一条长度为1的线段，随机剪两刀，求有一根大于0.5的概率。<br>&lt;5&gt; 讲一下你理解的矩阵的秩。低秩矩阵有什么特点？ 在图像处理领域，这些特点有什么应用？<br>&lt;6&gt; 讲一下你理解的特征值和特征向量。<br>&lt;7&gt; 为什么负梯度方向是使函数值下降最快的方向？简单数学推导一下</p><p>（3）机器学习基础<br>这部分建议参考周志华老师的《机器学习》。<br>下面是我在面试中被问到过的问题：<br>&lt;1&gt; 逻辑回归和线性回归对比有什么优点？<br>&lt;2&gt; 逻辑回归可以处理非线性问题吗？<br>&lt;3&gt; 分类问题有哪些评价指标？每种的适用场景。<br>&lt;4&gt; 讲一下正则化，L1和L2正则化各自的特点和适用场景。<br>&lt;5&gt; 讲一下常用的损失函数以及各自的适用场景。<br>&lt;6&gt; 讲一下决策树和随机森林<br>&lt;7&gt; 讲一下GBDT的细节，写出GBDT的目标函数。 GBDT和Adaboost的区别与联系<br>&lt;8&gt; 手推softmax loss公式<br>&lt;9&gt; 讲一下SVM, SVM与LR有什么联系。<br>&lt;10&gt;讲一下PCA的步骤。PCA和SVD的区别和联系<br>&lt;11&gt; 讲一下ensemble<br>&lt;12&gt; 偏差和方差的区别。ensemble的方法中哪些是降低偏差，哪些是降低方差？<br>…… 这部分问得太琐碎了，我能记起来的问题就这么多了。我的感觉，这部分问题大多数不是问得很深，所以不至于被问得哑口无言，总有得扯；但是要想给出一个特别深刻的回答，还是需要对机器学习的基础算法了解比较透彻。</p><p>（4）深度学习基础<br>这部分的准备，我推荐花书（Bengio的Deep learning）和 @魏秀参 学长的《解析卷积神经网络-深度学习实践手册》<br>下面是我在面试中被问到过的问题：<br>&lt;1&gt; 手推BP<br>&lt;2&gt; 手推RNN和LSTM结构<br>&lt;3&gt; LSTM中每个gate的作用是什么，为什么跟RNN比起来，LSTM可以防止梯度消失<br>&lt;4&gt; 讲一下pooling的作用， 为什么max pooling要更常用？哪些情况下，average pooling比max pooling更合适？<br>&lt;5&gt; 梯度消失和梯度爆炸的原因是什么？ 有哪些解决方法？<br>&lt;6&gt; CNN和RNN的梯度消失是一样的吗？<br>&lt;6&gt; 有哪些防止过拟合的方法？<br>&lt;7&gt; 讲一下激活函数sigmoid，tanh，relu. 各自的优点和适用场景？<br>&lt;8&gt; relu的负半轴导数都是0，这部分产生的梯度消失怎么办？<br>&lt;9&gt; batch size对收敛速度的影响。<br>&lt;10&gt; 讲一下batch normalization<br>&lt;11&gt; CNN做卷积运算的复杂度。如果一个CNN网络的输入channel数目和卷积核数目都减半，总的计算量变为原来的多少？<br>&lt;12&gt; 讲一下AlexNet的具体结构，每层的作用<br>&lt;13&gt; 讲一下你怎么理解dropout，分别从bagging和正则化的角度<br>&lt;14&gt; data augmentation有哪些技巧？<br>&lt;15&gt; 讲一下你了解的优化方法，sgd, momentum, rmsprop, adam的区别和联系<br>&lt;16&gt; 如果训练的神经网络不收敛，可能有哪些原因？<br>&lt;17&gt; 说一下你理解的卷积核， 1x1的卷积核有什么作用？<br>……..<br>同上，这部分的很多问题也是每个人都或多或少能回答一点，但要答得很好还是需要功底的。</p><p>（5）科研上的开放性问题<br>这部分的问题没有固定答案，也没法很好地针对性准备。功在平时，多读paper多思考，注意培养自己的insight和intuition<br>下面是我在面试中被问到过的问题：<br>&lt;1&gt; 选一个计算机视觉、深度学习、机器学习的子领域，讲一下这个领域的发展脉络，重点讲出各种新方法提出时的motivation，以及谈谈这个领域以后会怎么发展。<br>&lt;2&gt; 讲一下你最近看的印象比较深的paper<br>&lt;3&gt; 讲一下经典的几种网络结构， AlexNet， VGG，GoogleNet， Residual Net等等，它们各自最重要的contribution<br>&lt;4&gt; 你看过最近很火的XXX paper吗? 你对这个有什么看法？<br>……<br>（6） 编程语言、操作系统等方面的一些问题。<br>C++， Python， 操作系统，Linux命令等等。这部分问得比较少，但还是有的，不具体列了<br>（7）针对简历里项目/论文 / 实习的一些问题。<br>这部分因人而异，我个人的对大家也没参考价值，也不列了。</p><p>作者：wendy_要努力努力再努力<br>链接：<a href="https://www.jianshu.com/p/d40fc51874c8" target="_blank" rel="noopener">https://www.jianshu.com/p/d40fc51874c8</a><br>来源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unexpected key(s) in state_dict: “**module**.features.conv1.0.weight”</title>
      <link href="/2019/03/20/Unexpected-key-s-in-state-dict-%E2%80%9C-module-features-conv1-0-weight%E2%80%9D/"/>
      <url>/2019/03/20/Unexpected-key-s-in-state-dict-%E2%80%9C-module-features-conv1-0-weight%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<ul><li><p>参考此处<a href="https://discuss.pytorch.org/t/when-loading-a-model-unexpected-key-s-in-state-dict-module-features-conv1-0-weight/20505" target="_blank" rel="noopener">[link]</a></p></li><li><p>问题描述：在使用pytorch 加载预训练的模型时:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decoder.load_state_dict(checkpoint[<span class="string">'dec'</span>])</span><br></pre></td></tr></table></figure></li></ul><p>出现错误：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Missing</span> <span class="selector-tag">key</span>(<span class="selector-tag">s</span>) <span class="selector-tag">in</span> <span class="selector-tag">state_dict</span>: “<span class="selector-tag">features</span><span class="selector-class">.conv1</span><span class="selector-class">.0</span><span class="selector-class">.weight</span>”,</span><br><span class="line"><span class="selector-tag">Unexpected</span> <span class="selector-tag">key</span>(<span class="selector-tag">s</span>) <span class="selector-tag">in</span> <span class="selector-tag">state_dict</span>: “**<span class="selector-tag">module</span>**<span class="selector-class">.features</span><span class="selector-class">.conv1</span><span class="selector-class">.0</span><span class="selector-class">.weight</span>”,</span><br></pre></td></tr></table></figure><ul><li>原因：<br>在训练阶段，使用的是多GPU，采用了nn.DataParallel，因此在测试阶段，对应的模型也需要是多GPU的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非极大值抑制(NMS)</title>
      <link href="/2019/03/20/%E9%9D%9E%E6%9E%81%E5%A4%A7%E5%80%BC%E6%8A%91%E5%88%B6-NMS/"/>
      <url>/2019/03/20/%E9%9D%9E%E6%9E%81%E5%A4%A7%E5%80%BC%E6%8A%91%E5%88%B6-NMS/</url>
      
        <content type="html"><![CDATA[<p>非极大值抑制（Non-maximum suppression，NMS）是一种去除非极大值的算法，常用于计算机视觉中的边缘检测、物体识别等。</p><h2 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h2><p>给出一张图片和上面许多物体检测的候选框（即每个框可能都代表某种物体），但是这些框很可能有互相重叠的部分，我们要做的就是只保留最优的框。假设有N个框，每个框被分类器计算得到的分数为Si, 1&lt;=i&lt;=N。</p><p>0、建造一个存放待处理候选框的集合H，初始化为包含全部N个框；</p><p>建造一个存放最优框的集合M，初始化为空集。</p><p>1、将所有集合 H 中的框进行排序，选出分数最高的框 m，从集合 H 移到集合 M；</p><p>2、遍历集合 H 中的框，分别与框 m 计算交并比（Interection-over-union，IoU），如果高于某个阈值（一般为0~0.5），则认为此框与 m 重叠，将此框从集合 H 中去除。</p><p>3、回到第1步进行迭代，直到集合 H 为空。集合 M 中的框为我们所需。</p><h2 id="需要优化的参数："><a href="#需要优化的参数：" class="headerlink" title="需要优化的参数："></a>需要优化的参数：</h2><p>IoU 的阈值是一个可优化的参数，一般范围为0~0.5，可以使用交叉验证来选择最优的参数。<br>比如人脸识别的一个例子：</p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g19dbcocjfj30gw07kdmg.jpg"><p>已经识别出了 5 个候选框，但是我们只需要最后保留两个人脸。</p><p>首先选出分数最大的框（0.98），然后遍历剩余框，计算 IoU，会发现露丝脸上的两个绿框都和 0.98 的框重叠率很大，都要去除。</p><p>然后只剩下杰克脸上两个框，选出最大框（0.81），然后遍历剩余框（只剩下0.67这一个了），发现0.67这个框与 0.81 的 IoU 也很大，去除。</p><p>至此所有框处理完毕，算法结果：</p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g19dbr3kk4j30gw07kdmi.jpg"><p>（图片来自<a href="https://blog.csdn.net/shuzfan/article/details/52711706）" target="_blank" rel="noopener">https://blog.csdn.net/shuzfan/article/details/52711706）</a></p><h2 id="添加-by-yaya"><a href="#添加-by-yaya" class="headerlink" title="添加 by yaya:"></a>添加 by yaya:</h2><ul><li>在faster r-cnn中，得到了pred_boxes以及cls_boxes 之后，分别对每个类的objects进行NMS。（这里多说一句：使用了class_agnostic=false，即对每个bbox都有N个类别的得分）</li><li>首先得到得分最高的一个object bbox，之后，进行IOU分析，若IoU大于阈值，则剔除，否则保留。</li><li>对这一个得分最高的bbox分析完之后，再分析下一个次高得分的，并剔除所有与它IoU值大于阈值的object。一直这样分析，直到剩下的object之间的IoU值两两之间均小于阈值。</li><li>即可得到该类对应的bbox，且不交叠。</li><li>下一循环分析下一个类<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, imdb.num_classes):</span><br><span class="line">    inds = torch.nonzero(scores[:,j]&gt;thresh).view(<span class="number">-1</span>) </span><br><span class="line">    <span class="comment"># thresh = 0   inds.shape = torch.Size([300])</span></span><br><span class="line">    <span class="comment"># if there is det</span></span><br><span class="line">    <span class="keyword">if</span> inds.numel() &gt; <span class="number">0</span>:</span><br><span class="line">      cls_scores = scores[:,j][inds] <span class="comment"># 某个类在300个object上的得分</span></span><br><span class="line">      _, order = torch.sort(cls_scores, <span class="number">0</span>, <span class="literal">True</span>) <span class="comment"># 某个类在这300个object上的得分的高低排序</span></span><br><span class="line">      <span class="keyword">if</span> args.class_agnostic:</span><br><span class="line">        cls_boxes = pred_boxes[inds, :]</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        cls_boxes = pred_boxes[inds][:, j * <span class="number">4</span>:(j + <span class="number">1</span>) * <span class="number">4</span>]  <span class="comment"># 某个类对应的predict bbox</span></span><br><span class="line">      </span><br><span class="line">      cls_dets = torch.cat((cls_boxes, cls_scores.unsqueeze(<span class="number">1</span>)), <span class="number">1</span>)  <span class="comment"># torch.Size([300, 5])</span></span><br><span class="line">      <span class="comment"># cls_dets = torch.cat((cls_boxes, cls_scores), 1)</span></span><br><span class="line">      cls_dets = cls_dets[order]  <span class="comment"># torch.Size([300, 5]) 排了序之后的cat</span></span><br><span class="line">      keep = nms(cls_dets, cfg.TEST.NMS)  <span class="comment"># torch.Size([91, 1])</span></span><br><span class="line">      cls_dets = cls_dets[keep.view(<span class="number">-1</span>).long()]  <span class="comment"># torch.Size([91, 5])</span></span><br><span class="line">      <span class="keyword">if</span> vis:</span><br><span class="line">        im2show = vis_detections(im2show, imdb.classes[j], cls_dets.cpu().numpy(), <span class="number">0.3</span>)</span><br><span class="line">      all_boxes[j][i] = cls_dets.cpu().numpy()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      all_boxes[j][i] = empty_array</span><br></pre></td></tr></table></figure></li></ul><p>作者：HappyRocking<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/HappyRocking/article/details/79970627" target="_blank" rel="noopener">https://blog.csdn.net/HappyRocking/article/details/79970627</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>]]></content>
      
      
      <categories>
          
          <category> 目标检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机视觉学术会议</title>
      <link href="/2019/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE/"/>
      <url>/2019/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="A类"><a href="#A类" class="headerlink" title="A类"></a>A类</h3><ul><li>(AAAI)   Conference on Artificial Intelligence  </li></ul><p>截稿日期：2019-8-30</p><ul><li>CVPR 2019: IEEE Conference on Computer Vision and Pattern Recognition    </li></ul><p><a href="http://cvpr2019.thecvf.com/" target="_blank" rel="noopener">http://cvpr2019.thecvf.com/</a> </p><p>截稿日期：2018-11-16<br>通知日期：2019-03-02<br>会议日期：2019-06-15</p><ul><li>IJCAI 2019: International Joint Conference on Artificial Intelligence</li></ul><p><a href="http://www.ijcai19.org" target="_blank" rel="noopener">http://www.ijcai19.org</a></p><p>截稿日期：2019-02-05<br>会议日期：Aug 10 - Aug 16, 2019</p><ul><li>ICCV2019: International Conference on Computer Vision</li></ul><p><a href="http://iccv2019.thecvf.com" target="_blank" rel="noopener">http://iccv2019.thecvf.com</a></p><p>截稿日期：2019-05-01<br>会议日期：Oct 27 - Nov 3, 2019</p><ul><li>ECCV</li></ul><p>截稿时间：3 月 14 日<br>会议时间：9 月 8-14 日</p><ul><li>ACM International Conference on Multimedia (ACM MM) </li></ul><p><a href="https://www.acmmm.org/2019/" target="_blank" rel="noopener">https://www.acmmm.org/2019/</a></p><p>截稿日期：2019.4.1</p><h3 id="B类"><a href="#B类" class="headerlink" title="B类"></a>B类</h3><ul><li>ICME 2019: International Conference on Multimedia and Expo</li></ul><p><a href="http://www.icme2019.org" target="_blank" rel="noopener">http://www.icme2019.org</a> </p><p>截稿日期：2018-12-03<br>通知日期：2019-03-11<br>会议日期：2019-07-08</p><h3 id="C类"><a href="#C类" class="headerlink" title="C类"></a>C类</h3><ul><li>BMVC</li></ul><p><a href="http://bmvc2018.org" target="_blank" rel="noopener">http://bmvc2018.org</a></p><p>截稿时间：4 月 30 日</p><ul><li>ICIP</li></ul><p>截稿时间：3 月 2 日</p>]]></content>
      
      
      <categories>
          
          <category> 杂类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CV vs PIL</title>
      <link href="/2019/03/20/CV-vs-PIL/"/>
      <url>/2019/03/20/CV-vs-PIL/</url>
      
        <content type="html"><![CDATA[<h2 id="PIL"><a href="#PIL" class="headerlink" title="PIL"></a>PIL</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line">pil_image = Image.open(<span class="string">'test.jpg'</span>) <span class="comment"># 图片是360x480 宽x高  </span></span><br><span class="line">print(type(pil_image)) <span class="comment"># out: PIL.JpegImagePlugin.JpegImageFile  </span></span><br><span class="line">print(pil_image.size)  <span class="comment"># out: (360,480) # w,h  </span></span><br><span class="line">print(pil_image.mode) <span class="comment"># out: 'RGB'  </span></span><br><span class="line">  </span><br><span class="line">pil_image = np.array(pil_image,dtype=np.float32) <span class="comment"># image = np.array(image)默认是uint8  </span></span><br><span class="line">print(pil_image.shape) <span class="comment"># out: (480, 360, 3)  </span></span><br><span class="line"><span class="comment"># 神奇的事情发生了，w和h换了，变成(h,w,c)了  </span></span><br><span class="line"><span class="comment"># 注意ndarray中是 行row x 列col x 维度dim 所以行数是高，列数是宽</span></span><br></pre></td></tr></table></figure><blockquote><pre><code>输出结果：&lt;class &apos;PIL.JpegImagePlugin.JpegImageFile&apos;&gt;(360, 480)RGB(480, 360, 3)</code></pre></blockquote><p>这里截图在pycharm下调试的信息（未转化成numpy array之前）</p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g193y86ko4j30lt0ixmy8.jpg">  <blockquote><p>可以看到PIL.Image读出的image格式为（w,h,c）且image.mode = ‘RGB’<br>并且由代码的注释可以看到，当PIL.Image转化成numpy.array格式之后，image.size将转为（h,w,c）,c 仍为“RGB”</p></blockquote><h2 id="CV"><a href="#CV" class="headerlink" title="CV"></a>CV</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line">cv_image = cv2.imread(<span class="string">'test.jpg'</span>)  </span><br><span class="line">print(type(cv_image)) <span class="comment"># out: numpy.ndarray  </span></span><br><span class="line">print(cv_image.dtype) <span class="comment"># out: dtype('uint8')  </span></span><br><span class="line">print(cv_image.shape) <span class="comment"># out: (360,480, 3) (h,w,c) 和skimage类似  </span></span><br><span class="line"><span class="comment"># print(image) # BGR</span></span><br></pre></td></tr></table></figure><h2 id="为了比较PIL-和-CV"><a href="#为了比较PIL-和-CV" class="headerlink" title="为了比较PIL 和 CV"></a>为了比较PIL 和 CV</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(cv_image == pil_image)</span><br></pre></td></tr></table></figure><p>可以看到 分别是 False True False<br><strong>原因是PIL提取的是“RGB”，而CV提取的是“BGR”</strong><br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g194ap1lw4j306d07zmx0.jpg"></p><p>综上，可以凝练为以下几点：</p><ol><li>PIL提取的是PIL.image类型的数据（w,h,c），通道是“RGB”。</li><li>将该数据转为numpy.array之后，得到的是（h,w,c），通道仍是“RGB”。</li><li>CV提取的是numpy.array类型的数据（h,w,c），注意通道是“BGR”。</li></ol><ul><li>再</li><li>在pytorch中输入的image模式是“RGB”</li><li>在caffe中输入的是“BGR”</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pytorch_normalze</span><span class="params">(img)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    https://github.com/pytorch/vision/issues/223</span></span><br><span class="line"><span class="string">    return appr -1~1 RGB</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    normalize = tvtsf.Normalize(mean=[<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>],</span><br><span class="line">                                std=[<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">    img = normalize(t.from_numpy(img))</span><br><span class="line">    <span class="keyword">return</span> img.numpy()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">caffe_normalize</span><span class="params">(img)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    return appr -125-125 BGR</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    img = img[[<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>], :, :]  <span class="comment"># RGB-BGR</span></span><br><span class="line">    img = img * <span class="number">255</span></span><br><span class="line">    mean = np.array([<span class="number">122.7717</span>, <span class="number">115.9465</span>, <span class="number">102.9801</span>]).reshape(<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    img = (img - mean).astype(np.float32, copy=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> img</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础知识-try与except处理异常语句</title>
      <link href="/2019/03/19/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-try%E4%B8%8Eexcept%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E8%AF%AD%E5%8F%A5/"/>
      <url>/2019/03/19/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-try%E4%B8%8Eexcept%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="try-except介绍"><a href="#try-except介绍" class="headerlink" title="try/except介绍"></a>try/except介绍</h2><blockquote><p>与其他语言相同，在python中，try/except语句主要是用于处理程序正常执行过程中出现的一些异常情况，如语法错（python作为脚本语言没有编译的环节，在执行过程中对语法进行检测，出错后发出异常消息）、数据除零错误、从未定义的变量上取值等；而try/finally语句则主要用于在无论是否发生异常情况，都需要执行一些清理工作的场合，如在通信过程中，无论通信是否发生错误，都需要在通信完成或者发生错误时关闭网络连接。尽管<strong>try/except和**</strong>try/finally**的作用不同，但是在编程实践中通常可以把它们组合在一起使用try/except/else/finally的形式来实现稳定性和灵活性更好的设计。</p><p>默认情况下，在程序段的执行过程中，如果没有提供try/except的处理，脚本文件执行过程中所产生的异常消息会自动发送给程序调用端，如python shell，而python shell对异常消息的默认处理则是终止程序的执行并打印具体的出错信息。这也是在python shell中执行程序错误后所出现的出错打印信息的由来。</p></blockquote><h2 id="try-except格式"><a href="#try-except格式" class="headerlink" title="try/except格式"></a>try/except格式</h2><blockquote><p>python中try/except/else/finally语句的完整格式如下所示：</p><p>try:</p><p>​     Normal execution block</p><p>except A:</p><p>​     Exception A handle</p><p>except B:</p><p>​     Exception B handle</p><p>except:</p><p>​     Other exception handle</p><p>else:</p><p>​     if no exception,get here</p><p>finally:</p><p>​     print(“finally”)   </p></blockquote><blockquote><p>说明：</p><p>正常执行的程序在try下面的Normal execution block执行块中执行，在执行过程中如果发生了异常，则<strong>中断当前在Normal execution block中的执行</strong>，跳转到对应的异常处理块中开始执行；</p><p>python<strong>从第一个except X处开始查找</strong>，如果找到了对应的exception类型则进入其提供的exception handle中进行处理，如果没有找到则直接进入except块处进行处理。except块是可选项，如果没有提供，该exception将会被提交给python进行默认处理，处理方式则是<strong>终止应用程序并打印提示信息</strong>；</p><p>如果在Normal execution block执行块中执行过程中没有发生任何异常，则在执行完Normal execution block后会进入else执行块中（如果存在的话）执行。</p></blockquote><blockquote><p>无论是否发生了异常，只要提供了finally语句，以上try/except/else/finally代码块执行的最后一步总是执行finally所对应的代码块。</p><p>需要注意的是：</p><p>1.在上面所示的完整语句中try/except/else/finally所出现的顺序必须是try–&gt;except X–&gt;except–&gt;else–&gt;finally，即所有的<strong>except必须在else和finally之前</strong>，<strong>else（如果有的话）必须在finally之前</strong>，而<strong>except X必须在except之前</strong>。否则会出现语法错误。</p><p>2.对于上面所展示的try/except完整格式而言，else和finally都是可选的，而不是必须的，但是如果存在的话e<strong>lse必须在finally之前</strong>，<strong>finally</strong>（如果存在的话）<strong>必须在整个语句的最后位置</strong>。</p><p>3.在上面的完整语句中，else语句的存在必须以except X或者except语句为前提，<strong>如果在没有except语句的try block中使用else语句会引发语法错误</strong>。也就是说<strong>else不能与try/finally配合使用</strong>。</p></blockquote><p>4.except的使用要非常小心，慎用。</p><p>class AError(Exception):<br>     “””AError—exception”””<br>     print(‘AError’)</p><blockquote><p>try:</p><p>​     #raise AError</p><p>​     asdas(‘123’)</p><p>except AError:</p><p>​     print(“Get AError”)</p><p>except:</p><p>​     print(“exception”)     </p><p>else:</p><p>​     print(“else”)</p><p>finally:</p><p>​     print(“finally”)     </p><p>print(“hello wolrd”)</p><p>在上面的代码中，Normal execution block中出现了语法错误，但是由于使用了except语句，该语法错误就被掩盖掉了。因此在使用try/except是最好还是要非常清楚的知道Normal execution block中有可能出现的异常类型以进行针对性的处理。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(SGAE)Auto-Encoding Scene Graphs for Image Captioning</title>
      <link href="/2019/03/16/SAGE-Auto-Encoding-Scene-Graphs-for-Image-Captioning/"/>
      <url>/2019/03/16/SAGE-Auto-Encoding-Scene-Graphs-for-Image-Captioning/</url>
      
        <content type="html"><![CDATA[<p>本文是CVPR2019 的关于图像描述的文章，主要让我关注的原因是用到了scene graph 和 GCN，这也是本文最大的创新点。但是本文利用的是saptial GCN（悄悄说，构建的graph节点数量少，而且是异质的，不如说是多方面融合信息已达到丰富信息的目的 :-) ）</p><ul><li>后记<br>这里讲一下图卷积中spatial  gcn①②③ 与 spectral gcn ④⑤⑥<br>①Learning task-dependent distributed representations by backpropagation through structure.<br>②A new model for  learning in graph domains<br>③The graph neural network model<br>④Spectral networks and locally connected networks on graphs.<br>⑤Deep convolutional networks on graph-structured data.<br>⑥Semi-supervised classification with graph convolutional networks</li></ul><p>关于这篇论文采用的graph  convolutional network：采用的数</p><ul><li>为什么这样说？<br>本文提到了两类graph，一类是sentence scene graph，另一类是image scene graph，而在这两类下，又进行细分为relationship、attribute、object graph。但是，每个graph 中节点是异质的，比如在relationship graph中，obejct<sub>a</sub>， obejct<sub>b</sub>，relationship<sub>ab</sub>构成了一个graph，目的是来更新relationship embedding。从我的角度来看，只是融合相关信息来更新某一目标的特征，与graph无关。  </li><li>写在最前面，我个人的理解，在得到graph 节点的embedding 之后，就要输入gcn layer 来更新特征，这里，gcn layer 的表达公式可以这样理解： 该graph中所有的节点v<sub>i</sub>，经过concatenate之后，再经过一个全连接层。<br>gcn(.) = fc( concatenate(v1, v2, … , vn) )**</li></ul><p>下面说正文：</p><h1 id="General-encoder-decoder-network-for-image-captioning"><a href="#General-encoder-decoder-network-for-image-captioning" class="headerlink" title="General encoder-decoder network for image captioning"></a>General encoder-decoder network for image captioning</h1><ul><li><p>目前一般的encoder-decoder network for image captioning 是<strong>CNN提取image的特征，然后RNN来生成句子</strong>，例如下图所示。</p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14r211sidj30kb0fy0v3.jpg" style="zoom:80%"></li><li><p>进一步有<strong>加入attention</strong> [1]，下图是提取14×14×512 feature map of the fourth  convolutional layer，然后 flatten to 196 × 512 before feed into decoder。在输入到decoder时对这196个feature vector进行attention的加权求和。</p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14rdh7wg7j33ak1ep7wj.jpg" style="zoom:50%"></li><li><p>也有<strong>提取images 中的object，以此来提取显著信息，对object feature 进行attention的加权求和并送入decoder</strong>。具体地，使用RPN 的ROI pooling来提取objects feature，然后对LSTM的每一个step ,对这所有的object features进行attention操作，再作为输入送入LSTM[2]。如下图</p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14u74yahwj30q30modsg.jpg" style="zoom:70%"></li></ul><h1 id="本文的encoder-decoder-baseline"><a href="#本文的encoder-decoder-baseline" class="headerlink" title="本文的encoder-decoder baseline"></a>本文的encoder-decoder baseline</h1><h2 id="1-Encoder"><a href="#1-Encoder" class="headerlink" title="1. Encoder"></a><strong>1.</strong> <strong>Encoder</strong></h2><p>本文有两个encoder ： image-encoder；sentence-encoder<br>本文sentence-encoder  是用来预训练Dictionary，并共享给 image-encoder。但是在baseline中不用GCN/MGCN 和 Dictionary，因此image-encoder与sentence-encoder 之间是没有交集的。（我猜测 baseline中没有用到sentence-encoder）</p><p><strong>（1）对于image encoder 得到object embedding，relationship embedding , attribute embedding。</strong></p><p>如何得到object embedding，relationship embedding , attribute embedding？</p><ul><li>object detector : 采用与[1]一致的方式来训练faster r-cnn， 0.7的阈值 for proposal NMS， 0.3的阈值for object NMS。Faster R-CNN在visual genome上预训练，预训练之后，对proposals采取0.7的IoU阈值进行NMS，对objects 采取0.3的IoU阈值进行NMS，对每个image，采取10-100个object。使用RoI pooling 来提取object features，该object features 将作为后边relationship classifier 和attribute classifier的输入。</li><li>relationship classifier：使用在[5] 中提到的LSTM结构来作为关系分类器，来为两个object 分配一个relationship label。</li><li>attribute classifier : 为某个object 分配属性标签，将该object feature输入fc-relu-fc-softmax网络，则得到属性标签。</li></ul><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14vip74y0j311l09eq4y.jpg" style="zoom:60%">      <ul><li><p>以上三个输出的所有构成一个image scene graph  </p></li><li><p>需要说明以上三个是在<strong>Visual Genome数据集</strong>上预训练的，该数据集具有丰富的scene graph 标注，含有obejct’s categories，obejct’s attributes and pairwise relationships，因此可以用来训练目标检测器、属性分类器、关系分类器。但是由于这些标注含有很多噪声，因此采用一定的措施进行过滤：对于在数据集中出现超过2000次的objects，attributes，relationships保留下来，其余的去掉。经过这样的处理，则得到305个objects类，103个属性类，64个关系类  </p></li><li><p>经过分类器得到 label 之后，还需要得到相对应的embedding: <strong>u<sub>o</sub> , u<sub>r</sub> , u<sub>a</sub></strong> 。<br>其中 label 的维度472 = 305 + 103 + 64，即object/realation/attribute label的one hot vector 维度是三种节点的总类别数。</p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14w80gi8tj30w70ik0xu.jpg" style="zoom:70%">  </li></ul><p><strong>（2）对于sentence encoder 使用[6] 来得到 parse scene graph，进而得到object embedding，relationship embedding , attribute embedding</strong><br>注意这里的sentences使用的是<strong>MS COCO</strong>中的caption，而不是Visual Genome中的caption。同样对其进行过滤，过滤掉在all parsed scene graph中出现的objects、attributes、relationships次数少于10的，则剩下5364个objects类，1308个realtionships类，3430个attributes类。<br>sentence encoder 使用[6] 来得到 parse scene graph，但实际上，[6]又是使用[7]中的方法，所以读者最好看[7]<br>这里介绍 一下[6] SPICE 是用来评价image caption的一个性能指标，这里为什么使用它，它是用来做为一个评价指标的吗？首先回答第二个问题，不是用来作为评价指标的，而是利用了它的原理：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1dwj56im1j30iq0nmk00.jpg"></p><p>parse scene graph 的过程：sentence-&gt; syntax dependency tree-&gt; scene graph<br>给定一个句子，首先分析句法依赖树，再根据给定句法依赖树的情况下，输出scene graph，而scene graph 的输出是对sentence中的每一个次元，输出其是object，还是 relation，还是attribute（即，对每个word 输出一个one hot vector （我的猜测））。如下图所示：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1gbldqsamj30q50kntkm.jpg"></p><p>经过parse scene graph得到的是object <strong>label</strong>、relationship <strong>label</strong>、attributes <strong>label</strong>的one hot vector（注意one hot 的长度是 5346+1308+3430 = 10102，即 将三种node合在了一起）。得到label之后，再经过word embedding层即可得到对应的word embedding: <strong>e<sub>o</sub> , e<sub>r</sub> , e<sub>a</sub></strong>。<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14w6j9aouj31670aqdiw.jpg" style="zoom:50%"></p><h2 id="2-Decoder"><a href="#2-Decoder" class="headerlink" title="2.  Decoder"></a><strong>2.</strong>  <strong>Decoder</strong></h2><p>由两层LSTM组成（该部分与论文[1][4] 的decoder部分是完全一致的，只是输入的encoder output不一样而已），下图给出了我自己画的decoder 结构[1]给出的结构[4]中给出的decoder结构</p><ul><li>在[4]中encoder output是GCN输出的object features（两个graph生成的encoder output分别送入decoder）。</li><li>但是在本文中encoder output是 <strong>u<sub>o</sub> , u<sub>r</sub> , u<sub>a</sub></strong> 组合成的d×M 矩阵，或者是 <strong>e<sub>o</sub> , e<sub>r</sub> , e<sub>a</sub></strong> 组合成的d×M 矩阵 。M = num_objects + num_relationships + num_attributes  注意：在sentence-encoder中的输出，这里的M是该句子的parse scene graph实际生成的object、relation、attribute的数量（有可能baseline 中不使用 sentence-encoder）；在image-encoder中的输出，这里也是实际的object detector、relationship classifier、attribute classifier 输出的实际数量总和</li></ul><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14xg3jwvdj30mo0h2wfi.jpg" style="zoom:60%"><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g19d1x7kiij30im0bvaat.jpg" style="zoom:60%"><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14v8kb8kmj30sr0gzwgz.jpg" style="zoom:60%">具体地，这里也给出本文的表达方式如下表:这里的10369是对MS COCO中的captions 进行预处理之后，得到的 len of vocabulary<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14wrwfzplj30ze0hcjwe.jpg" style="zoom:60%"><h1 id="在baseline-上加东西"><a href="#在baseline-上加东西" class="headerlink" title="在baseline 上加东西"></a>在baseline 上加东西</h1><ul><li>一般的encoder-decoder如下图中的top所示，本文提出加入MGCN for image和GCN for sentence，同时加入Dictionary（共享参数 betwen sentence and image）<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14yn2vbtej30k40jzac6.jpg" style="zoom:50%">由以上可知，构建了image scene graph 和 sentence scene graph，下面将本文的主要创新点，加入GCN和Dictionary  </li></ul><h2 id="sentence-graph-gt-GCN-更新embedding"><a href="#sentence-graph-gt-GCN-更新embedding" class="headerlink" title="sentence graph -&gt; GCN (更新embedding )"></a>sentence graph -&gt; GCN (更新embedding )</h2><p>经上面的分析构建的sentence scene graph 在得到了object、relation、attribute label 对应的word embedding之后，将通过GCN来更新embedding。</p><ul><li>表中的（7）（8）（9）可以认为是三个relationship、attribute、object graph。<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14y1f5p02j31370e1jw1.jpg" style="zoom:60%"></li><li>解释这里的<strong>g<sub>r</sub> g<sub>a</sub> g<sub>o</sub> g<sub>s</sub></strong><br>以<strong>g<sub>r</sub></strong> 为例：g<sub>r</sub> (D<sub>in</sub>，D<sub>out</sub>）。输入维度为什么是3000？因为e<sub>oi</sub> , e<sub>rij</sub> , e<sub>oj</sub>的维度分别均是1000，论文中省略了将其concatenate的操作的说明，但是实际上是进行了concatenate操作，使得维度变为3000，并作为g<sub>r</sub>的输入。输出是1000维度。</li><li><strong>因此这里图卷积层，可以认为是 该graph中所有的节点v<sub>i</sub>，经过concatenate之后，再经过一个全连接层。<br>g(.) = fc( concatenate(v1, v2, … , vn) )</strong><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14y594pa8j30og0ksdi2.jpg" style="zoom:50%">  </li></ul><h2 id="image-graph-gt-Multi-modal-GCN-更新embedding"><a href="#image-graph-gt-Multi-modal-GCN-更新embedding" class="headerlink" title="image graph -&gt; Multi-modal GCN (更新embedding )"></a>image graph -&gt; Multi-modal GCN (更新embedding )</h2><p>与sentence graph 对应的GCN类似，这里的 multimodal 也没什么意思，就是特征融合时（9）（10）（11），既使用了label 对应的word embedding，又使用了feature。<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14yf14p1mj30sp0k0ten.jpg">  </p><ul><li>解释这里的<strong>f<sub>r</sub> f<sub>a</sub> f<sub>o</sub> f<sub>s</sub></strong><br>与sentence scene graph 对应的g一致，首先对输入进行了concatenate操作<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14yhc6gpzj314l0gktax.jpg"></li></ul><h2 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h2><ul><li><strong>该部分的作用</strong>是一个memory network。首先Dictionary在<strong>S-&gt;G-&gt;D-&gt;S</strong>上预训练，之后才被用于<strong>I-&gt;G-&gt;D-&gt;S</strong>  。即是参数共享的。而在<strong>S-&gt;G-&gt;D-&gt;S</strong>中，输入的sentence是由human generated。因此Dictionary中就preserve human’s inductive bias。进而与<strong>I-&gt;G-&gt;D-&gt;S</strong>  共享，使得由image 生成的predict caption也含有 human’s inductive bias</li><li>由上文分析可知，经过GCN/MGCN更新的embedding的维度均是1000，则Dictionary的输入维度均是1000，D是可学习参数矩阵1000*10000，输入的x经过Dictionary得到 x^<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14yrlt89sj310c07e40b.jpg">  </li></ul><h2 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h2><p>经过encoder 结合GCN/MGCN之后，输出发生了改变，这里再讲一下decoder的输入。</p><ul><li>在<strong>S-&gt;G-&gt;D-&gt;S</strong> 这个序列过程中由D-&gt;S 即输入decoder LSTM的过程，输入的是D的输出。</li><li>而在<strong>I-&gt;G-&gt;D-&gt;S</strong> 这个序列过程中，输入decoder LSTM的过程，输入的是D的输出v’和G的输出v^，即concate[v’, v^]<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g1507wpmlij30zf0h8dku.jpg"></li></ul><h1 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h1><ul><li>首先使用交叉熵损失函数训练 <strong>S-&gt;G-&gt;S</strong>  20 epoch。注意D不参与训练</li><li>使用交叉熵损失函数训练 <strong>S-&gt;G-&gt;D-&gt;S</strong>  20 epoch。这里的D参与训练</li><li>使用交叉熵损失函数训练 <strong>I-&gt;G-&gt;D-&gt;S</strong>  20 epoch。这里的D使用在上一步骤中预训练的参数，并fine-tune</li><li>使用RL-based reward 训练 <strong>I-&gt;G-&gt;D-&gt;S</strong>  40 epoch。 D参与训练  </li></ul><h1 id="推理过程"><a href="#推理过程" class="headerlink" title="推理过程"></a>推理过程</h1><ul><li>文章中没有写，但是我认为是<strong>I-&gt;G-&gt;D-&gt;S</strong>  </li></ul><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><ul><li>由下表可知，实验结果并不突出，尤其是与GCN-LSTM[7]对比可知，GCN-LSTM的结构更加简单的情况下，两个模型的结果却相差不多。</li><li>可以看到表中有三个GCN-LSTM， 最上边那个是本文作者的复现，由于GCN-LSTM的作者batch_size 太大，本文作者觉得对比不公平，因此重新复现了代码（没公开代码）并减小了bs进行实验得到的结果。第二个GCN-LSTM（sem graph）是原作者论文中的实验数据。第三个GCN-LSTM是融合了semantic graph 和saptial graph。</li><li>对于SGAE的融合应该是输入decoder的不仅是<strong>I-&gt;G-&gt;D-&gt;S</strong> 中D的输出v’，而且也输入G的输出 v^，即concate[v’,  v^]<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g14zjng66yj30oc0f0djs.jpg">   </li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] Bottom-up and top-down attention for image captioning and visual question answering<br>[2] Show, Attend and Tell: Neural Image Caption  Generation with Visual Attention<br>[3] Image Captioning with Object Detection and Localization<br>[4] Exploring Visual Relationship  for Image Captioning<br><strong>[5] Neural motifs: Scene graph parsing with global context</strong><br><strong>[6] Spice:  Semantic propositional image caption evaluation</strong><br><strong>[7] Generating Semantically Precise Scene Graphs from Textual Descriptions for Improved Image Retrieval</strong></p>]]></content>
      
      
      <categories>
          
          <category> 图像描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像描述 </tag>
            
            <tag> 图卷积网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Video as Space-Time Region Graphs</title>
      <link href="/2019/03/15/Video-as-Space-Time-Region-Graphs/"/>
      <url>/2019/03/15/Video-as-Space-Time-Region-Graphs/</url>
      
        <content type="html"><![CDATA[<p>本篇文章主要是讲图卷积网络应用在行为识别任务中。<br>使用的两个数据集是：charades和something-something数据集</p><ul><li>从数据集中video丰富性方面：其中charades数据集含有丰富的室内场景，video中的object较为复杂，也不居中。而，something-something 数据集中的video只含有1~2个object，且位于画面中的中心位置。</li><li>从数据集中video时长：charades的一整个video近30s长，但是annotation是对clips of video进行的标注，clips的分割也不具备规律性，几秒到几十秒不等。something-something数据集的video 时长为3s-6s。均为较短的视频。  </li></ul><p>由以上对数据集的分析，与作者的实验结果，结合，由于something-something的video时长短，objects of video 也较小，因此gcn+i3d 相比于对i3d的提升不大，而相反，charades数据集的提升较大。</p><ul><li>这里给出自己的看法：由于在charades上的提升较为明显，因此使用该网络应用到其他的网络中时，最好可以使用charades数据集进行pre-train，而不要使用something-something数据集。</li></ul><h2 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h2><p>在训练阶段，首先对video以6 fps的帧率进行截取帧，输入网络时，每个video选取30帧，这样相当于video中的5s。即在训练阶段，每个5s长的clips作为一个sample，赋给它相对应的label，进行训练。</p><h2 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h2><p>在测试阶段，charades对每个video 提取10个clips ，对每个clips的输出结果，以最大池化的方式进行聚合，对于something-something数据集，每个video提取2个clips，其他同理。</p><h2 id="Construct-Graph"><a href="#Construct-Graph" class="headerlink" title="Construct Graph"></a>Construct Graph</h2><p>对于charades dataset，每帧中提取50个object，对于something-something dataset ，每帧中提取10个object。</p><ul><li>Similarity Graph<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g13qsziabzj30fk0ahjrw.jpg" style="zoom:65%">Similarity graph 含有可学习参数</li><li>Spatial Graph</li><li>无可学习参数</li><li>We denote the IoU between object i in frame t and object  j in frame t + 1 as σ<sub>ij</sub><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g13qv0z3bxj30fq0b30t3.jpg" style="zoom:65%"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 行为识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 行为识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-物理CPU和逻辑CPU</title>
      <link href="/2019/03/13/linux-%E7%89%A9%E7%90%86CPU%E5%92%8C%E9%80%BB%E8%BE%91CPU/"/>
      <url>/2019/03/13/linux-%E7%89%A9%E7%90%86CPU%E5%92%8C%E9%80%BB%E8%BE%91CPU/</url>
      
        <content type="html"><![CDATA[<p>通过cat /proc/cpuinfo 来查看CPU的信息</p><p><img src="https:////upload-images.jianshu.io/upload_images/5262207-4e29a8e7da45169c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/837/format/webp" alt="img"></p><p>cpu.png</p><p>physical id 表示物理CPU的编号<br> CPU cores 表示每个物理CPU上的内核数<br> core id 表示每个内核的编号<br> processor 表示每个逻辑CPU的编号</p><p>逻辑CPU的总数=物理CPU的数量 * 每个物理CPU上的核数 * 超线程数<br> 如果 逻辑CPU的总数=物理CPU的数量 * 每个物理CPU上的核数 则表示超线程没开，否则表示超线程以开</p><p>作者：君子亮剑</p><p>链接：<a href="https://www.jianshu.com/p/ff8e8be262ac" target="_blank" rel="noopener">https://www.jianshu.com/p/ff8e8be262ac</a></p><p>来源：简书</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-查看cpu状态</title>
      <link href="/2019/03/13/linux-%E6%9F%A5%E7%9C%8Bcpu%E7%8A%B6%E6%80%81/"/>
      <url>/2019/03/13/linux-%E6%9F%A5%E7%9C%8Bcpu%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<ul><li>转载 “<a href="https://www.tianmaying.com/tutorial/cpu-top&quot;" target="_blank" rel="noopener">https://www.tianmaying.com/tutorial/cpu-top&quot;</a><br><code>top</code>命令是<code>Linux</code>下常用的性能分析工具，但本质上它提供了实时的对系统处理器的状态监视</li></ul><p>在命令行中输入<code>top</code>将输出一下信息：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">top - 23:16:12 up  7:40, <span class="number"> 1 </span>user,  load average: 0.97, 0.98, 1.01</span><br><span class="line">Tasks:<span class="number"> 440 </span>total,  <span class="number"> 2 </span>running,<span class="number"> 438 </span>sleeping,  <span class="number"> 0 </span>stopped,  <span class="number"> 0 </span>zombie</span><br><span class="line">%Cpu(s):  1.3 us,  1.4 sy,  0.0 ni, 96.9 id,  0.0 wa,  0.0 hi,  0.4 si,  0.0 st</span><br><span class="line">KiB Mem : 13183891+total, 12378241+free, <span class="number"> 3884532 </span>used, <span class="number"> 4171956 </span>buff/cache</span><br><span class="line">KiB Swap:       <span class="number"> 0 </span>total,       <span class="number"> 0 </span>free,       <span class="number"> 0 </span>used. 12719112+avail Mem </span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                                               </span><br><span class="line">11746 jenkins  <span class="number"> 20 </span> <span class="number"> 0 </span><span class="number"> 159972 </span> <span class="number"> 4760 </span> <span class="number"> 1600 </span>R  99.7  0.0 362:41.65 root/2                                                                                                                </span><br><span class="line">  <span class="number"> 42 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   4.3  0.0  14:46.50 rcu_sched                                                                                                             </span><br><span class="line">  <span class="number"> 68 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   2.6  0.0   0:55.10 rcuos/25                                                                                                              </span><br><span class="line">11414 jenkins  <span class="number"> 20 </span> <span class="number"> 0 </span>42.134g 1.652g <span class="number"> 24516 </span>S   0.7  1.3   2:37.54 java                                                                                                                  </span><br><span class="line">  <span class="number"> 49 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.3  0.0   0:32.35 rcuos/6                                                                                                               </span><br><span class="line"><span class="number"> 6818 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.3  0.0   0:34.33 kworker/0:1                                                                                                           </span><br><span class="line">14702 root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.3  0.0   0:00.26 kworker/2:0                                                                                                           </span><br><span class="line">15491 txq      <span class="number"> 20 </span> <span class="number"> 0 </span><span class="number"> 158044 </span> <span class="number"> 2616 </span> <span class="number"> 1552 </span>R   0.3  0.0   0:00.13 top                                                                                                                   </span><br><span class="line">   <span class="number"> 1 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span> <span class="number"> 45892 </span> <span class="number"> 8580 </span> <span class="number"> 3908 </span>S   0.0  0.0   0:13.06 systemd                                                                                                               </span><br><span class="line">   <span class="number"> 2 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.06 kthreadd</span><br></pre></td></tr></table></figure><p>前五行是当前整个系统资源的统计信息。</p><p>第一行是任务队列，包括当前时间，系统运行的总时间，系统用户登陆的数量，以及1分钟，5分钟，15分钟系统的负载情况。</p><p>第二行是<code>Tasks</code>信息，显示当前系统总共的进程数为440，运行状态的进程有两个，438个处于休眠状态，0个停止，0个僵尸进程。</p><p>第三行是<code>CPU</code>信息，很多人可能会忽略这些信息，我之前就是，所以详细说一下。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%<span class="selector-tag">Cpu</span>(<span class="selector-tag">s</span>):  1<span class="selector-class">.3</span> <span class="selector-tag">us</span>,  1<span class="selector-class">.4</span> <span class="selector-tag">sy</span>,  0<span class="selector-class">.0</span> <span class="selector-tag">ni</span>, 96<span class="selector-class">.9</span> <span class="selector-tag">id</span>,  0<span class="selector-class">.0</span> <span class="selector-tag">wa</span>,  0<span class="selector-class">.0</span> <span class="selector-tag">hi</span>,  0<span class="selector-class">.4</span> <span class="selector-tag">si</span>,  0<span class="selector-class">.0</span> <span class="selector-tag">st</span></span><br></pre></td></tr></table></figure><p><code>us</code> user CPU time —-用户空间占用<code>CPU</code>百分比</p><p><code>sy</code> system CPU time—-内核空间占用<code>CPU</code>百分比</p><p><code>ni</code> nice CPU time—-用户进程空间内改变过优先级的进程占用<code>CPU</code>百分比</p><p><code>id</code> idle—-空闲<code>CPU</code>百分比</p><p><code>wa</code> iowait—- 等待输入输出的<code>CPU</code>时间百分比</p><p><code>hi</code> hardware irq—-硬件中断</p><p><code>si</code> software irq—-软件中断</p><p><code>st</code> steal time—-实时</p><p>具体对应到第三行的详细信息，大家自己对照一下就行，或者在你命令行中试一下。</p><p>第四行<code>Memory</code>的状态信息，总共13183891+内存，空闲12378241+，使用3884532，缓存为4171956</p><p>第五行<code>Swap</code>交换分区信息，总共0，空闲0，使用0，缓存交换区总量12719112+</p><p>第六行是各个进程监视的项目列</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PID   <span class="built_in"> USER </span>     PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+   COMMAND</span><br><span class="line">PID` — 进程`id</span><br></pre></td></tr></table></figure><p><code>USER</code> — 进程所有者</p><p><code>PR</code> — 进程优先级</p><p><code>NI</code> — nice值。负值表示高优先级，正值表示低优先级</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VIRT` — 进程使用的虚拟内存总量。`VIRT=SWAP+RES</span><br><span class="line">RES` — 进程使用的、未被换出的物理内存大小。`RES=CODE+DATA</span><br></pre></td></tr></table></figure><p><code>SHR</code> — 共享内存大小</p><p><code>S</code>— 进程状态。<code>D</code>=不可中断的睡眠状态 <code>R</code>=运行 <code>S</code>=睡眠 <code>T</code>=跟踪/停止 <code>Z</code>=僵尸进程</p><p><code>%CPU</code> — 上次更新到现在的<code>CPU</code>时间占用百分比</p><p><code>%MEM</code> — 进程使用的物理内存百分比</p><p><code>TIME+</code> — 进程使用的<code>CPU</code>时间总计</p><p><code>COMMAND</code> — 进程名称（命令名/命令行）</p><p>对应的每个进程的信息，大家可以自己看一下。</p><p>如果你在命令行下再输入<code>1</code>，输出如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">top - <span class="number">23</span>:<span class="number">16</span>:<span class="number">12</span> <span class="keyword">up</span>  <span class="number">7</span>:<span class="number">40</span>,  <span class="number">1</span> user,  load average: <span class="number">0.97</span>, <span class="number">0.98</span>, <span class="number">1.01</span></span><br><span class="line">Task<span class="variable">s:</span> <span class="number">440</span> total,   <span class="number">2</span> running, <span class="number">438</span> sleeping,   <span class="number">0</span> stopped,   <span class="number">0</span> zombie</span><br><span class="line">%Cpu0  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu1  :  <span class="number">0.0</span> us,  <span class="number">0.3</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni, <span class="number">99.7</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu2  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu3  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu4  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu5  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu6  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu7  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu8  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu9  :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu10 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu11 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu12 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu13 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu14 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu15 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu16 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu17 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu18 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu19 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu20 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu21 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu22 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu23 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu24 : <span class="number">44.2</span> us, <span class="number">43.9</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,  <span class="number">0.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>, <span class="number">12.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu25 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu26 :  <span class="number">0.3</span> us,  <span class="number">0.3</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni, <span class="number">99.3</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu27 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu28 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu29 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu30 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">%Cpu31 :  <span class="number">0.0</span> us,  <span class="number">0.0</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">KiB Mem : <span class="number">13183891</span>+total, <span class="number">12377862</span>+free,  <span class="number">3887628</span> used,  <span class="number">4172660</span> buff/cache</span><br><span class="line">KiB Swap:        <span class="number">0</span> total,        <span class="number">0</span> free,        <span class="number">0</span> used. <span class="number">12718814</span>+avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                                               </span><br><span class="line"><span class="number">11746</span> jenkins   <span class="number">20</span>   <span class="number">0</span>  <span class="number">159972</span>   <span class="number">4760</span>   <span class="number">1600</span> R <span class="number">100.0</span>  <span class="number">0.0</span> <span class="number">393</span>:<span class="number">16.94</span> root/<span class="number">2</span>                                                                                                                </span><br><span class="line">   <span class="number">42</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">2.7</span>  <span class="number">0.0</span>  <span class="number">15</span>:<span class="number">59.27</span> rcu_sched                                                                                                             </span><br><span class="line">   <span class="number">67</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">1.3</span>  <span class="number">0.0</span>   <span class="number">1</span>:<span class="number">03.60</span> rcuos/<span class="number">24</span></span><br></pre></td></tr></table></figure><p>输入<code>1</code>可以查看每个逻辑<code>CPU</code>的情况，如上总共有32个逻辑<code>CPU</code>；</p><p>其他命令：</p><p>输入<code>b</code>，显示高亮，<code>shift+&gt;</code>和<code>shift+&lt;</code>可以左右切换</p><p>输入<code>x</code>也是显示高亮，但没有<code>b</code>那么明显，同理<code>shift+&gt;</code>和<code>shift+&lt;</code>可以左右切换</p><p>直接输入<code>top -c</code>，会显示完整命令，输出如下：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">top - 23:56:31 up  8:20, <span class="number"> 1 </span>user,  load average: 0.95, 0.97, 1.00</span><br><span class="line">Tasks:<span class="number"> 439 </span>total,  <span class="number"> 2 </span>running,<span class="number"> 437 </span>sleeping,  <span class="number"> 0 </span>stopped,  <span class="number"> 0 </span>zombie</span><br><span class="line">%Cpu(s):  1.4 us,  1.5 sy,  0.0 ni, 96.8 id,  0.0 wa,  0.0 hi,  0.4 si,  0.0 st</span><br><span class="line">KiB Mem : 13183891+total, 12377344+free, <span class="number"> 3892304 </span>used, <span class="number"> 4173168 </span>buff/cache</span><br><span class="line">KiB Swap:       <span class="number"> 0 </span>total,       <span class="number"> 0 </span>free,       <span class="number"> 0 </span>used. 12718340+avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                                               </span><br><span class="line">11746 jenkins  <span class="number"> 20 </span> <span class="number"> 0 </span><span class="number"> 159972 </span> <span class="number"> 4760 </span> <span class="number"> 1600 </span>R 100.0  0.0 402:57.42 root/2                                                                                                                </span><br><span class="line">  <span class="number"> 42 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   3.3  0.0  16:21.24 [rcu_sched]                                                                                                           </span><br><span class="line">  <span class="number"> 57 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.7  0.0   1:03.01 [rcuos/14]                                                                                                            </span><br><span class="line">  <span class="number"> 63 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.3  0.0   0:29.22 [rcuos/20]                                                                                                            </span><br><span class="line"><span class="number"> 7933 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.3  0.0   0:05.50 [kworker/20:0]                                                                                                        </span><br><span class="line">11414 jenkins  <span class="number"> 20 </span> <span class="number"> 0 </span>42.134g 1.661g <span class="number"> 24516 </span>S   0.3  1.3   2:47.29 /etc/alternatives/java -Dcom.sun.akuma.Daemon=daemonized -Djava.awt.headless=true -DJENKINS_HOME=/var/lib/jenkins -j+ </span><br><span class="line">14702 root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.3  0.0   0:01.48 [kworker/2:0]                                                                                                         </span><br><span class="line">15098 root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.3  0.0   0:01.37 [kworker/6:2]                                                                                                         </span><br><span class="line">18465 txq      <span class="number"> 20 </span> <span class="number"> 0 </span><span class="number"> 158088 </span> <span class="number"> 2720 </span> <span class="number"> 1640 </span>R   0.3  0.0   0:00.18 top -c                                                                                                                </span><br><span class="line">   <span class="number"> 1 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span> <span class="number"> 45892 </span> <span class="number"> 8580 </span> <span class="number"> 3908 </span>S   0.0  0.0   0:13.78 /usr/lib/systemd/systemd --switched-root --system --deserialize<span class="number"> 21 </span>                                                   </span><br><span class="line">   <span class="number"> 2 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.06 [kthreadd]                                                                                                            </span><br><span class="line">   <span class="number"> 3 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.34 [ksoftirqd/0]                                                                                                         </span><br><span class="line">   <span class="number"> 5 </span>root      <span class="number"> 0 </span>-20      <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.00 [kworker/0:0H]                                                                                                        </span><br><span class="line">   <span class="number"> 8 </span>root      rt  <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.35 [migration/0]                                                                                                         </span><br><span class="line">   <span class="number"> 9 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.00 [rcu_bh]                                                                                                              </span><br><span class="line">  <span class="number"> 10 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.00 [rcuob/0]                                                                                                             </span><br><span class="line">  <span class="number"> 11 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.00 [rcuob/1]</span><br></pre></td></tr></table></figure><p>输入<code>q</code>是退出，还有其他命令参数，用到的时候再说，今天先统计这几个。</p><p>版权声明</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> cpu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NumPy 副本和视图</title>
      <link href="/2019/03/13/NumPy-%E5%89%AF%E6%9C%AC%E5%92%8C%E8%A7%86%E5%9B%BE/"/>
      <url>/2019/03/13/NumPy-%E5%89%AF%E6%9C%AC%E5%92%8C%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="NumPy-副本和视图"><a href="#NumPy-副本和视图" class="headerlink" title="NumPy 副本和视图"></a>NumPy 副本和视图</h1><p><strong>副本（赋值）</strong>是一个数据的完整的拷贝，如果我们对副本进行修改，它不会影响到原始数据，物理内存不在同一位置。</p><p><strong>视图（引用）</strong>是数据的一个别称或引用，通过该别称或引用亦便可访问、操作原有数据，但原有数据不会产生拷贝。如果我们对视图进行修改，它会影响到原始数据，物理内存在同一位置。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>视图（引用）一般发生在：</strong></p><ul><li>1、numpy 的切片操作返回原数据的视图。</li><li>2、调用 ndarray 的 view() 函数产生一个视图。</li></ul><p><strong>副本一般发生在：</strong></p><ul><li>Python 序列的切片操作，调用deepCopy()函数。</li><li>调用 ndarray 的 copy() 函数产生一个副本。</li></ul><h2 id="yaya-举例："><a href="#yaya-举例：" class="headerlink" title="yaya 举例："></a>yaya 举例：</h2><p><strong>视图（引用）一般发生在：</strong></p><ul><li>1、numpy 的切片操作返回原数据的视图。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>)  <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b = a[:]   <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">10</span>  <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line">print(a)   <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line"><span class="comment"># 修改b数据值，将修改原数据a的值</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>)  <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b = a[:]   <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b.shape = <span class="number">2</span>,<span class="number">3</span>  <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line">print(b)  </span><br><span class="line"><span class="comment"># [[0 1]</span></span><br><span class="line"><span class="comment">#  [2 3]</span></span><br><span class="line"><span class="comment">#  [4 5]]</span></span><br><span class="line">print(a)   <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line"><span class="comment"># 修改b数据形状，不会修改原数据a的形状</span></span><br></pre></td></tr></table></figure><ul><li>2、调用 ndarray 的 view() 函数产生一个视图。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>)  <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b = a.view()   <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">10</span>  <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line">print(a)   <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line"><span class="comment"># 修改b数据值，将修改原数据a的值</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>)  <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b = a[:]   <span class="comment"># [0 1 2 3 4 5]</span></span><br><span class="line">b.shape = <span class="number">2</span>,<span class="number">3</span>  <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line">print(b)  </span><br><span class="line"><span class="comment"># [[0 1]</span></span><br><span class="line"><span class="comment">#  [2 3]</span></span><br><span class="line"><span class="comment">#  [4 5]]</span></span><br><span class="line">print(a)   <span class="comment"># [10 1 2 3 4 5]</span></span><br><span class="line"><span class="comment"># 修改b数据形状，不会修改原数据a的形状</span></span><br></pre></td></tr></table></figure><p><strong>副本一般发生在：</strong></p><ul><li>Python 序列的切片操作，调用deepCopy()函数。</li><li>调用 ndarray 的 copy() 函数产生一个副本。</li></ul><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><h3 id="无复制-指向同一地址"><a href="#无复制-指向同一地址" class="headerlink" title="无复制 (指向同一地址)"></a>无复制 (指向同一地址)</h3><p>简单的赋值不会创建数组对象的副本。 相反，它使用原始数组的相同id()来访问它。 id()返回 Python 对象的通用标识符，类似于 C 中的指针。</p><p>此外，一个数组的任何变化都反映在另一个数组上。 例如，一个数组的形状改变也会改变另一个数组的形状。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np    </span><br><span class="line">a = np.arange(<span class="number">6</span>)   </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'我们的数组是：'</span>) </span><br><span class="line"><span class="keyword">print</span> (a) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'调用 id() 函数：'</span>) </span><br><span class="line"><span class="keyword">print</span> (id(a)) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'a 赋值给 b：'</span>) </span><br><span class="line">b = a  <span class="keyword">print</span> (b) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'b 拥有相同 id()：'</span>) </span><br><span class="line"><span class="keyword">print</span> (id(b)) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'修改 b 的形状：'</span>) </span><br><span class="line">b.shape =  <span class="number">3</span>,<span class="number">2</span>   </span><br><span class="line"><span class="keyword">print</span> (b) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'a 的形状也修改了：'</span>) </span><br><span class="line"><span class="keyword">print</span> (a)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">我们的数组是：</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">调用 id() 函数：</span><br><span class="line"><span class="number">4349302224</span></span><br><span class="line">a 赋值给 b：</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">b 拥有相同 id()：</span><br><span class="line"><span class="number">4349302224</span></span><br><span class="line">修改 b 的形状：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">a 的形状也修改了：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br></pre></td></tr></table></figure><h3 id="视图或浅拷贝"><a href="#视图或浅拷贝" class="headerlink" title="视图或浅拷贝"></a>视图或浅拷贝</h3><p>ndarray.view() 方会创建一个新的数组对象，该方法创建的新数组的维数更改不会更改原始数据的维数。但是修改新数组的数值将会更改原始数据的数值。</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  numpy  <span class="keyword">as</span>  np  </span><br><span class="line">a = np.arange(<span class="number">6</span>)  </span><br><span class="line"><span class="keyword">print</span>  (<span class="string">'我们的数组是：'</span>)  </span><br><span class="line"><span class="keyword">print</span>  (a)  </span><br><span class="line"><span class="keyword">print</span>  (<span class="string">'调用 id() 函数：'</span>)  </span><br><span class="line"><span class="keyword">print</span>  (id(a))  </span><br><span class="line"><span class="keyword">print</span>  (<span class="string">'a 赋值给 b：'</span>)  </span><br><span class="line">b = a  <span class="keyword">print</span>  (b)  </span><br><span class="line"><span class="keyword">print</span>  (<span class="string">'b 拥有相同 id()：'</span>)  </span><br><span class="line"><span class="keyword">print</span>  (id(b))  </span><br><span class="line"><span class="keyword">print</span>  (<span class="string">'修改 b 的形状：'</span>)  </span><br><span class="line">b.shape = <span class="number">3</span>,<span class="number">2</span>  </span><br><span class="line"><span class="keyword">print</span>  (b)  </span><br><span class="line"><span class="keyword">print</span>  (<span class="string">'a 的形状也修改了：'</span>)  </span><br><span class="line"><span class="keyword">print</span>  (a)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">数组 a：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">创建 a 的视图：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">两个数组的 id() 不同：</span><br><span class="line">a 的 id()：</span><br><span class="line"><span class="number">4314786992</span></span><br><span class="line">b 的 id()：</span><br><span class="line"><span class="number">4315171296</span></span><br><span class="line">b 的形状：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">a 的形状：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br></pre></td></tr></table></figure><p>使用切片创建视图修改数据会影响到原始数组：</p><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np   </span><br><span class="line">arr = np.arange(<span class="number">12</span>) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'我们的数组：'</span>) </span><br><span class="line"><span class="keyword">print</span> (arr) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'创建切片：'</span>) </span><br><span class="line">a=arr[<span class="number">3</span>:] </span><br><span class="line">b=arr[<span class="number">3</span>:] </span><br><span class="line">a[<span class="number">1</span>]=<span class="number">123</span> </span><br><span class="line">b[<span class="number">2</span>]=<span class="number">234</span> </span><br><span class="line">print(arr) </span><br><span class="line">print(id(a),id(b),id(arr[<span class="number">3</span>:]))</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我们的数组：</span><br><span class="line">[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br><span class="line">创建切片：</span><br><span class="line">[  <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span> <span class="number">123</span> <span class="number">234</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>]</span><br><span class="line"><span class="number">4545878416</span> <span class="number">4545878496</span> <span class="number">4545878576</span></span><br></pre></td></tr></table></figure><p>变量 a,b 都是 arr 的一部分视图，对视图的修改会直接反映到原数据中。但是我们观察 a,b 的 id，他们是不同的，也就是说，视图虽然指向原数据，但是他们和赋值引用还是有区别的。</p><h3 id="副本或深拷贝"><a href="#副本或深拷贝" class="headerlink" title="副本或深拷贝"></a>副本或深拷贝</h3><p>ndarray.copy() 函数创建一个副本。 对副本数据进行修改，不会影响到原始数据，它们物理内存不在同一位置。</p><h2 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np    </span><br><span class="line">a = np.array([[<span class="number">10</span>,<span class="number">10</span>],  [<span class="number">2</span>,<span class="number">3</span>],  [<span class="number">4</span>,<span class="number">5</span>]])   </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'数组 a：'</span>) </span><br><span class="line"><span class="keyword">print</span> (a) <span class="keyword">print</span> (<span class="string">'创建 a 的深层副本：'</span>) </span><br><span class="line">b = a.copy()   </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'数组 b：'</span>) </span><br><span class="line"><span class="keyword">print</span> (b) <span class="comment"># b 与 a 不共享任何内容   </span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">'我们能够写入 b 来写入 a 吗？'</span>) </span><br><span class="line"><span class="keyword">print</span> (b <span class="keyword">is</span> a) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'修改 b 的内容：'</span>) </span><br><span class="line">b[<span class="number">0</span>,<span class="number">0</span>]  =  <span class="number">100</span>   </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'修改后的数组 b：'</span>) </span><br><span class="line"><span class="keyword">print</span> (b) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'a 保持不变：'</span>) </span><br><span class="line"><span class="keyword">print</span> (a)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">数组 a：</span><br><span class="line">[[<span class="number">10</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>]]</span><br><span class="line">创建 a 的深层副本：</span><br><span class="line">数组 b：</span><br><span class="line">[[<span class="number">10</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>]]</span><br><span class="line">我们能够写入 b 来写入 a 吗？</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">修改 b 的内容：</span><br><span class="line">修改后的数组 b：</span><br><span class="line">[[<span class="number">100</span>  <span class="number">10</span>]</span><br><span class="line"> [  <span class="number">2</span>   <span class="number">3</span>]</span><br><span class="line"> [  <span class="number">4</span>   <span class="number">5</span>]]</span><br><span class="line">a 保持不变：</span><br><span class="line">[[<span class="number">10</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>]]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> numpy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python  面试</title>
      <link href="/2019/03/12/python-%E9%9D%A2%E8%AF%95/"/>
      <url>/2019/03/12/python-%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5b6bc1d16fb9a04f9c43edc3" target="_blank" rel="noopener">https://juejin.im/post/5b6bc1d16fb9a04f9c43edc3</a></p><p><a href="https://juejin.im/post/5b8505b6e51d4538884d22bf" target="_blank" rel="noopener">https://juejin.im/post/5b8505b6e51d4538884d22bf</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础： 深入理解 python 中的赋值、引用、拷贝、作用域</title>
      <link href="/2019/03/12/python%E5%9F%BA%E7%A1%80%EF%BC%9A-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-python-%E4%B8%AD%E7%9A%84%E8%B5%8B%E5%80%BC%E3%80%81%E5%BC%95%E7%94%A8%E3%80%81%E6%8B%B7%E8%B4%9D%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2019/03/12/python%E5%9F%BA%E7%A1%80%EF%BC%9A-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-python-%E4%B8%AD%E7%9A%84%E8%B5%8B%E5%80%BC%E3%80%81%E5%BC%95%E7%94%A8%E3%80%81%E6%8B%B7%E8%B4%9D%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="浅复制："><a href="#浅复制：" class="headerlink" title="浅复制："></a>浅复制：</h3><ul><li>仅复制对象的引用，而不开辟内存，即，改变复制后的对象时，其实是在改变原对象内存中的内容。</li><li>b = a[ : ]<h3 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a>深复制</h3>将开辟新的内存，把原对象内存中的内容复制到新的内存中来，如果改变复制后的对象，将改变原对象的内容。即，这两个对象在完成复制之后，已经是两个独立的对象了</li></ul><p><strong>- 转载： <a href="https://draapho.github.io/2016/11/21/1618-python-variable/" target="_blank" rel="noopener">https://draapho.github.io/2016/11/21/1618-python-variable/</a></strong></p><h3 id="可变对象：list-dict-set-（引用传递）"><a href="#可变对象：list-dict-set-（引用传递）" class="headerlink" title="可变对象：list dict set  （引用传递）"></a>可变对象：list dict set  （引用传递）</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta"># list</span></span><br><span class="line">a= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">9</span></span><br><span class="line"><span class="keyword">print</span>(b) <span class="meta"># [9, 2, 3]</span></span><br><span class="line"><span class="keyword">print</span>(a) <span class="meta"># [9, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># dict</span></span><br><span class="line">a = &#123;&#125;</span><br><span class="line">a['key1'] = <span class="number">1</span></span><br><span class="line">b = a</span><br><span class="line">b['key1'] = <span class="number">9</span></span><br><span class="line"><span class="keyword">print</span>(b) <span class="meta"># &#123;'key1': 9&#125;</span></span><br><span class="line"><span class="keyword">print</span>(a) <span class="meta"># &#123;'key1': 9&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]  </span><br><span class="line">values[<span class="number">1</span>] = values  </span><br><span class="line">values  </span><br><span class="line">[<span class="number">0</span>, [...], <span class="number">2</span>] # 实际结果, 为何要赋值无限次?  </span><br><span class="line">[<span class="number">0</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="number">2</span>] # 预想结果</span><br></pre></td></tr></table></figure><p>   Python 没有赋值，只有引用。你这样相当于创建了一个引用自身的结构，所以导致了无限循环</p><h3 id="不可变对象：tuple-string-int-float-bool-（值传递）"><a href="#不可变对象：tuple-string-int-float-bool-（值传递）" class="headerlink" title="不可变对象：tuple string int float bool （值传递）"></a>不可变对象：<strong><em>tuple</em></strong> string int float bool （值传递）</h3><p>对于可变对象，对象的操作不会重建对象，而对于不可变对象，每一次操作就重建新的对象。</p><pre><code>def func_int(a):    a += 4def func_list(a_list):    a_list[0] = 4t = 0func_int(t)print t# output: 0t_list = [1, 2, 3]func_list(t_list)print t_list# output: [4, 2, 3]</code></pre><h3 id="Dictionary-与-List-与-Tuple的区别"><a href="#Dictionary-与-List-与-Tuple的区别" class="headerlink" title="Dictionary 与 List 与 Tuple的区别"></a>Dictionary 与 List 与 Tuple的区别</h3><p>元组和列表在结构上没有什么区别，唯一的差异在于元组是只读的，不能修改。</p><p><strong>Dictionary</strong> </p><ol><li>Dictionary 是 Python 的内置数据类型之一, 它定义了键和值之间一对一的关系。</li><li>每一个元素都是一个 key-value 对, 整个元素集合用大括号括起来</li><li>您可以通过 key 来引用其值, 但是不能通过值获取 key</li><li>在一个 dictionary 中不能有重复的 key。给一个存在的 key 赋值会覆盖原有的值。 <a href="file:///home/echo/.chmsee/bookshelf/4791a2294b7b1d4cf68b0e1df606181d/native_data_types/index.html#odbchelper.dict.2.2" target="_blank" rel="noopener"><img src="file:///home/echo/.chmsee/bookshelf/4791a2294b7b1d4cf68b0e1df606181d/images/callouts/2.png" alt="2"></a> 在任何时候都可以加入新的 key-value 对。这种语法同修改存在的值是一样的。</li><li>当使用 dictionary 时, 您需要知道: dictionary 的 key 是大小写敏感的</li><li>Dictionary 不只是用于存储字符串。Dictionary 的值可以是任意数据类型, 包括字符串, 整数, 对象, 甚至其它的 dictionary。在单个 dictionary 里, dictionary 的值并不需要全都是同一数据类型, 可以根据需要混用和匹配。 Dictionary 的 key 要严格多了, 但是它们可以是字符串, 整数和几种其它的类型 (后面还会谈到这一点) 。也可以在一个 dictionary 中混用和配匹 key 的数据类型</li><li><code>del</code> 允许您使用 key 从一个 dictionary 中删除独立的元素。</li><li><code>clear</code> 从一个 dictionary 中清除所有元素。注意空的大括号集合表示一个没有元素的 dictionary。</li></ol><hr><p><strong>List</strong> </p><ol><li>list是一个使用方括号括起来的有序元素集合。</li><li>List 可以作为以 0 下标开始的数组。任何一个非空 list 的第一个元素总是 <code>li[0]</code></li><li><code>负数索引从 list 的尾部开始向前计数来存取元素。任何一个非空的 list 最后一个元素总是</code> li[-1]。 <a href="file:///home/echo/.chmsee/bookshelf/4791a2294b7b1d4cf68b0e1df606181d/native_data_types/lists.html#odbchelper.list.2.2" target="_blank" rel="noopener"><img src="file:///home/echo/.chmsee/bookshelf/4791a2294b7b1d4cf68b0e1df606181d/images/callouts/2.png" alt="2"></a>如果负数索引使您感到糊涂, 可以这样理解: <code>li[-n] == li[len(li) - n]</code>。 所以在这个 list 里, <code>li[-3] == li[5 - 3] == li[2]</code>。</li><li><code>您可以通过指定 2 个索引得到 list 的子集, 叫做一个 “slice” 。返回值是一个新的 list, 它包含了 list 中按顺序从第一个 slice 索引 (这里为</code> li[1]) 开始, 直到但是不包括第二个 slice 索引 (这里为<code>li[3]</code>) 的所有元素。</li><li><code>如果将两个分片索引全部省略, 这将包括 list 的所有元素。但是与原始的名为</code> li 的 list 不同, 它是一个新 list, 恰好拥有与 <code>li</code> 一样的全部元素。<code>li[:]</code> 是生成一个 list 完全拷贝的一个简写。</li><li><code>``append</code> 向 list 的末尾追加单个元素。</li><li><code>insert</code> 将单个元素插入到 list 中。数值参数是插入点的索引。请注意, list 中的元素不必唯一, 有有两个独立的元素具有 <code>&#39;new&#39;</code> 这个相同的值<code>。</code></li><li><code>extend</code> 用来连接 list。请注意不要使用多个参数来调用 <code>extend</code>, 要使用一个 list 参数进行调用。</li><li>Lists 的两个方法 <code>extend</code> 和 <code>append</code> 看起来类似, 但实际上完全不同。 <code>extend</code> 接受一个参数, 这个参数总是一个 list, 并且添加这个 list 中的每个元素到原 list 中</li><li>另一方面, <code>append</code> 接受一个参数, 这个参数可以是任何数据类型, 并且简单地追加到 list 的尾部。 在这里使用一个含有 3 个元素的 list 参数调用 <code>append</code> 方法。</li><li><code>index</code> 在 list 中查找一个值的首次出现并返回索引值。</li><li>要测试一个值是否在 list 内, 使用 <code>in</code>, 如果值存在, 它返回 <code>True</code>, 否则返为 <code>False</code> 。</li><li><code>remove</code> 从 list 中删除一个值的首次出现。</li><li><code>pop</code> 是一个有趣的东西。它会做两件事: 删除 list 的最后一个元素, 然后返回删除元素的值。请注意, 这与 <code>li[-1]</code> 不同, 后者返回一个值但不改变 list 本身。也不同于 <code>li.remove(*value*)</code>, 后者改变 list 但并不返回值。</li><li>Lists 也可以用 <code>+</code> 运算符连接起来。 <code>*list* = *list* + *otherlist*</code> 相当于 <code>*list*.extend(*otherlist*)</code>。 但 <code>+</code>运算符把一个新 (连接后) 的 list 作为值返回, 而 <code>extend</code> 只修改存在的 list。 也就是说, 对于大型 list 来说, <code>extend</code> 的执行速度要快一些。</li><li>Python 支持 <code>+=</code> 运算符。 <code>li += [&#39;two&#39;]</code> 等同于 <code>li.extend([&#39;two&#39;])</code>。 <code>+=</code> 运算符可用于 list, 字符串和整数, 并且它也可以被重载用于用户自定义的类中。</li><li><code>*</code> 运算符可以作为一个重复器作用于 list。 <code>li = [1, 2] * 3</code> 等同于 <code>li = [1, 2] + [1, 2] + [1, 2]</code>, 即将三个 list 连接成一个。</li></ol><hr><p><strong>Tuple</strong></p><ol><li>​    Tuple是不可变的list.一是创建了一个tuple就不能以任何方式改变它.</li><li>​    定义tuple与定义list的方式相同,除了整个元素集是用小括号包围的而不是方括号.</li><li>　 Tuple的元素与list一样按定义的次序进行排序.Tuples的索引与list一样从0开始,所以一个非空的tuple的第一个元素总是t[0].</li><li>​    负数索引与 list 一样从 tuple 的尾部开始计数。</li><li>​    与 list 一样分片 (slice) 也可以使用。注意当分割一个 list 时, 会得到一个新的 list ；当分割一个 tuple 时, 会得到一个新的 tuple。</li><li>​    Tuple 没有方法：没有 <code>append</code> 或 <code>extend</code> 方法、没有 <code>remove</code> 或 <code>pop</code> 方法、没有 <code>index</code> 方法、可以使用 <code>in</code> 来查看一个元素是否存在于 tuple 中。</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(LSTM_TSA)Video Captioning with Transferred Semantic Attributes</title>
      <link href="/2019/03/03/LSTM-TSA-Video-Captioning-with-Transferred-Semantic-Attributes/"/>
      <url>/2019/03/03/LSTM-TSA-Video-Captioning-with-Transferred-Semantic-Attributes/</url>
      
        <content type="html"><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>在这篇文章中，我们提出了一个 Long Short-Term Memory with Transferred Semantic Attributes （LSTM-TSA）model，这是一个新颖的结构，可以将从images 和 videos 中学习到的transferred semantic attributes  结合到 encoder - decoder 结构中去。</p>]]></content>
      
      
      <categories>
          
          <category> 视频描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 视频描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytorch-Multi-Gpus</title>
      <link href="/2019/03/02/pytorch-Multi-Gpus/"/>
      <url>/2019/03/02/pytorch-Multi-Gpus/</url>
      
        <content type="html"><![CDATA[<ul><li>源为pytorch的官方文档</li><li><a href="https://pytorch.org/tutorials/beginner/blitz/data_parallel_tutorial.html" target="_blank" rel="noopener">website</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset, DataLoader</span><br><span class="line"></span><br><span class="line"><span class="comment"># Parameters and DataLoaders</span></span><br><span class="line">input_size = <span class="number">5</span></span><br><span class="line">output_size = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">30</span></span><br><span class="line">data_size = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="comment"># Our model</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_size, output_size)</span>:</span></span><br><span class="line">        super(Model, self).__init__()</span><br><span class="line">        self.fc = nn.Linear(input_size, output_size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, input)</span>:</span></span><br><span class="line">        output = self.fc(input)</span><br><span class="line">        print(<span class="string">"\tIn Model: input size"</span>, input.size(),</span><br><span class="line">              <span class="string">"output size"</span>, output.size())</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomDataset</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, size, length)</span>:</span></span><br><span class="line">        self.len = length</span><br><span class="line">        self.data = torch.randn(length, size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.data[index]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.len</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rand_loader = DataLoader(dataset=RandomDataset(input_size, data_size), batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">model = Model(input_size, output_size)</span><br><span class="line"><span class="keyword">if</span> torch.cuda.device_count() &gt; <span class="number">1</span>:</span><br><span class="line">    print(<span class="string">"Let's use"</span>, torch.cuda.device_count(), <span class="string">"GPUs!"</span>)</span><br><span class="line">    <span class="comment"># dim = 0 [30, xxx] -&gt; [10, ...], [10, ...], [10, ...] on 3 GPUs</span></span><br><span class="line">    model = nn.DataParallel(model)</span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">"cuda:0"</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line">model.to(device)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> rand_loader:</span><br><span class="line">    input = data.to(device)</span><br><span class="line">    output = model(input)</span><br><span class="line">    print(<span class="string">"Outside: input size"</span>, input.size(),</span><br><span class="line">          <span class="string">"output_size"</span>, output.size())</span><br></pre></td></tr></table></figure><h2 id="转载：-PyTorch-论文pytorch复现中遇到的BUG-https-www-cnblogs-com-kk17-p-10139884-html"><a href="#转载：-PyTorch-论文pytorch复现中遇到的BUG-https-www-cnblogs-com-kk17-p-10139884-html" class="headerlink" title="转载：[[PyTorch]论文pytorch复现中遇到的BUG]](https://www.cnblogs.com/kk17/p/10139884.html)"></a>转载：[[PyTorch]论文pytorch复现中遇到的BUG]](<a href="https://www.cnblogs.com/kk17/p/10139884.html" target="_blank" rel="noopener">https://www.cnblogs.com/kk17/p/10139884.html</a>)</h2><ul><li>我在Multi-GPUs时，也遇到了第一个问题</li></ul><p>目录</p><ul><li><a href="https://www.cnblogs.com/kk17/p/10139884.html#zip-argument-1-must-support-iteration" target="_blank" rel="noopener">1. zip argument #1 must support iteration</a></li><li><a href="https://www.cnblogs.com/kk17/p/10139884.html#torch.nn.dataparallel" target="_blank" rel="noopener">2. torch.nn.DataParallel</a></li><li><a href="https://www.cnblogs.com/kk17/p/10139884.html#model.state_dict" target="_blank" rel="noopener">3. model.state_dict()</a></li></ul><h1 id="1-zip-argument-1-must-support-iteration"><a href="#1-zip-argument-1-must-support-iteration" class="headerlink" title="1. zip argument #1 must support iteration"></a>1. zip argument #1 must support iteration</h1><p>在多gpu训练的时候，自动把你的batch_size分成n_gpu份，每个gpu跑一些数据， 最后再合起来。我之所以出现这个bug是因为返回的时候 返回了一个常量。。</p><h1 id="2-torch-nn-DataParallel"><a href="#2-torch-nn-DataParallel" class="headerlink" title="2. torch.nn.DataParallel"></a>2. torch.nn.DataParallel</h1><p>在使用torch.nn.DataParallel时候，要先把模型放在gpu上，再进行parallel。</p><h1 id="3-model-state-dict"><a href="#3-model-state-dict" class="headerlink" title="3. model.state_dict()"></a>3. model.state_dict()</h1><p>一般在现有的网络加载预训练模型通常是找到预训练模型在现有的model里面的参数，然后model进行更新，遇到一个bug， 发现加载预训练模型的时候， 效果很差，跟参数没有更新一样，找了一大顿bug，最后才发现，之前是单gpu进行的预训练，现在的模型使用的是多gpu， 打印现在模型的参数你会发现他所有的参数前面都加了一个module. 所以向以前一样更新，没有一个参数会被更新，因此写了一个万能模型参数加载函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pretrained_dict = checkpoint[<span class="string">'state_dict'</span>]</span><br><span class="line">model_dict = self.model.state_dict()</span><br><span class="line"><span class="keyword">if</span> checkpoint[<span class="string">'config'</span>][<span class="string">'n_gpu'</span>] &gt; <span class="number">1</span> <span class="keyword">and</span> self.config[<span class="string">'n_gpu'</span>] == <span class="number">1</span>:</span><br><span class="line">    new_dict = OrderedDict()</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> pretrained_dict.items():</span><br><span class="line">        name = k[<span class="number">7</span>:]</span><br><span class="line">        new_dict[name] = v</span><br><span class="line">    pretrained_dict = new_dict</span><br><span class="line"><span class="keyword">elif</span> checkpoint[<span class="string">'config'</span>][<span class="string">'n_gpu'</span>] == <span class="number">1</span> <span class="keyword">and</span> self.config[<span class="string">'n_gpu'</span>] &gt; <span class="number">1</span>:</span><br><span class="line">    new_dict = OrderedDict()</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> pretrained_dict.items():</span><br><span class="line">        name = <span class="string">"module."</span>+k</span><br><span class="line">        new_dict[name] = v</span><br><span class="line">    pretrained_dict = new_dict</span><br><span class="line">print(<span class="string">"The pretrained model's para is following"</span>)</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> pretrained_dict.items():</span><br><span class="line">    print(k)</span><br><span class="line">pretrained_dict = &#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> pretrained_dict.items() <span class="keyword">if</span> k <span class="keyword">in</span> model_dict&#125;</span><br><span class="line">model_dict.update(pretrained_dict)</span><br><span class="line">self.model.load_state_dict(model_dict)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>coco-detection</title>
      <link href="/2019/03/02/coco-detection/"/>
      <url>/2019/03/02/coco-detection/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spatio-Temporal Dynamics and Semantic Attribute Enriched Visual Encoding for Video Captioning</title>
      <link href="/2019/03/01/Spatio-Temporal-Dynamics-and-Semantic-Attribute-Enriched-Visual-Encoding-for-Video-Captioning/"/>
      <url>/2019/03/01/Spatio-Temporal-Dynamics-and-Semantic-Attribute-Enriched-Visual-Encoding-for-Video-Captioning/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>nltk-tokenize</title>
      <link href="/2019/02/28/nltk-tokenize/"/>
      <url>/2019/02/28/nltk-tokenize/</url>
      
        <content type="html"><![CDATA[<p>转载：<a href="https://pythonprogramming.net/tokenizing-words-sentences-nltk-tutorial/" target="_blank" rel="noopener">https://pythonprogramming.net/tokenizing-words-sentences-nltk-tutorial/</a></p><p>Next, you’re going to need NLTK 3. The easiest method to installing the NLTK module is going to be with pip.</p><p>For all users, that is done by opening up cmd.exe, bash, or whatever shell you use and typing:<br><code>pip install nltk</code></p><p>These are the words you will most commonly hear upon entering the Natural Language Processing (NLP) space, but there are many more that we will be covering in time. With that, let’s show an example of how one might actually tokenize something into tokens with the NLTK module.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from nltk<span class="selector-class">.tokenize</span> import sent_tokenize, word_tokenize</span><br><span class="line"></span><br><span class="line">EXAMPLE_TEXT = <span class="string">"Hello Mr. Smith, how are you doing today? The weather is great, and Python is awesome. The sky is pinkish-blue. You shouldn't eat cardboard."</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(sent_tokenize(EXAMPLE_TEXT)</span></span>)</span><br></pre></td></tr></table></figure><p>At first, you may think tokenizing by things like words or sentences is a rather trivial enterprise. For many sentences it can be. The first step would be likely doing a simple .split(‘. ‘), or splitting by period followed by a space. Then maybe you would bring in some <a href="https://pythonprogramming.net/regular-expressions-regex-tutorial-python-3/" target="_blank" rel="noopener"><strong>regular expressions</strong></a> to split by period, space, and then a capital letter. The problem is that things like Mr. Smith would cause you trouble, and many other things. Splitting by word is also a challenge, especially when considering things like concatenations like we and are to we’re. NLTK is going to go ahead and just save you a ton of time with this seemingly simple, yet very complex, operation.</p><p>The above code will output the sentences, split up into a list of sentences, which you can do things like iterate through with a <a href="https://pythonprogramming.net/loop-python-3-basics-tutorial/" target="_blank" rel="noopener"><strong>for loop</strong></a>.<br><code>[&#39;Hello Mr. Smith, how are you doing today?&#39;, &#39;The weather is great, and Python is awesome.&#39;, &#39;The sky is pinkish-blue.&#39;, &quot;You shouldn&#39;t eat cardboard.&quot;]</code></p><p>So there, we have created tokens, which are sentences. Let’s tokenize by word instead this time:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="name">word_tokenize</span>(<span class="name">EXAMPLE_TEXT</span>))</span><br></pre></td></tr></table></figure><p>Now our output is: <code>[&#39;Hello&#39;, &#39;Mr.&#39;, &#39;Smith&#39;, &#39;,&#39;, &#39;how&#39;, &#39;are&#39;, &#39;you&#39;, &#39;doing&#39;, &#39;today&#39;, &#39;?&#39;, &#39;The&#39;, &#39;weather&#39;, &#39;is&#39;, &#39;great&#39;, &#39;,&#39;, &#39;and&#39;, &#39;Python&#39;, &#39;is&#39;, &#39;awesome&#39;, &#39;.&#39;, &#39;The&#39;, &#39;sky&#39;, &#39;is&#39;, &#39;pinkish-blue&#39;, &#39;.&#39;, &#39;You&#39;, &#39;should&#39;, &quot;n&#39;t&quot;, &#39;eat&#39;, &#39;cardboard&#39;, &#39;.&#39;]</code></p><p>There are a few things to note here. First, notice that punctuation is treated as a separate token. Also, notice the separation of the word “shouldn’t” into “should” and “n’t.” Finally, notice that “pinkish-blue” is indeed treated like the “one word” it was meant to be turned into. Pretty cool!</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Maxout Networks</title>
      <link href="/2019/02/27/Maxout-Networks/"/>
      <url>/2019/02/27/Maxout-Networks/</url>
      
        <content type="html"><![CDATA[<p>本文是蒙特利尔大学信息与信息技术学院的几位大牛2013年在ICML上发表的一篇论文，提出了一种叫maxout的新模型，到目前用的比较少，可能这个算法参数个数会成k倍增加(k是maxout的一个参数)。文中提到这样命名的原因：（1）它的输出是一组输入的最大值（2）它与dropout是天然的组合。</p><p>文章首先肯定了dropout的意义，从音频分类到超大规模物体识别都有很好的改进，同时提出不应该把dropout作为一个适用于任意模型的轻微性能增强，而是通过直接设计一个模型来提高dropout能力，作为模型平均技术，可以获得最好的性能。</p><p>Dropout：</p><ul><li>dropout可以训练集成模型，它们共享参数并近似的对这些模型的预测进行了平均。它可以被当作一种通用的方法用在任何一种MLP和CNN模型中，但是在论文中，由于dropout的模型平均过程没有被证明，因而一个模型最好的性能的获得，应该通过直接设计这个模型使之可以增强dropout的模型平均的能力。使用了dropout的训练过程和一般的SGD方法完全不同。dropout在更新时使用更大的步长最有效，因为这样可以在不同的训练子集上对不同的模型有明显的影响来使得目标函数有持续的波动性，理想情况下整个训练过程就类似于使用bagging来训练集成的模型（带有参数共享的约束）。而一般的SGD更新时会使用更小的步长，来使得目标函数平滑的下降。对于深度网络模型，dropout只能作为模型平均的一种近似，显式的设计模型来最小化这种近似误差也可以提高dropout的性能。</li><li>dropout训练的集成模型中，所有模型都只包括部分输入和部分隐层参数。对每一个训练样本，我们都会训练一个包括不同隐层参数的子模型。dropout与bagging的相同点是不同的模型使用不同数据子集，不同点是dropout的每个模型都只训练一次且所有模型共享参数。</li><li>对于预测时如何平均所有子模型的问题，bagging一般使用的是算数平均，而对dropout产生的指数多个子模型则并非显而易见。但是如果模型只有一层 <img src="https://www.zhihu.com/equation?tex=p%28y+%7C+v%3B%CE%B8%29%3Dsoftmax%28v%5E%7BT%7D%2Bb%29" alt="p(y | v;θ)=softmax(v^{T}+b)">作为输出（p(y | v;θ)的几何平均），则最终的预测分布就是简单的 <img src="https://www.zhihu.com/equation?tex=softmax%28v%5E%7BT%7DW%2F2%2Bb%29" alt="softmax(v^{T}W/2+b)">，即指数多个子模型的平均预测就是完整模型的预测仅仅将权重减半而已。这个结果只能用在单softmax层的模型中，如果是深层模型如MLP，那么权重减半的方法只是几何平均的一种近似。</li></ul><p>Maxout是深度学习网络中的一层网络，就像池化层、卷积层一样等，我们可以把maxout 看成是网络的激活函数层。我们假设网络某一层的输入特征向量为：X=（x1,x2,……xd），也就是我们输入是d个神经元。Maxout隐藏层每个神经元的计算公式如下：</p><p><img src="https://www.zhihu.com/equation?tex=h_%7Bi%7D%3D%5Cmax_%7Bj+%5Cin+%5B1%2Ck%5D%7D%7Bz_%7Bij%7D%7D" alt="h_{i}=\max_{j \in [1,k]}{z_{ij}}"></p><p>上面的公式就是maxout隐藏层神经元i的计算公式。其中，k就是maxout层所需要的参数了，由我们人为设定大小。就像dropout一样，也有自己的参数p(每个神经元dropout概率)，maxout的参数是k。公式中Z的计算公式为： <img src="https://www.zhihu.com/equation?tex=z_%7Bij%7D%3Dx%5E%7BT%7DW_%7B..ij%7D%2Bb_%7Bij%7D" alt="z_{ij}=x^{T}W_{..ij}+b_{ij}"> ，权重w是一个大小为(d,m,k)三维矩阵，b是一个大小为(m,k)的二维矩阵，这两个就是我们需要学习的参数。如果我们设定参数k=1，那么这个时候，网络就类似于以前我们所学普通的MLP网络。</p><p>我们可以这么理解，本来传统的MLP算法在第i层到第i+1层，参数只有一组，然而现在我们不怎么干了，我们在这一层同时训练n组参数，然后选择激活值最大的作为下一层神经元的激活值。下面还是用一个例子进行讲解，比较容易搞懂。</p><p>（1）以前MLP的方法。<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0ldm6b5ujj30ix08mdg0.jpg"></p><p>其中 f 就是我们所谓的激活函数，比如Sigmod、Relu、Tanh等。</p><p>(2)Maxout 的方法。如果我们设置maxout的参数k=5，maxout层就如下所示：<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0ldmxgg2zj30n60e33zh.jpg"></p><p>相当于在每个输出神经元前面又多了一层。这一层有5个神经元。<br>所以这就是为什么采用maxout的时候，参数个数成k倍增加的原因。本来我们只需要一组参数就够了，采用maxout后，就需要有k组参数。</p><ul><li>对MLP而言，2个输入节点先构成5个“隐隐层”节点，然后在5个“隐隐层”节点中使用最大的构成了本层的一个节点，本层其他节点类似。<strong>实现技巧：</strong><code>maxout</code>和<code>relu</code>唯一的区别是，<code>relu</code>使用的max(x,0)是对隐层每一个单元执行的与0比较最大化操作，而<code>maxout</code>是对5个“隐隐层”单元的值执行最大化操作。如果将“隐隐层”单元在隐层展开，那么隐层就有20个“隐隐层”单元，<code>maxout</code>做的就是在这20个中每5个取一个最大值作为最后的隐层单元，最后的隐层单元仍然为4个。这里每5个取一个最大值也称为最大池化步长（max pooling stride）为5，最大池化步长默认和“隐隐层”个数相等，如果步长更小，则可以实现重叠最大池化。实现的时候，可以将隐层单元数设置为20个，权重维度（2，20）偏置维度（1，20），然后在20个中每5个取一个最大值得到4个隐层单元。</li><li>对于CNN而言，假设上一层有2个特征图，本层有4个特征图，那么就是将输入的2个特征图用5个滤波器卷积得到5张仿射特征图（affine feature maps），然后从这5张仿射特征图每个位置上选择最大值（跨通道池化，pool across channels）构成一张本层的特征图，本层其他特征图类似。<strong>实现技巧：</strong><code>relu</code>使用的max(x,0)是对每个通道的特征图的每一个单元执行的与0比较最大化操作，而<code>maxout</code>是对5个通道的特征图在通道的维度上执行最大化操作。而如果把5个特征图在本层展开，那么本层就有20个特征图，<code>maxout</code>做的就是在这20个中每5个取在通道维度上的最大值作为最后的特征图，最后本层特征图仍然为4个。同样最大池化步长默认为5。实现的时候，可以将本层特征图数设置为20个，权重维度（20，2，3，3）偏置维度（1，20，1，1），然后在20个中每5个取一个最大特征图得到4个特征图。<strong>注意：</strong> 对于CNN而言，在maxout输出后如果连接一个一般的降采样最大池化层，则可以将这个降采样最大池化融合进跨通道池化中，即在仿射特征图的每个池化窗口中选择最大值（相当于同时在通道间和空间取最大值）。这样就可以在maxout网络中省略显式的降采样最大池化层。</li></ul><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><ol><li>MNIST</li></ol><p>排列不变限制的MNIST（MNIST with permutation invariant，即像素排列顺序可以改变，输入的数据是2维的），使用两个全连接maxout层再接上一个softmax层，结合dropout和权重衰减。验证集选取训练集中后10000个样本。在得到最小的验证集误差时记录下前50000个样本的训练集对数似然L，接着在整个60000样本的训练集上<strong>继续训练</strong>直到验证集的对数似然达到L。<em>0.94%</em></p><p>无排列不变限制的MNIST（MNIST without permutation invariant，即像素排列顺序不变，输入的数据是3维的），使用三个卷积maxout层，之后接上空间最大池化层，最后接上一个softmax层。还可以使用扩充数据集的方法进一步提高。<em>0.45%</em></p><p>\2. CIFAR-10</p><p>预处理：全局像素归一化和ZCA白化</p><p>过程与MNIST类似，只是将继续训练改为了<strong>重新训练</strong>，因为继续训练的学习率很低训练太久。</p><p>使用三个卷积maxout层，之后接上全连接maxout层，最后接上一个softmax层。<em>13.2%</em>（不使用验证集数据）<em>11.68%</em>（使用验证集数据）<em>9.35%</em>（使用平移、水平翻转的扩充数据集）</p><p>\3. CIFAR-100</p><p>超参数使用和CIFAR-10一样</p><p><em>41.48%</em>（不使用验证集数据）<em>38.57%</em>（使用验证集数据）</p><p>\4. SVHN</p><p>验证集为训练集每类选取400个样本和额外集每类选取200个样本，其他的为训练集。</p><p>预处理：局部像素归一化</p><p>使用三个卷积maxout层，之后接上全连接maxout层，最后接上一个softmax层（同CIFAR-10）。<em>2.47%</em></p><h2 id="maxout对比relu"><a href="#maxout对比relu" class="headerlink" title="maxout对比relu"></a>maxout对比relu</h2><ul><li>跨通道池化可以减少网络状态并减少模型所需要的参数。</li><li>对于maxout，性能与跨通道池化时滤波器数量有很大关系，但对relu，性能与输出单元的数量没有关系，也就是relu并不从跨通道池化中受益。</li><li>要让relu达到maxout的表现，需要使之具有和maxout相同数量的滤波器（即使用比原来k倍的滤波器，同样也要k倍的relu单元），但网络状态和所需要的参数也是原来的k倍，也是对应maxout的k倍。</li></ul><h2 id="模型平均"><a href="#模型平均" class="headerlink" title="模型平均"></a>模型平均</h2><ul><li>单层softmax有对模型进行平均的能力，但是通过观察，多层模型中使用dropout也存在这样的模型平均，只是有拟合精度的问题。</li><li>训练中使用dropout使得maxout单元有了更大的输入附近的线性区域，因为每个子模型都要预测输出，每个maxout单元就要学习输出相同的预测而不管哪些输入被丢弃。改变dropout mask将经常明显移动有效输入，从而决定了输入被映射到分段线性函数的哪一段。使用dropout训练的maxout具有一种特性，即当dropout mask改变时每个maxout单元的最大化滤波器相对很少变化。</li><li>maxout网络中的线性和最大化操作可以让dropout的拟合模型平均的精度很高。而一般的激活函数几乎处处都是弯曲的，因而dropout的拟合模型平均的精度不高。</li></ul><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ul><li>训练中使用dropout时，maxout的优化性能比relu+max pooling好</li><li>dropout使用更大的步长最有效，使得目标函数有持续的波动性。而一般的SGD会使用更小的步长，来使得目标函数平滑的下降。dropout快速的探索着许多不同的方向然后拒绝那些损害性能的方向，而SGD缓慢而平稳的朝向最可能的方向移动。</li><li>实验中SGD使得relu饱和在0值的时间少于5%，而dropout则超过60%。由于relu激活函数中的0值是一个常数，这就会阻止梯度在这些单元上传播（无论正向还是反向），这也就使得这些单元很难再次激活，这会导致很多单元由激活转变为非激活。而maxout就不会存在这样的问题，梯度在maxout单元上总是能够传播，即使maxout出现了0值，但是这些0值是参数的函数可以被改变，从而maxout单元总是激活的。单元中较高比例的且不易改变的0值会损害优化性能。</li><li>dropout要求梯度随着dropout mask的改变而明显改变，而一旦梯度几乎不随着dropout mask的改变而改变时，dropout就简化成为了SGD。relu网络的低层部分会有梯度衰减的问题（梯度的方差在高层较大而反向传播到低层后较小）。maxout更好的将变化的信息反向传播到低层并帮助dropout以类似bagging的方式训练低层参数。relu则由于饱和使得梯度损失，导致dropout在低层的训练类似于一般的SGD。</li></ul><h2 id="总结文中的点"><a href="#总结文中的点" class="headerlink" title="总结文中的点"></a>总结文中的点</h2><ul><li>单个<code>maxout</code>激活函数可以理解成一种分段线性函数来近似任意凸函数（任意的凸函数都可由分段线性函数来拟合）。它在每处都是局部线性的（k个“隐隐层”节点都是线性的，取其最大值则为局部线性，分段的个数与k值有关），而一般的激活函数都有明显的曲率。</li><li>如同MLP一样，maxout网络也可以拟合任意连续函数。只要<code>maxout</code>单元含有任意多个“隐隐层”节点，那么只要两个隐层的maxout网络就可以实现任意连续函数的近似。</li><li>maxout网络不仅可以学习到隐层之间的关系，还可以学习到每个隐层单元的激活函数。</li><li>maxout放弃了传统激活函数的设计，它产生的表示不再是稀疏的，但是它的梯度是稀疏的，且dropout可以将它稀疏化。</li><li>maxout没有上下界，所以让它在某一端饱和是零概率事件。</li><li>如果训练时使用dropout，则dropout操作在矩阵相乘之前，而并不对<code>max</code>操作的输入执行dropout。</li><li>使用maxout会默认一个先验：样本集是凸集可分的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python:理解 yield 关键字</title>
      <link href="/2019/02/25/Python-%E7%90%86%E8%A7%A3-yield-%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2019/02/25/Python-%E7%90%86%E8%A7%A3-yield-%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<pre><code>转载：https://liam.page/2017/06/30/understanding-yield-in-python/</code></pre><h1 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h1><p>为了理解<a href="https://github.com/sususushi/reconstruction-network-for-video-captioning" target="_blank" rel="noopener">reconstruction-network</a> 代码中，如下代码是如何实现的，查看了此篇博客，并转载。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cycle</span><span class="params">(iterable)</span>:</span>  </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> iterable:  </span><br><span class="line">            <span class="keyword">yield</span> x</span><br><span class="line"></span><br><span class="line">train_data_loader = iter(cycle(MSVD.train_data_loader))</span><br><span class="line"><span class="keyword">for</span> iteration, batch <span class="keyword">in</span> enumerate(train_data_loader, <span class="number">1</span>):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> iteration == C.train_n_iteration:  </span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>解释：<strong>iter()</strong> 是python的一个函数，用来生成迭代器。而cycle中一整个for循环是对整个数据集调用一遍，而外部又有一个while true，该判断是一直成立的，则，会一直调用数据。因此此处不适用n_epoch 来停止加载数据，而是使用train_n_iteration。</p><hr><p>Python 是非常灵活的语言，其中 <code>yield</code> 关键字是普遍容易困惑的概念。</p><p>此篇将介绍 <code>yield</code> 关键字，及其相关的概念。</p><h2 id="迭代、可迭代、迭代器"><a href="#迭代、可迭代、迭代器" class="headerlink" title="迭代、可迭代、迭代器"></a>迭代、可迭代、迭代器</h2><h3 id="迭代（iteration）与可迭代（iterable）"><a href="#迭代（iteration）与可迭代（iterable）" class="headerlink" title="迭代（iteration）与可迭代（iterable）"></a>迭代（iteration）与可迭代（iterable）</h3><blockquote><p>迭代是一种操作；可迭代是对象的一种特性。</p></blockquote><p>很多数据都是「容器」；它们包含了很多其他类型的元素。实际使用容器时，我们常常需要逐个获取其中的元素。<strong>逐个获取元素的过程，就是「迭代」</strong>。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iteration</span></span><br><span class="line">a_list = [1, 2, 3]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a_list:</span><br><span class="line">    <span class="builtin-name">print</span>(i)</span><br></pre></td></tr></table></figure><p>如果我们可以从一个对象中，逐个地获取元素，那么我们就说这个对象是「可迭代的」。</p><p>Python 中的顺序类型，都是可迭代的（<code>list</code>, <code>tuple</code>, <code>string</code>）。其余包括 <code>dict</code>, <code>set</code>, <code>file</code> 也是可迭代的。对于用户自己实现的类型，如果提供了 <code>__iter__()</code> 或者 <code>__getitem__()</code> 方法，那么该类的对象也是可迭代的。</p><h3 id="迭代器（iterator）"><a href="#迭代器（iterator）" class="headerlink" title="迭代器（iterator）"></a>迭代器（iterator）</h3><blockquote><p>迭代器是一种对象。</p></blockquote><p>迭代器抽象的是一个「数据流」，是只允许迭代一次的对象。对迭代器不断调用 <code>next()</code> 方法，则可以依次获取下一个元素；当迭代器中没有元素时，调用 <code>next()</code> 方法会抛出 <code>StopIteration</code> 异常。迭代器的 <code>__iter__()</code> 方法返回迭代器自身；因此迭代器也是可迭代的。</p><h3 id="迭代器协议（iterator-protocol）"><a href="#迭代器协议（iterator-protocol）" class="headerlink" title="迭代器协议（iterator protocol）"></a>迭代器协议（iterator protocol）</h3><blockquote><p>迭代器协议指的是容器类需要包含一个特殊方法。</p></blockquote><p>如果一个容器类提供了 <code>__iter__()</code> 方法，并且该方法能返回一个能够逐个访问容器内所有元素的迭代器，则我们说该容器类实现了迭代器协议。</p><p>Python 中的迭代器协议和 Python 中的 <code>for</code> 循环是紧密相连的。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">iterator</span> protocol <span class="keyword">and</span> <span class="keyword">for</span> <span class="keyword">loop</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> something:</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure><p>Python 处理 <code>for</code> 循环时，首先会调用内建函数 <code>iter(something)</code>，它实际上会调用 <code>something.__iter__()</code>，返回 <code>something</code> 对应的迭代器。而后，<code>for</code> 循环会调用内建函数 <code>next()</code>，作用在迭代器上，获取迭代器的下一个元素，并赋值给 <code>x</code>。此后，Python 才开始执行循环体。</p><h2 id="生成器、yield-表达式"><a href="#生成器、yield-表达式" class="headerlink" title="生成器、yield 表达式"></a>生成器、<code>yield</code> 表达式</h2><h3 id="生成器函数（generator-function）和生成器（generator）"><a href="#生成器函数（generator-function）和生成器（generator）" class="headerlink" title="生成器函数（generator function）和生成器（generator）"></a>生成器函数（generator function）和生成器（generator）</h3><blockquote><p>生成器函数是一种特殊的函数；生成器则是特殊的迭代器。</p></blockquote><p>如果一个函数包含 <code>yield</code> 表达式，那么它是一个生成器函数；调用它会返回一个特殊的迭代器，称为生成器。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def <span class="built_in">func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">def <span class="built_in">gen</span>():</span><br><span class="line">    yield <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>(<span class="built_in">type</span>(func))   <span class="meta"># &lt;class 'function'&gt;</span></span><br><span class="line"><span class="keyword">print</span>(<span class="built_in">type</span>(gen))    <span class="meta"># &lt;class 'function'&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>(<span class="built_in">type</span>(<span class="built_in">func</span>())) <span class="meta"># &lt;class 'int'&gt;</span></span><br><span class="line"><span class="keyword">print</span>(<span class="built_in">type</span>(<span class="built_in">gen</span>()))  <span class="meta"># &lt;class 'generator'&gt;</span></span><br></pre></td></tr></table></figure><p>如上，生成器 <code>gen</code> 看起来和普通的函数没有太大区别。仅只是将 <code>return</code> 换成了 <code>yield</code>。用 <code>type()</code> 函数打印二者的类型也能发现，<code>func</code> 和 <code>gen</code> 都是函数。然而，二者的返回值的类型就不同了。<code>func()</code> 是一个 <code>int</code> 类型的对象；而 <code>gen()</code> 则是一个迭代器对象。</p><h3 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield 表达式"></a><code>yield</code> 表达式</h3><p>如前所述，如果一个函数定义中包含 <code>yield</code> 表达式，那么该函数是一个生成器函数（而非普通函数）。实际上，<code>yield</code> 仅能用于定义生成器函数。</p><p>与普通函数不同，生成器函数被调用后，其函数体内的代码并不会立即执行，而是返回一个生成器（generator-iterator）。当返回的生成器调用成员方法时，相应的生成器函数中的代码才会执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">yield</span> x ** <span class="number">2</span></span><br><span class="line">square_gen = square()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> square_gen:</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure><p>前面说到，<code>for</code> 循环会调用 <code>iter()</code> 函数，获取一个生成器；而后调用 <code>next()</code> 函数，将生成器中的下一个值赋值给 <code>x</code>；再执行循环体。因此，上述 <code>for</code> 循环基本等价于：</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">genitor = square_gen.__iter__()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    x = geniter.<span class="keyword">next</span>()<span class="meta"> # Python 3 是 __next__()</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>注意到，<code>square</code> 是一个生成器函数；作为它的返回值，<code>square_gen</code> 已经是一个迭代器；迭代器的 <code>__iter__()</code> 返回它自己。因此 <code>geniter</code> 对应的生成器函数，即是 <code>square</code>。</p><p>每次执行到 <code>x = geniter.next()</code> 时，<code>square</code> 函数会从上一次暂停的位置开始，一直执行到下一个 <code>yield</code> 表达式，将 <code>yield</code> 关键字后的表达式列表返回给调用者，并再次暂停。注意，<strong>每次从暂停恢复时，生成器函数的内部变量、指令指针、内部求值栈等内容和暂停时完全一致</strong>。</p><h3 id="生成器的方法"><a href="#生成器的方法" class="headerlink" title="生成器的方法"></a>生成器的方法</h3><p>生成器有一些方法。调用这些方法可以控制对应的生成器函数；不过，若是生成器函数已在执行过程中，调用这些方法则会抛出 <code>ValueError</code> 异常。</p><ul><li><code>generator.next()</code>：从上一次在 <code>yield</code> 表达式暂停的状态恢复，继续执行到下一次遇见 <code>yield</code> 表达式。当该方法被调用时，当前 <code>yield</code> 表达式的值为 <code>None</code>，下一个 <code>yield</code> 表达式中的表达式列表会被返回给该方法的调用者。若没有遇到 <code>yield</code> 表达式，生成器函数就已经退出，那么该方法会抛出 <code>StopIterator</code> 异常。</li><li><code>generator.send(value)</code>：和 <code>generator.next()</code> 类似，差别仅在与它会将当前 <code>yield</code> 表达式的值设置为 <code>value</code>。</li><li><code>generator.throw(type[, value[, traceback]])</code>：向生成器函数抛出一个类型为 <code>type</code> 值为 <code>value</code> 调用栈为 <code>traceback</code> 的异常，而后让生成器函数继续执行到下一个 <code>yield</code> 表达式。其余行为与 <code>generator.next()</code> 类似。</li><li><code>generator.close()</code>：告诉生成器函数，当前生成器作废不再使用。</li></ul><h3 id="举例和说明"><a href="#举例和说明" class="headerlink" title="举例和说明"></a>举例和说明</h3><h4 id="如果你看不懂生成器函数"><a href="#如果你看不懂生成器函数" class="headerlink" title="如果你看不懂生成器函数"></a>如果你看不懂生成器函数</h4><p>如果你还是不太能理解生成器函数，那么大致上你可以这样去理解。</p><ul><li>在函数开始处，加入 <code>result = list()</code>；</li><li>将每个 <code>yield</code> 表达式 <code>yield expr</code> 替换为 <code>result.append(expr)</code>；</li><li>在函数末尾处，加入 <code>return result</code>。</li></ul><h4 id="关于「下一个」yield-表达式"><a href="#关于「下一个」yield-表达式" class="headerlink" title="关于「下一个」yield 表达式"></a>关于「下一个」<code>yield</code> 表达式</h4><p>介绍「生成器的方法」时，我们说当调用 <code>generator.next()</code> 时，生成器函数会从当前位置开始执行到下一个 <code>yield</code> 表达式。这里的「下一个」指的是执行逻辑的下一个。因此</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f123</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> f123(): <span class="comment"># 1, 2, and 3, will be printed</span></span><br><span class="line">    print(item)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f13</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">False</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> f13(): <span class="comment"># 1 and 3, will be printed</span></span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure><h4 id="使用-send-方法与生成器函数通信"><a href="#使用-send-方法与生成器函数通信" class="headerlink" title="使用 send() 方法与生成器函数通信"></a>使用 <code>send()</code> 方法与生成器函数通信</h4><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def <span class="function"><span class="keyword">func</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        y = (yield x)</span><br><span class="line">        x += y</span><br><span class="line"></span><br><span class="line">geniter = <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">geniter.<span class="keyword">next</span>()  <span class="meta"># 1</span></span><br><span class="line">geniter.<span class="built_in">send</span>(<span class="number">3</span>) <span class="meta"># 4</span></span><br><span class="line">geniter.<span class="built_in">send</span>(<span class="number">10</span>)<span class="meta"># 14</span></span><br></pre></td></tr></table></figure><p>此处，生成器函数 <code>func</code> 用 <code>yield</code> 表达式，将处理好的 <code>x</code> 发送给生成器的调用者；与此同时，生成器的调用者通过 <code>send</code> 函数，将外部信息作为生成器函数内部的 <code>yield</code> 表达式的值，保存在 <code>y</code> 当中，并参与后续的处理。</p><p>这一特性是使用 <code>yield</code> 在 Python 中使用协程的基础。</p><h2 id="yield-的好处"><a href="#yield-的好处" class="headerlink" title="yield 的好处"></a><code>yield</code> 的好处</h2><p>Python 的老用户应该会熟悉 Python 2 中的一个特性：内建函数 <code>range</code> 和 <code>xrange</code>。其中，<code>range</code> 函数返回的是一个列表，而 <code>xrange</code> 返回的是一个迭代器。</p><blockquote><p>在 Python 3 中，<code>range</code> 相当于 Python 2 中的 <code>xrange</code>；而 Python 2 中的 <code>range</code> 可以用 <code>list(range())</code> 来实现。</p></blockquote><p>Python 之所以要提供这样的解决方案，是因为在很多时候，我们只是需要逐个顺序访问容器内的元素。大多数时候，我们不需要「一口气获取容器内所有的元素」。比方说，顺序访问容器内的前 5 个元素，可以有两种做法：</p><ul><li>获取容器内的所有元素，然后取出前 5 个；</li><li>从头开始，逐个迭代容器内的元素，迭代 5 个元素之后停止。</li></ul><p>显而易见，如果容器内的元素数量非常多（比如有 <code>10 ** 8</code> 个），或者容器内的元素体积非常大，那么后一种方案能节省巨大的时间、空间开销。</p><p>现在假设，我们有一个函数，其产出（返回值）是一个列表。而若我们知道，调用者对该函数的返回值，只有逐个迭代这一种方式。那么，如果函数生产列表中的每一个元素都需要耗费非常多的时间，或者生成所有元素需要等待很长时间，则使用 <code>yield</code> 把函数变成一个生成器函数，每次只产生一个元素，就能节省很多开销了。</p><p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Video captioning summary</title>
      <link href="/2019/02/23/Video-captioning-summary/"/>
      <url>/2019/02/23/Video-captioning-summary/</url>
      
        <content type="html"><![CDATA[<ul><li>总结一下各论文使用的encoder的model分别是什么，是否采用了C3D，若采用了C3D,每16帧输出一个特征向量，这样的话，n_frames/16 个特征向量，那么论文中又是如何聚合特征来得到video 特征的？<br>## </li></ul><h2 id="训练和测试的一般过程"><a href="#训练和测试的一般过程" class="headerlink" title="训练和测试的一般过程"></a>训练和测试的一般过程</h2><p>The training process predicts the next word given the previous words from groundtruth, while the generation process conditions the prediction on the ones previously generated by itself.  </p><h2 id="训练损失"><a href="#训练损失" class="headerlink" title="训练损失"></a>训练损失</h2><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0iyn2xsz9j30r00higpg.jpg" style="zoom:70%"><h2 id="Code-总结"><a href="#Code-总结" class="headerlink" title="Code 总结"></a>Code 总结</h2><table><thead><tr><th>model</th><th>batch_size</th><th>epoch</th><th>learning_rate</th><th>MSVD<br>train-dataset</th><th>MSR-train-dataset</th></tr></thead><tbody><tr><td>video-caption.pytorch</td><td>128</td><td>6001（MSR）</td><td>0.0004 (每200epoch下降0.8)</td><td>✘</td><td>6513 pairs<br>(每一次随机的从captions中选择一个作为label)</td></tr><tr><td>SA-tensorflow</td><td>100</td><td>200</td><td>0.0001（不变）</td><td>1200×41个pairs</td><td>✘</td></tr><tr><td>reconstruction-network</td><td>100</td><td>iter=100000  （epoch=100000×100/(1200*41）=203</td><td>0.00001（不变）</td><td>1200×41个pairs</td><td>✘</td></tr><tr><td>saliency-based</td><td>100</td><td>100</td><td>0.0003（不变）</td><td>略</td><td>✘</td></tr><tr><td>HRNE</td><td>200</td><td>128</td><td>0.0002</td><td>略</td><td>✘</td></tr></tbody></table><table><thead><tr><th>model</th><th>construct vocab use which dataset</th></tr></thead><tbody><tr><td>video-caption.pytorch</td><td>MSR: all</td></tr><tr><td>SA-tensorflow</td><td>MSVD: train</td></tr><tr><td>reconstruction-network</td><td>MSVD: all</td></tr><tr><td>saliency-based</td><td></td></tr><tr><td>HRNE</td><td></td></tr></tbody></table><table><thead><tr><th>model</th><th>loss function</th><th>input of decoder</th></tr></thead><tbody><tr><td>video-caption.pytorch</td><td>output of decoder（bs, hidden size）,经过一个全连接层得到one-hot形式(bs, n_vocab），在经过F.log_softmax。则损失函数 nn.NLLLoss（）</td><td>rnn1的输入是video feature;<br>rnn2的输入是rnn1的输出cancatenate 上一步ground truth的word embedding<br> output1, state1 = self.rnn1(vid_feats, state1)<br> input2 = torch.cat((output1, padding_words), dim=2)<br>          output2, state2 = self.rnn2(input2, state2)</td></tr><tr><td>SA-tensorflow</td><td><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0izmumz8sj30ry01l74i.jpg">LSTM的output/hidden state、经过attention加权求和得到的videofeature、上一步step的groundtruth word embedding进行concatenate，在经过全连接层、非线性层、全连接层、输入交叉熵损失函数：tf.nn.softmax_cross_entropy_with_logits</td><td>LSTM的输入是concatenate(video_feature, 上一步ground truth的word embdedding）</td></tr><tr><td>reconstruction-network</td><td>output of decoder（bs, hidden size）,经过一个全连接层得到one-hot形式(bs, n_vocab），在经过dropout。  则损失函数 nn.CrossEntropyLoss()</td><td>LSTM的输入是concatenate(video_feature, 上一步ground truth的word embdedding）</td></tr></tbody></table><hr><h2 id="Paper-总结"><a href="#Paper-总结" class="headerlink" title="Paper 总结"></a>Paper 总结</h2><table><thead><tr><th>model</th><th>dataset</th><th>n_frames</th></tr></thead><tbody><tr><td>S2VT</td><td>MSVD</td><td>每10帧取1帧</td></tr><tr><td>SA</td><td>MSVD</td><td>前240帧等间隔取26帧</td></tr><tr><td>h-RNN</td><td>MSVD</td><td>没讲( ˇˍˇ )</td></tr><tr><td>HRNE</td><td>MSVD</td><td>fixed 160帧</td></tr><tr><td>LSTM-TSA</td><td>MSVD</td><td>等间隔采取25帧</td></tr><tr><td>LSTM-E</td><td>MSVD</td><td>all frames</td></tr><tr><td>Reconstruction</td><td>MSVD  MSR-VTT</td><td>等间隔28帧</td></tr><tr><td>M3</td><td>MSVD  MSR-VTT</td><td>28帧for MSVD; 40帧for MSR-VTT</td></tr></tbody></table><table><thead><tr><th>model</th><th>词频</th><th>MSVD  vocabulary</th><th>MSR-VTT  vocabulary</th></tr></thead><tbody><tr><td>Hierarchical Boundary-Aware Neural Encoder for Video Captioning</td><td>大于等于5</td><td>4215</td><td></td></tr><tr><td>Multimodal Memory Modelling for Video Captioning</td><td></td><td>13,000</td><td>29,000</td></tr><tr><td>Spatio-Temporal Dynamics and Semantic Attribute Enriched Visual Encoding for Video Captioning</td><td></td><td>9450</td><td>23500</td></tr><tr><td>Describing Videos by Exploiting Temporal Structure</td><td></td><td>16,000</td><td></td></tr><tr><td>Video Paragraph Captioning Using Hierarchical Recurrent Neural Networks</td><td></td><td>12, 766（1, 297 and 670 videos ）</td><td></td></tr></tbody></table><table><thead><tr><th>model</th><th>feature</th><th>METER</th></tr></thead><tbody><tr><td>Mean Pool + LSTM</td><td>在COCO上预训练的Alex net</td><td>29.1</td></tr><tr><td>S2VT</td><td>RGB frames on VGG Net<br>optical flows on AlexNet</td><td>29.8</td></tr><tr><td>SA</td><td>GoogLeNet and 3D-CNN</td><td>29.6</td></tr><tr><td>LSTM-E</td><td>VGGNet and C3D</td><td>31.0</td></tr><tr><td>h-RNN</td><td>VGGNet and C3D</td><td>32.6</td></tr><tr><td>HRNE</td><td>GooLeNet</td><td>33.1</td></tr><tr><td>Reconstruction</td><td>Inception-V4<br> last pooling layer</td><td>34.1</td></tr></tbody></table><h2 id="提取frames-features-之后，获取video-feature的几种方法："><a href="#提取frames-features-之后，获取video-feature的几种方法：" class="headerlink" title="提取frames features 之后，获取video feature的几种方法："></a>提取frames features 之后，获取video feature的几种方法：</h2><p><strong>1. Mean pooling</strong></p><ul><li>Translating videos to natural language using deep recurrent neural networks. NACACL, 2015</li><li>Jointly modeling embedding and translation to bridge video and language. CoRR,  2015  </li></ul><p><strong>2. Weighted mean Pooling with an attention model</strong>    </p><ul><li>Describing videos by exploiting temporal structure. ICCV, 2015  </li><li>Exploring Visual Relationship for Image Captioning</li><li>2层LSTM，第一层LSTM的输入是对object/frames features进行平均池化，第二层LSTM的输入是给定第一层的hidden state 来得到attention 系数，从而对object/frames features进行加权求和。 即第一层用平均池化的特征来表征 global feture，第二层用加权求和的特征来表征 global feature</li></ul><p><strong>3. Taking the last output from an RNN encoder which summarizes the feature sequence</strong>    </p><ul><li>Long-term recurrent convolutional networks for visual recognition and description. CVPR, 2015</li><li>Sequence to sequence - video to tex. ICCV, 2015</li><li>A multi-scale multiple instance video description network. CoRR, 2015  </li></ul><h2 id="video-captioning-的模型中，含有extract-object-proposal的论文"><a href="#video-captioning-的模型中，含有extract-object-proposal的论文" class="headerlink" title="video captioning 的模型中，含有extract object proposal的论文"></a>video captioning 的模型中，含有extract object proposal的论文</h2><ul><li>Video paragraph captioning using hierarchical recurrent neural networks.  CVPR, 2016.  </li><li>object-aware aggregation with bidirectional temporal graph for video capioning. CVPR, 2019</li></ul><h2 id="loss"><a href="#loss" class="headerlink" title="loss"></a>loss</h2><ul><li>一般的情况下是对decoder的部分计算loss, 并反向传播，encoder采用预训练好的model，并不在进行finetune。</li></ul><h2 id="使用objects-feature-的文章"><a href="#使用objects-feature-的文章" class="headerlink" title="使用objects feature 的文章"></a>使用objects feature 的文章</h2><ul><li></li><li>video as graph : charades 每帧提取50个objects(当objects 的数量将为25的时候，score只降了0.2), something2 :每帧提取10个objects</li><li>我的msr-vtt: 提取5个效果比较好，不会包含太多的噪声</li><li>==尽量让一个video中的objects 不同，去聚类帧之间的objects==  </li></ul><table><thead><tr><th>论文</th><th>charades( 30s)</th><th></th><th>something-something( 3-6s )</th><th>activity</th><th>MSVD（10-25s）</th></tr></thead><tbody><tr><td>video as graph</td><td>16帧 *50</td><td></td><td>16帧* 10</td><td>10帧*100</td><td></td></tr><tr><td>HTM （video captioning)</td><td>80帧 *30</td><td></td><td></td><td></td><td>28帧*30</td></tr></tbody></table><table><thead><tr><th>论文</th><th>object detector</th><th>return</th></tr></thead><tbody><tr><td>(ACM 2019)Hierarchical Global-Local Temporal Modeling for VideoCaptioning</td><td>Faster rcnn 去掉rcnn的分类层，</td><td>提取_head_to_tail之后的特征 2048维</td></tr><tr><td>(CVPR 2019)Spatio-Temporal Dynamics and Semantic Attribute Enriched Visual Encoding for Video Captioning</td><td>YoLo</td><td>没说</td></tr><tr><td>(CVPR 2019)Grounded Video Description</td><td>a Faster RCNN model [24] with a ResNeXt-101 FPN backbone (在VG上预训练，类别会比coco 多，同时训练目标检测和属性分类)</td><td>返回的是fc6,我认为是_head_to_tail</td></tr><tr><td>( ECCV 2018)Videos as Space-Time Region Graph</td><td>the RPN with ResNet-50 backbone and FPN ==(需要注意，这里具体的：先由I3D得到THWd的特征，然后对32帧，每2帧取1帧，去得到这16帧的bbox，得到了bbox不是直接去得到pooled_feats，而是通过I3D的空间特征，bbox, Roi Align来得到bbox 的 region feat) ==</td><td>返回的是roi_pooling的7*7的，然后再进行平均池化</td></tr><tr><td>(CVPR 2019)Object-aware Aggregation with Bidirectional Temporal Graph for Video Captioning</td><td>MASK RCNN，在COCO上预训练，</td><td>将得到的regions 裁剪成图像，再送入ResNet-200中，得到res-layer5c的局部特征</td></tr><tr><td>（CVPR 2019）Auto-Encoding Scene Graphs for Image Captioning</td><td>faster rcnn , 使用 r-cnn 输出的 rois， 然后作用到 base feat上，使用 roi pooling 的到 pooled feats</td><td>返回 7*7的pooled feats</td></tr></tbody></table><ul><li>根据faster r-cnn 的网络结构，rpn部分输出bbox的预测，rcnn部分也输出bbox的预测，在目标检测任务中，采用rcnn的输出作为最后的结果。</li><li>但是在视频帧提取 object 的任务中，一般采用的是rpn部分输出的bbox,  why？ 这是因为，想要得到的不是bbox的坐标，而是bbox feats， 因此，直接取pooled_feats更加简洁方便。</li><li>所以在利用mmdetection时，设置 在rpn部分的max_region_per</li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 视频描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 视频描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(h-RNN)Video Paragraph Captioning Using Hierarchical Recurrent Neural Networks</title>
      <link href="/2019/02/23/h-RNN-Video-Paragraph-Captioning-Using-Hierarchical-Recurrent-Neural-Networks/"/>
      <url>/2019/02/23/h-RNN-Video-Paragraph-Captioning-Using-Hierarchical-Recurrent-Neural-Networks/</url>
      
        <content type="html"><![CDATA[<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><ul><li>这篇文章主要针对于一个video 划分为多个interval，并分别对其进行caption这样的数据集。其中段落生成器的作用：可以捕捉句子之间的相互依赖关系，同时段落生成器的输出作为句子生成器的输入，可以使得<strong>下一个句子的生成是建立在当前句子的语境下生成的</strong>。</li><li>另外对于MSVD这种一个video直接由一个sentence来描述的数据集，段落生成器不起作用，只是在<strong>decoder的结构相较于其他的model有不同之处</strong>：video feature 不输入decoder 的 RNN，而是与RNN的hidden state 级联后输入Multimodal层，Multimodal( concatenate( hidden state，video feature ) )。</li></ul><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>提出了一个方法：<strong>利用分层RNN开解决视频描述</strong>。我们的分层框架包含一个句子生成器和一个段落生成器。<strong><em>句子生成器</em></strong>产生一个简短的句子，这个句子可以描述一个特定的短视频间隔。它利用时间和空间的注意力机制，有选择地将注意力集中在视觉元素上。<strong><em>段落生成器</em></strong>通过将句子生成器产生的句子嵌入与段落历史结合起来作为输入来捕获句子间的依赖关系，并段落生成器的parahraph state 将作为输出语句生成器的新初始状态，然后句子生成器再生成下一个句子，~ 循环</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul><li><strong>对当前方法的总结：</strong><br>当给出了从视频帧中提取的深度卷积特征序列(例如vggnet 和c3d)，则视频的特征可以用以下几种方法获取：<br>（1）平均池化[1, 2]<br>（2）加权平均池化（attention 机制）[3]<br>（3）RNN encoder 的最后一个输出[4, 5, 6]<br>当前基于序列学习的视频描述方法，只专注于为一个简短的视频剪辑生成一个句子。到目前为止，深层次学习方法还没有尝试为长视频生成多个句子或段落的问题。使用平均池化得到 video feature 的方法，只适用于 short video clips where there is only one major event，随后有了 recurrent encoder 和 attention model。<br>我们的方法也采用了attention 机制。但是我们的框架和他们的框架之间存在两个不同之处，1. 解释<strong>空间注意力</strong>：即对每个frames 提取object proposals 然后基于注意力机制对proposal features of one frames 进行加权求和来得到frames features。这对于数据集中 object 非常小且难定位的情况有很大的帮助。另外，也解释一下<strong>时域注意力</strong>：是指对features of frames 进行加权求和，从而得到 video feature。 <strong>本文的注意力机制</strong>：提取M帧，每帧K个object, 则对这M*K个 object 进行基于attention 系数的加权求和。2. 在加权视频特征和注意权重之后，我们不会在加权特征的基础上限制递归层的隐藏状态。 </li><li><strong>Motivation</strong><br>大多数视频描述的不仅仅是一个事件。只用一个简短的句子来描述一个语义丰富的视频通常会产生信息不多甚至无聊的结果。例如，一个video 应该描述成<strong>那个人把土豆切成片，把洋葱切成块，把洋葱和土豆放进锅里</strong>，但是只产生one sentence的方法可能会说<strong>这个人在做饭</strong>。</li><li><strong>Idea</strong><br>我们想要利用句子之间的时域依赖性，这样，在生成段落时，句子就不会独立地生成。相反，一个句子的生成可能会受到前几句所提供的语义上下文的影响。<br>我们的分层RNN结构包括两个生成器，一个句子生成器和一个段落生成器，这两个生成器都使用RNN layers<br>据我们所知，这是分层RNN在视频字幕任务中的首次应用。  </li></ul><h2 id="Hierarchical-RNN-for-Video-Captioning"><a href="#Hierarchical-RNN-for-Video-Captioning" class="headerlink" title="Hierarchical RNN for Video Captioning"></a>Hierarchical RNN for Video Captioning</h2><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0gmi1zayjj314o0h2n1f.jpg">***designed by yaya:***<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0k7r1p5ygj316f0jyq47.jpg">我们的方法：在句子生成器之上堆叠了一个段落生成器**句子生成器**：1) RNN 用来语言建模 2) 多模态层对多源信息进行聚合 3) 注意力模型<ul><li>RNN1：word embedding 作为RNN的输入，并更新 hidden state </li><li>Attention layer: RNN 的hidden state 作为attention layer 的输入，来计算weight:   <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0gohii8woj30xx02saab.jpg" style="zoom:30%"><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0gom9zybsj30kg04mwes.jpg" style="zoom:45%">假设视频中有M帧，每帧有K个objects，则features：  <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0go2kemkqj30bq01pt8m.jpg" style="zoom:50%">若计算出了一组权重:  <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0go382u2qj309m0250so.jpg" style="zoom:50%">则 video feature：  <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0go5n8g7dj30if036mx8.jpg" style="zoom:30%">得到的video feature是一个特征通道，完整的模型是两个特征通道，一个由 object appearance 生成，另一个由action 生成</li><li>Multimodal<br>输入：RNN 的hidden state <strong>concate</strong> 2个Attention 的输出（两个特征通道Ua  C3D，action feature；Uo aggregate object appearance）。既有语言，又有视觉，因此成为多模态。<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0gpaasqgmj30sb022dg0.jpg" style="zoom:50%"></li><li>Hidden layer<br>-输出维度512 与 word embdeding 的维度一致</li><li>Softmax layer<br>输出维度与vocabulary size 一致</li><li>Maxid layer<br>Maxid layer 在softmax layer 的输出中挑选了最大值所在的索引，该索引将会被作为predicted word 的id(对应到vocabulary 的 索引)</li><li>预测的单词将会作为句子生成器的下一个输入（test）；下一个输入单词总是由带注释的句子（ground truth/ reference）提供。</li></ul><p><strong>段落生成器</strong> : 另外一个RNN，来建模句子之间的相互依赖。输入：1.句子生成器的输出， 2. paragraph history  输出：该输出作为句子生成器的初始状态<br>使用的RNN为GRU</p><ul><li>Word Embedding<br>1) 对sentences中的所有单词的embedding 取平均，得到一个压缩embedding vector<br>2) 同时也接受RNN1 的最后一个hidden state 作为 压缩表达<br>将上面两个压缩表达concatenated </li><li>Sentences Embedding<br>将上面concatenated 的特征输入该层，得到512维度的输出</li><li>RNN2</li><li>Paragraph State layer<br>输入：结合RNN2的hidden state 和 sentence embedding<br>输出：作为RNN1下一个句子的初始状态，为句子生成器提供了段落历史是有必要的，以便在上下文语境中中生成下一句。<br>它实质上为句子生成器提供了段落历史，以便在上下文中生成下一句。</li></ul><h2 id="Training-and-Generation"><a href="#Training-and-Generation" class="headerlink" title="Training and Generation"></a>Training and Generation</h2><p><strong>整个网络的循环过程</strong></p><ul><li>当RNN1在每一时间步骤中不断更新其hidden state，RNN2只在处理完整句子时才更新其hidden state。</li><li>RNN1 由beam search 得到 J 个sequence cost 最低的句子，挑选出1个最低的，然后送入RNN2。RNN2又输出隐层状态，最为RNN1下一个句子的初始隐层状态。如此循环，直至， when the sentence received by the paragraph generator is the EOP (end-of-paragraph) which consists of only the BOS and the EOS。</li></ul><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p><strong>数据集</strong><br>two benchmark datasets: YouTubeClips and TACoS-MultiLevel<br>YouTubeClips： 虽然每个video 有多个sentences进行描述，但是sentences是对这个video的整体描述，而不是分别对video进行分段描述。因此这个数据集作为我们方法的特例，paragraph length N=1.<br><strong>Encoder</strong></p><ul><li>由于YouTubeClips数据集中的object 十分显著，因此不进行提取object的操作，只对frame 提取特征，这样attention 只包括temporal attention ，而不包括 spatial attention。</li><li>对于TACoS-MultiLevel 数据集，首先使用光流大体的提取boundinig box，然后沿着bounding box 的边，提取220*220的image patches，保证相邻两个box 重合度为50%。使用VGG模型对每个patch提取特征，并使用attention的权重，对这些patches进行加权求和。此时，attention同时包括temporal 和 spatial。</li><li>C3D 提取 action/motion feature of video<br>C3D 模型：输入frames of video ，每16帧输出一个固定长度的特征向量。然后采用attention机制对C3D特征进行polling（加权求和）<br><strong>实验结果对比分析</strong></li><li>YouTubeClips  <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0hdv8rde9j30i7099jtg.jpg">   相比于**LSTM-E[2]**（同样同时利用了VGG和C3D特征），我们的模型效果更好。相比于**SA[3]**（同样利用了temporal attention）我们的方法更好，原因：RNN的输入不包括视频特征，换句话说， hidden state的更新不建立在video feature的基础上。video feature直接的输入到multimodal layer。</li><li>TACoS-MultiLevel<br>这里不做分析（可以自行参考论文）</li></ul><h2 id="Discussions-and-Limitations"><a href="#Discussions-and-Limitations" class="headerlink" title="Discussions and Limitations"></a>Discussions and Limitations</h2><ol><li>目前我们使用的目标检测方法很难处理small object，造成在生成句子时，极容易混淆，比如应该是orange ，却生成了mango</li><li>句子信息通过段落循环层单向流动，从段落开始到结尾，但也不是以相反的方式。如果第一个句子中含有错误信息，则会导致错误信息依次传递，目前使用双向RNN来生成句子，仍然是一个开放性的问题（yaya: sorry , i don’t kow what’s mean，可能是目前还不知道使用BiRNN来生成句子的效果是否好于单向RNN）。</li><li>与其他大多数图像/视频字幕方法一样，我们的方法存在一个已知的问题，即训练所使用的目标函数与生成方法所使用的目标函数之间存在差异。训练过程给定来自groundtruth的先前单词来预测下一个单词，而生成过程则对先前由其自身生成的单词进行预测。这个问题在我们的分层框架中更加放大，因为在训练时，段落生成器输入的是groundtruth，但是在测试阶段，输入的是句子生成器生成的句子。潜在的解决办法：</li></ol><ul><li>Scheduled Sampling<br>在训练过程中增加Scheduled Sampling，即随机的选择words of groundtruth或者由model生成的单词。</li><li>在训练的过程中直接优化metric(BLEU， CIDER, etc)</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <strong><em>Translating videos to natural language using deep recurrent neural networks</em></strong>. NACACL, 2015<br>[2] <strong><em>Jointly modeling embedding and translation to bridge video and language</em></strong>. CoRR,  2015<br>[3] <strong><em>Describing videos by exploiting temporal structure</em></strong>. ICCV, 2015<br>[4] <strong><em>Long-term recurrent convolutional networks for visual recognition and description</em></strong>. CVPR, 2015<br>[5] <strong><em>Sequence to sequence - video to text</em></strong>. ICCV, 2015<br>[6]  <strong><em>A multi-scale multiple instance video description network</em></strong>. CoRR, 2015</p>]]></content>
      
      
      <categories>
          
          <category> 视频描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 视频描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hierarchical Boundary-Aware Neural Encoder for Video Captioning</title>
      <link href="/2019/02/22/Hierarchical-Boundary-Aware-Neural-Encoder-for-Video-Captioning/"/>
      <url>/2019/02/22/Hierarchical-Boundary-Aware-Neural-Encoder-for-Video-Captioning/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0g5c5cwmxj30l00mh45o.jpg">  In this paper, we focus on the video encoding stage. we propose a recurrent network which can learn to adapt its temporal structure to input data.Our network is the first proposal which exploits temporal segments invideo captioning。在这篇文章中，给出了一个循环视频编码方案，该方案可以发现和利用视频的分层结构。不同于经典的编码解码方法（视频由一个循环层来连续的编码），我们提出了一个新颖的LSTM单元， 其可以识别帧/段之间非连续的点，相应地修改编码层的时间连接。Encoder Model---------<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0g57reyepj316c0m7k74.jpg">   - **traditional lstm network**使用LSTM来获得video feature，将每个frames 按每time step 依次送入LSTM，最后一个LSTM cell 的hidden state 用来得到video feature。  - **Time Boundary-aware LSTM network** ***(ours)***figure1 与 figure2 结合来看，存在BD（boundary detection ）来检测该帧是否为一个边界（an appearance or action change），若BD检测到存在一个边界，则**保存当前LSTM的输出**，并开始一个新的LSTM（即，hidden state and the cell memory 被重新初始化）。这就确保了在边界之后的输入数据，不受边界之前数据的影响。经过对all frames of video 进行这样的操作，于是得到可变长度的输出 (s1; s2; ...; sm), m是检测到segments的数量。这组输出又经过另外一个LSTM层（称为第二LSTM层），第二LSTM层的hidden state 作为整个视频的特征（参考figure1）。Decoder model-------------A Gated Recurrent Unit (GRU) layer]]></content>
      
      
      <categories>
          
          <category> 视频描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 视频描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>video-caption-dataset</title>
      <link href="/2019/02/22/video-caption-dataset/"/>
      <url>/2019/02/22/video-caption-dataset/</url>
      
        <content type="html"><![CDATA[<h2 id="Youtube2Text-（MSVD）-1"><a href="#Youtube2Text-（MSVD）-1" class="headerlink" title="Youtube2Text （MSVD）[1]"></a>Youtube2Text （MSVD）[1]</h2><ul><li>这个数据集包含 1967个短视频，10-25s，平均时长为9s，视频包含不同的人，动物，动作，场景等。</li><li>每个视频由不同的人标注了多个句子，大约41 annotated sentences per clip，共有 80839 个sentences，平均每个句子有8个words，这些所有的句子中共包含近16000个 unique words。</li><li>caption中包括多国的语言进行描述，部分论文中采取只选用laguage = english 的caption 进行训练和测试[3][4]</li><li>采用的split根据 [2] ： 1,200 videos for training, 100 for validation and 670 for testing.<br><a href="https://github.com/ShiYaya/video_captioning/tree/master/MSVD" target="_blank" rel="noopener">我的整理</a></li></ul><ul><li>数据的下载：</li><li><a href="https://www.microsoft.com/en-us/download/details.aspx?spm=a2c4e.11153940.blogcont209612.6.42ba7e9eAA1K2o&id=52422&from=http%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fdownloads%2F38cf15fd-b8df-477e-a4e4-a4680caa75af%2Fdefault.aspx" target="_blank" rel="noopener">[website]</a></li><li>原数据：只给出了video_id,以及strart and end time , 若需要video数据，则需要自己通过url下载</li><li>某篇对于视频分析的总结，给出了<a href="https://github.com/sinyeratlantis/sinyeratlantis.github.io/blob/master/content/dl/%E8%A7%86%E9%A2%91%E5%88%86%E6%9E%90%E6%96%87%E7%8C%AE%E8%B0%83%E7%A0%94.md" target="_blank" rel="noopener">MSVD的下载链接</a>，可用，推荐(下载速度快，且video命名相对较好)☀☀<br><br><a href="http://www.cs.utexas.edu/users/ml/clamp/videoDescription/YouTubeClips.tar" target="_blank" rel="noopener">直接的下载链接</a><strong>[推荐]</strong></li><li>某篇github 含有MSVD(Youtube2Text)的<a href="https://github.com/yaoli/arctic-capgen-vid" target="_blank" rel="noopener">[preproceed dataset]</a><br><br><a href="http://lisaweb.iro.umontreal.ca/transfert/lisa/users/yaoli/youtube2text_iccv15.zip" target="_blank" rel="noopener">直接的下载链接</a>(下载速度慢)</li><li>该篇github上含有<a href="https://github.com/ShiYaya/Video-Description-with-Spatial-Temporal-Attention#video-datas-and-pre-extracted-features-on-msvd-dataset" target="_blank" rel="noopener">MSVD数据集下载链接</a><br><br><a href="https://www.multcloud.com/share/050e69cd-cab9-4ba3-a671-ed459341ab41" target="_blank" rel="noopener">直接的下载链接</a></li><li>对caption 常用的预处理: 1) verting all text to lower case, 2) tokenizing the sentences, 3) removing punctuation.</li></ul><h2 id="MSR-VTT-dataset"><a href="#MSR-VTT-dataset" class="headerlink" title="MSR-VTT dataset"></a>MSR-VTT dataset</h2><p> 共10000个video, 每个video有20个sentences, 共20万 video/sentence pair，10-30s居多</p><ul><li>split:  train:6513, val:497, test：2990</li><li>MSR-VTT dataset v2 , just video url: <a href="http://ms-multimedia-challenge.com/2017/dataset" target="_blank" rel="noopener">http://ms-multimedia-challenge.com/2017/dataset</a></li><li>author split train test val by himself and provied video data :<a href="https://github.com/xiadingZ/video-caption.pytorch" target="_blank" rel="noopener">https://github.com/xiadingZ/video-caption.pytorch</a>  <br></li></ul><p><strong>下载这个数据集即可使用，但是还需要再找split!</strong><br></p><ul><li>MSR VTT 采用的split 是2016年提供的，<strong>目前科研广泛使用的都是2016年的</strong>。</li><li><a href="https://github.com/adi-dhal/In_Depth_Video_Analysis/tree/master/msr-vtt/2016" target="_blank" rel="noopener">[split]</a><br>MSR-VTT. Test video doesn’t have captions, so I spilit train-viedo to train/val/test. Extract and put them in <code>./data/</code> directory</li></ul><p>train-video: <a href="https://drive.google.com/file/d/1Qi6Gn_l93SzrvmKQQu-drI90L-x8B0ly/view?usp=sharing" target="_blank" rel="noopener">download link</a> <br><br>test-video: <a href="https://drive.google.com/file/d/10fPbEhD-ENVQihrRvKFvxcMzkDlhvf4Q/view?usp=sharing" target="_blank" rel="noopener">download link</a> <br><br>json info of train-video: <a href="https://drive.google.com/file/d/1LcTtsAvfnHhUfHMiI4YkDgN7lF1-_-m7/view?usp=sharing" target="_blank" rel="noopener">download link</a> <br><br>json info of test-video: <a href="https://drive.google.com/file/d/1Kgra0uMKDQssclNZXRLfbj9UQgBv-1YE/view?usp=sharing" target="_blank" rel="noopener">download link</a> <br></p><ul><li><p>download.py 可以下载MSR-VTT数据集(step by video)：<a href="https://github.com/OSUPCVLab/VideoToTextDNN" target="_blank" rel="noopener">[链接]</a></p></li><li><p>msr-vtt 2017 vs 2016<br>In the 2nd MSR Video to Language Challenge, we have combined the training set, validation set, and testing data in the 1st MSR Video to Language Challenge as the new training data. An additional test set of around 3K video clips will be released on June 1st as the final evaluation set. As such, we have 10K video clips for training and 3K video clips for testing this year. Each video is annotated with 20 natural sentences.<br><br>总结：就仅仅是将2016的train val and test 综合到一起，组成了2017： 一个大的含10000个video的train 数据集，并另外提供了2000个test video。<br><br>科研上普遍使用2016的分割方案，</p></li></ul><ul><li>In MSR-VTT dataset, we provide the category information for each video clip and the video clip contains audio information as well.</li></ul><h2 id="VATEX数据集"><a href="#VATEX数据集" class="headerlink" title="VATEX数据集"></a>VATEX数据集</h2><ul><li><p>一个新的数据集，41269个video， 时长大约10s, 每个video有10个中文，10个英文，同时这10个之中，中英文之间有5个是两两配对的</p></li><li><p>提出了两个新的任务：（1）一个encoder-decoder模型，在两种语言之间共享参数，即希望一个模型，可以得到两种语言的描述。（2）提出了一种新的机器翻译任务，即当进行中英文的机器翻译任务时，可以添加视频的视觉特征作为辅助信息</p></li><li><p>数据集的来源：来自于kinetics的validation dataset, 然后它们找人进行了caption的标注。它们将这41269个video 分成了4部分，train, validation, public test, secret test(不公开，用于比赛)</p></li><li><p>具体我的介绍见这篇博文</p></li></ul><h2 id="三个数据集的caption-length-的长度的统计情况"><a href="#三个数据集的caption-length-的长度的统计情况" class="headerlink" title="三个数据集的caption length 的长度的统计情况"></a>三个数据集的caption length 的长度的统计情况</h2><ul><li>eg, 句长为10 的captions 在当前这个数据集中所占比例   </li><li>msvd : 主要是len=6 为中心的居多<br><img src="https://i.loli.net/2019/09/07/jJ7ztsQb9MUR15X.png" alt="msvd_cap_length_.png"></li><li>msr-vtt：以len=9 为中心的居多<br><img src="https://i.loli.net/2019/09/07/SNYoIqHxPLWmU9D.png" alt="msr-vtt_cap_length_.png"></li><li>vatex：以len=15为中心的居多<br><img src="https://i.loli.net/2019/09/07/he7KYqMt8xj5pUs.png" alt="vatex_cap_length_.png"></li></ul><p>[1] Youtube2text: Recognizing and describing arbitrary activities using semantic hierarchies and zero-shot recognition. In ICCV 2013</p><p>[2] Translating videos to natural language using deep recurrent neural networks. NAACL, 2015.<br>[3] (ICCV 2015)Sequence to Sequence – Video to Text<br>[4] Jointly Modeling Embedding and Translation to Bridge Video and Language</p>]]></content>
      
      
      <categories>
          
          <category> 视频描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown用法</title>
      <link href="/2019/02/22/Markdown%E7%94%A8%E6%B3%95/"/>
      <url>/2019/02/22/Markdown%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ul><li><p>参考该网址：<br><a href="https://www.kancloud.cn/wizardforcel/markdown-simple-world/97375" target="_blank" rel="noopener">https://www.kancloud.cn/wizardforcel/markdown-simple-world/97375</a></p></li><li><p>在线编辑器<br><a href="https://stackedit.io/editor" target="_blank" rel="noopener">https://stackedit.io/editor</a></p></li><li><p>首行缩进两个字符：<br>切换至中文全角，shift+space 按一次，然后再摁space两次，即可出现首行缩进两个字符</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(LSTM-E)Jointly Modeling Embedding and Translation to Bridge Video and Language</title>
      <link href="/2019/02/22/LSTM-E-Jointly-Modeling-Embedding-and-Translation-to-Bridge-Video-and-Language/"/>
      <url>/2019/02/22/LSTM-E-Jointly-Modeling-Embedding-and-Translation-to-Bridge-Video-and-Language/</url>
      
        <content type="html"><![CDATA[<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><p>本文的主要贡献：</p><ol><li>同时使用了action feature of C3D and frames features。但是由于对C3D的特征也采用了mean pooling的方法，有缺陷，对action 特征的一种破坏。</li><li>提出了relevance loss ， 来加强整个句子的语义与视觉特征之间的关系。  </li></ol><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>目前存在的方法，依据给定的先前的单词以及视觉信息，来生成words，但是并没有利用句子语义与视觉内容之间的关系，导致生成的句子可能上下文是正确的，但是语义是错误的。<br>如 figure1，LSTM model 生成的句子是a man is riding a horse，逻辑上是没有错误的，但是语义却错了，图中出现的是woman 而不是man。<br>　　<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0f0qr6d2ij30lq0biq8s.jpg" width="500" hegiht="313" align="center"></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>  简单介绍LSTM-E：LSTM-E可以同时利用LSTM学习和视觉-语义embedding。LSTM 学习是为了在给定先前的单词以及视觉特征的基础上，最大化生成下一个单词的概率，后者是为了生成视觉-语义embedding，来加强整个句子的语义与视觉特征之间的关系。<br>  <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0f87gorc9j316d0kr11m.jpg" title="overview">  </p><ul><li><strong>Overview</strong><br>2D/3D 卷积神经网络被用来提取视频frames/clips的特征，平均池化来得到视频的特征。<br>基于视频特征<strong><em>v</em></strong>和句子语义<strong><em>s</em></strong>，生成sentences的<strong>LSTM model</strong> 和<strong>视觉-语义embeddeing model</strong> 联合学习。</li><li><strong>The sprit of LSTM-E</strong><br>在coherence和relevance之间的相互增强下来生成sentences。<strong><em>coherence:</em></strong>表达了生成words与视频内容之间的相关关系，由LSTM优化完成。<strong><em>relevance:</em></strong>整个句子的语义与视频内容之间的关系，由视觉-语义embeddeing model来度量。通过联合学习coherence和relevance，期望生成的句子在语境和语义上是正确的。</li><li><strong>说人话</strong><br>由两个model组成，一个是sequence learning 都有的coherence loss ，来最大化生成next word的似然概率；另一个是本文添加的relevance loss，通过优化视频特征与生成句子之间的差距，使得生成的句子语义上能对应video的内容。即同时考虑了句子单词之间的上下文关系，也考虑了句子语义与视频内容之间的关系。</li><li><strong>contribution</strong><br>提出了relevance loss !  </li></ul><h2 id="Video-Description-with-Relevance-and-Coherence"><a href="#Video-Description-with-Relevance-and-Coherence" class="headerlink" title="Video Description with Relevance and Coherence"></a>Video Description with Relevance and Coherence</h2><ul><li><strong>Visual-Semantic Embedding: Relevance</strong><br><strong><em>v</em></strong> 和 <strong><em>s</em></strong> 分别是视频的特征和sentences的特征（即，都是已知的），Ts和Tv用来降维到相同的维度，为了度量视频内容与句子语义之间的相关性，一个自然地方法是计算embedding之间的距离，因此定义relevance loss:<br><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0f8zoni8tj30bc01pmx2.jpg" 　style="zoom:45%"></li><li><strong>Translation by Sequence Learning: Coherence</strong><br>coherence loss：即为在给定视频特征的条件下，生成sentences的最大似然概率。  <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0f9l8bbvoj30ph02pglq.jpg" style="zoom:50%">  由overview的图可知，在实际的情况下LSTM的输入是：第一个LSTM输入是视频特征，其余的是前一个time step 生成的单词（在train时：是caption中给定的第t个单词，在test时：是前一个time step 生成的单词）。因此似然函数可以具体的表示为：  　　<img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0f9lgy6nfj317806fgm5.jpg" style="zoom:40%"></li></ul><h2 id="Joint-Modeling-Embedding-and-Translation"><a href="#Joint-Modeling-Embedding-and-Translation" class="headerlink" title="Joint Modeling Embedding and Translation"></a>Joint Modeling Embedding and Translation</h2><ul><li><p><strong>simultaneously minimizing the relevance loss and coherence loss.</strong>  </p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0fa1y3nkgj30nu05pq3p.jpg" style="zoom:70%"></li><li><p>*<em>LSTM结构 *</em><br>这里有多种方式来结合visual content 和 word of last time step。法一：each time step 都输入视频特征；法二：只在第一步输入视频特征。但是在[ 1 ]中指出，由于网络可以显式地利用噪声和更容易覆盖，所以每次输入图像都会产生劣质的效果。 因此，采用第二种方法，在给定视频特征v 和相对应的 sentence W ≡ [w0, w1, …, wNs]，LSTM的更新步骤如下：  </p><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0fcc8tiqej30z708l0t3.jpg">  <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0faic2fuzj30n508njs2.jpg" style="width: 50%; height: 50%">  在初始的第一步，视频特征作为LSTM的输入；在第二步，<#start#>开始的标志作为LSTM的输入，同时接受上一步的hidden state, cell state，以后每一步，都将上一步生成的word 作为输入，直至生成<#end#>。从第二步开始，使用LSTM cell 的hidden state 来预测 word( 对于LSTM output 与 hidden[0] 是一样的，参考：[https://mp.csdn.net/postedit/87516958](https://mp.csdn.net/postedit/87516958))<blockquote><p><code>output, hidden = self.rnn(input, hidden)</code></p></blockquote></#end#></#start#></li></ul><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><ul><li><strong>dataset</strong><br>MSVD:<br>Microsoft Research Video Description Corpus (YouTube2Text) , which contains 1,970 YouTube snippets. There are roughly 40 available English descriptions per video. In our experiments, we follow the setting used in prior works, taking 1,200 videos for training, 100 for validation and 670 for testing.</li><li><strong>result</strong><img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0fcs7kt8cj31ap0bhgow.jpg"></li><li><strong>The effect of hidden layer size</strong>  <img src="http://ww1.sinaimg.cn/large/006uWRWVly1g0fcvqbzvsj30qz09x760.jpg" style="width: 70%; height: 70%">  </li></ul><h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>a visual-semantic embedding space is additionally incorporated into LSTM learning. In this way, <strong>a global relationship between the video content and sentence semantics</strong> is simultaneously measured in addition to <strong>the local contextual relationship between the word at each step and the previous ones</strong> in LSTM learning. On the popular YouTube2Text dataset, the results of our experiments demonstrate the success of our approach, outperforming the current state-ofthe-art models </p><h2 id="Future-Work"><a href="#Future-Work" class="headerlink" title="Future Work"></a>Future Work</h2><p>视频作为一个时域序列，未来将会探究使用RNN来获得更好的特征；另外，如果有更大的数据集，更多的video sentences pairs ，那么可以使用更深的RNN，来得到更好的视频描述</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] O. Vinyals, A. Toshev, S. Bengio, and D. Erhan. Show and tell: A neural image caption generator. In CVPR, 2015.</p>]]></content>
      
      
      <categories>
          
          <category> 视频描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 视频描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub+Hexo 搭建个人网站详细教程</title>
      <link href="/2019/02/21/GitHub-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/"/>
      <url>/2019/02/21/GitHub-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26625249</a></p><p><a href="https://blog.csdn.net/xuezhisdc/article/details/53130328" target="_blank" rel="noopener">https://blog.csdn.net/xuezhisdc/article/details/53130328</a></p><h3 id="增加本地搜索功能"><a href="#增加本地搜索功能" class="headerlink" title="增加本地搜索功能"></a>增加本地搜索功能</h3><h4 id="自定义站点内容搜索"><a href="#自定义站点内容搜索" class="headerlink" title="自定义站点内容搜索"></a>自定义站点内容搜索</h4><ol><li><p>安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-generator-searchdb <span class="comment">--save</span></span><br></pre></td></tr></table></figure></li><li><p>编辑博客配置文件，新增以下内容到任意位置：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">search:</span></span><br><span class="line"><span class="symbol">      path:</span> search.xml</span><br><span class="line"><span class="symbol">      field:</span> post</span><br><span class="line"><span class="symbol">      format:</span> html</span><br><span class="line"><span class="symbol">      limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure></li><li><p>编辑主题配置文件，启用本地搜索功能：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p><a href="https://www.jianshu.com/p/44e211829447" target="_blank" rel="noopener">https://www.jianshu.com/p/44e211829447</a></p><p><a href="http://npm.taobao.org/package/hexo-blog-encrypt" target="_blank" rel="noopener">http://npm.taobao.org/package/hexo-blog-encrypt</a></p><p><a href="https://github.com/MikeCoder/hexo-blog-encrypt/" target="_blank" rel="noopener">https://github.com/MikeCoder/hexo-blog-encrypt/</a></p>]]></content>
      
      
      <categories>
          
          <category> 杂类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
