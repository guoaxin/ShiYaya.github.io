<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ShiYaya</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-03-20T03:24:45.296Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ShiYaya</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>How Many Data Points is a PromptWorth?</title>
    <link href="http://yoursite.com/2021/03/20/How-Many-Data-Points-is-a-PromptWorth/"/>
    <id>http://yoursite.com/2021/03/20/How-Many-Data-Points-is-a-PromptWorth/</id>
    <published>2021-03-20T03:24:45.000Z</published>
    <updated>2021-03-20T03:24:45.296Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[It’s Not Just Size That Matters] Small Language Models Are Also Few-Shot Learners</title>
    <link href="http://yoursite.com/2021/03/20/It%E2%80%99s-Not-Just-Size-That-Matters-Small-Language-Models-Are-Also-Few-Shot-Learners/"/>
    <id>http://yoursite.com/2021/03/20/It’s-Not-Just-Size-That-Matters-Small-Language-Models-Are-Also-Few-Shot-Learners/</id>
    <published>2021-03-20T02:51:52.000Z</published>
    <updated>2021-03-21T04:10:07.946Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<a href="https://www.sohu.com/a/422484297_500659" target="_blank" rel="noopener">https://www.sohu.com/a/422484297_500659</a></p><p>显然，这标题对标的就是 GPT-3，于是笔者饶有兴趣地点进去看看是谁这么有勇气挑战 GPT-3，又是怎样的小模型能挑战 GPT-3？经过阅读，原来作者提出通过适当的构造， <strong>用 BERT 的 MLM 模型</strong>也可以做小样本学习，看完之后颇有一种“原来还可以这样做”的恍然大悟感。在此与大家分享一下。</p><h2 id="冉冉升起的MLM"><a href="#冉冉升起的MLM" class="headerlink" title="冉冉升起的MLM"></a><strong>冉冉升起的MLM</strong></h2><p>MLM，全称“Masked Language Model”，可以翻译为“掩码语言模型”，实际上就是一个完形填空任务，随机 Mask 掉文本中的某些字词，然后要模型去预测被 Mask 的字词，示意图如下：</p><p><img src="https://i.loli.net/2021/03/20/izGapk4S6ZRqgFI.png" alt="img" style="zoom:50%;"></p><p>▲ BERT的MLM模型简单示意图</p><p>其中被 Mask 掉的部分，可以是直接随机选择的 Token，也可以是随机选择连续的能组成一整个词的 Token，后者称为 WWM（Whole Word Masking）。</p><p>开始，MLM 仅被视为 BERT 的一个预训练任务，训练完了就可以扔掉的那种，因此有一些开源的模型干脆没保留 MLM 部分的权重，比如 brightmart 版 [3] 和 clue 版 [4] 的 RoBERTa，而哈工大开源的 RoBERTa-wwm-ext-large [5]则不知道出于什么原因随机初始化了 MLM 部分的权重，因此如果要复现本文后面的结果，这些版本是不可取的。</p><p>然而，随着研究的深入，研究人员发现不止 BERT 的 Encoder 很有用，预训练用的 MLM 本身也很有用。</p><p>比如论文 <strong>BERT has a Mouth, and It Must Speak: BERT as a Markov Random Field Language Model</strong>[6]指出 MLM 可以作为一般的生成模型用，论文 <strong>Spelling Error Correction with Soft-Masked BERT</strong>[7] 则将 MLM 用于文本纠错。</p><p>笔者之前在 的实验也表明 MLM 的预训练权重也可以当作 UniLM 来用做 Seq2Seq 任务，还有一文将 MLM 的思想用于无监督分词和句法分析了。可以说 MLM 已经是大放异彩了。</p><h2 id="将任务转成完形填空"><a href="#将任务转成完形填空" class="headerlink" title="将任务转成完形填空"></a><strong>将任务转成完形填空</strong></h2><p>在本文里，我们再学习 MLM 的一个精彩应用：用于小样本学习或半监督学习，某些场景下甚至能做到零样本学习。</p><p>怎么将我们要做的任务跟 MLM 结合起来呢？很简单， <strong>给任务一个文本描述，然后转换为完形填空问题</strong>即可。举个例子，假如给定句子“这趟北京之旅我感觉很不错。”，那么我们补充个描述，构建如下的完形填空：</p><blockquote><p> <strong>__</strong>满意。这趟北京之旅我感觉很不错。</p></blockquote><p>进一步地，我们限制空位处只能填一个“很”或“不”，问题就很清晰了，就是要我们根据上下文一致性判断是否满意，如果“很”的概率大于“不”的概率，说明是正面情感倾向，否则就是负面的，这样我们就将<strong>情感分类问题</strong>转换为一个完形填空问题了，它可以用 MLM 模型给出预测结果，而 MLM 模型的训练可以不需要监督数据，因此理论上这能够实现零样本学习了。</p><p><strong style="color:blue;">多分类问题</strong>也可以做类似转换，比如<strong>新闻主题分类</strong>，输入句子为“八个月了，终于又能在赛场上看到女排姑娘们了。”，那么就可以构建：</p><blockquote><p> 下面播报一则<strong>__</strong>新闻。八个月了，终于又能在赛场上看到女排姑娘们了。</p></blockquote><p>这样我们就将新闻主题分类也转换为完形填空问题了，一个好的 MLM 模型应当能预测出“体育”二字来。</p><p>还有一些<strong style="color:blue;">简单的推理任务</strong>也可以做这样的转换，常见的是给定两个句子<strong>，判断这两个句子是否相容</strong>，比如“我去了北京”跟“我去了上海”就是矛盾的，“我去了北京”跟“我在天安门广场”是相容的，常见的做法就是将两个句子拼接起来输入到模型做，作为一个二分类任务。如果要转换为完形填空，那该怎么构造呢？一种比较自然的构建方式是：</p><blockquote><p>我去了北京？<strong>__</strong>，我去了上海。</p><p>我去了北京？<strong>__</strong>，我在天安门广场。</p><p>其中空位之处的候选词为 是 的 不 是 。</p></blockquote><h2 id="Pattern-Exploiting-Training"><a href="#Pattern-Exploiting-Training" class="headerlink" title="Pattern-Exploiting Training"></a><strong>Pattern-Exploiting Training</strong></h2><p>读到这里，读者应该不难发现其中的规律了，就是给输入的文本增加一个前缀或者后缀描述，并且 Mask 掉某些 Token，转换为完形填空问题，这样的转换在原论文中称为 <strong>Pattern</strong>，这个转换要尽可能与原来的句子组成一句自然的话，不能过于生硬，因为预训练的 MLM 模型就是在自然语言上进行的。</p><p>显然同一个问题可以有很多不同的 Pattern，比如情感分类的例子，描述可以放最后，变成“这趟北京之旅我感觉很不错。<strong><strong>满意。”；也可以多加几个字，比如“觉得如何？</strong></strong>满意。这趟北京之旅我感觉很不错。”。</p><p>然后，我们需要构建预测 Token 的候选空间，并且建立 Token 到实际类别的映射，这在原论文中称为 <strong>Verbalizer</strong>，比如情感分类的例子，我们的候选空间是 很 不 ，映射关系是 很 正 面 不 负 面 ，候选空间与实际类别之间不一定是一一映射，比如我们还可以加入“挺”、“太”、“难”字，并且认为 很 挺 太 正 面 以 及 不 难 负 面 ，等等。</p><p>不难理解，不少 NLP 任务都有可能进行这种转换，但显然这种转换一般只适用于 <strong>候选空间有限</strong>的任务，说白了就是只用来做 <strong>选择题</strong>，常见任务的就是 <strong>文本分类</strong>。</p><p>刚才说了，同一个任务可以有多种不同的 Pattern，原论文是这样处理的：</p><ol><li><p>对于每种 Pattern，单独用训练集 Finetune一个 MLM 模型出来；</p></li><li><p>然后将不同 Pattern对应的模型进行集成，得到融合模型；</p></li><li><p>用融合模型预测未标注数据的伪标签；</p></li><li><p>用伪标签数据 Finetune 一个常规的（非 MLM 的）模型。</p></li></ol><p>具体的集成方式大家自己看论文就行，这不是重点。这种训练模式被称为 <strong>Pattern-Exploiting Training（PET）</strong>，它首先出现在论文 <strong>Exploiting Cloze Questions for Few Shot Text Classification and Natural Language Inference</strong>。</p><p><strong style="color:blue;">yaya: 与 这篇论文思想很类似：How Many Data Points is a PromptWorth? （arXiv: 2103.08493v1）</strong></p><p>本文要介绍的这篇论文则进一步肯定和完善了 Pattern-Exploiting Training 的价值和结果，并整合了多任务学习，使得它在 SuperGLUE 榜单上的小样本学习效果超过了 GPT3。两篇论文的作者是相同的，是一脉相承的作品。</p><p><img src="https://i.loli.net/2021/03/20/dOMZNLsKykIDioQ.png" alt="img"></p><p>▲ PET在SuperGLUE上的小样本学习的结果</p><p>不过要吐槽一个点是，上图中 PET 的 223M 参数，所用的模型是 ALBERT-xxlarge-v2，事实上称 ALBERT 为“小模型”是一种很耍流氓的行为，因为它前向计算的速度并没有得到任何提升。ALBERT-xxlarge 共有 12 层，层与层之间参数是共享的，就前向计算而言，它应该等价于约 2700M（12 倍）参数的 GPT 才对。</p><h2 id="中文实践，检验效果"><a href="#中文实践，检验效果" class="headerlink" title="中文实践，检验效果"></a><strong>中文实践，检验效果</strong></h2><p>要真正确认一个方法或模型的价值，看论文的实验表格是不够的，论文给出的实验结果谁都不好说能否复现，其次就算英文上能复现也不代表中文上有价值，因此最实际的还是亲自动手做实验验证。下面是笔者的实验代码，供读者参考：</p><p>Github 地址：</p><p><a href="https://github.com/bojone/Pattern-Exploiting-Training" target="_blank" rel="noopener">https://github.com/bojone/Pattern-Exploiting-Training</a></p><p>我们将从以下几个角度来探讨 PET 的可行性：</p><p>\1. 直接利用现成的 MLM 模型效果如何？ <strong>（零样本学习1）</strong></p><p>\2. 用“大量无标签数据”微调现成的 MLM 模型效果如何？ <strong>（零样本学习2）</strong></p><p>\3. 用“小量标签数据”微调现成的 MLM 模型效果如何？ <strong>（小样本学习）</strong></p><p>\4. 用“小量标签数据+大量无标签数据”微调现成的MLM模型效果如何？ <strong>（半监督学习）</strong></p><p>下面主要给出 <strong>情感二分类</strong>的实验结果。另外还有一个新闻主题的多分类，代码也放到 Github 了，其结果是类似的，就不重复陈述了。</p><h3 id="4-1-零样本学习1"><a href="#4-1-零样本学习1" class="headerlink" title="4.1 零样本学习1"></a><strong>4.1 零样本学习1</strong></h3><p>这里主要探索的是给输入文本补上对应的 Pattern 后，直接基于现成的 MLM 模型进行预测，预测的准确率。由于构建模型的整个过程都不涉及到标签数据监督训练，因此这算是一种“零样本学习”。我们需要比较的是不同 Pattern、不同 MLM 模型上的效果：</p><p>下面是实验的几个 Pattern，其中空位处候选词语都为“很”和“不”：</p><p>P1：____满意。这趟北京之旅我感觉很不错。</p><p>P2：这趟北京之旅我感觉很不错。____满意。</p><p>P3：____好。这趟北京之旅我感觉很不错。</p><p>P4：____理想。这趟北京之旅我感觉很不错。</p><p>P5：感觉如何？____满意。这趟北京之旅我感觉很不错。</p><p>至于 MLM 模型，则是下面几个：</p><p>M1：Google 开源的中文版 BERT Base：</p><p><a href="https://github.com/google-research/bert" target="_blank" rel="noopener">https://github.com/google-research/bert</a></p><p>M2：哈工大开源的 RoBERTa-wwm-ext Base：</p><p><a href="https://github.com/ymcui/Chinese-BERT-wwm" target="_blank" rel="noopener">https://github.com/ymcui/Chinese-BERT-wwm</a></p><p>M3：腾讯 UER 开源的 BERT Base：</p><p><a href="https://share.weiyun.com/5QOzPqq" target="_blank" rel="noopener">https://share.weiyun.com/5QOzPqq</a></p><p>M4：腾讯 UER 开源的 BERT Large：</p><p><a href="https://share.weiyun.com/5G90sMJ" target="_blank" rel="noopener">https://share.weiyun.com/5G90sMJ</a></p><p>实验结果如下表（验证集/测试集）：</p><p><img src="https://i.loli.net/2021/03/20/8Yg2qH5CXoFPkcx.png" alt="img"></p><p>可以观察到，不同的 Pattern、不同的预训练模型之间还是有一定的差异的，整体而言 Large 版本的效果要明显好于 Base 版本的模型，说明像 GPT 到 GPT2 再到 GPT3 一样，还是把模型做得更大会更好。</p><p>此外，这还有可能说明实际上 MLM 还没有被充分训练好，或许是因为 BERT 这种 Mask 掉一部分的训练方式过于低效了，可能用 修改 Transformer 结构，设计一个更快更好的 MLM 模型 一文提到的改进版 MLM 会更好。</p><h3 id="4-2-零样本学习2"><a href="#4-2-零样本学习2" class="headerlink" title="4.2 零样本学习2"></a><strong>4.2 零样本学习2</strong></h3><p>看完上述结果，读者可能会想到：如果我用领域内的数据继续预训练 MLM 模型，那么能不能提升效果呢？答案是：能！下面是我们的实验结果，算力有限，我们只在 RoBERTa-wwm-ext（上述的 M2，继续预训练后的模型我们称为 M2+ 无监督）的基础上做了比较：</p><p><img src="https://i.loli.net/2021/03/20/Y8CdHbW1cjqByrD.png" alt="img"></p><p>要注意的是，这里我们只是用领域内的数据继续做 MLM 训练，这个过程是无监督的，也不需要标注信号，因此也算是“零样本学习”。同时，从到目前为止的结果我们可以看出，给输入本文加入“前缀”的效果比“后缀”更有优势一些。</p><h3 id="4-3-小样本学习"><a href="#4-3-小样本学习" class="headerlink" title="4.3 小样本学习"></a><strong>4.3 小样本学习</strong></h3><p>刚才我们讨论了无标签数据继续预训练 MLM 的提升，如果回到 PET 的目标场景，直接用小量的标签数据配合特定的 Pattern 训练 MLM 又如何呢？</p><p>这也就是真正的“小样本学习”训练了，这里我们保留约 200 个标注样本，构造样本的时候，我们先给每个句子补上 Pattern，除了 Pattern 自带的 Mask 位置之外，我们还随机 Mask 其他一部分，以增强对模型的正则。最终实验结果如下：</p><p><img src="https://i.loli.net/2021/03/20/qVFgDbyLQrXpZUt.png" alt="img"></p><p>结论就是除了“后缀式”的 P2 之外，其它结果都差不多，这进一步说明了“前缀式”的 Pattern 会比“后缀式”更有竞争力一些。在效果上，直接用同样的数据用常规的方法去微调一个 BERT 模型，大概的结果是 88.93 左右，所以基于 “MLP+Pattern” 的小样本学习方法可能带来轻微的性能提升。</p><h3 id="4-4-半监督学习"><a href="#4-4-半监督学习" class="headerlink" title="4.4 半监督学习"></a><strong>4.4 半监督学习</strong></h3><p>无监督的零样本学习和有监督的小样本学习都说完了，自然就轮到把标注数据和非标注数据都结合起来的“半监督学习”了。还是同样的任务，标注数据和非标注数据的比例大约是 1:99，标注数据带 Pattern，非标注数据不带 Pattern，大家都 Mask 掉一部分 Token 进行 MLM 预训练，最终测出来的效果如下：</p><p><img src="https://i.loli.net/2021/03/20/4QKcUYDtgAmeGqM.png" alt="img"></p><p>还是同样的，“后缀”明显比“前缀”差，“前缀”的效果差不多。具体效果上，则是肯定了额外的无标注数据也是有作用的。</p><p>直觉上来看，“前缀”比“后缀”要好，大体上是因为“前缀”的 Mask 位置比较固定，微弱的监督信号得以叠加增强？但这也不能解释为什么零样本学习的情况下也是“前缀”更好，估计还跟模型的学习难度有关系，可能句子前面部分的规律更加明显，相对来说更加容易学一些，所以前面部分就学习得更加充分？这一切都还只是猜测。</p><h3 id="4-5-汇总与结论"><a href="#4-5-汇总与结论" class="headerlink" title="4.5 汇总与结论"></a><strong>4.5 汇总与结论</strong></h3><p>将上述结果汇总如下：</p><p><img src="https://i.loli.net/2021/03/20/cpGqLZ2twR5z4di.png" alt="img"></p><p>读者还可以对比我们之前在文章 泛化性乱弹：从随机噪声、梯度惩罚到虚拟对抗训练 中用虚拟对抗训练（VAT）做半监督学习的结果，可以看到不管是零样本学习、小样本学习还是半监督学习，基于 MLM 模型的方式都能媲美基于 VAT 的半监督学习的结果。</p><p>我们在做短新闻多分类实验时的结果也是相似的。因此，这说明了 MLM 模型确实也可以作为一个优秀的零样本/小样本/半监督学习器来使用。</p><p>当然，基于 MLM 模型的缺点还是有的，比如 MLM 所使用的独立假设限制了它对更长文本的预测能力（说白了空位处的文字不能太长），以及无法预测不定长的答案也约束了它的场景（所以当前只能用于做选择题）。我们期待有更强的 MLM 模型出现，那时候就有可能在所有任务上都能与 GPT3 一较高下了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文介绍了 BERT 的 MLM 模型的一个新颖应用：配合特定的描述将任务转化为完形填空，利用 MLM 模型做零样本学习、小样本学习和半监督学习。</p><p>在原论文的 SuperGLUE 实验里边，它能达到媲美 GPT3 的效果，而笔者也在中文任务上做了一些实验，进一步肯定了该思路的有效性。整个思路颇为别致，给人一种“原来还可以这样做”的恍然大悟感，推荐大家学习一下。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://arxiv.org/abs/2005.14165" target="_blank" rel="noopener">https://arxiv.org/abs/2005.14165</a></p><p>[2] <a href="https://arxiv.org/abs/2009.07118" target="_blank" rel="noopener">https://arxiv.org/abs/2009.07118</a></p><p>[3] <a href="https://github.com/brightmart/roberta_zh" target="_blank" rel="noopener">https://github.com/brightmart/roberta_zh</a></p><p>[4] <a href="https://github.com/CLUEbenchmark/CLUEPretrainedModels" target="_blank" rel="noopener">https://github.com/CLUEbenchmark/CLUEPretrainedModels</a></p><p>[5] <a href="https://github.com/ymcui/Chinese-BERT-wwm" target="_blank" rel="noopener">https://github.com/ymcui/Chinese-BERT-wwm</a></p><p>[6] <a href="https://arxiv.org/abs/1902.04094" target="_blank" rel="noopener">https://arxiv.org/abs/1902.04094</a></p><p>[7] <a href="https://kexue.fm/archives/7661" target="_blank" rel="noopener">https://kexue.fm/archives/7661</a></p><p>[8] <a href="https://arxiv.org/abs/2001.07676" target="_blank" rel="noopener">https://arxiv.org/abs/2001.07676</a></p><h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><p>不懂的问题：</p><ul><li><p>mask 一个 Span, 多个空位然后逐词预测？？</p></li><li><p>在 [MASK] 位置 预测空间是多大？整个vocabulary ??</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：&lt;a href=&quot;https://www.sohu.com/a/422484297_500659&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.sohu.com/a/422484297_500659&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;显然
      
    
    </summary>
    
      <category term="NLP" scheme="http://yoursite.com/categories/NLP/"/>
    
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>[All NLP Tasks Are Generation Tasks] A General Pretraining Framework</title>
    <link href="http://yoursite.com/2021/03/20/All-NLP-Tasks-Are-Generation-Tasks-A-General-Pretraining-Framework/"/>
    <id>http://yoursite.com/2021/03/20/All-NLP-Tasks-Are-Generation-Tasks-A-General-Pretraining-Framework/</id>
    <published>2021-03-20T01:53:44.000Z</published>
    <updated>2021-03-20T02:47:38.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>目前基于预训练 的语言模型大致分为三类：</p><ul><li>autoregressive models (e.g.,GPT) 擅长长文本生成</li><li>autoencoding models (e.g., BERT) 擅长理解型任务，分类任务</li><li>encoder-decoder models (e.g., T5) 擅长基于条件的文本生成任务，比如 text summarize</li></ul><p>但是目前还未存在一个预训练框架可以在这三种任务上同时表现出优异的性能。这给模型的开发和选择带来了不便。</p><p>下表总结了不同的预训练框架可以处理的任务：</p><p><img src="https://i.loli.net/2021/03/20/ldKAem71a86xBcq.png" alt="image-20210320100920079" style="zoom: 25%;"></p><p>先前的工作试图通过多任务学习将各自的 objective 结合起来，从而统一不同的框架。但是，自回归和自编码的 objective 在本质上是不同的，简单的结合不能够充分的揭示所有框架的优势。</p><h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><p>本文提出了一个新颖的预训练框架GLM（General Language Model）来解决这个问题。</p><ul><li><p>本文的GLM基于autoregressive blank-filling，<strong style="color:red;">遵循自动编码(auto-encoding)的思想，我们从输入文本中随机消除了令牌的连续跨度。并遵循自回归预训练(auto-regressive)的思想训练模型以重建跨度。</strong></p></li><li><p>为了在一个框架中同时学习双向和单向的注意力机制，本文将文本分成两部分，未掩码的部分可以互相关注。掩码的部分不可以关注后续的掩码的token。</p></li><li>本文还提出了一个 2D位置编码技术，来指示inter- and intra- span position information。</li></ul><p>因此，本文的框架 GLM在预训练过程中，可以同时学习上下文表达和自回归生成。</p><p><img src="https://i.loli.net/2021/03/20/VrzfCnOFQi27NRU.png" alt="image-20210320103954828" style="zoom: 33%;"></p><h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><p>本文的结构有三个主要的优势：</p><ul><li>在一个预训练模型上，可以在三种任务上都表现的很好。</li><li>由于 <strong style="color:blue;">pretrain-finetune consistency</strong>，在分类任务上，本文提出的模型相比 BERT-like models 性能更加优异。</li><li>可以自然的处理 <strong style="color:red;">variable-length blank filling</strong>，这对很多下游任务是很重要的。</li></ul><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;存在的问题&quot;&gt;&lt;a href=&quot;#存在的问题&quot; class=&quot;headerlink&quot; title=&quot;存在的问题&quot;&gt;&lt;/a&gt;存在的问题&lt;/h2&gt;&lt;p&gt;目前基于预训练 的语言模型大致分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;autoregressive models (e
      
    
    </summary>
    
      <category term="NLP" scheme="http://yoursite.com/categories/NLP/"/>
    
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>Transformer</title>
    <link href="http://yoursite.com/2021/03/19/Transformer/"/>
    <id>http://yoursite.com/2021/03/19/Transformer/</id>
    <published>2021-03-19T10:58:13.000Z</published>
    <updated>2021-03-19T11:32:07.770Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/03/19/DrhRUENTcwXPo89.png" alt="image-20210319185913348" style="zoom:50%;"></p><p>Transformer模型中采用了 encoer-decoder 架构。论文中encoder层由6个encoder堆叠在一起，decoder层也一样。</p><h2 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h2><p>对于encoder，包含两层，一个self-attention层和一个前馈神经网络，self-attention能帮助当前节点不仅仅只关注当前的词，从而能获取到上下文的语义。</p><h2 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h2><p>decoder也包含encoder提到的两层网络，但是在这两层中间还有一层attention层，帮助当前节点获取到当前需要关注的重点内容。</p><p>Decoder 和 Encoder的结构差不多，但是多了一个attention的sub-layer，这里先明确一下decoder的输入输出和解码过程：</p><ul><li>输出：对应 $i$ 位置的输出词的概率分布</li><li>输入：encoder的输出 与 对应  $i-1$ 位置decoder的输出。所以中间的attention不是self-attention，它的<strong style="color:blue;">K，V来自encoder</strong>，<strong style="color:blue;">Q来自上一位置decoder的输出</strong></li><li><p>解码：这里要注意一下，训练和预测是不一样的。在训练时，解码是一次全部decode出来，用上一步的ground truth来预测（mask矩阵也会改动，让解码时看不到未来的token）；而预测时，因为没有ground truth了，需要一个个预测。</p><p>为了确保按照生成顺序：从左到右，使用sequence mask。</p><p>sequence mask 是为了使得 decoder 不能看见未来的信息。也就是对于一个序列，在 time_step 为 t 的时刻，我们的解码输出应该只能依赖于 t 时刻之前的输出，而不能依赖 t 之后的输出。因此我们需要想一个办法，把 t 之后的信息给隐藏起来。</p><p>那么具体怎么做呢？也很简单：产生一个上三角矩阵，上三角的值全为0。把这个矩阵作用在每一个序列上，就可以达到我们的目的。</p></li></ul><p><img src="https://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase64156846899939997439.gif" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/19/DrhRUENTcwXPo89.png&quot; alt=&quot;image-20210319185913348&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Transformer模型中采用了 en
      
    
    </summary>
    
      <category term="NLP" scheme="http://yoursite.com/categories/NLP/"/>
    
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>On Semantic Similarity in Video Retrieval</title>
    <link href="http://yoursite.com/2021/03/19/On-Semantic-Similarity-in-Video-Retrieval/"/>
    <id>http://yoursite.com/2021/03/19/On-Semantic-Similarity-in-Video-Retrieval/</id>
    <published>2021-03-19T08:50:22.000Z</published>
    <updated>2021-03-19T08:50:22.671Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Non-Autoregressive Coarse-to-Fine Video Captioning</title>
    <link href="http://yoursite.com/2021/03/19/Non-Autoregressive-Coarse-to-Fine-Video-Captioning/"/>
    <id>http://yoursite.com/2021/03/19/Non-Autoregressive-Coarse-to-Fine-Video-Captioning/</id>
    <published>2021-03-19T08:49:05.000Z</published>
    <updated>2021-03-19T08:49:05.794Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[Less is More] CLIPBERT for Video-and-Language Learning via Sparse Sampling</title>
    <link href="http://yoursite.com/2021/03/18/Less-is-More-CLIPBERT-for-Video-and-Language-Learning-via-Sparse-Sampling/"/>
    <id>http://yoursite.com/2021/03/18/Less-is-More-CLIPBERT-for-Video-and-Language-Learning-via-Sparse-Sampling/</id>
    <published>2021-03-18T07:33:09.000Z</published>
    <updated>2021-03-18T07:33:45.556Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="cross-modal" scheme="http://yoursite.com/categories/cross-modal/"/>
    
      <category term="end-to-end" scheme="http://yoursite.com/categories/cross-modal/end-to-end/"/>
    
    
      <category term="cross-modal" scheme="http://yoursite.com/tags/cross-modal/"/>
    
      <category term="end-to-end" scheme="http://yoursite.com/tags/end-to-end/"/>
    
  </entry>
  
  <entry>
    <title>[LightningDOT] Pre-training Visual-Semantic Embeddings for Real-Time Image-Text Retrieval</title>
    <link href="http://yoursite.com/2021/03/18/LightningDOT-Pre-training-Visual-Semantic-Embeddings-for-Real-Time-Image-Text-Retrieval/"/>
    <id>http://yoursite.com/2021/03/18/LightningDOT-Pre-training-Visual-Semantic-Embeddings-for-Real-Time-Image-Text-Retrieval/</id>
    <published>2021-03-18T06:02:17.000Z</published>
    <updated>2021-03-18T12:03:51.495Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-任务"><a href="#1-任务" class="headerlink" title="1. 任务"></a>1. 任务</h2><p>本文发表在 NAACL 2021，本文要研究的内容是如何提高 <strong>Image-text retrieval 任务的计算效率。</strong></p><h2 id="2-存在的问题"><a href="#2-存在的问题" class="headerlink" title="2. 存在的问题"></a>2. 存在的问题</h2><p>基于预训练的跨模态模型取得了很好的进展，但是在测试阶段存在<strong>推理速度慢</strong>的问题。 主要是由于Transformer 结构中的cross-modal attention 造成的巨大的计算消耗。 这种延迟以及计算消耗使其很难在实际中应用。</p><p>下图可视化了近年来 ITR task 的研究进展，（a） 早期，使用CNN和RNN分别提取视觉和语言特征，然后使用dot-product 来计算similarity。 （b）后来有人提出使用faster-RCNN 和 RNN 分别提取两个模态的特征，使用使用cross-attention，最后再计算相似性。（c）随着BERT的发展，有人使用BERT扩展出 V+L BERT 模型。(d) 由于cross-modal attention 是耗时的，因此，本文中提出去掉cross-modal 这个模块。</p><p><img src="https://i.loli.net/2021/03/18/fdU3lxwpkZo8yuG.png" alt="image-20210318143100485" style="zoom:50%;"></p><h2 id="3-本文的点"><a href="#3-本文的点" class="headerlink" title="3. 本文的点"></a>3. 本文的点</h2><ul><li>本文希望可以重新回归到 <strong>dot-product</strong> 这个简单的操作。本文中使用dot product 来做多模态融合，而不是使用计算量的self-attention。同时，为了利用有效的多模态嵌入学习，本文在两个encoder上都使用 [CLS] token。</li><li><p>通过消除模态之间耗时的交叉注意力，该模型可以在推理过程中学习视觉语义嵌入而无需在每个图像-文本对之间进行广泛匹配。此外，通过消除对图像-文本对的实时计算的依赖，我们可以一次<strong>离线地独立地</strong>计算所有图像和文本嵌入，并将这些嵌入重新用作新查询的<strong>缓存索引</strong>。</p></li><li><p>LightningDOT通过预先训练<strong>三个新颖的学习目标</strong>：Visual-embedding fused MLM (namely VMLM), Semantic-embedding  fused MRM (namely SMRM) and a cross-modal retrieval objective (namely CMR).</p><p>前两个预训练任务（VMLM 和 SMRM）是为了确保跨模态信息可以被获取到。CMR是为了鼓励模型在预训练阶段获得多模态融合。</p></li><li><p>重新排名（re-ranking）机制</p></li></ul><p>Note: 本文不是从模型压缩的角度来解决问题。</p><h2 id="4-贡献"><a href="#4-贡献" class="headerlink" title="4. 贡献"></a>4. 贡献</h2><p>提出了一个简单有效的方法，在不牺牲accuracy 的情况下，LightningDOT 可以数千倍的加速推理时间。</p><p>我们的工作是在基于预训练视觉语义嵌入，实现低延迟的实时跨模式检索的第一个已知工作。</p><h2 id="5-Method"><a href="#5-Method" class="headerlink" title="5. Method"></a>5. Method</h2><p><img src="https://i.loli.net/2021/03/18/kASuJa8xc6hYFne.png" alt="image-20210318175408610" style="zoom: 67%;"></p><p>在本节中，我们介绍LightningDOT框架，该框架由两个深层的Transformer作为图像和语言编码器。我们首先介绍三个预训练任务，然后介绍从<strong>离线特征提取</strong>到<strong>在线即时检索</strong>的 <strong>推理流程（inference pipline）</strong>。</p><p>图像编码器得到region features: $f_{\theta_{V}}(\mathbf{v})=\mathbf{h}=\left\{\mathbf{h}_{0}, \ldots, \mathbf{h}_{N}\right\}\left(\mathbf{h}_{j} \in \mathbb{R}^{d}\right)$</p><p>语言编码器得到token representations: $f_{\theta_{L}}(\mathbf{w})=\mathbf{z}=\left\{\mathbf{z}_{0}, \ldots, \mathbf{z}_{T}\right\}\left(\mathbf{z}_{j} \in \mathbb{R}^{d}\right)$</p><p>regard the output [CLS] embedding <strong><strong style="color:red;">$h_0$</strong> as global image representation</strong>, and <strong><strong style="color:red;">$z_0$</strong>as global text representation</strong></p><h3 id="5-1-Model-Pre-training"><a href="#5-1-Model-Pre-training" class="headerlink" title="5.1 Model Pre-training"></a>5.1 Model Pre-training</h3><h4 id="Visual-embedding-Fused-Masked-Language-Modeling-VMLM"><a href="#Visual-embedding-Fused-Masked-Language-Modeling-VMLM" class="headerlink" title="Visual-embedding Fused Masked Language Modeling (VMLM)"></a>Visual-embedding Fused Masked Language Modeling (VMLM)</h4><p>设有M个 masked tokens</p><p>对于 sentence $t$ and image $i$ ， The loss function of VMLM can be formulated as:</p><p>$\mathcal{L}_{\mathrm{VMLM}}(t, i)=-\log P_{\theta}\left(\mathbf{w}_{\mathbf{m}} \mid \mathbf{w}_{\backslash \mathbf{m}}, i\right)$<br>$=-\frac{1}{M} \sum_{k=1}^{M} \log P_{\theta_{\mathrm{mlm}}}\left(\mathbf{w}_{\mathbf{m}_{k}} \mid \mathbf{z}_{\mathbf{m}_{k}}+\mathbf{h}_{0}\right)$</p><p>其中 $z$ 是 hidden state。</p><p>Note： 这里的 +$h_0$ 是显式的加和，而不是使用cross-modal attention.</p><h4 id="Semantic-embedding-Fused-Masked-Region-Modeling-SMRM"><a href="#Semantic-embedding-Fused-Masked-Region-Modeling-SMRM" class="headerlink" title="Semantic-embedding Fused Masked Region Modeling (SMRM)"></a>Semantic-embedding Fused Masked Region Modeling (SMRM)</h4><p>$\mathcal{L}_{\mathrm{SMRM}}(i, t)=\mathcal{D}_{\theta_{\mathrm{mrm}}}\left(\mathbf{v}_{\mathbf{m}}, f_{\theta_{V}}\left(\mathbf{v}_{\backslash \mathbf{m}}\right), t\right)$<br>$=\frac{1}{M} \sum_{k=1}^{M} \mathcal{D}_{\theta_{\mathrm{mrm}}}\left(\mathbf{v}_{\mathbf{m}_{k}}, \mathbf{h}_{\mathbf{m}_{k}}+\mathbf{z}_{0}\right)$</p><p>这里的 $\mathcal{D}_{\theta_{\mathrm{mrm}}}$ 代表两个损失，一个是使用L2 distance 的 掩码区域特征回归，另外一个是用KL散度的掩码区域分类。</p><h4 id="Cross-modal-Retrieval-Objective-CMR"><a href="#Cross-modal-Retrieval-Objective-CMR" class="headerlink" title="Cross-modal Retrieval Objective (CMR)"></a>Cross-modal Retrieval Objective (CMR)</h4><p>The similarity score between query t and image i is defined as:</p><p>$S(t, i)=\left\langle\mathbf{z}_{0}, \mathbf{h}_{0}\right\rangle$</p><p>损失函数：</p><p>$\mathcal{L}_{\mathrm{IR}}^{(t)}=-\log \frac{e^{S\left(t, i_{1}\right)}}{\sum_{k=1}^{n} e^{S\left(t, i_{k}\right)}}$</p><p>$\mathcal{L}_{\mathrm{TR}}^{(i)}=-\log \frac{e^{S\left(i, t_{1}\right)}}{\sum_{k=1}^{n} e^{S\left(i, t_{k}\right)}}$</p><p>$\mathcal{L}_{\mathrm{CMR}}(B)=\frac{1}{2 n} \sum_{k=1}^{n} \mathcal{L}_{\mathrm{TR}}^{\left(i_{k}\right)}+\mathcal{L}_{\mathrm{IR}}^{\left(t_{k}\right)}$</p><h3 id="5-2-Real-time-Inference"><a href="#5-2-Real-time-Inference" class="headerlink" title="5.2 Real-time Inference"></a>5.2 Real-time Inference</h3><p>以text-to-image retrieval 作为样例来介绍 real-time inference pipline：</p><p>（1）离线图片特征提取与编码；（2）text query 在线检索；（3）使用top-retrieval images 做在线重拍</p><h4 id="Offline-Feature-Extraction"><a href="#Offline-Feature-Extraction" class="headerlink" title="Offline Feature Extraction"></a>Offline Feature Extraction</h4><p>首先使用 image encoder 来处理数据集中的所有图片，并存储其 global image representation 进入索引的内存中供以后使用。</p><p>整个image-to-index 过程，包括 faster rcnn 提取特征 以及 image transformer encoder 都是离线处理的。</p><h4 id="Online-Retrieval"><a href="#Online-Retrieval" class="headerlink" title="Online Retrieval"></a>Online Retrieval</h4><p>对于 text query, 使用language encoder 提取特征，然后依次计算与每个图片的相似度。图片将会被排序。实际中，人们感兴趣的是前top-k 检索结果。</p><p>使用FAISS来优化检索。</p><p>类似地，对于文本检索，可以通过简单地为所有句子预先计算嵌入并使用图像作为查询来应用相同的体系结构</p><h4 id="Re-ranking"><a href="#Re-ranking" class="headerlink" title="Re-ranking"></a>Re-ranking</h4><p>为了进一步提高检索结果，本文通过采用可选的<strong>重新排名模型</strong>提出了一种两阶段方法。</p><p>第一阶段，使用LightingDOT来检索 top-M images(or texts)。</p><p>第二阶段，使用一个性能更好的检索模型（通常比较慢）来重新排序从第一阶段检索到的 top-M pairs.</p><p>实验证明，可以同时从性能和效率两方面受益。</p><h2 id="6-Experiments"><a href="#6-Experiments" class="headerlink" title="6. Experiments"></a>6. Experiments</h2><h3 id="6-1-Results-on-Flickr30K-and-COCO"><a href="#6-1-Results-on-Flickr30K-and-COCO" class="headerlink" title="6.1 Results on Flickr30K and COCO"></a>6.1 Results on Flickr30K and COCO</h3><p><img src="https://i.loli.net/2021/03/18/TpcoUY7Zjel39dM.png" alt="image-20210318175824380" style="zoom: 50%;"></p><ul><li><p>在仅使用一阶段排序的情况下：</p><ul><li>相比于不使用预训练的模型，性能上有显著提升 CAAN (SOTA method with cross-attention）</li><li>与使用预训练的模型相比，UNITER，性能上仅下降了一点，但是速度上有600/1900倍的提升(Flickr30K/COCO)</li></ul></li><li><p>使用两阶段排序：</p><ul><li>性能上相比于一阶段有提升，同时比单纯的UNITER模型有 46-95倍速度的提升，</li></ul></li></ul><h3 id="6-2-Speed-amp-Space-Improvement"><a href="#6-2-Speed-amp-Space-Improvement" class="headerlink" title="6.2 Speed &amp; Space Improvement"></a>6.2 Speed &amp; Space Improvement</h3><ul><li><p>检索图像，比较推理速度差异</p><p>以 UNITER_base 作为比较对象。</p><p>SCAN，是一个不使用预训练的模型，但是采用了cross-modal attention.</p><p><img src="https://i.loli.net/2021/03/18/umlFqkgLfyKQ6Cx.png" alt="image-20210318180604083" style="zoom: 33%;"></p></li><li><p>扩大搜索池，性能仍然很好</p><p><img src="https://i.loli.net/2021/03/18/jelLQRdcFwWpaEU.png" alt="image-20210318180918374"></p></li></ul><h3 id="6-3-Ablation-Studies"><a href="#6-3-Ablation-Studies" class="headerlink" title="6.3 Ablation Studies"></a>6.3 Ablation Studies</h3><ul><li><p>观察各个模块的作用</p><p>(1) 【R-CNN only】不使用 image encoder, 直接使用 faster rcnn 提取的特征</p><p>(2)【 “+Image Encoder”】</p><p>(3)【+PT】 MLM+MRM+CMR 上预训练， 注意本文采用的预训练方案是 VMLM+SMRM+CMR</p><p><img src="https://i.loli.net/2021/03/18/ewAYK8M6idSBvEb.png" alt="image-20210318181810013" style="zoom: 33%;"></p><p><strong style="color:blue;">yaya: 其实，本文提出的预训练任务带来的提升并不明显。</strong></p></li><li><p>观察各个预训练任务的作用</p><p><img src="https://i.loli.net/2021/03/18/OkTcr9IVbxYBPgu.png" alt="image-20210318182135676" style="zoom: 50%;"></p><p>预训练任务对于本文提出的模型是有提升的，但是，提升的显著性似乎没有那么大。</p><p><strong style="color:blue;">yaya: 奇怪，为什么 这个 PT(ALL) 与 上个表Table 4 中的LightingDOT结果 不一致呢都？都是在Flickr30k validation上的结果</strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-任务&quot;&gt;&lt;a href=&quot;#1-任务&quot; class=&quot;headerlink&quot; title=&quot;1. 任务&quot;&gt;&lt;/a&gt;1. 任务&lt;/h2&gt;&lt;p&gt;本文发表在 NAACL 2021，本文要研究的内容是如何提高 &lt;strong&gt;Image-text retrieval 
      
    
    </summary>
    
      <category term="cross-modal" scheme="http://yoursite.com/categories/cross-modal/"/>
    
      <category term="Image-Text Retrieval" scheme="http://yoursite.com/categories/cross-modal/Image-Text-Retrieval/"/>
    
      <category term="real time" scheme="http://yoursite.com/categories/cross-modal/Image-Text-Retrieval/real-time/"/>
    
    
      <category term="cross-modal" scheme="http://yoursite.com/tags/cross-modal/"/>
    
      <category term="Image-Text Retrieval" scheme="http://yoursite.com/tags/Image-Text-Retrieval/"/>
    
      <category term="real time" scheme="http://yoursite.com/tags/real-time/"/>
    
  </entry>
  
  <entry>
    <title>Improving Translation Robustness with Visual Cues and Error Correction</title>
    <link href="http://yoursite.com/2021/03/17/Improving-Translation-Robustness-with-Visual-Cues-and-Error-Correction/"/>
    <id>http://yoursite.com/2021/03/17/Improving-Translation-Robustness-with-Visual-Cues-and-Error-Correction/</id>
    <published>2021-03-17T07:55:13.000Z</published>
    <updated>2021-03-17T08:33:45.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本文研究的任务"><a href="#本文研究的任务" class="headerlink" title="本文研究的任务"></a>本文研究的任务</h2><p>多模态机器翻译任务中对噪声样本的鲁棒性。</p><p>神经机器翻译模型对输入噪声很脆弱。当前的鲁棒性技术大多使模型<strong>适应</strong>现有的嘈杂文本，但是这些模型通常在<strong>遇到看不见的噪声</strong>时会失效，并且在clean  text 上的性能会下降（即相比于那些普通的模型，使用噪声样本来扩充数据的模型，其在clean text 上的性能会下降）。</p><h2 id="本文提出的点"><a href="#本文提出的点" class="headerlink" title="本文提出的点"></a>本文提出的点</h2><p>（1） 模型上：引入了<strong><em>视觉上下文</em></strong>的概念，以提高针对嘈杂文本的翻译鲁棒性。</p><p>（2）多任务：通过<strong>将纠错作为辅助任务</strong>来提出一种新的<strong><em>纠错训练</em>方案</strong>，以进一步提高鲁棒性。</p><p>实验证明，在 English-French and English-German 翻译任务上，（1）对于训练中遇到的噪声以及未遇到的噪声都有很好的鲁棒性。（2）同时保持了在 clean text 上的翻译质量。</p><h3 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h3><ul><li>不是重点来做 MMT model 的，略过</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;本文研究的任务&quot;&gt;&lt;a href=&quot;#本文研究的任务&quot; class=&quot;headerlink&quot; title=&quot;本文研究的任务&quot;&gt;&lt;/a&gt;本文研究的任务&lt;/h2&gt;&lt;p&gt;多模态机器翻译任务中对噪声样本的鲁棒性。&lt;/p&gt;
&lt;p&gt;神经机器翻译模型对输入噪声很脆弱。当前的鲁棒
      
    
    </summary>
    
      <category term="cross-modal" scheme="http://yoursite.com/categories/cross-modal/"/>
    
      <category term="image-guided MT" scheme="http://yoursite.com/categories/cross-modal/image-guided-MT/"/>
    
    
      <category term="cross-modal,image-guided MT" scheme="http://yoursite.com/tags/cross-modal-image-guided-MT/"/>
    
  </entry>
  
  <entry>
    <title>[VisualSparta] Sparse Transformer Fragment-level Matching for Large-scale Text-to-Image Search</title>
    <link href="http://yoursite.com/2021/03/16/VisualSparta-Sparse-Transformer-Fragment-level-Matching-for-Large-scale-Text-to-Image-Search/"/>
    <id>http://yoursite.com/2021/03/16/VisualSparta-Sparse-Transformer-Fragment-level-Matching-for-Large-scale-Text-to-Image-Search/</id>
    <published>2021-03-16T03:38:41.000Z</published>
    <updated>2021-03-20T03:24:21.590Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-任务"><a href="#1-任务" class="headerlink" title="1. 任务"></a>1. 任务</h2><p>本文是做跨模态检索问题。文本到图像的检索是多模态信息检索中的一项基本任务，即在给定文本查询的情况下从大型且未标记的图像数据集中检索相关图像。</p><h2 id="2-存在的问题"><a href="#2-存在的问题" class="headerlink" title="2. 存在的问题"></a>2. 存在的问题</h2><p>图文检索问题上存在两个核心挑战：<strong style="color:red;">准确率以及速度</strong>。</p><h2 id="3-本文提出的点"><a href="#3-本文提出的点" class="headerlink" title="3. 本文提出的点"></a>3. 本文提出的点</h2><p>在本文中，提出了基于transformer 的 VisualSparta 模型，这是一种新颖的文本到图像检索模型，该模型在准确性和效率上都比现有模型显著提高。</p><p>本文提出的模型关注点在于两点：</p><p>（1）准确率，学习query tokens 与 image regions之间的细粒度关系，以丰富跨模态理解。</p><p>（2）有效性，独立的学习query 和 answer（image）的特征表示，从而使得模型可以<strong><strong style="color:red;">离线的</strong>索引所有的candidate images</strong>。整个VisualSparta 模型可以作为一个经典的反向索引（Inverted index）搜索引擎，以实现高效搜索。</p><h2 id="4-本文的贡献"><a href="#4-本文的贡献" class="headerlink" title="4. 本文的贡献"></a>4. 本文的贡献</h2><p>1) 性能优势：提出了一个新的基于片段交互（fragment-level interaction）的图文检索模型，并取得了SOTA的性能；</p><p>2) 速度优势：相比于标准的向量搜索，VisualSparta 有391x 速度提升。且实验证明，由于VisualSparta 可以有效的进行<strong>反向索引</strong> ，因此对于更大的数据集，速度优势会更加的明显，</p><p>3) 第一：VisualSparta 是<strong>第一个</strong>可以在大规模数据集上实现<strong>实时搜索</strong>的，基于transformer的 text-to-image retrieval model，并且实现了显著的性能提升。本文的方法证明了large pretrained model 也可以占用<strong>较少的内存和较少的计算时间</strong>。</p><p>4) 对当前存在的 text-to-image retrieval models 进行了 accuracy-latency comparisons。</p><h2 id="5-Method"><a href="#5-Method" class="headerlink" title="5. Method"></a>5. Method</h2><p>本文提出了 <strong>VisualSparta retriever</strong>, a fragment-level transformer-based model for efficient text-image matching.</p><p><img src="https://i.loli.net/2021/03/16/ZTKckhILpCEBv19.png" alt="image-20210316192344412"></p><h3 id="5-1-Query-representation"><a href="#5-1-Query-representation" class="headerlink" title="5.1 Query representation"></a>5.1 Query representation</h3><p>在检索中，<strong style="color:red;">query 的处理是一个在线操作</strong>。需要很好的考虑query 编码的效率。以前的方法，使用bi-RNN来处理 query sentence，为每个token获得上下文特征表示。</p><p>本文中，不采用序列处理的方式。丢掉query中的顺序信息，仅仅使用预训练的word embedding 来表征每个token。<strong>这种方法可以使得每个token的特征表达损失独立的，与上下文无关的</strong>。同时这种方式对于高效的indexing and inference 是必要的。</p><p>a query is represented as $\hat{w}=\left\{\hat{w}_{1}, \ldots, \hat{w}_{m}\right\}$</p><h3 id="5-2-Visual-Representation"><a href="#5-2-Visual-Representation" class="headerlink" title="5.2 Visual Representation"></a>5.2 Visual Representation</h3><p>相比于 query 需要实时在线处理，answer candidates 可以在 query 到来之前离线编制索引 (indexed offline)。因此，answer candidates 的处理可以更加丰富和复杂。因此，本文 follow OSCAR的工作，对于answer candidates 本文提取其上下文特征。</p><p>具体的看上图.</p><p>$H_{\text {image }} \in \mathbb{R}^{(n+k) \times d_{H}}$ is the final contextualized representation for one answer.</p><h3 id="5-3-Scoring-Function"><a href="#5-3-Scoring-Function" class="headerlink" title="5.3 Scoring Function"></a>5.3 Scoring Function</h3><p>第一个等式：学习 image element 和 每个query token 之间的fragment-level 交互。</p><p>$y_{i} =\max _{j \in[1, n+k]}\left(\hat{w}_{i}^{T} h_{j}\right) $              <strong>（equation 10）</strong></p><p>第二个等式：经过一个 ReLu 和 可训练的bias来得到sparse embedding。</p><p>$ \phi\left(y_{i}\right) =\operatorname{ReLU}\left(y_{i}+b\right) $              <strong>（equation 11）</strong></p><p>第三个等式：对于所有的分数求和，并为了抑制过大的分数，使用log operation</p><p>$ f(q, v) =\sum_{i=0}^{m} \log \left(\phi\left(y_{i}\right)+1\right) $             <strong>（equation 12）</strong></p><h3 id="5-4-Retriever-Training"><a href="#5-4-Retriever-Training" class="headerlink" title="5.4 Retriever Training"></a>5.4 Retriever Training</h3><p>最小化如下目标：</p><p>$J=f\left(q, v^{+}\right)-\log \sum_{k \in K^{-}} e^{\left.f\left(q, v_{k}\right)\right)}$</p><p><strong style="color:blue;"><strong>yaya: 这个损失函数其实与正常的NCE损失不同</strong></strong></p><p>负样本的选择：从相同batch 中的其他image samples作为负样本。</p><p><strong>而且本文发现，相比于一些复杂的负样本选择策略（比如，使用有相近标签的相似图像作为负样本），这种负样本的选择策略是简单有效地，效果相当。</strong></p><p><strong style="color:blue;">yaya: 为什么这种选择策略比复杂的策略是有效的？？是不是在不同的场合，应该使用不同的策略呢？？</strong></p><h3 id="5-5-Efficient-Indexing-and-Inference"><a href="#5-5-Efficient-Indexing-and-Inference" class="headerlink" title="5.5 Efficient Indexing and Inference"></a>5.5 Efficient Indexing and Inference</h3><p><strong style="color:red;">real-time inference</strong></p><p>定义 testing query 为 $q=\left[w_{0}, \ldots w_{m}\right]$</p><p>the <strong>ranking score</strong> between $q$ and an image is （利用5.3 中第二个等式得到的 sparse embedding）:</p><p>​    $\operatorname{CACHE}(w, v)=\log ($ sparse embedding $) \quad w \in W $             <strong>（equation 14）</strong></p><p>​    $f(q, v)=\sum_{i=1}^{m} \operatorname{CACHE}\left(w_{i}, v\right)$             <strong>（equation 15）</strong></p><p>由于query term embedding 不是基于上下文得到。因此，可以预先计算 vocabulary $W$ 中每个<strong>term</strong> $w$  与 每个 image candidates 之间的 ranking feature $\phi(w, v)$，<strong style="color:red;">生成的分数 is cached during indexing</strong>，如等式14 所示。得到了一个一个  <strong style="color:red;">$N_{vocab}*M_{images} $的矩阵</strong></p><p><strong>during inference time，最终的分数可以经过 O(1)的查询和一个简单的求和运算得到，如 公式15所示。</strong></p><p><strong style="color:red;">Inverted Index</strong></p><p>更加重要的是，以上的计算可以经由一个 Inverted Index 来高效的实施。 Inverted Index 是现代搜索引擎的基础数据结构，如图1所示。</p><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95</a></p></blockquote><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><h3 id="Datasets"><a href="#Datasets" class="headerlink" title="Datasets"></a>Datasets</h3><ul><li><p>使用图像描述数据集作为本文text-to-image model 的数据来源。<strong>benchmark: MSCOCO; Flickr 30K</strong></p></li><li><p>for large-scale efficiency experiments: 由于目前不存在大规模的图像描述数据集。</p><p>因此，we <strong>manually design 113K and 1M datasets</strong> for testing the inference speed of different models in the large-scale setting.   对于这两个数据集，我们只关注于speed comparison。在数据上的模型性能忽略不比较。</p><p>The 113K dataset refers to the MSCOCO training set。</p><p>The 1M dataset we design consists of 1 million images randomly sampled from the MSCOCO training set.</p><p>所有的 <strong>efficiency test  experiments</strong> 都是在MSCOCO 1K and 5k test splits 再加上这113k 和 1M 数据上进行的。</p></li></ul><h3 id="Recall-Performance"><a href="#Recall-Performance" class="headerlink" title="Recall Performance"></a>Recall Performance</h3><p><img src="https://i.loli.net/2021/03/17/8dVeNz7bngQEwKl.png" alt="image-20210317120703074" style="zoom:50%;"></p><h3 id="Speed-Performance"><a href="#Speed-Performance" class="headerlink" title="Speed Performance"></a>Speed Performance</h3><p>三个模型使用相同的Faster-rcnn image region features。下表中没有考虑这部分时间。</p><p><img src="https://i.loli.net/2021/03/17/GfApECsXomRWHPq.png" alt="image-20210317120800787" style="zoom:50%;"></p><p>（1）在不同size的数据集下，本文提出的模型的速度远高于另外两个模型（一个使用dual encoding, 另一个使用transformer model）</p><p>（2）Table 2 also reveals that as the number of images increases, <strong>the performance drop is much slower</strong> when comparing VisualSparta with other two methods.</p><h3 id="Speed-Accuracy-Flexibility"><a href="#Speed-Accuracy-Flexibility" class="headerlink" title="Speed-Accuracy Flexibility"></a>Speed-Accuracy Flexibility</h3><p>在 Efficient Indexing and Inference 这一节，得到了一个  <strong style="color:red;">$N_{vocab}*M_{images} $的矩阵</strong>， 对于每个image, 与 N个words 计算出了weights, 可以挑选出 top-K， 这样更新为一个  <strong style="color:red;">$K_{words}*M_{images} $的矩阵</strong>，K 越小，检索效率越高。</p><p><img src="https://i.loli.net/2021/03/17/nkhj8yC6dPxugfw.png" alt="image-20210317132243925" style="zoom: 67%;"></p><p><img src="https://i.loli.net/2021/03/17/FmkRlfDp4WqTzOV.png" alt="image-20210317132318637" style="zoom: 50%;"></p><h3 id="Implementation-details"><a href="#Implementation-details" class="headerlink" title="Implementation details"></a>Implementation details</h3><ul><li>image encoder 的初始权重 从 Oscar-base model （12 layers and 768 hidden dimensions）中获得。</li><li>the query embedding， 使用Oscar-base word embedding的参数作为初始权重</li></ul><h2 id="可以查看的其他文献"><a href="#可以查看的其他文献" class="headerlink" title="可以查看的其他文献"></a>可以查看的其他文献</h2><p>本文受到此篇论文的启发: <strong>Sparta: Efficient open-domain question answering via sparse transformer matching retrieval.</strong></p><h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a><strong>yaya</strong></h2><ul><li><p>对于输入的消融实现，如果不提供 object label ？</p><p><strong>本文没有做这个实验。</strong></p></li><li><p>实验结果与 transformer-based retrieval model 的对比， eg: Oscar, Unicoder-VL 等</p><p><strong>本文没有做对比，只是与不基于pre-trained models 进行了对比。</strong></p><p><strong>但是实际上，本文的实验效果在准确率上，是不如那些基于预训练模型的。</strong></p></li><li><p>使用了 transformer 结构，那么本文的学习率是如何设计的？先warm up吗？？</p><p><strong>本文学习率为 1e-5， bs=20, 没有对学习率的变化进行说明。</strong></p></li><li><p>本文发现，相比于一些复杂的负样本选择策略（比如，使用有相近标签的相似图像作为负样本），这种负样本的选择策略是简单有效地，效果相当。</p><p><strong>对于这部分，论文中并没有相关的解释与实验数据说明</strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-任务&quot;&gt;&lt;a href=&quot;#1-任务&quot; class=&quot;headerlink&quot; title=&quot;1. 任务&quot;&gt;&lt;/a&gt;1. 任务&lt;/h2&gt;&lt;p&gt;本文是做跨模态检索问题。文本到图像的检索是多模态信息检索中的一项基本任务，即在给定文本查询的情况下从大型且未标记的图像数
      
    
    </summary>
    
      <category term="cross-modal" scheme="http://yoursite.com/categories/cross-modal/"/>
    
      <category term="real time" scheme="http://yoursite.com/categories/cross-modal/real-time/"/>
    
    
      <category term="cross-modal" scheme="http://yoursite.com/tags/cross-modal/"/>
    
      <category term="real time" scheme="http://yoursite.com/tags/real-time/"/>
    
  </entry>
  
  <entry>
    <title>Slot Filling</title>
    <link href="http://yoursite.com/2021/03/15/Slot-Filling/"/>
    <id>http://yoursite.com/2021/03/15/Slot-Filling/</id>
    <published>2021-03-15T11:51:07.000Z</published>
    <updated>2021-03-16T03:22:01.122Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Bridging the Gap between Training and Inference for Neural Machine Translation</title>
    <link href="http://yoursite.com/2021/03/15/Bridging-the-Gap-between-Training-and-Inference-for-Neural-Machine-Translation/"/>
    <id>http://yoursite.com/2021/03/15/Bridging-the-Gap-between-Training-and-Inference-for-Neural-Machine-Translation/</id>
    <published>2021-03-15T08:15:51.000Z</published>
    <updated>2021-03-15T09:31:10.180Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>本文是ACL 2019 的 最佳长文奖。</p><p><strong style="color:red;">论文主要解决神经网络在翻译领域，训练和测试时所用的上文信息不同造成的偏差问题。</strong></p><p><strong>论文提出了新的训练方法，而非新的模型。读完之后，发现这种方法适用于许多领域的训练-测试不匹配的问题，如：阅读理解、语言模型。</strong></p><h2 id="2-存在的问题"><a href="#2-存在的问题" class="headerlink" title="2. 存在的问题"></a>2. 存在的问题</h2><p>传统的神经机器翻译有两个问题：</p><ul><li><strong>exposure bias</strong> （训练和测试时所用的上文信息不同的问题）</li><li><strong>overcorrection</strong>（过度矫正）</li></ul><h3 id="2-1-exposure-bias"><a href="#2-1-exposure-bias" class="headerlink" title="2.1 exposure bias"></a>2.1 exposure bias</h3><p>那么，什么叫<code>训练和测试时所用的上文信息不同的问题</code>呢？</p><p>训练时, 无论上一步模型的预测输出是什么，在当前步decoder模型的输入都是ground truth word的，即：模型的输入都是正确的，如：<strong>are</strong> 。</p><p><img src="https://i.loli.net/2021/03/14/tMrJqWR1huDFHQ4.png" alt="image-20210314192737439" style="zoom:33%;"></p><p>在测试时，由于没有正确答案，所以用模型预测的上一个字的结果作为输入，如：is、 you 。</p><p>这就导致了在测试时，<strong>如果在某个地方预测错，那么之后模型的输入都是错误的</strong>，这就造成了错误会一直累积；或许模型在某个地方所预测的是另一种翻译的词，但是在训练时没有碰到过这种情况，所以模型无法进行处理。</p><p>这种偏差叫做<code>exposure bias</code>。</p><h3 id="2-2-overcorrection"><a href="#2-2-overcorrection" class="headerlink" title="2.2 overcorrection"></a>2.2 overcorrection</h3><p>训练翻译模型时，还会碰到另一个问题：<strong>overcorrection</strong>（过度矫正）</p><p>什么意思呢？</p><p><img src="https://i.loli.net/2021/03/15/k8USC1drMGB6Jwh.png" alt="img"></p><p>当模型在第三个位置预测出‘abide’时，为了让这句话的loss最小，模型之后会预测 with the rule，但是 abide with the rule 是错误的；正确的应该是 abide by the rule。</p><p>注解: abide 与 by 搭配，而不是与with 搭配。</p><h2 id="3-Method"><a href="#3-Method" class="headerlink" title="3. Method"></a>3. Method</h2><p><img src="https://i.loli.net/2021/03/14/QLSZEk4dqNln6jV.png" alt="image-20210314193828727" style="zoom:50%;"></p><p>为了消除或减轻train阶段和infer阶段的差别, 论文提出从真实的词 $y_{t-1}^{*}$ 和预测的词 $y_{t-1}^{\text {oracle }}$ 中抽样, decoder根据抽样的词来预测下一个词 $y_{t}$ 。使用论文提出的方法, 在时间步 $t$ 预测 $y_{t}$ 分为三步:</p><p>[1] 设真实输出中上一个词为 $y_{j-1}^{*}$ 。从预测的词中选择oracle word $y_{j-1}^{\text {oracle }},$ 论文提出了两种方法来选择oracle word，分别是词级别的方法和句子级别的方法。</p><p>[2] 接着从 $\left\{y_{j-1}^{\text {oracle }}, y_{j-1}^{<em>}\right\}.$ 中抽样一个词，抽中 $y_{j-1}^{</em>}$ 的概率为 $p$, 抽中 $y_{j-1}^{\text {oracle }}$ 的概率为 $1-p_{\circ}$ </p><p>[3] 最后, decoder根据抽样的这个词来预测 $y_{j}$。</p><h3 id="3-1-Oracle-Word-Selection"><a href="#3-1-Oracle-Word-Selection" class="headerlink" title="3.1 Oracle Word Selection"></a>3.1 Oracle Word Selection</h3><p>传统的方法中， decoder会根据上一个时间步真实的 $y_{t-1}^{*}$ 来预测 $y_{t}$ 。</p><p>为了消除train阶段的infer阶段的 差别，可以从预测的词中选择oracle word $y_{t-1}^{\text {oracle }}$ 来代替 $y_{t-1^{\circ}}^{*}$ </p><p>一种方法是每个时间步采用词级别的 greedy search来生成oracle word, 称为word-level oracle(WO)。另一种方法是采用beam-search, 扩大搜索空间, 用句子级的衡量指标(如：BLEU)对beam-search的结果进行排序，称为sentence-level oracle(SO).</p><h4 id="3-1-1-Word-Level-Oracle"><a href="#3-1-1-Word-Level-Oracle" class="headerlink" title="3.1.1 Word Level Oracle"></a>3.1.1 <strong>Word Level Oracle</strong></h4><p><img src="https://i.loli.net/2021/03/14/oJlrVILE6FgkcyM.png" alt="image-20210314200245535" style="zoom: 33%;"></p><p><img src="https://i.loli.net/2021/03/14/wc7Ql4js39KBCXg.png" alt="image-20210314200310765" style="zoom:33%;"></p><p>选择 $y_{t-1}^{\text {oracle }}$ 最简单直观的方法是, 在时间步$t$-1 , 选择公式 $P_{t-1}$ 中概率最高的词作为 $y_{t-1}^{\text {oracle }},$ 如Fig.2所 示。 为了获得更健壮的 $y_{t-1}^{\text {oracle }}$, 更好地选择是使用<a href="https://www.cnblogs.com/initial-h/p/9468974.html" target="_blank" rel="noopener">gumbel max技术</a>来冲离散分布中进行抽样, 如 Fig.3所示。<br>具体地讲, 将gumbel noise <strong style="color:blue;">$\eta$</strong> 作为正则化项加到decoder的预测概率分布上，进而再做softmax操作。</p><p>$\eta=-\log (-\log u)$<br>$\tilde{o}_{j-1}=\left(o_{j-1}+\eta\right) / \tau$<br>$\tilde{P}_{j-1}=\operatorname{softmax}\left(\tilde{o}_{j-1}\right)$</p><p>其中变量 $u \sim U(0,1)$ 服从均匀分布。 $\tau$ 为温度系数, 当 $\tau \rightarrow 0$ 时， 公式(8)的softmax()逐渐相当于<br>$\operatorname{argmax}()$ 函数 $;$ 当 $\tau \rightarrow \infty$ 时, $\operatorname{softmax}()$ 函数逐渐相当于均匀分布。</p><p>则 $y_{t-1}^{\text {oracle }}$ 为：$y_{j-1}^{\text {oracle }}=\operatorname{argmax}\left(\tilde{P}_{j-1}\right)$</p><p>需要注意的是gumbel noise $\eta$ 只用来选择oracle word，而不会影响train阶段的目标函数。</p><h4 id="3-1-2-Sentence-Level-Oracle"><a href="#3-1-2-Sentence-Level-Oracle" class="headerlink" title="3.1.2 Sentence Level Oracle"></a>3.1.2 <strong>Sentence Level Oracle</strong></h4><p>在每一次训练前，模型先用 beam search找到最好的 k 个候选翻译，然后将这 k 句话与正确答案计算 BLEU得分，取得分最高的当作备选句子。</p><p>有了备选句子后怎么办？比如，模型现在要预测第四个词，那么模型的输入是第三个词，这第三个词可以是正确译文的第三个词（传统做法）、可以是模型所预测的第三个词（Word Level）、也可以是这句备选句子的第三个词（Sentence-Level）。</p><p>现在有一个问题： 如果备选句子的长度与答案的长度不一样怎么办，这样备选句子与ground truth不是一一对应的了，那么这样的替换就没有意义了，因为我们希望这个词和对应答案的词是意思相近的或者是近义词。</p><p>作者给出了办法：</p><p>beam search在生成句子时，直到模型预测出结尾符<eos>才结束。</eos></p><p>假设ground truth的长度是 n ：</p><p>1、若模型在 n 之前就预测出<eos>结尾符，那么，我们选择概率第二的作为预测词。</eos></p><p>2、若模型在 n 时没有预测出<eos>结尾符，那么，我们选择<eos>结尾符，并使用它的概率。</eos></eos></p><p>作者的思路就是这样，然后就是最小化每一个字与<strong>ground truth</strong>对应字的负似然对数。</p><p>是与<strong>原始的ground truth</strong>的词计算loss！！！ 而不是与替换了的词，这个替换只发生在模型的输入。</p><h3 id="3-2-Sampling-with-Decay"><a href="#3-2-Sampling-with-Decay" class="headerlink" title="3.2 Sampling with Decay"></a>3.2 Sampling with Decay</h3><p>在train阶段刚开始时，抽中真实的词 $y_{j-1}^{*}$ 的概率比较大，随着模型逐渐收敛，抽中预测的词 $y_{j-1}^{\text {oracle }}$ 的概率变大，让模型有能力处理”过度纠正的问题”。</p><p>在训练的初始阶段, 如果过多地选择 $y_{t-1}^{\text {oracle }},$ 会导致模型收敘速度慢; 在训练的后期阶段，如果过多地选择 $y_{t-1}^{*},$ 会导致模型在train阶段没有学习到如何处理infer阶段的差别。 </p><p>因此，好的选择是：在训练的初始阶段， 更大概率地选择 $y_{t-1}^{*}$ 来加快模型收敛，当模型逐渐收敛后, 以更大概率选择 $y_{t-1}^{\text {oracle }},$ 来让模型学习到如何处理infer阶段的差别以及让模型有能力处理”过度纠正的问题”。从数学表示上，概率 $p$ 先大后逐渐衰减，$p$ 随着训练轮数 $e$ 的增大而逐渐变小。</p><p>$p=\frac{\mu}{\mu+\exp \left(\frac{e}{\mu}\right)}$</p><p><img src="https://i.loli.net/2021/03/15/H6U7Dc5wP8KAsNG.png" alt="image-20210315173055286" style="zoom: 67%;"></p><h3 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h3><p>本文主要的两点贡献：</p><p>(1) word level oracle selection</p><p>(2) sampling with decay</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://zhuanlan.zhihu.com/p/76227765" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/76227765</a></p><p><a href="https://spring-quan.github.io/2019/08/02/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E3%80%8ABridging-the-Gap-between-Training-and-Inference-for-Neural-Machine-Translation%E3%80%8B/" target="_blank" rel="noopener">https://spring-quan.github.io/2019/08/02/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E3%80%8ABridging-the-Gap-between-Training-and-Inference-for-Neural-Machine-Translation%E3%80%8B/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h2&gt;&lt;p&gt;本文是ACL 2019 的 最佳长文奖。&lt;/p&gt;
&lt;p&gt;&lt;strong style=&quot;color:red;&quot;&gt;论文主要解
      
    
    </summary>
    
      <category term="NLP" scheme="http://yoursite.com/categories/NLP/"/>
    
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>Beam Search</title>
    <link href="http://yoursite.com/2021/03/15/Beam-Search/"/>
    <id>http://yoursite.com/2021/03/15/Beam-Search/</id>
    <published>2021-03-15T07:44:10.000Z</published>
    <updated>2021-03-15T08:24:12.121Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. <strong>前言</strong></h2><p>自然语言处理任务中，如机器翻译、对话、文本摘要等，都涉及到序列生成。文本序列生成解码过程中有用到 greedy search、维特比算法、beam search等。</p><h2 id="2-Beam-Search-介绍"><a href="#2-Beam-Search-介绍" class="headerlink" title="2. Beam Search 介绍"></a>2. Beam Search 介绍</h2><p>beam search尝试在广度优先基础上进行进行搜索空间的优化（类似于剪枝）达到减少内存消耗的目的。</p><ul><li><strong>算法过程</strong></li></ul><p>定义词表大小是V，beam size是 B，序列长度是L。</p><p>假设V=100，B=3：</p><ol><li><p>生成第1个词时，选择概率最大的3个词（假设是a，b，c），即从100个中选了前3个；</p></li><li><p>生成第2个词时，将当前序列a/b/c分别与词表中的 100个词组合，得到 3*100个序列，从中选 3个概率最大的，作为当前序列（假设现在是am，bq，as）；</p></li><li><p>持续上述过程，直到结束。最终输出3个得分最高的。</p></li></ol><ul><li><strong>算法复杂度</strong> $O(B<em>V</em>L)$</li></ul><p>在第2步，要计算 $B<em>V$ 次。序列长度是L，生成长度为L的序列，计算  $B</em>V*L$ 次。</p><h2 id="3-算法评价"><a href="#3-算法评价" class="headerlink" title="3. 算法评价"></a>3. 算法评价</h2><ul><li><strong>优点</strong></li></ul><p>(1) 减少计算开销。相对于广度优先搜索，广搜每次都要保留所有可能的结果，复杂度是  $O(V^L)$指数级。</p><ul><li><strong>缺点（第3部分详细讲）</strong></li></ul><p>(1) 数据下溢</p><p>(2) 倾向于生成短的序列</p><p>(3) 单一性问题</p><ul><li><strong>Beam size 设置</strong></li></ul><p>(1) B越大</p><p>优点：可考虑的选择越多，能找到的句子越好</p><p>缺点：计算代价更大，速度越慢，内存消耗越大</p><p>(2) B越小</p><p>优点：计算代价小，速度快，内存占用越小</p><p>缺点：可考虑的选择变少，结果没那么好</p><h2 id="4-问题解决"><a href="#4-问题解决" class="headerlink" title="4. 问题解决"></a>4. 问题解决</h2><h3 id="4-1-数据下溢"><a href="#4-1-数据下溢" class="headerlink" title="4.1 数据下溢"></a>4.1 数据下溢</h3><p>求序列概率的时候，序列概率是多个条件概率的乘积$P\left(y^{<1>} y^{<2>} \ldots y^{T_{y}}\right)=P\left(y^{<1>} \mid x\right) P\left(y^{<2>} \mid x, y^{<1>}\right) \ldots P\left(y^{T_{y}} \mid x, y^{<1>} \ldots, y^{T_{y}-1}\right)$.</1></1></2></1></2></1></p><p>每个概率都小于1甚至远远小于1，很多概率相乘起来，会得到很小很小的数字，会造成数据下溢，即数值太小，计算机的浮点表示不能精确储存。</p><p><strong>解决</strong>：<strong>将最大化的乘积式取对数</strong>，由 $\log M^{*} N=\log M+\log N$ 公式可得，上述需要最大化的王积式可以转化为: $\arg \max _{y} \sum_{y=1}^{T_{y}} \log P\left(y^{<t>} \mid x, y^{<1>}, \ldots, y^{<t-1>}\right)$</t-1></1></t></p><p>即乘积的log变成了log的求和，最大化这个log的求和值能够得到同样的结果，并且不会出现 数值下溢和四舍五入。</p><h3 id="4-2-倾向于生成短的序列"><a href="#4-2-倾向于生成短的序列" class="headerlink" title="4.2 倾向于生成短的序列"></a>4.2 倾向于生成短的序列</h3><p>生成的句子序列越长，对数概率相加的结果就越小（越为负值）, 所以倾向于生成短序列。 对序列长度进行惩罚，降低生成短序列的倾向。</p><p><strong>解决方法：</strong> 对数概率相加的结果, 除以序列长度 $L$ 。<br>实践中，通常采用更柔和的方法, 在 $L$ 上加上指数 $a \in(0,1),$ 即 $L^{a},$ 例如 $a=0.7$ 。如果 $a=1, \quad L^{a}=L$ 就相当于完全用长度来归一化; 如果 $a=0, \quad L^{a}=1$ 就相当于完全没有 归一化, $a \in(0,1)$ 就是在完全归一化和没有归一化之间。</p><p>或者更加复杂一点：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">norm</span> = self.opt.beam_search_norm</span><br><span class="line"><span class="attr">candidate_logprob</span> = (beam_logprobs_sum[q] * t ** norm + local_logprob) / ((t+<span class="number">1</span>) ** norm)</span><br></pre></td></tr></table></figure><h3 id="4-3-单一性问题"><a href="#4-3-单一性问题" class="headerlink" title="4.3 单一性问题"></a><strong>4.3 单一性问题</strong></h3><p>beam search 有一个大问题是输出的 $B$ 个句子的差异性很小，无法体现语言的多样性（比如文本摘要、机器翻译的生成文本，往往有不止一种表述方式）。</p><p><strong>解决方法：</strong> 分组 加入相似性惩罚。diverse beam search 来自<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1610.02424.pdf" target="_blank" rel="noopener">论文</a></p><p>具体如下：选择 Beam size 为 $B$，然后将其分为 $G$组，每一组就有 $B/G$个beam。每个单独的组内跟 beam search很像，不断延展序列。同时通过引入一个dissimilarity 项来保证组与组之间有差异。</p><p><img src="https://i.loli.net/2021/03/15/VQDxijZcGtzlEph.png" alt="image-20210315161115581" style="zoom: 50%;"></p><p>如上图所示，B = 6, G=3，每一组的beam width为2。</p><p>组内与 beam search 很像：从t-1到 t 时刻，不断的减少搜索空间（如同beam search一样）。</p><p>组间差异：对于t=4时刻，我们先对第一组输出y（t=4），然后我们开始对第二组输出y（t=4），但是第二组y（t=4）的score不仅取决于第二组之前的y（t=3），也取决于其与第一组的相似程度。以此类推，在t=4时刻对于第三组的输出，我们从上图可以看到其score的打分标准。这儿对于其 dissimilarity 项的计算采用的办法是 hamming diversity，这个理解起来很简单，比如这个时刻可能输出的词在上面的组出现过，我们就对这个词的分数-1，如果这个时刻可能输出的词在上面组没有出现过，我们就对这个词的分数不惩罚。</p><ul><li><strong>DBS算法：</strong></li></ul><p><img src="https://i.loli.net/2021/03/15/DdS1XPZvoEptVgw.png" alt="image-20210315161139107" style="zoom: 50%;"></p><p>DBS算法</p><ul><li><strong>附：</strong>很多论文里有对 beam search的改进，主要是针对生成序列的<strong>多样性</strong>的。多样性问题，在对话里很常见。</li></ul><h2 id="5-其他相关问题："><a href="#5-其他相关问题：" class="headerlink" title="5. 其他相关问题："></a><strong>5. 其他相关问题</strong>：</h2><h3 id="5-1-训练的时候需要-Beam-Search-吗？"><a href="#5-1-训练的时候需要-Beam-Search-吗？" class="headerlink" title="5.1 训练的时候需要 Beam Search 吗？"></a><strong>5.1 训练的时候需要 Beam Search 吗？</strong></h3><p>不需要。因为训练的时候知道每一步的正确答案，没必要进行这样的搜索。</p><p>5.2 为什么不用贪心搜索？**</p><p>贪心搜索相当于 Beam Search 中 B=1的情况，每次只选择概率最大的词，容易陷入局部最优，但我们真正需要的是一个序列，我们希望整个序列的概率最大。</p><h3 id="5-3-维特比算法"><a href="#5-3-维特比算法" class="headerlink" title="5.3 维特比算法"></a>5.3 维特比算法</h3><p>维特比算法是用动态规划的思想。简单来说就是：从开始状态之后每走一步，就记录下<strong>到达该状态的所有路径的概率最大值</strong>，然后以此最大值为基准继续向后推进。显然，如果这个最大值都不能使该状态成为最大似然状态路径上的结点的话，那些小于它的概率值（以及对应的路径）就更没有可能了。</p><p>Beam Search与Viterbi算法虽然都是解空间的剪枝算法，但它们的思路是不同的。Beam Search是对状态迁移的路径进行剪枝，而 Viterbi 算法是合并不同路径到达同一状态的概率值，用最大值作为对该状态的充分估计值，从而在后续计算中，忽略历史信息（这种以偏概全也就是所谓的Markov性），以达到剪枝的目的。<br>从状态转移图的角度来说，Beam Search是空间剪枝，而Viterbi算法是时间剪枝。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. &lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;自然语言处理任务中，如机器翻译、对话、文本摘要等，都涉及到序列生成。文本序列生成解码过
      
    
    </summary>
    
      <category term="NLP" scheme="http://yoursite.com/categories/NLP/"/>
    
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>Bottom-Up and Top-Down Attention for Image Captioning and Visual Question Answering</title>
    <link href="http://yoursite.com/2021/03/15/Bottom-Up-and-Top-Down-Attention-for-Image-Captioning-and-Visual-Question-Answering/"/>
    <id>http://yoursite.com/2021/03/15/Bottom-Up-and-Top-Down-Attention-for-Image-Captioning-and-Visual-Question-Answering/</id>
    <published>2021-03-15T07:06:11.000Z</published>
    <updated>2021-03-15T08:24:37.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>人类视觉系统存在两种attention机制。Top-down attention由当前任务所决定，我们会根据当前任务（即VQA中的问题），聚焦于与任务紧密相关的部分。Bottom-up attention指的是我们会被显著的、突出的、新奇的事物给吸引。</p><p>以前的方法用到的visual attention mechanisms大都属于top-down类型，即取问题作为输入，建模attention分布，然后作用于CNN提取的图像特征（image features）。然而，这种方法的attention作用的图像对应于下图的左图，没有考虑图片的内容。对于人类来说，注意力会更加集中于图片的目标或其他显著区域，所以作者引进Bottom-up attention机制，如下图的右图所示，attention作用于object proposal。</p><p><img src="https://i.loli.net/2021/03/15/p8WFURqkGw6iIfC.png" alt="image-20210315150105258" style="zoom:50%;"></p><h2 id="Basic-idea"><a href="#Basic-idea" class="headerlink" title="Basic idea"></a>Basic idea</h2><p>Bottom-Up注意力机制: 即基于目标（objects）或显著区域（salient image regions）来计算attention。具体来说，bottom-up机制基于Faster R-CNN，得到图片中每个目标或显著区域的特征向量（feature vector）表示。</p><p>Top-Down机制: 取question作为输入，建模特征权重（feature weightings）或者说attention分布。</p><h2 id="概括："><a href="#概括：" class="headerlink" title="概括："></a>概括：</h2><p><strong>（1）Bottom-Up</strong><br>使用Faster R-CNN 中的R-CNN来得到object feature。<br><strong>（2）Top-Down Attention</strong><br>得到了该层的隐层状态，并与object features  中的每一个<strong>v<sub>i</sub></strong>来计算一个attention 系数。<br><strong>（3）对object features 进行attention 权重求和</strong><br>得到image feature<br><strong>（4）Decoder：language LSTM</strong><br>输出预测单词</p><p><img src="https://i.loli.net/2021/03/15/IcK4HYAsGwjzPqv.jpg" alt="img" style="zoom: 67%;"><br><img src="https://i.loli.net/2021/03/15/lqZx5tngfd9r2Gs.jpg" alt="img" style="zoom:50%;"></p><h2 id="Bottom-Up"><a href="#Bottom-Up" class="headerlink" title="Bottom-Up"></a>Bottom-Up</h2><ul><li><strong>主要介绍一下Faster R-CNN 的训练过程</strong><br>（1）首先Resnet-101 是在ImageNet上预训练的<br>（2）Faster R-CNN在MS COCO上进行预训练<br>rpn 的score classification loss，bbox regression loss<br>r-cnn 的score classification loss，bbox regression loss<br>（3）Faster R-CNN在Visual Genome上再进行预训练<br>为了得到更好的特征表达，增加一个预测属性的输出： </li><li><strong>具体的网络：</strong><br>To predict attributes for region i, we concatenate the mean  pooled convolutional feature vi with a learned embedding  of the ground-truth object class, and feed this into an additional output layer defining a softmax distribution over each  attribute class plus a ‘no attributes’ class.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Motivation&quot;&gt;&lt;a href=&quot;#Motivation&quot; class=&quot;headerlink&quot; title=&quot;Motivation&quot;&gt;&lt;/a&gt;Motivation&lt;/h2&gt;&lt;p&gt;人类视觉系统存在两种attention机制。Top-down attenti
      
    
    </summary>
    
      <category term="图像描述" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E6%8F%8F%E8%BF%B0/"/>
    
    
      <category term="图像描述" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E6%8F%8F%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>Gumbel-Softmax Trick和Gumbel分布</title>
    <link href="http://yoursite.com/2021/03/15/Gumbel-Softmax-Trick%E5%92%8CGumbel%E5%88%86%E5%B8%83/"/>
    <id>http://yoursite.com/2021/03/15/Gumbel-Softmax-Trick和Gumbel分布/</id>
    <published>2021-03-15T02:02:30.000Z</published>
    <updated>2021-03-18T12:04:15.131Z</updated>
    
    <content type="html"><![CDATA[<h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><ul><li><p>由于最近看到的几篇论文中都有提及到gumble softmax的操作，因此想要具体了解一下。</p></li><li><p>用到gumbel softmax 的论文包括以下几篇</p><ul><li><p>解决不可微分问题</p><p>【ICCV 2019】Learning to Assemble Neural Module Tree Networks for Visual Grounding</p><p>【arXiv: 2101.12059v1】VX2TEXT: End-to-End Learning of Video-Based Text Generation From Multimodal Inputs</p><p>【arXiv: 2103.08862】Gumbel-Attention for Multi-modal Machine Translation</p><blockquote><p><strong>Categorical reparameterization with gumbel-softmax.</strong>  ICLR 2017</p></blockquote></li><li><p>在概率分布上添加gumble noise，再从新的概率分布上以概率检索样本</p><p> Bridging the Gap between Training and Inference for Neural Machine Translation</p><blockquote><p><strong>A* sampling.</strong> NIPS 2017</p></blockquote></li></ul></li></ul><p>来源:  <a href="https://www.cnblogs.com/initial-h/p/9468974.html" target="_blank" rel="noopener">https://www.cnblogs.com/initial-h/p/9468974.html</a></p><p>之前看MADDPG论文的时候，作者提到在离散的信息交流环境中，使用了Gumbel-Softmax estimator。于是去搜了一下，发现该技巧应用甚广，如深度学习中的各种GAN、强化学习中的A2C和MADDPG算法等等。只要涉及在离散分布上运用重参数技巧时(re-parameterization)，都可以试试Gumbel-Softmax Trick。</p><p>  这篇文章是学习以下链接之后的个人理解，内容也基本出于此，需要深入理解的可以自取。</p><ul><li><a href="http://amid.fish/humble-gumbel" target="_blank" rel="noopener">The Humble Gumbel Distribution</a></li><li><a href="https://hips.seas.harvard.edu/blog/2013/04/06/the-gumbel-max-trick-for-discrete-distributions/" target="_blank" rel="noopener">The Gumbel-Max Trick for Discrete Distributions</a></li><li><a href="https://casmls.github.io/general/2017/02/01/GumbelSoftmax.html" target="_blank" rel="noopener">The Gumbel-Softmax Trick for Inference of Discrete Variables</a></li><li><a href="https://www.zhihu.com/question/62631725/answer/201338234" target="_blank" rel="noopener">如何理解Gumbel-Max trick？</a></li></ul><p>  这篇文章从直观感觉讲起，先讲Gumbel-Softmax Trick用在哪里及如何运用，再编程感受Gumbel分布的效果，最后讨论数学证明。</p><h2 id="一、Gumbel-Softmax-Trick用在哪里"><a href="#一、Gumbel-Softmax-Trick用在哪里" class="headerlink" title="一、Gumbel-Softmax Trick用在哪里"></a>一、Gumbel-Softmax Trick用在哪里</h2><h3 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h3><p>  通常在强化学习中，如果动作空间是离散的，比如上、下、左、右四个动作，通常的做法是网络输出一个四维的one-hot向量(不考虑空动作)，分别代表四个动作。比如 [1,0,0,0] 代表上，[0,1,0,0] 代表下等等。而具体取哪个动作呢，就根据输出的每个维度的大小，选择值最大的作为输出动作, 即argmax(v)。</p><p>  例如网络输出的四维向量为v=[−20,10,9.6,6.2]，第二个维度取到最大值10，那么输出的动作就是[0,1,0,0]，也就是下，这和多类别的分类任务是一个道理。但是这种取法有个问题是不能计算梯度，也就不能更新网络。通常的做法是加softmax函数，把向量归一化，这样既能计算梯度，同时值的大小还能表示概率的含义。softmax函数定义：$\sigma\left(z_{i}\right)=\frac{e^{z_{i}}}{\sum_{j=1}^{K} e^{z_{j}}}$</p><p>  那么将v=[−20,10,9.6,6.2]通过softmax函数后有σ(v)=[0,0.591,0.396,0.013]，这样做不会改变动作或者说类别的选取，同时softmax倾向于让最大值的概率显著大于其他值，比如这里10和9.6经过softmax放缩之后变成了0.591和0.396，6.2对应的概率更是变成了0.013，这有利于把网络训成一个one-hot输出的形式，这种方式在分类问题中是常用方法。</p><p>  但是这么做还有一个问题，这个表示概率的向量σ(v)=[0,0.591,0.396,0.013]并没有真正显示出概率的含义，因为一旦某个值最大，就选择相应的动作或者分类。比如σ(v)=[0,0.591,0.396,0.013]和σ(v)=[0,0.9,0.1,0]在类别选取的结果看来没有任何差别，都是选择第二个类别，但是从概率意义上讲差别是巨大的。所以需要一种方法不仅选出动作，而且遵从概率的含义。</p><p>  很直接的方法是依概率分布采样就完事了，比如直接用<code>np.random.choice</code>函数依照概率生成样本值，这样概率就有意义了。这样做确实可以，但是又有一个问题冒了出来：这种方式怎么计算梯度？不能计算梯度怎么用BP的方式更新网络？</p><p>  这时重参数(re-parameterization)技巧解决了这个问题，<a href="https://casmls.github.io/general/2017/02/01/GumbelSoftmax.html" target="_blank" rel="noopener">这里</a>有详尽的解释，不过比较晦涩。简单来说重参数技巧的一个用处是把采样的步骤移出计算图，这样整个图就可以计算梯度BP更新了。之前我一直在想分类任务直接softmax之后BP更新不就完事了吗，为什么非得采样。后来看了VAE和GAN之后明白，还有很多需要采样训练的任务。这里举简单的VAE(变分自编码器)的例子说明需要采样训练的任务以及重参数技巧，详细内容来自<a href="https://www.bilibili.com/video/av20165127" target="_blank" rel="noopener">视频</a>和<a href="http://kvfrans.com/variational-autoencoders-explained/" target="_blank" rel="noopener">博客</a>。</p><h3 id="Re-parameterization-Trick"><a href="#Re-parameterization-Trick" class="headerlink" title="Re-parameterization Trick"></a>Re-parameterization Trick</h3><p>  最原始的自编码器通常长这样：</p><p><img src="C:\Users\shiyaya\Desktop\1428973-20180813165000500-1207992534.jpg" alt="img" style="zoom: 67%;"></p><p>  左右两边是端到端的出入输出网络，中间的绿色是提取的特征向量，这是一种直接从图片提取特征的方式。<br>  而VAE长这样:</p><p><img src="https://i.loli.net/2021/03/18/yO5L9kCMPhrwJub.png" alt="image-20210318135149420"></p><p>  VAE的想法是不直接用网络去提取特征向量，而是提取这张图像的分布特征，也就把绿色的特征向量替换为分布的参数向量，比如说均值和标准差。然后需要decode图像的时候，就从encode出来的分布中采样得到特征向量样本，用这个样本去重建图像，这时怎么计算梯度的问题就出现了。<br>  重参数技巧可以解决这个问题，它长下面这样:</p><p><img src="https://i.loli.net/2021/03/18/27e1EIhVFfWyJKi.png" alt="img" style="zoom:67%;"></p><p>假设图中的 $x$ 和 $\phi$ 表示VAE中的均值和标准差向量, 它们是确定性的节点。而需要输出的样本 $z$ 是带有随机性的节点， 重参数就是把带有随机性的 $z$ 变成确定性的节点, 同时随机性用另一个输入节点 $\epsilon$ 代替。<br>例如，这里用正态分布采样, 原本从均值为 $x$ 和标准差为 $\phi$ 的正态分布 $N\left(x, \phi^{2}\right)$ 中采样得到 $z_{\circ}$ 现在将其转化成从标准正态分布 $N(0,1)$ 中采样得到 $\epsilon$ , 再计算得到 $z=x+\epsilon \cdot \phi_{\circ}$ 这样一来, 采样的过程移出了计算图, 整张计算图就可以计算梯度进行更新了，而新加的 $\epsilon$ 的输入分支不 做更新，只当成一个没有权重变化的输入。</p><p>到这里，需要采样训练的任务实例以及重参数技巧基本有个概念了。</p><h3 id="Gumbel-Softmax-Trick"><a href="#Gumbel-Softmax-Trick" class="headerlink" title="Gumbel-Softmax Trick"></a>Gumbel-Softmax Trick</h3><p>VAE的例子是一个连续分布(正态分布)的重参数，离散分布的情况也一样，首先需要可以采样，使得离散的概率分布有意义而不是只取概率最大的值，其次需要可以计算梯度。那么怎么做到的，具体操作如下：</p><p>对于n维概率向量$\pi$, 对$\pi$对应的离散随机变量 $x_{\pi}$ 添加Gumbel噪声，再取样$x_{\pi}=\arg \max \left(\log \left(\pi_{i}\right)+G_{i}\right)$<br>其中, $G_{i}$ 是独立同分布的标准Gumbel分布的随机变量，标准Gumbel分布的CDF为$F(x)=e^{-e^{-x}}$</p><p>这就是<strong style="color:red;">Gumbel-Max trick</strong>。可以看到由于这中间有一个argmax操作，这是不可导的。所以用softmax函数代替之，也就是<strong style="color:red;">Gumbel-Softmax Trick</strong>，而$G_{i}$ 可以通过Gumbel分布求逆从均匀分布生成，即 $G_{i}=-\log \left(-\log \left(U_{i}\right)\right), U_{i} \sim U(0,1)$</p><p>算法流程如下：</p><ul><li><p>对于网络输出的一个 $n$ 维向量 $v$ （predict logits）, 生成 $n$ 个服从均匀分布 $U(0,1)$ 的独立样本 $\epsilon_{1}, \ldots, \epsilon_{n}$</p></li><li><p>通过 $G_{i}=-\log \left(-\log \left(\epsilon_{i}\right)\right)$ 计算得到 $G_{i}$</p></li><li><p>对应相加得到新的值向量 $v^{\prime}=\left[v_{1}+G_{1}, v_{2}+G_{2}, \ldots, v_{n}+G_{n}\right]$</p></li><li><p>通过Softmax函数</p></li></ul><script type="math/tex; mode=display">\sigma_{\tau}\left(v_{i}^{\prime}\right)=\frac{e^{v_{i}^{\prime} / \tau}}{\sum_{j=1}^{n} e^{v_{j}^{\prime} / \tau}}</script><p>计算概率大小得到最终的类别。其中 $\tau$ 是温度参数。</p><p>temperature控制着softmax的soft程度，温度越高，生成的分布越平滑（接近这里的均匀分布）；温度越低，生成的分布越接近离散的one-hot分布（argmax）。因此，<strong>训练时可以逐渐降低温度，以逐步逼近真实的离散分布。</strong></p><p><strong>yaya: 其实这里的 gumbel softmax 不是针对网络输出$v$ 进行一个离散采样，而是对 $v$ 添加噪声之后，再取softmax，而后得到新的概率分布，而这个新的概率分布也不是去argmax, 而是对于每个 $v_i$ 重新分配一个概率权重。其优点在于可以调控 temperature， 当温度低时，近似做了argmax 采样</strong></p><p>直观上来说，Gumbel-Softmax就是在原来的输出上加入了一个噪声，对于强化学习来说，在选择动作之前加一个Gumbel扰动，相当于增加了探索度，感觉上是合理的，而同时他又能保证采样是对原分布的逼近。对于深度学习的任务来说，添加随机性去模拟分布的样本生成，也是合情合理的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;yaya&quot;&gt;&lt;a href=&quot;#yaya&quot; class=&quot;headerlink&quot; title=&quot;yaya&quot;&gt;&lt;/a&gt;yaya&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;由于最近看到的几篇论文中都有提及到gumble softmax的操作，因此想要具体了解一下。&lt;/p&gt;
&lt;/
      
    
    </summary>
    
      <category term="杂类" scheme="http://yoursite.com/categories/%E6%9D%82%E7%B1%BB/"/>
    
    
      <category term="杂类" scheme="http://yoursite.com/tags/%E6%9D%82%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Object Relational Graph with Teacher-Recommended Learning for Video Captioning</title>
    <link href="http://yoursite.com/2021/03/13/Object-Relational-Graph-with-Teacher-Recommended-Learning-for-Video-Captioning/"/>
    <id>http://yoursite.com/2021/03/13/Object-Relational-Graph-with-Teacher-Recommended-Learning-for-Video-Captioning/</id>
    <published>2021-03-13T11:13:46.000Z</published>
    <updated>2021-03-15T01:32:56.252Z</updated>
    
    <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />    <label for="pass">Welcome to my blog, enter password to read.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Just can be seen by yaya.
    
    </summary>
    
      <category term="cross-modal" scheme="http://yoursite.com/categories/cross-modal/"/>
    
      <category term="video captioning" scheme="http://yoursite.com/categories/cross-modal/video-captioning/"/>
    
    
      <category term="cross-modal,video captioning" scheme="http://yoursite.com/tags/cross-modal-video-captioning/"/>
    
  </entry>
  
  <entry>
    <title>[VATEX Captioning Challenge 2019] Multi-modal Information Fusion and Multi-stage Training Strategy for Video Captioning</title>
    <link href="http://yoursite.com/2021/03/13/VATEX-Captioning-Challenge-2019-Multi-modal-Information-Fusion-and-Multi-stage-Training-Strategy-for-Video-Captioning/"/>
    <id>http://yoursite.com/2021/03/13/VATEX-Captioning-Challenge-2019-Multi-modal-Information-Fusion-and-Multi-stage-Training-Strategy-for-Video-Captioning/</id>
    <published>2021-03-13T07:39:13.000Z</published>
    <updated>2021-03-15T08:22:45.689Z</updated>
    
    <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />    <label for="pass">Welcome to my blog, enter password to read.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Just can be seen by yaya.
    
    </summary>
    
      <category term="cross-modal" scheme="http://yoursite.com/categories/cross-modal/"/>
    
      <category term="video captioning" scheme="http://yoursite.com/categories/cross-modal/video-captioning/"/>
    
    
      <category term="cross-modal,video captioning" scheme="http://yoursite.com/tags/cross-modal-video-captioning/"/>
    
  </entry>
  
  <entry>
    <title>多模态人工智能</title>
    <link href="http://yoursite.com/2021/03/12/%E5%A4%9A%E6%A8%A1%E6%80%81%E4%BA%A4%E4%BA%92%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    <id>http://yoursite.com/2021/03/12/多模态交互人工智能/</id>
    <published>2021-03-12T10:11:52.000Z</published>
    <updated>2021-03-12T12:22:43.491Z</updated>
    
    <content type="html"><![CDATA[<p>多模态：视觉，语音，自然语言</p><p><img src="https://i.loli.net/2021/03/12/8ObjKzRVd4UXgS3.png" alt="image-20210312202150477"></p><p><img src="https://i.loli.net/2021/03/12/IqFHGuL6ZYOKwXb.png" alt="image-20210312202209438"></p><p><img src="https://i.loli.net/2021/03/12/CsF8TR3m9UlS54N.png" alt="image-20210312202229192"></p><p><img src="https://i.loli.net/2021/03/12/HbPD8yaB3GU7IAk.png" alt="image-20210312202108780"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;多模态：视觉，语音，自然语言&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/12/8ObjKzRVd4UXgS3.png&quot; alt=&quot;image-20210312202150477&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https:
      
    
    </summary>
    
      <category term="cross-modal" scheme="http://yoursite.com/categories/cross-modal/"/>
    
    
      <category term="cross-modal" scheme="http://yoursite.com/tags/cross-modal/"/>
    
  </entry>
  
  <entry>
    <title>Learning to Contrast the Counterfactual Samples for Robust Visual Question Answering</title>
    <link href="http://yoursite.com/2021/03/12/Learning-to-Contrast-the-Counterfactual-Samples-for-Robust-Visual-Question-Answering/"/>
    <id>http://yoursite.com/2021/03/12/Learning-to-Contrast-the-Counterfactual-Samples-for-Robust-Visual-Question-Answering/</id>
    <published>2021-03-12T09:43:10.000Z</published>
    <updated>2021-03-12T10:05:32.371Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://blog.csdn.net/weixin_45347379/article/details/112182143" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45347379/article/details/112182143</a></p><p>学习对比反事实样本，以实现稳健的视觉问答<br>Learning to Contrast the Counterfactual Samples for Robust Visual Question Answering<br>在阅读本文之前，一定要阅读论文：Counterfactual Samples Synthesizing for Robust Visual Question Answering（简称CSS）</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><img src="https://i.loli.net/2021/03/12/gODk8QFCNWaUsVP.png" alt="image-20210312175656070"></p><p>文章的方法主要包括三个部分：（1）一个基本的VQA模型。（2）一个事实和反事实样本合成（CSS）模块。（3）一个对比学习（CL）目标。</p><h4 id="第一部分和第二部分"><a href="#第一部分和第二部分" class="headerlink" title="第一部分和第二部分"></a><strong>第一部分和第二部分</strong></h4><p>属于CSS已经实现的，主要作用在于：</p><p>（1）并通过多分类的方法预测答案，并产生图中右上方基本VQAloss。</p><p><img src="https://i.loli.net/2021/03/12/z3Q52bActwqMhov.png" alt="在这里插入图片描述"></p><p>（2）得到（I, I+, I-）和（Q, Q+, Q-），</p><p><img src="https://i.loli.net/2021/03/12/din9DctNLV1EORo.png" alt="在这里插入图片描述"></p><h4 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a><strong>第三部分</strong></h4><p>以（I, I+, I-）为例，将（I, I+, I-）和Q喂给VQA模型，分别产生原始样本的嵌入mm（V, Q）作为anchor（a），事实样本的嵌入mm(V+, Q)作为positive（p），反事实样本嵌入mm(V-, Q)作为negati（n）<br>利用余弦相似度作为评分函数，对正样本输出高值，对负样本输出低值，公式如下：</p><p><img src="https://i.loli.net/2021/03/12/XIjKWu7szqi3A4w.png" alt="在这里插入图片描述"></p><p>同样的方法得到anchor和negative之间的评分s(a, n), 这就相当于图中展示的，拉近原始图像与事实区域图像的关系，推远原始图像与反事实区域的距离。<br>对比损失定义为：（这就是图片下方得到的Contrastive loss）</p><p><img src="https://i.loli.net/2021/03/12/CY4OJ7PZmD9Eaud.png" alt="在这里插入图片描述"></p><p>最后，这种对比损失与基础分类损失的加权总和弥补了整体损失：</p><p><img src="https://i.loli.net/2021/03/12/8GL3BxlSEpAg951.png" alt="在这里插入图片描述"></p><p>虽然文章说，<strong style="color:red;">这种方法能够使模型学习他们之间的关系，并从更有因果关系的方面预测正确答案。</strong>但是，个人感觉如果仅仅使以上方法，并不能从理论上提高模型的能力。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><img src="https://i.loli.net/2021/03/12/wAmbOSxRU97dN12.png" alt="在这里插入图片描述"></p><h3 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h3><ul><li>看了本文博客之后，没有看原文，个人任务这种方法有限，</li><li>可能模型的设计上，是有新意的，使用对比学习来增强VQA模型的性能，但是往往自己做的时候会收效甚微</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转自：&lt;a href=&quot;https://blog.csdn.net/weixin_45347379/article/details/112182143&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/weixin_
      
    
    </summary>
    
      <category term="cross-modal" scheme="http://yoursite.com/categories/cross-modal/"/>
    
      <category term="VQA" scheme="http://yoursite.com/categories/cross-modal/VQA/"/>
    
    
      <category term="cross-modal,VQA" scheme="http://yoursite.com/tags/cross-modal-VQA/"/>
    
  </entry>
  
  <entry>
    <title>Semantic Equivalent Adversarial Data Augmentation for Visual Question Answering</title>
    <link href="http://yoursite.com/2021/03/12/Semantic-Equivalent-Adversarial-Data-Augmentation-for-Visual-Question-Answering/"/>
    <id>http://yoursite.com/2021/03/12/Semantic-Equivalent-Adversarial-Data-Augmentation-for-Visual-Question-Answering/</id>
    <published>2021-03-12T03:27:29.000Z</published>
    <updated>2021-03-12T09:31:48.943Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p>受到深度学习的快速发展，VQA 近年来取得了非常成功的进展。数据增强是深度学习中的一个有用的技巧，但是，目前很少有工作关注于VQA任务的数据增强。</p><p>对于image side: 一些简单的数据增强操作不能直接应用到VQA这一场景下，比如，rotation and flipping 等操作，都可能导致<image, question, answer> 这一结构的正确性遭到破坏。</image,></p><p>对于text side (eg: questions) , it is challenging to come up with <strong>generalized rules for language transformation.</strong> 另外，有一类任务是Visual Question Generation，根据image和 answer来生成问题，但是生成的问题常常是有语法错误的，而且，他们在同一个目标数据集上进行学习，生成的数据与原始数据的分布是一致的，因此，<strong>若使用这种方案来做数据扩充，难以解决过拟合问题</strong>(通常训练数据和测试数据不是同一个分布)。</p><p>在本文中，不直接对image或者是question进行操作，而是对images 和 questions生成对抗样本作为数据增强。增强的样本不会改变image的原始语义，也不会改变questions中的semantic meaning。对抗性示例是经过<strong>策略</strong>修改的样本，可以成功地欺骗深层模型以做出不正确的预测。这种修改是难以察觉的，<strong>它在使对抗性示例的基础分布远离原始数据的同时保持了数据的语义。</strong>本文是第一个同时对image 和 text进行数据扩充的方法（已有的方法只是单独对一方面进行数据扩充）。</p><p>进而，使用本文方法产生的<strong>数据增强样本</strong>和<strong>对抗训练</strong>来训练经典的VQA model (BUTD) 。</p><p>实验结果证明，不仅可以提高 VQAv2的整体性能，而且相比于baseline还可以有效抵抗对抗攻击。</p><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p><img src="https://i.loli.net/2021/03/12/rmyqUFXQewT2PBK.png" alt="image-20210312165449352" style="zoom:50%;"></p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><h4 id="何时加入对抗样本"><a href="#何时加入对抗样本" class="headerlink" title="何时加入对抗样本"></a>何时加入对抗样本</h4><ul><li><p>本文发现，将干净样本和对抗样本进行混合，然后<strong>从头到尾</strong>的训练，这种方案不会在干净样本上收敛。因此本文只在特定的训练时期对样本进行混合，最后使用干净样本进行微调。</p><p>本文实验中max-epoch=25.</p><p><img src="https://i.loli.net/2021/03/12/YOblV6WT4rtMkSf.png" alt="image-20210312171853940" style="zoom: 50%;"></p><p>本文的解释：与干净样本相比，对抗样本与其有不同的分布。如果把提升模型在VQA任务上的性能作为我们的主要目标，那么模型在干净样本上的拟合能力需要<strong>在结束</strong>的时候to be retrieved。而<strong>在开始</strong>时，模型需要warm up，此时不适合加入对抗样本。因此在中间阶段加入融合对抗样本的训练。</p></li><li><p>实验证明本文提出的方法不仅可以提高在干净样本上的VQA任务的性能，还能提高<strong>在对抗样本上的鲁棒性</strong>。</p></li></ul><h4 id="相比于baseline还可以有效抵抗对抗攻击"><a href="#相比于baseline还可以有效抵抗对抗攻击" class="headerlink" title="相比于baseline还可以有效抵抗对抗攻击"></a>相比于baseline还可以有效抵抗对抗攻击</h4><p><img src="https://i.loli.net/2021/03/12/np4eUgXwkz2rK5M.png" alt="image-20210312172242341" style="zoom:50%;"></p><h3 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h3><ul><li><strong>何时加入对抗样本</strong> 这个实验告诉我们：一般情况，我们提出一种数据增强方案，通常会从头到尾的使用，但是未必是好的。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Motivation&quot;&gt;&lt;a href=&quot;#Motivation&quot; class=&quot;headerlink&quot; title=&quot;Motivation&quot;&gt;&lt;/a&gt;Motivation&lt;/h3&gt;&lt;p&gt;受到深度学习的快速发展，VQA 近年来取得了非常成功的进展。数据增强是深度学
      
    
    </summary>
    
      <category term="cross-modal" scheme="http://yoursite.com/categories/cross-modal/"/>
    
      <category term="VQA" scheme="http://yoursite.com/categories/cross-modal/VQA/"/>
    
    
      <category term="cross-modal,VQA" scheme="http://yoursite.com/tags/cross-modal-VQA/"/>
    
  </entry>
  
</feed>
