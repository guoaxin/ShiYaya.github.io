<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ShiYaya</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-07-08T08:15:13.768Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ShiYaya</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LM-MLC 一种基于完型填空的多标签分类算法</title>
    <link href="http://yoursite.com/2021/07/08/LM-MLC-%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E5%AE%8C%E5%9E%8B%E5%A1%AB%E7%A9%BA%E7%9A%84%E5%A4%9A%E6%A0%87%E7%AD%BE%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2021/07/08/LM-MLC-一种基于完型填空的多标签分类算法/</id>
    <published>2021-07-08T08:07:41.000Z</published>
    <updated>2021-07-08T08:15:13.768Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<a href="https://mp.weixin.qq.com/s/1VnR1zQ4LWnUDl6USdxVhQ#" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/1VnR1zQ4LWnUDl6USdxVhQ#</a></p><p>同样一篇基于 PET， 模板的方式来做NLP任务的论文</p><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a><strong>1 前言</strong></h2><p>本文主要介绍本人在全球人工智能技术创新大赛【赛道一】设计的一种基于完型填空(模板)的多标签分类算法：LM-MLC，该算法拟合能力很强能感知标签关联性，在多个数据集上测试表明该算法与主流算法无显著性差异，在该比赛数据集上的dev效果很好，但是由于比赛期间事情多，没有好好在test集做测试。</p><p>个人认为该算法根正苗红，理论上可以获得更好的效果，因此做个开源，抛砖引玉，希望有人能提出更为有效的改进。本次开源的代码可读性较强，也有较高的扩展性，本人把LM-MLC可做的修改均写成超参形式，方便各位做测试。</p><p>Github：<a href="https://github.com/DunZhang/LM-MLC" target="_blank" rel="noopener">https://github.com/DunZhang/LM-MLC</a></p><h2 id="2-多标签分类任务"><a href="#2-多标签分类任务" class="headerlink" title="2 多标签分类任务"></a><strong>2 多标签分类任务</strong></h2><p>NLP里的多标签分类任务，输入多为一段文本，输出该文本的的标签。比如在新闻类型分类中，一篇新闻可以同时有”军事”、”政治”和”历史”三个标签，再举个例子，疾病分类中，一位患者可以既感冒又咳嗽。</p><p>多标签分类任务依据数据特点又可以划分为多种类型。</p><h3 id="2-1-文本长度"><a href="#2-1-文本长度" class="headerlink" title="2.1 文本长度"></a>2.1 文本长度</h3><p>文本长度会直接影响到算法的选择，长度过长对算法语义理解要求会变高，如果长度超过512个字符，就不好直接使用BERT，需要分段编码或使用其他算法(LSTM、XLNET等)。文本过长也使得训练时间变长，着实影响到了穷逼的炼丹进度。</p><h3 id="2-2-内容是否加密"><a href="#2-2-内容是否加密" class="headerlink" title="2.2 内容是否加密"></a>2.2 内容是否加密</h3><p>大部分数据集是未加密的，直接可以看到原文。少部分数据集做了脱敏处理，原字词会被替换为数字或其他符号。虽说保护了隐私，但是对算法要求变高了，因为无法使用预训练模型，也没有办法做错误分析。为了达到更好的效果，需要对此类数据集继续做预训练，然后基于该预训练模型微调多标签分类任务。上文中我说的比赛就是做了加密处理。</p><h3 id="2-3-标签数量"><a href="#2-3-标签数量" class="headerlink" title="2.3 标签数量"></a>2.3 标签数量</h3><p>多标签分类数据集标签数量有多有少，少则几个多达上千(比如知乎看山杯数据集)，标签数量多少也会影响到算法的选择，标签数量过多时，多标签分类任务也可以考虑转化为搜索任务，此外标签数量过多时，往往会有严重的类不平衡问题，这在设计算法时也是需要考虑的。</p><h3 id="2-4-标签关联性"><a href="#2-4-标签关联性" class="headerlink" title="2.4 标签关联性"></a>2.4 标签关联性</h3><p>有些数据集的标签之间会存在相关性，比如新闻分类中，关于军事的新闻可能也会和政治有关系，疾病分类中，如果得了高血压，就有可能影响到视网膜。所以对于有关联的标签，算法如能考虑到标签的关联性，那么理论上效果是可以提升的，LM-MLC算法里就认真探索了标签关联性。</p><h2 id="3-自然语言处理中的完型填空"><a href="#3-自然语言处理中的完型填空" class="headerlink" title="3 自然语言处理中的完型填空"></a><strong>3 自然语言处理中的完型填空</strong></h2><p>先说一说完型填空，即一段文本，挖掉几个词，让模型去猜挖掉的词是什么，其实这就是遮挡语言模型。我们可以借助完型填空完成一些自然处理任务，关于这块的介绍，苏建林的两篇博客：博客1，博客2介绍的细致、精彩，因此我就不再过多叙述。</p><p>为了便于理解，我举个完型填空做新闻分类的例子，待分类文本是：美国攻打伊拉克，是因为萨达姆偷了布什家的高压锅 ，我们在该段文本后(或前面)加上如下一段话：这是关于[MASK]的新闻，这样完整的进入BERT的输入就是：[CLS]美国攻打伊拉克，是因为萨达姆偷了布什家的高压锅，这是关于[MASK]的新闻[SEP], 我们只要让模型判断掩掉的词是什么即可，如预测词是军事，那么分类结果就是军事，通常情况下候选词是全体标签。</p><p><img src="https://i.loli.net/2021/07/08/Eybwgr72T4D6tQz.png" alt="640" style="zoom:50%;"></p><h2 id="4-LM-MLC-把完型填空用在多标签分类数据集上"><a href="#4-LM-MLC-把完型填空用在多标签分类数据集上" class="headerlink" title="4 LM-MLC:把完型填空用在多标签分类数据集上"></a><strong>4 LM-MLC:把完型填空用在多标签分类数据集上</strong></h2><p>说了那么多背景知识，下面开始正式介绍LM-MLC算法。</p><h3 id="4-1-模板构建"><a href="#4-1-模板构建" class="headerlink" title="4.1 模板构建"></a><strong>4.1 模板构建</strong></h3><p>上文举得例子是关于分类的，那么对于多标签分类任务要如何构建模板呢，很自然的可以加入如下模板：”有标签1：[MASK],有标签2：[MASK],有标签3：[MASK]”, 该[MASK]预测的词就是：YES或NO。一图胜千言，我们假设是在新闻多标签分类任务，共有三个标签分别是”军事”,”政治”和”历史”，假设文本是：美国攻打伊拉克，那么输入就是：</p><p><img src="https://i.loli.net/2021/07/08/BXYNRLdHau9jC7l.png" alt="640" style="zoom:50%;"></p><p>人工构建模板是一个困难的事情，模板选取很关键，模板是很不稳定的，因此本算法使用了P-tuning的做法，把模板变为[unused*]或者自己在bert的vocab中新建一些词汇，总之就是让模型自己去寻找最佳模板，所以上图输入可以进一步修改为如下形式：</p><p><img src="https://i.loli.net/2021/07/08/abroHAk3t7B12sY.png" alt="640"></p><p>至于[MASK]前后放多少未使用字符，模板位置，不同标签是否使用不同[MASK]等就是各种微小改动，具体可以看开源代码，均以超参形式存于代码中，可以一次试个够。</p><h3 id="4-2-模型架构"><a href="#4-2-模型架构" class="headerlink" title="4.2 模型架构"></a><strong>4.2 模型架构</strong></h3><p>本次博客主要还是抛砖引玉，想把方法公开了和各位讨论，本次所用模型都是极为简单的，没有使用任何比赛的trick，主要提供思想。</p><h4 id="4-2-1-Baseline模型架构"><a href="#4-2-1-Baseline模型架构" class="headerlink" title="4.2.1 Baseline模型架构"></a><strong>4.2.1 Baseline模型架构</strong></h4><p>本模型的Baseline模型就是基于BERT的，模型架构极为简单，CLS向量后接全连接层，然后过Sigmoid层作为每个tag的分数。损失函数可以选用最基础的BCELoss。多提一句，也可以当成分类任务做，用交叉熵优化，但其实看公式，其实是差不多的，本人就懒得折腾了。</p><h4 id="4-2-2-LM-MLC模型架构"><a href="#4-2-2-LM-MLC模型架构" class="headerlink" title="4.2.2 LM-MLC模型架构"></a><strong>4.2.2 LM-MLC模型架构</strong></h4><p>模型架构图前面已经有了，再用文字描述下：基础部分还是BERT，获取TokenEmbedding后使用gather方法提取[MASK]的embedding，然后通过Sigmoid获取每个标签的分数，同样使用BCELoss损失函数。</p><h3 id="4-3-如何训练"><a href="#4-3-如何训练" class="headerlink" title="4.3 如何训练"></a><strong>4.3 如何训练</strong></h3><p>最简单的训练方式就是一次掩盖掉所有的标签然后全部预测，此类方法适合标签没有关联性的数据集。如果标签之间存在关联性，肯定要通过一部分标签值来预测余下的标签值，这也是LM-MLC算法的核心，很多方法都是围绕这个点设计的。</p><p>如何判断标签之间有无关联性呢，方法很简单，取训练集的标签值购置01向量，然后计算统计相关系数即可，根据系数值和下表判断相关性：</p><p><img src="https://i.loli.net/2021/07/08/gbGJ4LmNfHtYKch.png" alt="图片"></p><p>在训练过程中，要把一部分[MASK]改为YES或NO，这种方式让模型在对[MASK]标签做预测时不仅能感知到哪些标签值是0哪些标签值是1以及哪些标签是待预测的。在本算法中使用了[MASK]的真实值，相当于teacher-force-learning，同时为了提升模型的鲁棒性，会以1%的概率故意给错标签，实测这个trick还是挺关键的。</p><p>想要完整实现该思想时，要考虑好多细节，本人想了3种实现策略，但是也没找到最优解，我把思路和逻辑一一罗列出来供大家参考讨论。</p><p>思路一，全随机 在训练时随机掩盖一部分标签，让模型进行预测并计算损失损失。</p><p>思路二，固定掩盖顺序 假设有四个标签，掩盖顺序为1-&gt;2-&gt;3-&gt;4，那么可能的掩盖顺序是：1，12，123，1234，这种方法在预测时也要使用相同的方式去预测，掩盖顺序目前没有发现最优解。</p><p>思路三，UniLM 把标签作为生成任务，通过修改AttentionMask的方式来实现，即以UniLM的形式去训练，这个我没有尝试，因为这种方式已经不再是完型填空的范畴了，欢迎大家尝试。</p><p>本人比较推荐思路一，在实验中思路一的效果也是不错的</p><h3 id="4-4-如何预测"><a href="#4-4-如何预测" class="headerlink" title="4.4 如何预测"></a><strong>4.4 如何预测</strong></h3><p>预测时的基本思想是先预测一个标签，然后在该标签预测结果的基础上继续预测其他标签。那么最重要的问题就是如何确定预测顺序，有如下几种预测方法：</p><p>方法1：随机，即随机确定一个顺序，不足在于不同顺序会影响性能上下浮动约2个百分点</p><p>方法2：固定顺序，即按照固定顺序预测，难点在于顺序难以确定 </p><p>方法3：Top-P,每一次选取模型置信度最高的标签作为首先预测的标签，效果尚可 </p><p>方法4：搜索算法，使用遗传算法等搜索算法选取一个在dev上效果最号的预测顺序作为最终顺序，也可以不用搜索算法，直接random几百次找个最好的也行</p><p>方法3效果还行，方法4可提升逼格发论文。</p><h3 id="4-5-如何进一步提升效果"><a href="#4-5-如何进一步提升效果" class="headerlink" title="4.5 如何进一步提升效果"></a><strong>4.5 如何进一步提升效果</strong></h3><p>在当前预训练+微调的框架下，有一个简单有效的方法那就是不要停止预训练，即把预训练模型在微调数据集上继续做预训练，然后再做微调，该方法以获得ACL2020最佳论文荣誉提名，具体参见Don’t Stop Pretraining:Adapt Language Models to Domains and Tasks。</p><p>为什么我说LM-MLC是根正苗红呢，因为完形填空他完美契合mlm预训练任务，都是预测[MASK], 我总结两个使用该思想的方法：</p><p>常规做法：先继续预训练，然后微调</p><p>联合训练：同时做Word Mask(mlm 任务)和Label Mask(完形填空任务)，然后把loss加一起，可以适当提高Label Mask的权重</p><p>本人是使用第二种，因为这两个任务实在是太契合了，通常我是微调25轮，其中前15轮联合训练，后10轮task-specific的训练，不能所有轮数都联合训练，那不然预测和训练的数据又会不一致。</p><h3 id="4-6-小结"><a href="#4-6-小结" class="headerlink" title="4.6 小结"></a><strong>4.6 小结</strong></h3><p>LM-MLC算法最大的缺点是不支持标签数量过多，假设有100个标签，模板长度为2，再加上自身MASK，那么光标签模板就占了300的长度，而BERT的输入长度限制为512，所以数据集标签多了是无法使用该方法的。</p><p>此外，由于时间精力有限，几乎没有找到合适的存在标签关联的数据集，所以对于标签关联性的一些构想还是缺少验证的，这种数据集怕是要手工构建了，绝大多数数据集都是标签无关，因此直接全部掩盖掉，全部预测就行了。</p><h2 id="5-简单实验"><a href="#5-简单实验" class="headerlink" title="5 简单实验"></a><strong>5 简单实验</strong></h2><p><strong>数据集介绍</strong></p><p>全球人工智能技术创新大赛【赛道一】比赛数据集，是关于医疗影像描述文本的，输出为哪些部位有异常，初赛是17分类，复赛在17分类的基础上又多了12标签分类，本人把复赛初赛复赛数据集合并到一起，当成17多标签分类任务来做。数据集不太方便提供下载。</p><p><strong>AAPD数据集</strong>，这是开源的数据集，我分析AAPD数据集并没有较强的标签关联性，搞不懂为啥SGM多标签分类算法要用这个训练集。。。</p><p><strong>Stackoverflow数据集</strong>，Stackoverflow的帖子都是带有tag的，截图如下，但是该数据集不能直接获得，需要去该网站（<a href="https://archive.org/details/stackexchange）下载，可能需要梯子，然后手工清洗后作为训练集，清洗代码可以见我另外一个开源库DomainSpecificThesaurus。或者先用我清洗的10W数据集，下载链接请往后看。" target="_blank" rel="noopener">https://archive.org/details/stackexchange）下载，可能需要梯子，然后手工清洗后作为训练集，清洗代码可以见我另外一个开源库DomainSpecificThesaurus。或者先用我清洗的10W数据集，下载链接请往后看。</a></p><p><strong>RCV1-V2数据集</strong>，也是开源数据集，标签间也没啥关联性，而且看着文本总感觉很奇怪。</p><p>我提供了AAPD数据集、清洗后的Stackoverflow数据集和RCv1-v2数据集，下载地址：</p><p><a href="https://drive.google.com/file/d/1qNOfb4WX7TpTSPuhGIAAvzAbOc1MbHCO/view" target="_blank" rel="noopener">https://drive.google.com/file/d/1qNOfb4WX7TpTSPuhGIAAvzAbOc1MbHCO/view</a></p><p><strong>实验结果</strong></p><p>因为硬件资源有限，本人工作也较忙，没有做太多的实验，这里把有记录的比赛数据集结果和AAPD数据集测试结果贴出来。</p><p>全球人工智能技术创新大赛【赛道一】的测试结果：</p><p><img src="https://i.loli.net/2021/07/08/mqOFiescWHYvM3J.png" alt="图片"></p><p>AAPD数据集的测试结果：</p><p><img src="https://i.loli.net/2021/07/08/DmXbY1r7us8UFoc.png" alt="图片"></p><p>简单解释下四个方法的含义：</p><p>Baseline: BERT+FC, 详情见上文或源码</p><p>Baseline+mlm: 与mlm联合训练，即mlm_loss+bce_loss</p><p>LM-MLC: 基于完形填空的多标签分类算法，就本人所设计算法</p><p>LM-MLC: 与mlm联合预训练，详情见上文或源码</p><p>前前后后做了很多实验，客观来说，实验结果不太符合预期，效果在其他数据集上没有显著性提升，还是挺郁闷的，抛砖引玉，希望读者能提出的改进意见。不过该方法也没有明显差于其他方法，在以后比赛中作为一种融合模型还是可以滴。</p><h2 id="6-代码介绍"><a href="#6-代码介绍" class="headerlink" title="6 代码介绍"></a><strong>6 代码介绍</strong></h2><p>Github开源地址：<a href="https://github.com/DunZhang/LM-MLC代码做了好多修改，力求简洁易用，同时具有较强的可读性和可扩展性，文中提到的好多点都做成了超参形式，欢迎试水" target="_blank" rel="noopener">https://github.com/DunZhang/LM-MLC代码做了好多修改，力求简洁易用，同时具有较强的可读性和可扩展性，文中提到的好多点都做成了超参形式，欢迎试水</a></p><p><img src="https://i.loli.net/2021/07/08/HEIkqPGivCL5r7y.png" alt="图片"></p><p>目录结构及文件名含义如下：</p><p><img src="https://i.loli.net/2021/07/08/UT5K6DJNX12fIeb.png" alt="图片"></p><h2 id="7-TODOList"><a href="#7-TODOList" class="headerlink" title="7 TODOList"></a><strong>7 TODOList</strong></h2><p>数据集，多标签分类数据集实在是太少了，需要多搞点数据集尤其是中文数据集和标签相关的数据集</p><p>UnilM，可以考虑试一试，文本部分全部交互，标签逐个生成</p><p>考虑标签本身的语义信息，比如经济标签，经济二字本身就是有语义信息的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：&lt;a href=&quot;https://mp.weixin.qq.com/s/1VnR1zQ4LWnUDl6USdxVhQ#&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/1VnR1zQ4LWnUDl6
      
    
    </summary>
    
      <category term="NLP" scheme="http://yoursite.com/categories/NLP/"/>
    
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>MDETR - Modulated Detection for End-to-End Multi-Modal Understanding</title>
    <link href="http://yoursite.com/2021/07/07/MDETR-Modulated-Detection-for-End-to-End-Multi-Modal-Understanding/"/>
    <id>http://yoursite.com/2021/07/07/MDETR-Modulated-Detection-for-End-to-End-Multi-Modal-Understanding/</id>
    <published>2021-07-07T08:43:47.000Z</published>
    <updated>2021-07-07T09:06:32.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="研究内容"><a href="#研究内容" class="headerlink" title="研究内容"></a>研究内容</h2><p>将目标检测与下游任务结合起来，端到端的训练</p><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p><code>物体检测</code>构成了大多数最先进的<code>多模式理解系统</code>的一个组成部分，通常作为一个黑箱来检测图像中的<code>固定概念词汇</code>。 这种流行的使用目标检测的方法没有考虑到下游的多模态理解任务，而且往往是性能的瓶颈。</p><p>此外，目标检测模型通常被冻结。这不仅阻碍了模型感知能力的进一步完善，而且还限制了它只能接触到检测到的物体，而不是整个图像。 这种 “流水线 “式的方法限制了与其他作为上下文的模态的共同训练。 在视觉语言设置中，它意味着 resulting system 的词汇限制在检测器的类别和属性上。 因此，这样的系统不能识别可以用自由格式文本表达的新概念组合。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;研究内容&quot;&gt;&lt;a href=&quot;#研究内容&quot; class=&quot;headerlink&quot; title=&quot;研究内容&quot;&gt;&lt;/a&gt;研究内容&lt;/h2&gt;&lt;p&gt;将目标检测与下游任务结合起来，端到端的训练&lt;/p&gt;
&lt;h2 id=&quot;存在的问题&quot;&gt;&lt;a href=&quot;#存在的问题&quot; clas
      
    
    </summary>
    
      <category term="cross-modal" scheme="http://yoursite.com/categories/cross-modal/"/>
    
    
      <category term="cross-modal" scheme="http://yoursite.com/tags/cross-modal/"/>
    
  </entry>
  
  <entry>
    <title>Seq2Seq中Exposure Bias现象的浅析与对策</title>
    <link href="http://yoursite.com/2021/07/05/Seq2Seq%E4%B8%ADExposure-Bias%E7%8E%B0%E8%B1%A1%E7%9A%84%E6%B5%85%E6%9E%90%E4%B8%8E%E5%AF%B9%E7%AD%96/"/>
    <id>http://yoursite.com/2021/07/05/Seq2Seq中Exposure-Bias现象的浅析与对策/</id>
    <published>2021-07-05T03:53:43.000Z</published>
    <updated>2021-07-05T04:25:42.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Seq2Seq中Exposure-Bias现象的浅析与对策"><a href="#Seq2Seq中Exposure-Bias现象的浅析与对策" class="headerlink" title="Seq2Seq中Exposure Bias现象的浅析与对策"></a>Seq2Seq中Exposure Bias现象的浅析与对策</h2><p>前些天笔者写了<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&amp;mid=2247503481&amp;idx=1&amp;sn=f998484d31148762630e2fdc16af01aa&amp;chksm=96ea11f9a19d98ef4a4c29e7fd86c01a278888374bc5a5ae9bd208de41cdfe6e53b67a09e967&amp;token=748748465&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">CRF用过了，不妨再了解下更快的MEMM？</a>，里边提到了 MEMM 的局部归一化和 CRF 的全局归一化的优劣。</p><p>同时，笔者联想到了 Seq2Seq 模型，因为 Seq2Seq 模型的典型训练方案 Teacher Forcing 就是一个局部归一化模型，所以它也存在着局部归一化所带来的毛病——也就是我们经常说的“Exposure Bias”。</p><p>带着这个想法，笔者继续思考了一翻，将最后的思考结果记录在此文。</p><p><img src="https://i.loli.net/2021/07/05/3zdSt9gLwn41GZa.png" alt="image-20210705121610582" style="zoom:50%;"></p><p>▲ 经典的 Seq2Seq 模型图示</p><p>本文算是一篇进阶文章，适合对Seq2Seq模型已经有一定的了解、希望进一步提升模型的理解或表现的读者。关于Seq2Seq的入门文章，可以阅读旧作<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&amp;mid=2247491314&amp;idx=1&amp;sn=3e22d4a6d732b0877fdc567d2bce1076&amp;chksm=96e9c172a19e48646005da05e143751aa9012c141dd1cf9846a2b418cbf854c7d343013105a1&amp;token=748748465&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">玩转Keras之seq2seq自动生成标题</a>和<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&amp;mid=2247499793&amp;idx=1&amp;sn=685c54d27186a89dcf32d91ce0927274&amp;chksm=96ea1f91a19d9687af5dbe751accc9c1ddd7392f6cf4294dc8a024751a64053cbcb8c60ef8f8&amp;token=748748465&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">从语言模型到Seq2Seq：Transformer如戏，全靠Mask。</a></p><p>本文的内容大致为：</p><ol><li>Exposure Bias 的成因分析及例子；</li><li>简单可行的缓解 Exposure Bias 问题的策略。</li></ol><h2 id="1-Softmax"><a href="#1-Softmax" class="headerlink" title="1. Softmax"></a>1. Softmax</h2><p>首先，我们来回顾 Softmax 相关内容。大家都知道，对于向量 $\left(x_{1}, x_{2}, \ldots, x_{n}\right)$, 它的 Softmax 为:<br>$<br>\left(p_{1}, p_{2}, \ldots, p_{n}\right)=\frac{1}{\sum_{i=1}^{n} e^{x_{i}}}\left(e^{x_{1}}, e^{x_{2}}, \ldots, e^{x_{n}}\right)<br>$<br>由于 $e^{t}$ 是关于 $t$ 的严格单调递增函数，所以如果 $x_{k}$ 是 $x_{1}, x_{2}, \ldots, x_{n}$ 中的最大者， 那么 $p_{k}$也是 $p_{1}, p_{2}, \ldots, p_{n}$ 中的最大者。<br>对于分类问题，我们所用的 Ioss 一般是交叉嫡，也就是：<br>$<br>-\log p_{t}=\log \left(\sum_{i=1}^{n} e^{x_{i}}\right)-x_{t}(2)<br>$<br>其中 $t$ 是目标类。如文章 《寻求一个光滑的最大值函数》[1] 所述，上式第一项实际上是$\max \left(x_{1}, x_{2}, \ldots, x_{n}\right)$ 的光滑近似，所以为了形象理解交叉嫡, 我们可以写出:<br>$<br>-\log p_{t} \approx \max \left(x_{1}, x_{2}, \ldots, x_{n}\right)-x_{t}<br>$<br>也就是说，交叉商实际上在缩小目标类得分 $x_{t}$ 与全局最大值的差距，显然这个差距最小只能为 0 ，并且此时目标类得分就是最大值者。所以， Softmax 加交叉嫡的效果就是“希望目标类的得分成为最大值”。</p><h2 id="2-Teacher-Forcing"><a href="#2-Teacher-Forcing" class="headerlink" title="2. Teacher Forcing"></a>2. Teacher Forcing</h2><p>现在，我们来看 Seq2Seq，它通过条件分解来建模联合概率分布：</p><p>$\begin{aligned} p(\boldsymbol{y} \mid \boldsymbol{x}) &amp;=p\left(y_{1}, y_{2}, \ldots, y_{n} \mid \boldsymbol{x}\right) \\ &amp;=p\left(y_{1} \mid \boldsymbol{x}\right) p\left(y_{2} \mid \boldsymbol{x}, y_{1}\right) \ldots p\left(y_{n} \mid \boldsymbol{x}, y_{1}, \ldots, y_{n-1}\right) \end{aligned}$</p><p>每一项自然也就用 Softmax 来建模的，即：</p><p>$p\left(y_{1} \mid \boldsymbol{x}\right)=\frac{e^{f\left(y_{1} ; \boldsymbol{x}\right)}}{\sum_{y_{1}} e^{f\left(y_{1} ; \boldsymbol{x}\right)}}$,<br>$p\left(y_{2} \mid \boldsymbol{x}, y_{1}\right)=\frac{e^{f\left(y_{1}, y_{2} ; \boldsymbol{x}\right)}}{\sum_{y_{2}} e^{f\left(y_{1}, y_{2} ; \boldsymbol{x}\right)}}$,<br>$\ldots$,<br>$p\left(y_{n} \mid \boldsymbol{x}, y_{1}, \ldots, y_{n-1}\right)=\frac{e^{f\left(y_{1}, y_{2}, \ldots, y_{n} ; \boldsymbol{x}\right)}}{\sum_{y_{n}} e^{f\left(y_{1}, y_{2}, \ldots, y_{n} ; \boldsymbol{x}\right)}}$</p><p>乘起来就是：<br>$<br>p(\boldsymbol{y} \mid \boldsymbol{x})=\frac{e^{f\left(y_{1} ; \boldsymbol{x}\right)}}{\left(\sum_{y_{1}} e^{f\left(y_{1} ; \boldsymbol{x}\right)}\right)\left(\sum_{y} e^{f\left(y_{1}, y_{2} ; \boldsymbol{x}\right)}\right) \ldots\left(\sum_{y_{n}} e^{f\left(y_{1}, y_{2}, \ldots, y_{n} ; \boldsymbol{x}\right)}\right)}<br>$<br>而训练目标就是：<br>$-\log p(\boldsymbol{y} \mid \boldsymbol{x})=-\log p\left(y_{1} \mid \boldsymbol{x}\right)-\log p\left(y_{2} \mid \boldsymbol{x}, y_{1}\right)-\cdots-\log p\left(y_{n} \mid \boldsymbol{x}, y_{1}, \ldots, y_{n-1}\right)$这个直接的训练目标就叫做 Teacher Forcing, 因为在算 $-\log p\left(y_{2} \mid \boldsymbol{x}, y_{1}\right)$ 的时候我们要知道真实的 $y_{1}$, 在算 $-\log p\left(y_{3} \mid \boldsymbol{x}, y_{1}, y_{2}\right)$ 我们需要知道真实的 $y_{1}, y_{2}$, 依此类推， 这就好像有一个经验丰富的老师预先给我们铺好了大部分的路，让我们只需要求下一步即可。</p><p>这个直接的训练目标就叫做 Teacher Forcing，因为在算 的时候我们要知道真实的 ，在算 我们需要知道真实的 ，依此类推，这就好像有一个经验丰富的老师预先给我们铺好了大部分的路，让我们只需要求下一步即可。</p><p>这种方法训练起来简单，而且结合 CNN 或 Transformer 那样的模型就可以实现并行的训练，但它可能会带来 Exposure Bias 问题。</p><h2 id="3-Exposure-Bias"><a href="#3-Exposure-Bias" class="headerlink" title="3. Exposure Bias"></a>3. Exposure Bias</h2><p>其实 Teacher Forcing 这个名称本身就意味着它本身会存在 Exposure Bias 问题。回想一下老师教学生解题的过程，一般的步骤为：</p><ul><li>第一步应该怎么思考；</li><li>第一步想出来后，第二步我们有哪些选择；</li><li>确定了第二步后，第三步我们可以怎么做；</li><li>…</li><li>有了这 n-1 步后，最后一步就不难想到了。</li></ul><p>这个过程其实跟 Seq2Seq 的 Teacher Forcing 方案的假设是一样的。有过教学经验的读者就知道，通常来说学生们都能听得频频点头，感觉全都懂了，然后让学生课后自己做题，多数还是一脸懵比。</p><p>为什么会这样呢？其中一个原因就是 Exposure Bias。说白了，问题就在于，老师总是假设学生能想到前面若干步后，然后教学生下一步，但如果前面有一步想错了或者想不出来呢？这时候这个过程就无法进行下去了，也就是没法得到正确答案了，这就是 Exposure Bias 问题。</p><h2 id="4-Beam-Search"><a href="#4-Beam-Search" class="headerlink" title="4. Beam Search"></a>4. Beam Search</h2><p>事实上，我们真正做题的时候并不总是这样子，假如我们卡在某步无法确定时，我们就遍历几种选择，然后继续推下去，看后面的结果反过来辅助我们确定前面无法确定的那步。对应到 Seq2Seq 来说，这其实就相当于基于 Beam Search 的解码过程。</p><p>对于 Beam Search，我们应该能发现，beam size 并不是越大越好，有些情况甚至是 beam size 等于 1 时最好，这看起来有点不合理，因为 beam size 越大，理论上找到的序列就越接近最优序列，所以应该越有可能正确才对。事实上这也算是 Exposure Bias 的现象之一。</p><p>从式（6）我们可以看出，Seq2Seq 对目标序列 的打分函数为：</p><p>$f\left(y_{1} ; \boldsymbol{x}\right)+f\left(y_{1}, y_{2} ; \boldsymbol{x}\right)+\cdots+f\left(y_{1}, y_{2}, \ldots, y_{n} ; \boldsymbol{x}\right)$</p><p>正常来说，我们希望目标序列是所有候选序列之中分数最高的，根据本文开头介绍的 Softmax 方法，我们建立的概率分布应该是：</p><p>$p(\boldsymbol{y} \mid \boldsymbol{x})=\frac{e^{f\left(y_{1} ; \boldsymbol{x}\right)+f\left(y_{1}, y_{2} ; \boldsymbol{x}\right)+\cdots+f\left(y_{1}, y_{2}, \ldots, y_{n} ; \boldsymbol{x}\right)}}{\sum_{y_{1}, y_{2}, \ldots, y_{n}} e^{f\left(y_{1} ; \boldsymbol{x}\right)+f\left(y_{1}, y_{2} ; \boldsymbol{x}\right)+\cdots+f\left(y_{1}, y_{2}, \ldots, y_{n} ; \boldsymbol{x}\right)}}$</p><p>但上式的分母需要遍历所有路径求和，难以实现，而式（6）就作为一种折衷的选择得到了广泛应用。但式（6）跟式（9）并不等价，因此哪怕模型已经成功优化，也可能出现“最优序列并不是目标序列”的现象。</p><h2 id="5-简单例子"><a href="#5-简单例子" class="headerlink" title="5. 简单例子"></a>5. 简单例子</h2><p>我们来举一个简单例子。设序列长度只有 2，候选序列是 $(a, b)$ 和 $(c, d)$, 而目标序列是<br>$(a, b)$, 训练完成后，模型的概率分布情况为：</p><p><img src="https://i.loli.net/2021/07/05/l5dg34prCf8vzbB.png" alt="image-20210705122243485" style="zoom:50%;"></p><p>如果 beam size 为 1, 那么因为 $p(a)&gt;p(c)$, 所以第一步只能输出 $a$, 接着因为$p(b \mid a)&gt;p(d \mid a)$, 所以第二步只能输出 $b$, 成功输出了正确序列 $(a, b)$ 。但如果 beam size 为 2，那么第一步输出 $(a, 0.6),(c, 0.4)$, 而第二步遍历所有组合，我们得到：</p><p><img src="https://i.loli.net/2021/07/05/9SyY3m6nARxGofN.png" alt="image-20210705122317192" style="zoom:50%;"></p><p>所以输出了错误的序列 $(c,d)$。</p><p>那是因为模型没训练好吗？并不是，前面说过 Softmax 加交叉商的目的就是让目标的得分最大，对于第一步我们有 $p(a)&gt;p(c)$, 所以第一步的训练目标已经达到了，而第二步在 $a$ 已经预先知道的前提下我们有 $p(b \mid a)&gt;p(d \mid a)$ ，这说明第二步的训练目标也达到了。</p><p>因此，模型已经算是训练好了，只不过可能因为模型表达能力限制等原因，得分并没有特别高，但“让目标的得分最大”这个目标已经完成了。</p><h2 id="6-思考对策"><a href="#6-思考对策" class="headerlink" title="6. 思考对策"></a>6. 思考对策</h2><p>从上述例子中读者或许可以看出问题所在了：主要是 $p(d \mid c)$ 太高了，而 $p(d \mid c)$ 是没有经过训练的，没有任何显式的机制去抑制 $p(d \mid c)$ 变大，因此就出现了“最优序列并不是目标序列”的现象。</p><p>看到这里，读者可能就能想到一个朴素的对策了：添加额外的优化目标，降低那些Beam Search出来的非目标序列不就行了？</p><p>事实上，这的确是一个有效的解决方法，相关结果发表在 2016 年的论文 <strong><em>Sequence-to-Sequence Learning as Beam-Search Optimization</em></strong> [2]。但这样一来几乎要求每步训练前的每个样本都要进行一次 Beam Search，计算成本太大。</p><p>还有一些更新的结果，比如 ACL 2019 的最佳长论文 <strong><em>Bridging the Gap between Training and Inference for Neural Machine Translation\</em></strong> [3] 就是聚焦于解决 Exposure Bias 问题。此外，通过强化学习直接优化 BLEU 等方法，也能一定程度上缓解 Exposure Bias。</p><p>然而，据笔者所了解，这些致力于解决 Exposure Bias 的方法，大部分都是大刀阔斧地改动了训练过程，甚至会牺牲原来模型的训练并行性（需要递归地采样负样本，如果模型本身是 RNN 那倒无妨，但如果本身是 CNN 或 Transformer，那伤害就很大了），成本的提升幅度比效果的提升幅度大得多。</p><h2 id="7-构建负样本"><a href="#7-构建负样本" class="headerlink" title="7. 构建负样本"></a>7. 构建负样本</h2><p>纵观大部分解决 Exposure Bias 的论文，以及结合我们前面的例子和体会，不难想到，其主要思想就是构造有代表性的负样本，然后在训练过程中降低这些负样本的概率，所以问题就是如何构造“有代表性”的负样本了。</p><p>这里给出笔者构思的一种简单策略，实验证明它能一定程度上缓解 Exposure Bias，提升文本生成的表现，重要的是，这种策略比较简单，基本能做到即插即用，几乎不损失训练性能。</p><p>方法很简单，就是随机替换一下 Decoder 的输入词（Decoder 的输入词有个专门的名字，叫做 oracle words），如下图所示：</p><p><img src="https://i.loli.net/2021/07/05/KblSQv4UzCkoVW5.png" alt="image-20210705121402164" style="zoom:50%;"></p><p>▲ 一种缓解Exposure Bias的简单策略：直接将Decoder的部分输入词随机替换为别的词</p><p>其中紫色的 [R] 代表被随机替换的词。其实不少 Exposure Bias 的论文也是这个思路，只不过随机选词的方案不一样。笔者提出的方案很简单：</p><ol><li><p>50% 的概率不做改变；</p></li><li><p>50% 的概率把输入序列中 30% 的词替换掉，替换对象为原目标序列的任意一个词。</p></li></ol><p>也就是说，随机替换发生概率是 50%&gt;&gt;随机替换的比例是 30%，随机抽取空间就是目标序列的词集。</p><p>这个策略的灵感在于：尽管 Seq2Seq 不一定能完全生成目标序列，但它通常能生成大部分目标序列的词（但顺序可能不对，或者重复出现同一些词），因此这样替换后的输入序列通常可以作为有代表性的负样本。对了，说明一下，50% 和 30% 这两个比例纯粹是拍脑袋的，没仔细调参，因为生成模型调一次实在是太累了。</p><p>效果如何呢？笔者做了两个标题（摘要）生成的实验（就是 CLGE [4] 的前两个），其中 baseline 是 task_seq2seq_autotitle_csl.py [5]，代码开源于：</p><p><a href="https://github.com/bojone/exposure_bias" target="_blank" rel="noopener">https://github.com/bojone/exposure_bias</a></p><p>结果如下表：</p><p><img src="https://i.loli.net/2021/07/05/ae1MA82g9zBV6Lr.png" alt="image-20210705121333189" style="zoom:50%;"></p><p><img src="https://i.loli.net/2021/07/05/WlX9DUvHn1iYA62.png" alt="image-20210705121322078" style="zoom:50%;"></p><p>可以发现，在 CSL 任务中，基于随机替换的策略稳定提升了文本生成的所有指标，而 LCSTS 任务的各个指标则各有优劣，考虑到 LCSTS 本身比较难，各项指标本来就低，所以应该说 CSL 的结果更有说服力一些。</p><p>这表明，笔者提出的上述策略确实是一种值得尝试的方案（注：所有实验都重复了两次然后取平均，所以实验结果应该是比较可靠的了）。</p><h2 id="8-对抗训练"><a href="#8-对抗训练" class="headerlink" title="8. 对抗训练"></a>8. 对抗训练</h2><p>思考到这里，我们不妨再“天马行空”一下：既然解决 Exposure Bias 的思路之一就是要构造有代表性的负样本输入，说白了就是让模型在扰动下依然能预测正确，而前些天我们不是才讨论了一种生成扰动样本的方法吗？</p><p>不错，那就是<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&amp;mid=2247504686&amp;idx=2&amp;sn=087dc7e98ede7960b3baacb20d55ce40&amp;chksm=96ea0caea19d85b8dccc52f07763b82f4aaffda6dd4cbdd784e682f13de6a11c6ced5b8df96f&amp;token=748748465&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">对抗训练</a>。如果直接往 baseline 模型里边加入对抗训练，能不能提升模型的性能呢？简单起见，笔者做了往 baseline 模型里边梯度惩罚（也算是对抗训练的一种）的实验，结果对比如下：</p><p><img src="https://i.loli.net/2021/07/05/ZOhswW8mGaSxIYc.png" alt="image-20210705121226535" style="zoom:50%;"></p><p><img src="https://i.loli.net/2021/07/05/J1pAQX28GScMPIB.png" alt="image-20210705121209230" style="zoom:50%;"></p><p>可以看到，对抗训练（梯度惩罚）进一步提升了 CSL 生成的所有指标，而 LCSTS 上则同样比较“随缘”。因此，对抗训练也可以列入“提升文本生成模型的潜力技巧”名单之中。</p><h2 id="9-本文小结"><a href="#9-本文小结" class="headerlink" title="9. 本文小结"></a>9. 本文小结</h2><p>本文讨论了 Seq2Seq 中的 Exposure Bias 现象，尝试从直观上和理论上分析 Exposure Bias 的原因，并给出了简单可行的缓解 Exposure Bias 问题的对策。</p><p>其中包括笔者构思的一种随机替换策略，以及基于对抗训练的策略，这两种策略的好处是它们几乎是即插即用的，并且实验表明它们能一定程度上提升文本生成的各个指标。</p><p><strong>相关链接</strong></p><p>[1] <a href="https://kexue.fm/archives/3290" target="_blank" rel="noopener">https://kexue.fm/archives/3290</a></p><p>[2] <a href="https://arxiv.org/abs/1606.02960" target="_blank" rel="noopener">https://arxiv.org/abs/1606.02960</a></p><p>[3] <a href="https://arxiv.org/abs/1906.02448" target="_blank" rel="noopener">https://arxiv.org/abs/1906.02448</a></p><p>[4] <a href="https://github.com/CLUEbenchmark/CLGE" target="_blank" rel="noopener">https://github.com/CLUEbenchmark/CLGE</a></p><p>[5] <a href="https://github.com/bojone/bert4keras/blob/master/examples/task_seq2seq_autotitle_csl.py" target="_blank" rel="noopener">https://github.com/bojone/bert4keras/blob/master/examples/task_seq2seq_autotitle_csl.py</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Seq2Seq中Exposure-Bias现象的浅析与对策&quot;&gt;&lt;a href=&quot;#Seq2Seq中Exposure-Bias现象的浅析与对策&quot; class=&quot;headerlink&quot; title=&quot;Seq2Seq中Exposure Bias现象的浅析与对策&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>R-Drop: Regularized Dropout for Neural Networks</title>
    <link href="http://yoursite.com/2021/07/05/R-Drop-Regularized-Dropout-for-Neural-Networks/"/>
    <id>http://yoursite.com/2021/07/05/R-Drop-Regularized-Dropout-for-Neural-Networks/</id>
    <published>2021-07-05T03:14:14.000Z</published>
    <updated>2021-07-07T02:51:35.584Z</updated>
    
    <content type="html"><![CDATA[<p>来源：<a href="https://mp.weixin.qq.com/s/IvhGbFEMotpKJIUPExUklg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/IvhGbFEMotpKJIUPExUklg</a></p><p>关注 NLP 新进展的读者，想必对四月份发布的 SimCSE [1] 印象颇深，它通过简单的“Dropout 两次”来构造正样本进行对比学习，达到了无监督语义相似度任务的全面 SOTA。无独有偶，最近的论文《R-Drop: Regularized Dropout for Neural Networks》提出了 R-Drop，它将“Dropout两次”的思想用到了有监督任务中，每个实验结果几乎都取得了明显的提升。此外，笔者在自己的实验还发现，它在半监督任务上也能有不俗的表现。</p><p>小小的“Dropout两次”，居然跑出了“五项全能”的感觉，不得不令人惊讶。本文来介绍一下 R-Drop，并分享一下笔者对它背后原理的思考。</p><p><img src="https://i.loli.net/2021/07/05/fCjDeTwZyztI3s6.png" alt="image-20210705111612040" style="zoom:50%;"></p><p><strong>论文标题：</strong>R-Drop: Regularized Dropout for Neural Networks</p><p><strong>论文链接：</strong><a href="https://arxiv.org/abs/2106.14448" target="_blank" rel="noopener">https://arxiv.org/abs/2106.14448</a></p><p><strong>代码链接：</strong><a href="https://github.com/dropreg/R-Drop" target="_blank" rel="noopener">https://github.com/dropreg/R-Drop</a></p><h2 id="1-SimCSE"><a href="#1-SimCSE" class="headerlink" title="1. SimCSE"></a>1. SimCSE</h2><p>《中文任务还是 SOTA 吗？我们给 SimCSE 补充了一些实验》[1] 中，我们已经对 SimCSE 进行了介绍。简单来说，SimCSE 是 NLP 的一种对比学习方案，对比学习的标准流程是同一个样本通过不同的数据扩增手段得到的结果视为正样本对，而 batch 内的所有其他样本视为负样本，然后就是通过 loss 来缩小正样本的距离、拉大负样本的距离了。</p><p>所以难度主要集中在数据扩增手段上。对于 NLP 来说，我们很难人工构建保证语义不变的数据扩增，所以 SimCSE 干脆不人工进行数据扩增，而是通过“Dropout 两次”的方式来得到同一个输入的不同特征向量，并将它们视为正样本对。奇怪的是，这个简单的“Dropout 两次”构造正样本，看上去是一种“无可奈何”的妥协选择，但消融实验却发现它几乎优于所有其他数据扩增方法，令人惊讶之余又让人感叹“大道至简”。</p><p><img src="https://i.loli.net/2021/07/05/Z8UKsXLWCAyp3dO.png" alt="image-20210705112154737" style="zoom:50%;"></p><p>在实现上，SimCSE 也相当简单，所谓“Dropout 两次”，只需要将样本重复地输入到模型，然后计算相应的 loss 就行了，如上图所示。由于 Dropout 本身的随机性，每个样本的 Dropout 模式都是不一样的，所以只要单纯地重复样本，就可以实现“Dropout 两次”的效果。</p><h2 id="2-R-Drop"><a href="#2-R-Drop" class="headerlink" title="2. R-Drop"></a>2. R-Drop</h2><p>从结果上来看，SimCSE 就是希望 Dropout对模型结果不会有太大影响，也就是模型输出对 Dropout 是鲁棒的。所以很明显，“Dropout 两次”这种思想是可以推广到一般任务的，这就是 R-Drop（Regularized Dropout）。</p><h3 id="2-1-分类问题"><a href="#2-1-分类问题" class="headerlink" title="2.1 分类问题"></a>2.1 分类问题</h3><p>在笔者看来，R-Drop 跟 SimCSE 是高度相关的，甚至 R-Drop 应该是受到了 SimCSE 启发的，不过 R-Drop 论文并没有引用 SimCSE，所以这就比较迷了。</p><p><img src="https://i.loli.net/2021/07/05/PkRl8QUn2uC1W5j.png" alt="image-20210705112225164" style="zoom: 80%;"></p><p>具体来说，以分类问题为例，训练数据为 ，模型为 ，每个样本的 loss 一般是交叉熵：</p><p>$\mathcal{L}_{i}=-\log P_{\theta}\left(y_{i} \mid x_{i}\right)$</p><p>在“Dropout 两次”的情况下，其实我们可以认为样本已经通过了两个略有不同的模型，我们分别记为 和 。这时候 R-Drop 的 loss 分为两部分，一部分是常规的交叉熵：</p><p>$\mathcal{L}_{i}^{(C E)}=-\log P_{\theta}^{(1)}\left(y_{i} \mid x_{i}\right)-\log P_{\theta}^{(2)}\left(y_{i} \mid x_{i}\right)$</p><p>另一部分则是两个模型之间的对称 KL 散度，它希望不同 Dropout 的模型输出尽可能一致：</p><p>$\mathcal{L}_{i}^{(K L)}=\frac{1}{2}\left[K L\left(P_{\theta}^{(2)}\left(y \mid x_{i}\right) | P_{\theta}^{(1)}\left(y \mid x_{i}\right)\right)+K L\left(P_{\theta}^{(1)}\left(y \mid x_{i}\right) | P_{\theta}^{(2)}\left(y \mid x_{i}\right)\right)\right]$</p><p>最终 loss 就是两个 loss 的加权和：</p><p>$\mathcal{L}_{i}=\mathcal{L}_{i}^{(C E)}+\alpha \mathcal{L}_{i}^{(K L)}$</p><p>也就是说，它在常规交叉熵的基础上，加了一项强化模型鲁棒性正则项。</p><h3 id="2-2-一般形式"><a href="#2-2-一般形式" class="headerlink" title="2.2 一般形式"></a>2.2 一般形式</h3><p>可能有些读者会问非分类问题应该将 KL 项替换为什么，事实上原论文并没有在非分类问题上进行实验，不过这里可以补充一下。我们可以留意到：</p><p>$-\log P_{\theta}\left(y_{i} \mid x_{i}\right)=K L\left(\right.$ one_hot $\left.\left(y_{i}\right) | P_{\theta}\left(y \mid x_{i}\right)\right)$</p><p>所以，上述 只不过是 KL 散度的反复使用，它的一般形式是：</p><p>$\mathcal{L}_{i}=\mathcal{D}\left(y_{i}, f_{\theta}^{(1)}\left(x_{i}\right)\right)+\mathcal{D}\left(y_{i}, f_{\theta}^{(2)}\left(x_{i}\right)\right)+\frac{\alpha}{2}\left[\mathcal{D}\left(f_{\theta}^{(2)}\left(x_{i}\right), f_{\theta}^{(1)}\left(x_{i}\right)\right)+\mathcal{D}\left(f_{\theta}^{(1)}\left(x_{i}\right), f_{\theta}^{(2)}\left(x_{i}\right)\right)\right]$</p><p>因此对于非分类问题，我们将 换成适当的度量（而不是 KL 散度）即可。</p><h2 id="3-实验效果"><a href="#3-实验效果" class="headerlink" title="3. 实验效果"></a>3. 实验效果</h2><p>我们先来看看 R-Drop 的实验结果。</p><p>R-Drop 的主要超参有三个：batch_size, $\alpha$ 和 Dropout 概率。batch_size 一 般取决于我们的算力，对个人来说调整空间不大; 原论文的 $\alpha$ 从 $1 \sim 5$ 都有，笔者自己的实验中，则取了 $\alpha=4$, 也没细调。至于 Dropout的概率，跟笔者在《中文任务还是 SOTA 吗？ 我们给 $\operatorname{SimCSE}$ 补充了一些实验》 [1] 所选的一样，设为 $0.3$ 效果比较好。</p><h3 id="3-1-论文报告"><a href="#3-1-论文报告" class="headerlink" title="3.1 论文报告"></a>3.1 论文报告</h3><p>说实话，原论文所报告的 R-Drop 的效果是相当让人惊艳的，这也是笔者不得不要介绍一波 R-Drop 的主要原因。原论文在 NLU、NLG、CV 的分类等多种任务上都对 R-Drop 做了对比实验，大部分实验效果都称得上“明显提升”。</p><p>官方实现：<a href="https://github.com/dropreg/R-Drop" target="_blank" rel="noopener">https://github.com/dropreg/R-Drop</a></p><p>下面截图一部分实验结果：</p><p><img src="https://i.loli.net/2021/07/05/Ff3U5wNhAv9kEjz.png" alt="image-20210705112718166" style="zoom:50%;"></p><p>▲ R-Drop在机器翻译任务上的效果</p><p><img src="https://i.loli.net/2021/07/05/tVo7znGCKvUDN5m.png" alt="image-20210705112750407" style="zoom: 50%;"></p><p>▲ R-Drop在GLUE任务上的效果</p><p>特别地，在机器翻译任务上，简单的“Transformer + R-Drop”超过了其他更加复杂方法的效果：</p><p><img src="https://i.loli.net/2021/07/05/gm1UzqLS9pB5KIy.png" alt="image-20210705112819739" style="zoom: 50%;"></p><p>▲ 机器翻译任务上不同方法的对比</p><p>论文还包括自动摘要、语言模型、图像分类等实验，以及关于超参数的一些消融实验，大家仔细看原论文就好。总的来说，R-Drop 的这份“成绩单”，确实足以让人为之点赞了。</p><h3 id="3-2-个人尝试"><a href="#3-2-个人尝试" class="headerlink" title="3.2 个人尝试"></a>3.2 个人尝试</h3><p>当然，笔者坚持的观点是“没有在中文测试过的模型是没有灵魂的”，一般情况下笔者都是在中文任务上亲自尝试过之后，才会写作分享。</p><p>个人实现：<a href="https://github.com/bojone/r-drop" target="_blank" rel="noopener">https://github.com/bojone/r-drop</a></p><p>有中文监督任务上，笔者实验了两个文本分类任务（CLUE 榜单的 IFLYTEK 和 TNEWS）。</p><p><img src="https://i.loli.net/2021/07/05/6WdlENPmujJQh8y.png" alt="image-20210705112907796" style="zoom:50%;"></p><p>和一个文本生成任务（CSL 标题生成，参考 <a href="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&amp;mid=2247504805&amp;idx=2&amp;sn=e0e149112e3318bf65d309e32db356b2&amp;chksm=96ea0c25a19d8533ec3d623547b415a58072b353037ac4cd95c68d9dc67f6eb48370684dc6dd&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Seq2Seq 中 Exposure Bias 现象的浅析与对策</a>）：</p><p><img src="https://i.loli.net/2021/07/05/epuUgz8yJSC6jxY.png" alt="image-20210705112924382" style="zoom:50%;"></p><p>可以看到，R-Drop 的结果足以 PK 在<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&amp;mid=2247504686&amp;idx=2&amp;sn=087dc7e98ede7960b3baacb20d55ce40&amp;chksm=96ea0caea19d85b8dccc52f07763b82f4aaffda6dd4cbdd784e682f13de6a11c6ced5b8df96f&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">对抗训练浅谈：意义、方法和思考（附Keras 实现</a>）中介绍的著名正则化手段“对抗训练”和“梯度惩罚”了。</p><h3 id="3-3-实现要点"><a href="#3-3-实现要点" class="headerlink" title="3.3 实现要点"></a>3.3 实现要点</h3><p>相比于对抗学习等复杂正则化方法，R-Drop 的实现难度可谓是相当低了，这里以 bert4keras 为例，简单介绍一下如何将一个普通的训练脚本改为带 Dropout 的模式。</p><p>首先，是数据生成部分，改动如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">data_generator</span><span class="params">(DataGenerator)</span>:</span></span><br><span class="line">    <span class="string">"""数据生成器</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self, random=False)</span>:</span></span><br><span class="line">        batch_token_ids, batch_segment_ids, batch_labels = [], [], []</span><br><span class="line">        <span class="keyword">for</span> is_end, (text, label) <span class="keyword">in</span> self.sample(random):</span><br><span class="line">            token_ids, segment_ids = tokenizer.encode(text, maxlen=maxlen)</span><br><span class="line">            <span class="comment"># batch_token_ids.append(token_ids)</span></span><br><span class="line">            <span class="comment"># batch_segment_ids.append(segment_ids)</span></span><br><span class="line">            <span class="comment"># batch_labels.append([label])</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">                batch_token_ids.append(token_ids)</span><br><span class="line">                batch_segment_ids.append(segment_ids)</span><br><span class="line">                batch_labels.append([label])</span><br><span class="line">            <span class="comment"># if len(batch_token_ids) == self.batch_size or is_end:</span></span><br><span class="line">            <span class="keyword">if</span> len(batch_token_ids) == self.batch_size * <span class="number">2</span> <span class="keyword">or</span> is_end:</span><br><span class="line">                batch_token_ids = sequence_padding(batch_token_ids)</span><br><span class="line">                batch_segment_ids = sequence_padding(batch_segment_ids)</span><br><span class="line">                batch_labels = sequence_padding(batch_labels)</span><br><span class="line">                <span class="keyword">yield</span> [batch_token_ids, batch_segment_ids], batch_labels</span><br><span class="line">                batch_token_ids, batch_segment_ids, batch_labels = [], [], []</span><br></pre></td></tr></table></figure><p>然后，自定义一个新 loss：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.losses <span class="keyword">import</span> kullback_leibler_divergence <span class="keyword">as</span> kld</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">categorical_crossentropy_with_rdrop</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    <span class="string">"""配合上述生成器的R-Drop Loss</span></span><br><span class="line"><span class="string">    其实loss_kl的除以4，是为了在数量上对齐公式描述结果。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    loss_ce = K.categorical_crossentropy(y_true, y_pred)  <span class="comment"># 原来的loss</span></span><br><span class="line">    loss_kl = kld(y_pred[::<span class="number">2</span>], y_pred[<span class="number">1</span>::<span class="number">2</span>]) + kld(y_pred[<span class="number">1</span>::<span class="number">2</span>], y_pred[::<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">return</span> K.mean(loss_ce) + K.mean(loss_kl) / <span class="number">4</span> * alpha</span><br></pre></td></tr></table></figure><p>最后把模型的 Dropout 打开，并用这个 data_generator 和 categorical_crossentropy_with_rdrop 来训练模型就行了。</p><h2 id="4-个人理解"><a href="#4-个人理解" class="headerlink" title="4. 个人理解"></a>4. 个人理解</h2><p>看完了让人赏心悦目的实验结果后，我们来啃一下理论。原论文提供了对 R-Drop 的一个理论分析，大致意思是 R-Drop 会促进参数的同化，从而起到正则化作用。不过个人感觉这个解释并不直观，而且还不够本质。下面笔者试图提供 R-Drop 的另外几个角度的理解。</p><h3 id="4-1-一致性"><a href="#4-1-一致性" class="headerlink" title="4.1 一致性"></a>4.1 一致性</h3><p>R-Dropout 可以看成是 Dropout 的改进，那 Dropout 有什么问题呢? 其实 Dropout 是典型的训练和预测不一致的方法。具体来说， Dropout 在训练阶段往 $\left(\right.$ 某些层的) 输入加上了乘性噪声，使得模型从 $f_{\theta}(x)$ 变成了 $f_{\theta}(x, \varepsilon)$, 其中 $\varepsilon$ 的每个元素有 $\mathrm{p}$的概率为 0 ，剩下 1-p 的概率为 $1 /(1-\mathrm{p})$ ，训练目标就是：</p><p>$\mathbb{E}_{(x, y) \sim \mathcal{D}} \mathbb{E}_{\varepsilon}\left[l\left(y, f_{\theta}(x, \varepsilon)\right)\right]$</p><p>这样训练之后，我们应该用哪个模型预测最好呢？不确定，但如果损失函数是 $l_{2}$距离的话，那么我们可以推出最佳预测模型应该是：</p><p>$\mathbb{E}_{\varepsilon}\left[f_{\theta}(x, \varepsilon)\right]$</p><p><strong>推导：</strong>如果用$l_{2}$ 损失，此时单个样本的损失是：</p><p>$\mathbb{E}_{\varepsilon}\left[\left|y-f_{\theta}(x, \varepsilon)\right|^{2}\right]=|y|^{2}-2\left\langle y, \mathbb{E}_{\varepsilon}\left[f_{\theta}(x, \varepsilon)\right]\right\rangle+\mathbb{E}_{\varepsilon}\left[\left|f_{\theta}(x, \varepsilon)\right|^{2}\right]$</p><p>注意，现在我们的问题是“模型训练完后应该用什么函数来预测”，所以 $f_{\theta}(x, \varepsilon)$ 是常数， $\mathrm{y}$ 才是要优化的变量，这只不过是一个 二次函数的最小值问题，容易解得 $y=\mathbb{E}_{\varepsilon}\left[f_{\theta}(x, \varepsilon)\right]$ 时损失函数最小。</p><p>我们假定这个结果能泛化到一般情况。上式告诉我们，带 Dropout 的模型的正确步骤是“模型融合”：</p><p>对同一个输入多次传入模型中（模型不关闭 Dropout），然后把多次的预测结果平均值作为最终的预测结果。</p><p>但我们一般情况下的预测方式显然不是这样的，而是直接关闭 Dropout 进行确定性的预测，这等价于预测模型由“模型平均”变成了“权重平均”：</p><p>$f_{\theta}\left(x, \mathbb{E}_{\varepsilon}[\varepsilon]\right)=f_{\theta}(x, 1)=f_{\theta}(x)$</p><p>这里的 1 指的是全 1 向量。所以，我们训练的是不同 Dropout 的融合模型，预测的时候用的是关闭 Dropout 的单模型，两者未必等价，这就是 Dropout 的训练预测不一致问题。</p><p>现在，我们就不难理解 R-Drop 了，它通过增加一个正则项，来强化模型对 Dropout 的鲁棒性，使得不同的 Dropout 下模型的输出基本一致，因此能降低这种不一致性，促进“模型平均”与“权重平均”的相似性，从而使得简单关闭 Dropout 的效果等价于多 Dropout 模型融合的结果，提升模型最终性能。</p><h3 id="4-2-连续性"><a href="#4-2-连续性" class="headerlink" title="4.2 连续性"></a>4.2 连续性</h3><p>本文开头就提到 R-Drop 与 SimCSE 的相似性，事实上它还跟另外一个方法相当相似，那便是“虚拟对抗训练（Virtual Adversarial Training，VAT）”。（不过 R-Drop 也没引 VAT，难道就只有笔者觉得像吗？？）</p><p>关于 VAT 的介绍，大家可以参考笔者之前的文章<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&amp;mid=2247507771&amp;idx=1&amp;sn=b92559c624c7c58e77a11c89bec5e99a&amp;chksm=96ea00bba19d89adb05dd98193e7371d43f090fcaf6be401e01c0109beee7920e84cb13274c9&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">泛化性乱弹：从随机噪声、梯度惩罚到虚拟对抗训练</a>。简单来说，VAT 也是通过一个正则项，使得模型对扰动更加鲁棒，增强模型本身的连续性（小的变化不至于对结果产生大的影响）。它们不同的地方在于加扰动的方式，VAT 只把扰动加入到输入中，并且通过对抗的思想提升扰动的针对性；R-Drop 的扰动则可以施加到模型的每一层中，并且扰动是随机的。</p><p>有读者可能想到了，VAT 可是主打半监督训练的，那是不是意味着 R-Drop 也可以做半监督训练？这部分原论文并没有实验，是笔者自己做的实验，答案是确实可以，跟 VAT 类似，R-Drop 新增的 KL 散度项是不需要标签的，因此可以无监督训练，混合起来就是半监督了，效果也还不错。下面是笔者的实验结果：</p><p><img src="https://i.loli.net/2021/07/05/UT8bI3qG54D19wt.png" alt="image-20210705113103693" style="zoom:50%;"></p><p>可以看到，R-Drop 的半监督效果完全不逊色于 VAT，而且它实现比 VAT 简单，速度也比 VAT 快！看来 VAT 有望退休了～ 直觉上来看，虽然 R-Drop 的扰动是随机的，但是 R-Drop 的扰动更多，所以它造成的扰动也会放大，也可能比得上 VAT 经过对抗优化的扰动，所以 R-Drop 能够不逊色于 VAT。</p><h3 id="4-3-非目标类"><a href="#4-3-非目标类" class="headerlink" title="4.3 非目标类"></a>4.3 非目标类</h3><p>一个比较直接的疑问是，如果我的模型够复杂，单靠交叉熵这一项，不能使得模型对 Dropout 鲁棒吗？KL 散度那一项造成了什么直接的区别？</p><p>事实上，还真的不能。要注意的是，交叉熵的训练目标主要是：让目标类的得分大于非目标类的得分，这样模型就能正确地把目标类预测出来了（参考<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&amp;mid=2247505145&amp;idx=1&amp;sn=42467a5475b64d3031a46594261600d2&amp;chksm=96ea0b79a19d826fb7e040968bbe928daf528d38e63d916b05cbc60a5d350755e619abc2aff8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">将“softmax+交叉熵”推广到多标签分类问题</a>）。也就是说，如果只有交叉熵这一项，模型的训练结果顶多是：</p><blockquote><p>不同的 Dropout 下，目标类的得分都大于非目标类的得分。</p></blockquote><p>而不能做到：</p><blockquote><p>不同的 Dropout 下，每个类的得分一致。</p></blockquote><p>所以也就没有解决训练预测不一致的问题。从公式上来看，交叉熵（2）只跟目标类别有关，不关心非目标类的分布，假如目标类为第一个类别，那么预测结果是 [0.5, 0.2, 0.3] 或 [0.5, 0.3, 0.2]，对它来说都没区别。但对于 KL 散度项（3）来说就不一样了，每个类的得分都要参与计算，[0.5, 0.2, 0.3] 或 [0.5, 0.3, 0.2] 是有非零损失的。</p><h2 id="5-本文小结"><a href="#5-本文小结" class="headerlink" title="5. 本文小结"></a>5. 本文小结</h2><p>本文介绍了 R-Drop，它将“Dropout 两次”的思想用到了有监督任务中，每个实验结果几乎都取得了明显的提升。此外，笔者在自己的实验还发现，它在半监督任务上也能有不俗的表现。最后，分享了笔者对 R-Drop 的三个角度的思考。</p><h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h2><p>[1] <a href="https://kexue.fm/archives/8348" target="_blank" rel="noopener">https://kexue.fm/archives/8348</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来源：&lt;a href=&quot;https://mp.weixin.qq.com/s/IvhGbFEMotpKJIUPExUklg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/IvhGbFEMotpKJIUP
      
    
    </summary>
    
      <category term="NLP, ML" scheme="http://yoursite.com/categories/NLP-ML/"/>
    
    
      <category term="NLP, ML" scheme="http://yoursite.com/tags/NLP-ML/"/>
    
  </entry>
  
  <entry>
    <title>Unifying Vision-and-Language Tasks via Text Generation</title>
    <link href="http://yoursite.com/2021/07/03/Unifying-Vision-and-Language-Tasks-via-Text-Generation/"/>
    <id>http://yoursite.com/2021/07/03/Unifying-Vision-and-Language-Tasks-via-Text-Generation/</id>
    <published>2021-07-03T10:16:18.000Z</published>
    <updated>2021-07-04T14:00:11.166Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/j-min/VL-T5" target="_blank" rel="noopener">code</a></p><h2 id="当前跨模态预训练模型存在的问题"><a href="#当前跨模态预训练模型存在的问题" class="headerlink" title="当前跨模态预训练模型存在的问题"></a>当前跨模态预训练模型存在的问题</h2><ul><li>当前跨模态预训练模型在做下游任务时，通常都是根据特定任务设计相应的 head 和 objective。例如，a multi-label answer classifier for visual question answering, a region scorer for referring expression comprehension, and a language decoder for image captioning.</li></ul><h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><p>为了避免复杂的设计，本文提出了一个联合框架，可以在同一个结构中学习不同的任务。<strong style="color:red;">具体地，本文将判别式任务和生成式任务都转化为 Text  Generation task。</strong>本文的这种方法达到了近似SOTA的效果。</p><p>同时本文提出的框架可以在<strong>同一个参数</strong>下进行多任务训练，这种设置下，可以实现与单独训练特定任务达到相似的性能。(yaya解释，意思是说，这个模型在多任务的设置下训练之后，可以直接拿来去做各种任务，与单独训练特定任务的效果近似)</p><p>这种范式的好处：</p><ul><li>不需要为特定任务设计特定的head</li><li>对于一个新的任务，通过对input and output 进行 text rewrite即可，而不需要增加额外的参数或者是设计新的结构和训练目标。</li><li>由于预训练任务是生成式任务，因此相比于MLM这种理解型任务，文本生成能力更强。比如，当我们回答需要非简单答案的开放式问题时，这一点尤其有帮助，在这种情况下，判别性方法只能从<strong>预定义的频繁候选者集合中</strong>回答，而我们的模型可以生成开放式的自然语言答案。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/j-min/VL-T5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;code&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;当前跨模态预训练模型存在的问题&quot;&gt;&lt;a href=&quot;#当前跨模态预训练模型存在的问题&quot; 
      
    
    </summary>
    
      <category term="croos-moal" scheme="http://yoursite.com/categories/croos-moal/"/>
    
    
      <category term="cross-modal" scheme="http://yoursite.com/tags/cross-modal/"/>
    
  </entry>
  
  <entry>
    <title>Zero-Shot Detection via Vision and Language Knowledge Distillation</title>
    <link href="http://yoursite.com/2021/06/25/Zero-Shot-Detection-via-Vision-and-Language-Knowledge-Distillation/"/>
    <id>http://yoursite.com/2021/06/25/Zero-Shot-Detection-via-Vision-and-Language-Knowledge-Distillation/</id>
    <published>2021-06-25T09:28:47.000Z</published>
    <updated>2021-06-25T09:28:47.189Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>理解对比学习和 SimCSE</title>
    <link href="http://yoursite.com/2021/06/22/%E7%90%86%E8%A7%A3%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0%E5%92%8C-SimCSE/"/>
    <id>http://yoursite.com/2021/06/22/理解对比学习和-SimCSE/</id>
    <published>2021-06-22T13:03:55.000Z</published>
    <updated>2021-06-22T13:19:19.187Z</updated>
    
    <content type="html"><![CDATA[<p>来源：<a href="https://mp.weixin.qq.com/s/12UvfXnaB4NTy54wWIFZdQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/12UvfXnaB4NTy54wWIFZdQ</a></p><p>2020 年的 Moco 和 SimCLR 等，掀起了对比学习在 CV 领域的热潮，2021 年的 SimCSE，则让 NLP 也乘上了对比学习的东风。下面就尝试用 QA 的形式挖掘其中一些细节知识点，去更好地理解对比学习和 SimCSE。</p><ul><li><p>如何去理解对比学习，它和度量学习的差别是什么？</p></li><li><p>对比学习中一般选择一个 batch 中的所有其他样本作为负例，那如果负例中有很相似的样本怎么办？</p></li><li><p>infoNCE loss 如何去理解，和 CE loss有什么区别？</p></li><li><p>对比学习的 infoNCE loss 中的温度常数的作用是什么？</p></li><li><p>SimCSE 中的 dropout mask 指的是什么，dropout rate 的大小影响的是什么？</p></li><li><p>SimCSE 无监督模式下的具体实现流程是怎样的，标签生成和 loss 计算如何实现？</p></li></ul><h2 id="1-如何去理解对比学习，它和度量学习的差别是什么？"><a href="#1-如何去理解对比学习，它和度量学习的差别是什么？" class="headerlink" title="1. 如何去理解对比学习，它和度量学习的差别是什么？"></a><strong>1. 如何去理解对比学习，它和度量学习的差别是什么？</strong></h2><p>对比学习的思想是去拉近相似的样本，推开不相似的样本，而目标是要从样本中学习到一个好的语义表示空间。</p><p>论文 [1] 给出的 “Alignment and Uniformity on the Hypersphere”，就是一个非常好的去理解对比学习的角度。</p><p>好的对比学习系统应该具备两个属性：Alignment和Uniformity（参考上图）。</p><p>所谓“Alignment”，指的是相似的例子，也就是正例，映射到单位超球面后，应该有接近的特征，也即是说，在超球面上距离比较近；</p><p>所谓“Uniformity”，指的是系统应该倾向在特征里保留尽可能多的信息，这等价于使得映射到单位超球面的特征，尽可能均匀地分布在球面上，分布得越均匀，意味着保留的信息越充分。分布均匀意味着两两有差异，也意味着各自保有独有信息，这代表信息保留充分（参考自 [2]）。</p><p>度量学习和对比学习的思想是一样的，都是去拉近相似的样本，推开不相似的样本。但是对比学习是无监督或者自监督学习方法，而度量学习一般为有监督学习方法。而且对比学习在 loss 设计时，为单正例多负例的形式，因为是无监督，数据是充足的，也就可以找到无穷的负例，但<font color="red">如何构造有效正例才是重点。</font></p><p>而度量学习多为二元组或三元组的形式，如常见的 Triplet 形式（anchor，positive，negative），Hard Negative 的挖掘对最终效果有较大的影响。</p><h2 id="2-对比学习中一般选择一个-batch-中的所有其他样本作为负例，那如果负例中有很相似的样本怎么办？"><a href="#2-对比学习中一般选择一个-batch-中的所有其他样本作为负例，那如果负例中有很相似的样本怎么办？" class="headerlink" title="2. 对比学习中一般选择一个 batch 中的所有其他样本作为负例，那如果负例中有很相似的样本怎么办？"></a>2. <strong>对比学习中一般选择一个 batch 中的所有其他样本作为负例，那如果负例中有很相似的样本怎么办？</strong></h2><p>在无监督无标注的情况下，这样的伪负例，其实是不可避免的，首先可以想到的方式是去扩大语料库，去加大 batch size，以降低 batch 训练中采样到伪负例的概率，减少它的影响。</p><p>另外，神经网络是有一定容错能力的，像伪标签方法就是一个很好的印证，但前提是错误标签数据或伪负例占较小的比例。</p><p>PS：也确有人考虑研究过这个问题，可以参考论文 [3] [4]</p><h2 id="3-infoNCE-loss-如何去理解，和-CE-loss-有什么区别？"><a href="#3-infoNCE-loss-如何去理解，和-CE-loss-有什么区别？" class="headerlink" title="3. infoNCE loss 如何去理解，和 CE loss 有什么区别？"></a>3. <strong>infoNCE loss 如何去理解，和 CE loss 有什么区别？</strong></h2><p><strong>infoNCE loss</strong> 全称 info Noise Contrastive Estimation loss，对于一个 batch 中的样本 i，它的 loss 为：</p><p><img src="https://i.loli.net/2021/06/22/Omj8YCPkqeWwyp4.png" alt="image-20210622211019708" style="zoom:50%;"></p><p>要注意的是，<font color="red">log 里面的分母叠加项是<strong>包括了分子项</strong>的。</font> 分子是正例对的相似度，分母是正例对+所有负例对的相似度，最小化 infoNCE loss，就是去最大化分子的同时最小化分母，也就是最大化正例对的相似度，最小化负例对的相似度。</p><p>上面公式直接看可能没那么清晰，可以把负号放进去，分子分母倒过来化简一下就会很明了了。</p><p><strong>CE loss</strong>，Cross Entropy loss，在输入 p 是 softmax 的输出时：</p><p><img src="https://i.loli.net/2021/06/22/YFIfqETp1S7Kg83.png" alt="image-20210622211041814" style="zoom:50%;"></p><p>在分类场景下，真实标签 y 一般为 one-hot 的形式，因此，CE loss 可以简化成（i 位置对应标签 1）：</p><p><img src="https://i.loli.net/2021/06/22/saTEDlBWg1uUNAp.png" alt="image-20210622211108963" style="zoom:50%;"></p><p>看的出来，info NCE loss 和在一定条件下简化后的 CE loss 是非常相似的，但有一个区别要注意的是：</p><p>infoNCE loss 中的 K 是 batch 的大小，是可变的，是第 i 个样本要和 batch 中的每个样本计算相似度，而 batch 里的每一个样本都会如此计算，因此上面公式只是样本 i 的 loss。</p><p>CE loss 中的 K 是分类类别数的大小，任务确定时是不变的，i 位置对应标签为 1 的位置。不过实际上，infoNCE loss 就是直接可以用 CE loss 去计算的。</p><p>注：1）info NCE loss 不同的实现方式下，它的计算方式和 K 的含义可能会有差异；2）info NCE loss 是基于 NCE loss 的，对公式推导感兴趣的可以参考 [5]。</p><h2 id="4-对比学习的-infoNCE-loss-中的温度常数-t-的作用是什么？"><a href="#4-对比学习的-infoNCE-loss-中的温度常数-t-的作用是什么？" class="headerlink" title="4. 对比学习的 infoNCE loss 中的温度常数 t 的作用是什么？"></a>4. <strong>对比学习的 infoNCE loss 中的温度常数 t 的作用是什么？</strong></h2><p>论文 [6] 给出了非常细致的分析，知乎博客 [7] 则对论文 [6] 做了细致的解读，这里摘录它的要点部分：</p><p>温度系数的作用是调节对困难样本的关注程度：<strong>越小的温度系数越关注于将本样本和最相似的困难样本分开</strong>，去得到更均匀的表示。然而困难样本往往是与本样本相似程度较高的，很多困难负样本其实是潜在的正样本，过分强迫与困难样本分开会破坏学到的潜在语义结构，因此，温度系数不能过小。</p><p>考虑两个极端情况，温度系数趋向于 0 时，对比损失退化为只关注最困难的负样本的损失函数；当温度系数趋向于无穷大时，对比损失对所有负样本都一视同仁，失去了困难样本关注的特性。</p><p>还有一个角度：</p><p>可以把不同的负样本想像成同极点电荷在不同距离处的受力情况，距离越近的点电荷受到的库伦斥力更大，而距离越远的点电荷受到的斥力越小。</p><p>对比损失中，越近的负例受到的斥力越大，具体的表现就是对应的负梯度值越大 [4]。这种性质更有利于形成在超球面均匀分布的特征。</p><p>对照着公式去理解：</p><p><img src="https://i.loli.net/2021/06/22/QTPnuCLMc6Ug1sb.png" alt="image-20210622211420543" style="zoom:33%;"></p><p>温度系数很小时，越相似也即越困难的负例，对应的 就会越大，在分母叠加项中所占的比重就会越大，对整体 loss 的影响就会越大，具体的表现就是对应的负梯度值越大 [7]。</p><p>当然，这仅仅是提供了一种定性的认识，定量的认识和推导可以参见博客 [7]。</p><h2 id="5-SimCSE-中的-dropout-mask-指的是什么，dropout-rate-的大小影响的是什么？"><a href="#5-SimCSE-中的-dropout-mask-指的是什么，dropout-rate-的大小影响的是什么？" class="headerlink" title="5. SimCSE 中的 dropout mask 指的是什么，dropout rate 的大小影响的是什么？"></a>5. <strong>SimCSE 中的 dropout mask 指的是什么，dropout rate 的大小影响的是什么？</strong></h2><p>一般而言的 mask 是对 token 级别的 mask，比如说 BERT MLM 中的 mask，batch 训练时对 padding 位的 mask 等。</p><p>SimCSE 中的 dropout mask，对于 BERT 模型本身，是一种网络模型的随机，是对网络参数 W 的 mask，起到防止过拟合的作用。</p><p>而 SimCSE 巧妙的把它作为了一种 noise，起到数据增强的作用，因为同一句话，经过带 dropout 的模型两次，得到的句向量是不一样的，但是因为是相同的句子输入，最后句向量的语义期望是相同的，因此作为正例对，让模型去拉近它们之间的距离。</p><p>在实现上，因为一个 batch 中的任意两个样本，经历的 dropout mask 都是不一样的，因此，一个句子过两次 dropout，SimCSE 源码中实际上是在一个 batch 中实现的，即 [a,a,b,b…] 作为一个 batch 去输入。</p><p>dropout rate 大小的影响，可以理解为，这个概率会对应有 dropout 的句向量相对无 dropout 句向量，在整个单位超球体中偏移的程度，因为 BERT 是多层的结构，每一层都会有 dropout，这些 noise 的累积，会让句向量在每个维度上都会有偏移的，只是 p 较小的情况下，两个向量在空间中仍较为接近，如论文所说，“keeps a steady alignment”，保证了一个稳定的对齐性。</p><h2 id="6-SimCSE-无监督模式下的具体实现流程是怎样的，标签生成和-loss-计算如何实现？"><a href="#6-SimCSE-无监督模式下的具体实现流程是怎样的，标签生成和-loss-计算如何实现？" class="headerlink" title="6. SimCSE 无监督模式下的具体实现流程是怎样的，标签生成和 loss 计算如何实现？"></a>6. <strong>SimCSE 无监督模式下的具体实现流程是怎样的，标签生成和 loss 计算如何实现？</strong></h2><p>这里用一个简单的例子和 Pytorch 代码来说明：</p><p><strong>前向句子 embedding 计算：</strong></p><p>假设初始输入一个句子集 sents = [a,b]，每一句要过两次 BERT，因此复制成 sents = [a,a,b,b]。</p><p>sents 以 batch 的形式过 BERT 等语言模型得到句向量：batch_emb = [a1,a2,b1,b2]。</p><p><strong>batch 标签生成：</strong>标签为 1 的地方是相同句子不同 embedding 对应的位置。</p><p><img src="https://i.loli.net/2021/06/22/bE15TPnoGCRvFZk.png" alt="image-20210622211637062" style="zoom: 33%;"></p><p>pytorch 中的 CE_loss，要使用一维的数字标签，上面的 one-hot 标签可转换成：[1,0,3,2]。</p><p>可以把 label 拆成两个部分：奇数部分 [1,3…] 和偶数部分 [0,2…]，交替的每个奇数在偶数前面。因此实际生成的时候，可以分别生成两个部分再 concat 并 reshape 成一维。</p><p>pytorch 中 label 的生成代码如下：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构造标签</span></span><br><span class="line"><span class="keyword">batch</span>_size = <span class="keyword">batch</span>_emb.size<span class="params">(0)</span></span><br><span class="line">y_<span class="literal">true</span> = torch.cat<span class="params">([torch.arange(1,batch_size,<span class="attr">step</span>=2,<span class="attr">dtype</span>=torch.long)</span><span class="string">.unsqueeze</span><span class="params">(1)</span>,</span><br><span class="line">                    torch.arange<span class="params">(0,batch_size,<span class="attr">step</span>=2,<span class="attr">dtype</span>=torch.long)</span><span class="string">.unsqueeze</span><span class="params">(1)</span>],</span><br><span class="line">                    dim=1)<span class="string">.reshape</span><span class="params">([batch_size,])</span></span><br></pre></td></tr></table></figure><p><strong>score 和 loss计算：</strong></p><p>batch_emb 会先 norm，再计算任意两个向量之间的点积，得到向量间的余弦相似度，维度是：[batch_size, batch_size]。</p><p>但是对角线的位置，也就是自身的余弦相似度，需要 mask 掉，因为它肯定是 1，是不产生 loss 的。</p><p>然后，要除以温度系数，再进行 loss 的计算，loss_func 采用 CE loss，注意 CE loss 中是自带 softmax 计算的。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算score和loss</span></span><br><span class="line"><span class="attr">norm_emb</span> = F.normalize(batch_emb, dim=<span class="number">1</span>, p=<span class="number">2</span>)</span><br><span class="line"><span class="attr">sim_score</span> = torch.matmul(norm_emb, norm_emb.transpose(<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="attr">sim_score</span> = sim_score - torch.eye(batch_size) * <span class="number">1</span>e12</span><br><span class="line"><span class="attr">sim_score</span> = sim_score * <span class="number">20</span>        <span class="comment"># 温度系数为 0.05，也就是乘以20</span></span><br><span class="line"><span class="attr">loss</span> = loss_func(sim_score, y_<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">loss_func</span> = nn.CrossEntropyLoss()</span><br><span class="line">def simcse_loss(batch_emb):</span><br><span class="line">    <span class="string">""</span><span class="string">"用于无监督SimCSE训练的loss</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    <span class="comment"># 构造标签</span></span><br><span class="line">    <span class="attr">batch_size</span> = batch_emb.size(<span class="number">0</span>)</span><br><span class="line">    <span class="attr">y_true</span> = torch.cat([torch.arange(<span class="number">1</span>, batch_size, <span class="attr">step=2,</span> <span class="attr">dtype=torch.long).unsqueeze(1),</span></span><br><span class="line">                        torch.arange(<span class="number">0</span>, batch_size, <span class="attr">step=2,</span> <span class="attr">dtype=torch.long).unsqueeze(1)],</span></span><br><span class="line">                       <span class="attr">dim=1).reshape([batch_size,])</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算score和loss</span></span><br><span class="line">    <span class="attr">norm_emb</span> = F.normalize(batch_emb, <span class="attr">dim=1,</span> <span class="attr">p=2)</span></span><br><span class="line">    <span class="attr">sim_score</span> = torch.matmul(norm_emb, norm_emb.transpose(<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">    <span class="attr">sim_score</span> = sim_score - torch.eye(batch_size) * <span class="number">1</span>e12</span><br><span class="line">    <span class="attr">sim_score</span> = sim_score * <span class="number">20</span></span><br><span class="line">    <span class="attr">loss</span> = loss_func(sim_score, y_true)</span><br><span class="line">    return loss</span><br></pre></td></tr></table></figure><p>注：看过论文源码 [8] 的同学可能会发现，这个和论文源码中的实现方式不一样，论文源码是为了兼容无监督 SimCSE 和有监督 SimCSE，并兼容有 hard negative 的三句输入设计的，因此实现上有差异。</p><p>看过苏神源码 [9] 的同学也会发现，构造标签的地方不一样，那是因为 keras 的 CE loss 用的是 one-hot 标签，pytorch 用的是数字标签，但本质一样。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] Understanding Contrastive Representation Learning through Alignment and Uniformity on the Hypersphere</p><p>[2] <a href="https://zhuanlan.zhihu.com/p/367290573" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/367290573</a></p><p>[3] Debiased Contrastive Learning</p><p>[4] ADACLR: Adaptive Contrastive Learning Of Representation By Nearest Positive Expansion</p><p>[5] <a href="https://zhuanlan.zhihu.com/p/334772391" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/334772391</a></p><p>[6] Understanding the Behaviour of Contrastive Loss</p><p>[7] <a href="https://zhuanlan.zhihu.com/p/357071960" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/357071960</a></p><p>[8] <a href="https://github.com/princeton-nlp/SimCSE" target="_blank" rel="noopener">https://github.com/princeton-nlp/SimCSE</a></p><p>[9] <a href="https://github.com/bojone/SimCSE" target="_blank" rel="noopener">https://github.com/bojone/SimCSE</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来源：&lt;a href=&quot;https://mp.weixin.qq.com/s/12UvfXnaB4NTy54wWIFZdQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/12UvfXnaB4NTy54w
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GEM: A General Evaluation Benchmark for Multimodal Tasks</title>
    <link href="http://yoursite.com/2021/06/22/GEM-A-General-Evaluation-Benchmark-for-Multimodal-Tasks/"/>
    <id>http://yoursite.com/2021/06/22/GEM-A-General-Evaluation-Benchmark-for-Multimodal-Tasks/</id>
    <published>2021-06-22T00:53:34.000Z</published>
    <updated>2021-06-22T01:54:52.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><ul><li><p>类似于 GLUE，SuperGLUE 这种 language evaluation benchmark 可以评估纯语言预训练模型的能力，但是多模态方向上，多模态预训练模型的能力还没有相关的benchmark，本文提出了 <font color="red">多模态任务上 evaluation benchmark：<strong>GEM</strong>。</font></p></li><li><p>本文的多模态任务，包括 image-text <strong>GEM-I</strong>; video-text <strong>GEM-V</strong>。同时相比于当前存在的多模态数据集（例如 MSCOCO，Flickr30K，YouCook2, MSR-VTT）， <font color="red"><strong>GEM</strong> 规模上更大，且涵盖多种语言。</font></p></li><li><p>本文提供了两个多模态多语言预训练模型, <a href="https://arxiv.org/abs/2006.02635" target="_blank" rel="noopener">M3P</a> and <a href="https://arxiv.org/abs/2002.06353" target="_blank" rel="noopener">m-UniVL</a> 作为 GEM 的baseline. M3P是一个现成的多语言， image-text 预训练模型，m-UniVL是 本文对video-text预训练模型 UniVL 做的扩展</p></li></ul><h2 id="相关论文"><a href="#相关论文" class="headerlink" title="相关论文"></a>相关论文</h2><p>总结一下多模态预训练模型中，<strong>包含多语言</strong>的一些模型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;本文的点&quot;&gt;&lt;a href=&quot;#本文的点&quot; class=&quot;headerlink&quot; title=&quot;本文的点&quot;&gt;&lt;/a&gt;本文的点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;类似于 GLUE，SuperGLUE 这种 language evaluation benchmark 可
      
    
    </summary>
    
      <category term="cross-modal" scheme="http://yoursite.com/categories/cross-modal/"/>
    
    
      <category term="cross-modal" scheme="http://yoursite.com/tags/cross-modal/"/>
    
  </entry>
  
  <entry>
    <title>Frozen in Time: A Joint Video and Image Encoder for End-to-End Retrieval</title>
    <link href="http://yoursite.com/2021/06/18/Frozen-in-Time-A-Joint-Video-and-Image-Encoder-for-End-to-End-Retrieval-1/"/>
    <id>http://yoursite.com/2021/06/18/Frozen-in-Time-A-Joint-Video-and-Image-Encoder-for-End-to-End-Retrieval-1/</id>
    <published>2021-06-18T01:56:24.000Z</published>
    <updated>2021-06-22T00:55:06.924Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="cross-modal" scheme="http://yoursite.com/categories/cross-modal/"/>
    
    
      <category term="cross-modal" scheme="http://yoursite.com/tags/cross-modal/"/>
    
  </entry>
  
  <entry>
    <title>VinVL: Revisiting Visual Representations in Vision-Language Models</title>
    <link href="http://yoursite.com/2021/06/16/VinVL-Revisiting-Visual-Representations-in-Vision-Language-Models/"/>
    <id>http://yoursite.com/2021/06/16/VinVL-Revisiting-Visual-Representations-in-Vision-Language-Models/</id>
    <published>2021-06-16T08:51:45.000Z</published>
    <updated>2021-06-16T09:04:59.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本文的任务"><a href="#本文的任务" class="headerlink" title="本文的任务"></a>本文的任务</h2><p>研究如何改善 V+L 跨模态预训练模型</p><h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><p>通过改善目标检测器模型，来改善以物体 (object) 为中心的图像表示 (image representation)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;本文的任务&quot;&gt;&lt;a href=&quot;#本文的任务&quot; class=&quot;headerlink&quot; title=&quot;本文的任务&quot;&gt;&lt;/a&gt;本文的任务&lt;/h2&gt;&lt;p&gt;研究如何改善 V+L 跨模态预训练模型&lt;/p&gt;
&lt;h2 id=&quot;本文的点&quot;&gt;&lt;a href=&quot;#本文的点&quot; clas
      
    
    </summary>
    
      <category term="cross-modal" scheme="http://yoursite.com/categories/cross-modal/"/>
    
    
      <category term="cross-modal" scheme="http://yoursite.com/tags/cross-modal/"/>
    
  </entry>
  
  <entry>
    <title>UniT: Multimodal Multitask Learning with a Unified Transformer</title>
    <link href="http://yoursite.com/2021/06/15/UniT-Multimodal-Multitask-Learning-with-a-Unified-Transformer/"/>
    <id>http://yoursite.com/2021/06/15/UniT-Multimodal-Multitask-Learning-with-a-Unified-Transformer/</id>
    <published>2021-06-15T04:56:08.000Z</published>
    <updated>2021-06-16T02:22:02.690Z</updated>
    
    <content type="html"><![CDATA[<p>曾几何时，多模态预训练已经不是一个新的话题，各大顶会诸多论文仿佛搭上Visual和BERT，就能成功paper+=1，VisualBERT、ViLBERT层出不穷，傻傻分不清楚……这些年NLPer在跨界上忙活的不亦乐乎，提取视觉特征后和文本词向量一同输入到万能的Transformer中，加大力度预训练，总有意想不到的SOTA。</p><p>如何在多模态的语境中更细致准确地利用Transformer强大的表达能力呢？Facebook最新的 <strong><em>Transformer is All You Need</em></strong> 也许可以给你答案。</p><p><img src="https://i.loli.net/2021/06/15/7HAQCbFuxkGpOgt.png" alt="image-20210615125803091" style="zoom:67%;"></p><p>这篇貌似标题党的文章开宗明义，针对文本+视觉的多模态任务，用好Transformer就够了，与许多前作不同，这次提出的模型一个模型可以解决多个任务：目标检测、自然语言理解、视觉问答，各个模型板块各司其职、条理清晰：<strong>视觉编码器</strong>、<strong>文本编码器</strong>、<strong>特征融合解码器</strong>，都是建立在多层Transformer之上，最后添加为每个任务设计的<strong>处理器</strong>，通过多任务训练，一举刷新了多个任务的榜单。</p><p><strong>论文题目</strong>:<br><strong><em>Transformer is All You Need: Multimodal Multitask Learning with a Unified Transformer</em></strong></p><p><strong>论文链接</strong>:<br><em><a href="https://arxiv.org/pdf/2102.10772.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/2102.10772.pdf</a></em></p><p><img src="https://i.loli.net/2021/06/15/EXpkQu8UT67eYrn.png" alt="image-20210615125848323" style="zoom: 67%;"></p><h2 id="文本编码器"><a href="#文本编码器" class="headerlink" title="文本编码器"></a>文本编码器</h2><p>用Transformer提取文本特征是个老生常谈的问题，从BERT石破天惊开始，纯文本领域近乎已被Transformer蚕食殆尽，所以该文也不能免俗，直接借用BERT的结构提取文本内容，区别在于，为了解决多个任务，在文本序列前添加了一个针对不同任务的参数向量，在最后输出隐藏状态到解码器时再去掉。</p><p><img src="https://i.loli.net/2021/06/15/l5z9uxCfsK3iEkD.png" alt="image-20210615125939485" style="zoom:50%;"></p><h2 id="视觉编码器"><a href="#视觉编码器" class="headerlink" title="视觉编码器"></a>视觉编码器</h2><p>本文将Transformer强大的表达能力运用到视觉特征的提取中，由于图片像素点数量巨大，首先通过基于卷积神经网络的ResNet-50提取卷积特征，极大程度上地降低了特征数量，最终得到的feature map大小为，然后用全联接层调整单个特征的维度到，再利用多层Transformer中的注意力机制提取各个feature之间的关系，由于Transformer的输入是序列，文章将拉成一条长为的序列，另外和文本编码器类似，同样添加了与下游任务相关的。</p><p><img src="https://i.loli.net/2021/06/15/8s9PnX7Zgz3piNS.png" alt="image-20210615130014598" style="zoom:67%;"></p><p>其中是调整维度的全联接层，是多层Transformer编码器。</p><h2 id="模态融合解码器"><a href="#模态融合解码器" class="headerlink" title="模态融合解码器"></a>模态融合解码器</h2><p>多模态的关键之一就在于怎么同时利用多个模态，在本文中是通过Transformer的解码器实现的，这个解码器首先将任务相关的query做self-attention，再将结果与文本编码器和视觉编码器的结果做cross-attention，针对单一模态的任务，选取对应编码器的输出即可，针对多模态的任务，取两个编码器输出的拼接。</p><p><img src="https://i.loli.net/2021/06/15/TJHRK84Ppv9jzYU.png" alt="image-20210615130046055" style="zoom:50%;"></p><h2 id="任务处理器-task-specific-output-head"><a href="#任务处理器-task-specific-output-head" class="headerlink" title="任务处理器(task-specific output head)"></a>任务处理器(task-specific output head)</h2><p>之前多模态预训练模型往往只针对某一项任务，而本文提出的一个模型可以解决多个文本+视觉任务，与BERT可以解决多个文本任务类似，本文的模型在模态融合解码器的结果上添加为每个任务设计的处理器，这个处理器相对简单，用于从隐藏状态中提取出与特定任务相匹配的特征。</p><ul><li><strong>目标检测</strong>：添加box_head和class_head两个前馈神经网络从最后一层隐藏状态中提取特征用来确定目标位置和预测目标类型。</li></ul><p><img src="https://i.loli.net/2021/06/15/jZhuaekyDWdP46w.png" alt="image-20210615130137970"></p><ul><li><strong>自然语言理解、视觉问答</strong>：通过基于全联接层的分类模型实现，将模态融合解码器结果的第一位隐藏状态输入到两层全联接层并以GeLU作为激活函数，最后计算交叉熵损失。</li></ul><p><img src="https://i.loli.net/2021/06/15/kCJYopFwB7MKRE4.png" alt="image-20210615130146288"></p><h2 id="实验与总结"><a href="#实验与总结" class="headerlink" title="实验与总结"></a>实验与总结</h2><p>本文提出的多模态预训练模型各个板块划分明确，通过多层Transformer分别提取特征，再利用解码器机制融合特征并完成下游任务，同时借助最后一层任务相关的处理器，可以通过一个模型解决多个任务，同时也让多任务预训练成为可能，并在实验中的各个数据集上得到了论文主要进行了两部分实验：</p><h3 id="多任务学习："><a href="#多任务学习：" class="headerlink" title="多任务学习："></a>多任务学习：</h3><p>这里的多任务涉及目标检测和视觉问答两个任务，在目标检测上运用COCO和VG两个数据集，在视觉问答上运用VQAv2数据集。对比了单一任务和多任务同时训练的结果，同时对比了不同任务共用解码器的结果。</p><p><img src="C:\Users\shiyaya\AppData\Roaming\Typora\typora-user-images\image-20210615130353457.png" alt="image-20210615130353457"></p><p>从结果中我们可以看出，单纯的使用多任务训练并不一定可以提高结果，不同任务间虽然相关但是却不完全相同，这可能是任务本身差异或者数据集的特性所导致，第二行和第五行可以很明显地看出COCO上的目标检测和VQAv2的视觉问答相结合后，结果有显著的下降，然而VG上的目标检测却能够和视觉问答很好地结合，通过三个数据集上的共同训练，可以得到最高的结果。</p><h3 id="多模态学习："><a href="#多模态学习：" class="headerlink" title="多模态学习："></a>多模态学习：</h3><p>这一实验中，为了体现所提出模型能够有效解决多个多种模态的不同任务，论文作者在之前COCO、VG、VQAv2的基础上，增加了单一文本任务GLUE的几个数据集（QNLI、QQP、MNLI、SST-2）和视觉推断数据集SNLI-VE，从数据集的数量上可以看出本文模型的全能性。与本文对比的有纯文本的BERT、基于Transformer的视觉模型DETR、多模态预训练模型VisualBERT。</p><p><img src="https://i.loli.net/2021/06/15/hSUibrVRlXz8KF2.png" alt="image-20210615130226872"></p><p>仔细看各个数据集上的结果，不难看出本文提出的模型其实并不能在所有数据集多上刷出SOTA，比如COCO上逊色于DETR，SNLI-VE逊色于VisualBERT，SST-2逊色于BERT，其他数据集上都有一定的提高，但是模型却胜在一个“全”字，模型的结构十分清晰明了，各个板块的作用十分明确，同时针对不同任务的处理器也对后续多模态任务富有启发性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;曾几何时，多模态预训练已经不是一个新的话题，各大顶会诸多论文仿佛搭上Visual和BERT，就能成功paper+=1，VisualBERT、ViLBERT层出不穷，傻傻分不清楚……这些年NLPer在跨界上忙活的不亦乐乎，提取视觉特征后和文本词向量一同输入到万能的Transf
      
    
    </summary>
    
      <category term="cross-modal" scheme="http://yoursite.com/categories/cross-modal/"/>
    
    
      <category term="cross-modal" scheme="http://yoursite.com/tags/cross-modal/"/>
    
  </entry>
  
  <entry>
    <title>SimCSE: Simple Contrastive Learning of Sentence Embeddings</title>
    <link href="http://yoursite.com/2021/06/11/SimCSE-Simple-Contrastive-Learning-of-Sentence-Embeddings/"/>
    <id>http://yoursite.com/2021/06/11/SimCSE-Simple-Contrastive-Learning-of-Sentence-Embeddings/</id>
    <published>2021-06-11T02:50:57.000Z</published>
    <updated>2021-06-11T02:50:57.626Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Non-Autoregressive Neural Machine Translation</title>
    <link href="http://yoursite.com/2021/06/07/Non-Autoregressive-Neural-Machine-Translation/"/>
    <id>http://yoursite.com/2021/06/07/Non-Autoregressive-Neural-Machine-Translation/</id>
    <published>2021-06-07T02:50:12.000Z</published>
    <updated>2021-06-12T03:44:40.846Z</updated>
    
    <content type="html"><![CDATA[<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p> <a href="https://homes.cs.washington.edu/~jkasai/2020-01-28/nat/" target="_blank" rel="noopener">https://homes.cs.washington.edu/~jkasai/2020-01-28/nat/</a></p><p>翻译版：<a href="https://zhuanlan.zhihu.com/p/110794460" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/110794460</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本篇博客针对当前使用<strong>非自回归</strong>方式处理<strong>机器翻译</strong>任务的相关论文进行总结。</p><h2 id="为什么要进行非自回归机器翻译？"><a href="#为什么要进行非自回归机器翻译？" class="headerlink" title="为什么要进行非自回归机器翻译？"></a>为什么要进行非自回归机器翻译？</h2><p>最近的一系列工作提出了非自回归机器翻译的方法 (NAT, <a href="https://arxiv.org/abs/1711.02281" target="_blank" rel="noopener">Gu et al. 2018</a>) 。NAT并行生成目标单词，这与标准自动回归翻译（AT）形成对比，后者可以预测以所有先前单词为条件的每个单词。虽然AT通常在相似配置下比NAT表现更好，但是NAT通过并行计算加快了推理速度。这种非自回归生成的一个非常成功的应用是Parallel WaveNet  (<a href="https://arxiv.org/abs/1711.10433" target="_blank" rel="noopener">Oord et al. 2017</a>)，将原始自回归Wavenet的速度提高了1000倍以上，并部署在了Google助手中。从NAT快速推断得到的收益可以允许在工业界的特定延迟和预算下部署更大，更深的Transformer模型。在这篇博客文章中，我将概述有关非自回归翻译的最新研究，并讨论我认为对进一步发展而言缺失或重要的内容。</p><h2 id="基本问题和可能的解决方法"><a href="#基本问题和可能的解决方法" class="headerlink" title="基本问题和可能的解决方法"></a>基本问题和可能的解决方法</h2><p>生成中的<a href="https://arxiv.org/abs/1711.02281" target="_blank" rel="noopener">多模式性(Multimodality)</a>对NAT提出了根本的挑战。我们都知道语言是高度多模态的(multimodal)。举一个小例子，英文句子<code>he is very good at Japanese</code>和<code>he speaks Japanese very well</code>是日语句子<code>彼は日本語が上手です</code>的两个有效译文。但是，看起很像的两个句子：<code>he speaks very good at Japanese</code>或<code>he is very good at very well</code>则没有任何意义。我们需要知道模型提交给它自己的两种可能的翻译是哪一种，但是在条件独立的解码中很难实现这一点。并行解码打破了条件依赖性，并经常导致输出不一致。文献中的一些工作已经提出解决NAT中Multimodality问题的方法。在这里，我对提出的方法进行了概括和分类。</p><h3 id="1-基于迭代（Iteration-based）的方法"><a href="#1-基于迭代（Iteration-based）的方法" class="headerlink" title="1. 基于迭代（Iteration-based）的方法"></a>1. 基于迭代（Iteration-based）<strong>的方法</strong></h3><p>解决并行解码问题的一种方法是迭代地优化模型输出(<a href="https://arxiv.org/abs/1802.06901" target="_blank" rel="noopener">Lee et al., 2018</a>; <a href="https://arxiv.org/abs/1904.09324" target="_blank" rel="noopener">Ghazvininejad et al., 2019</a>; <a href="https://homes.cs.washington.edu/~jkasai/2020-01-28/nat/Ghazvininejad et al., 2019" target="_blank" rel="noopener">Gu et al. 2019</a>; <a href="https://arxiv.org/pdf/2001.05136.pdf" target="_blank" rel="noopener">Kasai et al. 2020</a>)。在此框架中，我们放弃了完全可并行化的生成，而是在<strong>每次迭代中优化了先前生成的单词</strong>。由于通常我们所需的迭代次数比输出句子中单词的数量少得多，因此与自回归模型相比，迭代方法仍可以改善等待时间。这些论文均采用不同的方法进行细化，为了更清晰地理解，您可以参考<a href="https://arxiv.org/abs/1904.09324" target="_blank" rel="noopener">Ghazvininejad et al., 2019</a>  提出的一种典型的条件屏蔽语言模型（CMLM）。在给定源文本的情况下，使用目标端的BERT-style的掩蔽语言建模目标对CMLM进行训练，在推断中，我们Mask住<em>低置信度</em>的token，并在每次迭代中对其进行更新。 <a href="https://arxiv.org/pdf/2001.05136.pdf" target="_blank" rel="noopener">Kasai et al. 2020</a> 工作提出了DisCo Transformer，该Transformer可计算出这种掩盖语言建模MLM的有效替代方案。特别地，在给定其他reference token的任意子集的情况下，可以训练DisCo Transformer来预测每个输出token。可以将其视为一次模拟多个masking。我们证明了DisCo Transformer可以减少所需的迭代次数（从而减少解码时间），同时保持转换质量。</p><blockquote><p>[1] Deterministic Non-Autoregressive Neural Sequence Modeling by Iterative Refinement</p><p>[2] Mask-Predict: Parallel Decoding of Conditional Masked Language Models. Marjan Ghazvininejad, Omer Levy, Yinhan Liu, Luke Zettlemoyer</p><p>[3] Non-autoregressive Machine Translation with Disentangled Context Transformer. Jungo Kasai,  James Cross,  Marjan Ghazvininejad, Jiatao Gu</p></blockquote><h3 id="2-比NLL更好的训练目标"><a href="#2-比NLL更好的训练目标" class="headerlink" title="2. 比NLL更好的训练目标"></a>2. 比NLL更好的训练目标</h3><p>一些工作提出了对数负似然性NLL的替代损失函数。我的直觉是使用普通NLL损失进行训练无法捕捉高度多峰分布(multimodal distributions)的表征。这在某种程度上让人联想到生成对抗网络（GAN）中的对抗损失。在图像生成中，原始的L2重建损失将使模式崩溃并产生模糊的图像，当使用NLL损失训练NAT模型时，可能会发生类似情况。拟议的替代损失函数包括NAT模型与自回归教师之间的隐藏状态的距离(<a href="https://arxiv.org/abs/1909.06708" target="_blank" rel="noopener">Li et al. 2019</a>)，Ngram词袋差 (<a href="https://arxiv.org/pdf/1911.09320.pdf" target="_blank" rel="noopener">Shao et al. 2020</a>) 和辅助正则化 (<a href="https://arxiv.org/pdf/1902.10245.pdf" target="_blank" rel="noopener">Wang et al. 2019</a>). 。与基于迭代的方法相比，这一系列方法可以并行实现一次生成，但代价是性能大大降低。</p><h3 id="3-精简-部分的自回归解码"><a href="#3-精简-部分的自回归解码" class="headerlink" title="3. 精简/部分的自回归解码"></a>3. 精简/部分的自回归解码</h3><p>先前的工作还提出了将轻度或部分自回归模块整合到NAT模型中的方法。 <a href="https://arxiv.org/pdf/1803.03382.pdf" target="_blank" rel="noopener">Kaiser et al. 2018</a> 生成了较短序列的潜在变量，并在顶部进行了并行单词预测。Blockwise decoding和Insertion Transformer产生的局部自回归方式一个句子 (<a href="https://arxiv.org/abs/1811.03115" target="_blank" rel="noopener">Stern et al. 2018</a>, <a href="https://arxiv.org/abs/1902.03249" target="_blank" rel="noopener">2019</a>).  <a href="https://arxiv.org/abs/1910.11555" target="_blank" rel="noopener">Sun et al. 2019</a> 在变压器输出向量之上引入了factorized CRF层，并通过波束近似(beam approximation)进行了快速自回归解码。 <a href="https://arxiv.org/abs/1911.02215" target="_blank" rel="noopener">Ran et al. 2019</a> 引入了精简自回归源端重排序模块，以促进并行目标解码。请注意，他们还使用非自回归重排序模块显示了结果，但是性能却差得多。</p><h3 id="4-用潜在变量建模"><a href="#4-用潜在变量建模" class="headerlink" title="4. 用潜在变量建模"></a>4. 用潜在变量建模</h3><p>我们可以在此框架中解释许多模型。例如，可以将所有以预测长度(predicted length)为条件的NAT模型视为具有潜在变量的建模。但尤其是 <a href="https://arxiv.org/abs/1909.02480" target="_blank" rel="noopener">Ma et al. 2019</a>  使用生成流技术对目标句子的复杂分布进行建模。 <a href="https://arxiv.org/abs/1908.07181" target="_blank" rel="noopener">Shu et al. 2020</a> 开发出了具有确定性推论(deterministic inference)的连续潜在变量NAT模型。</p><h3 id="5-从自回归模型中蒸馏"><a href="#5-从自回归模型中蒸馏" class="headerlink" title="5. 从自回归模型中蒸馏"></a>5. 从自回归模型中蒸馏</h3><p>据我所知，几乎所有表现好的NAT模型都经过自回归模型 (e.g. <a href="https://arxiv.org/abs/1711.02281" target="_blank" rel="noopener">Gu et al. 2018</a>) 的序列级知识蒸馏(<a href="https://arxiv.org/abs/1606.07947" target="_blank" rel="noopener">Kim &amp; Rush 2016</a>）训练而成。虽然较大Transformer的蒸馏也有助于自回归机器翻译，尤其是在贪婪解码的情况下，但它的作用是是较大程度上简化NAT模型 (<a href="https://arxiv.org/pdf/2001.05136.pdf" target="_blank" rel="noopener">Kasai et al. 2020</a>)。 <a href="https://arxiv.org/abs/1911.02727" target="_blank" rel="noopener">Zhou et al. 2019</a> 研究了模型容量与蒸馏数据之间的关系，表明模型容量与蒸馏数据复杂性之间存在相关性。这表明知识蒸馏可以杀死原始数据中的某些模式，从而可以更好地训练NAT模型。</p><h2 id="悬而未决的问题和未来目标"><a href="#悬而未决的问题和未来目标" class="headerlink" title="悬而未决的问题和未来目标"></a>悬而未决的问题和未来目标</h2><p>在这里，我重点介绍了我个人好奇的非自回归机器翻译中的开放性问题。</p><ul><li><strong>我们需要蒸馏吗？</strong>蒸馏肯定是一次性的训练成本，但是如果每次更改训练数据或语言对时都必须这样做，则蒸馏成本可能会很高。我们是否可以利用原始数据获得合理的性能？</li><li><strong>我们需要预测目标长度吗？</strong>我仍然发现目标长度预测很奇怪。当前的许多NAT方法都要求目标长度预测并且以这个预测的长度作为条件。虽然长度预测为我们提供了在潜在变量空间中进行搜索的机会，但长度预测会破坏生成的灵活性。</li><li><strong>NAT可以胜过AT吗？</strong>我们已经看到，在相同的配置下，AT的性能通常优于NAT。但是，NAT可以做得更好吗？或者更实际的说，在相同的延迟预算下，NAT是否能明显胜过AT？NAT可以使用更大的配置。</li><li><strong>预训练和NAT。</strong>在非自回归机器翻译中使用大规模预训练的掩蔽语言模型MLM可能比在自回归翻译中使用更容易。NAT中的解码器（例如条件屏蔽语言模型）看起来更像BERT。</li><li><strong>训练和推理中的隔阂(bridge)。</strong>在迭代NAT框架中，<strong><strong style="color:red;">训练和推理之间经常会出现差距</strong></strong>。For example, a conditional language model (CMLM) is trained to predict masked tokens given the other <strong>gold</strong> observed tokens. 最近一项成功的尝试是对CMLM进行SMART训练 (<a href="https://arxiv.org/abs/2001.08785" target="_blank" rel="noopener">Ghazvininejad et al. 2020</a>) ，他们训练模型以从先前的预测误差中恢复。这种方法可普及到基于迭代的NAT。</li><li><strong>向结构化预测学习。</strong>NLP中已经在结构化预测（例如语法和语义解析）方面投入了很多精力。我们可以从结构化预测的方法中学习以更好地处理生成中的条件依赖性吗？训练和推理之间的上述差距是句法分析中研究的一个问题 (e.g. dynamic oracle, <a href="https://www.aclweb.org/anthology/C12-1059/" target="_blank" rel="noopener">Goldberg &amp; Nivre 2012</a>)。我怀疑从结构化预测中还会吸取更多教训。</li></ul><h2 id="ACL-2021"><a href="#ACL-2021" class="headerlink" title="ACL 2021"></a>ACL 2021</h2><p>【ACL findings】Progressive Multi-Granularity Training for Non-Autoregressive  Translation<br><strong>标题</strong>：非自回归翻译的渐进式多粒度训练</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://zhuanlan.zhihu.com/p/110794460" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/110794460</a></p><p><a href="https://homes.cs.washington.edu/~jkasai/2020-01-28/nat/" target="_blank" rel="noopener">https://homes.cs.washington.edu/~jkasai/2020-01-28/nat/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;来源&quot;&gt;&lt;a href=&quot;#来源&quot; class=&quot;headerlink&quot; title=&quot;来源&quot;&gt;&lt;/a&gt;来源&lt;/h2&gt;&lt;p&gt; &lt;a href=&quot;https://homes.cs.washington.edu/~jkasai/2020-01-28/nat/&quot; tar
      
    
    </summary>
    
      <category term="NLP" scheme="http://yoursite.com/categories/NLP/"/>
    
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>The multimodality problem in NAT</title>
    <link href="http://yoursite.com/2021/06/07/The-multimodality-problem-in-NAT/"/>
    <id>http://yoursite.com/2021/06/07/The-multimodality-problem-in-NAT/</id>
    <published>2021-06-07T02:40:43.000Z</published>
    <updated>2021-06-12T08:57:41.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="multimodality-problem"><a href="#multimodality-problem" class="headerlink" title="multimodality problem"></a>multimodality problem</h2><p>非自回归神经机器翻译系统(NAT)通过打破自回归性，并行地生成所有目标词，大幅度地提高了推断速度。然而，现有的NAT模型由于<strong>多峰问题</strong>，与自回归神经网络机器翻译模型相比，翻译质量仍有很大差距。</p><p><strong><strong style="color:red;">什么是多峰问题</strong></strong>，举个简单的例子将汉语句子“干/得/好/！”翻译成英文，可以翻译成“Good job !”或者“Well done !”。由于<strong style="color:blue;">非自回归模型</strong>的条件独立性假设，推断时第一个词“Good”和“Well”的概率是差不多大的，如果第二个词“job”和“done”的概率也差不多大，会使得模型生成出“Good done !”或者“Well job !”这样错误的翻译。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>Learning to Recover from Multi-Modality Errors for Non-Autoregressive Neural Machine Translation</p><p>Syntactically Supervised Transformers for Faster Neural Machine Translation</p><p>ICML 2021 (Oral)：Order-Agnostic Cross Entropy for Non-Autoregressive Machine Translation</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;multimodality-problem&quot;&gt;&lt;a href=&quot;#multimodality-problem&quot; class=&quot;headerlink&quot; title=&quot;multimodality problem&quot;&gt;&lt;/a&gt;multimodality problem&lt;/
      
    
    </summary>
    
      <category term="NLP" scheme="http://yoursite.com/categories/NLP/"/>
    
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>最新机器翻译进展</title>
    <link href="http://yoursite.com/2021/06/07/%E6%9C%80%E6%96%B0%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91%E8%BF%9B%E5%B1%95/"/>
    <id>http://yoursite.com/2021/06/07/最新机器翻译进展/</id>
    <published>2021-06-07T02:10:19.000Z</published>
    <updated>2021-06-07T04:24:20.202Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AAAI-2021"><a href="#AAAI-2021" class="headerlink" title="AAAI  2021"></a>AAAI  2021</h2><p>在 AAAI2021 上同样涌现了许多关于机器翻译任务的研究工作，几乎所有的工作都是基于Transformer模型展开讨论。这里对机器翻译在AAAI2021上的最新研究进展进行总结：</p><h2 id="1-引入语法信息"><a href="#1-引入语法信息" class="headerlink" title="1. 引入语法信息"></a><strong>1. 引入语法信息</strong></h2><p>尽管依托于模型本身本文就能从海量数据中捕获到语言之间的映射关系，但研究人员一直在探索如何将句法、语义等先验知识有效地融入到模型中，并指导模型取得进一步的性能突破。传统的做法通常使用外部工具从训练样本中构造句法树等先验知识，之后在编码端、解码端分别融入先验知识。SyntAligner[1]采取一种自监督双语句法对齐方法，让模型在高维空间中对源语-目标语的句法结构进行精确对齐，从而最大限度地利用对齐后的句法结构之间的互信息提高翻译的性能。</p><blockquote><p>Self-supervised Bilingual Syntactic Alignment for Neural Machine Translation</p></blockquote><h2 id="2-无监督机器翻译"><a href="#2-无监督机器翻译" class="headerlink" title="2. 无监督机器翻译"></a><strong>2. 无监督机器翻译</strong></h2><p>无监督机器翻译同样是机器翻译中备受关注的研究热点。在现实世界中，除了部分富资源语言（如英语，汉语，德语，俄语，印地语等），更多的语言本身受众较小，缺乏海量的双语平行语料进行监督学习。因此，如何在这种资源匮乏，甚至零资源的条件下，学习语言之间的映射是极具挑战的。目前无监督机器翻译通常采用迭代式的back-translation。此外，利用预训练的技术手段能够有效地加快模型的收敛，提高翻译的正确性。[2]通过在构造伪数据的过程中对合成的句子进行正则化约束能够有效地改善翻译的性能。</p><blockquote><p>Empirical Regularization for Synthetic Sentence Pairs in Unsupervised Neural Machine Translation</p></blockquote><h2 id="3-多语言翻译"><a href="#3-多语言翻译" class="headerlink" title="3. 多语言翻译"></a><strong>3. 多语言翻译</strong></h2><p>伴随着机器翻译的发展，研究人员逐渐开始探索不局限于双语句对之间的翻译。多语言模型通过一个模型实现多个语种之间的翻译能够有效降低多语言翻译部署成本。同时将一种源语言翻译成多种不同的目标语言是多语言翻译最常见的场景之一。SimNMT[3]提出了一种同步交叉交互解码器，即在每个目标语生成时，可以依赖未来的信息，以及其他目标语言的历史和未来的上下文信息，充分利用语言内与语言间的信息。</p><h2 id="4-语音翻译"><a href="#4-语音翻译" class="headerlink" title="4. 语音翻译"></a><strong>4. 语音翻译</strong></h2><p>语音翻译直接将源语的语音翻译成目标语言的文本。传统的方法中，采用语音识别和机器翻译级联的方法来解决这一问题。但是具有延迟高，占用存储大，以及容易产生错误累积的问题，很多工作开始关注直接使用端到端的语音到文本的模型来解决这一问题。对于跨模态之间的语言映射，为了让单一的模型充分学习模态之间的关联信息，往往需要引入更多的跨模态和跨语言的特征，造成了沉重的负担，同时单纯的用于端到端模型的语音到文本数据较少，无法充分利用语言识别和机器翻译的数据。为了解决这些问题，COSTT[4]作为一种通用的框架同时结合了级联模型与端到端模型的优点，能够更好地利用大规模双语平行语料，在多个测试集上取得了最优的效果。</p><p>同声传译是一种实时的语言翻译场景，对翻译时延的要求更加严格。目前主流的手段是采用Wait-K策略，但仍然存在由于重复编码导致的训练慢，以及缺少对未来信息建模的问题。Future-guided Training[5]采取unidirectional Transformer方式来避免重复编码，并引入averaged embedding来满足当前词与过去词之间的信息交互。同时利用知识精炼的手段让网络充分利用未来的信息，从而达到更准确的预测。</p><h2 id="5-领域适应"><a href="#5-领域适应" class="headerlink" title="5. 领域适应"></a><strong>5. 领域适应</strong></h2><p>在神经机器翻译中，通过微调来做领域的迁移是一种常见的方法。但是，无约束的微调需要非常仔细的超参数调整，否则很容易在目标域上出现过拟合，导致在通用领域上的性能退化。PRUNE-TUNE[6]是一种基于渐变修剪的领域适应算法。它学习微小的特定于领域的子网以进行调优，通过调整它相应的子网来适应一个新的领域。有效缓解了在微调过中的过拟合和退化问题。</p><p>此外，领域适应与其他方法相结合也是研究的一个热点。元学习对于低资源神经机器翻译(NMT)的有效性已经得到了充分的验证。但是元训练的NMT系统在未见领域中的翻译性能仍然较差。Meta-Curriculum Learning[7]是一种新的面向领域适应的元课程学习方法。在元训练过程中，NMT首先从各个领域学习相似的知识，以避免早期陷入局部最优，最后学习针对不同领域学习个性化的知识，以提高模型对领域特定知识学习的鲁棒性。</p><h2 id="6-解码加速：轻量模型-非自回归解码"><a href="#6-解码加速：轻量模型-非自回归解码" class="headerlink" title="6. 解码加速：轻量模型/非自回归解码"></a><strong>6. 解码加速：轻量模型/非自回归解码</strong></h2><p>过参数化的（超大规模）模型能够有效提升神经机器翻译的性能，但是庞大的存储开销和高昂的计算复杂度使得这类模型无法直接部署到边缘设备(如手机，翻译笔，离线翻译机等)上。早期为了提高模型对未登录词的覆盖度往往使用更大的词表，同时增大了词嵌入矩阵的存储开销，以及构建词表上概率分布时对计算资源的消耗。针对该问题，Partial Vector Quantization[8]提出了一种部分矢量量化的方法，通过压缩词嵌入降低softmax层的计算复杂度，同时使用查找操作来替换softmax层中的大部分乘法运算，在保障翻译质量的同时大大减少了词嵌入矩阵的参数和softmax层的计算复杂度。</p><p>近期，深层模型在神经机器翻译中取得突破性进展，但伴随着层数的堆叠同样面临上述问题。GPKD[9]中提出一种基于群体置换的知识蒸馏方法将深层模型压缩为浅层模型，该方法可以分别应用与编码端与解码端达到模型压缩和解码加速的目的。文中探讨了一种深编码器-浅解码器的异构网络， 其既能保证翻译的准确度，同时满足工业生产的推断时延需求。此外采用子层跳跃的正则化训练方法缓解随着网络加深带来的过拟合问题。</p><p>此外，沿着减少解码端计算复杂度的研究方向，例如Averaged Attention Network（ACL2018）和Sharing Attention Network（IJCAI2019），Compressed Attention Network[10]采取压缩子层的方式，将解码器每一层中分离的多个子层压缩成一个子层，进而简化解码端的计算复杂度，达到解码加速的目的。这种方式在深编码器-浅解码器的结构上取得了进一步的加速增益。</p><p>上述的工作通过轻量化模型提高推断速度，本质上在解码过程中还是采用自回归的方式。相比之下非自回归解码同样是一种有效的解码加速手段。非自回归神经机器翻译系统(NAT)通过打破自回归性，并行地生成所有目标词，大幅度地提高了推断速度。然而，现有的NAT模型由于<strong>多峰问题</strong>，与自回归神经网络机器翻译模型相比，翻译质量仍有很大差距。<strong>什么是多峰问题</strong>，举个简单的例子将汉语句子“干/得/好/！”翻译成英文，可以翻译成“Good job !”或者“Well done !”。由于非自回归模型的条件独立性假设，推断时第一个词“Good”和“Well”的概率是差不多大的，如果第二个词“job”和“done”的概率也差不多大，会使得模型生成出“Good done !”或者“Well job !”这样错误的翻译。ReorderNAT[11]提出一个新颖的NAT框架，通过显式地建模重排序信息来指导非自回归解码。区别于传统方法，根据源语的繁衍率来构造解码端的输入，ReorderNAT在编码器和解码器中间引入了重排序机制。该机制将源语的表示按照目标语的语序进行重新组合，减少解码器对语序的再加工。</p><h2 id="7-评测方法及应用"><a href="#7-评测方法及应用" class="headerlink" title="7. 评测方法及应用"></a><strong>7. 评测方法及应用</strong></h2><p>除了针对机器翻译系统的研究外，如何有效的评估机器翻译系统的性能也是一个重要的研究方向。通常情况下我们使用BLEU作为译文质量评估的常用指标，但是在很多应用场景中，并没有可以对比的参考译文。机器翻译质量评估(QE)便是在不依赖任何参考译文的情况下预测机器翻译质量的一项任务。在QE任务中，通常使用预测器-估计器框架(Predictor-Estimator)。使用预训练的预测器作为特征提取器，再通过评估器对译文进行评估。但是预测器和估计器在训练数据和训练目标上都存在差距，这使得QE模型不能更直接地从大量平行语料库中受益。<strong>DirectQE</strong>[12]中提出了一个新框架，通过生成器在构造QE伪数据，使用额外的探测器在生成的数据上进行训练，并为QE任务设定了新的学习目标，将原本分离的过程进行整合。</p><p>同样机器翻译本身也可以作为工具应用于其他的任务。研究人员为了解决问答任务的数据稀缺问题，通过机器翻译方法来构造多语言问答数据[13]。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <strong>Self-supervised Bilingual Syntactic Alignment for Neural Machine Translation</strong></p><p>[2] Empirical Regularization for Synthetic Sentence Pairs in Unsupervised Neural Machine Translation</p><p>[3] Synchronous Interactive Decoding for Multilingual Neural Machine Translation</p><p>[4] Consecutive Decoding for Speech-to-text Translation</p><p>[5] Future-Guided Incremental Transformer for Simultaneous Translation</p><p>[6] Finding Sparse Structure for Domain Specific Neural Machine Translation</p><p>[7] Meta-Curriculum Learning for Domain Adaptation in Neural Machine Translation</p><p>[8] Accelerating Neural Machine Translation with Partial Word Embedding Compression</p><p>[9] Learning Light-Weight Translation Models from Deep Transformer</p><p>[10] An Efficient Transformer Decoder with Compressed Sub-layers</p><p>[11] <strong>Guiding Non-Autoregressive Neural Machine Translation Decoding with Reordering Information</strong></p><p>[12] <strong>DirectQE: Direct Pretraining for Machine Translation Quality Estimation</strong></p><p>[13] Multilingual Transfer Learning for QA Using Translation as Data Augmentation</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AAAI-2021&quot;&gt;&lt;a href=&quot;#AAAI-2021&quot; class=&quot;headerlink&quot; title=&quot;AAAI  2021&quot;&gt;&lt;/a&gt;AAAI  2021&lt;/h2&gt;&lt;p&gt;在 AAAI2021 上同样涌现了许多关于机器翻译任务的研究工作，几乎所有的工作
      
    
    </summary>
    
      <category term="NLP" scheme="http://yoursite.com/categories/NLP/"/>
    
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>Masked Non-Autoregressive Image Captioning</title>
    <link href="http://yoursite.com/2021/06/06/Masked-Non-Autoregressive-Image-Captioning/"/>
    <id>http://yoursite.com/2021/06/06/Masked-Non-Autoregressive-Image-Captioning/</id>
    <published>2021-06-06T06:53:49.000Z</published>
    <updated>2021-06-06T08:21:43.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>以 Non-Autoregressive 的方式来做 Image Captioning</p><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><ul><li><p>自回归的方式做生成任务存在的问题</p><p>自回归解码导致了一些问题，如连续的错误积累、生成缓慢、不恰当的语义和缺乏多样性。 </p><p><strong>顺序解码很容易从训练数据中 copy tokens 来提高语法准确性</strong>，这很容易造成语义错误，而且在图像字幕的生成方面缺乏多样性。</p></li><li><p>非自回归的方式</p><p>非自回归解码已被提出来解决神经机器翻译（NMT）的生成速度较慢的问题。但直接应用到多模态描述生成任务上不是很直接：由于对真实目标分布的间接建模，不可避免地引入了另一个问题，被称为 “多模态问题”。</p><p>多模态问题【网络】：一种特殊的<strong>问题</strong>，其中不存在唯一的全局解决方案。可以在搜索空间周围找到多个全局优化或一个具有多个局部优化（或峰值）的全局优化。即，一对多问题。</p><p>多模态问题【本文】：完全的条件独立会导致对真实目标分布的近似度低。complete conditional independence results in the poor approximation to the true target distribution。</p></li></ul><h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><p>本文提出 masked non-autoregressive decoding 来解决 自回归解码 和 非自回归解码 中存在的问题。</p><ul><li><p>训练阶段</p><p>对于输入句子，以几种 （K） 比例进行掩码。</p></li><li><p>在推理阶段</p><p>在推理过程中，从一个<strong>完全被掩盖</strong>的序列到一个<strong>完全没有被掩盖</strong>的序列，以一种合成的方式，分几个 （K） 阶段平行地生成字幕。</p></li></ul><p>实验证明，我们提出的模型可以更有效地保留语义内容，并可以生成更多样性的标题。</p><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p><img src="https://i.loli.net/2021/06/06/GagfcOSPqskTiEW.png" alt="image-20210606152813892"></p><h3 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h3><p>使用CNN提取的特征图，或者是 使用目标检测器检测得到的 object features.</p><h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><p>与传统的Tansformer 来做seq-to-seq 是一样的，只是移去了 decoder的 autoregressive mask ， 即decoder 中的每个token，是双向attention。</p><h3 id="Masked-non-autoregressive-decoding"><a href="#Masked-non-autoregressive-decoding" class="headerlink" title="Masked non-autoregressive decoding"></a>Masked non-autoregressive decoding</h3><p>如图1</p><p>训练阶段，以 K 种比例进行掩码，比如 K = [1, 0.6, 0.2],其中 k=1, 代表全部掩码</p><p>测试阶段，使用 K stage，从全部掩码到部分掩码，来一步一步的优化caption。</p><details><summary>细节-增强鲁邦性</summary>我们还以一定比例的随机词来替代 [MASK] token 或 ground-truth token。 在我们的实验中，由于标题的长度相对较短，我们只是在每个非完全屏蔽的输入序列中用一个随机的词替换一个词。 使用随机词可以增强标记的上下文表示，并通过在训练期间引入噪声标记来提高推理过程的稳健性，因为模型在推理的早期阶段很容易产生错误的标记。</details><h3 id="作者分析"><a href="#作者分析" class="headerlink" title="作者分析"></a>作者分析</h3><p>我们提供了更多的分析和讨论，关于模型在不同比例的掩蔽序列中所学习的内容，以及模型在推理过程中不同阶段的预测。 我们进一步讨论了自回归和屏蔽式非自回归解码之间的内在差异。</p><ul><li><p>在训练阶段</p><ul><li>掩码的比例大时，会输出视觉单词</li><li>掩码的比例小时，会对语法进行修正</li></ul></li><li><p>在测试阶段</p><p>在推理过程中，the masked non-autoregressive 解码过程很好地反映了模型在训练过程中所学习的内容。 在早期阶段，该模型倾向于在语言组织较差的图像中生成包含高频率（如 “a”、”on”）和突出的视觉线索（如物体、颜色名词和重要动词）的caption，而在后期阶段，该模型可以通过采用训练好的双向语言模型来选择最合适的词来连接子序列的两边，从而生成语义和语法上正确的标题。 如图1 </p></li><li><p>自回归和屏蔽式非自回归解码之间的内在差异</p><p>在推理过程中，自回归解码和掩码非自回归解码的区别在于掩码非自回归解码自然接近人类的语言生成。更具体地说，人类首先在大脑中生成视觉场景的关键词，然后选择其他词来连接不同的部分，并按照语言规则组成整个句子。这是一个<strong>先视觉再语言</strong>的生成过程，视觉信息奠定了字幕的基础，语言信息辅助以组合的方式而不是顺序的方式形成最终的字幕，这样会更好地保留有意义的语义信息。<strong>掩码非自回归解码一步生成整个句子，因此前面标记的质量不会显着影响后面的标记，这从根本上缓解了自回归解码中存在的顺序错误累积</strong>。相比之下，自回归解码是一个从左到右逐字的生成过程，因此后面步骤生成的标记在很大程度上取决于前面步骤的标记，一旦前面的标记不合适，就容易出现顺序错误累积。更糟糕的是，它只有一次机会生成整个标题，而无法调整前面不适当的标记。因此，自回归解码在保持流畅性方面相当不错，但难以准确说出图像丰富的显着语义内容。</p></li></ul><h2 id="Inference-rules"><a href="#Inference-rules" class="headerlink" title="Inference rules"></a>Inference rules</h2><ul><li><p>推理阶段每个 stage, 如何确定mask 哪些token？或者保留哪些token ?</p><p><strong>保留信息量最大的 token</strong> 并屏蔽每个阶段生成的字幕中的其他位置以生成新的屏蔽输入序列至关重要。</p><p>在本文中，我们采用了一种直接的方法。在这种方法中，在这种方法中，那些不包括在高频率的标记集中的 tokens (tf-idf的思想) ，以及具有高概率且与迄今所选标记不重复的 tokens ，被指定为高度优先保留的 tokens 。例如，在图 <a href="https://www.arxiv-vanity.com/papers/1906.00717/#S3.F1" target="_blank" rel="noopener">1中</a>，我们保留了第一阶段输出序列的 “二”、“鸭子”、“游泳” 和“水”。此外，对最后阶段生成的 caption 进行处理，选择与之前选择的 tokens 不重复的 tokens 。 </p></li><li><p>推理阶段，caption的长度是如何确定的？</p><p>关于推理过程中 length of caption 的确定, 我们首先计算训练数据中的长度的分布情况，然后从这个分布中选择一个随机的长度 T 作为标题。 随后。由T个 [MASK] token 组成的序列被送入模型，这样，一个完整的标题就可以最终被解码。 另一个选择是，我们直接为所有图像设置一个固定的序列长度。 该模型将根据长度自动强制生成粗略或精细的标题，但具有类似的语义信息。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h2&gt;&lt;p&gt;以 Non-Autoregressive 的方式来做 Image Captioning&lt;/p&gt;
&lt;h2 id=&quot;存在的问题&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="cross-modal" scheme="http://yoursite.com/categories/cross-modal/"/>
    
    
      <category term="cross-modal" scheme="http://yoursite.com/tags/cross-modal/"/>
    
  </entry>
  
  <entry>
    <title>Mask-Predict: Parallel Decoding of Conditional Masked Language Models</title>
    <link href="http://yoursite.com/2021/06/06/Mask-Predict-Parallel-Decoding-of-Conditional-Masked-Language-Models/"/>
    <id>http://yoursite.com/2021/06/06/Mask-Predict-Parallel-Decoding-of-Conditional-Masked-Language-Models/</id>
    <published>2021-06-06T06:38:51.000Z</published>
    <updated>2021-06-06T06:45:31.307Z</updated>
    
    <content type="html"><![CDATA[<p>Facebook发表在EMNLP 2019上的工作</p><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>机器翻译</p><h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><p>非自回归的生成方式</p><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p>这篇文章将masked language model和iterative refinement进行了结合。并提出了更精确的解码方法。</p><p>具体来说，在训练时，这篇文章采用了和masked language model一样的设定。即，随机mask掉目标语句中的一些单词作为decoder input，mask的策略也和Bert中的一致。而decoder output则是这些位置上被mask掉的原始单词。其中，与Bert对每个句子固定mask掉15%的单词不同的是，这篇文章中被mask单词的数目是在从1到句子长度的范围中随机选取的。这样做的好处会在decoding时显现出来。</p><p><img src="https://i.loli.net/2021/06/06/bBgAcQlLFVSt6Es.jpg" alt="img"></p><p>图二：Mask-Predict 解码示意图</p><p>在预测时，这篇文章提出了基于mask and predict的解码方法，是文章的主要贡献。其实在masked language model这个框架下，解码方法是水到渠成的，即每次迭代时，都在当前翻译结果上mask掉一些词，再预测这些词即可。这里有几个点需要特别考虑。一是如何决定mask掉哪些词。文中给出的解决方法是选取top k个解码时置信度最小的词，把他们mask掉再重新预测。二是如何确定mask掉多少个词，也就是如何选取k。文中给出了基于迭代次数递减的策略，即<strong>在第一次解码时，将所有位置都置为[MASK]</strong>，同时预测所有位置的词。<strong>在之后解码迭代中，按照随迭代次数线性衰减的方式确定需要mask的单词个数</strong>：</p><p>$n=N \cdot \frac{T-t}{T}$</p><p>其中N是目标语句的长度，T和t则分别是总的迭代次数和当前迭代次数。上图中展示了解码过程的一个例子。</p><p>上面提到对每个句子，训练时每个epoch确定被mask单词数目时都是随机从 [1，句子长度] 中选取得到的。由于在解码时，被mask单词的个数是线性递减的，即会从 [句子长度，1] 依次递减。因此，训练时这样选取被mask单词的数目可以增加模型的capacity，让模型能处理任意个单词被mask掉时的情况，从而更符合解码时的策略，减少bias并达到更好的效果。</p><p>在确定目标语句的长度时，这篇文章采用了与上篇文章相同的方法，即通过encoder output来预测目标语句的长度，和golden目标语句的长度作为额外的loss function单独训练。</p><h2 id="Results"><a href="#Results" class="headerlink" title="Results"></a><strong>Results</strong></h2><p><img src="https://i.loli.net/2021/06/06/xongXjtwZciSe42.jpg" alt="img" style="zoom:50%;"></p><p>从上表中可以看到，这篇文章在WMT14 En-De和WMT16 En-Ro上均达到了SOTA。但有一点存疑的是，由于文章中也采用了knowledge distillation来训练non-autoregressive模型，而其采用的autoregressive teacher模型均为比较强的模型（28.6 on WMT14 En-De and 34.28 on WMT16 En-Ro），没有控制变量采用和baseline相同效果的autoregressive teacher。而一般来说，teacher越强训练出的non-autoregressive模型也会越强，因此<strong>这篇文章良好的效果应该也有一部分是得益于其选择了较强的teacher</strong>。</p><p>文中也做了在WMT17 En-Zh上的实验，以及对迭代次数和mutiple length candidates的分析，这里就不一一赘述了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Iterative refinement无疑是一个改善 $O(1)$非自回归模型的良好方向，在增加了有限的复杂度（通常是 $O(10)$)的代价下，非自回归模型的翻译质量得到了大幅提高。在这个方向中， Mask-Predict这篇文章给出了一个优良的解码范例，即每次迭代并不会预测所有的单词，而是预测置信度较低的数个单词。</p><p>但这样的解码范例也可能并不是最优的。因为模型给出的概率上的置信度有时候并不会反应真正的翻译质量。如何证明/设计与翻译质量挂钩的解码策略也是一个值得思考的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Facebook发表在EMNLP 2019上的工作&lt;/p&gt;
&lt;h2 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h2&gt;&lt;p&gt;机器翻译&lt;/p&gt;
&lt;h2 id=&quot;本文的点&quot;&gt;&lt;a href=&quot;#本文的点
      
    
    </summary>
    
      <category term="NLP" scheme="http://yoursite.com/categories/NLP/"/>
    
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>Improving Neural Machine Translation with Soft Template Prediction</title>
    <link href="http://yoursite.com/2021/06/06/Improving-Neural-Machine-Translation-with-Soft-Template-Prediction/"/>
    <id>http://yoursite.com/2021/06/06/Improving-Neural-Machine-Translation-with-Soft-Template-Prediction/</id>
    <published>2021-06-06T01:51:58.000Z</published>
    <updated>2021-06-06T04:11:11.576Z</updated>
    
    <content type="html"><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>机器翻译</p><h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><p>受到人类翻译过程和其他领域基于模板和基于语法的方法启发，微软亚洲研究院提出了一种使用<strong>从语法树结构中提取的模板</strong>作为<strong>软目标模板</strong>来指导翻译过程的方法 ST-NMT。</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>尽管近年来神经机器翻译（NMT）取得了长足的进步，但大多数神经机器翻译模型直接从源文本生成翻译。受到人类翻译过程和其他领域基于模板和基于语法的方法的成功启发，我们提出了一种使用从语法树结构中提取的模板作为软目标模板来指导翻译过程的方法。为了学习目标句子的句法结构，我们采用语法分析树来生成候选模板，并将模板信息融合到编码器-解码器框架中，同时利用模板和源文本生成翻译。实验表明，我们的模型在四个数据集上明显优于基线模型，证明了软目标模板的有效性。</p><h2 id="软模板预测"><a href="#软模板预测" class="headerlink" title="软模板预测"></a>软模板预测</h2><p>近年来，神经机器翻译取得了巨大的进步，但常规的神经机器翻译模型一般直接把源语言文本翻译到目标语言文本。但实际上，我们知道人类在翻译一句话时通常是先对目标文本的句型或者结构有一个大致的想法，然后再将源语言文本翻译成为目标语言文本，并不是直接逐词进行翻译。</p><p>通常我们在进行造句训练的时候，最开始老师会教给我们一些句型，例如 “sb. like doing sth; There be…” 等，然后让我们做练习。下图是一个中英翻译训练教材的内容，要求根据以下句型将中文翻译到英文。</p><p><img src="https://i.loli.net/2021/06/06/ipqb2FWnoZxsufz.png" alt="img" style="zoom:50%;"></p><p><em>图1：中英翻译训练教材内容</em></p><p>受到人类翻译过程的启示，我们提出了使用从句法分析树提取模板作为软目标语言模板来指导翻译过程的方法。为了学习目标句子的句法结构，我们采用句法分析树来生成候选模板。如图2所示，我们首先根据源语言文本预测将要用到的目标语言的模板，这里 “我喜欢打篮球”，很容易想到 “sb. like doing sth” 这个句型，随后我们根据源语言和模板来生成翻译。</p><p><img src="https://i.loli.net/2021/06/06/UnaNz1vmtAidhTQ.png" alt="img" style="zoom:50%;"></p><p><em>图2：使用软目标模板指导翻译过程示例</em></p><p>基于这一核心思想以及模板方法在机器摘要、问答和其他文本上取得的成功。我们假设目标句子的候选模板可以指导句子翻译过程。我们将这些从句法分析树中提取的模板作为软模板，由 S, NP, VP 这些具有句子结构信息和目标语言组成。这里模板是“软 (soft) ”的，因为我们<strong>并不强制要求生成的目标语言翻译一定是完全基于模板来生成</strong>，这里的模板仅仅是提供一种参考来对翻译提供一定的帮助。</p><p>为了更有效地使用软模板，我们引入了基于目标语言软模板的神经机器翻译模型 (Soft Template-based NMT，ST-NMT)，它可以使用源文本和软模板来预测最终的翻译。我们的方法可以分为两个阶段。在第一阶段，通过使用源文本和从句法分析树中提取的模板，训练一个标准的 Transformer 模型来专门预测软目标模板。在第二阶段，我们使用两种编码器，包括软目标模板编码器和源语言编码器，以对源文本和模板进行编码并生成最终翻译。</p><h2 id="目标软模板预测"><a href="#目标软模板预测" class="headerlink" title="目标软模板预测"></a>目标软模板预测</h2><p><img src="https://i.loli.net/2021/06/06/MSToYB93vDrqCwz.png" alt="img" style="zoom:50%;"></p><p><em>图3：从分析树中抽取模板</em></p><p>在此过程中，通过使用源语言 S 和模板 T 数据，我们对 P(T|X) 建模，使得我们能够根据源语言对模板进行预测。为了构造源语言-模板数据集，我们使用句法分析树来解析目标语言文本并获得树形结构。然后，我们裁剪超过一定深度的节点，并将裁剪后的子树按照原有顺序还原回去得到模板数据。通过这些操作，我们获得了源语言-模板平行训练数据，并训练了 Transformer 模型 P(T|X) 来预测软目标模板。</p><p>语法解析树可以显示整个句子的结构和语法信息，利用语法来区分终端（terminal nodes）和非终端节点（non-terminal nodes）。更确切地说，非终端节点由属于非终端节点集合 S，而终端节点属于目标语言节点集合 V。S={V, VP, NP, …, ASBR} 等代表语法成分的标记和 V={There, are, …, people} 包含目标语言单词。如 图3 所示，句子“有人在奔跑”通过语法解析树生成树形结构。在这种情况下，非终端节点集合S0={S, NP, VP, EX, VBP, NP, DT, NNS, VBG} 和终端节点集合 V0={There, are, some, people, running}。我们的模板 T={t1, t2, t3, t4} 是有序序列，由终端节点和非终端节点组成。在这种情况下，t1=There, t2=are, t3=VP, t4=NP。我们的模板是提取特定深度的子树，并使用位于子树的叶节上的终端和非终端节点来生成模板。</p><p>为了预测软目标模板，我们根据源文本和提取的模板的训练数据来训练一个Transformer 模型。Transformer 模型读取源文本，并使用束搜索预测软目标模板。然后，我们选择束搜索的前 K 个结果作为模板。</p><p><strong>选择子树的深度是一个权衡。在图3中，当深度等于1是一种特殊的情况，此时模板仅具有一个符号 S。模板 S 无法提供任何有用的信息。另一个特殊情况是当深度大于6时，“There are some people running” 此时模板只有终端节点。该模板仅包含目标语言单词，不能提供任何其他信息。而当深度等于4时，模板为 “There are VP NP”。该模板包含句子句法和结构信息，适用于我们的方法。</strong></p><p>使用 Transformer 模型 P(T|X)，我们需要构造伪训练数据(源语言文本、目标语言文本、目标软模板)，而不是通过语法分析树直接提取的模板。给定源文本 X，我们使用 P(T|X) 通过束搜索来生成排名靠前的目标语言软模板 T。最后，我们得到三元组训练数据 (源语言文本、目标语言文本、软模板）为下一阶段做准备。</p><h2 id="ST-NMT模型"><a href="#ST-NMT模型" class="headerlink" title="ST-NMT模型"></a>ST-NMT模型</h2><p>我们的模型首先通过源语言 Transformer 编码器以读取源语言序列 X=(x1, x2, x3, …, xn)并生成模板序列 T=(t1, t2, t3, …, tm) 由模板 Transformer 解码器提供。如图3所示，我们的模型使用源语言 Transformer 编码器和模板 Transformer 编码器，分别对源语言序列 X 和模板序列 T 进行编码，最终解码器生成最终翻译。我们的方法主要包括两个阶段：（1）训练数据由基于选区的解析树构造。然后，我们采用标准的 Transformer 将源文本转换为下一代软目标模板。（2）基于源文本和预测的软目标模板，我们使用两个编码器分别将两个序列编码为隐藏状态，并使用目标语言解码器生成最终翻译。</p><p><img src="https://i.loli.net/2021/06/06/Lz1C5HU7uFwle6K.png" alt="image-20210606102157632"></p><p><em>图4：ST-NMT 模型</em></p><p>给定三元组训练数据（源语言文本，目标语言文本，软模板）后，我们使用源语言文本和软模板生成目标语言文本如下公式。源语言 Transformer 编码器和软模板Transformer 编码器将输入序列 X 和由目标语言单词和非终端节点组成的模板 T 映射到隐层向量。然后，与两个编码器交互的 Transformer 解码器生成最终翻译 Y，即：</p><p><img src="https://i.loli.net/2021/06/06/qFu6TDtBbhQOXnf.png" alt="image-20210606102328094" style="zoom: 33%;"></p><p>基于源语言编码器隐藏层状态和软模板编码器隐藏层状态，目标语言 Transformer 解码器使用编码器-解码器多头注意共同使用源语言和模板信息来生成最终翻译 Y。此外，目标序列解码器使用两组注意力机制参数用于不同的编码器。解码器分别使用源语句上下文 X=(x1, …, xm)和目标模板上下文 T=(t1, …, tn)，然后我们的模型通过关注源上下文和模板上下文获得两个隐藏状态,在这里，我们使用门控单元融合了包含源语言信息的隐藏层状态和包含模板信息的隐藏层状态，如下所示：</p><p><img src="https://i.loli.net/2021/06/06/2omSktuZxNEUYeC.png" alt="image-20210606111455578" style="zoom:50%;"></p><p><img src="https://i.loli.net/2021/06/06/F4RvzfdciHe3Jr8.png" alt="image-20210606111502794" style="zoom:50%;"></p><p>与常规 NMT 相似，为了使模型能够预测目标序列，我们使用最大似然估计来更新模型参数。当我们在不使用模板 Transformer 编码器的情况下训练 P(Y|X) 时，我们仅需要优化以下损失函数:</p><p><img src="https://i.loli.net/2021/06/06/BZDHSQC19LhXlOA.png" alt="image-20210606120505997" style="zoom:50%;"></p><p>我们使用模板 Transformer 编码器训练 P(Y|X,T) 时，损失函数可以通过以下公式计算：</p><p><img src="https://i.loli.net/2021/06/06/kvnLlAHoF42XbcG.png" alt="image-20210606120523147" style="zoom:50%;"></p><p>在实践中，我们发现优化这两个目标可以使得模型更易于训练避免收到模板中噪声的干扰，并获得较高的 BLEU 分数，因为存在一些影响翻译质量的低质量模板。<strong>通过同时优化两个目标，我们可以减少某些低质量模板的影响并提高模型的稳定性。</strong>为了平衡这两个目标，我们的模型在两个目标上同时进行了迭代训练，如下所示：</p><p><img src="https://i.loli.net/2021/06/06/BrkEVRDWHZen41L.png" alt="image-20210606120604504" style="zoom:50%;"></p><h2 id="实验与分析"><a href="#实验与分析" class="headerlink" title="实验与分析"></a>实验与分析</h2><p>为了证明该方法的有效性，我们在多个数据集和多个语种进行了实验，包括 IWSLT14 德语-英语翻译任务，WMT14 英语-德语翻译任务，LDC 中英翻译任务和 ASPEC 日中翻译任务。实验表明，与基线模型相比，我们的方法取得了更好的结果，这表明软目标模板可以有效地指导翻译过程并提供积极的影响。同时我们的方法可用于不同规模、不同语种、不同领域的数据集。</p><p><img src="https://i.loli.net/2021/06/06/EfX8xaJeFYLzpDb.png" alt="image-20210606120732113" style="zoom:50%;"></p><p><em>表1：LDC 中英翻译任务结果</em></p><p><img src="https://i.loli.net/2021/06/06/19RGWj5xsK7HzXV.png" alt="image-20210606120755429" style="zoom: 50%;"></p><p><em>表2：WMT14 英语-德语翻译任务结果</em></p><p><img src="https://i.loli.net/2021/06/06/2HjICRYAgV9db5L.png" alt="image-20210606120824797" style="zoom:50%;"></p><p><em>表3：IWSLT14 德语-英语翻译任务结果</em></p><p><img src="https://i.loli.net/2021/06/06/e4hJ8gaKn3xmXwz.png" alt="image-20210606120844581" style="zoom:50%;"></p><p><em>表4：ASPEC 日中翻译任务结果</em></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这项工作中，我们提出了一种利用源文本和软模板生成翻译的机器翻译模型。我们的方法可以从子树中提取模板，该子树是从语法分析树的特定深度得到的。然后，我们使用 Transformer 模型来预测源文本的软目标模板。进一步，我们结合了源文本和模板信息来指导翻译过程。我们将软模板神经机器翻译模型（ST-NMT）与其他基线模型在多个数据集上进行比较。实验结果表明，ST-NMT 可以显著提高翻译性能。</p><h2 id="yaya"><a href="#yaya" class="headerlink" title="yaya"></a>yaya</h2><ul><li>其实也可以构造成 hard target, 强硬使其输出为对应的span</li><li>但是如果这样的话，soft target 是作为辅助信息，影响力 (&gt;=0)。如果使用强硬的，则影响力可能为&lt;0</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h2&gt;&lt;p&gt;机器翻译&lt;/p&gt;
&lt;h2 id=&quot;本文的点&quot;&gt;&lt;a href=&quot;#本文的点&quot; class=&quot;headerlink&quot; title=&quot;本文的点&quot;
      
    
    </summary>
    
      <category term="NLP" scheme="http://yoursite.com/categories/NLP/"/>
    
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>Frozen in Time: A Joint Video and Image Encoder for End-to-End Retrieval</title>
    <link href="http://yoursite.com/2021/05/29/Frozen-in-Time-A-Joint-Video-and-Image-Encoder-for-End-to-End-Retrieval/"/>
    <id>http://yoursite.com/2021/05/29/Frozen-in-Time-A-Joint-Video-and-Image-Encoder-for-End-to-End-Retrieval/</id>
    <published>2021-05-29T02:02:01.000Z</published>
    <updated>2021-05-29T02:33:06.447Z</updated>
    
    <content type="html"><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p> text-to-video-retrieval</p><h2 id="当前存在的问题"><a href="#当前存在的问题" class="headerlink" title="当前存在的问题"></a>当前存在的问题</h2><ul><li>这一领域的挑战包括: (1) 视觉结构的设计和 (2) 训练数据的性质，因为现有的大规模视频-文本训练数据集，如HowTo100M，是有噪声的，因此只有通过大量的计算才能实现有竞争力的性能。</li></ul><h2 id="本文的点"><a href="#本文的点" class="headerlink" title="本文的点"></a>本文的点</h2><ul><li>【训练使用的数据集】针对上述提到的问题，本文提出了一个端到端的可训练模型，该模型利用大规模的图像描述和视频描述数据集。该模型可以灵活的在图像-文本，视频-文本数据集上进行训练，可以是单独的方式或者是组合的方式。</li><li>【模型结构】本文提出的模型是对最近的ViT和Timesformer架构的改编和扩展，由空间和时间上的 attention 组成。</li><li>【训练方案】使用课程学习的训练方式（由易到难），开始时将图像视为视频的 “冻结 “快照，然后在视频数据集上训练时逐渐学会关注越来越多的时域上下文。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h2&gt;&lt;p&gt; text-to-video-retrieval&lt;/p&gt;
&lt;h2 id=&quot;当前存在的问题&quot;&gt;&lt;a href=&quot;#当前存在的问题&quot; class
      
    
    </summary>
    
      <category term="cross-modal" scheme="http://yoursite.com/categories/cross-modal/"/>
    
    
      <category term="cross-modal" scheme="http://yoursite.com/tags/cross-modal/"/>
    
  </entry>
  
  <entry>
    <title>[T5] Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer</title>
    <link href="http://yoursite.com/2021/04/28/T5-Exploring-the-Limits-of-Transfer-Learning-with-a-Unified-Text-to-Text-Transformer/"/>
    <id>http://yoursite.com/2021/04/28/T5-Exploring-the-Limits-of-Transfer-Learning-with-a-Unified-Text-to-Text-Transformer/</id>
    <published>2021-04-28T11:38:01.000Z</published>
    <updated>2021-06-02T02:41:50.709Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<a href="https://zhuanlan.zhihu.com/p/88438851" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/88438851</a></p><p>对于 T5 这篇论文，<em>Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer</em>，无疑也是类似的论文。它的意义不在烧了多少钱，也不在屠了多少榜（砸钱就能砸出来），其中 idea 创新也不大，它最重要作用是给<strong style="color:red;"><strong>整个 NLP 预训练模型领域提供了一个通用框架</strong></strong>，把所有任务都转化成一种形式，正如论文里所说的</p><blockquote><p>introducing a unified framework that converts every language problem into a text-to-text format.</p></blockquote><p>之后未来做 NLP 实验时，可能就不再是自己怎么调一些模型了，而是无论什么任务，直接拿来一个超大预训练模型，然后<strong style="color:red;"><strong>主要工作就变成了怎么把任务转换成合适的文本输入输出</strong></strong>，于是我们就成了带引号的”数据科学家“。而且可以用于多种任务，而模型对这些任务的区分只是根据你构建的输入输出形式，其实这让我想起 Jeff Dean 在某次谈话中谈到的谷歌未来方向，想做一个超级模型，什么任务都能直接处理，而它内部可以是稀疏的，或者可以局部 Distill，来对单独任务进行处理。</p><p>关于论文，作者们做了很多实验。将近七十个实验，这也是大家吐槽财大气粗的原因，太有冲击力了，小家小业的话估计跑里面个小实验就够呛了。</p><p>正因为如此多实验，所以才对预训练模型中的大量技巧获得了一个较公平的比对和分析，但这也使得整篇论文长度巨长，读起来头晕。不是 idea 的冲击，而都是些琐碎细节，看了几大段后发现，还是看图表一目了然。</p><p>这里就简单介绍一下里面做了哪些实验，之后各取所需回看论文。</p><h2 id="Why-Text-to-Text？"><a href="#Why-Text-to-Text？" class="headerlink" title="Why Text-to-Text？"></a>Why Text-to-Text？</h2><p>首先为什么叫 T5 模型，因为是 <strong>Transfer Text-to-Text Transformer</strong> 的简写，和 XLNet 一样也不在芝麻街玩了，也有说法是吐槽谷歌 <strong>T5 Level</strong>（高级软件工程师）。</p><p>Transfer 来自 Transfer Learning，预训练模型大体在这范畴，Transformer 也不必多说，那么 Text-to-Text 是什么呢。那就是作者在这提出的一个统一框架，靠着大力出奇迹，<strong>将所有 NLP 任务都转化成 Text-to-Text （文本到文本）任务</strong>。</p><p><img src="https://i.loli.net/2021/04/28/zSwycrjd2qkPGas.png" alt="image-20210428195223812"></p><p>举几个例子就明白了，比如英德翻译，只需将训练数据集的输入部分前加上“translate English to German（给我从英语翻译成德语）” 就行。假设需要翻译”That is good”，那么先转换成 “translate English to German：That is good.” 输入模型，之后就可以直接输出德语翻译 “Das ist gut.”</p><p>再比如情感分类任务，输入”sentiment：This movie is terrible!”，前面直接加上 “sentiment：”，然后就能输出结果“negative（负面）”。</p><p>最神奇的是，对于需要输出连续值的 STS-B（文本语义相似度任务），居然也是直接输出文本，而不是加个连续值输出头。以每 0.2 为间隔，从 1 到 5 分之间分成 21 个值作为输出分类任务。比如上图中，输出 3.8 其实不是数值，而是一串文本，之所以能进行这样的操作，应该完全赖于 T5 模型强大的容量。</p><p>通过这样的方式就能将 NLP 任务都转换成 Text-to-Text 形式，也就可以<strong>用同样的模型，同样的损失函数，同样的训练过程，同样的解码过程来完成所有 NLP 任务</strong>。其实这个思想之前 GPT2 论文里有提，上斯坦福 cs224n 时 Socher 讲的 The Natural Language Decathlon 也有提。</p><h2 id="Data：C4-（Bomb-）"><a href="#Data：C4-（Bomb-）" class="headerlink" title="Data：C4 （Bomb!）"></a>Data：C4 （Bomb!）</h2><p>作者从 Common Crawl（一个公开的网页存档数据集，每个月大概抓取 20TB 文本数据） 里清出了 750 GB 的训练数据，然后取名为 ” Colossal Clean Crawled Corpus （超大型干净爬取数据）“，简称 C4，论作者取名之恶趣味。</p><p>大概清理过程如下：</p><ul><li>只保留结尾是正常符号的行；</li><li>删除任何包含不好的词的页面，具体词表参考<strong><a href="https://link.zhihu.com/?target=https%3A//github.com/LDNOOBW/List-of-Dirty-Naughty-Obscene-and-Otherwise-Bad-Words" target="_blank" rel="noopener">List-of-Dirty-Naughty-Obscene-and-Otherwise-Bad-Words</a></strong>库（笔者按：宝藏库，到里面转了一圈，看了看熟悉的几门语言，瞬间涨了不少新姿势 ）；</li><li>包含 Javascript 词的行全去掉；</li><li>包含编程语言中常用大括号的页面；</li><li>任何包含”lorem ipsum（用于排版测试）“的页面；</li><li>连续三句话重复出现情况，保留一个。</li></ul><h2 id="Architecture：The-Best-One"><a href="#Architecture：The-Best-One" class="headerlink" title="Architecture：The Best One"></a><strong>Architecture：The Best One</strong></h2><p>首先作者们先对预训练模型中的多种模型架构（Transformer）进行了比对，最主要的模型架构可以分成下面三种。</p><p><img src="C:\Users\shiyaya\AppData\Roaming\Typora\typora-user-images\image-20210428195326843.png" alt="image-20210428195326843"></p><p>第一种，<strong>Encoder-Decoder 型</strong>，即 Seq2Seq 常用模型，分成 Encoder 和 Decoder 两部分，对于 Encoder 部分，输入可以看到全体，之后结果输给 Decoder，而 Decoder 因为输出方式只能看到之前的。此架构代表是 MASS（今年WMT的胜者），而 BERT 可以看作是其中 Encoder 部分。</p><p>第二种， 相当于上面的 <strong>Decoder 部分</strong>，当前时间步只能看到之前时间步信息。典型代表是 GPT2 还有最近 CTRL 这样的。</p><p>第三种，<strong>Prefix LM（Language Model） 型</strong>，可看作是上面 Encoder 和 Decoder 的融合体，一部分如 Encoder 一样能看到全体信息，一部分如 Decoder 一样只能看到过去信息。最近开源的 UniLM 便是此结构。</p><p>上面这些模型架构都是 Transformer 构成，之所以有这些变换，主要是<strong>对其中注意力机制的 Mask 操作</strong>。</p><p><img src="C:\Users\shiyaya\AppData\Roaming\Typora\typora-user-images\image-20210428195656637.png" alt="image-20210428195656637"></p><p>通过实验作者们发现，在提出的这个 Text-to-Text 架构中，Encoder-Decoder 模型效果最好。于是乎，就把它定为 T5 模型，因此<strong>所谓的 T5 模型其实就是个 Transformer 的 Encoder-Decoder 模型</strong>。</p><p>之后是对预训练目标的大范围探索，具体做了哪些实验，下面这张图就能一目了然。</p><p><img src="https://i.loli.net/2021/04/28/HGA86geR3s5JoOl.png" alt="image-20210428200712939"></p><p>总共从四方面来进行比较。</p><p>第一个方面，<strong>高层次方法（自监督的预训练方法）对比</strong>，总共三种方式。</p><ol><li><strong>语言模型式</strong>，就是 GPT-2 那种方式，从左到右预测；</li><li><strong>BERT-style 式</strong>，就是像 BERT 一样将一部分给破坏掉，然后还原出来；</li><li><strong>Deshuffling （顺序还原）式</strong>，就是将文本打乱，然后还原出来。</li></ol><p><img src="https://i.loli.net/2021/04/28/La7uURigVxpHzdG.png" alt="image-20210428200943309"></p><p>其中发现 Bert-style 最好，进入下一轮。</p><p>第二方面，对文本一部分进行<strong>破坏时的策略</strong>，也分三种方法。</p><ol><li><strong>Mask 法</strong>，如现在大多模型的做法，将被破坏 token 换成特殊符如 [M]；</li><li><strong style="color:red;"><strong>replace span（小段替换）法</strong>，可以把它当作是把上面 Mask 法中相邻 [M] 都合成了一个特殊符，每一小段替换一个特殊符，提高计算效率；</strong></li><li><strong>Drop 法</strong>，没有替换操作，直接随机丢弃一些字符。</li></ol><p><img src="https://i.loli.net/2021/04/28/swF3Ab4uBetv1Nf.png" alt="image-20210428201451717"></p><p>此轮获胜的是 <strong>Replace Span 法</strong>（如下图），类似做法如 SpanBERT 也证明了有效性。</p><p><img src="https://i.loli.net/2021/04/28/9gAnaOWSlmMbxCF.png" alt="image-20210428195311177"></p><p>当当当，进入下一轮。</p><p>第三方面，到底该<strong>对文本百分之多少进行破坏</strong>呢，挑了 4 个值，10%，15%，25%，50%，最后发现 BERT 的 <strong>15%</strong> 就很 ok了。这时不得不感叹 BERT 作者 Devlin 这个技术老司机直觉的厉害。</p><p>接着进入更细节，第四方面，因为 Replace Span 需要决定<strong>对大概多长的小段进行破坏</strong>，于是对不同长度进行探索，2，3，5，10 这四个值，最后发现 <strong>3</strong> 结果最好。</p><p>终于获得了完整的 T5 模型，还有它的训练方法。</p><p><img src="C:\Users\shiyaya\AppData\Roaming\Typora\typora-user-images\image-20210428201927674.png" alt="image-20210428201927674"></p><ul><li>Transformer Encoder-Decoder 模型；</li><li>BERT-style 式的破坏方法；</li><li>Replace Span 的破坏策略；</li><li>15 %的破坏比；</li><li>3 的破坏时小段长度。</li></ul><p>到此基本上 T5 预训练就大致说完了，之后是些细碎探索。</p><h2 id="Datasets"><a href="#Datasets" class="headerlink" title="Datasets"></a>Datasets</h2><p>接着作者们拿着 C4 数据集做了各种实验，比如说从里面分出各种类型的数据集，单独训练 T5 模型，之后看在下游任务的表现，发现一些情况<strong>领域内的预训练数据可以增强下游任务</strong>（想当然的）。而 C4 完整数据集因为数据太多太杂，可能反而不如这种领域内较少数据集。</p><p>还有从 C4 中抽出不同量数据做实验，发现<strong>数据少时，模型会记住数据所以之后表现会比较差</strong>（这个也是想当然）。</p><p><img src="https://i.loli.net/2021/04/28/8bgrwBkAYaWQTJp.png" alt="image-20210428202002738" style="zoom:67%;"></p><h2 id="Training：Multi-Task-Learning"><a href="#Training：Multi-Task-Learning" class="headerlink" title="Training：Multi-Task Learning"></a><strong>Training：Multi-Task Learning</strong></h2><p>作者们之后又针对 MTDNN 给 T5 做了一系列类似训练，在一堆监督和非监督数据上进行预训练。</p><p>结果发现，只要<strong>混合训练比例调得OK，和前面说的非监督预训练性能差不多</strong>。</p><h2 id="Scaling：bigger-is-better"><a href="#Scaling：bigger-is-better" class="headerlink" title="Scaling：bigger is better?"></a><strong>Scaling：bigger is better?</strong></h2><p>接着又做了当放大模型某方面规模的相关实验，分别是增大模型，增大数据，还有在一定资源限制下的集成。</p><p>结论是，当<strong>这些因素放大时对性能都有提高，但其中大模型是最必要的</strong>。</p><h2 id="Models"><a href="#Models" class="headerlink" title="Models"></a><strong>Models</strong></h2><p>最后就是结合上面所有实验结果，训练了不同规模几个模型，由小到大：</p><ul><li>Small，Encoder 和 Decoder 都只有 6 层，隐维度 512，8 头；</li><li>Base，相当于 Encoder 和 Decoder 都用 BERT-base；</li><li>Large，Encoder 和 Decoder 都用 BERT-large 设置，除了层数只用 12 层；</li><li>3B（Billion）和11B，层数都用 24 层，不同的是其中头数量和前向层的维度。</li></ul><p>11B 的模型最后在 GLUE，SuperGLUE，SQuAD，还有 CNN/DM 上取得了 SOTA，而 WMT 则没有。看了性能表之后，我猜想之所以会有 3B 和 11B 模型出现，主要是为了刷榜。看表就能发现。</p><p><img src="https://i.loli.net/2021/04/28/JF4X6LzSgpxho93.jpg" alt="img"></p><p>比如说 GLUE，到 3B 时效果还并不是 SOTA，大概和 RoBERTa 评分差不多都是 88.5，而把模型加到 11B 才打破 ALBERT 的记录。然后其他实验结果也都差不多，3B 时还都不是 SOTA，而是靠 11B 硬拉上去的。除了 WMT 翻译任务，可能感觉差距太大，要拿 SOTA 代价过大，所以就没有再往上提。根据这几个模型的对比，可以发现<strong>即使是容量提到 11B，性能提升的间隔还是没有变缓</strong>，<strong>因此我认为再往上加容量还是有提升空间</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/88438851&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/88438851&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于 T5 
      
    
    </summary>
    
      <category term="NLP" scheme="http://yoursite.com/categories/NLP/"/>
    
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
  </entry>
  
</feed>
